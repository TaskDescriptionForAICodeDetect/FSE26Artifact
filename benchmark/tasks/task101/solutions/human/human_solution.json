[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc()\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tvector<int> cmp(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tbool f = false;\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\t\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t\tf = true;\n\t\t}\n\t\tassert(f);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>> sccgraph = scc();\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (indeg[cmp[i]] == 0) res++;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-10;\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      if (     cross(a[in[0]]-a[in[1]],a[in[2]]-a[in[1]]) >=0)\n\tassert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])>=0);\n      else assert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])<=0);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n      rep(k,tri[j].size()){\n\tif (is_in(tri[i],tri[j][k])){\n\t  assert(false);\n\t  inedge[i].pb(j);\n\t  redge[j].pb(i);\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n\n\n    //rep(i,n){rep(j,sq[i].size())cout<< sq[i][j];cout << endl;}\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-3;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nint V;\nvector<vector<int> > G,rG;\nvector<int> vs;\nbool used[100];\nint cmp[100];\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]){\n      dfs(G[v][i]);\n    }\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]){\n      rdfs(rG[v][i],k);\n    }\n  }\n}\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[2])>eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    G=rG=vector<vector<int> >(n);\n    vs.clear();\n    bool e[100][100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<-eps;\n\t      e[i][j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    e[i][j]|=!f;\n\t    if(e[i][j]){\n\t      G[i].push_back(j);\n\t      rG[j].push_back(i);\n\t    }\n\t  }\n\t}\n      }\n    }\n    V=n;\n    fill(begin(used),end(used),false);\n    for(int v=0;v<V;v++){\n      if(!used[v]){\n\tdfs(v);\n      }\n    }\n    fill(begin(used),end(used),false);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]]){\n\trdfs(vs[i],k++);\n      }\n    }\n    bool in[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(e[i][j]&&cmp[i]!=cmp[j]){\n\t  in[cmp[j]]=true;\n\t}\n      }\n    }\n    cout<<count(in,in+k,false)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-6;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\t/*for (int i = 0; i < g.size(); i++){\n\t\tSegment s(curr(g, i), next(g, i));\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(s, h[j]) < 0.01){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tSegment s(curr(h, i), next(h, i));\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(s, g[j]) < 0.01){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(norm(b - a), norm(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tVector a = tri[i][1] - tri[i][0];\n\t\tVector nv = tri[i][0] + (a / 2.0);\n\t\tnv = tri[i][2] - nv;\n\t\tnv /= abs(nv);\n\t\tnv *= d;\n\t\t\n\t\tsqr[i][0] = tri[i][0];\n\t\tsqr[i][1] = tri[i][1];\n\t\tsqr[i][2] = tri[i][1] + nv;\n\t\tsqr[i][3] = tri[i][0] + nv;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tsqr[i].resize(4);\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-8;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tif (contains(g, h[0])) return true;\n\tif (contains(h, g[0])) return true;\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc()\n{\n\tvector<int> vs;\n\tvector<bool> used(n);\n\tvector<int> cmp(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>> sccgraph = scc();\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0) res++;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < (int)n; i++)\n#define EPS (1e-8)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n#define MAX 100\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) :\n\t\t\tx(x), y(y) {\n\t}\n\tPoint operator +(Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator -(Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator *(double a) {\n\t\treturn Point(x * a, y * a);\n\t}\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n\tdouble norm() {\n\t\treturn x * x + y * y;\n\t}\n\tbool operator <(const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator ==(const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm(Vector a) {\n\treturn a.x * a.x + a.y * a.y;\n}\ndouble dot(Vector a, Vector b) {\n\treturn a.x * b.x + a.y * b.y;\n}\ndouble cross(Vector a, Vector b) {\n\treturn a.x * b.y - a.y * b.x;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS)\n\t\treturn COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)\n\t\treturn CLOCKWISE;\n\tif (dot(a, b) < -EPS)\n\t\treturn ONLINE_BACK;\n\tif (norm(a) < norm(b))\n\t\treturn ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool isIntersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0\n\t\t\t&& ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool isInside(Polygon gon, Point p) {\n\tfor (int i = 0; i < gon.size(); i++) {\n\t\tif (ccw(gon[i], gon[(i + 1) % gon.size()], p) == CLOCKWISE)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nclass Triangle {\npublic:\n\tvector<Point> P;\n\tTriangle() {\n\t\tP.resize(3);\n\t}\n\tvoid normalize() {\n\t\tvector<Point> tmp(3);\n\t\tif (norm(P[0] - P[1]) == norm(P[0] - P[2])) {\n\t\t\ttmp[0] = P[1];\n\t\t\ttmp[1] = P[2];\n\t\t\ttmp[2] = P[0];\n\t\t} else if (norm(P[1] - P[0]) == norm(P[1] - P[2])) {\n\t\t\ttmp[0] = P[0];\n\t\t\ttmp[1] = P[2];\n\t\t\ttmp[2] = P[1];\n\t\t} else if (norm(P[2] - P[0]) == norm(P[2] - P[1])) {\n\t\t\ttmp[0] = P[0];\n\t\t\ttmp[1] = P[1];\n\t\t\ttmp[2] = P[2];\n\t\t}\n\t\tP = tmp;\n\t\tif (ccw(P[0], P[1], P[2]) != COUNTER_CLOCKWISE) {\n\t\t\tswap(P[0], P[1]);\n\t\t}\n\t}\n};\nclass Graph {\npublic:\n\tint n;\n\tvector<vector<int> > adj;\n\tGraph(int n = 0) :n(n) {\n\t\tadj.resize(n);\t\n\t\trep(i, n)\tadj[i].clear();\n\t}\n\tvoid connect(int i, int j) {\n\t\tadj[i].push_back(j);\n\t}\n\tvoid transpose() {\n\t\tvector<vector<int> > nadj;\n\t\tnadj.resize(n);\n\t\trep(i, n)\n\t\t\tnadj[i].clear();\n\t\trep(i, n)\n\t\t\trep(j, adj[i].size())\n\t\t\t\tnadj[adj[i][j]].push_back(i);\n\t\trep(i, n)\n\t\t\tadj[i] = nadj[i];\n\t}\n};\nint n;\ndouble d;\nTriangle T[MAX];\nGraph g;\nint visited[MAX], finish[MAX], t;\nvector<int> com;\nbool overlapPolygon(Polygon p1, Polygon p2) {\n\trep(i, p1.size())\n\t\tif (isInside(p2, p1[i]))\n\t\t\treturn true;\n\trep(i, p2.size())\n\t\tif (isInside(p1, p2[i]))\n\t\t\treturn true;\n\trep(i, p1.size())\n\t\trep(j, p2.size())\n\t\t{\n\t\t\tif (isIntersect(p1[i], p1[(i + 1) % p1.size()], p2[j],\n\t\t\t\t\tp2[(j + 1) % p2.size()]))\n\t\t\t\treturn true;\n\t\t}\n\treturn false;\n}\nbool overlap(int t1, int t2) {\n\tTriangle s = T[t1];\n\tvector<Point> rect, tri;\n\tPoint c = Point((s.P[0].x + s.P[1].x) / 2, (s.P[0].y + s.P[1].y) / 2);\n\tVector v = s.P[2] - c;\n\tdouble a = v.abs();\n\tv.x = d * v.x / a;\n\tv.y = d * v.y / a;\n\tPoint l = s.P[0] + v;\n\tPoint r = s.P[1] + v;\n\trect.push_back(s.P[1]);\n\trect.push_back(r);\n\trect.push_back(l);\n\trect.push_back(s.P[0]);\n\ttri = T[t2].P;\n\treturn overlapPolygon(rect, tri);\n}\nvoid dfs(int &u) {\n\tvisited[u] = t++;\n\trep(i, g.adj[u].size())\n\t{\n\t\tint v = g.adj[u][i];\n\t\tif (visited[v] == -1)\n\t\t\tdfs(v);\n\t}\n\tfinish[u] = t++;\n}\nvoid dfsT(int &u) {\n\tcom.push_back(u);\n\tvisited[u] = 1;\n\trep(i, g.adj[u].size())\n\t{\n\t\tint v = g.adj[u][i];\n\t\tif (visited[v] == 0)\n\t\t\tdfsT(v);\n\t}\n}\nvoid makeGraph() {\n\tg = Graph(n);\n\trep(i, n)\n\t\trep(j, n)\n\t\t{\n\t\t\tif (i != j && overlap(i, j)) {\n\t\t\t\tg.connect(i, j);\n\t\t\t}\n\t\t}\n}\nint scc() {\n\tint id[MAX];\n\tbool indeg[MAX];\n\trep(i, n)\n\t\tvisited[i] = finish[i] = -1;\n\tt = 0;\n\trep(i, n)\n\t\tif (visited[i] == -1)\n\t\t\tdfs(i);\n\tg.transpose();\n\tvector<pair<int, int> > order;\n\trep(i, n)\n\t\torder.push_back(make_pair(finish[i], i));\n\tsort(order.begin(), order.end());\n\trep(i, n)\n\t\tvisited[i] = 0;\n\tint ncom = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint u = order[i].second;\n\t\tcom.clear();\n\t\tif (visited[u] == 0) {\n\t\t\tdfsT(u);\n\t\t\trep(c, com.size())\n\t\t\t\tid[com[c]] = ncom;\n\t\t\tncom++;\n\t\t}\n\t}\n\tint cnt = 0;\n\tg.transpose();\n\trep(i, ncom)\n\t\tindeg[i] = false;\n\trep(u, n)\n\t\trep(i, g.adj[u].size())\n\t\t{\n\t\t\tint v = g.adj[u][i];\n\t\t\tif (id[v] != id[u])\n\t\t\t\tindeg[id[v]] = true;\n\t\t}\n\trep(i, ncom)\n\t\tif (!indeg[i])\n\t\t\tcnt++;\n\treturn cnt;\n}\nint main() {\n\twhile( cin >> n >> d && n ) {\n\t\trep(i, n) {\n\t\t\tTriangle t;\n\t\t\trep(j, 3) cin >> t.P[j].x >> t.P[j].y;\n\t\t\tt.normalize();\n\t\t\tT[i] = t;\n\t\t}\n\t\tmakeGraph();\n\t\tcout << scc() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct coor {\n\tdouble x, y;\n};\nstruct tri {\n\tcoor p[3];\n\tcoor rec[4];\n};\n\nint n, d;\nvector<tri> v;\nvector<vector<int> > edge;\n\nconst double EPS = 1e-4;\nconst double ERR = 1e-2;\n\ntemplate<class T>\nT sqr(T x) {\n\treturn x * x;\n}\n\ndouble dist(coor a, coor b) {\n\treturn sqrt(sqr(a.x-b.x) + sqr(a.y-b.y));\n}\n\ndouble dist_lp(coor c, coor a, coor b) {\n\tcoor v0, v1;\n\tv0.x = b.x - a.x; v0.y = b.y - a.y;\n\tv1.x = c.x - a.x; v1.y = c.y - a.y;\n\n\tif(sqr(dist(a,b)) + sqr(dist(a,c)) - sqr(dist(c,b)) > 0\n\t\t\t&& sqr(dist(a,b)) + sqr(dist(b,c)) - sqr(dist(c,a)) > 0) {\n\t\tdouble cross;\n\t\tcross = fabs(v0.x * v1.y - v0.y * v1.x);\n\t\treturn cross / dist(a,b);\n\t}\n\n\treturn min(dist(a,c), dist(b,c));\n}\n\nbool in_poly(coor p, coor poly[], int sz) {\n\tdouble sign = +0.0;\n\tfor(int i = 0; i < sz; i++) {\n\t\tcoor v0, v1;\n\t\tv0.x = poly[i].x - p.x; v0.y = poly[i].y - p.y;\n\t\tv1.x = poly[(i+1)%sz].x - p.x; v1.y = poly[(i+1)%sz].y - p.y;;\n\n\t\tif(i != 0 && sign * (v0.x * v1.y - v0.y * v1.x) < EPS) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tsign = (v0.x * v1.y - v0.y * v1.x);\n\n\t\tif(i == sz-1) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < sz; i++) {\n\t\tif(dist_lp(p,poly[i], poly[(i+1)%sz]) <= ERR + EPS) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool seg_cross(coor a, coor b, coor c, coor d) {\n\tcoor v0, v1, v2;\n\t\n\tv0.x = a.x - c.x; v0.y = a.y - c.y;\n\tv1.x = b.x - c.x; v1.y = b.y - c.y;\n\tv2.x = d.x - c.x; v2.y = d.y - c.y;\n\n\tdouble s, t;\n\ts = (v0.x * v2.y - v0.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\tt = - (v1.x * v2.y - v1.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\n\tif(s + t > 1-EPS && s > -EPS && t > -EPS) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool exist_edge(tri from, tri to) {\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(in_poly(to.p[i], from.rec, 4)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(in_poly(from.rec[i], to.p, 3)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 3; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tif(seg_cross(to.p[i], to.p[(i+1)%3], from.rec[j], from.rec[(j+1)%4])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool visited[128];\nbool touch[128];\n\nvoid check(int i, int s) {\n\tif(i != s && touch[i])\n\t\ttouch[i] = false;\n\tif(visited[i])\n\t\treturn;\n\tvisited[i] = true;\n\tfor(int j = 0; j < (int)edge[i].size(); j++) {\n\t\tcheck(edge[i][j], s);\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> d, n || d) {\n\t\tv.clear();\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tvisited[i] = touch[i] = false;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttri in;\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tcoor c;\n\t\t\t\tcin >> c.x >> c.y;\n\t\t\t\tin.p[j] = c;\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tif(fabs(dist(in.p[(0+j)%3],in.p[(1+j)%3]) - dist(in.p[(1+j)%3], in.p[(2+j)%3])) < EPS) {\n\t\t\t\t\tswap(in.p[(1+j)%3], in.p[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcoor add;\n\t\t\tadd.x =\t(in.p[1].x - in.p[0].x) + (in.p[1].x - in.p[2].x);\n\t\t\tadd.y = (in.p[1].y - in.p[0].y) + (in.p[1].y - in.p[2].y);\n\n\t\t\tdouble addlen;\n\t\t\taddlen = sqrt(sqr(add.x) + sqr(add.y));\n\t\t\tadd.x = add.x * d / addlen;\n\t\t\tadd.y = add.y * d / addlen;\n\n\t\t\tin.rec[0].x = in.p[0].x; in.rec[0].y = in.p[0].y;\n\t\t\tin.rec[1].x = in.p[2].x; in.rec[1].y = in.p[2].y;\n\t\t\tin.rec[2].x = in.p[2].x + add.x; in.rec[2].y = in.p[2].y + add.y;\n\t\t\tin.rec[3].x = in.p[0].x + add.x; in.rec[3].y = in.p[0].y + add.y;\n\n\t\t\tv.push_back(in);\n\t\t}\n\n\t\tfor(int i = 0; i < (int)v.size(); i++) {\n\t\t\tfor(int j = 0; j < (int)v.size(); j++) {\n\t\t\t\tif(i != j) {\n\t\t\t\t\tif(exist_edge(v[i], v[j])) {\n\t\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\ttouch[i] = true;\n\t\t\t\tcheck(i, i);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(touch[i])\n\t\t\t\tres++;\n\t\t}\n\t\tcout <<  res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-5;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tSegment s(curr(g, i), next(g, i));\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(s, h[j]) <= EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tSegment s(curr(h, i), next(h, i));\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(s, g[j]) <= EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tbool f = false;\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\t\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t\tf = true;\n\t\t}\n\t\tassert(f);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to] = 1;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-1;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && -EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\t//if (intersect(u, v)) return true;\n\t\t\tif (distance(u, v) < EPS) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tSegment s(curr(g, i), next(g, i));\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(s, h[j]) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tSegment s(curr(h, i), next(h, i));\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(s, g[j]) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs(0);\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(norm(b - a), norm(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tVector a = tri[i][1] - tri[i][0];\n\t\tVector nv = tri[i][0] + (a / 2.0);\n\t\tnv = tri[i][2] - nv;\n\t\tnv /= abs(nv);\n\t\tnv *= d;\n\t\t\n\t\tsqr[i][0] = tri[i][0];\n\t\tsqr[i][1] = tri[i][1];\n\t\tsqr[i][2] = tri[i][1] + nv;\n\t\tsqr[i][3] = tri[i][0] + nv;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tsqr[i].resize(4);\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\n#include <cstring>\n\n// ???, ????????????\ntypedef std::complex<double> Point;\ntypedef Point Vector;\n\nnamespace std {\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\t\n\tistream& operator >> (istream &is, Point &a){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\ta = Point(x, y);\n\t\treturn is;\n\t}\n\t\n\tostream& operator << (ostream &os, Point a){\n\t\treturn os << a.real() << \" \" << a.imag();\n\t}\n}\n\n// ??´???\nstruct Line {\n\tPoint p1, p2;\n\tLine(){}\n\tLine(const Point &p1, const Point &p2): p1(p1), p2(p2){}\n};\ntypedef Line Segment;\n\nnamespace std {\n\tistream& operator >> (istream &is, Line &a){\n\t\treturn is >> a.p1 >> a.p2;\n\t}\n}\n\n// ???\nstruct Circle {\n\tPoint p; double r;\n\tCircle(){}\n\tCircle(const Point &p, double r): p(p), r(r){}\n};\n\nnamespace std {\n\tistream& operator >> (istream &is, Circle &a){\n\t\treturn is >> a.p >> a.r;\n\t}\n}\n\n// ????§???¢\ntypedef std::vector<Point> Polygon;\n\nconst double EPS = 1e-12;\nconst double INF = 1e12;\nconst double PI = acos(-1.0);\n\n// ????????¨??????????????¢???\nenum CCW {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0,\n};\n\n// ?????¢????£????????????¢???\nenum {\n\tOUT = 0,\n\tON = 1,\n\tIN = 2,\n};\n\n\n// a ??? 2 ??? (a ^ 2)\ndouble SQ(double a);\n\n// ?????????????????????????????¢??°\nbool EQ(double a, double b);\nbool NEQ(double a, double b);\nbool LT(double a, double b);\nbool GT(double a, double b);\nbool LEQ(double a, double b);\nbool GEQ(double a, double b);\n\n// ??§?????? <=> ?????°?????????\ndouble toDeg(double t);\ndouble toRad(double t);\n\n// ????????? (dot(a, a))\ndouble norm(const Vector &a);\n\n// ??????, ??????\ndouble dot(const Vector &a, const Vector &b);\ndouble cross(const Vector &a, const Vector &b);\n\n// ??´???, ??????\nbool orthogonal(const Segment &s1, const Segment &s2);\nbool parallel(const Segment &s1, const Segment &s2);\n\n// ?°???±, ????°?\nPoint project(const Line &l, const Point &p);\nPoint reflect(const Line &l, const Point &p);\n\n// ?????? (p0, p1) ??¨??? p2 ???????????¢???\nint ccw(const Point &p0, const Point &p1, const Point &p2);\n\n// ????????????\nbool intersectLP(const Line &l, const Point &p);\nbool intersectLL(const Line &l1, const Line &l2);\nbool intersectLS(const Line &l, const Segment &s);\nbool intersectSP(const Segment &s, const Point &p);\nbool intersectSS(const Segment &s1, const Segment &s2);\nint intersectCP(const Circle &c, const Point &p);\nbool intersectCL(const Circle &c, const Line &l);\nint intersectCS(const Circle &c, const Segment &s);\nint intersectCC(const Circle &c1, const Circle &c2);\n\n// ?????¢\ndouble distanceLP(const Line &l, const Point &p);\ndouble distanceLL(const Line &l1, const Line &l2);\ndouble distanceLS(const Line &l, const Segment &s);\ndouble distanceSP(const Segment &s, const Point &p);\ndouble distanceSS(const Segment &s1, const Segment &s2);\ndouble distanceCP(const Circle &c, const Point &p);\ndouble distanceCL(const Circle &c, const Line &l);\ndouble distanceCS(const Circle &c, const Segment &s);\ndouble distanceCC(const Circle &c1, const Circle &c2);\n\n// ??????\nPoint crossPointLL(const Line &l1, const Line &l2);\nPoint crossPointLS(const Line &l, const Segment &s);\nPoint crossPointSS(const Segment &s1, const Segment &s2);\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l);\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s);\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2);\n\n\ndouble SQ(double a){\n\treturn a * a;\n}\n\nbool EQ(double a, double b){\n\treturn std::abs(a - b) < EPS;\n}\n\nbool NEQ(double a, double b){\n\treturn !EQ(a, b);\n}\n\nbool LT(double a, double b){\n\treturn a - b < -EPS;\n}\n\nbool GT(double a, double b){\n\treturn a - b > EPS;\n}\n\nbool LEQ(double a, double b){\n\treturn !GT(a, b);\n}\n\nbool GEQ(double a, double b){\n\treturn !LT(a, b);\n}\n\ndouble toDeg(double t){\n\treturn t * 180 / PI;\n}\n\ndouble toRad(double t){\n\treturn t / 180 * PI;\n}\n\ndouble norm(const Vector &a){\n\treturn SQ(a.real()) + SQ(a.imag());\n}\n\ndouble dot(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).real();\n}\n\ndouble cross(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).imag();\n}\n\n// AOJ CGL_2_A\nbool orthogonal(const Segment &s1, const Segment &s2){\n\treturn EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_2_A\nbool parallel(const Segment &s1, const Segment &s2){\n\treturn EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_1_A\nPoint project(const Line &l, const Point &p){\n\tVector base = l.p2 - l.p1;\n\tdouble r = dot(p - l.p1, base) / norm(base);\n\treturn l.p1 + base * r;\n}\n\n// AOJ CGL_1_B\nPoint reflect(const Line &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2.0;\n}\n\n// AOJ CGL_1_C\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (GT(cross(a, b), 0.0)) return COUNTER_CLOCKWISE;\n\tif (LT(cross(a, b), 0.0)) return CLOCKWISE;\n\tif (LT(dot(a, b), 0.0)) return ONLINE_BACK;\n\tif (LT(norm(a), norm(b))) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersectLP(const Line &l, const Point &p){\n\treturn LEQ(std::abs(cross(l.p1 - p, l.p2 - p)), 0.0);\n}\n\nbool intersectLL(const Line &l1, const Line &l2){\n\treturn !parallel(l1, l2) || LEQ(std::abs(cross(l1.p2 - l1.p1, l2.p1 - l1.p1)), 0.0);\n}\n\nbool intersectLS(const Line &l, const Segment &s){\n\treturn LEQ(cross(l.p2 - l.p1, s.p1 - l.p1) * cross(l.p2 - l.p1, s.p2 - l.p1), 0.0);\n}\n\nbool intersectSP(const Segment &s, const Point &p){\n\treturn norm(s.p1 - p) + norm(s.p2 - p) - norm(s.p2 - s.p1) < EPS;\n}\n\n// CGL_2_B\nbool intersectSS(const Segment &s1, const Segment &s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\nint intersectCP(const Circle &c, const Point &p){\n\tdouble dd = norm(c.p - p);\n\tif (LT(dd, SQ(c.r))) return IN;\n\tif (EQ(dd, SQ(c.r))) return ON;\n\treturn OUT;\n}\n\nbool intersectCL(const Circle &c, const Line &l){\n\tdouble d = distanceLP(l, c.p);\n\treturn LEQ(d, c.r);\n}\n\nint intersectCS(const Circle &c, const Segment &s){\n\tdouble dd1 = norm(c.p - s.p1);\n\tdouble dd2 = norm(c.p - s.p2);\n\tif (LT(dd1, SQ(c.r)) && LT(dd2, SQ(c.r))) return IN;\n\tif (GT(distanceCS(c, s), 0.0)) return OUT;\n\treturn ON;\n}\n\n// c1 ??? c2 ???????????????????????¨??? IN\n// c1 ??? c2 ????????£???????????¨??? ON\n// c1 ??? c2 ?????????????????¨??? OUT\nint intersectCC(const Circle &c1, const Circle &c2){\n\tif (GT(norm(c1.p - c2.p), SQ(c1.r + c2.r))) return OUT;\n\tif (LT(norm(c1.p - c2.p), SQ(c2.r))) return IN;\n\tif (LT(norm(c1.p - c2.p), SQ(c1.r))) return OUT;\n\treturn ON;\n}\n\ndouble distanceLP(const Line &l, const Point &p){\n\treturn std::abs(cross(l.p2 - l.p1, p - l.p1)) / std::abs(l.p2 - l.p1);\n}\n\ndouble distanceLL(const Line &l1, const Line &l2){\n\tif (intersectLL(l1, l2)) return 0.0;\n\treturn distanceLP(l1, l2.p1);\n}\n\ndouble distanceLS(const Line &l, const Segment &s){\n\tif (intersectLS(l, s)) return 0.0;\n\treturn std::min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\n\ndouble distanceSP(const Segment &s, const Point &p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return std::abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return std::abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\n// AOJ CGL_2_D\ndouble distanceSS(const Segment &s1, const Segment &s2){\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn std::min(\n\t\tstd::min(\n\t\t\tdistanceSP(s1, s2.p1),\n\t\t\tdistanceSP(s1, s2.p2)\n\t\t),\n\t\tstd::min(\n\t\t\tdistanceSP(s2, s1.p1),\n\t\t\tdistanceSP(s2, s1.p2)\n\t\t)\n\t);\n}\n\ndouble distanceCP(const Circle &c, const Point &p){\n\treturn std::abs(std::abs(c.p - p) - c.r);\n} \n\ndouble distanceCL(const Circle &c, const Line &l){\n\tif (intersectCL(c, l)) return 0.0;\n\treturn distanceLP(l, c.p) - c.r;\n}\n\ndouble distanceCS(const Circle &c, const Segment &s){\n\tif (intersectCS(c, s)) return 0.0;\n\treturn std::min(distanceCP(c, s.p1), distanceCP(c, s.p2));\n}\n\ndouble distanceCC(const Circle &c1, const Circle &c2){\n\tif (intersectCC(c1, c2) == ON) return 0.0;\n\tif (intersectCC(c1, c2) == IN){\n\t\treturn c2.r - (std::abs(c1.p - c2.p) + c1.r);\n\t}\n\tif (intersectCC(c2, c1) == IN){\n\t\treturn c1.r - (std::abs(c1.p - c2.p) + c2.r);\n\t}\n\treturn (c1.r + c2.r) - (c1.r + c2.r);\n}\n\nPoint crossPointLL(const Line &l1, const Line &l2){\n\tassert(intersectLL(l1, l2));\n\tVector base = l2.p2 - l2.p1;\n\tdouble d1 = std::abs(cross(base, l1.p1 - l2.p1));\n\tdouble d2 = std::abs(cross(base, l1.p2 - l2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn l1.p1 + (l1.p2 - l1.p1) * t;\n}\n\nPoint crossPointLS(const Line &l, const Segment &s){\n\tassert(intersectLS(l, s));\n\treturn crossPointLL(l, s);\n}\n\nPoint crossPointSS(const Segment &s1, const Segment &s2){\n\tassert(intersectSS(s1, s2));\n\treturn crossPointSS(s1, s2);\n}\n\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l){\n\tif (!intersectCL(c, l)) return std::vector<Point>();\n\tstd::vector<Point> ret;\n\tVector proj = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / std::abs(l.p2 - l.p1);\n\tdouble base = sqrt(SQ(c.r) - norm(proj - c.p));\n\tret.push_back(proj + e * base);\n\tret.push_back(proj - e * base);\n\treturn ret;\n}\n\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s){\n\tstd::vector<Point> ret = crossPointCL(c, s);\n\tfor (int i = 0; i < ret.size(); i++){\n\t\tif (!intersectCP(c, ret[i])){\n\t\t\tswap(ret[i], ret.back());\n\t\t\tret.pop_back();\n\t\t\ti--;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2){\n\tif (!intersectCC(c1, c2)) return std::vector<Point>();\n\tstd::vector<Point> ret;\n\tdouble d = std::abs(c1.p - c2.p);\n\tdouble a = std::acos((SQ(c1.r) + SQ(d) - SQ(c2.r)) / (2 * c1.r * d));\n\tdouble t = std::arg(c2.p - c1.p);\n\tret.push_back(c1.p + std::polar(c1.r, t + a));\n\tret.push_back(c1.p + std::polar(c1.r, t - a));\n\treturn ret;\n}\n\nnamespace {\nenum {DIRECTED, UNDIRECTED};\nconst int GRAPH_TYPE = DIRECTED;\n\ntypedef int Weight;\nconst Weight INF = 1 << 28;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge() {}\n\tEdge(int src, int dst, Weight weight = 1): src(src), dst(dst), weight(weight) {}\n\tbool operator < (const Edge &t) const { return weight < t.weight; }\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n\nvoid addEdge(Graph &g, int src, int dst, int weight = 1)\n{\n\tg[src].push_back(Edge(src, dst, weight));\n\tif (GRAPH_TYPE == UNDIRECTED) g[dst].push_back(Edge(dst, src, weight));\n};\n\nGraph transpose(const Graph &g)\n{\n\tGraph rg(g.size());\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\taddEdge(rg, g[i][j].dst, g[i][j].src, g[i][j].weight);\n\t\t}\n\t}\n\treturn rg;\n}\n\nvoid dfs_(const Graph &g, int v, bool *used, std::vector<int> &vs)\n{\n\tused[v] = true;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) dfs_(g, to, used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs_(const Graph &g, int v, int k, bool *used, std::vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) rdfs_(g, to, k, used, cmp);\n\t}\n}\n\nint scc(const Graph &g, std::vector<int> &cmp)\n{\n\tGraph rg = transpose(g);\n\tstd::vector<int> vs;\n\tbool *used = new bool[g.size()];\n\tcmp.resize(g.size());\n\t\n\tstd::memset(used, false, g.size());\n\tfor (int v = 0; v < g.size(); v++){\n\t\tif (!used[v]) dfs_(g, v, used, vs);\n\t}\n\t\n\tstd::memset(used, false, g.size());\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs_(rg, vs[i], k++, used, cmp);\n\t}\n\t\n\tdelete used;\n\treturn k;\n}\n}\n\n\nusing namespace std;\n\nint n;\ndouble d;\nvector<Polygon> tri;\nvector<Polygon> rect;\n\nbool contains(const Polygon &g, const Point &p)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tint t = ccw(g[i], g[(i + 1) % g.size()], p);\n\t\tif (t == CLOCKWISE) return false;\n\t\tif (t == ON_SEGMENT) return true;\n\t}\n\treturn true;\n}\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment s(g[i], g[(i + 1) % g.size()]);\n\t\t\tSegment t(h[j], h[(j + 1) % h.size()]);\n\t\t\tif (LEQ(distanceSS(s, t), 0.01)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\t\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\trect.assign(n, Polygon(4));\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tif (EQ(norm(tri[i][j] - tri[i][(j + 1) % 3]), norm(tri[i][j] - tri[i][(j + 2) % 3]))){\n\t\t\t\tswap(tri[i][0], tri[i][j]);\n\t\t\t}\n\t\t}\n\t\tif (ccw(tri[i][1], tri[i][2], tri[i][0]) == CLOCKWISE){\n\t\t\tswap(tri[i][1], tri[i][2]);\n\t\t}\n\t\t\n\t\tVector s = tri[i][2] - tri[i][1];\n\t\tVector normal = s / abs(s) * Vector(0, 1) * d;\n\t\trect[i][0] = tri[i][1];\n\t\trect[i][1] = tri[i][2];\n\t\trect[i][2] = tri[i][2] + normal;\n\t\trect[i][3] = tri[i][1] + normal;\n\t}\n\t\n\tGraph graph(n);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(rect[i], tri[j])){\n\t\t\t\taddEdge(graph, i, j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tint v = scc(graph, cmp);\n\tint mat[100][100] = {};\n\tint in[100] = {};\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < graph[i].size(); j++){\n\t\t\tint src = cmp[i];\n\t\t\tint dst = cmp[graph[i][j].dst];\n\t\t\tif (src == dst) continue;\n\t\t\tif (mat[src][dst]++) continue;\n\t\t\tin[dst]++;\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < v; i++){\n\t\tif (in[i] == 0) res++;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tstd::cout << std::fixed << std::setprecision(12);\n\t\n\twhile (cin >> n >> d, n){\n\t\ttri.assign(n, Polygon(3));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-2)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) + SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\nG convexHull(vector<P> s){\n\tif (s.size() < 3) return s;\n\tG u, l;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tfor (int i = 2; i < s.size(); i++){\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\tl.push_back(u[i]);\n\t}\n\treturn l;\n}\n\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G &a, G &b)\n{\t\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a.size(); i++){\n\t\tif (contains(b, a[i])){\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int i = 0; i < b.size(); i++){\n\t\tif (contains(a, b[i])){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t\tr = convexHull(r);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tvector<int> toi(V);\n\tfor (int i = 0; i < V; i++){\n\t\ttoi[tps[i]] = i;\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) res++;\n\t\tfor (int to : sccgraph[tps[i]]){\n\t\t\tused[toi[to]] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-8 + 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tSegment s(curr(g, i), next(g, i));\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(s, h[j]) <= EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tSegment s(curr(h, i), next(h, i));\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(s, g[j]) <= EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(norm(b - a), norm(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tbool f = false;\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\t\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t\tf = true;\n\t\t}\n\t\tassert(f);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-1;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nint V;\nvector<vector<int> > G,rG;\nvector<int> vs;\nbool used[100];\nint cmp[100];\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]){\n      dfs(G[v][i]);\n    }\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]){\n      rdfs(rG[v][i],k);\n    }\n  }\n}\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[2])>eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    G=rG=vector<vector<int> >(n);\n    vs.clear();\n    bool e[100][100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<eps;\n\t      e[i][j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    e[i][j]|=!f;\n\t    if(e[i][j]){\n\t      G[i].push_back(j);\n\t      rG[j].push_back(i);\n\t    }\n\t  }\n\t}\n      }\n    }\n    V=n;\n    fill(begin(used),end(used),false);\n    for(int v=0;v<V;v++){\n      if(!used[v]){\n\tdfs(v);\n      }\n    }\n    fill(begin(used),end(used),false);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]]){\n\trdfs(vs[i],k++);\n      }\n    }\n    bool in[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(e[i][j]&&cmp[i]!=cmp[j]){\n\t  in[cmp[j]]=true;\n\t}\n      }\n    }\n    cout<<count(in,in+k,false)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<cfloat>\n#include<tuple>\n#include<set>\n#include<stack>\n#include<algorithm>\n\nconst double INF = DBL_MAX / 3.0;\n\nconst double EPS = 1e-10;\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Polygon;\n// member\nclass Point {\ndouble x_value, y_value;\npublic:\nPoint() :x_value(0.0), y_value(0.0) {}\nPoint(double d) :x_value(d), y_value(d) {}\nPoint(double a, double b) :x_value(a), y_value(b) {}\ndouble x() const {return x_value;}\ndouble y() const {return y_value;}\ndouble x(double d) {return x_value = d;}\ndouble y(double d) {return y_value = d;}\nconst Point operator-() const;\nconst Point& operator=(const Point&);\nconst Point& operator+=(const Point&);\nconst Point& operator-=(const Point&);\nconst Point& operator*=(const Point&);\nconst Point& operator/=(const Point&);\ndouble dot(const Point&) const;\ndouble cross(const Point&) const;\ndouble abs() const;\ndouble norm() const;\nconst Point normalize() const;\ndouble distance(const Point&) const;\ndouble distance(const Segment&) const;\ndouble distance(const Line&) const;\nbool intersect(const Point&) const;\nbool intersect(const Segment&) const;\nbool intersect(const Line&) const;\nconst Point projection(const Line&) const;\nconst Point reflection(const Line&) const;\nPOSITION ccw(const Point&, const Point&) const;\n};\nbool operator==(const Point& lhs, const Point& rhs);\nbool operator!=(const Point& lhs, const Point& rhs);\nbool operator<(const Point& lhs, const Point& rhs);\nbool operator>(const Point& lhs, const Point& rhs);\nbool operator<=(const Point& lhs, const Point& rhs);\nbool operator>=(const Point& lhs, const Point& rhs);\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\nPoint source_point, target_point;\npublic:\nSegment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\nSegment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\nconst Point& source() const {return source_point;}\nconst Point& target() const {return target_point;}\nconst Point& source(const Point& p) {return source_point = p;}\nconst Point& target(const Point& p) {return target_point = p;}\nconst Line line() const;\ndouble distance(const Point&) const;\ndouble distance(const Segment&) const;\ndouble distance(const Line&) const;\nbool intersect(const Point&) const;\nbool intersect(const Segment&) const;\nbool intersect(const Line&) const;\nPOSITION ccw(const Point&) const;\n};\nclass Line {\nPoint source_point, target_point;\npublic:\nLine(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\nLine(const Point& a, const Point& b) :source_point(a), target_point(b) {}\nconst Point& source() const {return source_point;}\nconst Point& target() const {return target_point;}\nconst Point& source(const Point& p) {return source_point = p;}\nconst Point& target(const Point& p) {return target_point = p;}\nconst Segment segment() const;\ndouble distance(const Point&) const;\ndouble distance(const Segment&) const;\ndouble distance(const Line&) const;\nbool intersect(const Point&) const;\nbool intersect(const Segment&) const;\nbool intersect(const Line&) const;\nconst Point projection(const Point&) const;\nconst Point reflection(const Point&) const;\nconst Point crosspoint(const Line&) const;\nPOSITION ccw(const Point&) const;\n};\nclass Polygon {\nstd::vector<Point> point;\npublic:\nPolygon() {}\nexplicit Polygon(std::vector<Point> p) :point(p) {}\nconst std::vector<Point>& vertex() const {return point;}\nconst Point& vertex(int i) const {return point.at(i);}\nconst std::vector<Segment> edge() const {\nstd::vector<Segment> result;\nfor(int i = 0; i < size(); ++i) result.push_back(Segment(vertex(i), vertex((i + 1) % size())));\nreturn result;\n}\nconst Segment edge(int i) const {return Segment(vertex(i), vertex((i + 1) % size()));}\nint size() const {return point.size();}\nvoid add(const Point&);\ndouble area() const;\nbool convex() const;\nbool include(const Point&) const;\nbool intersect(const Polygon&) const;\nbool on_edge(const Point&) const;\nconst Polygon convex_hull() const;\n};\n// Point\nbool operator==(const Point& lhs, const Point& rhs) {return lhs.x() == rhs.x() && lhs.y() == rhs.y();}\nbool operator!=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() || lhs.y() != rhs.y();}\nbool operator<(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() < rhs.y();}\nbool operator>(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() > rhs.y();}\nbool operator<=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() <= rhs.y();}\nbool operator>=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() >= rhs.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\nconst Point Point::normalize() const {return abs() == 0.0 ? Point(0.0, 0.0) : Point(x(), y()) / abs();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\nconst Point& a = *this;\nPoint v1 = b - a;\nPoint v2 = p - a;\nif(v1.cross(v2) > EPS) return COUNTER_CLOCKWISE;\nif(v1.cross(v2) < -EPS) return CLOCKWISE;\nif(v1.dot(v2) < -EPS) return ONLINE_BACK;\nif(v2.norm() - v1.norm() > EPS) return ONLINE_FRONT;\nreturn ON_SEGMENT;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\nPoint q = line().projection(p);\nif(intersect(q)) return q.distance(p);\nreturn std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\nif(intersect(s)) return 0.0;\ndouble a = distance(s.source());\ndouble b = distance(s.target());\ndouble c = s.distance(source());\ndouble d = s.distance(target());\nreturn std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\nbool a = ccw(s.source()) * ccw(s.target()) <= 0;\nbool b = s.ccw(source()) * s.ccw(target()) <= 0;\nreturn a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\nif(intersect(s)) return 0.0;\ndouble a = distance(s.source());\ndouble b = distance(s.target());\nreturn a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\nPoint v1 = source() - p;\nPoint v2 = target() - p;\nreturn fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\nPoint v1 = target() - source();\nPoint v2 = s.source() - source();\nPoint v3 = s.target() - source();\nreturn v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\nPoint v1 = target() - source();\nPoint v2 = l.target() - l.source();\nPoint v3 = l.source() - source();\nreturn fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\nPoint v1 = p - source();\nPoint v2 = source() - target();\nreturn Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\nreturn p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\nPoint v1 = target() - source();\nPoint v2 = l.target() - l.source();\nPoint v3 = target() - l.source();\ndouble a = v1.cross(v2);\ndouble b = v1.cross(v3);\nif(fabs(a) <= EPS && fabs(b) <= EPS) return l.source();\nreturn l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Polygon\nvoid Polygon::add(const Point& p) {point.push_back(p);}\ndouble Polygon::area() const {\ndouble sum = 0.0;\nfor(int i = 0; i < size(); ++i) sum += vertex(i).cross(vertex((i+1) % size()));\nreturn fabs(sum) / 2.0;\n}\nbool Polygon::convex() const {\nPOSITION direction = ONLINE_BACK;\nfor(int i = 1; i < size(); ++i) {\nPOSITION d = vertex(i - 1).ccw(vertex(i), vertex((i + 1) % size()));\nif(d != CLOCKWISE && d != COUNTER_CLOCKWISE) continue;\nif(direction == ONLINE_BACK) direction = d;\nif(direction != d) return false;\n}\nreturn true;\n}\nbool Polygon::include(const Point& p) const {\nbool in = false;\nfor(int i = 0; i < size(); ++i) {\nPoint a = vertex(i) - p;\nPoint b = vertex((i + 1) % size()) - p;\nif(a.y() > b.y()) std::swap(a, b);\nif(a.y() <= 0.0 && 0 < b.y() && a.cross(b) < 0.0) in = !in;\nif(fabs(a.cross(b)) <= EPS && a.dot(b) <= EPS) return true;\n}\nreturn in;\n}\nbool Polygon::intersect(const Polygon& p) const {\nfor(const auto& e1: edge()) for(const auto& e2: p.edge()) if(e1.intersect(e2)) return true;\nreturn false;\n}\nbool Polygon::on_edge(const Point& p) const {\nfor(int i = 0; i < size(); ++i) if(vertex(i).ccw(vertex((i + 1) % size()), p) == ON_SEGMENT) return true;\nreturn false;\n}\nconst Polygon Polygon::convex_hull() const {                // Andrew's Monotone Chain\nPolygon result;\nstd::vector<Point> res;\nstd::vector<Point> original = vertex();\nsort(original.begin(), original.end());\noriginal.insert(original.end(), original.rbegin() + 1, original.rend());\nfor(const auto& v: original) {\nwhile(res.size() >= 2 && res[res.size() - 2].ccw(res[res.size() - 1], v) == CLOCKWISE) res.pop_back();\nres.push_back(v);\n}\nres.pop_back();\nfor(const auto& v: res) result.add(v);\nreturn result;\n}\n\n// Edge\nclass Edge {\nint from_value, to_value;\ndouble weight_value;\npublic:\nEdge() {}\nEdge(int f, int t, double w) :from_value(f), to_value(t), weight_value(w) {}\nint from() const {return from_value;}\nint to() const {return to_value;}\ndouble weight() const {return weight_value;}\n};\n\n// Graph\nclass Graph {\nint size_value;\nstd::vector<std::vector<Edge>> edge_value;\n\npublic:\nexplicit Graph(int s) :size_value(s) {edge_value.resize(s);}\n\nint size() const {return size_value;}\nconst std::vector<Edge>& edge(int v) const {return edge_value[v];}\n\nvoid add(const Edge& e);\nvoid add(int from, int to, double weight);\npublic:\nstd::vector<std::vector<int>> Kosaraju() const;\nprivate:\nvoid Kosaraju_dfs_postorder(int from, std::vector<bool>& visited, std::stack<int>& order) const;\nstd::vector<int> Kosaraju_dfs_decompose(const std::vector<std::vector<Edge>>& reverse_edge, int from, std::vector<bool>& visited) const;\n};\n\n// implements\nvoid Graph::add(const Edge& e) {edge_value[e.from()].push_back(e);}\nvoid Graph::add(int from, int to, double weight) {edge_value[from].push_back(Edge(from, to, weight));}\nstd::vector<std::vector<int>> Graph::Kosaraju() const {\nstd::vector<std::vector<int>> result;\nstd::vector<bool> visited(size(), false);\nstd::stack<int> order;\nfor(int v = 0; v < size(); ++v) if(!visited[v]) Kosaraju_dfs_postorder(v, visited, order);\nstd::vector<std::vector<Edge>> reverse_edge(size(), std::vector<Edge>());\nfor(int v = 0; v < size(); ++v) for(const auto& e: edge(v)) reverse_edge[e.to()].push_back(Edge(e.to(), e.from(), e.weight()));\nvisited = std::vector<bool>(size(), false);\nwhile(!order.empty()) {\nint v = order.top();\norder.pop();\nif(visited[v]) continue;\nresult.push_back(Kosaraju_dfs_decompose(reverse_edge, v, visited));\n}\nreturn result;\n}\nvoid Graph::Kosaraju_dfs_postorder(int from, std::vector<bool>& visited, std::stack<int>& order) const {\nvisited[from] = true;\nfor(const auto& e: edge(from)) if(!visited[e.to()]) Kosaraju_dfs_postorder(e.to(), visited, order);\norder.push(from);\n}\nstd::vector<int> Graph::Kosaraju_dfs_decompose(const std::vector<std::vector<Edge>>& reverse_edge, int from, std::vector<bool>& visited) const {\nstd::vector<int> result;\nresult.push_back(from);\nvisited[from] = true;\nfor(const auto& e: reverse_edge[from]) {\nif(visited[e.to()]) continue;\nstd::vector<int> add = Kosaraju_dfs_decompose(reverse_edge, e.to(), visited);\nresult.insert(result.end(), add.begin(), add.end());\n}\nreturn result;\n}\n\nusing namespace std; \nint main() {\nint n, d;\nwhile(cin >> n >> d, n | d) {\nvector<Polygon> triangle(n);\nfor(auto &t: triangle) {\nvector<Point> vertex(3);\nfor(auto &v: vertex) {\ndouble x, y;\ncin >> x >> y;\nv = Point(x, y);\n}\nif(vertex[0].distance(vertex[1]) == vertex[0].distance(vertex[2])) swap(vertex[0], vertex[2]);\nif(vertex[1].distance(vertex[0]) == vertex[1].distance(vertex[2])) swap(vertex[1], vertex[2]);\nfor(const auto &v: vertex) t.add(v);\n}\n\nvector<Polygon> light(n);\nfor(int i = 0; i < triangle.size(); ++i) {\nPoint n = (triangle[i].vertex(1) - triangle[i].vertex(0)).normalize();\nif(triangle[i].vertex(0).ccw(triangle[i].vertex(1), triangle[i].vertex(2)) > 0) n = Point(-n.y(), n.x());\nelse                                                                            n = Point(n.y(), -n.x());\nlight[i].add(triangle[i].vertex(0));\nlight[i].add(triangle[i].vertex(0) + (n * d));\nlight[i].add(triangle[i].vertex(1) + (n * d));\nlight[i].add(triangle[i].vertex(1));\n}\n\nGraph g(n);\nfor(int i = 0; i < n; ++i) {\nfor(int j = 0; j < n; ++j) {\nif(i == j) continue;\nbool shine = false;\n\n// 辺の交差判定\nfor(const auto &l: light[i].edge())\nfor(const auto &t: triangle[j].edge())\nif(l.intersect(t)) shine = true;\n// 点の包含判定\nfor(const auto &v: light[i].vertex())\nif(triangle[j].include(v)) shine = true;\nfor(const auto &v: triangle[j].vertex())\nif(light[i].include(v)) shine = true;\n// 線分と点の距離が0.01以下\nfor(const auto &l: light[i].edge())\nfor(const auto &t: triangle[j].edge())\nif(l.distance(t) <= 0.01) shine = true;\n\nif(!shine) continue;\ng.add(Edge(i, j, 1));\n}\n}\n\nauto scc = g.Kosaraju();\nvector<int> indegree(scc.size(), 0);\nfor(int i = 0; i < scc.size(); ++i) {\nfor(int j = i + 1; j < scc.size(); ++j) {\nfor(const auto& v: scc[i]) for(const auto& e: g.edge(v)){\nif(find(scc[j].begin(), scc[j].end(), e.to()) != scc[j].end()) ++indegree[j];\n}\n}\n}\ncout << count(indegree.begin(), indegree.end(), 0) << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS = 0.01, INF = 1e12, PI = acos(-1.0);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  G ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < 1e-8; // triangle inequality\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n#include<stack>\nvoid visit(const vector<vi> &g, int v, vector<vi>& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  each(e, g[v]) {\n    int w = *e;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const vector<vi>& g,\n    vector<vi>& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint n, d;\nvector<vi> g;\n\nint main(){\n\twhile(cin >> n >> d, n || d){\n\t\tg.clear(); g.resize(n);\n\t\tvector<G> tri;\n\t\trep(i, n){\n\t\t\tint t;\n\t\t\tG p(3);\n\t\t\tdouble l[3];\n\t\t\trep(j, 3) cin >> p[j].real() >> p[j].imag();\n\t\t\trep(j, 3) l[j] = abs(p[j] - p[(j + 1) % 3]);\n\t\t\trep(j, 3) if(abs(l[j] - l[(j + 1) % 3]) < EPS){\n\t\t\t\tt = (j + 1) % 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswap(p[t], p[(t + 1) % 3]);\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\trep(i, n){\n\t\t\tG &p = tri[i];\n\t\t\tP dir = p[0] - (p[1] + p[2]) * 0.5;\n\t\t\tdir *= d / abs(dir);\n\t\t\t\n\t\t\tG ps;\n\t\t\tps.pb(p[1]); ps.pb(p[2]);\n\t\t\tps.pb(p[1] + dir); ps.pb(p[2] + dir);\n\t\t\tps = convex_hull(ps);\n\t\t\t\n\t\t\trep(j, n){\n\t\t\t\tbool ok = 0;\n\t\t\t\trep(k, 3){\n\t\t\t\t\trep(l, 4) if(distanceSP(L(ps[l], ps[(l + 1) % 4]), tri[j][k])\n\t\t\t\t\t\t< EPS) ok = 1;\n\t\t\t\t\tif(contains(ps, tri[j][k]) != OUT) ok = 1;\n\t\t\t\t}\n\t\t\t\tif(ok) g[i].pb(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tmap<int, int> to;\n\t\tvector<vi> scc;\n\t\tstronglyConnectedComponents(g, scc);\n\t\tint m = scc.size();\n\t\tvi in(m);\n\t\t\n\t\trep(i, m) rep(j, scc[i].size()){\n\t\t\tto[scc[i][j]] = i;\n\t\t}\n\t\trep(i, n) rep(j, g[i].size()){\n\t\t\tint a = to[i], b = to[g[i][j]];\n\t\t\tif(a != b) in[b]++;\n\t\t}\n\t\trep(i, m) if(in[i] == 0) ans++;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nstruct coor {\n\tdouble x, y;\n};\nstruct tri {\n\tcoor p[3];\n\tcoor rec[4];\n};\n\nint n, d;\nvector<tri> v;\nvector<vector<int> > edge;\n\nconst double EPS = 1e-9;\nconst double ERR = 1e-2;\n\ntemplate<class T>\nT sqr(T x) {\n\treturn x * x;\n}\n\ndouble dist(coor a, coor b) {\n\treturn sqrt(sqr(a.x-b.x) + sqr(a.y-b.y));\n}\n\ndouble dist_lp(coor c, coor a, coor b) {\n\tcoor v0, v1;\n\tv0.x = b.x - a.x; v0.y = b.y - a.y;\n\tv1.x = c.x - a.x; v1.y = c.y - a.y;\n\n\tif(sqr(dist(a,b)) + sqr(dist(a,c)) - sqr(dist(c,b)) > 0\n\t\t\t&& sqr(dist(a,b)) + sqr(dist(b,c)) - sqr(dist(c,a)) > 0) {\n\t\tdouble cross;\n\t\tcross = fabs(v0.x * v1.y - v0.y * v1.x);\n\t\treturn cross / dist(a,b);\n\t}\n\n\treturn min(dist(a,c), dist(b,c));\n}\n\nbool in_poly(coor p, coor poly[], int sz) {\n\tdouble sign = +0.0;\n\tfor(int i = 0; i < sz; i++) {\n\t\tcoor v0, v1;\n\t\tv0.x = poly[i].x - p.x; v0.y = poly[i].y - p.y;\n\t\tv1.x = poly[(i+1)%sz].x - p.x; v1.y = poly[(i+1)%sz].y - p.y;;\n\n\t\tif(i != 0 && sign * (v0.x * v1.y - v0.y * v1.x) < EPS*EPS) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tsign = (v0.x * v1.y - v0.y * v1.x);\n\n\t\tif(i == sz-1) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < sz; i++) {\n\t\tif(dist_lp(p,poly[i], poly[(i+1)%sz]) <= ERR + EPS) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool seg_cross(coor a, coor b, coor c, coor d) {\n\tcoor v0, v1, v2;\n\t\n\tv0.x = a.x - c.x; v0.y = a.y - c.y;\n\tv1.x = b.x - c.x; v1.y = b.y - c.y;\n\tv2.x = d.x - c.x; v2.y = d.y - c.y;\n\n\tdouble s, t;\n\ts = (v0.x * v2.y - v0.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\tt = - (v1.x * v2.y - v1.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\n\tif(s + t > 1-EPS && s > -EPS && t > -EPS) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool exist_edge(tri from, tri to) {\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(in_poly(to.p[i], from.rec, 4)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(in_poly(from.rec[i], to.p, 3)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 3; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tif(seg_cross(to.p[i], to.p[(i+1)%3], from.rec[j], from.rec[(j+1)%4])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool visited[128];\nbool touch[128];\n\nvoid check(int i, int s) {\n\tif(i != s && touch[i])\n\t\ttouch[i] = false;\n\tif(visited[i])\n\t\treturn;\n\tvisited[i] = true;\n\tfor(int j = 0; j < (int)edge[i].size(); j++) {\n\t\tcheck(edge[i][j], s);\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> d, n || d) {\n\t\tv.clear();\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tvisited[i] = touch[i] = false;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttri in;\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tcoor c;\n\t\t\t\tcin >> c.x >> c.y;\n\t\t\t\tin.p[j] = c;\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tif(fabs(dist(in.p[(0+j)%3],in.p[(1+j)%3]) - dist(in.p[(1+j)%3], in.p[(2+j)%3])) < EPS) {\n\t\t\t\t\tswap(in.p[(1+j)%3], in.p[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcoor add;\n\t\t\t//*\n\t\t\tadd.x =\t(in.p[1].x - in.p[0].x) + (in.p[1].x - in.p[2].x);\n\t\t\tadd.y = (in.p[1].y - in.p[0].y) + (in.p[1].y - in.p[2].y);\n\t\t\t// */\n\t\t\t/*\n\t\t\tint sign = -1;\n\t\t\tif((in.p[2].x - in.p[0].x)*(in.p[1].y - in.p[0].y) - (in.p[2].y - in.p[0].y)*(in.p[1].x - in.p[0].x) < 0)\n\t\t\t\tsign = 1;\n\t\t\tadd.x =\t(in.p[2].y - in.p[0].y) * sign;\n\t\t\tadd.y = -(in.p[2].x - in.p[0].x) * sign;\n\t\t\t// */\n\n\t\t\tdouble addlen;\n\t\t\taddlen = sqrt(sqr(add.x) + sqr(add.y));\n\t\t\tadd.x = add.x * d / addlen;\n\t\t\tadd.y = add.y * d / addlen;\n\n\t\t\tin.rec[0].x = in.p[0].x; in.rec[0].y = in.p[0].y;\n\t\t\tin.rec[1].x = in.p[2].x; in.rec[1].y = in.p[2].y;\n\t\t\tin.rec[2].x = in.p[2].x + add.x; in.rec[2].y = in.p[2].y + add.y;\n\t\t\tin.rec[3].x = in.p[0].x + add.x; in.rec[3].y = in.p[0].y + add.y;\n\n\t\t\tv.push_back(in);\n\t\t}\n\n\t\tfor(int i = 0; i < (int)v.size(); i++) {\n\t\t\tfor(int j = 0; j < (int)v.size(); j++) {\n\t\t\t\tif(i != j) {\n\t\t\t\t\tif(exist_edge(v[i], v[j])) {\n\t\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcout << \"*\";\n\t\t\tfor(int j = 0; j < (int)edge[i].size(); j++)\n\t\t\t\tcout << edge[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\ttouch[i] = true;\n\t\t\t\tcheck(i, i);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(touch[i])\n\t\t\t\tres++;\n\t\t}\n\t\tcout <<  res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-6;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tSegment s(curr(g, i), next(g, i));\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(s, h[j]) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tSegment s(curr(h, i), next(h, i));\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(s, g[j]) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(norm(b - a), norm(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\t\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tsqr[i].resize(4);\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-2;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nint V;\nvector<vector<int> > G,rG;\nvector<int> vs;\nbool used[100];\nint cmp[100];\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]){\n      dfs(G[v][i]);\n    }\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]){\n      rdfs(rG[v][i],k);\n    }\n  }\n}\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[2])>eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    G=rG=vector<vector<int> >(n);\n    vs.clear();\n    bool e[100][100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<-eps;\n\t      e[i][j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    e[i][j]|=!f;\n\t    if(e[i][j]){\n\t      G[i].push_back(j);\n\t      rG[j].push_back(i);\n\t    }\n\t  }\n\t}\n      }\n    }\n    V=n;\n    fill(begin(used),end(used),false);\n    for(int v=0;v<V;v++){\n      if(!used[v]){\n\tdfs(v);\n      }\n    }\n    fill(begin(used),end(used),false);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]]){\n\trdfs(vs[i],k++);\n      }\n    }\n    bool in[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(e[i][j]&&cmp[i]!=cmp[j]){\n\t  in[j]=true;\n\t}\n      }\n    }\n    cout<<count(in,in+k,false)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < (int)n; i++)\n#define EPS 0.01\n#define equals(a, b) (fabs((a) - (b)) <= EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n\n#define MAX 100\n\nclass Point{\n    public:\n    double x, y;\n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) <= EPS && fabs(y-p.y) <= EPS;\n    }\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ) { return sqrt(norm(a)); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t     ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool isInside(Polygon gon, Point p ){\n    for ( int i = 0; i < gon.size(); i++ ){\n\tif ( ccw(gon[i], gon[(i+1)%gon.size()], p) == CLOCKWISE ) return false;\n    }\n    return true;\n}\n\nclass Triangle{\n    public:\n    vector<Point> P;\n    Triangle(){ P.resize(3);}\n    void normalize(){\n\tvector<Point> tmp(3);\n\tif ( equals(norm(P[0]-P[1]), norm(P[0]-P[2])) ){\n\t    tmp[0] = P[1]; tmp[1] = P[2]; tmp[2] = P[0];\n\t} else if ( equals(norm(P[1]-P[0]), norm(P[1]-P[2])) ){\n\t    tmp[0] = P[0]; tmp[1] = P[2]; tmp[2] = P[1];\n\t} else if ( equals(norm(P[2]-P[0]), norm(P[2]-P[1])) ){\n\t    tmp[0] = P[0]; tmp[1] = P[1]; tmp[2] = P[2];\n\t}\n\tP = tmp;\n\tif ( ccw(P[0], P[1], P[2]) != COUNTER_CLOCKWISE ) swap(P[0], P[1]);\n    }\n\n    double getArea(){\n\tdouble a = abs(P[0]-P[1]); \n\tdouble b = abs(P[0]-P[2]); \n\tdouble c = abs(P[2]-P[1]); \n\tdouble s= (a + b + c)/2.0;\n\treturn sqrt(s*(s-a)*(s-b)*(s-c));\n    }\n};\n\nclass Graph{\npublic:\n    int n;\n    vector<vector<int> > adj;\n    Graph(int n = 0):n(n){\n\tadj.resize(n);\n\trep(i, n) adj[i].clear();\n    }\n    void connect(int i, int j){ adj[i].push_back(j); }\n    void transpose(){\n\tvector<vector<int> > nadj;\n\tnadj.resize(n);\n\trep(i, n) nadj[i].clear();\n\trep(i, n) rep(j, adj[i].size())\tnadj[adj[i][j]].push_back(i);\n\trep(i, n) adj[i] = nadj[i];\n    }\n};\n\nint n;\ndouble d;\nTriangle T[MAX];\n\nGraph g;\nint visited[MAX], finish[MAX], t;\nvector<int> com;\n\nbool overlapPolygon(Polygon p1, Polygon p2){\n    rep(i, p1.size()) if ( isInside(p2, p1[i]) ) return true;\n    rep(i, p2.size()) if ( isInside(p1, p2[i]) ) return true;\n    rep(i, p1.size()) rep(j, p2.size()){\n      if ( isIntersect(p1[i], p1[(i+1)%p1.size()], p2[j], p2[(j+1)%p2.size()])) return true;\n    }\n    return false;\n}\n\nbool overlap( int t1, int t2){\n    Triangle s = T[t1];\n    vector<Point> rect, tri;\n    Point c = Point((s.P[0].x+s.P[1].x)/2, (s.P[0].y+s.P[1].y)/2);\n    Vector v = s.P[2] - c;\n    double a = v.abs();\n    v.x = d*v.x/a;\n    v.y = d*v.y/a;\n    Point l = s.P[0] + v;\n    Point r = s.P[1] + v;\n    rect.push_back(s.P[1]);\n    rect.push_back(r);\n    rect.push_back(l);\n    rect.push_back(s.P[0]);\n    tri = T[t2].P;\n    return overlapPolygon(rect, tri);\n}\n\nvoid dfs(int &u){\n    visited[u] = t++;\n    rep(i, g.adj[u].size()){\n\tint v = g.adj[u][i];\n\tif ( visited[v] == -1 ) dfs(v);\n    }\n    finish[u] = t++;\n}\n\nvoid dfsT(int &u){\n    com.push_back(u);\n    visited[u] = 1;\n    rep(i, g.adj[u].size()){\n\tint v = g.adj[u][i];\n\tif ( visited[v] == 0 ) dfsT(v);\n    }\n}\n\nvoid makeGraph(){\n    g = Graph(n);\n    rep(i, n) rep(j, n)\n\tif ( i != j && overlap(i, j) )\n\t    g.connect(i, j);\n}\n\nint scc(){\n    int id[MAX];\n    bool indeg[MAX];\n\n    rep(i, n) visited[i] = finish[i] = -1;\n    t = 0;\n    rep(i, n) if ( visited[i] == -1 ) dfs(i);\n\n    g.transpose();\n    \n    vector<pair<int, int> > order;\n    rep(i, n) order.push_back(make_pair(finish[i], i));\n    sort(order.begin(), order.end());\n    \n    rep(i, n) visited[i] = 0;\n    \n    int ncom = 0;\n    \n    for ( int i = n-1; i >= 0; i-- ){\n\tint u = order[i].second;\n\tcom.clear();\n\tif ( visited[u] == 0 ) {\n\t    dfsT(u);\n\t    rep(c, com.size()) id[com[c]] = ncom;\n\t    ncom++;\n\t}\n    }\n    \n    int cnt = 0;\n    g.transpose();\n\n    rep(i, ncom) indeg[i] = false;\n    \n    rep(u, n) rep(i, g.adj[u].size()){\n\tint v = g.adj[u][i];\n\tif ( id[v] != id[u] ) indeg[id[v]] = true;\n    }\n    rep(i, ncom) if (!indeg[i]) cnt++;\n    \n    return cnt;\n}\n\nmain(){\n    while( cin >> n >> d && n ){\n\trep(i, n){\n\t    Triangle t;\n\t    rep(j, 3) cin >> t.P[j].x >> t.P[j].y;\n\t    t.normalize();\n\t    T[i] = t;\n\t}\n\tdouble a = T[0].getArea();\n\n\tfor ( int i = 0; i < n-1; i++ ){\n\t    for ( int j = i+1; j < n; j++ ){\n\t\trep(a, 3) rep(b, 3){\n\t\t    Point p1 = T[i].P[a];\n\t\t    Point p2 = T[i].P[(a+1)%3];\n\t\t    Point p3 = T[j].P[b];\n\t\t    Point p4 = T[j].P[(b+1)%3];\n\t\t}\n\t    }\n\t}\n\n\tmakeGraph();\n\tcout << scc() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-10;\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      if (     cross(a[in[0]]-a[in[1]],a[in[2]]-a[in[1]]) >=0)\n\tassert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])>=0);\n      else assert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])<=0);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      /*\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n      */\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[ j].pb(i);\n      }else if (is_intersected_polygon(tri[i],tri[j])){\n\t//\tassert(false);\n\tinedge[i].pb(j);\n\tredge[ j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-6;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tSegment s(curr(g, i), next(g, i));\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(s, h[j]) < 0.01 + EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tSegment s(curr(h, i), next(h, i));\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(s, g[j]) < 0.01 + EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs(0);\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(norm(b - a), norm(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tVector a = tri[i][1] - tri[i][0];\n\t\tVector nv = tri[i][0] + (a / 2.0);\n\t\tnv = tri[i][2] - nv;\n\t\tnv /= abs(nv);\n\t\tnv *= d;\n\t\t\n\t\tsqr[i][0] = tri[i][0];\n\t\tsqr[i][1] = tri[i][1];\n\t\tsqr[i][2] = tri[i][1] + nv;\n\t\tsqr[i][3] = tri[i][0] + nv;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tsqr[i].resize(4);\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef int Weight;\nconst Weight INF = 1 << 28;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge() {}\n\tEdge(int src, int dst, Weight weight = 1): src(src), dst(dst), weight(weight) {}\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n\nvoid addEdge(Graph &g, int src, int dst, int weight = 1)\n{\n\tg[src].push_back(Edge(src, dst, weight));\n};\n\nGraph transpose(const Graph &g)\n{\n\tGraph rg(g.size());\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\taddEdge(rg, g[i][j].dst, g[i][j].src, g[i][j].weight);\n\t\t}\n\t}\n\treturn rg;\n}\n\nstd::vector<Weight> dijkstra(const Graph &g, int src){\n\tstd::vector<Weight> dist(g.size(), INF);\n\tstd::priority_queue<std::pair<Weight, int>,\n\t                    std::vector<std::pair<Weight, int> >,\n\t\t\t\t\t\tstd::greater<std::pair<Weight, int> > > pq;\n\t\n\tdist[src] = Weight(0);\n\tpq.push(std::make_pair(Weight(0), src));\n\t\n\twhile (pq.size()){\n\t\tint cur = pq.top().second;\n\t\tWeight sum = pq.top().first;\n\t\tpq.pop();\n\t\tif (dist[cur] < sum) continue;\n\t\t\n\t\tfor (int i = 0; i < g[cur].size(); i++){\n\t\t\tconst Edge &e = g[cur][i];\n\t\t\tif (dist[e.dst] > sum + e.weight){\n\t\t\t\tdist[e.dst] = sum + e.weight;\n\t\t\t\tpq.push(std::make_pair(sum + e.weight, e.dst));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dist;\n}\n\nvoid dfs_(const Graph &g, int v, bool *used, std::vector<int> &vs)\n{\n\tused[v] = true;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) dfs_(g, to, used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs_(const Graph &g, int v, int k, bool *used, std::vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) rdfs_(g, to, k, used, cmp);\n\t}\n}\n\nint scc(const Graph &g, std::vector<int> &cmp)\n{\n\tGraph rg = transpose(g);\n\tstd::vector<int> vs;\n\tbool *used = new bool[g.size()];\n\tcmp.resize(g.size());\n\t\n\tmemset(used, false, g.size());\n\tfor (int v = 0; v < g.size(); v++){\n\t\tif (!used[v]) dfs_(g, v, used, vs);\n\t}\n\t\n\tmemset(used, false, g.size());\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs_(rg, vs[i], k++, used, cmp);\n\t}\n\t\n\tdelete used;\n\treturn k;\n}\n\n#include <bits/stdc++.h>\n\nnamespace geo {\n\n// ???????????§??????\n\ntypedef std::complex<double> Point;\n\nstruct Segment {\n\tPoint p1, p2;\n\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n};\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef std::vector<Point> Polygon;\n\n// ?????°, ??????\n\nconst double PI = acos(-1);\nconst double EPS = 1e-12;\nconst double INF = 1e12;\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE \t\t= -1;\nconst int ONLINE_BACK\t\t= 2;\nconst int ONLINE_FRONT\t\t= -2;\nconst int ON_SEGMENT\t\t= 0;\nconst int OUT\t\t\t\t= 0;\nconst int ON\t\t\t\t= 1;\nconst int IN\t\t\t\t= 2;\n\ninline double square(double a){return a * a;}\ninline bool equal(double a, double b){return std::abs(a - b) < EPS;}\ninline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\ninline double norm(const Point &a){return square(a.real()) + square(a.imag());}\ninline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\ninline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\ninline double toDeg(double t){return t / PI * 180;}\ninline double toRad(double t){return t / 180 * PI;}\n\n#define curr(v, i) v[i]\n#define next(v, i) v[(i + 1) % v.size()]\n#define prev(v, i) v[(i - 1 + (int)v.size()) % v.size()]\n\n\n// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n// ????§?????????????????????? Point rp ?????£??\\????????????\n\nbool cmpx(const Point &a, const Point &b){\n\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\treturn b.imag() < b.imag();\n}\n\nbool cmpy(const Point &a, const Point &b){\n\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\treturn a.real() < b.real();\n}\n\nPoint rp;\nbool cmparg(const Point &a, const Point &b){\n\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\tif (!equal(rada, radb)) return rada < radb;\n\treturn norm(a) < norm(b);\n}\n\n\n// ??´???, ??????\n\nbool orthgonal(const Vector &a, const Vector &b){\n\treturn equal(dot(a, b), 0.0);\n}\n\nbool parallel(const Vector &a, const Vector &b){\n\treturn equal(cross(a, b), 0.0);\n}\n\n\n// ????°?, ?°???±\n\nPoint project(const Segment &s, const Point &p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(const Segment &s, const Point &p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\n\n// ??????????????????\n\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n\n// ?????¢\n\ndouble distanceLP(const Line &l, const Point &p){\n\treturn std::abs(cross(l.p2 - l.p1, p - l.p1) / std::abs(l.p2 - l.p1));\n}\n\ndouble distanceSP(const Segment &s, const Point &p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return std::abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return std::abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\nbool intersect(const Segment &s1, const Segment &s2);\ndouble distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn std::min(\n\t\tstd::min(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\tstd::min(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t);\n}\n\n\n// ????????????\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &s){\n\t// ???????????° (0 ~ 2) ?????????\n\tdouble dist = distanceSP(s, c.p) - c.r;\n\tif (equal(dist, 0.0)) return 1;\n\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\nint intersect(const Circle &c1, const Circle &c2){\n\t// ???????????° (0 ~ 2) ?????????\n\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\tif (equal(dist, 0.0)) return 1;\n\tif (dist < 0.0) return 2;\n\treturn 0;\n}\n\n\n// ??????\n\nPoint crossPoint(const Segment &s1, const Segment &s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = std::abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = std::abs(cross(base, s1.p2 - s2.p1));\n\t\n\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\tassert(!equal(d1 + d2, 0.0));\n\t\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nstd::vector<Point> crossPoints(const Circle &c, const Line &l){\n\tstd::vector<Point> res;\n\tif (!intersect(c, l)) return res;\n\t\n\tVector pr = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / std::abs(l.p2 - l.p1);\n\tdouble base = std::sqrt(c.r * c.r - norm(pr - c.p));\n\tres.push_back(pr + e * base);\n\tres.push_back(pr - e * base);\n\tif (equalVector(res[0], res[1])) res.pop_back();\n\treturn res;\n}\n\nstd::vector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\tstd::vector<Point> res;\n\tif (!intersect(c1, c2)) return res;\n\t\n\tdouble d = std::abs(c1.p - c2.p);\n\tdouble a = std::acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\tdouble t = std::arg(c2.p - c1.p);\n\tres.push_back(c1.p + std::polar(c1.r, t + a));\n\tres.push_back(c1.p + std::polar(c1.r, t - a));\n\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\n\treturn res;\n}\n\n\n// ??????\n\nint contains(const Polygon &g, const Point &p){\n\tint n = g.size();\n\tbool res = false;\n\tfor (int i = 0; i < n; i++){\n\t\tPoint a = g[i] - p;\n\t\tPoint b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t}\n\treturn res ? IN : OUT;\n}\n\n\n// ??????\n\nPolygon convexHull(std::vector<Point> s){\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tstd::sort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\t\n\tfor (int i = 2; i < s.size(); i++){\n\t\tint n = u.size();\n\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\tu.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t\n\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\tint n = l.size();\n\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\tl.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t\n\tstd::reverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\tl.push_back(u[i]);\n\t}\n\t\n\treturn l;\n}\n\t\n\n// ???????§???¢??????\n\nPolygon convexCut(const Polygon &g, const Line &l){\n\tPolygon res;\n\tfor (int i = 0; i < g.size(); i++){\n\t\tconst Point &a = curr(g, i);\n\t\tconst Point &b = next(g, i);\n\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\tres.push_back(a);\n\t\t}\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\n}\n\nnamespace std {\nbool operator < (const geo::Point &a, const geo::Point &b){\n\treturn geo::cmpx(a, b);\n}\n}\n\nbool intersect(const geo::Polygon &g, const geo::Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tgeo::Segment s(curr(g, i), next(g, i));\n\t\t\tgeo::Segment t(curr(h, j), next(h, j));\n\t\t\tif (geo::intersect(s, t)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (geo::contains(h, curr(g, i))) return true;\n\t}\n\t\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (geo::contains(g, curr(h, i))) return true;\n\t}\n\t\n\treturn false;\n}\n\nint n;\ndouble d;\nstd::vector<geo::Polygon> tris;\nstd::vector<geo::Polygon> sqrs;\n\nvoid solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tgeo::Point &a = curr(tris[i], j),\n\t\t\t\t\t   &b = prev(tris[i], j),\n\t\t\t\t\t   &c = next(tris[i], j);\n\t\t\tif (geo::equal(std::abs(a - b), std::abs(a - c))){\n\t\t\t\tstd::swap(tris[i][j], tris[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsqrs.assign(n, geo::Polygon(4));\n\tfor (int i = 0; i < n; i++){\n\t\tgeo::Vector A = tris[i][1] - tris[i][0];\n\t\tgeo::Vector B = tris[i][2] - tris[i][0];\n\t\tgeo::Vector normal;\n\t\t\n\t\tif (geo::dot(B, A * geo::Vector(0, 1)) > geo::dot(B, A * geo::Vector(0, -1))){\n\t\t\tnormal = A * geo::Vector(0, 1) / std::abs(A) * d;\n\t\t}\n\t\telse normal = A * geo::Vector(0, -1) / std::abs(A) * d;\n\t\t\n\t\tsqrs[i][0] = tris[i][0];\n\t\tsqrs[i][1] = tris[i][1];\n\t\tsqrs[i][2] = tris[i][1] + normal;\n\t\tsqrs[i][3] = tris[i][0] + normal;\n\t}\n\t\n\tGraph g(n);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqrs[i], tris[j])){\n\t\t\t\taddEdge(g, i, j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstd::vector<int> cmp;\n\tint k = scc(g, cmp);\n\t\n\tstd::vector<int> v(k, 1);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\tint src = g[i][j].src;\n\t\t\tint dst = g[i][j].dst;\n\t\t\tif (src != dst) v[cmp[dst]] = 0;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < k; i++){\n\t\tres += v[i];\n\t}\n\t\n\tstd::printf(\"%d\\n\", res);\n}\n\nint main()\n{\n\twhile (std::scanf(\"%d %lf\", &n, &d), n){\n\t\ttris.assign(n, geo::Polygon(3));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tdouble x, y;\n\t\t\t\tstd::cin >> x >> y;\n\t\t\t\ttris[i][j] = geo::Point(x, y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-8;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nPoly tri[110];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nvector<P> convex_hull(vector<P> v){\n  int n = v.size(), k = 0;\n  sort(v.begin(),v.end());\n  vector<P> r(2*n);\n  for(int i=0;i<n;i++){\n    while(k>1 && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= EPS)k--;\n    r[k++] = v[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= EPS)k--;\n    r[k++] = v[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\nbool cross_poly(Poly a, Poly b){\n  int n1 = a.size(), n2 = b.size();\n  rep(i,n2)if(inter_pos(a,b[i]))return true;\n  rep(i,n1)if(inter_pos(b,a[i]))return true;\n  rep(i,n1)rep(j,n2)\n    if(is_cp(L(a[i],a[(i+1)%n1]),L(b[j],b[(j+1)%n2])))return true;\n  return false;\n}\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      tri[i].resize(3);\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n      tri[i] = convex_hull(tri[i]);\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]); break;\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n      rect[i] = convex_hull(rect[i]);\n    }\n\n    rep(i,n){g[i].clear(); rg[i].clear();}\n    rep(i,n){\n      rep(j,n){\n\tif(i==j)continue;\n\tif(cross_poly(rect[i],tri[j])){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n  \n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n \n#define MAX_N (128)\n#define EPS (0.01)\n#define SQ(X) ((X) * (X))\n \nusing namespace std;\n \nclass Triangle {\n    public:\n        double x[3], y[3];\n        int no;\n};\n \nclass Point {\n    public:\n        double x, y;\n         \n        Point operator - (Point &a){\n            Point ret;\n            ret.x = x - a.x;\n            ret.y = y - a.y;\n            return (ret);\n        }\n};\n \nvector<int> G[MAX_N];\nvector<int> rG[MAX_N];\nvector<int> compress[MAX_N];\nvector<int> vs;\nbool used[MAX_N];\nbool group[MAX_N];\nint cmp[MAX_N];\nint N;\n \nvoid addEdge(int from, int to)\n{\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n \nvoid dfs(int v)\n{\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++){\n        if (!used[G[v][i]]){\n            dfs(G[v][i]);\n        }\n    }\n    vs.push_back(v);\n}\n \nvoid revDfs(int v, int k)\n{\n    used[v] = true;\n    cmp[v] = k;\n    for (int i = 0; i < rG[v].size(); i++){\n        if (!used[rG[v][i]]){\n            revDfs(rG[v][i], k);\n        }\n    }\n}\n \nint scc()\n{\n    int ret;\n    memset(used, 0, sizeof(used));\n    vs.clear();\n     \n    for (int i = 0; i < N; i++){\n        if (!used[i]){\n            dfs(i);\n        }\n    }\n     \n    memset(used, 0, sizeof(used));\n     \n    ret = 0;\n    for (int i = vs.size() - 1; i >= 0; i--){\n        if (!used[vs[i]]){\n            revDfs(vs[i], ret++);\n        }\n    }\n     \n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < G[i].size(); j++){\n            if (cmp[i] != cmp[G[i][j]]){\n                compress[cmp[G[i][j]]].push_back(cmp[i]);\n            }\n        }\n    }\n     \n    return (ret);\n}\n \ndouble inProduct(Point a, Point b)\n{\n    return (a.x * b.x + a.y * b.y);\n}\n \ndouble getSize(Point a)\n{\n    return (sqrt(SQ(a.x) + SQ(a.y)));\n}\n \nbool checkCross(Point *p, Point k)\n{\n\tdouble minX, minY, maxX, maxY;\n\t\n\tmaxX = max(max(p[0].x, p[1].x), max(p[2].x, p[3].x));\n\tminX = min(min(p[0].x, p[1].x), min(p[2].x, p[3].x));\n\tmaxY = max(max(p[0].y, p[1].y), max(p[2].y, p[3].y));\n\tminY = min(min(p[0].y, p[1].y), min(p[2].y, p[3].y));\n\t\n\tbool checkX = minX - k.x <= EPS && k.x - maxX <= EPS;\n\tbool checkY = minY - k.y <= EPS && k.y - maxY <= EPS;\n    return (checkX && checkY);\n}\n \nvoid judgeAdj(Triangle a, Triangle b, double dist)\n{\n    double len;\n    Point p[4];\n     \n    len = 0.0;\n    for (int i = 0; i < 3; i++){\n        for (int j = i + 1; j < 3; j++){\n            if (len < SQ(a.x[i] - a.x[j]) + SQ(a.y[i] - a.y[j])){\n                len = SQ(a.x[i] - a.x[j]) + SQ(a.y[i] - a.y[j]);\n                p[0].x = a.x[i], p[0].y = a.y[i];\n                p[1].x = a.x[j], p[1].y = a.y[j];\n            }\n        }\n    }\n    //printf(\"%lf %lf %lf %lf\\n\", p[0].x, p[0].y, p[1].x, p[1].y);\n    Point e, sa;\n     \n    e.x = 0, e.y = 1;\n    sa = p[1] - p[0];\n    double theta = acos(inProduct(e, sa) / (getSize(e) * getSize(sa)));\n    //theta = min(theta, M_PI - theta);\n    //printf(\"theta = %lf\\n\", theta);\n     \n    p[2].x = p[0].x + dist * cos(theta), p[2].y = p[0].y + dist * sin(theta);\n    p[3].x = p[1].x + dist * cos(theta), p[3].y = p[1].y + dist * sin(theta);\n     \n    bool cross = false;\n     \n    for (int i = 0; i < 3; i++){\n\t\tPoint k;\n        k.x = b.x[i], k.y = b.y[i];\n\t\tcross |= checkCross(p, k);\n    }\n     \n    if (cross == true){\n        //printf(\"hoge, %d, %d\\n\", a.no, b.no);\n        addEdge(a.no, b.no);\n    }\n     \n}\n \nint main()\n{\n    int n, d;\n    Triangle data[128];\n     \n    while (1){\n        scanf(\"%d%d\", &n, &d);\n         \n        N = n;\n        if (n + d == 0){\n            break;\n        }\n         \n        for (int i = 0; i < n; i++){\n            data[i].no = i;\n            for (int j = 0; j < 3; j++){\n                scanf(\"%lf%lf\", &data[i].x[j], &data[i].y[j]);\n            }\n        }\n         \n        for (int i = 0; i < n; i++){\n            G[i].clear();\n            rG[i].clear();\n            compress[i].clear();\n        }\n         \n        for (int i = 0; i < n; i++){\n            for (int j = 0; j < n; j++){\n                if (i != j){\n                    judgeAdj(data[i], data[j], d);\n                }\n            }\n        }\n         \n        int k = scc();\n         \n        int ans = 0;\n        memset(used, 0, sizeof(used));\n         \n        for (int i = 0; i < k; i++){\n            if (compress[i].size() == 0){\n                ans++;\n            }\n        }\n         \n        printf(\"%d\\n\", ans);\n    }\n     \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-2;\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      //if (     cross(a[in[0]]-a[in[1]],a[in[2]]-a[in[1]]) >=0)\n      //\tassert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])>=0);\n      //      else assert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])<=0);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  //assert(false);\n  return ret;\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<-eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <-eps))return true;\n  else return false;\n}\n\n#define DSS distance_ls_p\ndouble distance_ss_p(P a,P b,P c,P d){\n  return min(  min( DSS(a,b,c),DSS(a,b,d)),min(DSS(c,d,a),DSS(c,d,b)));\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri,double d){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }else {\n\trep(k,tri[j].size()){\n\t  if (is_in(tri[i],tri[j][k])&&\n\t      (distance_ss_p(sq[i][0],sq[i][1],tri[j][0],tri[j][1])<d+eps ||\n\t       distance_ss_p(sq[i][0],sq[i][1],tri[j][1],tri[j][2])<d+eps||\n\t       distance_ss_p(sq[i][0],sq[i][1],tri[j][2],tri[j][0])<d+eps)\n\t      ){\n\t    assert(false);\n\t    inedge[i].pb(j);\n\t    redge[j].pb(i);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in,d);\n\n\n    //rep(i,n){rep(j,sq[i].size())cout<< sq[i][j];cout << endl;}\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-5;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < 1e-10){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      break;\n    }\n  }while(next_permutation(in,in+3));\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,postorder[i].order);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-5;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n\tcross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n\t( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-8)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) * SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G &a, G &b)\n{\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)) return true;\n\t\t}\n\t}\n\tfor (int i = 0; i < a.size(); i++){\n\t\tif (contains(b, a[i])) return true;\n\t}\n\tfor (int i = 0; i < b.size(); i++){\n\t\tif (contains(a, b[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) res++;\n\t\tused[i] = true;\n\t\tfor (int to : sccgraph[i]){\n\t\t\tused[to] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct coor {\n\tdouble x, y;\n};\nstruct tri {\n\tcoor p[3];\n\tcoor rec[4];\n};\n\nint n, d;\nvector<tri> v;\nvector<vector<int> > edge;\n\nconst double EPS = 1e-9;\nconst double ERR = 1e-2;\n\ntemplate<class T>\nT sqr(T x) {\n\treturn x * x;\n}\n\ndouble dist(coor a, coor b) {\n\treturn sqrt(sqr(a.x-b.x) + sqr(a.y-b.y));\n}\n\ndouble dist_lp(coor c, coor a, coor b) {\n\tcoor v0, v1;\n\tv0.x = b.x - a.x; v0.y = b.y - a.y;\n\tv1.x = c.x - a.x; v1.y = c.y - a.y;\n\n\tif(sqr(dist(a,b)) + sqr(dist(a,c)) - sqr(dist(c,b)) > 0\n\t\t\t&& sqr(dist(a,b)) + sqr(dist(b,c)) - sqr(dist(c,a)) > 0) {\n\t\tdouble cross;\n\t\tcross = fabs(v0.x * v1.y - v0.y * v1.x);\n\t\treturn cross / dist(a,b);\n\t}\n\n\treturn min(dist(a,c), dist(b,c));\n}\n\nbool in_poly(coor p, coor poly[], int sz) {\n\tdouble sign = +0.0;\n\tfor(int i = 0; i < sz; i++) {\n\t\tcoor v0, v1;\n\t\tv0.x = poly[i].x - p.x; v0.y = poly[i].y - p.y;\n\t\tv1.x = poly[(i+1)%sz].x - p.x; v1.y = poly[(i+1)%sz].y - p.y;;\n\n\t\tif(i != 0 && sign * (v0.x * v1.y - v0.y * v1.x) < EPS) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tsign = (v0.x * v1.y - v0.y * v1.x);\n\n\t\tif(i == sz-1) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < sz; i++) {\n\t\tif(dist_lp(p,poly[i], poly[(i+1)%sz]) <= ERR + EPS) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool seg_cross(coor a, coor b, coor c, coor d) {\n\tcoor v0, v1, v2;\n\t\n\tv0.x = a.x - c.x; v0.y = a.y - c.y;\n\tv1.x = b.x - c.x; v1.y = b.y - c.y;\n\tv2.x = d.x - c.x; v2.y = d.y - c.y;\n\n\tdouble s, t;\n\ts = (v0.x * v2.y - v0.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\tt = - (v1.x * v2.y - v1.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\n\tif(s + t > 1-EPS && s > -EPS && t > -EPS) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool exist_edge(tri from, tri to) {\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(in_poly(to.p[i], from.rec, 4))\n\t\t\treturn true;\n\t}\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(in_poly(from.rec[i], to.p, 3))\n\t\t\treturn true;\n\t}\n\n\tfor(int i = 0; i < 3; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tif(seg_cross(to.p[i], to.p[(i+1)%3], from.rec[j], from.rec[(j+1)%4]))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool visited[128];\nbool touch[128];\n\nvoid check(int i, int s) {\n\tif(i != s && touch[i])\n\t\ttouch[i] = false;\n\tif(visited[i])\n\t\treturn;\n\tvisited[i] = true;\n\tfor(int j = 0; j < edge[i].size(); j++) {\n\t\tcheck(edge[i][j], s);\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> d, n || d) {\n\t\tv.clear();\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tvisited[i] = touch[i] = false;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttri in;\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tcoor c;\n\t\t\t\tcin >> c.x >> c.y;\n\t\t\t\tin.p[j] = c;\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tif(fabs(dist(in.p[(0+j)%3],in.p[(1+j)%3]) - dist(in.p[(1+j)%3], in.p[(2+j)%3])) < EPS) {\n\t\t\t\t\tswap(in.p[(1+j)%3], in.p[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcoor add;\n\t\t\tadd.x =\t(in.p[1].x - in.p[0].x) + (in.p[1].x - in.p[2].x);\n\t\t\tadd.y = (in.p[1].y - in.p[0].y) + (in.p[1].y - in.p[2].y);\n\n\t\t\tdouble addlen;\n\t\t\taddlen = sqrt(sqr(add.x) + sqr(add.y));\n\t\t\tadd.x = add.x * d / addlen;\n\t\t\tadd.y = add.y * d / addlen;\n\n\t\t\tin.rec[0].x = in.p[0].x; in.rec[0].y = in.p[0].y;\n\t\t\tin.rec[1].x = in.p[2].x; in.rec[1].y = in.p[2].y;\n\t\t\tin.rec[2].x = in.p[2].x + add.x; in.rec[2].y = in.p[2].y + add.y;\n\t\t\tin.rec[3].x = in.p[0].x + add.x; in.rec[3].y = in.p[0].y + add.y;\n\n\t\t\tv.push_back(in);\n\t\t}\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\t\tif(i != j) {\n\t\t\t\t\tif(exist_edge(v[i], v[j])) {\n\t\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint i_ = (i+5)%n;\n\t\t\tif(!visited[i_]) {\n\t\t\t\ttouch[i_] = true;\n\t\t\t\tcheck(i_, i_);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(touch[i])\n\t\t\t\tres++;\n\t\t}\n\t\tcout <<  res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<stack>\n#include<complex>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nconst double EPS = 0.05;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > EPS)   return +1;       // counter clockwise\n  if (cross(b, c) < EPS)   return -1;       // clockwise\n\tassert(0);\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)+EPS) swap(a, b);\n    if (imag(a) < -EPS && EPS < imag(b))\n      if (cross(a, b) < -EPS) in = !in;\n    if (abs(cross(a, b)) < EPS  && dot(a, b) < EPS) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) < EPS &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) < EPS;\n}\nbool intersect(G &rect, G &tri){\n\trep(i,3)if(contains(rect,tri[i]))return 1;\n\trep(i,3){\n\t\tL l(tri[i],tri[(i+1)%3]);\n\t\trep(j,4)if(intersectSS(l,L(rect[i],rect[(i+1)%4])))return 1;\n\t}\n\treturn 0;\n}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight=0) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid visit(const Graph &g, int v, vector< vector<int> >& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  fr(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const Graph& g,\n    vector< vector<int> >& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint main(){\n\tint n;\n\tdouble d;\n\twhile(cin>>n>>d,n){\n\t\tvector<G> tri;\n\t\trep(i,n){\n\t\t\tdouble a,b,c,d,e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tG p; p.pb(P(a,b)); p.pb(P(c,d)); p.pb(P(e,f));\n\t\t\tif(abs(abs(p[2]-p[0])-abs(p[2]-p[1]))>EPS){\n\t\t\t\tif(abs(abs(p[2]-p[0])-abs(p[1]-p[0]))<EPS)swap(p[2],p[0]);\n\t\t\t\telse swap(p[1],p[0]);\n\t\t\t}\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\tGraph e(n);\n\t\t\n\t\trep(i,n)rep(j,n)if(i!=j){\n\t\t\t\n\t\t\tG &p=tri[i];\n\t\t\tP m=(p[0]+p[1])*0.5,dir=(p[2]-m)*(d/abs(p[2]-m));\n\t\t\t\n\t\t\tG rect;\n\t\t\trect.pb(p[0]); rect.pb(p[1]);\n\t\t\trect.pb(p[1]+dir); rect.pb(p[0]+dir);\n\t\t\tif(ccw(rect[0],rect[1],rect[2])<0)reverse(rect.begin(),rect.end());\n\t\t\t\n\t\t\tif(intersect(rect,tri[j]))e[i].pb(Edge(i,j));\n\t\t}\n\t\t\n\t\tvector<vector<int> > scc;\n\t\tstronglyConnectedComponents(e,scc);\n\t\tint m=scc.size(),to[100],in[100]={0},ans=0;\n\t\trep(i,m)fr(j,scc[i])to[*j]=i;\n\t\trep(i,n)fr(j,e[i])if(to[i]!=to[j->dst])\n\t\tin[to[j->dst]]++;\n\t\t\n\t\trep(i,m)if(in[i]==0)ans++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-2)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) * SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nbool mergeIfAble(S &s1, S s2){\n\tif (!parallel(s1, s2)) return false;\n\tif (abs(ccw(s1.p1, s2.p1, s1.p2)) == 1) return false;\n\tif (ccw(s1.p1, s1.p2, s2.p1) == ONLINE_FRONT ||\n\t\tccw(s2.p1, s2.p2, s1.p1) == ONLINE_FRONT){\n\t\treturn false;\n\t}\n\ts1 = S(min(s1.p1, s2.p1), max(s1.p2, s2.p2));\n\treturn true;\n}\nvoid merge(vector<S> &ss){\n\tfor (int i = 0; i < ss.size(); i++){\n\t\tif (ss[i].p2 < ss[i].p1){\n\t\t\tswap(ss[i].p1, ss[i].p2);\n\t\t}\n\t}\n\tfor (int i = 0; i < ss.size(); i++){\n\t\tfor (int j = i + 1; j < ss.size(); j++){\n\t\t\tif (mergeIfAble(ss[i], ss[j])){\n\t\t\t\tss[j--] = ss.back();\n\t\t\t\tss.pop_back();\n\t\t\t}\n\t\t}\n\t}\n}\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\nG convexHull(vector<P> s){\n\tif (s.size() < 3) return s;\n\tG u, l;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tfor (int i = 2; i < s.size(); i++){\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\tl.push_back(u[i]);\n\t}\n\treturn l;\n}\n\nGraph SArrangement(const vector<S> &ss, vector<P> &ps){\n\tfor (int i = 0; i < ss.size(); i++){\n\t\tps.push_back(ss[i].p1);\n\t\tps.push_back(ss[i].p2);\n\t\tfor (int j = i + 1; j < ss.size(); j++){\n\t\t\tif (intersectSS(ss[i], ss[j])){\n\t\t\t\tps.push_back(crossP(ss[i], ss[j]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(ps.begin(), ps.end());\n\tps.erase(unique(ps.begin(), ps.end()), ps.end());\n\tGraph g(ps.size());\n\tfor (int i = 0; i < ss.size(); i++){\n\t\tvector<pair<D, int> > v;\n\t\tfor (int j = 0; j < ps.size(); j++){\n\t\t\tif (PonS(ss[i], ps[j])){\n\t\t\t\tv.push_back(make_pair(norm(ss[i].p1 - ps[i]), j));\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tfor (int j = 0; j < (int)v.size() - 1; j++){\n\t\t\tint a = v[j].second, b = v[j + 1].second;\n\t\t\tD c = abs(ps[a] - ps[b]);\n\t\t\tg[a].push_back(Edge(b, c));\n\t\t\tg[b].push_back(Edge(a, c));\n\t\t}\n\t}\n\treturn g;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G a, G b)\n{\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)) return true;\n\t\t}\n\t\tif (contains(b, a[i])) return true;\n\t}\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) res++;\n\t\tfor (int to : sccgraph[i]){\n\t\t\tused[to] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <cassert>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nconst double EPS = 0.01;\n\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\n \ndouble area(vector<P> p){\n\tdouble S = 0 ; \n\tp.push_back(p[0]);\n\t/*　多角形の面積公式 (反時計回りの場合) */\n\tfor(int i = 0 ; i < p.size()-1 ; i++){\n\t\tS += (p[i].real() - p[i+1].real()) * (p[i].imag()+p[i+1].imag());\n\t}\n\tS /= 2.0;\n\treturn S;\n}\nbool contains(vector<P> &a,P b){\n\t//b = (-10000,-10000);\n\tdouble ans = 0;\n\tfor(int i = 0 ; i < a.size() ; i++){\n\t\tvector<P> w;\n\t\tw.push_back(a[i]);\n\t\tw.push_back(a[(i+1)%a.size()]);\n\t\tw.push_back(b);\n\t\tans += abs(area(w));\n\t}\n\tans = abs(ans);\n\t//cout << a[0] << \" \" << a[1] << \" \" << a[2] << \" \" << a[3] << \" \" << b << \" \" << (fabs(abs(area(a)) - ans ) < EPS) << endl;\n\t//cout << ans << \" \" << abs(area(a)) << \" \" << a.size() << endl;\n\treturn fabs(abs(area(a)) - ans ) < EPS;\n}\n\n/*\n\t幾何: \n\t\t・凸多角形の点包含判定\n\t\t・凸多角形同士の線分交差判定\n\tグラフ:\n\t\t・強連結成分分解\n\t\t・入次数数える\n*/\n\nint N;\n\n\nbool eq(double a,double b){\n\treturn fabs(a-b) < 1e-9;\n}\n\nint done[100] ={};\nint wf[100][100]={};\n\nint dfs(int pos){\n\tif( done[pos] ) return 0;\n\telse done[pos] = 1;\n\tfor(int i = 0 ; i < 100 ; i++){\n\t\tif(wf[pos][i])dfs(i);\n\t}\n}\nint main(){\n\tint n;\n\tdouble d;\n\twhile(cin >> n >> d && n ){\n\t\tmemset(done,0,sizeof(done));\n\t\tmemset(wf,0,sizeof(wf));\n\t\t\n\t\tvector<G> g(n);\n\t\tvector<G> g2(n);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x1,x2,x3,y1,y2,y3;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\t\tg[i].push_back(P(x1,y1));\n\t\t\tg[i].push_back(P(x2,y2));\n\t\t\tg[i].push_back(P(x3,y3));\n\t\t\tdouble A = abs( P(x2,y2) - P(x1,y1) );\n\t\t\tdouble B = abs( P(x2,y2) - P(x3,y3) );\n\t\t\tdouble C = abs( P(x3,y3) - P(x1,y1) );\n\t\t\tL l(P(-1,-1),P(-1,-1));\n\t\t\tif( eq(A,B) ) l = L( P(x3,y3) , P(x1,y1) );\n\t\t\telse if( eq(A,C) ) l = L( P(x2,y2) , P(x3,y3) );\n\t\t\telse if( eq(B,C) ) l = L( P(x2,y2) , P(x1,y1) );\n\t\t\telse while(1){}\n\t\t\t\n\t\t\tP r = l[1] - l[0];\n\t\t\tr = P(-r.imag(),r.real());\n\t\t\tr /= abs(r);\n\t\t\t\n\t\t\t//cout << A << \" \" << B << \" \" << C << \" \" << l[0] << \"-\" << l[1] << \" \" << r << endl;\n\t\t\tfor(int coef = -1 ; coef <= 1 ; coef += 2 ){\n\t\t\t\tvector<P> XX;\n\t\t\t\tXX.push_back(l[0]);\n\t\t\t\tXX.push_back(l[0] + coef * d * r );\n\t\t\t\tXX.push_back(l[1] + coef * d * r );\t\t\t\n\t\t\t\tXX.push_back(l[1]);\n\t\t\t\tint ok = 1;\n\t\t\t\t\n\t\t\t\tfor(int j = 0 ; j < 3 ; j++){\n\t\t\t\t\tif( !contains(XX,g[i][j]) ){\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( ok ) {\n\t\t\t\t\tif( g2[i].size() ) assert(0);\n\t\t\t\t\tg2[i] = XX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif( i != j ) {\n\t\t\t\t\tint ok = 0;\n\t\t\t\t\tfor(int l = 0 ; l < 3 ; l++){\n\t\t\t\t\t\tif( contains(g2[i],g[j][l]) ){\n\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0 ; k < 4 ; k++){\n\t\t\t\t\t\tfor(int l = k+1 ; l < 4 ; l++){\n\t\t\t\t\t\t\tfor(int m = 0 ; m < 3 ; m++){\n\t\t\t\t\t\t\t\tfor(int o = m+1 ; o < 3 ; o++){\n\t\t\t\t\t\t\t\t\tif( intersectSS(L(g2[i][k],g2[i][l]),L(g[j][m],g[j][o])) ){\n\t\t\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( ok ) {\n\t\t\t\t\t\twf[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\t\tfor(int k = 0 ; k < n ; k++)\n\t\t\t\t\twf[j][k] |= wf[j][i] & wf[i][k];\n\t\tint in[100] = {};\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif(wf[i][j]) in[j]++;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif( !done[i] && !in[i] ){\n\t\t\t\tdfs(i);\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif( !done[i] ){\n\t\t\t\tdfs(i);\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-10;\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      if (     cross(a[in[0]]-a[in[1]],a[in[2]]-a[in[1]]) >=0)\n\tassert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])>=0);\n      else assert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])<=0);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n      rep(k,tri[j].size()){\n\tif (is_in(tri[i],tri[j][k])){\n\t  inedge[i].pb(j);\n\t  redge[j].pb(i);\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n\n\n    //rep(i,n){rep(j,sq[i].size())cout<< sq[i][j];cout << endl;}\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-3\n;\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      //if (     cross(a[in[0]]-a[in[1]],a[in[2]]-a[in[1]]) >=0)\n      //\tassert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])>=0);\n      //      else assert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])<=0);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  //assert(false);\n  return ret;\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<-eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <-eps))return true;\n  else return false;\n}\n\n#define DSS distance_ls_p\ndouble distance_ss_p(P a,P b,P c,P d){\n  return min(  min( DSS(a,b,c),DSS(a,b,d)),min(DSS(c,d,a),DSS(c,d,b)));\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri,double d){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }else {\n\trep(k,tri[j].size()){\n\t  if (is_in(tri[i],tri[j][k])&&\n\t      (distance_ss_p(sq[i][0],sq[i][1],tri[j][0],tri[j][1])<d+eps ||\n\t       distance_ss_p(sq[i][0],sq[i][1],tri[j][1],tri[j][2])<d+eps||\n\t       distance_ss_p(sq[i][0],sq[i][1],tri[j][2],tri[j][0])<d+eps)\n\t      ){\n\t    assert(false);\n\t    inedge[i].pb(j);\n\t    redge[j].pb(i);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in,d);\n\n\n    //rep(i,n){rep(j,sq[i].size())cout<< sq[i][j];cout << endl;}\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<unordered_map>\n#define eps 1e-9\nusing namespace std;\n\ntypedef complex<double> point;\ntypedef pair<point, point> pp;\n\n//??????\ndouble dot(point a, point b){\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\n//??????\ndouble cross(point a, point b){\n  return imag(conj(a) * b);\n}\n\n//counter clock wise\nint ccw(point a, point b, point c){\n  if(cross(b - a, c - a) >  eps)return  1;//??????ab????????´\n  if(cross(b - a, c - a) < -eps)return -1;//??????ab????????´\n  if(dot(b - a, c - a) < -eps)return 2;//??´???ab??????a???????????????\n  if(abs(b - a) + eps < abs(c - a))return -2;//??´???ab??????b???????????????\n  return 0;//??´???ab???\n}\ntypedef struct door{\n  double r;\n  point x, y, z, p;\n  point rot(point p, double theta){\n    return point(p.real()*cos(theta) +\n                 p.imag()*sin(theta),\n                 -p.real()*sin(theta) +\n                 p.imag()*cos(theta));\n  }\n  void rectangle(){\n    p = y - x;\n    if(ccw(x, y, z) == -1){\n      p = rot(p, M_PI/2.0);\n    }else if(ccw(x, y, z) == 1){\n      p = rot(p, -M_PI/2.0);\n    }\n    p *= r/abs(p);\n  }\n}door;\n\nbool isCover(door from, door to){\n  point p[4];\n  p[0] = from.x;\n  p[1] = from.y;\n  p[2] = from.y + from.p;\n  p[3] = from.x + from.p;\n  int f = ccw(p[0], p[1], to.x);\n  bool flag = true;\n  for (int i = 1; i < 4; i++) {\n    if(ccw(p[i], p[(i + 1)%4], to.x) != f and\n       ccw(p[i], p[(i + 1)%4], to.x) != 0)\n      flag = false;\n  }\n  if(flag)return true;\n  f = ccw(p[0], p[1], to.y);\n  for (int i = 1; i < 4; i++) {\n    if(ccw(p[i], p[(i + 1)%4], to.y) != f and\n       ccw(p[i], p[(i + 1)%4], to.y) != 0)\n      return false;\n  }\n  return true;\n}\n\nvoid dfs(vector<vector<int> > &g,\n         vector<int> &vs, int v, bool* used){\n  used[v] = true;\n  for (int i = 0; i < g[v].size(); i++) {\n    if(not used[g[v][i]])dfs(g, vs, g[v][i], used);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(vector<vector<int> > &rg,\n          vector<int> &cmp, int v, int k, bool* used){\n  used[v] = true;\n  cmp[v] = k;\n  for (int i = 0; i < rg[v].size(); i++) {\n    if(not used[rg[v][i]])\n      rdfs(rg, cmp, rg[v][i], k, used);\n  }\n}\n\nvector<vector<int> > scc(vector<vector<int> > &g,\n                         vector<vector<int> > &rg){\n  bool used[g.size()];\n  memset(used, false, sizeof(used));\n  vector<int> vs, cmp(g.size(), -1);\n  for (int i = 0; i < g.size(); i++) {\n    if(not used[i])dfs(g, vs, i, used);\n  }\n  memset(used, false, sizeof(used));\n  int k = 0;\n  for (int i = vs.size() -  1; i >= 0; i--) {\n    if(not used[vs[i]]) rdfs(rg, cmp, vs[i], k++, used);\n  }\n  unordered_map<int, int> hash;\n  for (int i = 0; i < cmp.size(); i++) {\n    hash[i] = cmp[i];\n  }\n  vector<vector<int> > res(hash.size());\n  for (int i = 0; i < g.size(); i++) {\n    for (int j = 0; j < g[i].size(); j++) {\n      res[hash[g[i][j]]].push_back(hash[i]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n, r;\n  while(std::cin >> n >> r, n){\n    door d[n];\n    for (int i = 0; i < n; i++) {\n      int a, b;\n      std::cin >> a >> b;\n      d[i].x = point(a, b);\n    \n      std::cin >> a >> b;\n      d[i].y = point(a, b);\n    \n      std::cin >> a >> b;\n      d[i].z = point(a, b);\n      d[i].r = r;\n      d[i].rectangle();\n    }\n    vector<vector<int> > g(n), rg(n);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if(isCover(d[i], d[j])){\n          g[i].push_back(j);\n          rg[j].push_back(i);\n        }\n      }\n    }\n    vector<vector<int> > dag = scc(g, rg);\n    int ans = 0;\n    for (int i = 0; i < dag.size(); i++) {\n      if(dag[i].size() == 0)ans++;\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-2;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[2])>eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    bool c[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<-eps;\n\t      c[j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    c[j]|=!f;\n\t  }\n\t}\n      }\n    }\n    cout<<max<int>(1,count(c,c+n,false))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass UnionFindTree\n{\n    vector<int> parent; // em[h\n    vector<int> rank;   // ØÌ³ÌãÀ\n    int find(int x){\n        if(parent[x] == x)\n            return x;\n        return parent[x] = find(parent[x]);\n    }\npublic:\n    UnionFindTree(int n){ // RXgN^\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        rank.assign(n, 0);\n    }\n    void unite(int x, int y){ // xÆyÌO[vð¹\n        if((x = find(x)) != (y = find(y))){\n            if(rank[x] < rank[y])\n                parent[x] = y;\n            else{\n                parent[y] = x;\n                if(rank[x] == rank[y])\n                    ++ rank[x];\n            }\n        }\n    }\n    bool same(int x, int y){ // xÆyÌO[vª¯¶©ð²×é\n        return find(x) == find(y);\n    }\n    int num(){ // O[vÌðÔ·\n        vector<bool> root(parent.size(), false);\n        for(unsigned i=0; i<parent.size(); ++i)\n            root[find(i)] = true;\n        return count(root.begin(), root.end(), true);\n    }\n};\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\ndouble segmentPointDist(const Point& a1, const Point& a2, const Point& p)\n{\n    if((a2-a1).dot(p-a1) < 0)\n        return a1.dist(p);\n    else if((a1-a2).dot(p-a2) < 0)\n        return a2.dist(p);\n    else\n        return abs((a2-a1).cross(p-a1)) / a1.dist(a2);\n}\n\ndouble segmentsDist(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) < -EPS) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) < -EPS))\n        return 0.0;\n\n    double ret = segmentPointDist(a1, a2, b1);\n    ret = min(ret, segmentPointDist(a1, a2, b2));\n    ret = min(ret, segmentPointDist(b1, b2, a1));\n    ret = min(ret, segmentPointDist(b1, b2, a2));\n    return ret;\n}\n\nbool convexContain(const vector<Point>& cp, const Point& p)\n{\n    int n = cp.size();\n    bool ret1 = true;\n    bool ret2 = true;\n    for(int i=0; i<n; ++i){\n        double a = (cp[(i+1)%n] - cp[i]).cross(p - cp[i]);\n        if(a < -EPS)\n            ret1 = false;\n        if(a > EPS)\n            ret2 = false;\n    }\n    return ret1 || ret2;\n}\n\nbool polygonsCollide(const vector<Point>& cp1, const vector<Point>& cp2)\n{\n    int n = cp1.size();\n    int m = cp2.size();\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<m; ++j){\n            if(segmentsDist(cp1[i], cp1[(i+1)%n], cp2[j], cp2[(j+1)%m]) < 0.01 + EPS)\n                return true;\n        }\n    }\n\n    return convexContain(cp1, cp2[0]) || convexContain(cp2, cp1[0]);\n}\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Point> > p(n, vector<Point>(3));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<3; ++j){\n                cin >> p[i][j].x >> p[i][j].y;\n            }\n            if(p[i][0].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][1], p[i][2]);\n            if(p[i][1].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][0], p[i][2]);\n        }\n\n        UnionFindTree uft(n);\n        vector<bool> check(n, false);\n        for(int i=0; i<n; ++i){\n            Point v = p[i][1] - p[i][0];\n            v = v / v.length() * d;\n            swap(v.y, v.x);\n            v.y *= -1;\n            if(v.dot(p[i][2] - p[i][0]) < 0)\n                v = v * -1;\n\n            vector<Point> p1(4);\n            p1[0] = p[i][0];\n            p1[1] = p[i][0] + v;\n            p1[2] = p[i][1] + v;\n            p1[3] = p[i][1];\n\n            for(int j=0; j<n; ++j){\n                if(j == i)\n                    continue;\n                if(polygonsCollide(p1, p[j])){\n                    uft.unite(i, j);\n                    check[j] = true;\n                }\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            if(!check[i])\n                ++ ret;\n            else{\n                bool b = true;\n                for(int j=0; j<n; ++j){\n                    if(uft.same(i, j) && !check[j])\n                        b = false;\n                }\n                if(b)\n                    ++ ret;\n                check[i] = false;\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,postorder[i].order);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n\tcross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n\t( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass UnionFindTree\n{\n    vector<int> parent; // em[h\n    vector<int> rank;   // ØÌ³ÌãÀ\n    int find(int x){\n        if(parent[x] == x)\n            return x;\n        return parent[x] = find(parent[x]);\n    }\npublic:\n    UnionFindTree(int n){ // RXgN^\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        rank.assign(n, 0);\n    }\n    void unite(int x, int y){ // xÆyÌO[vð¹\n        if((x = find(x)) != (y = find(y))){\n            if(rank[x] < rank[y])\n                parent[x] = y;\n            else{\n                parent[y] = x;\n                if(rank[x] == rank[y])\n                    ++ rank[x];\n            }\n        }\n    }\n    bool same(int x, int y){ // xÆyÌO[vª¯¶©ð²×é\n        return find(x) == find(y);\n    }\n    int num(){ // O[vÌðÔ·\n        vector<bool> root(parent.size(), false);\n        for(unsigned i=0; i<parent.size(); ++i)\n            root[find(i)] = true;\n        return count(root.begin(), root.end(), true);\n    }\n};\n\nconst double EPS = 1.0e-3;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\ndouble segmentPointDist(const Point& a1, const Point& a2, const Point& p)\n{\n    if((a2-a1).dot(p-a1) < 0)\n        return a1.dist(p);\n    else if((a1-a2).dot(p-a2) < 0)\n        return a2.dist(p);\n    else\n        return abs((a2-a1).cross(p-a1)) / a1.dist(a2);\n}\n\ndouble segmentsDist(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) < -EPS) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) < -EPS))\n        return 0.0;\n\n    double ret = segmentPointDist(a1, a2, b1);\n    ret = min(ret, segmentPointDist(a1, a2, b2));\n    ret = min(ret, segmentPointDist(b1, b2, a1));\n    ret = min(ret, segmentPointDist(b1, b2, a2));\n    return ret;\n}\n\nbool convexContain(const vector<Point>& cp, const Point& p)\n{\n    int n = cp.size();\n    bool ret1 = true;\n    bool ret2 = true;\n    for(int i=0; i<n; ++i){\n        double a = (cp[(i+1)%n] - cp[i]).cross(p - cp[i]);\n        if(a < -EPS)\n            ret1 = false;\n        if(a > EPS)\n            ret2 = false;\n    }\n    return ret1 || ret2;\n}\n\nbool polygonsCollide(const vector<Point>& cp1, const vector<Point>& cp2)\n{\n    int n = cp1.size();\n    int m = cp2.size();\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<m; ++j){\n            if(segmentsDist(cp1[i], cp1[(i+1)%n], cp2[j], cp2[(j+1)%m]) < 0.01 + EPS)\n                return true;\n        }\n    }\n\n    return convexContain(cp1, cp2[0]) || convexContain(cp2, cp1[0]);\n}\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Point> > p(n, vector<Point>(3));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<3; ++j){\n                cin >> p[i][j].x >> p[i][j].y;\n            }\n            if(p[i][0].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][1], p[i][2]);\n            if(p[i][1].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][0], p[i][2]);\n            if((p[i][1] - p[i][0]).cross(p[i][2] - p[i][0]) < 0)\n                swap(p[i][0], p[i][1]);\n        }\n\n        UnionFindTree uft(n);\n        vector<bool> check(n, false);\n        for(int i=0; i<n; ++i){\n            Point v = p[i][1] - p[i][0];\n            v = v / v.length() * d;\n            swap(v.y, v.x);\n            v.x *= -1;\n\n            vector<Point> p1(4);\n            p1[0] = p[i][0];\n            p1[1] = p[i][0] + v;\n            p1[2] = p[i][1] + v;\n            p1[3] = p[i][1];\n\n            for(int j=0; j<n; ++j){\n                if(j == i)\n                    continue;\n                if(polygonsCollide(p1, p[j])){\n                    uft.unite(i, j);\n                    check[j] = true;\n                }\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            if(!check[i])\n                ++ ret;\n            else{\n                bool b = true;\n                for(int j=0; j<n; ++j){\n                    if(uft.same(i, j) && !check[j])\n                        b = false;\n                }\n                if(b)\n                    ++ ret;\n                check[i] = false;\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-10;\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      //if (     cross(a[in[0]]-a[in[1]],a[in[2]]-a[in[1]]) >=0)\n      //\tassert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])>=0);\n      //      else assert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])<=0);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  //assert(false);\n  return ret;\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\n#define DSS distance_ls_p\ndouble distance_ss_p(P a,P b,P c,P d){\n  return min(  min( DSS(a,b,c),DSS(a,b,d)),min(DSS(c,d,a),DSS(c,d,b)));\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri,double d){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n      rep(k,tri[j].size()){\n\tif (is_in(tri[i],tri[j][k])&&\n\t    (distance_ss_p(sq[i][0],sq[i][1],tri[j][0],tri[j][1])<d+eps ||\n\t     distance_ss_p(sq[i][0],sq[i][1],tri[j][1],tri[j][2])<d+eps||\n\t     distance_ss_p(sq[i][0],sq[i][1],tri[j][2],tri[j][0])<d+eps)\n\t    ){\n\t  //assert(false);\n\t  inedge[i].pb(j);\n\t  redge[j].pb(i);\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in,d);\n\n\n    //rep(i,n){rep(j,sq[i].size())cout<< sq[i][j];cout << endl;}\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-2)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) + SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G &a, G &b)\n{\t\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a.size(); i++){\n\t\tif (contains(b, a[i])){\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int i = 0; i < b.size(); i++){\n\t\tif (contains(a, b[i])){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tvector<int> toi(V);\n\tfor (int i = 0; i < V; i++){\n\t\ttoi[tps[i]] = i;\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) res++;\n\t\tfor (int to : sccgraph[tps[i]]){\n\t\t\tused[toi[to]] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define EPS 1e-8\n#define DEB 0\n\ntypedef complex<double> P;\n\nint n,d,cnt,num[128];\nint edge[128][128],redge[128][128];\nint visi[128],revisi[128];\n\nclass Triangle{\n  public:\n\tvector<P> v,sikaku;\n};\n\nTriangle data[100];\n\ndouble cross(P a, P b){\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\ndouble dot(P a, P b){\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\n\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif( cross(a,b)>EPS ) return 1;  //left\n\tif( cross(a,b)<-EPS ) return -1;  //right\n\tif( dot(a,b)<-EPS ) return 2;\n\tif( abs(a) < abs(b) ) return -2;\n\treturn 0;\n}\nbool isinside(vector<P>& v, vector<P>& s){\n\trep(i,v.size()){\n\t\trep(j,s.size()){\n\t\t\tif( ccw(s[j],s[(j+1)%4],v[i])!=-1 ) return false;\n\t\t}\n\t}\n\treturn true;\n}\nbool isintersept(P a1, P a2, P b1, P b2){\n\treturn ( ccw(a1,a2,b1)*ccw(a1,a2,b2)<=0 &&\n\t\t\t ccw(b1,b2,a1)*ccw(b1,b2,a2)<=0 );\n}\n\nbool ok(vector<P>& v , vector<P>& s){\n\trep(i,s.size()){\n\t\trep(j,v.size()){\n\t\t\tif( isintersept(s[i],s[(i+1)%4],v[j],v[(j+1)%3]) ) return true;\n\t\t}\n\t}\n\treturn isinside(v,s);\n}\n\nvoid dfs(int node){\n\trep(i,n)if( !visi[i] && edge[node][i]>0 ){\n\t\tvisi[i] = 1;\n\t\tdfs(i);\n\t}\n\tnum[cnt++] = node;\n\treturn;\n}\n\nvoid dfs_t(int node){\n\trep(i,n)if( !revisi[i] && redge[node][i]>0 ){\n\t\trevisi[i] = 1;\n\t\tdfs_t(i);\n\t}\n}\n\n\nint main(){\n\n\twhile(scanf(\"%d%d\",&n,&d),n|d){\n\t\tcnt = 0;\n\t\trep(i,128)visi[i]=revisi[i]=num[i]=0;\n\t\trep(i,128)rep(j,128)edge[i][j]=redge[i][j]=0;\n\t\trep(i,100){\n\t\t\tdata[i].v.clear();\n\t\t\tdata[i].sikaku.clear();\n\t\t}\n\t\t\t  \n\t\trep(i,n){\n\t\t\tint x[3],y[3];\n\t\t\tscanf(\"%d%d%d%d%d%d\",x,y,x+1,y+1,x+2,y+2);\n\t\t\trep(j,3){\n\t\t\t\tint x1 = x[(j+1)%3] - x[j];\n\t\t\t\tint y1 = y[(j+1)%3] - y[j];\n\t\t\t\tint x2 = x[(j+2)%3] - x[(j+1)%3];\n\t\t\t\tint y2 = y[(j+2)%3] - y[(j+1)%3];\n\t\t\t\tif( x1*x1+y1*y1 == x2*x2+y2*y2 ){\n#if DEB\n\t\t\t\t\tprintf(\"j:%d\\n\",j);\n#endif\n\n\t\t\t\t\tP p0 = P(x[j], y[j]);\n\t\t\t\t\tP p1 = P(x[(j+2)%3], y[(j+2)%3]);\n\t\t\t\t\tP p2 = P(x[(j+1)%3], y[(j+1)%3]);\n\t\t\t\t\tif( ccw(p0,p1,p2)==1 ){\n\t\t\t\t\t\tP tmp = (p1-p0)*P(0,1);\n\t\t\t\t\t\ttmp = tmp/abs(tmp) * P(d,0);\n#if DEB\n\t\t\t\t\t\tprintf(\"ccw==1\\n\");\n\t\t\t\t\t\tcout << tmp << endl;\n\n\t\t\t\t\t\tcout << p0+tmp << endl;\n\t\t\t\t\t\tcout << p1+tmp << endl;\n#endif\n\n\t\t\t\t\t\t//p0,(p0+tmp),(p1+tmp),p1\n\n\t\t\t\t\t\tdata[i].v.push_back(p0);\n\t\t\t\t\t\tdata[i].v.push_back(p2);\n\t\t\t\t\t\tdata[i].v.push_back(p1);\n\t\t\t\t\t\tdata[i].sikaku.push_back(p0);\n\t\t\t\t\t\tdata[i].sikaku.push_back(p0+tmp);\n\t\t\t\t\t\tdata[i].sikaku.push_back(p1+tmp);\n\t\t\t\t\t\tdata[i].sikaku.push_back(p1);\n\n#if DEB\n\t\t\t\t\t\trep(k,4){\n\t\t\t\t\t\t\tcout << \":: \" << data[i].sikaku[k] << endl;\n\t\t\t\t\t\t}\n#endif\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}else if( ccw(p0,p1,p2)==-1 ){\n\t\t\t\t\t\tP tmp = (p0-p1)*P(0,1);\n\t\t\t\t\t\ttmp = tmp/abs(tmp) * P(d,0);\n#if DEB\n\t\t\t\t\t\tputs(\"ccw==-1\");\n\t\t\t\t\t\tcout << tmp << endl;\n\t\t\t\t\t\tcout << p0+tmp << endl;\n\t\t\t\t\t\tcout << p1+tmp << endl;\n#endif\n\t\t\t\t\t\t//p1,(p1+tmp),(p0+tmp),p0\n\n\t\t\t\t\t\tdata[i].v.push_back(p1);\n\t\t\t\t\t\tdata[i].v.push_back(p2);\n\t\t\t\t\t\tdata[i].v.push_back(p0);\n\t\t\t\t\t\tdata[i].sikaku.push_back(p1);\n\t\t\t\t\t\tdata[i].sikaku.push_back(p1+tmp);\n\t\t\t\t\t\tdata[i].sikaku.push_back(p0+tmp);\n\t\t\t\t\t\tdata[i].sikaku.push_back(p0);\n\t\t\t\t\t\t\n\t\t\t\t\t}else{\n\t\t\t\t\t\tputs(\"error\"); exit(0);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i,n){\n\t\t\trep(j,n)if( i!=j ){\n\t\t\t\tif( ok(data[j].v, data[i].sikaku) ){\n\t\t\t\t\tedge[i][j] = 1;\n\t\t\t\t\tredge[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#if DEB\n\t\tputs(\"normal\");\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tprintf(\"%d \",edge[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\tputs(\"\\nreverse\");\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tprintf(\"%d \",redge[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n#endif\n\n\t\tcnt = 0;\n\t\trep(i,n)if( !visi[i] ){\n\t\t\tvisi[i] = 1;\n\t\t\tdfs(i);\n\t\t}\n#if DEB\n\t\tputs(\"num\");\n\t\trep(i,n){\n\t\t\tprintf(\"num[%d]:%d\\n\",i,num[i]);\n\t\t}\n#endif\t\t\n\t\tint ans = 0;\n\t\tmemset(visi,0,sizeof(visi));\n\t\tfor(int i=cnt-1; i>=0; i--)if( !visi[num[i]] ){\n\t\t\tvisi[num[i]] = 1;\n\t\t\tans++;\n\t\t\tdfs(num[i]);\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-1;\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      //if (     cross(a[in[0]]-a[in[1]],a[in[2]]-a[in[1]]) >=0)\n      //\tassert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])>=0);\n      //      else assert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])<=0);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  //assert(false);\n  return ret;\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<-eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <-eps))return true;\n  else return false;\n}\n\n#define DSS distance_ls_p\ndouble distance_ss_p(P a,P b,P c,P d){\n  return min(  min( DSS(a,b,c),DSS(a,b,d)),min(DSS(c,d,a),DSS(c,d,b)));\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri,double d){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }else {\n\trep(k,tri[j].size()){\n\t  if (is_in(tri[i],tri[j][k])&&\n\t      (distance_ss_p(sq[i][0],sq[i][1],tri[j][0],tri[j][1])<d+eps ||\n\t       distance_ss_p(sq[i][0],sq[i][1],tri[j][1],tri[j][2])<d+eps||\n\t       distance_ss_p(sq[i][0],sq[i][1],tri[j][2],tri[j][0])<d+eps)\n\t      ){\n\t    assert(false);\n\t    inedge[i].pb(j);\n\t    redge[j].pb(i);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in,d);\n\n\n    //rep(i,n){rep(j,sq[i].size())cout<< sq[i][j];cout << endl;}\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct coor {\n\tdouble x, y;\n};\nstruct tri {\n\tcoor p[3];\n\tcoor rec[4];\n};\n\nint n, d;\nvector<tri> v;\nvector<vector<int> > edge;\n\nconst double EPS = 1e-9;\nconst double ERR = 1e-2;\n\ntemplate<class T>\nT sqr(T x) {\n\treturn x * x;\n}\n\ndouble dist(coor a, coor b) {\n\treturn sqrt(sqr(a.x-b.x) + sqr(a.y-b.y));\n}\n\ndouble dist_lp(coor c, coor a, coor b) {\n\tcoor v0, v1;\n\tv0.x = b.x - a.x; v0.y = b.y - a.y;\n\tv1.x = c.x - a.x; v1.y = c.y - a.y;\n\n\tif(sqr(dist(a,b)) + sqr(dist(a,c)) - sqr(dist(c,b)) > 0\n\t\t\t&& sqr(dist(a,b)) + sqr(dist(b,c)) - sqr(dist(c,a)) > 0) {\n\t\tdouble cross;\n\t\tcross = fabs(v0.x * v1.y - v0.y * v1.x);\n\t\treturn cross / dist(a,b);\n\t}\n\n\treturn min(dist(a,c), dist(b,c));\n}\n\nbool in_poly(coor p, coor poly[], int sz) {\n\tdouble sign = +0.0;\n\tfor(int i = 0; i < sz; i++) {\n\t\tcoor v0, v1;\n\t\tv0.x = poly[i].x - p.x; v0.y = poly[i].y - p.y;\n\t\tv1.x = poly[(i+1)%sz].x - p.x; v1.y = poly[(i+1)%sz].y - p.y;;\n\n\t\tif(i != 0 && sign * (v0.x * v1.y - v0.y * v1.x) < EPS) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tsign = (v0.x * v1.y - v0.y * v1.x);\n\n\t\tif(i == sz-1) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < sz; i++) {\n\t\tif(dist_lp(p,poly[i], poly[(i+1)%sz]) <= ERR + EPS) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool seg_cross(coor a, coor b, coor c, coor d) {\n\tcoor v0, v1, v2;\n\t\n\tv0.x = a.x - c.x; v0.y = a.y - c.y;\n\tv1.x = b.x - c.x; v1.y = b.y - c.y;\n\tv2.x = d.x - c.x; v2.y = d.y - c.y;\n\n\tdouble s, t;\n\ts = (v0.x * v2.y - v0.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\tt = - (v1.x * v2.y - v1.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\n\tif(s + t > 1-EPS && s > -EPS && t > -EPS) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool exist_edge(tri from, tri to) {\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(in_poly(to.p[i], from.rec, 4))\n\t\t\treturn true;\n\t}\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(in_poly(from.rec[i], to.p, 3))\n\t\t\treturn true;\n\t}\n\n\tfor(int i = 0; i < 3; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tif(seg_cross(to.p[i], to.p[(i+1)%3], from.rec[j], from.rec[(j+1)%4]))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool visited[128];\nbool touch[128];\n\nvoid check(int i, int s) {\n\tif(i != s && touch[i])\n\t\ttouch[i] = false;\n\tif(visited[i])\n\t\treturn;\n\tvisited[i] = true;\n\tfor(int j = 0; j < edge[i].size(); j++) {\n\t\tcheck(edge[i][j], s);\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> d, n || d) {\n\t\tv.clear();\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tvisited[i] = touch[i] = false;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttri in;\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tcoor c;\n\t\t\t\tcin >> c.x >> c.y;\n\t\t\t\tin.p[j] = c;\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tif(fabs(dist(in.p[(0+j)%3],in.p[(1+j)%3]) - dist(in.p[(1+j)%3], in.p[(2+j)%3])) < ERR) {\n\t\t\t\t\tswap(in.p[(1+j)%3], in.p[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcoor add;\n\t\t\tadd.x =\t(in.p[1].x - in.p[0].x) + (in.p[1].x - in.p[2].x);\n\t\t\tadd.y = (in.p[1].y - in.p[0].y) + (in.p[1].y - in.p[2].y);\n\n\t\t\tdouble addlen;\n\t\t\taddlen = sqrt(sqr(add.x) + sqr(add.y));\n\t\t\tadd.x = add.x * d / addlen;\n\t\t\tadd.y = add.y * d / addlen;\n\n\t\t\tin.rec[0].x = in.p[0].x; in.rec[0].y = in.p[0].y;\n\t\t\tin.rec[1].x = in.p[2].x; in.rec[1].y = in.p[2].y;\n\t\t\tin.rec[2].x = in.p[2].x + add.x; in.rec[2].y = in.p[2].y + add.y;\n\t\t\tin.rec[3].x = in.p[0].x + add.x; in.rec[3].y = in.p[0].y + add.y;\n\n\t\t\tv.push_back(in);\n\t\t}\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\t\tif(i != j) {\n\t\t\t\t\tif(exist_edge(v[i], v[j])) {\n\t\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint i_ = (i+5)%n;\n\t\t\tif(!visited[i_]) {\n\t\t\t\ttouch[i_] = true;\n\t\t\t\tcheck(i_, i_);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(touch[i])\n\t\t\t\tres++;\n\t\t}\n\t\tcout <<  res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst double EPS = 0.01;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\n// int contains(const polygon& P, const point& p) {\n// \tbool in = false;\n// \tfor (int i = 0; i < P.size(); ++i) {\n// \t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n// \t\tif (imag(a) > imag(b)) swap(a, b);\n// \t\tif (imag(a) <= 0 && 0 < imag(b))\n// \t\t\tif (cross(a, b) < 0) in = !in;\n// \t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n// \t}\n// \treturn in ? IN : OUT;\n// }\nint contains(const G& pol, const P& p){\n\tif(pol.size() < 2) return OUT;\n\tif(intersectSP({pol[0], pol[1]}, p)) return ON;\n\tbool f = cross(pol[1]-pol[0], p - pol[0]) > 0;\n\tfor(int i = 1; i < pol.size(); i++) {\n\t\tauto& now = pol[i];\n\t\tauto& nxt = pol[(i+1) % pol.size()];\n\t\tif(intersectSP({nxt, now}, p)) return ON;\n\t\tif(f^(cross(nxt-now, p-now)>0)) return OUT;\n\t}\n\treturn IN;\n}\n\n\n//????????´???????£???????????????????(??????????????£???????????????)\nenum{NO_HIT=0, HIT, A_IN_B, B_IN_A};\nint HitPol_Pol(const polygon& a, const polygon& b){\n\tbool f = true, hit = false;\n\trep(i, a.size()){\n\t\tif(contains(b, a[i]) == OUT) f = false;\n\t\telse hit = true;\n\t}\n\tif(f) return A_IN_B;\n\tf = true;\n\trep(i, b.size()){\n\t\tif(contains(a, b[i]) == OUT) f = false;\n\t\telse hit = true;\n\t}\n\tif(f) return B_IN_A;\n\tif(hit) return HIT;\n\trep(i, a.size()) rep(j, b.size()){\n\t\tL la(curr(a, i), next(a, i)), lb(curr(b, j), next(b, j));\n\t\tif(intersectSS(la, lb)) return HIT;\n\t}\n\treturn NO_HIT;\n}\n//point???theta???????????¢\npoint spinP(const point& p, double theta){\n\treturn p*complex<double>(cos(theta),sin(theta));\n}\npoint spinPExtend(const point& p, double theta, double rate){\n\treturn p*complex<double>(rate*cos(theta),rate*sin(theta));\n}\n\nstruct SCC{//O(V+E)\n    static const int MAX_V = 1010;\n    int V;\n    vector<int> G[MAX_V], rG[MAX_V];\n    vector<int> vs;\n    bool used[MAX_V];\n    int cmp[MAX_V];\n    vector<vector<int> > res;\n \n \n    SCC(int v) : V(v){};\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n \n    void dfs(int v){\n        used[v] = true;\n        for(int i = 0; i < G[v].size(); i++){\n            if(!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v] = true;\n        cmp[v] = k;\n        for(int i = 0; i < rG[v].size(); i++){\n            if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n \n    int scc(){\n        memset(used, 0, sizeof(used));\n        vs.clear();\n        for(int v = 0; v < V; v++){\n            if(!used[v]) dfs(v);\n        }\n        memset(used, 0, sizeof(used));\n        int k = 0;\n        for(int i = vs.size() - 1; i >= 0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++);\n        }\n \n        res.clear();\n        res.resize(k);\n        for(int i = 0; i < V; i++){\n            res[cmp[i]].push_back(i);\n        }\n        return k;\n    }\n};\n\nint main(){\n\tint n, d;\n\twhile(cin >> n >> d && (n+d)){\n\t\tvector<polygon> tri(n);\n\t\trep(i, n){\n\t\t\tdouble x, y;\n\t\t\trep(j, 3){\n\t\t\t\tcin >> x >> y;\n\t\t\t\ttri[i].pb({x, y});\n\t\t\t}\n\t\t}\n\t\tvector<polygon> pol(n);\n\t\trep(i, n){\n\t\t\tdouble dist[3];\n\t\t\trep(j, 3){\n\t\t\t\tdist[j] = abs(curr(tri[i], j)-next(tri[i], j));\n\t\t\t}\n\t\t\trep(j, 3) {\n\t\t\t\tif(abs(dist[j] - dist[(j+1)%3])<1e-8){\n\t\t\t\t\tpol[i].pb(tri[i][j]);\n\t\t\t\t\tpol[i].pb(tri[i][(j+2)%3]);\n\t\t\t\t\tpol[i].pb(spinPExtend(pol[i][0]-pol[i][1], (ccw(pol[i][1], pol[i][0], tri[i][(j+1)%3])> 0)?PI/2:-PI/2, d/abs(pol[i][1]-pol[i][0]))+pol[i][1]);\n\t\t\t\t\tpol[i].pb(pol[i][2]+pol[i][0]-pol[i][1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSCC scc(n);\n\t\trep(i, n) rep(j, i){\n\t\t\tif(HitPol_Pol(pol[i], tri[j])!=NO_HIT) scc.add_edge(i, j);\n\t\t\tif(HitPol_Pol(tri[i], pol[j])!=NO_HIT) scc.add_edge(j, i);\n\t\t}\n\t\tscc.scc();\n\t\tvector<int> f(scc.res.size(), 1);\n\t\trep(i, n) rep(j, i){\n\t\t\tif(scc.cmp[i] == scc.cmp[j]) continue;\n\t\t\tif(HitPol_Pol(pol[i], tri[j])!=NO_HIT) f[scc.cmp[j]] = 0;\n\t\t\telse if(HitPol_Pol(tri[i], pol[j])!=NO_HIT) f[scc.cmp[i]] = 0;\n\t\t}\n\t\tcout<<accumulate(all(f), 0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cfloat>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define EPS (1e-8)\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint ( double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n\tPoint operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n\tPoint operator * ( double a ){ return Point(x*a, y*a); }\n\tdouble abs() { return sqrt(norm());}\n\tdouble norm() { return x*x + y*y; }\n\tbool operator < ( const Point &p ) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == ( const Point &p ) const {\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs(Vector a) {return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b) {return (sqrt(norm(a - b)));}\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\ndouble eq(double a, double b)\n{\n\treturn (fabs(a - b) <= EPS);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n//3点の位置関係を求める\nint ccw( Point p0, Point p1, Point p2 ){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( norm(a) < norm(b) ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//A = p2 - p1, B = p4 - p3が交差するか\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n\n\n//多角形の中に点があるか\nbool isInside(Polygon gon, Point p ){\n\tfor ( int i = 0; i < gon.size(); i++ ){\n\t\tif ( ccw(gon[i], gon[(i+1)%gon.size()], p) == CLOCKWISE ) return (false);\n\t}\n\treturn (true);\n}\n\n//単位ベクトルを求める\nPoint unitVector(Point t){\n\tdouble u=abs(t);\n\treturn Point(t.x/u , t.y/u);\n}\n//cosθを求める\ndouble getcos(Point a , Point b){\n\treturn (dot(a,b) / (abs(a)*abs(b)));\n}\n\n//sinθを求める\ndouble getsin(Point a , Point b){\n\tdouble t=getcos(a,b);\n\treturn sqrt(1.0-t*t);\n}\n\n//点pと直線abとの距離を求める\ndouble pld(Point p , Point a , Point b){\n\treturn fabs(cross(b - a,p - a))/abs(b-a);\n}\n\n//点pと線分abとの距離を求める\ndouble psd(Point p , Point a , Point b){\n\tif( dot( b-a , p-a ) < EPS) return abs(p-a);\n\tif( dot( a-b , p-b ) < EPS) return abs(p-b);\n\treturn fabs(cross( b-a , p-a )) / abs(b-a);\n}\n\n//線分交点計算\nPoint interpointS(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint b=b2-b1;\n\tdouble d1=fabs(cross(b , a1-b1));\n\tdouble d2=fabs(cross(b , a2-b1));\n\tdouble t=d1 / (d1 + d2);\n\tPoint a=a2-a1;\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線交点計算\nPoint interpointL(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint a=a2-a1;\n\tPoint b=b2-b1;\n\tdouble t=cross(b , b1-a1) / cross(b , a);\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線abと円及び球 |x-c|=rの交点を求める 　球の場合は型Point→Sに変更するだけ\nvoid interpointLC(Point a , Point b , Point c , double r , Point ans[]){\n\tif(pld(c , a , b) > r + EPS) return;\n\tPoint v=unitVector(b-a);\n\tdouble delta=dot(v,a-c)*dot(v,a-c)-abs(a-c)*abs(a-c)+r*r;\n\tdouble t=-dot(v,a-c);\n\tdouble s=sqrt(delta);\n\tans[0]=a+v*(t+s);\n\tans[1]=a+v*(t-s);\n}\n\n//１次変換集\n\n//ｘ（y=k）に関する対象変換 　k=0でｘ軸による変換\nPoint xTranslate(Point t,double k){\n\treturn Point(t.x , 2*k-t.y);\n}\n\n//ｙ(x=k)に関する対象変換\tk=0でｙ軸による変換\nPoint yTranslate(Point t,double k){\n\treturn Point(2*k-t.x , t.y);\n}\n\n//点Point kに関する対象変換\t\tPoint(0,0)で原点による変換\nPoint oTranslate(Point t,Point k){\n\treturn k+(k-t);\n}\n\n\n\n\n\n//点pを中心としてr(radian)回転\t\tp(0,0)で原点を中心として回転\nPoint rotate(Point t , Point p , double r){\n\t//double r=radians(angle);\n\tdouble ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n\tdouble tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n\treturn Point(ta , tb);\n}\n\n//応用\n//２円 |x-a|=raと|x-b|=rbの交点計算\nvoid interpointCC(Point a , double ra , Point b , double rb , Point ans[]){\n\tdouble di=fabs(abs(a-b));\n\tif(di > ra+rb || di < fabs(ra-rb)) return;\n\tdouble t=(ra*ra-rb*rb+di*di)/(di+di);\n\tdouble rd=acos(t/ra);\n\n\tPoint dv=unitVector(b-a);\n\tPoint g1=rotate(dv , Point(0,0) , rd);\n\tPoint g2=rotate(dv , Point(0,0) , -rd);\n\tans[0]=a+g1*ra;\n\tans[1]=a+g2*ra;\n}\n\n//法線ベクトルを求める\nPoint normalVector(Point p,Point a,Point b){\n\tPoint v=unitVector(b-a);\n\tv = cross(v , p-a) > 0 ?  Point(v.y,(-1)*v.x) : Point((-1)*v.y , v.x);\n\treturn v*pld(p,a,b);\n}\n\n//直線abに関する対象変換\nPoint fTranslate(Point t , Point a , Point b){\n\treturn t+normalVector(t,a,b)*2;\n}\n\n//３角形の面積を求める\ndouble area(Point a, Point b, Point c){\n\treturn fabs(cross(c-a , b-a)*0.5);\n}\n\n//多角形の面積を求める //凸包のソート済みが前提\ndouble polygonArea(Polygon t){\n\tdouble ans=0.0;\n\tfor(unsigned int i=0;i<t.size();i++)\n\t\tans+=cross(t[i] , t[(i+1)%t.size()]);\n\treturn ans/2;\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = static_cast<int>(ps.size());\n    Polygon qs(n * 2);\n    for (int i = 0; i < n; ++i) {\n      while (k > 1 && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    for (int i = n-2, t = k; i >= 0; --i) {\n      while (k > t && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    qs.resize(k-1);\n    return qs;\n}\n\nPolygon tri[100];\nint n, d;\n\nbool isIn(Polygon a, Polygon b)\n{\n\tfor (int i = 0; i < a.size(); i++) if (isInside(b, a[i])) return (true);\n\tfor (int i = 0; i < b.size(); i++) if (isInside(a, b[i])) return (true);\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tif (isIntersect(a[i], a[(i + 1) % a.size()], b[j], b[(j + 1) % b.size()])) return (true);\n\t\t}\n\t}\t\n\treturn (false);\n}\n\nbool check(Polygon a, Polygon b)\n{\n\tdouble di[3];\n\tfor (int i = 0; i < 3; i++){\n\t\tdi[i] = abs(a[i] - a[(i + 1) % 3]);\n\t}\n\t\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\tif (eq(di[i], di[j])){\n\t\t\t\tint cnt[3] = {0};\n\t\t\t\tcnt[i]++; cnt[(i + 1) % 3]++;\n\t\t\t\tcnt[j]++; cnt[(j + 1) % 3]++;\n\t\t\t\tfor (int k = 0; k < 3; k++){\n\t\t\t\t\tif (cnt[k] == 2){\n\t\t\t\t\t\tswap(a[k], a[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPolygon c;\n\tc.push_back(a[0]); c.push_back(a[1]);\n\t\n\tPoint t = Point((a[0].x + a[1].x) / 2, (a[0].y + a[1].y) / 2);\n\tPoint k = a[2] - t;\n\tc.push_back(a[1] + k * (d / abs(k))); c.push_back(a[0] + k * (d / abs(k)));\n\t\n\treturn (isIn(c, b));\n}\n\nvector<int> G[128], rG[128];\nint ord[128], gr[128];\nbool vis[128];\nint ctr;\n\nvoid addEdge(int src, int dst)\n{\n\tG[src].push_back(dst);\n\trG[dst].push_back(src);\n}\n\nvoid dfs1(int v)\n{\n\tvis[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tif (!vis[G[v][i]]) dfs1(G[v][i]);\n\t}\n\tord[ctr++] = v;\n}\n\nvoid dfs2(int v, int k)\n{\n\tvis[v] = true;\n\tgr[v] = k;\n\tfor (int i = 0; i < rG[v].size(); i++){\n\t\tif (!vis[rG[v][i]]) dfs2(rG[v][i], k);\n\t}\n\t\n}\n\nint scc()\n{\n\tmemset(vis, 0, sizeof(vis));\n\tctr = 0;\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!vis[i]){\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\tint k = 0;\n\tmemset(vis, 0, sizeof(vis));\n\tfor (int i = n - 1; i >= 0; i--){\n\t\tif (!vis[ord[i]]){\n\t\t\tdfs2(ord[i], k++);\n\t\t}\n\t}\n\t\n\tint ret = k;\n\tmemset(vis, 0, sizeof(vis));\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < G[i].size(); j++){\n\t\t\tif (gr[i] != gr[G[i][j]]){\n\t\t\t\tret -= (1 ^ vis[gr[G[i][j]]]);\n\t\t\t\tvis[gr[G[i][j]]] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (ret);\n}\n\nint main()\n{\n\tPoint t;\n\twhile (scanf(\"%d %d\", &n, &d) && n + d){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tscanf(\"%lf %lf\", &t.x, &t.y);\n\t\t\t\ttri[i].push_back(Point(t.x, t.y));\n\t\t\t}\n\t\t\tG[i].clear(); rG[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (i != j && check(tri[i], tri[j])){\n\t\t\t\t\taddEdge(i, j);\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\t\n\t\t\n\t\tprintf(\"%d\\n\", scc());\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "// The Last Door\n\n#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値, Polygonのメンバ変数\n#include<algorithm> // min(), sort(), reverse()\n\nconst double EPS = 1e-10;\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\nclass Polygon;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    const Point normalize() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n    void print() const;\n};\nbool operator==(const Point& lhs, const Point& rhs);\nbool operator!=(const Point& lhs, const Point& rhs);\nbool operator<(const Point& lhs, const Point& rhs);\nbool operator>(const Point& lhs, const Point& rhs);\nbool operator<=(const Point& lhs, const Point& rhs);\nbool operator>=(const Point& lhs, const Point& rhs);\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Segment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Segment&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Segment&) const;\n    bool orthogonal(const Line&) const;\n    POSITION ccw(const Point&) const;\n    void print() const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Line(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Segment&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Segment&) const;\n    bool orthogonal(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n    void print() const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool in(const Point&) const;\n    bool out(const Point&) const;\n    bool include(const Point&) const;\n    bool include(const Segment&) const;\n    bool include(const Line&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    std::vector<Point> crosspoint(const Circle&) const;\n    void print() const;\n};\nclass Polygon {\n    std::vector<Point> point;\npublic:\n    Polygon() {}\n    explicit Polygon(std::vector<Point> p) :point(p) {}\n    const std::vector<Point>& vertex() const {return point;}\n    const Point& vertex(int i) const {return point.at(i);}\n    const std::vector<Segment> edge() const {\n        std::vector<Segment> result;\n        for(int i = 0; i < size(); ++i) result.push_back(Segment(vertex(i), vertex((i + 1) % size())));\n        return result;\n    }\n    const Segment edge(int i) const {return Segment(vertex(i), vertex((i + 1) % size()));}\n    int size() const {return point.size();}\n    void add(const Point&);\n    double area() const;\n    bool convex() const;\n    bool include(const Point&) const;\n    bool intersect(const Polygon&) const;\n    bool on_edge(const Point&) const;\n    const Polygon convex_hull() const;\n    void print() const;\n};\n// Point\nbool operator==(const Point& lhs, const Point& rhs) {return lhs.x() == rhs.x() && lhs.y() == rhs.y();}\nbool operator!=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() || lhs.y() != rhs.y();}\nbool operator<(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() < rhs.y();}\nbool operator>(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() > rhs.y();}\nbool operator<=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() <= rhs.y();}\nbool operator>=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() >= rhs.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\nconst Point Point::normalize() const {return abs() == 0.0 ? Point(0.0, 0.0) : Point(x(), y()) / abs();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return COUNTER_CLOCKWISE;\n    if(v1.cross(v2) < -EPS) return CLOCKWISE;\n    if(v1.dot(v2) < -EPS) return ONLINE_BACK;\n    if(v2.norm() - v1.norm() > EPS) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nvoid Point::print() const {std::cout << x() << \", \" << y() << std::endl;}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    return std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    return std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nbool Segment::parallel(const Line& l) const {line().parallel(l);}\nbool Segment::parallel(const Segment& s) const {return line().parallel(s.line());}\nbool Segment::orthogonal(const Line& l) const {return line().orthogonal(l);}\nbool Segment::orthogonal(const Segment& s) const {return line().orthogonal(s.line());}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\nvoid Segment::print() const {std::cout << \"source: \"; source().print(); std::cout << \"target: \"; target().print();}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nbool Line::parallel(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dxl - dyl * dx) <= EPS;\n}\nbool Line::parallel(const Segment& s) const {return parallel(s.line());}\nbool Line::orthogonal(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dyl + dxl * dx) <= EPS;\n}\nbool Line::orthogonal(const Segment& s) const {return orthogonal(s.line());}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) return l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\nvoid Line::print() const {std::cout << \"source: \"; source().print(); std::cout << \"target: \"; target().print();}\n// Circle\nbool Circle::in(const Point& p) const {return center().distance(p) < r() - EPS;}\nbool Circle::out(const Point& p) const {return r() + EPS < center().distance(p);}\nbool Circle::include(const Point& p) const {return center().distance(p) <= r() + EPS;}\nbool Circle::include(const Segment& s) const {return center().distance(s) <= r() + EPS;}\nbool Circle::include(const Line& l) const {return center().distance(l) <= r() + EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) <= r() - c.r() + EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) <= r() + c.r() + EPS;}\nstd::vector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    std::vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\nvoid Circle::print() const {std::cout << \"radius: \" << r() << \" - point: \"; center().print();}\n// Polygon\nvoid Polygon::add(const Point& p) {point.push_back(p);}\ndouble Polygon::area() const {\n    double sum = 0.0;\n    for(int i = 0; i < size(); ++i) sum += vertex(i).cross(vertex((i+1) % size()));\n    return fabs(sum) / 2.0;\n}\nbool Polygon::convex() const {\n    POSITION direction = ONLINE_BACK;\n    for(int i = 1; i < size(); ++i) {\n        POSITION d = vertex(i - 1).ccw(vertex(i), vertex((i + 1) % size()));\n        if(d != CLOCKWISE && d != COUNTER_CLOCKWISE) continue;\n        if(direction == ONLINE_BACK) direction = d;\n        if(direction != d) return false;\n    }\n    return true;\n}\nbool Polygon::include(const Point& p) const {\n    bool in = false;\n    for(int i = 0; i < size(); ++i) {\n        Point a = vertex(i) - p;\n        Point b = vertex((i + 1) % size()) - p;\n        if(a.y() > b.y()) std::swap(a, b);\n        if(a.y() <= 0.0 && 0 < b.y() && a.cross(b) < 0.0) in = !in;\n        if(fabs(a.cross(b)) <= EPS && a.dot(b) <= EPS) return true;\n    }\n    return in;\n}\nbool Polygon::intersect(const Polygon& p) const {\n    for(const auto& e1: edge()) for(const auto& e2: p.edge()) if(e1.intersect(e2)) return true;\n    return false;\n}\nbool Polygon::on_edge(const Point& p) const {\n    for(int i = 0; i < size(); ++i) if(vertex(i).ccw(vertex((i + 1) % size()), p) == ON_SEGMENT) return true;\n    return false;\n}\nconst Polygon Polygon::convex_hull() const {                // Andrew's Monotone Chain\n    Polygon result;\n    std::vector<Point> res;\n    std::vector<Point> original = vertex();\n    sort(original.begin(), original.end());\n    original.insert(original.end(), original.rbegin() + 1, original.rend());\n    for(const auto& v: original) {\n        while(res.size() >= 2 && res[res.size() - 2].ccw(res[res.size() - 1], v) == CLOCKWISE) res.pop_back();\n        res.push_back(v);\n    }\n    res.pop_back();\n    for(const auto& v: res) result.add(v);\n    return result;\n}\nvoid Polygon::print() const {for(const auto& v: vertex()) std::cout << v.x() << \", \" << v.y() << std::endl;}\n\n////////////////////////////////////////////////////////////////////////////////\n\nusing namespace std;\n\nint main() {\n    int n, d;\n    while(cin >> n >> d, n | d) {\n        vector<Polygon> triangle(n);\n        for(auto &t: triangle) {\n            vector<Point> vertex(3);\n            for(auto &v: vertex) {\n                double x, y;\n                cin >> x >> y;\n                v = Point(x, y);\n            }\n            if(vertex[0].distance(vertex[1]) == vertex[0].distance(vertex[2])) swap(vertex[0], vertex[2]);\n            if(vertex[1].distance(vertex[0]) == vertex[1].distance(vertex[2])) swap(vertex[1], vertex[2]);\n            for(const auto &v: vertex) t.add(v);\n        }\n\n        vector<Polygon> light(n);\n        for(int i = 0; i < triangle.size(); ++i) {\n            Point n = (triangle[i].vertex(1) - triangle[i].vertex(0)).normalize();\n            if(triangle[i].vertex(0).ccw(triangle[i].vertex(1), triangle[i].vertex(2)) > 0) n = Point(-n.y(), n.x());\n            else                                                                            n = Point(n.y(), -n.x());\n            light[i].add(triangle[i].vertex(0));\n            light[i].add(triangle[i].vertex(0) + (n * d));\n            light[i].add(triangle[i].vertex(1) + (n * d));\n            light[i].add(triangle[i].vertex(1));\n        }\n\n        vector<int> indegree(n, 0);\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if(i == j) continue;\n                for(const auto &l: light[i].edge()) {\n                    for(const auto &t: triangle[j].edge())\n                        if(l.intersect(t)) ++indegree[j];\n                }\n            }\n        }\n        cout << count(indegree.begin(), indegree.end(), 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-6;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tSegment s(curr(g, i), next(g, i));\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(s, h[j]) < 0.01){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tSegment s(curr(h, i), next(h, i));\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(s, g[j]) < 0.01){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(norm(b - a), norm(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = (a * v * d) / abs(a);\n\t\t\t\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tsqr[i].resize(4);\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS = 0.01, INF = 1e12, PI = acos(-1.0);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  G ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n#include<stack>\nvoid visit(const vector<vi> &g, int v, vector<vi>& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  each(e, g[v]) {\n    int w = *e;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const vector<vi>& g,\n    vector<vi>& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint n, d;\nvector<vi> g;\n\nint main(){\n\twhile(cin >> n >> d, n || d){\n\t\tg.clear(); g.resize(n);\n\t\tvector<G> tri;\n\t\trep(i, n){\n\t\t\tint t;\n\t\t\tG p(3);\n\t\t\tdouble l[3];\n\t\t\trep(j, 3) cin >> p[j].real() >> p[j].imag();\n\t\t\trep(j, 3) l[j] = abs(p[j] - p[(j + 1) % 3]);\n\t\t\trep(j, 3) if(abs(l[j] - l[(j + 1) % 3]) < EPS){\n\t\t\t\tt = (j + 1) % 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswap(p[t], p[(t + 1) % 3]);\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\trep(i, n){\n\t\t\tG &p = tri[i];\n\t\t\tP dir = p[0] - (p[1] + p[2]) * 0.5;\n\t\t\tdir *= d / abs(dir);\n\t\t\t\n\t\t\tG ps;\n\t\t\tps.pb(p[1]); ps.pb(p[2]);\n\t\t\tps.pb(p[1] + dir); ps.pb(p[2] + dir);\n\t\t\tps = convex_hull(ps);\n\t\t\t\n\t\t\trep(j, n){\n\t\t\t\tbool ok = 0;\n\t\t\t\trep(k, 3) if(contains(ps, tri[j][k]) != OUT) ok = 1;\n\t\t\t\tif(ok) g[i].pb(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tmap<int, int> to;\n\t\tvector<vi> scc;\n\t\tstronglyConnectedComponents(g, scc);\n\t\tint m = scc.size();\n\t\tvi in(m);\n\t\t\n\t\trep(i, m) rep(j, scc[i].size()){\n\t\t\tto[scc[i][j]] = i;\n\t\t}\n\t\trep(i, n) rep(j, g[i].size()){\n\t\t\tint a = to[i], b = to[g[i][j]];\n\t\t\tif(a != b) in[b]++;\n\t\t}\n\t\trep(i, m) if(in[i] == 0) ans++;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\n#define double long double\n\nstruct coor {\n\tdouble x, y;\n};\nstruct tri {\n\tcoor p[3];\n\tcoor rec[4];\n};\n\nint n, d;\nvector<tri> v;\nvector<vector<int> > edge;\n\nconst double EPS = 1e-9;\nconst double ERR = 1e-2;\n\ntemplate<class T>\nT sqr(T x) {\n\treturn x * x;\n}\n\ndouble dist(coor a, coor b) {\n\treturn sqrt(sqr(a.x-b.x) + sqr(a.y-b.y));\n}\n\ndouble dist_lp(coor c, coor a, coor b) {\n\tcoor v0, v1;\n\tv0.x = b.x - a.x; v0.y = b.y - a.y;\n\tv1.x = c.x - a.x; v1.y = c.y - a.y;\n\n\tif(sqr(dist(a,b)) + sqr(dist(a,c)) - sqr(dist(c,b)) > 0\n\t\t\t&& sqr(dist(a,b)) + sqr(dist(b,c)) - sqr(dist(c,a)) > 0) {\n\t\tdouble cross;\n\t\tcross = fabs(v0.x * v1.y - v0.y * v1.x);\n\t\treturn cross / dist(a,b);\n\t}\n\n\treturn min(dist(a,c), dist(b,c));\n}\n\nbool in_poly(coor p, coor poly[], int sz) {\n\tdouble sign = +0.0;\n\tfor(int i = 0; i < sz; i++) {\n\t\tcoor v0, v1;\n\t\tv0.x = poly[i].x - p.x; v0.y = poly[i].y - p.y;\n\t\tv1.x = poly[(i+1)%sz].x - p.x; v1.y = poly[(i+1)%sz].y - p.y;;\n\n\t\tif(i != 0 && sign * (v0.x * v1.y - v0.y * v1.x) < EPS) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tsign = (v0.x * v1.y - v0.y * v1.x);\n\n\t\tif(i == sz-1) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < sz; i++) {\n\t\tif(dist_lp(p,poly[i], poly[(i+1)%sz]) <= ERR + EPS) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool seg_cross(coor a, coor b, coor c, coor d) {\n\tcoor v0, v1, v2;\n\t\n\tv0.x = a.x - c.x; v0.y = a.y - c.y;\n\tv1.x = b.x - c.x; v1.y = b.y - c.y;\n\tv2.x = d.x - c.x; v2.y = d.y - c.y;\n\n\tdouble s, t;\n\ts = (v0.x * v2.y - v0.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\tt = - (v1.x * v2.y - v1.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\n\tif(s + t > 1-EPS && s > -EPS && t > -EPS) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool exist_edge(tri from, tri to) {\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(in_poly(to.p[i], from.rec, 4)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(in_poly(from.rec[i], to.p, 3)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 3; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tif(seg_cross(to.p[i], to.p[(i+1)%3], from.rec[j], from.rec[(j+1)%4])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool visited[128];\nbool touch[128];\n\nvoid check(int i, int s) {\n\tif(i != s && touch[i])\n\t\ttouch[i] = false;\n\tif(visited[i])\n\t\treturn;\n\tvisited[i] = true;\n\tfor(int j = 0; j < (int)edge[i].size(); j++) {\n\t\tcheck(edge[i][j], s);\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> d, n || d) {\n\t\tv.clear();\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tvisited[i] = touch[i] = false;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttri in;\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tcoor c;\n\t\t\t\tcin >> c.x >> c.y;\n\t\t\t\tin.p[j] = c;\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tif(fabs(dist(in.p[(0+j)%3],in.p[(1+j)%3]) - dist(in.p[(1+j)%3], in.p[(2+j)%3])) < EPS) {\n\t\t\t\t\tswap(in.p[(1+j)%3], in.p[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcoor add;\n\t\t\t//*\n\t\t\tadd.x =\t(in.p[1].x - in.p[0].x) + (in.p[1].x - in.p[2].x);\n\t\t\tadd.y = (in.p[1].y - in.p[0].y) + (in.p[1].y - in.p[2].y);\n\t\t\t// */\n\t\t\t/*\n\t\t\tint sign = -1;\n\t\t\tif((in.p[2].x - in.p[0].x)*(in.p[1].y - in.p[0].y) - (in.p[2].y - in.p[0].y)*(in.p[1].x - in.p[0].x) < 0)\n\t\t\t\tsign = 1;\n\t\t\tadd.x =\t(in.p[2].y - in.p[0].y) * sign;\n\t\t\tadd.y = -(in.p[2].x - in.p[0].x) * sign;\n\t\t\t// */\n\n\t\t\tdouble addlen;\n\t\t\taddlen = sqrt(sqr(add.x) + sqr(add.y));\n\t\t\tadd.x = add.x * d / addlen;\n\t\t\tadd.y = add.y * d / addlen;\n\n\t\t\tin.rec[0].x = in.p[0].x; in.rec[0].y = in.p[0].y;\n\t\t\tin.rec[1].x = in.p[2].x; in.rec[1].y = in.p[2].y;\n\t\t\tin.rec[2].x = in.p[2].x + add.x; in.rec[2].y = in.p[2].y + add.y;\n\t\t\tin.rec[3].x = in.p[0].x + add.x; in.rec[3].y = in.p[0].y + add.y;\n\n\t\t\tv.push_back(in);\n\t\t}\n\n\t\tfor(int i = 0; i < (int)v.size(); i++) {\n\t\t\tfor(int j = 0; j < (int)v.size(); j++) {\n\t\t\t\tif(i != j) {\n\t\t\t\t\tif(exist_edge(v[i], v[j])) {\n\t\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcout << \"*\";\n\t\t\tfor(int j = 0; j < (int)edge[i].size(); j++)\n\t\t\t\tcout << edge[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\ttouch[i] = true;\n\t\t\t\tcheck(i, i);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(touch[i])\n\t\t\t\tres++;\n\t\t}\n\t\tcout <<  res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-2)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) * SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G &a, G &b)\n{\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)) return true;\n\t\t}\n\t}\n\tfor (int i = 0; i < a.size(); i++){\n\t\tif (contains(b, a[i])) return true;\n\t}\n\tfor (int i = 0; i < b.size(); i++){\n\t\tif (contains(a, b[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) res++;\n\t\tfor (int to : sccgraph[i]){\n\t\t\tused[to] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<unordered_map>\n#define eps 1e-9\nusing namespace std;\ntypedef complex<double> point;\n\n//??????\ndouble dot(point a, point b){\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\n//??????\ndouble cross(point a, point b){\n  return imag(conj(a) * b);\n}\n\n//counter clock wise\nint ccw(point a, point b, point c){\n  if(cross(b - a, c - a) >  eps)return  1;//??????ab????????´\n  if(cross(b - a, c - a) < -eps)return -1;//??????ab????????´\n  if(dot(b - a, c - a) < -eps)return 2;//??´???ab??????a???????????????\n  if(abs(b - a) + eps < abs(c - a))return -2;//??´???ab??????b???????????????\n  return 0;//??´???ab???\n}\ntypedef struct door{\n  double r;\n  point x, y, z, p;\n  point rot(point p, double theta){\n    return point(p.real()*cos(theta) +\n                 p.imag()*sin(theta),\n                 -p.real()*sin(theta) +\n                 p.imag()*cos(theta));\n  }\n  void rectangle(){\n    p = y - x;\n    if(ccw(x, y, z) == -1){\n      p = rot(p, M_PI/2.0);\n    }else if(ccw(x, y, z) == 1){\n      p = rot(p, -M_PI/2.0);\n    }\n    p *= r/abs(p);\n  }\n}door;\n\nclass SCC{\npublic:\n  SCC(vector<vector<int> > g_):g(g_){\n    rg.resize(g.size());\n    for (int i = 0; i < g.size(); i++) {\n      for (int j = 0; j < g[i].size(); j++) {\n        rg[g[i][j]].push_back(i);\n      }\n    }\n  };\n  void makeScc();\n  int size(){return g.size();};\n  int sccSize(){return scc.size();};\n  vector<vector<int> > g, scc;\nprivate:\n  void dfs(int v, bool *used);\n  void rdfs(int v, int k, bool *used);\n  vector<vector<int> > rg;\n  vector<int> vs, cmp;\n};\n\nvoid SCC::makeScc() {\n  bool used[g.size()];\n  memset(used, false, sizeof(used));\n  vs.resize(g.size());\n  cmp.resize(g.size(), -1);\n  for (int i = 0; i < g.size(); i++) {\n    if(not used[i])dfs(i, used);\n  }\n  memset(used, false, sizeof(used));\n  int k = 0;\n  for (int i = vs.size() -  1; i >= 0; i--) {\n    if(not used[vs[i]]) rdfs(vs[i], k++, used);\n  }\n  unordered_map<int, int> hash;\n  for (int i = 0; i < cmp.size(); i++) {\n    hash[i] = cmp[i];\n  }\n  scc.resize(hash.size());\n  for (int i = 0; i < g.size(); i++) {\n    for (int j = 0; j < g[i].size(); j++) {\n      scc[hash[g[i][j]]].push_back(hash[i]);\n    }\n  }\n}\nvoid SCC::dfs(int v, bool *used) {\n  used[v] = true;\n  for (int i = 0; i < g[v].size(); i++) {\n    if(not used[g[v][i]])dfs(g[v][i], used);\n  }\n  vs.push_back(v);\n}\nvoid SCC::rdfs(int v, int k, bool* used){\n  used[v] = true;\n  cmp[v] = k;\n  for (int i = 0; i < rg[v].size(); i++) {\n    if(not used[rg[v][i]])\n      rdfs(rg[v][i], k, used);\n  }\n}\n\nbool isCover(door from, door to){\n  point p[4];\n  p[0] = from.x;\n  p[1] = from.y;\n  p[2] = from.y + from.p;\n  p[3] = from.x + from.p;\n\n  int f = ccw(p[0], p[1], to.x);\n  bool flag = true;\n  if(f == 0)return true;\n  if(f != 1 and f != -1)flag = false;\n  for (int i = 1; i < 4 and flag; i++) {\n    if(ccw(p[i], p[(i + 1)%4], to.x) != f)\n      flag = false;      \n    if(ccw(p[i], p[(i + 1)%4], to.x) == 0)\n      return true;\n  }\n  if(flag)return true;\n  f = ccw(p[0], p[1], to.y);\n  if(f == 0)return true;\n  if(f != 1 and f != -1)return false;\n  for (int i = 1; i < 4; i++) {\n    if(ccw(p[i], p[(i + 1)%4], to.y) == 0)\n      return true;\n    if(ccw(p[i], p[(i + 1)%4], to.y) != f)\n      return false;\n  }\n  return true;\n}\n\n\n\n\nint main(){\n  int n, r;\n  while(std::cin >> n >> r, n){\n    door d[n];\n    for (int i = 0; i < n; i++) {\n      int a, b;\n      std::cin >> a >> b;\n      d[i].x = point(a, b);\n    \n      std::cin >> a >> b;\n      d[i].y = point(a, b);\n    \n      std::cin >> a >> b;\n      d[i].z = point(a, b);\n      d[i].r = r;\n      d[i].rectangle();\n    }\n    vector<vector<int> > g(n), rg(n);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if(isCover(d[i], d[j])){\n          g[i].push_back(j);\n          rg[j].push_back(i);\n        }\n      }\n    }\n    SCC dag(g);\n    dag.makeScc();\n    int ans = 0;\n    for (int i = 0; i < dag.sccSize(); i++) {\n      if(dag.scc[i].size() == 0)ans++;\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)==real(b)?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\nconst D EPS = 1e-8;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nPoly tri[110];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nvector<P> convex_hull(vector<P> v){\n  int n = v.size(), k = 0;\n  sort(v.begin(),v.end());\n  vector<P> r(2*n);\n  for(int i=0;i<n;i++){\n    while(k>1 && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= EPS)k--;\n    r[k++] = v[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= EPS)k--;\n    r[k++] = v[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\nbool cross_poly(Poly a, Poly b){\n  int n1 = a.size(), n2 = b.size();\n  rep(i,n2)if(inter_pos(a,b[i]))return true;\n  rep(i,n1)if(inter_pos(b,a[i]))return true;\n  rep(i,n1)rep(j,n2)\n    if(is_cp(L(a[i],a[(i+1)%n1]),L(b[j],b[(j+1)%n2])))return true;\n  return false;\n}\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      tri[i].resize(3);\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n      tri[i] = convex_hull(tri[i]);\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(ccw(tri[i][j],tri[i][n1],tri[i][n2])!=1){\n\t    swap(rect[i][0],rect[i][1]); break;\n\t  }\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n      rect[i] = convex_hull(rect[i]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\tif(cross_poly(rect[i],tri[j])){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-2;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nint V;\nvector<vector<int> > G,rG;\nvector<int> vs;\nbool used[100];\nint cmp[100];\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]){\n      dfs(G[v][i]);\n    }\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]){\n      rdfs(rG[v][i],k);\n    }\n  }\n}\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[2])>eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    G=rG=vector<vector<int> >(n);\n    vs.clear();\n    bool e[100][100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<eps;\n\t      e[i][j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t      e[i][j]|=abs(p[i][k]-r[j][k])<=eps;\n\t    }\n\t    e[i][j]|=!f;\n\t    if(e[i][j]){\n\t      G[i].push_back(j);\n\t      rG[j].push_back(i);\n\t    }\n\t  }\n\t}\n      }\n    }\n    V=n;\n    fill(begin(used),end(used),false);\n    for(int v=0;v<V;v++){\n      if(!used[v]){\n\tdfs(v);\n      }\n    }\n    fill(begin(used),end(used),false);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]]){\n\trdfs(vs[i],k++);\n      }\n    }\n    bool in[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(e[i][j]&&cmp[i]!=cmp[j]){\n\t  in[cmp[j]]=true;\n\t}\n      }\n    }\n    cout<<count(in,in+k,false)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-10;\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      if (     cross(a[in[0]]-a[in[1]],a[in[2]]-a[in[1]]) >=0)\n\tassert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])>=0);\n      else assert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])<=0);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\n#define DSS distance_ls_p\ndouble distance_ss_p(P a,P b,P c,P d){\n  return min(  min( DSS(a,b,c),DSS(a,b,d)),min(DSS(c,d,a),DSS(c,d,b)));\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n      rep(k,tri[j].size()){\n\tif (is_in(tri[i],tri[j][k])&&\n\t    (distance_ss_p(sq[i][0],sq[i][1],tri[j][0],tri[j][1])||\n\t     distance_ss_p(sq[i][0],sq[i][1],tri[j][1],tri[j][2])||\n\t     distance_ss_p(sq[i][0],sq[i][1],tri[j][2],tri[j][0]))\n\t    ){\n\t  assert(false);\n\t  inedge[i].pb(j);\n\t  redge[j].pb(i);\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n\n\n    //rep(i,n){rep(j,sq[i].size())cout<< sq[i][j];cout << endl;}\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値, Polygonのメンバ変数\n#include<algorithm> // min(), sort(), reverse()\n \nconst double EPS = 1e-10;\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\nclass Polygon;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    const Point normalize() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n    void print() const;\n};\nbool operator==(const Point& lhs, const Point& rhs);\nbool operator!=(const Point& lhs, const Point& rhs);\nbool operator<(const Point& lhs, const Point& rhs);\nbool operator>(const Point& lhs, const Point& rhs);\nbool operator<=(const Point& lhs, const Point& rhs);\nbool operator>=(const Point& lhs, const Point& rhs);\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Segment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Segment&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Segment&) const;\n    bool orthogonal(const Line&) const;\n    POSITION ccw(const Point&) const;\n    void print() const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Line(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Segment&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Segment&) const;\n    bool orthogonal(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n    void print() const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool in(const Point&) const;\n    bool out(const Point&) const;\n    bool include(const Point&) const;\n    bool include(const Segment&) const;\n    bool include(const Line&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    std::vector<Point> crosspoint(const Circle&) const;\n    void print() const;\n};\nclass Polygon {\n    std::vector<Point> point;\npublic:\n    Polygon() {}\n    explicit Polygon(std::vector<Point> p) :point(p) {}\n    const std::vector<Point>& vertex() const {return point;}\n    const Point& vertex(int i) const {return point.at(i);}\n    const std::vector<Segment> edge() const {\n        std::vector<Segment> result;\n        for(int i = 0; i < size(); ++i) result.push_back(Segment(vertex(i), vertex((i + 1) % size())));\n        return result;\n    }\n    const Segment edge(int i) const {return Segment(vertex(i), vertex((i + 1) % size()));}\n    int size() const {return point.size();}\n    void add(const Point&);\n    double area() const;\n    bool convex() const;\n    bool include(const Point&) const;\n    bool intersect(const Polygon&) const;\n    bool on_edge(const Point&) const;\n    const Polygon convex_hull() const;\n    void print() const;\n};\n// Point\nbool operator==(const Point& lhs, const Point& rhs) {return lhs.x() == rhs.x() && lhs.y() == rhs.y();}\nbool operator!=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() || lhs.y() != rhs.y();}\nbool operator<(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() < rhs.y();}\nbool operator>(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() > rhs.y();}\nbool operator<=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() <= rhs.y();}\nbool operator>=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() >= rhs.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\nconst Point Point::normalize() const {return abs() == 0.0 ? Point(0.0, 0.0) : Point(x(), y()) / abs();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return COUNTER_CLOCKWISE;\n    if(v1.cross(v2) < -EPS) return CLOCKWISE;\n    if(v1.dot(v2) < -EPS) return ONLINE_BACK;\n    if(v2.norm() - v1.norm() > EPS) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nvoid Point::print() const {std::cout << x() << \", \" << y() << std::endl;}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    return std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    return std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nbool Segment::parallel(const Line& l) const {line().parallel(l);}\nbool Segment::parallel(const Segment& s) const {return line().parallel(s.line());}\nbool Segment::orthogonal(const Line& l) const {return line().orthogonal(l);}\nbool Segment::orthogonal(const Segment& s) const {return line().orthogonal(s.line());}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\nvoid Segment::print() const {std::cout << \"source: \"; source().print(); std::cout << \"target: \"; target().print();}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nbool Line::parallel(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dxl - dyl * dx) <= EPS;\n}\nbool Line::parallel(const Segment& s) const {return parallel(s.line());}\nbool Line::orthogonal(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dyl + dxl * dx) <= EPS;\n}\nbool Line::orthogonal(const Segment& s) const {return orthogonal(s.line());}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) return l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\nvoid Line::print() const {std::cout << \"source: \"; source().print(); std::cout << \"target: \"; target().print();}\n// Circle\nbool Circle::in(const Point& p) const {return center().distance(p) < r() - EPS;}\nbool Circle::out(const Point& p) const {return r() + EPS < center().distance(p);}\nbool Circle::include(const Point& p) const {return center().distance(p) <= r() + EPS;}\nbool Circle::include(const Segment& s) const {return center().distance(s) <= r() + EPS;}\nbool Circle::include(const Line& l) const {return center().distance(l) <= r() + EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) <= r() - c.r() + EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) <= r() + c.r() + EPS;}\nstd::vector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    std::vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\nvoid Circle::print() const {std::cout << \"radius: \" << r() << \" - point: \"; center().print();}\n// Polygon\nvoid Polygon::add(const Point& p) {point.push_back(p);}\ndouble Polygon::area() const {\n    double sum = 0.0;\n    for(int i = 0; i < size(); ++i) sum += vertex(i).cross(vertex((i+1) % size()));\n    return fabs(sum) / 2.0;\n}\nbool Polygon::convex() const {\n    POSITION direction = ONLINE_BACK;\n    for(int i = 1; i < size(); ++i) {\n        POSITION d = vertex(i - 1).ccw(vertex(i), vertex((i + 1) % size()));\n        if(d != CLOCKWISE && d != COUNTER_CLOCKWISE) continue;\n        if(direction == ONLINE_BACK) direction = d;\n        if(direction != d) return false;\n    }\n    return true;\n}\nbool Polygon::include(const Point& p) const {\n    bool in = false;\n    for(int i = 0; i < size(); ++i) {\n        Point a = vertex(i) - p;\n        Point b = vertex((i + 1) % size()) - p;\n        if(a.y() > b.y()) std::swap(a, b);\n        if(a.y() <= 0.0 && 0 < b.y() && a.cross(b) < 0.0) in = !in;\n        if(fabs(a.cross(b)) <= EPS && a.dot(b) <= EPS) return true;\n    }\n    return in;\n}\nbool Polygon::intersect(const Polygon& p) const {\n    for(const auto& e1: edge()) for(const auto& e2: p.edge()) if(e1.intersect(e2)) return true;\n    return false;\n}\nbool Polygon::on_edge(const Point& p) const {\n    for(int i = 0; i < size(); ++i) if(vertex(i).ccw(vertex((i + 1) % size()), p) == ON_SEGMENT) return true;\n    return false;\n}\nconst Polygon Polygon::convex_hull() const {                // Andrew's Monotone Chain\n    Polygon result;\n    std::vector<Point> res;\n    std::vector<Point> original = vertex();\n    sort(original.begin(), original.end());\n    original.insert(original.end(), original.rbegin() + 1, original.rend());\n    for(const auto& v: original) {\n        while(res.size() >= 2 && res[res.size() - 2].ccw(res[res.size() - 1], v) == CLOCKWISE) res.pop_back();\n        res.push_back(v);\n    }\n    res.pop_back();\n    for(const auto& v: res) result.add(v);\n    return result;\n}\nvoid Polygon::print() const {for(const auto& v: vertex()) std::cout << v.x() << \", \" << v.y() << std::endl;}\n \n////////////////////////////////////////////////////////////////////////////////\n \nusing namespace std;\n \nint main() {\n    int n, d;\n    while(cin >> n >> d, n | d) {\n        vector<Polygon> triangle(n);\n        for(auto &t: triangle) {\n            vector<Point> vertex(3);\n            for(auto &v: vertex) {\n                double x, y;\n                cin >> x >> y;\n                v = Point(x, y);\n            }\n            if(vertex[0].distance(vertex[1]) == vertex[0].distance(vertex[2])) swap(vertex[0], vertex[2]);\n            if(vertex[1].distance(vertex[0]) == vertex[1].distance(vertex[2])) swap(vertex[1], vertex[2]);\n            for(const auto &v: vertex) t.add(v);\n        }\n \n        vector<Polygon> light(n);\n        for(int i = 0; i < triangle.size(); ++i) {\n            Point n = (triangle[i].vertex(1) - triangle[i].vertex(0)).normalize();\n            if(triangle[i].vertex(0).ccw(triangle[i].vertex(1), triangle[i].vertex(2)) > 0) n = Point(-n.y(), n.x());\n            else                                                                            n = Point(n.y(), -n.x());\n            light[i].add(triangle[i].vertex(0));\n            light[i].add(triangle[i].vertex(0) + (n * d));\n            light[i].add(triangle[i].vertex(1) + (n * d));\n            light[i].add(triangle[i].vertex(1));\n        }\n \n        vector<int> indegree(n, 0);\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if(i == j) continue;\n                // 辺の交差判定\n                for(const auto &l: light[i].edge()) {\n                    for(const auto &t: triangle[j].edge())\n                        if(l.intersect(t)) ++indegree[j];\n                }\n                // 点の包含判定\n                for(const auto &v: light[i].vertex()) {\n                    if(triangle[j].include(v)) ++indegree[j];\n                }\n                for(const auto &v: triangle[j].vertex()) {\n                    if(light[i].include(v)) ++indegree[j];\n                }\n            }\n        }\n        cout << count(indegree.begin(), indegree.end(), 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\n#include <cstring>\n\n// ???, ????????????\ntypedef std::complex<double> Point;\ntypedef Point Vector;\n\nnamespace std {\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\t\n\tistream& operator >> (istream &is, Point &a){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\ta = Point(x, y);\n\t\treturn is;\n\t}\n\t\n\tostream& operator << (ostream &os, Point a){\n\t\treturn os << a.real() << \" \" << a.imag();\n\t}\n}\n\n// ??´???\nstruct Line {\n\tPoint p1, p2;\n\tLine(){}\n\tLine(const Point &p1, const Point &p2): p1(p1), p2(p2){}\n};\ntypedef Line Segment;\n\nnamespace std {\n\tistream& operator >> (istream &is, Line &a){\n\t\treturn is >> a.p1 >> a.p2;\n\t}\n}\n\n// ???\nstruct Circle {\n\tPoint p; double r;\n\tCircle(){}\n\tCircle(const Point &p, double r): p(p), r(r){}\n};\n\nnamespace std {\n\tistream& operator >> (istream &is, Circle &a){\n\t\treturn is >> a.p >> a.r;\n\t}\n}\n\n// ????§???¢\ntypedef std::vector<Point> Polygon;\n\nconst double EPS = 1e-12;\nconst double INF = 1e12;\nconst double PI = acos(-1.0);\n\n// ????????¨??????????????¢???\nenum CCW {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0,\n};\n\n// ?????¢????£????????????¢???\nenum {\n\tOUT = 0,\n\tON = 1,\n\tIN = 2,\n};\n\n\n// a ??? 2 ??? (a ^ 2)\ndouble SQ(double a);\n\n// ?????????????????????????????¢??°\nbool EQ(double a, double b);\nbool NEQ(double a, double b);\nbool LT(double a, double b);\nbool GT(double a, double b);\nbool LEQ(double a, double b);\nbool GEQ(double a, double b);\n\n// ??§?????? <=> ?????°?????????\ndouble toDeg(double t);\ndouble toRad(double t);\n\n// ????????? (dot(a, a))\ndouble norm(const Vector &a);\n\n// ??????, ??????\ndouble dot(const Vector &a, const Vector &b);\ndouble cross(const Vector &a, const Vector &b);\n\n// ??´???, ??????\nbool orthogonal(const Segment &s1, const Segment &s2);\nbool parallel(const Segment &s1, const Segment &s2);\n\n// ?°???±, ????°?\nPoint project(const Line &l, const Point &p);\nPoint reflect(const Line &l, const Point &p);\n\n// ?????? (p0, p1) ??¨??? p2 ???????????¢???\nint ccw(const Point &p0, const Point &p1, const Point &p2);\n\n// ????????????\nbool intersectLP(const Line &l, const Point &p);\nbool intersectLL(const Line &l1, const Line &l2);\nbool intersectLS(const Line &l, const Segment &s);\nbool intersectSP(const Segment &s, const Point &p);\nbool intersectSS(const Segment &s1, const Segment &s2);\nint intersectCP(const Circle &c, const Point &p);\nbool intersectCL(const Circle &c, const Line &l);\nint intersectCS(const Circle &c, const Segment &s);\nint intersectCC(const Circle &c1, const Circle &c2);\n\n// ?????¢\ndouble distanceLP(const Line &l, const Point &p);\ndouble distanceLL(const Line &l1, const Line &l2);\ndouble distanceLS(const Line &l, const Segment &s);\ndouble distanceSP(const Segment &s, const Point &p);\ndouble distanceSS(const Segment &s1, const Segment &s2);\ndouble distanceCP(const Circle &c, const Point &p);\ndouble distanceCL(const Circle &c, const Line &l);\ndouble distanceCS(const Circle &c, const Segment &s);\ndouble distanceCC(const Circle &c1, const Circle &c2);\n\n// ??????\nPoint crossPointLL(const Line &l1, const Line &l2);\nPoint crossPointLS(const Line &l, const Segment &s);\nPoint crossPointSS(const Segment &s1, const Segment &s2);\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l);\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s);\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2);\n\n\ndouble SQ(double a){\n\treturn a * a;\n}\n\nbool EQ(double a, double b){\n\treturn std::abs(a - b) < EPS;\n}\n\nbool NEQ(double a, double b){\n\treturn !EQ(a, b);\n}\n\nbool LT(double a, double b){\n\treturn a - b < -EPS;\n}\n\nbool GT(double a, double b){\n\treturn a - b > EPS;\n}\n\nbool LEQ(double a, double b){\n\treturn !GT(a, b);\n}\n\nbool GEQ(double a, double b){\n\treturn !LT(a, b);\n}\n\ndouble toDeg(double t){\n\treturn t * 180 / PI;\n}\n\ndouble toRad(double t){\n\treturn t / 180 * PI;\n}\n\ndouble norm(const Vector &a){\n\treturn SQ(a.real()) + SQ(a.imag());\n}\n\ndouble dot(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).real();\n}\n\ndouble cross(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).imag();\n}\n\n// AOJ CGL_2_A\nbool orthogonal(const Segment &s1, const Segment &s2){\n\treturn EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_2_A\nbool parallel(const Segment &s1, const Segment &s2){\n\treturn EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_1_A\nPoint project(const Line &l, const Point &p){\n\tVector base = l.p2 - l.p1;\n\tdouble r = dot(p - l.p1, base) / norm(base);\n\treturn l.p1 + base * r;\n}\n\n// AOJ CGL_1_B\nPoint reflect(const Line &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2.0;\n}\n\n// AOJ CGL_1_C\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (GT(cross(a, b), 0.0)) return COUNTER_CLOCKWISE;\n\tif (LT(cross(a, b), 0.0)) return CLOCKWISE;\n\tif (LT(dot(a, b), 0.0)) return ONLINE_BACK;\n\tif (LT(norm(a), norm(b))) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersectLP(const Line &l, const Point &p){\n\treturn LEQ(std::abs(cross(l.p1 - p, l.p2 - p)), 0.0);\n}\n\nbool intersectLL(const Line &l1, const Line &l2){\n\treturn !parallel(l1, l2) || LEQ(std::abs(cross(l1.p2 - l1.p1, l2.p1 - l1.p1)), 0.0);\n}\n\nbool intersectLS(const Line &l, const Segment &s){\n\treturn LEQ(cross(l.p2 - l.p1, s.p1 - l.p1) * cross(l.p2 - l.p1, s.p2 - l.p1), 0.0);\n}\n\nbool intersectSP(const Segment &s, const Point &p){\n\treturn norm(s.p1 - p) + norm(s.p2 - p) - norm(s.p2 - s.p1) < EPS;\n}\n\n// CGL_2_B\nbool intersectSS(const Segment &s1, const Segment &s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\nint intersectCP(const Circle &c, const Point &p){\n\tdouble dd = norm(c.p - p);\n\tif (LT(dd, SQ(c.r))) return IN;\n\tif (EQ(dd, SQ(c.r))) return ON;\n\treturn OUT;\n}\n\nbool intersectCL(const Circle &c, const Line &l){\n\tdouble d = distanceLP(l, c.p);\n\treturn LEQ(d, c.r);\n}\n\nint intersectCS(const Circle &c, const Segment &s){\n\tdouble dd1 = norm(c.p - s.p1);\n\tdouble dd2 = norm(c.p - s.p2);\n\tif (LT(dd1, SQ(c.r)) && LT(dd2, SQ(c.r))) return IN;\n\tif (GT(distanceCS(c, s), 0.0)) return OUT;\n\treturn ON;\n}\n\n// c1 ??? c2 ???????????????????????¨??? IN\n// c1 ??? c2 ????????£???????????¨??? ON\n// c1 ??? c2 ?????????????????¨??? OUT\nint intersectCC(const Circle &c1, const Circle &c2){\n\tif (GT(norm(c1.p - c2.p), SQ(c1.r + c2.r))) return OUT;\n\tif (LT(norm(c1.p - c2.p), SQ(c2.r))) return IN;\n\tif (LT(norm(c1.p - c2.p), SQ(c1.r))) return OUT;\n\treturn ON;\n}\n\ndouble distanceLP(const Line &l, const Point &p){\n\treturn std::abs(cross(l.p2 - l.p1, p - l.p1)) / std::abs(l.p2 - l.p1);\n}\n\ndouble distanceLL(const Line &l1, const Line &l2){\n\tif (intersectLL(l1, l2)) return 0.0;\n\treturn distanceLP(l1, l2.p1);\n}\n\ndouble distanceLS(const Line &l, const Segment &s){\n\tif (intersectLS(l, s)) return 0.0;\n\treturn std::min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\n\ndouble distanceSP(const Segment &s, const Point &p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return std::abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return std::abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\n// AOJ CGL_2_D\ndouble distanceSS(const Segment &s1, const Segment &s2){\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn std::min(\n\t\tstd::min(\n\t\t\tdistanceSP(s1, s2.p1),\n\t\t\tdistanceSP(s1, s2.p2)\n\t\t),\n\t\tstd::min(\n\t\t\tdistanceSP(s2, s1.p1),\n\t\t\tdistanceSP(s2, s1.p2)\n\t\t)\n\t);\n}\n\ndouble distanceCP(const Circle &c, const Point &p){\n\treturn std::abs(std::abs(c.p - p) - c.r);\n} \n\ndouble distanceCL(const Circle &c, const Line &l){\n\tif (intersectCL(c, l)) return 0.0;\n\treturn distanceLP(l, c.p) - c.r;\n}\n\ndouble distanceCS(const Circle &c, const Segment &s){\n\tif (intersectCS(c, s)) return 0.0;\n\treturn std::min(distanceCP(c, s.p1), distanceCP(c, s.p2));\n}\n\ndouble distanceCC(const Circle &c1, const Circle &c2){\n\tif (intersectCC(c1, c2) == ON) return 0.0;\n\tif (intersectCC(c1, c2) == IN){\n\t\treturn c2.r - (std::abs(c1.p - c2.p) + c1.r);\n\t}\n\tif (intersectCC(c2, c1) == IN){\n\t\treturn c1.r - (std::abs(c1.p - c2.p) + c2.r);\n\t}\n\treturn (c1.r + c2.r) - (c1.r + c2.r);\n}\n\nPoint crossPointLL(const Line &l1, const Line &l2){\n\tassert(intersectLL(l1, l2));\n\tVector base = l2.p2 - l2.p1;\n\tdouble d1 = std::abs(cross(base, l1.p1 - l2.p1));\n\tdouble d2 = std::abs(cross(base, l1.p2 - l2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn l1.p1 + (l1.p2 - l1.p1) * t;\n}\n\nPoint crossPointLS(const Line &l, const Segment &s){\n\tassert(intersectLS(l, s));\n\treturn crossPointLL(l, s);\n}\n\nPoint crossPointSS(const Segment &s1, const Segment &s2){\n\tassert(intersectSS(s1, s2));\n\treturn crossPointSS(s1, s2);\n}\n\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l){\n\tif (!intersectCL(c, l)) return std::vector<Point>();\n\tstd::vector<Point> ret;\n\tVector proj = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / std::abs(l.p2 - l.p1);\n\tdouble base = sqrt(SQ(c.r) - norm(proj - c.p));\n\tret.push_back(proj + e * base);\n\tret.push_back(proj - e * base);\n\treturn ret;\n}\n\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s){\n\tstd::vector<Point> ret = crossPointCL(c, s);\n\tfor (int i = 0; i < ret.size(); i++){\n\t\tif (!intersectCP(c, ret[i])){\n\t\t\tswap(ret[i], ret.back());\n\t\t\tret.pop_back();\n\t\t\ti--;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2){\n\tif (!intersectCC(c1, c2)) return std::vector<Point>();\n\tstd::vector<Point> ret;\n\tdouble d = std::abs(c1.p - c2.p);\n\tdouble a = std::acos((SQ(c1.r) + SQ(d) - SQ(c2.r)) / (2 * c1.r * d));\n\tdouble t = std::arg(c2.p - c1.p);\n\tret.push_back(c1.p + std::polar(c1.r, t + a));\n\tret.push_back(c1.p + std::polar(c1.r, t - a));\n\treturn ret;\n}\n\nnamespace {\nenum {DIRECTED, UNDIRECTED};\nconst int GRAPH_TYPE = DIRECTED;\n\ntypedef int Weight;\nconst Weight INF = 1 << 28;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge() {}\n\tEdge(int src, int dst, Weight weight = 1): src(src), dst(dst), weight(weight) {}\n\tbool operator < (const Edge &t) const { return weight < t.weight; }\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n\nvoid addEdge(Graph &g, int src, int dst, int weight = 1)\n{\n\tg[src].push_back(Edge(src, dst, weight));\n\tif (GRAPH_TYPE == UNDIRECTED) g[dst].push_back(Edge(dst, src, weight));\n};\n\nGraph transpose(const Graph &g)\n{\n\tGraph rg(g.size());\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\taddEdge(rg, g[i][j].dst, g[i][j].src, g[i][j].weight);\n\t\t}\n\t}\n\treturn rg;\n}\n\nvoid dfs_(const Graph &g, int v, bool *used, std::vector<int> &vs)\n{\n\tused[v] = true;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) dfs_(g, to, used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs_(const Graph &g, int v, int k, bool *used, std::vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) rdfs_(g, to, k, used, cmp);\n\t}\n}\n\nint scc(const Graph &g, std::vector<int> &cmp)\n{\n\tGraph rg = transpose(g);\n\tstd::vector<int> vs;\n\tbool *used = new bool[g.size()];\n\tcmp.resize(g.size());\n\t\n\tstd::memset(used, false, g.size());\n\tfor (int v = 0; v < g.size(); v++){\n\t\tif (!used[v]) dfs_(g, v, used, vs);\n\t}\n\t\n\tstd::memset(used, false, g.size());\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs_(rg, vs[i], k++, used, cmp);\n\t}\n\t\n\tdelete used;\n\treturn k;\n}\n}\n\n\nusing namespace std;\n\nint n;\ndouble d;\nvector<Polygon> tri;\nvector<Polygon> rect;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment s(g[i], g[(i + 1) % g.size()]);\n\t\t\tSegment t(h[j], h[(j + 1) % h.size()]);\n\t\t\tif (intersectSS(s, t)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint solve()\n{\n\trect.assign(n, Polygon(4));\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tif (EQ(norm(tri[i][j] - tri[i][(j + 1) % 3]), norm(tri[i][j] - tri[i][(j + 2) % 3]))){\n\t\t\t\tswap(tri[i][0], tri[i][j]);\n\t\t\t}\n\t\t}\n\t\tif (ccw(tri[i][1], tri[i][2], tri[i][0]) == CLOCKWISE){\n\t\t\tswap(tri[i][1], tri[i][2]);\n\t\t}\n\t\t\n\t\tVector s = tri[i][2] - tri[i][1];\n\t\tVector normal = s / abs(s) * Vector(0, 1) * d;\n\t\trect[i][0] = tri[i][1];\n\t\trect[i][1] = tri[i][2];\n\t\trect[i][2] = tri[i][2] + normal;\n\t\trect[i][3] = tri[i][1] + normal;\n\t}\n\t\n\tGraph graph(n);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(rect[i], tri[j])){\n\t\t\t\taddEdge(graph, i, j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tint v = scc(graph, cmp);\n\tGraph sccgraph(v);\n\tint mat[100][100] = {};\n\tint in[100] = {};\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < graph[i].size(); j++){\n\t\t\tint src = cmp[i];\n\t\t\tint dst = cmp[graph[i][j].dst];\n\t\t\tif (src == dst) continue;\n\t\t\tif (mat[src][dst]++) continue;\n\t\t\tin[dst]++;\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < v; i++){\n\t\tif (in[i] == 0) res++;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tstd::cout << std::fixed << std::setprecision(12);\n\t\n\twhile (cin >> n >> d, n){\n\t\ttri.assign(n, Polygon(3));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\ndouble d,tx[100][3],ty[100][3],bx[100][4],by[100][4];\nint n,f[100];\n\nstruct gr {\n\tint t,f;\n\tint to[100],fr[100];\n};\n\n\ngr g[100];\n\nvoid makebox() {\n\tint i,j,j1,j2,a,a1,a2;\n\tdouble vx1,vy1,vx2,vy2,b;\n\tfor (i=0;i<n;i++) {\n\t\tfor (j=0;j<3;j++) {\n\t\t\tj1=(j+1) % 3; j2=(j+2) % 3;\n\t\t\tif (((tx[i][j]-tx[i][j1])*(tx[i][j]-tx[i][j1])+(ty[i][j]-ty[i][j1])*(ty[i][j]-ty[i][j1]))-((tx[i][j]-tx[i][j2])*(tx[i][j]-tx[i][j2])+(ty[i][j]-ty[i][j2])*(ty[i][j]-ty[i][j2]))==0) a=j;\n\t\t}\n\t\ta1=(a+1) % 3; a2=(a+2) % 3;\n\t\tvx1=tx[i][a]-(tx[i][a1]+tx[i][a2])/2;\n\t\tvy1=ty[i][a]-(ty[i][a1]+ty[i][a2])/2;\n\t\tb=sqrt(vx1*vx1+vy1*vy1);\n\t\tbx[i][0]=tx[i][a1]; by[i][0]=ty[i][a1];\n\t\tbx[i][1]=tx[i][a2]; by[i][1]=ty[i][a2];\n\t\tvx2=d*vx1/b; vy2=d*vy1/b;\n\t\tbx[i][2]=bx[i][1]+vx2; by[i][2]=by[i][1]+vy2;\n\t\tbx[i][3]=bx[i][0]+vx2; by[i][3]=by[i][0]+vy2;\n\t}\n}\nint hit(int n1,int n2) {\n\tint i,j,k;\n\tdouble a,b,mtb,mt,mb,vx1,vy1,vx2,vy2,vx[5],vy[5];\n\tfor (i=0;i<2;i++) { vx[i]=bx[n1][i+1]-bx[n1][i]; vy[i]=by[n1][i+1]-by[n1][i];}\n\tfor (i=0;i<3;i++) { vx[2+i]=tx[n2][(i+1) % 3]-tx[n2][i]; vy[2+i]=ty[n2][(i+1) % 3]-ty[n2][i];}\n\tfor (i=0;i<5;i++) {\n\t\t vx2=-vy[i]; vy2=vx[i];\n\t\t vx1=vx2/sqrt(vx2*vx2+vy2*vy2); vy1=vy2/sqrt(vx2*vx2+vy2*vy2);\n\t\t mtb=0;\n\t\tfor (j=0;j<3;j++) for (k=0;k<4;k++) {\n\t\t vx2=bx[n1][k]-tx[n2][j]; vy2=by[n1][k]-ty[n2][j];\n\t\t a=vx2*vx1+vy2*vy1; if (a<0) a=-a;\n\t\t if (a>mtb) mtb=a;\n\t     }\n\t     a=vx[0]*vx1+vy[0]*vy1; if (a<0) a=-a;\n\t     b=vx[1]*vx1+vy[1]*vy1; if (b<0) b=-b;\n\t     mb=a+b;\n\t     mt=0;\n\t     for (j=0;j<3;j++) { a=(vx[2+j]*vx1+vy[2+j]*vy1)/2; if (a<0) mt-=a; else mt+=a; }\n\t     if (mtb-mt-mb>0) return 0;   \n\t\t      }\n\t\t return 1;     \n         }\n         \nvoid  search(int s) {\n\tint i;\n\tf[s]=1;\n\tfor (i=0;i<g[s].t;i++) if (f[g[s].to[i]]==0) search(g[s].to[i]);\n\tfor (i=0;i<g[s].f;i++) if (f[g[s].fr[i]]==0) { search(g[s].fr[i]); break;}\n }\n  \nint main() {\n\tint i,j,ans;\n\twhile (true) {\n\tcin >> n >> d;\n\tif (n==0) break;\n    for (i=0;i<n;i++) {\n\t\tfor (j=0;j<3;j++) cin >> tx[i][j] >> ty[i][j];\n\t\tg[i].t=g[i].f=0;\n\t    }\n    makebox();\n    for (i=0;i<n;i++) for (j=0;j<n;j++) if (i!=j) {if (hit(i,j)==1) { g[i].to[g[i].t]=j; g[i].t++; g[j].fr[g[j].f]=i; g[j].f++;}}\n\tfor (i=0;i<n;i++) f[i]=0; ans=0;\n\tfor (i=0;i<n;i++) if (f[i]==0) { ans++; search(i);}\n\tcout << ans << endl;\n    }    \n   return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-6, AD = 1e-2;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0){\n\t    swap(rect[i][0],rect[i][1]); break;\n\t  }\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k])){\n\t    f = true; break;\n\t  }\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3)if(seg_p_dis(rseg,tri[j][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,3){\n\t    L tseg = L(tri[j][k],rect[j][(k+1)%3]);\n\t    rep(l,4)if(seg_p_dis(tseg,rect[i][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n\nenum CCW{FRONT=0x01,RIGHT=0x02,BACK=0x04,LEFT=0x08,OVER=0x10};\nenum CIRCLE_RELATION{CIRCLE_SAME=0x01,CIRCLE_CONTAIN=0x02,\n\t\t     CIRCLE_NO_CROSS=0x04,CIRCLE_ONE_CROSS=0x08,\n\t\t     CIRCLE_ONE_INSIDE_CROSS=0x10,CIRCLE_TWO_CROSS=0x20};\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n\nconst double infty = 1e40;\nconst double eps = 1e-8;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\n// oÍ\nostream &operator<<(ostream &os, const pair<point,point> &p){\n  os << p.fr << \"-\" << p.sc;\n  return os;\n}\n\n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n\n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n\n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\n\n// _Iy[^\nbool far(point a, point b){ return abs(b-a)>0; }\nbool near(point a, point b){ return abs(b-a)<=0; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(ret<0)ret+=2*pi;\n  if(ret>2*pi)ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem varg2(vec a, vec b){\n  elem ret = varg(a,b);\n  if(ret>pi)return 2*pi-ret;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n\n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( dot(s.sc-s.fr,x-s.fr)<0 ) return abs(x-s.fr);\n  if( dot(s.fr-s.sc,x-s.sc)<0 ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n\n// CCW oXg¾ªA¸xÉæé\ninline int ccw(const point &a, point b, point x){\n  b -= a;\n  x -= a;\n  if( eq(cross(b,x),0.0) && dot(b,x) < 0 ) return BACK;\n  if( eq(cross(b,x),0.0) && abs(b) < abs(x) ) return FRONT;\n  if( eq(cross(b,x),0.0) ) return OVER;\n  if( cross(b,x) > 0 ) return LEFT;\n  if( cross(b,x) < 0 ) return RIGHT;\n}\n\n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n\n// üªÌð·»è\ninline bool intersectedSS(const seg &a, const seg &b)\n{\n  int cwaf=ccw(a.fr,a.sc,b.fr);\n  int cwbf=ccw(b.fr,b.sc,a.fr);\n  int cwas=ccw(a.fr,a.sc,b.sc);\n  int cwbs=ccw(b.fr,b.sc,a.sc);\n  if( cwaf==OVER || cwas==OVER || cwbf==OVER || cwbs==OVER ) return true;\n  return ( cwaf | cwas ) == (LEFT|RIGHT) && ( cwbf | cwbs ) == (LEFT|RIGHT);\n}\n\n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n\n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n\n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\n/* Op` */\nstruct triangle{\n  vector<point> p;\n  triangle():p(3,point(0,0)){}\n  triangle(point a,point b,point c){p.push_back(a);p.push_back(b);p.push_back(c);}\n  bool inside(const point &t)const{\n    int ccw01=ccw(p[0],p[1],t),ccw02=ccw(p[1],p[2],t),ccw03=ccw(p[2],p[0],t);\n    return ccw01==ccw02&&ccw02==ccw03;\n  }\n  bool contain(const point &t)const{\n    int ccw01=ccw(p[0],p[1],t),ccw02=ccw(p[1],p[2],t),ccw03=ccw(p[2],p[0],t);\n    if((ccw01|ccw02|ccw03)&OVER)return true;\n    else return ccw01==ccw02&&ccw02==ccw03;\n  }\n};\n\n/* é` */\nstruct rectangle{\n  vector<point> p;\n  rectangle():p(4,point(0,0)){}\n  rectangle(point a, point b, point c, point d){\n    p.push_back(a);  p.push_back(b);  p.push_back(c);  p.push_back(d);\n  }\n  bool inside(const point &t)const{\n    int ccw01=ccw(p[0],p[1],t),ccw02=ccw(p[1],p[2],t),ccw03=ccw(p[2],p[0],t);\n    return ccw01==ccw02&&ccw02==ccw03;\n  }\n  bool contain(const point &t)const{\n    int ccw01=ccw(p[0],p[1],t),ccw02=ccw(p[1],p[2],t),ccw03=ccw(p[2],p[3],t),ccw04=ccw(p[3],p[0],t);\n    if((ccw01|ccw02|ccw03|ccw04)&OVER)return true;\n    else return ccw01==ccw02&&ccw02==ccw03&&ccw03==ccw04;\n  }\n  bool rayReach(const triangle &t){ // t : traignle\n    for(int i = 0; i < (int)t.p.size(); ++i){\n      if( this->contain(t.p[i]) ) return true;\n    }\n    for(int i = 0; i < 4; ++i){\n      seg s(p[i],p[(i+1)%4]);\n      for(int j = 0; j < (int)t.p.size(); ++j){\n\tseg ss(t.p[j],t.p[(j+1)%t.p.size()]);\n\tif( intersectedSS( s, ss ) ) return true;\n      }\n    }\n    return false;\n  }\n};\n\nrectangle touch(triangle t, elem d)\n{\n  rectangle ret;\n  elem da=abs(t.p[0]-t.p[1]);\n  elem db=abs(t.p[1]-t.p[2]);\n  elem dc=abs(t.p[2]-t.p[0]);\n  \n  if(eq(da,db)){\n    vec v=d*uvec( t.p[1] - (t.p[2]+t.p[0])/2.0 );\n    ret.p[0]=t.p[2]+v;\n    ret.p[1]=t.p[2];\n    ret.p[2]=t.p[0];\n    ret.p[3]=t.p[0]+v;\n  }else if(eq(da,dc)){\n    vec v=d*uvec( t.p[0] - (t.p[1]+t.p[2])/2.0 );\n    ret.p[0]=t.p[1]+v;\n    ret.p[1]=t.p[1];\n    ret.p[2]=t.p[2];\n    ret.p[3]=t.p[2]+v;\n  }else if(eq(db,dc)){\n    vec v=d*uvec( t.p[2] - (t.p[0]+t.p[1])/2.0 );\n    ret.p[0]=t.p[0]+v;\n    ret.p[1]=t.p[0];\n    ret.p[2]=t.p[1];\n    ret.p[3]=t.p[1]+v;\n  }\n  return ret;\n}\n\nstruct Node{\n  vector<int> con;\n};\n\ntypedef vector<Node> Graph;\n\nvoid visit(const Graph &g, int v, vector< vector<int> > &scc,\n\t   stack<int> &S, vector<int> &inS,\n\t   vector<int> &low, vector<int> &num, int &time)\n{\n  low[v] = num[v] = ++time;\n  S.push(v);\n  inS[v]=1;\n  for(int i = 0; i < (int)g[v].con.size(); ++i){\n    int w=g[v].con[i];\n    if(num[w]==0){\n      visit(g,w,scc,S,inS,low,num,time);\n      low[v]=min(low[v],low[w]);\n    }else if(inS[w])\n      low[v]=min(low[v],num[w]);\n  }\n  if(low[v]==num[v]){\n    scc.push_back(vector<int>());\n    while(true){\n      int w=S.top(); S.pop(); inS[w]=0;\n      scc.back().push_back(w);\n      if( v == w ) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const Graph &g, vector< vector<int> > &scc)\n{\n  int n = g.size();\n  vector<int> num(n),low(n);\n  stack<int> S;\n  vector<int> inS(n);\n  int time=0;\n  for(int i=0;i<n;++i){\n    if(num[i]==0)\n      visit(g,i,scc,S,inS,low,num,time);\n  }\n}\n\nint solve(const vector<triangle> &vt, elem d)\n{\n  Graph G;\n\n  for(int i = 0; i < (int)vt.size(); ++i){\n    Node node;\n    for(int j = 0; j < (int)vt.size(); ++j){\n      if( i != j ){\n\trectangle R = touch(vt[i],d);\n\tif( R.rayReach( vt[j] ) ){\n\t  node.con.push_back(j);\n\t}\n      }else\n\tnode.con.push_back(j);\n    }\n    G.push_back(node);\n  }\n  \n  vector< vector<int> > scc;\n  stronglyConnectedComponents( G, scc );\n\n  int in[scc.size()];\n  for(int i = 0; i < (int)scc.size(); ++i){\n    in[i] = 0;\n  }\n  Graph DAG;\n  for(int i = 0; i < (int)scc.size(); ++i){\n    Node node;\n    for(int ii = 0; ii < (int)scc[i].size(); ++ii){\n      int from = scc[i][ii];\n      for(int j = 0; j < (int)scc.size(); ++j){\n\tif(i!=j){\n\t  for(int jj = 0; jj < (int)scc[j].size(); ++jj){\n\t    int to = scc[j][jj];\n\t    for(int k = 0; k < (int)G[from].con.size(); ++k){\n\t      if( G[from].con[k] == to ){\n\t\tnode.con.push_back(j);\n\t\tin[j]++;\n\t\tgoto next;\n\t      }\n\t    }\n\t  }\n\tnext:;\n\t}\n      }\n    }\n    DAG.push_back(node);\n  }\n\n  /*\n  for(int i = 0; i < (int)DAG.size(); ++i){\n    printf(\"%d : \", i );\n    for(int j = 0; j < (int)DAG[i].con.size(); ++j){\n      printf(\"%d \", DAG[i].con[j] );\n    }\n    printf(\"\\n\");\n  }\n  */\n\n  int ret = 0;\n  for(int i = 0; i < (int)DAG.size(); ++i){\n    if( in[i] == 0 ) ++ret;\n  }\n  return ret;\n}\n\nint main(){\n  while(true){\n    int n;\n    elem d;\n    vector<triangle> vt;\n    scanf(\"%d%lf\", &n, &d);\n    if(n==0)break;\n    for(int i = 0; i < n; ++i){\n      double x1,y1,x2,y2,x3,y3;\n      scanf(\"%lf%lf%lf%lf%lf%lf\", &x1, &y1, &x2, &y2, &x3, &y3);\n      point ta(x1,y1),tb(x2,y2),tc(x3,y3);\n      vt.push_back(triangle(ta,tb,tc));\n    }\n    int res = solve( vt, d );\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-3;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nint g[110][110];\nPt p[110][3];\nint UF[110];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[i][i]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble ax,bx,cx,ay,by,cy;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n\t\t\tdouble A=(bx-cx)*(bx-cx)+(by-cy)*(by-cy);\n\t\t\tdouble B=(ax-cx)*(ax-cx)+(ay-cy)*(ay-cy);\n\t\t\tdouble C=(ax-bx)*(ax-bx)+(ay-by)*(ay-by);\n\t\t\tif(ABS(A-B)<EPS){\n\t\t\t\tp[i][0]=Pt(ax,ay);p[i][1]=Pt(bx,by);p[i][2]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(B-C)<EPS){\n\t\t\t\tp[i][2]=Pt(ax,ay);p[i][0]=Pt(bx,by);p[i][1]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(C-A)<EPS){\n\t\t\t\tp[i][1]=Pt(ax,ay);p[i][2]=Pt(bx,by);p[i][0]=Pt(cx,cy);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)if(iSP(p[i][0],p[i][2],p[i][1])==-1)swap(p[i][0],p[i][1]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tif(i==j)continue;\n\t\t\tPt t[4];\n\t\t\tt[0]=p[i][0];\n\t\t\tt[1]=p[i][1];\n\t\t\tt[3]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[3]=t[0]+t[3]/t[3].ABS()*(double)b;\n\t\t\tt[2]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[2]=t[1]+t[2]/t[2].ABS()*(double)b;\n\t\t\tbool ok=false;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][k]+(p[j][(k+1)%3]-p[j][k])*10000.0)&&\n\t\t\t\t\tiSS(t[l],t[(l+1)%4],p[j][(k+1)%3],p[j][(k+1)%3]+(p[j][k]-p[j][(k+1)%3])*10000.0))ok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tg[i][j]=1;\n\t\t//\t\tprintf(\"%d %d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]|=g[i][k]&g[k][j];\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)if(g[i][j]&&g[j][i])UNION(i,j);\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(FIND(i)!=FIND(j)&&g[j][i])ok=false;\n\t\t\t}\n\t\t\tif(ok)ret++;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (equal(cross(a, b), 0.0) && dot(a, b) <= 0.0) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() <= 0.0 && 0.0 < b.imag() && cross(a, b) < 0.0) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\t//if (intersect(u, v)) return true;\n\t\t\tif (distance(u, v) < EPS) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs(0);\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(norm(b - a), norm(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tVector a = tri[i][1] - tri[i][0];\n\t\tVector nv = tri[i][0] + (a / 2.0);\n\t\tnv = tri[i][2] - nv;\n\t\tnv /= abs(nv);\n\t\tnv *= d;\n\t\t\n\t\tsqr[i][0] = tri[i][0];\n\t\tsqr[i][1] = tri[i][1];\n\t\tsqr[i][2] = tri[i][1] + nv;\n\t\tsqr[i][3] = tri[i][0] + nv;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tsqr[i].resize(4);\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n\nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);}}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);}};\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { }};\nint ccw(P a, P b, P c) {b -= a; c -= a;if (cross(b, c) > 0)   return +1;if (cross(b, c) < 0)   return -1;if (dot(b, c) < 0) return +2;if (norm(b) < norm(c)) return -2;return 0;}\n\n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n\nconst double PI = 3.14159265358979323846;\n\n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;for (int i = 0; i < P.size(); ++i) {point a = curr(P,i) - p, b = next(P,i) - p;if (imag(a) > imag(b)) swap(a, b);if (imag(a) <= 0 && 0 < imag(b))if (cross(a, b) < 0) in = !in;if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;}return in ? IN : OUT;}\n// Area of Polygon //\ndouble area2(const polygon& P) {double A = 0;for (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));return A;}\n// Totsuhou! Andrew's Monotone Chain //\nvector<point> convex_hull(vector<point> ps) {int n = ps.size(), k = 0;sort(ps.begin(), ps.end());vector<point> ch(2*n);for (int i = 0; i < n; ch[k++] = ps[i++])while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;ch.resize(k-1);return ch;}\n\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\nP reflection(const L &l, const P &p) {return p + 2.0 * (projection(l, p) - p);}\ndouble distanceLP(const L &l, const P &p) {return abs(p - projection(l, p));}\ndouble distanceLL(const L &l, const L &m) {return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);}\ndouble distanceLS(const L &l, const L &s) {if (intersectLS(l, s)) return 0;return min(distanceLP(l, s[0]), distanceLP(l, s[1]));}\ndouble distanceSP(const L &s, const P &p) {const P r = projection(s, p);if (intersectSP(s, r)) return abs(r - p);return min(abs(s[0] - p), abs(s[1] - p));}\ndouble distanceSS(const L &s, const L &t) {if (intersectSS(s, t)) return 0;  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));}\nP crosspoint(const L &l, const L &m) {double A = cross(l[1] - l[0], m[1] - m[0]);double B = cross(l[1] - l[0], l[1] - m[0]);if (abs(A) < EPS && abs(B) < EPS) return m[0];return m[0] + B / A * (m[1] - m[0]);}\n\nint convex_contains(const polygon &P, const point &p) {\n  const int n = P.size();\n  point g = (P[0] + P[n/3] + P[2*n/3]) / 3.0; // inner-point\n  int a = 0, b = n;\n  while (a+1 < b) { // invariant: c is in fan g-P[a]-P[b]\n    int c = (a + b) / 2;\n    if (cross(P[a]-g, P[c]-g) > 0) { // angle < 180 deg\n      if (cross(P[a]-g, p-g) > 0 && cross(P[c]-g, p-g) < 0) b = c;\n      else                                                  a = c;\n    } else {\n      if (cross(P[a]-g, p-g) < 0 && cross(P[c]-g, p-g) > 0) a = c;\n      else                                                  b = c;\n    }\n  }\n  b %= n;\n  if (cross(P[a] - p, P[b] - p) < 0) return 0;\n  if (cross(P[a] - p, P[b] - p) > 0) return 2;\n  return 1;\n}\n\n#define input(A) A.real() >> A.imag()\n#define toRad(n) ((n)*(PI/180.0))\n\nG getrect(G v,double d){\n\tL l(P(0,0),P(0,0));\n\tint a[2];\n\trep(i,3)rep(j,3){\n\t\tif(abs(v[i]-v[j]) > abs(l[0]-l[1]) ){\n\t\t\tl = L(v[i],v[j]);\n\t\t\ta[0] = i , a[1] = j;\n\t\t}\n\t}\n\tP src = l[0] , g;\n\trep(i,3) if(!count(a,a+3,i)) g = v[i];\n\t\n\tl[0]-=src , l[1]-=src , g -= src;\n\trep(i,2){\n\t\tdouble th = atan2(l[1].imag(),l[1].real()) + toRad(90) * (1-i*2);\n\t\tP one = P(cos(th) *  d , sin(th) * d);\n\t\tP two = P(cos(th) *  d , sin(th) * d) + l[1];\n\t\tG gokinyan;\n\t\tgokinyan.push_back(l[0]);\n\t\tgokinyan.push_back(one);\n\t\tgokinyan.push_back(two);\n\t\tgokinyan.push_back(l[1]);\n\t\tif(contains(gokinyan,g)){\n\t\t\trep(i,4)gokinyan[i] += src;\n\t\t\treturn gokinyan;\n\t\t}\n\t}\n\treturn G(4);\n\t\n}\ntypedef vector< vector<int> > Graph;\nbool done[100];\nvoid init(){ rep(i,100)done[i] = false;}\nint n,d;\n\nvoid dfs(int pos,Graph &g,vector<int> &route){\n\tif(done[pos]) return;\n\telse done[pos] = true;\n\trep(i,g[pos].size()) dfs(g[pos][i],g,route);\n\troute.push_back(pos);\n}\n\nint getGraph( Graph &v1 , Graph &v2){\n\tvector<int> r;\n\tinit();\n\trep(i,n) if(!done[i]) dfs(i,v1,r);\n\treverse(all(r));\n\tinit();\n\tint pos[100] , k = 0;\n\trep(i,n){\n\t\tvector<int> v;\n\t\tif(!done[r[i]]){\n\t\t\tdfs(r[i],v2,v);\n\t\t\trep(j,v.size()) pos[v[j]] = k;\n\t\t\tk++;\n\t\t}\n\t}\n\tGraph g1(k),g2(k);\n\trep(i,n) rep(j,v1[i].size())if(pos[i] != pos[v1[i][j]])g1[pos[i]].push_back(pos[v1[i][j]]),g2[pos[v1[i][j]]].push_back(pos[i]);\n\t\n\tv1 = g1 , v2 = g2;\n\treturn k;\n}\nint main(){\n\twhile(cin >> n >> d && n || d){\n\t\tvector<pair<G,int> > data;\n\t\tvector<G> other;\n\t\tGraph graph(n) , r_graph(n); \t\n\t\trep(i,n){\n\t\t\tG v(3);\n\t\t\tcin >> input(v[0]) >> input(v[1]) >> input(v[2]);\n\t\t\tother.push_back(v);\n\t\t\tdata.push_back(make_pair(getrect(v,d),i));\n\t\t}\n\t\t//rep(i,n){rep(j,4) cout << data[i].first[j] <<\" \";cout << endl;}\n\t\trep(i,n)rep(j,n){\n\t\t\tif(i == j) continue;\n\t\t\tbool isok = false;\n\t\t\trep(k,3) isok |= !!contains(data[i].first,other[j][k]);\n\t\t\trep(k,3) rep(l,3) rep(m,4){\n\t\t\t\tif(k != l) isok |= intersectSS(L(data[i].first[m],data[i].first[(m+1)%4]),L(other[j][l],other[j][k]));\n\t\t\t}\n\t\t\tif(isok) graph[i].push_back(j) , r_graph[j].push_back(i);\n\t\t}\n\t\t/*rep(i,n){\n\t\t\tcout << \"[n\" << i << \"] : \";\n\t\t\trep(j,graph[i].size()) cout << graph[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t\tcout << \"[r\" << i << \"] : \";\n\t\t\trep(j,r_graph[i].size()) cout << r_graph[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}*/\n\t\tn = getGraph(graph,r_graph);\n\t\t\n\t\t/*rep(i,n){\n\t\t\tcout << \"[\" << i << \"] : \";\n\t\t\trep(j,r_graph[i].size()){\n\t\t\t\tcout << r_graph[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\t\n\t\tint cnt = 0;\n\t\trep(i,n) cnt += !r_graph[i].size();\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc()\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tvector<int> cmp(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tbool f = false;\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\t\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t\tf = true;\n\t\t}\n\t\tassert(f);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>> sccgraph = scc();\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0) res++;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n  n=tmpn;\n  rep(i,n)assert(component[i] < n);\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      /*\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n      */\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[ j].pb(i);\n      }else if (is_intersected_polygon(tri[i],tri[j])){\n\t//\tassert(false);\n\tinedge[i].pb(j);\n\tredge[ j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-5;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      break;\n    }\n  }while(next_permutation(in,in+3));\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-3;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nint V;\nvector<vector<int> > G,rG;\nvector<int> vs;\nbool used[100];\nint cmp[100];\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]){\n      dfs(G[v][i]);\n    }\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]){\n      rdfs(rG[v][i],k);\n    }\n  }\n}\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[2])>eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    G=rG=vector<vector<int> >(n);\n    vs.clear();\n    bool e[100][100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<eps;\n\t      e[i][j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    e[i][j]|=!f;\n\t    if(e[i][j]){\n\t      G[i].push_back(j);\n\t      rG[j].push_back(i);\n\t    }\n\t  }\n\t}\n      }\n    }\n    V=n;\n    fill(begin(used),end(used),false);\n    for(int v=0;v<V;v++){\n      if(!used[v]){\n\tdfs(v);\n      }\n    }\n    fill(begin(used),end(used),false);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]]){\n\trdfs(vs[i],k++);\n      }\n    }\n    bool in[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(e[i][j]&&cmp[i]!=cmp[j]){\n\t  in[cmp[j]]=true;\n\t}\n      }\n    }\n    cout<<count(in,in+k,false)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-8;\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      //if (     cross(a[in[0]]-a[in[1]],a[in[2]]-a[in[1]]) >=0)\n      //\tassert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])>=0);\n      //      else assert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])<=0);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  //assert(false);\n  return ret;\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<-eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <-eps))return true;\n  else return false;\n}\n\n#define DSS distance_ls_p\ndouble distance_ss_p(P a,P b,P c,P d){\n  return min(  min( DSS(a,b,c),DSS(a,b,d)),min(DSS(c,d,a),DSS(c,d,b)));\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri,double d){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }else {\n\trep(k,tri[j].size()){\n\t  if (is_in(tri[i],tri[j][k])&&\n\t      (distance_ss_p(sq[i][0],sq[i][1],tri[j][0],tri[j][1])<d+eps ||\n\t       distance_ss_p(sq[i][0],sq[i][1],tri[j][1],tri[j][2])<d+eps||\n\t       distance_ss_p(sq[i][0],sq[i][1],tri[j][2],tri[j][0])<d+eps)\n\t      ){\n\t    assert(false);\n\t    inedge[i].pb(j);\n\t    redge[j].pb(i);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in,d);\n\n\n    //rep(i,n){rep(j,sq[i].size())cout<< sq[i][j];cout << endl;}\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<stack>\n#include<complex>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nconst double EPS = 0.1;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > EPS)   return +1;       // counter clockwise\n  if (cross(b, c) < EPS)   return -1;       // clockwise\n\tif (dot(b, c) < EPS)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)-EPS) return -2;       // a--b--c on line\n  return 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)+EPS) swap(a, b);\n    if (imag(a) < -EPS && EPS < imag(b))\n      if (cross(a, b) < -EPS) in = !in;\n    if (abs(cross(a, b)) < EPS  && dot(a, b) < EPS) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) < EPS &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) < EPS;\n}\nbool intersect(G &rect, G &tri){\n\trep(i,3)if(contains(rect,tri[i]))return 1;\n\trep(i,4)if(contains(tri,rect[i]))return 1;\n\trep(i,3){\n\t\tL l(tri[i],tri[(i+1)%3]);\n\t\trep(j,4)if(intersectSS(l,L(rect[i],rect[(i+1)%4])))return 1;\n\t}\n\treturn 0;\n}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight=0) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid visit(const Graph &g, int v, vector< vector<int> >& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  fr(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const Graph& g,\n    vector< vector<int> >& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint main(){\n\tint n;\n\tdouble d;\n\twhile(cin>>n>>d,n){\n\t\tvector<G> tri;\n\t\trep(i,n){\n\t\t\tdouble a,b,c,d,e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tG p; p.pb(P(a,b)); p.pb(P(c,d)); p.pb(P(e,f));\n\t\t\tif(abs(abs(p[2]-p[0])-abs(p[2]-p[1]))>EPS){\n\t\t\t\tif(abs(abs(p[2]-p[0])-abs(p[1]-p[0]))<EPS)swap(p[2],p[0]);\n\t\t\t\telse swap(p[1],p[0]);\n\t\t\t}\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\tGraph e(n);\n\t\t\n\t\trep(i,n)rep(j,n)if(i!=j){\n\t\t\t\n\t\t\tG &p=tri[i];\n\t\t\tP m=(p[0]+p[1])*0.5,dir=(p[2]-m)*(d/abs(p[2]-m));\n\t\t\t\n\t\t\tG rect;\n\t\t\trect.pb(p[0]); rect.pb(p[1]);\n\t\t\trect.pb(p[1]+dir); rect.pb(p[0]+dir);\n\t\t\tif(ccw(rect[0],rect[1],rect[2])<0)reverse(rect.begin(),rect.end());\n\t\t\t\n\t\t\tif(intersect(rect,tri[j]))e[i].pb(Edge(i,j));\n\t\t}\n\t\t\n\t\tvector<vector<int> > scc;\n\t\tstronglyConnectedComponents(e,scc);\n\t\tint m=scc.size(),to[100],in[100]={0},ans=0;\n\t\trep(i,m)fr(j,scc[i])to[*j]=i;\n\t\trep(i,n)fr(j,e[i])if(to[i]!=to[j->dst])\n\t\tin[to[j->dst]]++;\n\t\t\n\t\trep(i,m)if(in[i]==0)ans++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-8;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nPoly tri[110];\nPoly rect[110];\n\ninline P unit(P p){return p/abs(p);}\ninline D dot(P x,P y){return real(conj(x)*y);}\ninline D cross(P x,P y){return imag(conj(x)*y);}\n\ninline vector<P> convex_hull(vector<P> v){\n  int n = v.size(), k = 0;\n  sort(v.begin(),v.end());\n  vector<P> r(2*n);\n  for(int i=0;i<n;i++){\n    while(k>1 && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= EPS)k--;\n    r[k++] = v[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= EPS)k--;\n    r[k++] = v[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\ninline int ccw(P &a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\ninline bool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline bool inter_pos(Poly &p,P &x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\ninline bool cross_poly(Poly &a, Poly &b){\n  int n1 = a.size(), n2 = b.size();\n  rep(i,n2)if(inter_pos(a,b[i]))return true;\n  rep(i,n1)if(inter_pos(b,a[i]))return true;\n  rep(i,n1)rep(j,n2)\n    if(is_cp(L(a[i],a[(i+1)%n1]),L(b[j],b[(j+1)%n2])))return true;\n  return false;\n}\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\ninline int scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&d), n+d){\n    rep(i,n){\n      tri[i].resize(3);\n      scanf(\"%lf%lf\",&tri[i][0].real(),&tri[i][0].imag());\n      scanf(\"%lf%lf\",&tri[i][1].real(),&tri[i][1].imag());\n      scanf(\"%lf%lf\",&tri[i][2].real(),&tri[i][2].imag());\n      tri[i] = convex_hull(tri[i]);\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]); break;\n\t}\n      }\n\n      P ver = (D)d*unit((rect[i][0]-rect[i][1])*P(0,-1));\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n      rect[i] = convex_hull(rect[i]);\n    }\n\n    rep(i,n){g[i].clear(); rg[i].clear();}\n    rep(i,n){\n      rep(j,n){\n\tif(i==j)continue;\n\tif(cross_poly(rect[i],tri[j])){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n  \n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    printf(\"%d\\n\",res);\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-2;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nint g[110][110];\nPt p[110][3];\nint UF[110];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[i][i]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble ax,bx,cx,ay,by,cy;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n\t\t\tdouble A=(bx-cx)*(bx-cx)+(by-cy)*(by-cy);\n\t\t\tdouble B=(ax-cx)*(ax-cx)+(ay-cy)*(ay-cy);\n\t\t\tdouble C=(ax-bx)*(ax-bx)+(ay-by)*(ay-by);\n\t\t\tif(ABS(A-B)<EPS){\n\t\t\t\tp[i][0]=Pt(ax,ay);p[i][1]=Pt(bx,by);p[i][2]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(B-C)<EPS){\n\t\t\t\tp[i][2]=Pt(ax,ay);p[i][0]=Pt(bx,by);p[i][1]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(C-A)<EPS){\n\t\t\t\tp[i][1]=Pt(ax,ay);p[i][2]=Pt(bx,by);p[i][0]=Pt(cx,cy);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)if(iSP(p[i][0],p[i][2],p[i][1])==-1)swap(p[i][0],p[i][1]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tif(i==j)continue;\n\t\t\tPt t[4];\n\t\t\tt[0]=p[i][0];\n\t\t\tt[1]=p[i][1];\n\t\t\tt[3]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[3]=t[0]+t[3]/t[3].ABS()*(double)b;\n\t\t\tt[2]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[2]=t[1]+t[2]/t[2].ABS()*(double)b;\n\t\t\tbool ok=false;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tbool L=false;\n\t\t\t\tbool R=false;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][k]+(p[j][(k+1)%3]-p[j][k])*1000000.0))L=true;\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][(k+1)%3],p[j][(k+1)%3]+(p[j][k]-p[j][(k+1)%3])*1000000.0))R=true;\n\t\t\t\t}\n\t\t\t\tif(L&&R)ok=true;\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tg[i][j]=1;\n\t\t//\t\tprintf(\"%d %d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]|=g[i][k]&g[k][j];\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)if(g[i][j]&&g[j][i])UNION(i,j);\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(FIND(i)!=FIND(j)&&g[j][i])ok=false;\n\t\t\t}\n\t\t\tif(ok)ret++;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-1;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (equal(cross(a, b), 0.0) && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) < -EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\t//if (intersect(u, v)) return true;\n\t\t\tif (distance(u, v) < EPS) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs(0);\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(norm(b - a), norm(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tVector a = tri[i][1] - tri[i][0];\n\t\tVector nv = tri[i][0] + (a / 2.0);\n\t\tnv = tri[i][2] - nv;\n\t\tnv /= abs(nv);\n\t\tnv *= d;\n\t\t\n\t\tsqr[i][0] = tri[i][0];\n\t\tsqr[i][1] = tri[i][1];\n\t\tsqr[i][2] = tri[i][1] + nv;\n\t\tsqr[i][3] = tri[i][0] + nv;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tsqr[i].resize(4);\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<stack>\n#include<complex>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nconst double EPS = 1e-2;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersect(G &rect, G &tri){\n\trep(i,3)if(contains(rect,tri[i]))return 1;\n\trep(i,3){\n\t\tL l(tri[i],tri[(i+1)%3]);\n\t\trep(j,4)if(intersectSS(l,L(rect[i],rect[(i+1)%4])))return 1;\n\t}\n\treturn 0;\n}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight=0) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid visit(const Graph &g, int v, vector< vector<int> >& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  fr(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const Graph& g,\n    vector< vector<int> >& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint main(){\n\tint n;\n\tdouble d;\n\twhile(cin>>n>>d,n){\n\t\tvector<G> tri;\n\t\trep(i,n){\n\t\t\tdouble a,b,c,d,e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tG p; p.pb(P(a,b)); p.pb(P(c,d)); p.pb(P(e,f));\n\t\t\tif(abs(p[2]-p[0])!=abs(p[2]-p[1])){\n\t\t\t\tif(abs(p[2]-p[0])==abs(p[1]-p[0]))swap(p[2],p[0]);\n\t\t\t\telse swap(p[1],p[0]);\n\t\t\t}\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\tGraph e(n);\n\t\t\n\t\trep(i,n)rep(j,n)if(i!=j){\n\t\t\t\n\t\t\tG &p=tri[i];\n\t\t\tP m=(p[0]+p[1])*0.5,dir=(p[2]-m)*(d/abs(p[2]-m));\n\t\t\t\n\t\t\tG rect;\n\t\t\trect.pb(p[0]); rect.pb(p[1]);\n\t\t\trect.pb(p[1]+dir); rect.pb(p[0]+dir);\n\t\t\tif(ccw(rect[0],rect[1],rect[2])<0)reverse(rect.begin(),rect.end());\n\t\t\t\n\t\t\tif(intersect(rect,tri[j]))e[i].pb(Edge(i,j));\n\t\t}\n\t\t\n\t\tvector<vector<int> > scc;\n\t\tstronglyConnectedComponents(e,scc);\n\t\tint m=scc.size(),to[100],in[100]={0},ans=0;\n\t\trep(i,m)fr(j,scc[i])to[*j]=i;\n\t\trep(i,n)fr(j,e[i])if(to[i]!=to[j->dst])\n\t\tin[to[j->dst]]++;\n\t\t\n\t\trep(i,m)if(in[i]==0)ans++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\ndouble d,tx[100][3],ty[100][3],bx[100][4],by[100][4];\nint n,f[100],f2[100],mc;\n\nstruct gr {\n\tint t,f;\n\tint to[100],fr[100];\n};\n\n\ngr g[100];\n\nvoid makebox() {\n\tint i,j,j1,j2,a,a1,a2;\n\tdouble vx1,vy1,vx2,vy2,b;\n\tfor (i=0;i<n;i++) {\n\t\tfor (j=0;j<3;j++) {\n\t\t\tj1=(j+1) % 3; j2=(j+2) % 3;\n\t\t\tif (((tx[i][j]-tx[i][j1])*(tx[i][j]-tx[i][j1])+(ty[i][j]-ty[i][j1])*(ty[i][j]-ty[i][j1]))-((tx[i][j]-tx[i][j2])*(tx[i][j]-tx[i][j2])+(ty[i][j]-ty[i][j2])*(ty[i][j]-ty[i][j2]))==0) a=j;\n\t\t}\n\t\ta1=(a+1) % 3; a2=(a+2) % 3;\n\t\tvx1=tx[i][a]-(tx[i][a1]+tx[i][a2])/2;\n\t\tvy1=ty[i][a]-(ty[i][a1]+ty[i][a2])/2;\n\t\tb=sqrt(vx1*vx1+vy1*vy1);\n\t\tbx[i][0]=tx[i][a1]; by[i][0]=ty[i][a1];\n\t\tbx[i][1]=tx[i][a2]; by[i][1]=ty[i][a2];\n\t\tvx2=d*vx1/b; vy2=d*vy1/b;\n\t\tbx[i][2]=bx[i][1]+vx2; by[i][2]=by[i][1]+vy2;\n\t\tbx[i][3]=bx[i][0]+vx2; by[i][3]=by[i][0]+vy2;\n\t}\n}\nint hit(int n1,int n2) {\n\tint i,j,k;\n\tdouble a,b,mtb,mt,mb,vx1,vy1,vx2,vy2,vx[5],vy[5];\n\tfor (i=0;i<2;i++) { vx[i]=bx[n1][i+1]-bx[n1][i]; vy[i]=by[n1][i+1]-by[n1][i];}\n\tfor (i=0;i<3;i++) { vx[2+i]=tx[n2][(i+1) % 3]-tx[n2][i]; vy[2+i]=ty[n2][(i+1) % 3]-ty[n2][i];}\n\tfor (i=0;i<5;i++) {\n\t\t vx2=-vy[i]; vy2=vx[i];\n\t\t vx1=vx2/sqrt(vx2*vx2+vy2*vy2); vy1=vy2/sqrt(vx2*vx2+vy2*vy2);\n\t\t mtb=0;\n\t\tfor (j=0;j<3;j++) for (k=0;k<4;k++) {\n\t\t vx2=bx[n1][k]-tx[n2][j]; vy2=by[n1][k]-ty[n2][j];\n\t\t a=vx2*vx1+vy2*vy1; if (a<0) a=-a;\n\t\t if (a>mtb) mtb=a;\n\t     }\n\t     a=vx[0]*vx1+vy[0]*vy1; if (a<0) a=-a;\n\t     b=vx[1]*vx1+vy[1]*vy1; if (b<0) b=-b;\n\t     mb=a+b;\n\t     mt=0;\n\t     for (j=0;j<3;j++) { a=(vx[2+j]*vx1+vy[2+j]*vy1)/2; if (a<0) a=-a;  mt+=a;  }\n\t     if (mtb-mt-mb>0.01) return 0;   \n\t\t      }\n\t\t return 1;     \n         }\n         \nvoid  search(int s) {\n\tint i;\n\tmc++; f2[s]=1;\n\tfor (i=0;i<g[s].t;i++) if (f[g[s].to[i]]==0 && f2[g[s].to[i]]==0) search(g[s].to[i]);\n }\n  \nint main() {\n\tint i,j,ans,mn,mi,t;\n\twhile (true) {\n\tcin >> n >> d;\n\tif (n==0) break;\n    for (i=0;i<n;i++) {\n\t\tfor (j=0;j<3;j++) cin >> tx[i][j] >> ty[i][j];\n\t\tg[i].t=g[i].f=0;\n\t    }\n    makebox(); t=n;\n    for (i=0;i<n;i++) for (j=0;j<n;j++) if (i!=j) {if (hit(i,j)==1) { g[i].to[g[i].t]=j; g[i].t++; g[j].fr[g[j].f]=i; g[j].f++;}}\n\tfor (i=0;i<n;i++) f[i]=0; ans=0;\n\twhile (t>0) {\n\t\t   mn=0;\n\t       for (i=0;i<n;i++) {\n\t\t   if (f[i]==0) {\n\t\t\t   for (j=0;j<n;j++) f2[j]=0;\n\t\t\t   mc=0; search(i);\n\t\t\t   if (mc>mn) { mi=i; mn=mc;}\n\t\t\t   }\n\t\t   }\n\t\t   for (j=0;j<n;j++) f2[j]=0;\n\t\t   mc=0; search(mi);\n\t\t   for (j=0;j<n;j++) if (f2[j]==1) f[j]=1;\n\t\t   t-=mc;\n\t\t   ans++;\t    \n           }\n           cout << ans << endl; \n      }\n     return 0;\n}  \t "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n\tcross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n\t( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <cassert>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nconst double EPS = 0.01;\n\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\n \ndouble area(vector<P> p){\n\tdouble S = 0 ; \n\tp.push_back(p[0]);\n\t/*　多角形の面積公式 (反時計回りの場合) */\n\tfor(int i = 0 ; i < p.size()-1 ; i++){\n\t\tS += (p[i].real() - p[i+1].real()) * (p[i].imag()+p[i+1].imag());\n\t}\n\tS /= 2.0;\n\treturn S;\n}\nbool contains(vector<P> &a,P b){\n\t//b = (-10000,-10000);\n\tdouble ans = 0;\n\tfor(int i = 0 ; i < a.size() ; i++){\n\t\tvector<P> w;\n\t\tw.push_back(a[i]);\n\t\tw.push_back(a[(i+1)%a.size()]);\n\t\tw.push_back(b);\n\t\tans += abs(area(w));\n\t}\n\tans = abs(ans);\n\t//cout << a[0] << \" \" << a[1] << \" \" << a[2] << \" \" << a[3] << \" \" << b << \" \" << (fabs(abs(area(a)) - ans ) < EPS) << endl;\n\t//cout << ans << \" \" << abs(area(a)) << \" \" << a.size() << endl;\n\treturn fabs(abs(area(a)) - ans ) < EPS;\n}\n\n/*\n\t幾何: \n\t\t・凸多角形の点包含判定\n\t\t・凸多角形同士の線分交差判定\n\tグラフ:\n\t\t・強連結成分分解\n\t\t・入次数数える\n*/\n\nint n;\n\n\nbool eq(double a,double b){\n\treturn fabs(a-b) < EPS;\n}\n\nint done[100] ={};\nint wf[100][100]={};\n\nint dfs(int pos){\n\tif( done[pos] ) return 0;\n\telse done[pos] = 1;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif(wf[pos][i])dfs(i);\n\t}\n}\nint main(){\n\tdouble d;\n\twhile(cin >> n >> d && n ){\n\t\tmemset(done,0,sizeof(done));\n\t\tmemset(wf,0,sizeof(wf));\n\t\t\n\t\tvector<G> g(n);\n\t\tvector<G> g2(n);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x1,x2,x3,y1,y2,y3;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\t\tg[i].push_back(P(x1,y1));\n\t\t\tg[i].push_back(P(x2,y2));\n\t\t\tg[i].push_back(P(x3,y3));\n\t\t\tdouble A = abs( P(x2,y2) - P(x1,y1) );\n\t\t\tdouble B = abs( P(x2,y2) - P(x3,y3) );\n\t\t\tdouble C = abs( P(x3,y3) - P(x1,y1) );\n\t\t\tL l(P(-1,-1),P(-1,-1));\n\t\t\tif( eq(A,B) ) l = L( P(x3,y3) , P(x1,y1) );\n\t\t\telse if( eq(A,C) ) l = L( P(x2,y2) , P(x3,y3) );\n\t\t\telse if( eq(B,C) ) l = L( P(x2,y2) , P(x1,y1) );\n\t\t\telse while(1){}\n\t\t\t\n\t\t\tassert( !( eq(A,B) && eq(B,C) ) );\n\t\t\tP r = l[1] - l[0];\n\t\t\tr = P(-r.imag(),r.real());\n\t\t\tr /= abs(r);\n\t\t\t\n\t\t\t//cout << A << \" \" << B << \" \" << C << \" \" << l[0] << \"-\" << l[1] << \" \" << r << endl;\n\t\t\tfor(int coef = -1 ; coef <= 1 ; coef += 2 ){\n\t\t\t\tvector<P> XX;\n\t\t\t\tXX.push_back(l[0]);\n\t\t\t\tXX.push_back(l[0] + coef * d * r );\n\t\t\t\tXX.push_back(l[1] + coef * d * r );\t\t\t\n\t\t\t\tXX.push_back(l[1]);\n\t\t\t\tint ok = 1;\n\t\t\t\t\n\t\t\t\tfor(int j = 0 ; j < 3 ; j++){\n\t\t\t\t\tif( !contains(XX,g[i][j]) ){\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( ok ) {\n\t\t\t\t\tif( g2[i].size() ) assert(0);\n\t\t\t\t\tg2[i] = XX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif( i != j ) {\n\t\t\t\t\tint ok = 0;\n\t\t\t\t\tfor(int l = 0 ; l < 3 ; l++){\n\t\t\t\t\t\tif( contains(g2[i],g[j][l]) ){\n\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0 ; k < 4 ; k++){\n\t\t\t\t\t\tfor(int l = k+1 ; l < 4 ; l++){\n\t\t\t\t\t\t\tfor(int m = 0 ; m < 3 ; m++){\n\t\t\t\t\t\t\t\tfor(int o = m+1 ; o < 3 ; o++){\n\t\t\t\t\t\t\t\t\tif( intersectSS(L(g2[i][k],g2[i][l]),L(g[j][m],g[j][o])) ){\n\t\t\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( ok ) {\n\t\t\t\t\t\twf[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\t\tfor(int k = 0 ; k < n ; k++)\n\t\t\t\t\twf[j][k] |= wf[j][i] & wf[i][k];\n\t\tint in[100] = {};\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif(wf[i][j]) in[j]++;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif( !done[i] && !in[i] ){\n\t\t\t\tdfs(i);\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif( !done[i] ){\n\t\t\t\tdfs(i);\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\n#define MAX_N (128)\n#define EPS (0.01)\n#define SQ(X) ((X) * (X))\n\nusing namespace std;\n\nclass Triangle {\n\tpublic:\n        double x[3], y[3];\n\t    int no;\n};\n\nclass Point {\n    public:\n    \tdouble x, y;\n        \n\t    Point Point::operator - (Point &a){\n            Point ret;\n\t\t    ret.x = x - a.x;\n\t\t    ret.y = y - a.y;\n\t\t    return (ret);\n\t    }\n};\n\nvector<int> G[MAX_N];\nvector<int> rG[MAX_N];\nvector<int> compress[MAX_N];\nvector<int> vs;\nbool used[MAX_N];\nbool group[MAX_N];\nint cmp[MAX_N];\nint N;\n\nvoid addEdge(int from, int to)\n{\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v)\n{\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++){\n        if (!used[G[v][i]]){\n            dfs(G[v][i]);\n        }\n    }\n    vs.push_back(v);\n}\n\nvoid revDfs(int v, int k)\n{\n    used[v] = true;\n    cmp[v] = k;\n    for (int i = 0; i < rG[v].size(); i++){\n        if (!used[rG[v][i]]){\n            revDfs(rG[v][i], k);\n        }\n    }\n}\n\nint scc()\n{\n    int ret;\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    \n    for (int i = 0; i < N; i++){\n        if (!used[i]){\n            dfs(i);\n        }\n    }\n    \n    memset(used, 0, sizeof(used));\n    \n    ret = 0;\n    for (int i = vs.size() - 1; i >= 0; i--){\n        if (!used[vs[i]]){\n            revDfs(vs[i], ret++);\n        }\n    }\n    \n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < G[i].size(); j++){\n            if (cmp[i] != cmp[G[i][j]]){\n                compress[cmp[G[i][j]]].push_back(cmp[i]);\n            }\n        }\n    }\n    \n    return (ret);\n}\n\ndouble inProduct(Point a, Point b)\n{\n\treturn (a.x * b.x + a.y * b.y);\n}\n\ndouble getSize(Point a)\n{\n\treturn (sqrt(SQ(a.x) + SQ(a.y)));\n}\n\nbool checkCross(Point p1, Point p2, Point p3, Point p4)\n{\n    double check1 = (p2.x - p1.x) * (p4.y - p3.y) - (p2.y - p1.y) * (p4.x - p3.x);\n    \n    Point pq = p3 - p1;\n    \n    double check2 = (p4.y - p3.y) * pq.x - (p4.x - p3.x) * pq.y;\n    double check3 = (p2.y - p1.y) * pq.x - (p2.x - p1.x) * pq.y;\n    \n    \n    if (check1 > EPS){\n        return (0 <= check3 / check1 && check3 / check1 <= 1 && 0 <= check2 / check1 && check2 / check1 <= 1);\n    }\n    \n    return (fabs(check2) <= EPS && fabs(check3) <= EPS);\n}\n\nvoid judgeAdj(Triangle a, Triangle b, double dist)\n{\n\tdouble len;\n\tPoint p[4];\n\t\n\tlen = 0.0;\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\tif (len < SQ(a.x[i] - a.x[j]) + SQ(a.y[i] - a.y[j])){\n\t\t\t\tlen = SQ(a.x[i] - a.x[j]) + SQ(a.y[i] - a.y[j]);\n\t\t\t\tp[0].x = a.x[i], p[0].y = a.y[i];\n\t\t\t\tp[1].x = a.x[j], p[1].y = a.y[j];\n\t\t\t}\n\t\t}\n\t}\n    //printf(\"%lf %lf %lf %lf\\n\", p[0].x, p[0].y, p[1].x, p[1].y);\n\tPoint e, sa;\n\t\n    e.x = 0, e.y = 1;\n\tsa = p[0] - p[1];\n\tdouble theta = acos(inProduct(e, sa) / (getSize(e) * getSize(sa)));\n    theta = min(theta, M_PI - theta);\n\t//printf(\"theta = %lf\\n\", theta);\n    \n\tp[2].x = p[0].x + dist * cos(theta), p[2].y = p[0].y + dist * sin(theta);\n\tp[3].x = p[1].x + dist * cos(theta), p[3].y = p[1].y + dist * sin(theta);\n\t\n\tbool cross = false;\n\t\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = i + 1; j < 3; j++){\n            Point k[2];\n            k[0].x = b.x[i], k[0].y = b.y[i];\n            k[1].x = b.x[j], k[1].y = b.y[j];\n\t\t\tcross |= checkCross(k[0], k[1], p[0], p[1]);\n\t\t\tcross |= checkCross(k[0], k[1], p[0], p[2]);\n\t\t\tcross |= checkCross(k[0], k[1], p[1], p[3]);\n\t\t\tcross |= checkCross(k[0], k[1], p[2], p[3]);\n\t\t}\n\t}\n\t\n\tif (cross == true){\n        //printf(\"hoge, %d, %d\\n\", a.no, b.no);\n\t\taddEdge(a.no, b.no);\n\t}\n\t\n}\n\nint main()\n{\n\tint n, d;\n\tTriangle data[128];\n\t\n\twhile (1){\n\t\t\n\t\tscanf(\"%d %d\", &n, &d);\n\t\t\n        N = n;\n\t\tif (n + d == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tdata[i].no = i;\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tscanf(\"%lf%lf\", &data[i].x[j], &data[i].y[j]);\n\t\t\t}\n\t\t}\n\t\t\n        for (int i = 0; i < n; i++){\n            G[i].clear();\n            rG[i].clear();\n            compress[i].clear();\n        }\n        \n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n                if (i != j){\n    \t\t\t\tjudgeAdj(data[i], data[j], d);\n                }\n\t\t\t}\n\t\t}\n\t\t\n\t\tint k = scc();\n    \t\n    \tint ans = 0;\n    \tmemset(used, 0, sizeof(used));\n    \t\n    \tfor (int i = 0; i < k; i++){\n        \tif (compress[i].size() == 0){\n        \t    ans++;\n        \t}\n    \t}\n    \t\n    \tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-8)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) * SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G &a, G &b)\n{\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)) return true;\n\t\t}\n\t}\n\tfor (int i = 0; i < a.size(); i++){\n\t\tif (contains(b, a[i])) return true;\n\t}\n\tfor (int i = 0; i < b.size(); i++){\n\t\tif (contains(a, b[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) res++;\n\t\tfor (int to : sccgraph[i]){\n\t\t\tused[to] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-7, AD = 1e-2;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0){\n\t    swap(rect[i][0],rect[i][1]); break;\n\t  }\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k])){\n\t    f = true; break;\n\t  }\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3)if(seg_p_dis(rseg,tri[j][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,3){\n\t    L tseg = L(tri[j][k],rect[j][(k+1)%3]);\n\t    rep(l,4)if(seg_p_dis(tseg,rect[i][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < (int)n; i++)\n#define EPS (1e-8)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n#define MAX 100\nclass Point{\npublic:\ndouble x, y;\n  Point ( double x = 0, double y = 0):x(x),y(y){}\n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - (Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * (double a ){ return Point(x*a, y*a); }\n\n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw( Point p0, Point p1, Point p2 ){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n  if ( cross(a, b) < -EPS ) return CLOCKWISE;\n  if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n  if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n  return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool isInside(Polygon gon, Point p ){\n  for ( int i = 0; i < gon.size(); i++ ){\n    if ( ccw(gon[i], gon[(i+1)%gon.size()], p) == CLOCKWISE ) return false;\n  }\n  return true;\n}\n\nclass Triangle{\npublic:\n  vector<Point> P;\n  Triangle(){ P.resize(3);}\n  void normalize(){\n    vector<Point> tmp(3);\n    if ( norm(P[0]-P[1]) == norm(P[0]-P[2]) ){\n      tmp[0] = P[1]; tmp[1] = P[2]; tmp[2] = P[0];\n    } else if ( norm(P[1]-P[0]) == norm(P[1]-P[2]) ){\n      tmp[0] = P[0]; tmp[1] = P[2]; tmp[2] = P[1];\n    } else if ( norm(P[2]-P[0]) == norm(P[2]-P[1]) ){\n      tmp[0] = P[0]; tmp[1] = P[1]; tmp[2] = P[2];\n    }\n    P = tmp;\n    if ( ccw(P[0], P[1], P[2]) != COUNTER_CLOCKWISE ) {\n      swap(P[0], P[1]);\n    }\n  }\n};\n\nclass Graph{\npublic:\n  int n;\n  vector<vector<int> > adj;\n  Graph(int n = 0):n(n){\n    adj.resize(n);\n    rep(i, n) adj[i].clear();\n  }\n  void connect(int i, int j){ adj[i].push_back(j); }\n  void transpose(){\n    vector<vector<int> > nadj;\n    nadj.resize(n);\n    rep(i, n) nadj[i].clear();\n    rep(i, n) rep(j, adj[i].size()) nadj[adj[i][j]].push_back(i);\n    rep(i, n) adj[i] = nadj[i];\n  }\n};\n\nint n;\ndouble d;\nTriangle T[MAX];\n\nGraph g;\nint visited[MAX], finish[MAX], t;\nvector<int> com;\n\nbool overlapPolygon(Polygon p1, Polygon p2){\n  rep(i, p1.size()) if ( isInside(p2, p1[i]) ) return true;\n  rep(i, p2.size()) if ( isInside(p1, p2[i]) ) return true;\n  rep(i, p1.size()) rep(j, p2.size()){\n    if ( isIntersect(p1[i], p1[(i+1)%p1.size()], p2[j], p2[(j+1)%p2.size()]))\n      return true;\n  }\n  return false;\n}\n\nbool overlap( int t1, int t2){\n  Triangle s = T[t1];\n  vector<Point> rect, tri;\n  Point c = Point((s.P[0].x+s.P[1].x)/2, (s.P[0].y+s.P[1].y)/2);\n  Vector v = s.P[2] - c;\n  double a = v.abs();\n  v.x = d*v.x/a;\n  v.y = d*v.y/a;\n  Point l = s.P[0] + v;\n  Point r = s.P[1] + v;\n  rect.push_back(s.P[1]);\n  rect.push_back(r);\n  rect.push_back(l);\n  rect.push_back(s.P[0]);\n  tri = T[t2].P;\n  return overlapPolygon(rect, tri);\n}\n\nvoid dfs(int &u){\n  visited[u] = t++;\n  rep(i, g.adj[u].size()){\n    int v = g.adj[u][i];\n    if ( visited[v] == -1 ) dfs(v);\n  }\n  finish[u] = t++;\n}\n\nvoid dfsT(int &u){\n  com.push_back(u);\n  visited[u] = 1;\n  rep(i, g.adj[u].size()){\n    int v = g.adj[u][i];\n    if ( visited[v] == 0 ) dfsT(v);\n  }\n}\n\nvoid makeGraph(){\n  g = Graph(n);\n  rep(i, n) rep(j, n){\n    if ( i != j && overlap(i, j) ) {\n      g.connect(i, j);\n    }\n  }\n}\n\nint scc(){\n  int id[MAX];\n  bool indeg[MAX];\n  rep(i, n) visited[i] = finish[i] = -1;\n  t = 0;\n  rep(i, n) if ( visited[i] == -1 ) dfs(i);\n  g.transpose();\n  vector<pair<int, int> > order;\n  rep(i, n) order.push_back(make_pair(finish[i], i));\n  sort(order.begin(), order.end());\n  rep(i, n) visited[i] = 0;\n  int ncom = 0;\n  for ( int i = n-1; i >= 0; i-- ){\n    int u = order[i].second;\n    com.clear();\n    if ( visited[u] == 0 ) {\n      dfsT(u);\n      rep(c, com.size()) id[com[c]] = ncom;\n      ncom++;\n    }\n  }\n  int cnt = 0;\n  g.transpose();\n  rep(i, ncom) indeg[i] = false;\n  rep(u, n) rep(i, g.adj[u].size()){\n    int v = g.adj[u][i];\n    if ( id[v] != id[u] ) indeg[id[v]] = true;\n  }\n  rep(i, ncom) if (!indeg[i]) cnt++;\n  return cnt;\n}\n\nmain(){\n  while( cin >> n >> d && n ){\n    rep(i, n){\n      Triangle t;\n      rep(j, 3) cin >> t.P[j].x >> t.P[j].y;\n      t.normalize();\n      T[i] = t;\n    }\n    makeGraph();\n    cout << scc() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cfloat>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define EPS (1e-8)\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint ( double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n\tPoint operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n\tPoint operator * ( double a ){ return Point(x*a, y*a); }\n\tdouble abs() { return sqrt(norm());}\n\tdouble norm() { return x*x + y*y; }\n\tbool operator < ( const Point &p ) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == ( const Point &p ) const {\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs(Vector a) {return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b) {return (sqrt(norm(a - b)));}\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\ndouble eq(double a, double b)\n{\n\treturn (fabs(a - b) <= EPS);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n//3点の位置関係を求める\nint ccw( Point p0, Point p1, Point p2 ){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( norm(a) < norm(b) ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//A = p2 - p1, B = p4 - p3が交差するか\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n\n\n//多角形の中に点があるか\nbool isInside(Polygon gon, Point p ){\n\tfor ( int i = 0; i < gon.size(); i++ ){\n\t\tif ( ccw(gon[i], gon[(i+1)%gon.size()], p) == CLOCKWISE ) return (false);\n\t}\n\treturn (true);\n}\n\n//単位ベクトルを求める\nPoint unitVector(Point t){\n\tdouble u=abs(t);\n\treturn Point(t.x/u , t.y/u);\n}\n//cosθを求める\ndouble getcos(Point a , Point b){\n\treturn (dot(a,b) / (abs(a)*abs(b)));\n}\n\n//sinθを求める\ndouble getsin(Point a , Point b){\n\tdouble t=getcos(a,b);\n\treturn sqrt(1.0-t*t);\n}\n\n//点pと直線abとの距離を求める\ndouble pld(Point p , Point a , Point b){\n\treturn fabs(cross(b - a,p - a))/abs(b-a);\n}\n\n//点pと線分abとの距離を求める\ndouble psd(Point p , Point a , Point b){\n\tif( dot( b-a , p-a ) < EPS) return abs(p-a);\n\tif( dot( a-b , p-b ) < EPS) return abs(p-b);\n\treturn fabs(cross( b-a , p-a )) / abs(b-a);\n}\n\n//線分交点計算\nPoint interpointS(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint b=b2-b1;\n\tdouble d1=fabs(cross(b , a1-b1));\n\tdouble d2=fabs(cross(b , a2-b1));\n\tdouble t=d1 / (d1 + d2);\n\tPoint a=a2-a1;\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線交点計算\nPoint interpointL(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint a=a2-a1;\n\tPoint b=b2-b1;\n\tdouble t=cross(b , b1-a1) / cross(b , a);\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線abと円及び球 |x-c|=rの交点を求める 　球の場合は型Point→Sに変更するだけ\nvoid interpointLC(Point a , Point b , Point c , double r , Point ans[]){\n\tif(pld(c , a , b) > r + EPS) return;\n\tPoint v=unitVector(b-a);\n\tdouble delta=dot(v,a-c)*dot(v,a-c)-abs(a-c)*abs(a-c)+r*r;\n\tdouble t=-dot(v,a-c);\n\tdouble s=sqrt(delta);\n\tans[0]=a+v*(t+s);\n\tans[1]=a+v*(t-s);\n}\n\n//１次変換集\n\n//ｘ（y=k）に関する対象変換 　k=0でｘ軸による変換\nPoint xTranslate(Point t,double k){\n\treturn Point(t.x , 2*k-t.y);\n}\n\n//ｙ(x=k)に関する対象変換\tk=0でｙ軸による変換\nPoint yTranslate(Point t,double k){\n\treturn Point(2*k-t.x , t.y);\n}\n\n//点Point kに関する対象変換\t\tPoint(0,0)で原点による変換\nPoint oTranslate(Point t,Point k){\n\treturn k+(k-t);\n}\n\n\n\n\n\n//点pを中心としてr(radian)回転\t\tp(0,0)で原点を中心として回転\nPoint rotate(Point t , Point p , double r){\n\t//double r=radians(angle);\n\tdouble ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n\tdouble tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n\treturn Point(ta , tb);\n}\n\n//応用\n//２円 |x-a|=raと|x-b|=rbの交点計算\nvoid interpointCC(Point a , double ra , Point b , double rb , Point ans[]){\n\tdouble di=fabs(abs(a-b));\n\tif(di > ra+rb || di < fabs(ra-rb)) return;\n\tdouble t=(ra*ra-rb*rb+di*di)/(di+di);\n\tdouble rd=acos(t/ra);\n\n\tPoint dv=unitVector(b-a);\n\tPoint g1=rotate(dv , Point(0,0) , rd);\n\tPoint g2=rotate(dv , Point(0,0) , -rd);\n\tans[0]=a+g1*ra;\n\tans[1]=a+g2*ra;\n}\n\n//法線ベクトルを求める\nPoint normalVector(Point p,Point a,Point b){\n\tPoint v=unitVector(b-a);\n\tv = cross(v , p-a) > 0 ?  Point(v.y,(-1)*v.x) : Point((-1)*v.y , v.x);\n\treturn v*pld(p,a,b);\n}\n\n//直線abに関する対象変換\nPoint fTranslate(Point t , Point a , Point b){\n\treturn t+normalVector(t,a,b)*2;\n}\n\n//３角形の面積を求める\ndouble area(Point a, Point b, Point c){\n\treturn fabs(cross(c-a , b-a)*0.5);\n}\n\n//多角形の面積を求める //凸包のソート済みが前提\ndouble polygonArea(Polygon t){\n\tdouble ans=0.0;\n\tfor(unsigned int i=0;i<t.size();i++)\n\t\tans+=cross(t[i] , t[(i+1)%t.size()]);\n\treturn ans/2;\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = static_cast<int>(ps.size());\n    Polygon qs(n * 2);\n    for (int i = 0; i < n; ++i) {\n      while (k > 1 && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    for (int i = n-2, t = k; i >= 0; --i) {\n      while (k > t && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    qs.resize(k-1);\n    return qs;\n}\n\nPolygon tri[100];\nint n, d;\n\nbool isIn(Polygon a, Polygon b)\n{\n\tfor (int i = 0; i < a.size(); i++) if (isInside(b, a[i])) return (true);\n\tfor (int i = 0; i < b.size(); i++) if (isInside(a, b[i])) return (true);\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tif (isIntersect(a[i], a[(i + 1) % a.size()], b[j], b[(j + 1) % b.size()])) return (true);\n\t\t}\n\t}\t\n\treturn (false);\n}\n\nbool check(Polygon a, Polygon b)\n{\n\tdouble di[3];\n\tfor (int i = 0; i < 3; i++){\n\t\tdi[i] = abs(a[i] - a[(i + 1) % 3]);\n\t}\n\t\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\tif (eq(di[i], di[j])){\n\t\t\t\tint cnt[3] = {0};\n\t\t\t\tcnt[i]++; cnt[(i + 1) % 3]++;\n\t\t\t\tcnt[j]++; cnt[(j + 1) % 3]++;\n\t\t\t\tfor (int k = 0; k < 3; k++){\n\t\t\t\t\tif (cnt[k] == 2){\n\t\t\t\t\t\tswap(a[k], a[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPolygon c;\n\tc.push_back(a[0]); c.push_back(a[1]);\n\t\n\tPoint t = Point((a[0].x + a[1].x) / 2, (a[0].y + a[1].y) / 2);\n\tPoint k = a[2] - t;\n\tc.push_back(a[0] + k * (d / abs(k))); c.push_back(a[1] + k * (d / abs(k)));\n\t\n\treturn (isIn(c, b));\n}\n\nvector<int> G[128], rG[128];\nint ord[128], gr[128];\nbool vis[128];\nint ctr;\n\nvoid addEdge(int src, int dst)\n{\n\tG[src].push_back(dst);\n\trG[dst].push_back(src);\n}\n\nvoid dfs1(int v)\n{\n\tvis[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tif (!vis[G[v][i]]) dfs1(G[v][i]);\n\t}\n\tord[ctr++] = v;\n}\n\nvoid dfs2(int v, int k)\n{\n\tvis[v] = true;\n\tgr[v] = k;\n\tfor (int i = 0; i < rG[v].size(); i++){\n\t\tif (!vis[rG[v][i]]) dfs2(rG[v][i], k);\n\t}\n\t\n}\n\nint scc()\n{\n\tmemset(vis, 0, sizeof(vis));\n\tctr = 0;\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!vis[i]){\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\tint k = 0;\n\tmemset(vis, 0, sizeof(vis));\n\tfor (int i = n - 1; i >= 0; i--){\n\t\tif (!vis[ord[i]]){\n\t\t\tdfs2(ord[i], k++);\n\t\t}\n\t}\n\t\n\tint ret = k;\n\tmemset(vis, 0, sizeof(vis));\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < G[i].size(); j++){\n\t\t\tif (gr[i] != gr[G[i][j]]){\n\t\t\t\tret -= (1 ^ vis[gr[G[i][j]]]);\n\t\t\t\tvis[gr[G[i][j]]] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (ret);\n}\n\nint main()\n{\n\tPoint t;\n\twhile (scanf(\"%d %d\", &n, &d) && n + d){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tscanf(\"%lf %lf\", &t.x, &t.y);\n\t\t\t\ttri[i].push_back(Point(t.x, t.y));\n\t\t\t}\n\t\t\tG[i].clear(); rG[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (i != j && check(tri[i], tri[j])){\n\t\t\t\t\taddEdge(i, j);\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\t\n\t\t\n\t\tprintf(\"%d\\n\", scc());\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-5;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      break;\n    }\n    break;\n  }while(next_permutation(in,in+3));\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<cstdlib>\n#include<cmath>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define reep(i,n) reps(i,1,n+1)\n\n#define INF 1000000000\n\ndouble getlength(double dx, double dy){\n\treturn sqrt(dx*dx + dy*dy);\n}\n\nclass Point{\n\tpublic:\n\tdouble x,y;\n\tPoint(double x, double y):x(x),y(y){}\n};\n\nclass Line{\n\tpublic:\n\tdouble cx,cy,r,s;\n\tLine(double cx,double cy,double r,double s):cx(cx),cy(cy),r(r),s(s){}\n\tLine(int x1,int y1,int x2,int y2){\n\t\tcx = (x1+x2)/2.0;\n\t\tcy = (y1+y2)/2.0;\n\t\tr = getlength(x1-x2, y1-y2)/2.0;\n\t\ts = atan2(y2-y1, x2-x1);\n\t}\n\tLine(){}\n\tvoid print(){\n\t\tprintf(\"line cx=%.2lf cy=%.2lf r=%.2lf s=%.2lf\\n\",cx,cy,r,s);\n\t}\n\tbool ishit(double x, double y, double d){\n\t\tx-=cx; y-=cy;\n\t\tdouble nx = cos(s)*x - sin(s)*y;\n\t\tdouble ny = sin(s)*x + cos(s)*y;\n\t\t\n\t\t//printf(\"nx=%.2lf ny=%.2lf\\n\",nx,ny);\n\t\t\n\t\tif(fabs(nx)<=r+0.001 && 0<=ny+0.001 && ny<=d+0.001)return true;\n\t\treturn false;\n\t}\n\tPoint getpoint(){\n\t\treturn Point(cx+r*cos(s), cy+r*sin(s));\n\t}\n};\n\nclass Tri{\n\tpublic:\n\tLine line[3];\n\tTri(int x1,int y1,int x2,int y2,int x3,int y3){\n\t\tline[0] = Line(x1,y1,x2,y2);\n\t\tline[1] = Line(x2,y2,x3,y3);\n\t\tline[2] = Line(x3,y3,x1,y1);\n\t\tlinesort();\n\t}\n\tvoid linesort(){\n\t\twhile(1){\n\t\t\tif(line[0].r > line[1].r)return;\n\t\t\tLine bin = line[0];\n\t\t\tline[0] = line[1];\n\t\t\tline[1] = line[2];\n\t\t\tline[2] = bin;\n\t\t}\n\t}\n\tPoint getpoint(int num){\n\t\treturn line[num].getpoint();\n\t}\n\tvoid print(){\n\t\tprintf(\"TRIANGLE\\n\");\n\t\trep(i,3) line[i].print();\n\t}\n};\n\nvoid saiki(int now, int& val, int num[100], vector<int> to[100]){\n\tif(num[now]!=-1)return;\n\tnum[now] = val; val++;\n\t\n\trep(i,to[now].size()){\n\t\tsaiki(to[now][i], val, num, to);\n\t}\n}\n\nvoid saiki2(int now,int visit[100],vector<int> ot[100]){\n\tif(visit[now]==1)return;\n\tvisit[now] = 1;\n\t\n\trep(i,ot[now].size()){\n\t\tsaiki2(ot[now][i], visit, ot);\n\t}\n}\n\nint maina(){\n\tint x1,y1,x2,y2,x3,y3;\n\tcin>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\n\tLine line = Line(x1,y1,x2,y2);\n\tline.ishit(x3,y3,1);\n}\n/*\n0 1 1 0 1 1\n*/\n\nint main(){\n\twhile(1){\n\t\tint n,d;\n\t\tcin>>n>>d;\n\t\tif(n==0)break;\n\t\t\n\t\tvector<Tri> tri;\n\t\t\n\t\trep(i,n){\n\t\t\tint x1,y1,x2,y2,x3,y3;\n\t\t\tcin>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\t\t\n\t\t\ttri.push_back(Tri(x1,y1,x2,y2,x3,y3));\n\t\t}\n\t\t\n\t\t//グラフの構成\n\t\tvector<int> to[100];\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tbool hit = false;\n\t\t\t\trep(p,3){\n\t\t\t\t\tPoint pt = tri[j].getpoint(p);\n\t\t\t\t\thit |= tri[i].line[0].ishit(pt.x, pt.y, d);\n\t\t\t\t}\n\t\t\t\tif(hit){\n\t\t\t\t\tto[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\trep(i,n){\n\t\t\tprintf(\"GRAPH \");\n\t\t\trep(j,to[i].size()){\n\t\t\t\tprintf(\"%d \",to[i][j]);\n\t\t\t}puts(\"\");\n\t\t}*/\n\t\t\n\t\t//逆向きグラフの構成\n\t\tvector<int> ot[100];\n\t\trep(i,n){\n\t\t\trep(j,to[i].size()){\n\t\t\t\tot[to[i][j]].push_back(i);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\trep(i,n){\n\t\t\tprintf(\"HPARG \");\n\t\t\trep(j,ot[i].size()){\n\t\t\t\tprintf(\"%d \",ot[i][j]);\n\t\t\t}puts(\"\");\n\t\t}*/\n\t\t\n\t\t//行きがけ数値配布\n\t\tint num[100]; int val=0;\n\t\trep(i,100)num[i]=-1;\n\t\trep(i,n)saiki(i, val, num, to);\n\t\tint start[100];\n\t\trep(i,n)start[num[i]] = i;\n\t\t/*rep(i,n){\n\t\t\tprintf(\"IKI %d\\n\",num[i]);\n\t\t}*/\n\t\t/*\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tprintf(\"sti = %d\\n\",start[i]);\n\t\t}*/\n\t\t\n\t\t//逆向き探索\n\t\tint visit[100]={0}; int ans = 0;\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tif(visit[start[i]]==0){\n\t\t\t\tans++;\n\t\t\t\tsaiki2(start[i], visit, ot);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-1;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nint V;\nvector<vector<int> > G,rG;\nvector<int> vs;\nbool used[100];\nint cmp[100];\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]){\n      dfs(G[v][i]);\n    }\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]){\n      rdfs(rG[v][i],k);\n    }\n  }\n}\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[2])>eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    G=rG=vector<vector<int> >(n);\n    vs.clear();\n    bool e[100][100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<-eps;\n\t      e[i][j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    e[i][j]|=!f;\n\t    if(e[i][j]){\n\t      G[i].push_back(j);\n\t      rG[j].push_back(i);\n\t    }\n\t  }\n\t}\n      }\n    }\n    V=n;\n    fill(begin(used),end(used),false);\n    for(int v=0;v<V;v++){\n      if(!used[v]){\n\tdfs(v);\n      }\n    }\n    fill(begin(used),end(used),false);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]]){\n\trdfs(vs[i],k++);\n      }\n    }\n    bool in[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(e[i][j]&&cmp[i]!=cmp[j]){\n\t  in[j]=true;\n\t}\n      }\n    }\n    cout<<count(in,in+k,false)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-2;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nint V;\nvector<vector<int> > G,rG;\nvector<int> vs;\nbool used[100];\nint cmp[100];\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]){\n      dfs(G[v][i]);\n    }\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]){\n      rdfs(rG[v][i],k);\n    }\n  }\n}\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[2])>eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    G=rG=vector<vector<int> >(n);\n    vs.clear();\n    bool e[100][100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<eps;\n\t      e[i][j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t      e[i][j]|=abs(p[j][k]-r[i][l])<=eps;\n\t    }\n\t    e[i][j]|=!f;\n\t    if(e[i][j]){\n\t      G[i].push_back(j);\n\t      rG[j].push_back(i);\n\t    }\n\t  }\n\t}\n      }\n    }\n    V=n;\n    fill(begin(used),end(used),false);\n    for(int v=0;v<V;v++){\n      if(!used[v]){\n\tdfs(v);\n      }\n    }\n    fill(begin(used),end(used),false);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]]){\n\trdfs(vs[i],k++);\n      }\n    }\n    bool in[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(e[i][j]&&cmp[i]!=cmp[j]){\n\t  in[cmp[j]]=true;\n\t}\n      }\n    }\n    cout<<count(in,in+k,false)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass UnionFindTree\n{\n    vector<int> parent; // em[h\n    vector<int> rank;   // ØÌ³ÌãÀ\n    int find(int x){\n        if(parent[x] == x)\n            return x;\n        return parent[x] = find(parent[x]);\n    }\npublic:\n    UnionFindTree(int n){ // RXgN^\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        rank.assign(n, 0);\n    }\n    void unite(int x, int y){ // xÆyÌO[vð¹\n        if((x = find(x)) != (y = find(y))){\n            if(rank[x] < rank[y])\n                parent[x] = y;\n            else{\n                parent[y] = x;\n                if(rank[x] == rank[y])\n                    ++ rank[x];\n            }\n        }\n    }\n    bool same(int x, int y){ // xÆyÌO[vª¯¶©ð²×é\n        return find(x) == find(y);\n    }\n    int num(){ // O[vÌðÔ·\n        vector<bool> root(parent.size(), false);\n        for(unsigned i=0; i<parent.size(); ++i)\n            root[find(i)] = true;\n        return count(root.begin(), root.end(), true);\n    }\n};\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\nbool convexContain(const vector<Point>& cp, const Point& p)\n{\n    int n = cp.size();\n    bool ret1 = true;\n    bool ret2 = true;\n    for(int i=0; i<n; ++i){\n        double a = (cp[(i+1)%n] - cp[i]).cross(p - cp[i]);\n        if(a < -EPS)\n            ret1 = false;\n        if(a > EPS)\n            ret2 = false;\n    }\n    return ret1 || ret2;\n}\n\ndouble segmentPointDist(const Point& a1, const Point& a2, const Point& p)\n{\n    if((a2-a1).dot(p-a1) < 0){\n        return a1.dist(p);\n    }else if((a1-a2).dot(p-a2) < 0){\n        return a2.dist(p);\n    }else{\n        return (a2-a1).cross(p-a1) / a1.dist(a2);\n    }\n}\n\ndouble segmentsDist(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(min(a1.x, a2.x) > max(b1.x, b2.x) || min(b1.x, b2.x) > max(a1.x, a2.x) || min(a1.y, a2.y) > max(b1.y, b2.y) || min(b1.y, b2.y) > max(a1.y, a2.y))\n        return 0.0;\n\n    double ret = segmentPointDist(a1, a2, b1);\n    ret = min(ret, segmentPointDist(a1, a2, b2));\n    ret = min(ret, segmentPointDist(b1, b2, a1));\n    ret = min(ret, segmentPointDist(b1, b2, a2));\n    return ret;\n}\n\nbool polygonsCollide(const vector<Point>& cp1, const vector<Point>& cp2)\n{\n    int n = cp1.size();\n    int m = cp2.size();\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<m; ++j){\n            if(segmentsDist(cp1[i], cp1[(i+1)%n], cp2[j], cp2[(j+1)%m]) < 0.01 + EPS)\n                return true;\n        }\n    }\n\n    return convexContain(cp1, cp2[0]) || convexContain(cp2, cp1[0]);\n}\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Point> > p(n, vector<Point>(3));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<3; ++j){\n                cin >> p[i][j].x >> p[i][j].y;\n            }\n            if(p[i][0].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][1], p[i][2]);\n            if(p[i][1].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][0], p[i][2]);\n        }\n\n        vector<vector<Point> > rect(n, vector<Point>(4));\n        for(int i=0; i<n; ++i){\n\n        }\n\n        UnionFindTree uft(n);\n        vector<bool> check(n, false);\n        for(int i=0; i<n; ++i){\n            Point v = p[i][0] - p[i][1];\n            v = v / v.length() * d;\n            swap(v.y, v.x);\n            v.y *= -1;\n\n            vector<Point> p1(4);\n            p1[0] = p[i][0];\n            p1[1] = p[i][0] + v;\n            p1[2] = p[i][1] + v;\n            p1[3] = p[i][1];\n            if(!convexContain(p1, p[i][2])){\n                p1[1] = p[i][0] - v;\n                p1[2] = p[i][1] - v;\n            }\n\n            for(int j=0; j<n; ++j){\n                if(j == i)\n                    continue;\n                if(polygonsCollide(p1, p[j])){\n                    uft.unite(i, j);\n                    check[j] = true;\n                }\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            if(!check[i])\n                ++ ret;\n            else{\n                bool b = true;\n                for(int j=0; j<n; ++j){\n                    if(uft.same(i, j) && !check[j])\n                        b = false;\n                }\n                if(b)\n                    ++ ret;\n                check[i] = false;\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\ndouble d,tx[100][3],ty[100][3],bx[100][4],by[100][4];\nint n,f[100];\n\nstruct gr {\n\tint t,f;\n\tint to[100],fr[100];\n};\n\n\ngr g[100];\n\nvoid makebox() {\n\tint i,j,j1,j2,a,a1,a2;\n\tdouble vx1,vy1,vx2,vy2,b;\n\tfor (i=0;i<n;i++) {\n\t\tfor (j=0;j<3;j++) {\n\t\t\tj1=(j+1) % 3; j2=(j+2) % 3;\n\t\t\tif (((tx[i][j]-tx[i][j1])*(tx[i][j]-tx[i][j1])+(ty[i][j]-ty[i][j1])*(ty[i][j]-ty[i][j1]))==\n\t\t\t    ((tx[i][j]-tx[i][j2])*(tx[i][j]-tx[i][j2])+(ty[i][j]-ty[i][j2])*(ty[i][j]-ty[i][j2]))) a=j;\n\t\t}\n\t\ta1=(a+1) % 3; a2=(a+2) % 3;\n\t\tvx1=tx[i][a]-(tx[i][a1]+tx[i][a2])/2;\n\t\tvy1=ty[i][a]-(ty[i][a1]+ty[i][a2])/2;\n\t\tb=sqrt(vx1*vx1+vy1*vy1);\n\t\tbx[i][0]=tx[i][a1]; by[i][0]=ty[i][a1];\n\t\tbx[i][1]=tx[i][a2]; by[i][1]=ty[i][a2];\n\t\tvx2=d*vx1/b; vy2=d*vy1/b;\n\t\tbx[i][2]=bx[i][1]+vx2; by[i][2]=by[i][1]+vy2;\n\t\tbx[i][3]=bx[i][0]+vx2; by[i][3]=by[i][0]+vy2;\n\t}\n}\nint hit(int n1,int n2) {\n\tint i,j,k;\n\tdouble a,b,mtb,mt,mb,vx1,vy1,vx2,vy2,vx[5],vy[5];\n\tfor (i=0;i<2;i++) { vx[i]=bx[n1][i+1]-bx[n1][i]; vy[i]=by[n1][i+1]-by[n1][i];}\n\tfor (i=0;i<3;i++) { vx[2+i]=tx[n2][(i+1) % 3]-tx[n2][i]; vy[2+i]=ty[n2][(i+1) % 3]-ty[n2][i];}\n\tfor (i=0;i<5;i++) {\n\t\t vx2=-vy[i]; vy2=vx[i];\n\t\t vx1=vx2/sqrt(vx2*vx2+vy2*vy2); vy1=vy2/sqrt(vx2*vx2+vy2*vy2);\n\t\t mtb=0;\n\t\tfor (j=0;j<3;j++) for (k=0;k<4;k++) {\n\t\t vx2=bx[n1][k]-tx[n2][j]; vy2=by[n1][k]-ty[n2][j];\n\t\t a=vx2*vx1+vy2*vy1; if (a<0) a=-a;\n\t\t if (a>mtb) mtb=a;\n\t     }\n\t     a=vx[0]*vx1+vy[0]*vy1; if (a<0) a=-a;\n\t     b=vx[1]*vx1+vy[1]*vy1; if (b<0) b=-b;\n\t     mb=a+b;\n\t     mt=0;\n\t     for (j=0;j<3;j++) { a=(vx[2+j]*vx1+vy[2+j]*vy1)/2; if (a<0) mt-=a; else mt+=a; }\n\t     if (mtb-mt-mb>0.01) return 0;   \n\t\t      }\n\t\t return 1;     \n         }\n         \nvoid  search(int s) {\n\tint i;\n\tf[s]=1;\n\tfor (i=0;i<g[s].t;i++) if (f[g[s].to[i]]==0) search(g[s].to[i]);\n\tfor (i=0;i<g[s].f;i++) if (f[g[s].fr[i]]==0) { search(g[s].fr[i]); break;}\n }\n  \nint main() {\n\tint i,j,ans;\n\twhile (true) {\n\tcin >> n >> d;\n\tif (n==0) break;\n    for (i=0;i<n;i++) {\n\t\tfor (j=0;j<3;j++) cin >> tx[i][j] >> ty[i][j];\n\t\tg[i].t=g[i].f=0;\n\t    }\n    makebox();\n    for (i=0;i<n;i++)for (j=0;j<n;j++) if (i!=j) {if (hit(i,j)==1) { g[i].to[g[i].t]=j; g[i].t++; g[j].fr[g[j].f]=i; g[j].f++;}}\n\tfor (i=0;i<n;i++) f[i]=0; ans=0;\n\tfor (i=0;i<n;i++) if (f[i]==0) { ans++; search(i);}\n\tcout << ans << endl;\n    }    \n   return 0;\n}  \t "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (equal(cross(a, b), 0.0) && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) < -EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\t//if (intersect(u, v)) return true;\n\t\t\tif (distance(u, v) < EPS) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs(0);\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(norm(b - a), norm(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tVector a = tri[i][1] - tri[i][0];\n\t\tVector nv = tri[i][0] + (a / 2.0);\n\t\tnv = tri[i][2] - nv;\n\t\tnv /= abs(nv);\n\t\tnv *= d;\n\t\t\n\t\tsqr[i][0] = tri[i][0];\n\t\tsqr[i][1] = tri[i][1];\n\t\tsqr[i][2] = tri[i][1] + nv;\n\t\tsqr[i][3] = tri[i][0] + nv;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tsqr[i].resize(4);\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-7, AD = 1e-2;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0){\n\t    swap(rect[i][0],rect[i][1]); break;\n\t  }\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k])){\n\t    f = true; break;\n\t  }\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3)if(seg_p_dis(rseg,tri[j][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,3){\n\t    L tseg = L(tri[j][k],rect[j][(k+1)%3]);\n\t    rep(l,4)if(seg_p_dis(tseg,rect[i][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-10;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return distance_ls_p(a,b,c) < 0.01+eps;\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n\tcross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\n\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<-eps ) && //-EPS\n\t( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <-eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n\n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-2)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) * SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G &a, G &b)\n{\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)) return true;\n\t\t}\n\t}\n\tfor (int i = 0; i < a.size(); i++){\n\t\tif (contains(b, a[i])) return true;\n\t}\n\tfor (int i = 0; i < b.size(); i++){\n\t\tif (contains(a, b[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) res++;\n\t\tfor (int to : sccgraph[i]){\n\t\t\tused[to] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)==real(b)?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\nconst D EPS = 1e-8;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nPoly tri[110];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nvector<P> convex_hull(vector<P> v){\n  int n = v.size(), k = 0;\n  sort(v.begin(),v.end());\n  vector<P> r(2*n);\n  for(int i=0;i<n;i++){\n    while(k>1 && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= EPS)k--;\n    r[k++] = v[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= EPS)k--;\n    r[k++] = v[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\nbool cross_poly(Poly a, Poly b){\n  int n1 = a.size(), n2 = b.size();\n  rep(i,n2)if(inter_pos(a,b[i]))return true;\n  rep(i,n1)if(inter_pos(b,a[i]))return true;\n  rep(i,n1)rep(j,n2)\n    if(is_cp(L(a[i],a[(i+1)%n1]),L(b[j],b[(j+1)%n2])))return true;\n  return false;\n}\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      tri[i].resize(3);\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n      tri[i] = convex_hull(tri[i]);\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(ccw(tri[i][n1],tri[i][n2],tri[i][j])!=1){\n\t    swap(rect[i][0],rect[i][1]); break;\n\t  }\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n      rect[i] = convex_hull(rect[i]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\tif(cross_poly(rect[i],tri[j])){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<stack>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-2;\nconst double PI=acos(-1);\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint &operator+=(const point &a){ x+=a.x; y+=a.y; }\n\tpoint &operator-=(const point &a){ x-=a.x; y-=a.y; }\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\ntemplate<class T>\npoint<double> operator/(const point<T> &a,double c){ return (point<double>){a.x/c,a.y/c}; }\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\npoint<double> rot(const point<double> &a,double theta){\n\treturn (point<double>){a.x*cos(theta)-a.y*sin(theta),a.x*sin(theta)+a.y*cos(theta)};\n}\n\ntemplate<class T>\nstruct segment{ point<T> a,b; };\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n):vector< point<T> >(n){}\n};\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\nbool cover(const polygon<double> &G,const point<double> &p){\n\tint n=G.size();\n\tbool res=false;\n\trep(i,n){\n\t\tpoint<double> v1=G[i]-p,v2=G[(i+1)%n]-p;\n\t\tif(v1.y>v2.y) swap(v1,v2);\n\t\tif(v1.y<EPS && EPS<v2.y && cross(v1,v2)>EPS) res=!res;\n\t\tif(abs(cross(v1,v2))<EPS && dot(v1,v2)<EPS) return true;\n\t}\n\treturn res;\n}\n\nbool cover(const polygon<double> &G,const polygon<double> &H){\n\tint m=G.size(),n=H.size();\n\trep(j,n) if(!cover(G,H[j])) return false;\n\treturn true;\n}\n\nbool intersect(const polygon<double> &G,const polygon<double> &H){\n\tint m=G.size(),n=H.size();\n\trep(i,m) rep(j,n) if(intersect((segment<double>){G[i],G[(i+1)%m]},(segment<double>){H[j],H[(j+1)%n]})) return true;\n\treturn cover(G,H) || cover(H,G);\n}\n\nconst int V_MAX=100;\n\nint ord[V_MAX],low[V_MAX];\nvoid dfs(int u,int &c,stack<int> &S,bool *inS,const vector<int> *G,int &scc_id,int *scc){\n\tord[u]=low[u]=c++;\n\tS.push(u);\n\tinS[u]=true;\n\n\trep(i,G[u].size()){\n\t\tint v=G[u][i];\n\t\tif(ord[v]==-1){\n\t\t\tdfs(v,c,S,inS,G,scc_id,scc);\n\t\t\tlow[u]=min(low[u],low[v]);\n\t\t}\n\t\telse if(inS[v]){\n\t\t\tlow[u]=min(low[u],ord[v]);\n\t\t}\n\t}\n\n\tif(ord[u]==low[u]){\n\t\tint v;\n\t\tdo{\n\t\t\tv=S.top(); S.pop();\n\t\t\tinS[v]=false;\n\t\t\tscc[v]=scc_id;\n\t\t}while(v!=u);\n\t\tscc_id++;\n\t}\n}\n\nint SCC(int n,const vector<int> *G,int *scc){\n\tstatic bool inS[V_MAX];\n\trep(u,n){\n\t\tord[u]=-1;\n\t\tinS[u]=false;\n\t}\n\tstack<int> S;\n\tint c=0,n_scc=0;\n\trep(u,n) if(ord[u]==-1) dfs(u,c,S,inS,G,n_scc,scc);\n\treturn n_scc;\n}\n\nint main(){\n\tint n;\n\tfor(double d;scanf(\"%d%lf\",&n,&d),n;){\n\t\tpolygon<double> T[100];\n\t\trep(i,n){\n\t\t\tT[i].resize(3);\n\t\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&T[i][0].x,&T[i][0].y,&T[i][1].x,&T[i][1].y,&T[i][2].x,&T[i][2].y);\n\t\t}\n\n\t\tvector<int> G[100];\n\t\trep(i,n){\n\t\t\tint k0,k1,k2; // T[i][k0]-T[i][k1] が底辺\n\t\t\tif     (abs(dist(T[i][0],T[i][2])-dist(T[i][1],T[i][2]))<EPS) k0=0, k1=1, k2=2;\n\t\t\telse if(abs(dist(T[i][1],T[i][0])-dist(T[i][2],T[i][0]))<EPS) k0=1, k1=2, k2=0;\n\t\t\telse                                                          k0=2, k1=0, k2=1;\n\t\t\t// k0-k1-k2 で CCW になるように\n\t\t\tif(ccw(T[i][k0],T[i][k1],T[i][k2])==CW) swap(k0,k1);\n\n\t\t\tpolygon<double> R(4); // ビームを表す長方形\n\t\t\tR[0]=T[i][k0];\n\t\t\tR[1]=T[i][k1];\n\t\t\tR[2]=T[i][k1]+d*rot((T[i][k1]-T[i][k0])/abs(T[i][k1]-T[i][k0]), PI/2);\n\t\t\tR[3]=T[i][k0]+d*rot((T[i][k0]-T[i][k1])/abs(T[i][k0]-T[i][k1]),-PI/2);\n\n\t\t\trep(j,n) if(i!=j && intersect(T[j],R)) G[i].push_back(j);\n\t\t}\n\n\t\tint scc[100];\n\t\tint n_scc=SCC(n,G,scc);\n\n\t\tbool src[100];\n\t\trep(u,n_scc) src[u]=true;\n\t\trep(i,n) rep(j,G[i].size()) if(scc[i]!=scc[G[i][j]]) src[scc[G[i][j]]]=false;\n\t\tprintf(\"%d\\n\",count(src,src+n_scc,true));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst double EPS = 0.01;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n//????????´???????£???????????????????(??????????????£???????????????)\nenum{NO_HIT=0, HIT, A_IN_B, B_IN_A};\nint HitPol_Pol(const polygon& a, const polygon& b){\n\tbool f = true, hit = false;\n\trep(i, a.size()){\n\t\tif(!contains(b, a[i])) f = false;\n\t\telse hit = true;\n\t}\n\tif(f) return A_IN_B;\n\tf = true;\n\trep(i, b.size()){\n\t\tif(!contains(a, b[i])) f = false;\n\t\telse hit = true;\n\t}\n\tif(f) return B_IN_A;\n\tif(hit) return HIT;\n\trep(i, a.size()) rep(j, b.size()){\n\t\tL la(curr(a, i), next(a, i)), lb(curr(b, j), next(b, j));\n\t\tif(intersectSS(la, lb)) return HIT;\n\t}\n\treturn NO_HIT;\n}\n//point???theta???????????¢\npoint spinP(const point& p, double theta){\n\treturn p*complex<double>(cos(theta),sin(theta));\n}\npoint spinPExtend(const point& p, double theta, double rate){\n\treturn p*complex<double>(rate*cos(theta),rate*sin(theta));\n}\n\nstruct SCC{//O(V+E)\n    static const int MAX_V = 1010;\n    int V;\n    vector<int> G[MAX_V], rG[MAX_V];\n    vector<int> vs;\n    bool used[MAX_V];\n    int cmp[MAX_V];\n    vector<vector<int> > res;\n \n \n    SCC(int v) : V(v){};\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n \n    void dfs(int v){\n        used[v] = true;\n        for(int i = 0; i < G[v].size(); i++){\n            if(!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v] = true;\n        cmp[v] = k;\n        for(int i = 0; i < rG[v].size(); i++){\n            if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n \n    int scc(){\n        memset(used, 0, sizeof(used));\n        vs.clear();\n        for(int v = 0; v < V; v++){\n            if(!used[v]) dfs(v);\n        }\n        memset(used, 0, sizeof(used));\n        int k = 0;\n        for(int i = vs.size() - 1; i >= 0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++);\n        }\n \n        res.clear();\n        res.resize(k);\n        for(int i = 0; i < V; i++){\n            res[cmp[i]].push_back(i);\n        }\n        return k;\n    }\n};\n\nint main(){\n\tint n, d;\n\twhile(cin >> n >> d && (n+d)){\n\t\tvector<polygon> tri(n);\n\t\trep(i, n){\n\t\t\tdouble x, y;\n\t\t\trep(j, 3){\n\t\t\t\tcin >> x >> y;\n\t\t\t\ttri[i].pb({x, y});\n\t\t\t}\n\t\t}\n\t\tvector<polygon> pol(n);\n\t\trep(i, n){\n\t\t\tdouble dist[3];\n\t\t\trep(j, 3){\n\t\t\t\tdist[j] = abs(curr(tri[i], j)-next(tri[i], j));\n\t\t\t}\n\t\t\trep(j, 3) {\n\t\t\t\tif(abs(dist[j] - dist[(j+1)%3])<1e-8){\n\t\t\t\t\tpol[i].pb(tri[i][j]);\n\t\t\t\t\tpol[i].pb(tri[i][(j+2)%3]);\n\t\t\t\t\tpol[i].pb(spinPExtend(pol[i][0]-pol[i][1], (ccw(pol[i][1], pol[i][0], tri[i][(j+1)%3])> 0)?PI/2:-PI/2, d/abs(pol[i][1]-pol[i][0]))+pol[i][1]);\n\t\t\t\t\tpol[i].pb(pol[i][2]+pol[i][0]-pol[i][1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSCC scc(n);\n\t\trep(i, n) rep(j, i){\n\t\t\tif(HitPol_Pol(pol[i], tri[j])!=NO_HIT) scc.add_edge(i, j);\n\t\t\tif(HitPol_Pol(tri[i], pol[j])!=NO_HIT) scc.add_edge(j, i);\n\t\t}\n\t\tscc.scc();\n\t\tvector<int> f(scc.res.size(), 1);\n\t\trep(i, n) rep(j, i){\n\t\t\tif(scc.cmp[i] == scc.cmp[j]) continue;\n\t\t\tif(HitPol_Pol(pol[i], tri[j])!=NO_HIT) f[scc.cmp[j]] = 0;\n\t\t\telse if(HitPol_Pol(tri[i], pol[j])!=NO_HIT) f[scc.cmp[i]] = 0;\n\t\t}\n\t\tcout<<accumulate(all(f), 0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\ndouble d,tx[100][3],ty[100][3],bx[100][4],by[100][4];\nint n,f[100];\n\nstruct gr {\n\tint t,f;\n\tint to[100],fr[100];\n};\n\n\ngr g[100];\n\nvoid makebox() {\n\tint i,j,j1,j2,a,a1,a2;\n\tdouble vx1,vy1,vx2,vy2,b;\n\tfor (i=0;i<n;i++) {\n\t\tfor (j=0;j<3;j++) {\n\t\t\tj1=(j+1) % 3; j2=(j+2) % 3;\n\t\t\tif (((tx[i][j]-tx[i][j1])*(tx[i][j]-tx[i][j1])+(ty[i][j]-ty[i][j1])*(ty[i][j]-ty[i][j1]))-((tx[i][j]-tx[i][j2])*(tx[i][j]-tx[i][j2])+(ty[i][j]-ty[i][j2])*(ty[i][j]-ty[i][j2]))==0) a=j;\n\t\t}\n\t\ta1=(a+1) % 3; a2=(a+2) % 3;\n\t\tvx1=tx[i][a]-(tx[i][a1]+tx[i][a2])/2;\n\t\tvy1=ty[i][a]-(ty[i][a1]+ty[i][a2])/2;\n\t\tb=sqrt(vx1*vx1+vy1*vy1);\n\t\tbx[i][0]=tx[i][a1]; by[i][0]=ty[i][a1];\n\t\tbx[i][1]=tx[i][a2]; by[i][1]=ty[i][a2];\n\t\tvx2=d*vx1/b; vy2=d*vy1/b;\n\t\tbx[i][2]=bx[i][1]+vx2; by[i][2]=by[i][1]+vy2;\n\t\tbx[i][3]=bx[i][0]+vx2; by[i][3]=by[i][0]+vy2;\n\t}\n}\nint hit(int n1,int n2) {\n\tint i,j,k;\n\tdouble a,b,mtb,mt,mb,vx1,vy1,vx2,vy2,vx[5],vy[5];\n\tfor (i=0;i<2;i++) { vx[i]=bx[n1][i+1]-bx[n1][i]; vy[i]=by[n1][i+1]-by[n1][i];}\n\tfor (i=0;i<3;i++) { vx[2+i]=tx[n2][(i+1) % 3]-tx[n2][i]; vy[2+i]=ty[n2][(i+1) % 3]-ty[n2][i];}\n\tfor (i=0;i<5;i++) {\n\t\t vx2=-vy[i]; vy2=vx[i];\n\t\t vx1=vx2/sqrt(vx2*vx2+vy2*vy2); vy1=vy2/sqrt(vx2*vx2+vy2*vy2);\n\t\t mtb=0;\n\t\tfor (j=0;j<3;j++) for (k=0;k<4;k++) {\n\t\t vx2=bx[n1][k]-tx[n2][j]; vy2=by[n1][k]-ty[n2][j];\n\t\t a=vx2*vx1+vy2*vy1; if (a<0) a=-a;\n\t\t if (a>mtb) mtb=a;\n\t     }\n\t     a=vx[0]*vx1+vy[0]*vy1; if (a<0) a=-a;\n\t     b=vx[1]*vx1+vy[1]*vy1; if (b<0) b=-b;\n\t     mb=a+b;\n\t     mt=0;\n\t     for (j=0;j<3;j++) { a=(vx[2+j]*vx1+vy[2+j]*vy1)/2; if (a<0) mt-=a; else mt+=a; }\n\t     if (mtb-mt-mb>0.01) return 0;   \n\t\t      }\n\t\t return 1;     \n         }\n         \nvoid  search(int s) {\n\tint i;\n\tf[s]=1;\n\tfor (i=0;i<g[s].t;i++) if (f[g[s].to[i]]==0) { g[g[s].to[i]].f=0; search(g[s].to[i]); }\n\tfor (i=0;i<g[s].f;i++) if (f[g[s].fr[i]]==0) { search(g[s].fr[i]); break;}\n }\n  \nint main() {\n\tint i,j,ans;\n\twhile (true) {\n\tcin >> n >> d;\n\tif (n==0) break;\n    for (i=0;i<n;i++) {\n\t\tfor (j=0;j<3;j++) cin >> tx[i][j] >> ty[i][j];\n\t\tg[i].t=g[i].f=0;\n\t    }\n    makebox();\n    for (i=0;i<n;i++) for (j=0;j<n;j++) if (i!=j) {if (hit(i,j)==1) { g[i].to[g[i].t]=j; g[i].t++; g[j].fr[g[j].f]=i; g[j].f++;}}\n\tfor (i=0;i<n;i++) f[i]=0; ans=0;\n\tfor (i=0;i<n;i++) if (f[i]==0) { ans++; search(i);}\n\tcout << ans << endl;\n    }    \n   return 0;\n}  \t "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 0.011;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (equal(cross(a, b), 0.0) && dot(a, b) <= 0.0) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() <= 0.0 && 0.0 < b.imag() && cross(a, b) < 0.0) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\t//if (intersect(u, v)) return true;\n\t\t\tif (distance(u, v) < EPS) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs(0);\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(norm(b - a), norm(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tVector a = tri[i][1] - tri[i][0];\n\t\tVector nv = tri[i][0] + (a / 2.0);\n\t\tnv = tri[i][2] - nv;\n\t\tnv /= abs(nv);\n\t\tnv *= d;\n\t\t\n\t\tsqr[i][0] = tri[i][0];\n\t\tsqr[i][1] = tri[i][1];\n\t\tsqr[i][2] = tri[i][1] + nv;\n\t\tsqr[i][3] = tri[i][0] + nv;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tsqr[i].resize(4);\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst double EPS = 0.01;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n//????????´???????£???????????????????(??????????????£???????????????)\nenum{NO_HIT=0, HIT, A_IN_B, B_IN_A};\nint HitPol_Pol(const polygon& a, const polygon& b){\n\tbool f = true, hit = false;\n\trep(i, a.size()){\n\t\tif(contains(b, a[i]) == OUT) f = false;\n\t\telse hit = true;\n\t}\n\tif(f) return A_IN_B;\n\tf = true;\n\trep(i, b.size()){\n\t\tif(contains(a, b[i]) == OUT) f = false;\n\t\telse hit = true;\n\t}\n\tif(f) return B_IN_A;\n\tif(hit) return HIT;\n\trep(i, a.size()) rep(j, b.size()){\n\t\tL la(curr(a, i), next(a, i)), lb(curr(b, j), next(b, j));\n\t\tif(intersectSS(la, lb)) return HIT;\n\t}\n\treturn NO_HIT;\n}\n//point???theta???????????¢\npoint spinP(const point& p, double theta){\n\treturn p*complex<double>(cos(theta),sin(theta));\n}\npoint spinPExtend(const point& p, double theta, double rate){\n\treturn p*complex<double>(rate*cos(theta),rate*sin(theta));\n}\n\nstruct SCC{//O(V+E)\n    static const int MAX_V = 1010;\n    int V;\n    vector<int> G[MAX_V], rG[MAX_V];\n    vector<int> vs;\n    bool used[MAX_V];\n    int cmp[MAX_V];\n    vector<vector<int> > res;\n \n \n    SCC(int v) : V(v){};\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n \n    void dfs(int v){\n        used[v] = true;\n        for(int i = 0; i < G[v].size(); i++){\n            if(!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v] = true;\n        cmp[v] = k;\n        for(int i = 0; i < rG[v].size(); i++){\n            if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n \n    int scc(){\n        memset(used, 0, sizeof(used));\n        vs.clear();\n        for(int v = 0; v < V; v++){\n            if(!used[v]) dfs(v);\n        }\n        memset(used, 0, sizeof(used));\n        int k = 0;\n        for(int i = vs.size() - 1; i >= 0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++);\n        }\n \n        res.clear();\n        res.resize(k);\n        for(int i = 0; i < V; i++){\n            res[cmp[i]].push_back(i);\n        }\n        return k;\n    }\n};\n\nint main(){\n\tint n, d;\n\twhile(cin >> n >> d && (n+d)){\n\t\tvector<polygon> tri(n);\n\t\trep(i, n){\n\t\t\tdouble x, y;\n\t\t\trep(j, 3){\n\t\t\t\tcin >> x >> y;\n\t\t\t\ttri[i].pb({x, y});\n\t\t\t}\n\t\t}\n\t\tvector<polygon> pol(n);\n\t\trep(i, n){\n\t\t\tdouble dist[3];\n\t\t\trep(j, 3){\n\t\t\t\tdist[j] = abs(curr(tri[i], j)-next(tri[i], j));\n\t\t\t}\n\t\t\trep(j, 3) {\n\t\t\t\tif(abs(dist[j] - dist[(j+1)%3])<1e-8){\n\t\t\t\t\tpol[i].pb(tri[i][j]);\n\t\t\t\t\tpol[i].pb(tri[i][(j+2)%3]);\n\t\t\t\t\tpol[i].pb(spinPExtend(pol[i][0]-pol[i][1], (ccw(pol[i][1], pol[i][0], tri[i][(j+1)%3])> 0)?PI/2:-PI/2, d/abs(pol[i][1]-pol[i][0]))+pol[i][1]);\n\t\t\t\t\tpol[i].pb(pol[i][2]+pol[i][0]-pol[i][1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSCC scc(n);\n\t\trep(i, n) rep(j, i){\n\t\t\tif(HitPol_Pol(pol[i], tri[j])!=NO_HIT) scc.add_edge(i, j);\n\t\t\tif(HitPol_Pol(tri[i], pol[j])!=NO_HIT) scc.add_edge(j, i);\n\t\t}\n\t\tscc.scc();\n\t\tvector<int> f(scc.res.size(), 1);\n\t\trep(i, n) rep(j, i){\n\t\t\tif(scc.cmp[i] == scc.cmp[j]) continue;\n\t\t\tif(HitPol_Pol(pol[i], tri[j])!=NO_HIT) f[scc.cmp[j]] = 0;\n\t\t\telse if(HitPol_Pol(tri[i], pol[j])!=NO_HIT) f[scc.cmp[i]] = 0;\n\t\t}\n\t\tcout<<accumulate(all(f), 0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return distance_ls_p(a,b,c) < 0.01+eps;\n\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n\tcross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\n\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<-eps ) && //-EPS\n\t( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <-eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n        ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    d+=0.001;\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-2)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) * SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\tassert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nbool mergeIfAble(S &s1, S s2){\n\tif (!parallel(s1, s2)) return false;\n\tif (abs(ccw(s1.p1, s2.p1, s1.p2)) == 1) return false;\n\tif (ccw(s1.p1, s1.p2, s2.p1) == ONLINE_FRONT ||\n\t\tccw(s2.p1, s2.p2, s1.p1) == ONLINE_FRONT){\n\t\treturn false;\n\t}\n\ts1 = S(min(s1.p1, s2.p1), max(s1.p2, s2.p2));\n\treturn true;\n}\nvoid merge(vector<S> &ss){\n\tfor (int i = 0; i < ss.size(); i++){\n\t\tif (ss[i].p2 < ss[i].p1){\n\t\t\tswap(ss[i].p1, ss[i].p2);\n\t\t}\n\t}\n\tfor (int i = 0; i < ss.size(); i++){\n\t\tfor (int j = i + 1; j < ss.size(); j++){\n\t\t\tif (mergeIfAble(ss[i], ss[j])){\n\t\t\t\tss[j--] = ss.back();\n\t\t\t\tss.pop_back();\n\t\t\t}\n\t\t}\n\t}\n}\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\nG convexHull(vector<P> s){\n\tif (s.size() < 3) return s;\n\tG u, l;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tfor (int i = 2; i < s.size(); i++){\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\tl.push_back(u[i]);\n\t}\n\treturn l;\n}\n\nGraph SArrangement(const vector<S> &ss, vector<P> &ps){\n\tfor (int i = 0; i < ss.size(); i++){\n\t\tps.push_back(ss[i].p1);\n\t\tps.push_back(ss[i].p2);\n\t\tfor (int j = i + 1; j < ss.size(); j++){\n\t\t\tif (intersectSS(ss[i], ss[j])){\n\t\t\t\tps.push_back(crossP(ss[i], ss[j]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(ps.begin(), ps.end());\n\tps.erase(unique(ps.begin(), ps.end()), ps.end());\n\tGraph g(ps.size());\n\tfor (int i = 0; i < ss.size(); i++){\n\t\tvector<pair<D, int> > v;\n\t\tfor (int j = 0; j < ps.size(); j++){\n\t\t\tif (PonS(ss[i], ps[j])){\n\t\t\t\tv.push_back(make_pair(norm(ss[i].p1 - ps[i]), j));\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tfor (int j = 0; j < (int)v.size() - 1; j++){\n\t\t\tint a = v[j].second, b = v[j + 1].second;\n\t\t\tD c = abs(ps[a] - ps[b]);\n\t\t\tg[a].push_back(Edge(b, c));\n\t\t\tg[b].push_back(Edge(a, c));\n\t\t}\n\t}\n\treturn g;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G a, G b)\n{\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)) return true;\n\t\t}\n\t\tif (contains(b, a[i])) return true;\n\t}\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) res++;\n\t\tfor (int to : sccgraph[i]){\n\t\t\tused[to] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-3)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) * SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nbool mergeIfAble(S &s1, S s2){\n\tif (!parallel(s1, s2)) return false;\n\tif (abs(ccw(s1.p1, s2.p1, s1.p2)) == 1) return false;\n\tif (ccw(s1.p1, s1.p2, s2.p1) == ONLINE_FRONT ||\n\t\tccw(s2.p1, s2.p2, s1.p1) == ONLINE_FRONT){\n\t\treturn false;\n\t}\n\ts1 = S(min(s1.p1, s2.p1), max(s1.p2, s2.p2));\n\treturn true;\n}\nvoid merge(vector<S> &ss){\n\tfor (int i = 0; i < ss.size(); i++){\n\t\tif (ss[i].p2 < ss[i].p1){\n\t\t\tswap(ss[i].p1, ss[i].p2);\n\t\t}\n\t}\n\tfor (int i = 0; i < ss.size(); i++){\n\t\tfor (int j = i + 1; j < ss.size(); j++){\n\t\t\tif (mergeIfAble(ss[i], ss[j])){\n\t\t\t\tss[j--] = ss.back();\n\t\t\t\tss.pop_back();\n\t\t\t}\n\t\t}\n\t}\n}\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\nG convexHull(vector<P> s){\n\tif (s.size() < 3) return s;\n\tG u, l;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tfor (int i = 2; i < s.size(); i++){\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\tl.push_back(u[i]);\n\t}\n\treturn l;\n}\n\nGraph SArrangement(const vector<S> &ss, vector<P> &ps){\n\tfor (int i = 0; i < ss.size(); i++){\n\t\tps.push_back(ss[i].p1);\n\t\tps.push_back(ss[i].p2);\n\t\tfor (int j = i + 1; j < ss.size(); j++){\n\t\t\tif (intersectSS(ss[i], ss[j])){\n\t\t\t\tps.push_back(crossP(ss[i], ss[j]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(ps.begin(), ps.end());\n\tps.erase(unique(ps.begin(), ps.end()), ps.end());\n\tGraph g(ps.size());\n\tfor (int i = 0; i < ss.size(); i++){\n\t\tvector<pair<D, int> > v;\n\t\tfor (int j = 0; j < ps.size(); j++){\n\t\t\tif (PonS(ss[i], ps[j])){\n\t\t\t\tv.push_back(make_pair(norm(ss[i].p1 - ps[i]), j));\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tfor (int j = 0; j < (int)v.size() - 1; j++){\n\t\t\tint a = v[j].second, b = v[j + 1].second;\n\t\t\tD c = abs(ps[a] - ps[b]);\n\t\t\tg[a].push_back(Edge(b, c));\n\t\t\tg[b].push_back(Edge(a, c));\n\t\t}\n\t}\n\treturn g;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G a, G b)\n{\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)) return true;\n\t\t}\n\t\tif (contains(b, a[i])) return true;\n\t}\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) res++;\n\t\tfor (int to : sccgraph[i]){\n\t\t\tused[to] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cfloat>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define EPS (1e-8)\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint ( double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n\tPoint operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n\tPoint operator * ( double a ){ return Point(x*a, y*a); }\n\tdouble abs() { return sqrt(norm());}\n\tdouble norm() { return x*x + y*y; }\n\tbool operator < ( const Point &p ) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == ( const Point &p ) const {\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs(Vector a) {return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b) {return (sqrt(norm(a - b)));}\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\ndouble eq(double a, double b)\n{\n\treturn (fabs(a - b) <= EPS);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n//3点の位置関係を求める\nint ccw( Point p0, Point p1, Point p2 ){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( norm(a) < norm(b) ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//A = p2 - p1, B = p4 - p3が交差するか\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n\n\n//多角形の中に点があるか\nbool isInside(Polygon gon, Point p ){\n\tfor ( int i = 0; i < gon.size(); i++ ){\n\t\tif ( ccw(gon[i], gon[(i+1)%gon.size()], p) == CLOCKWISE ) return (false);\n\t}\n\treturn (true);\n}\n\n//単位ベクトルを求める\nPoint unitVector(Point t){\n\tdouble u=abs(t);\n\treturn Point(t.x/u , t.y/u);\n}\n//cosθを求める\ndouble getcos(Point a , Point b){\n\treturn (dot(a,b) / (abs(a)*abs(b)));\n}\n\n//sinθを求める\ndouble getsin(Point a , Point b){\n\tdouble t=getcos(a,b);\n\treturn sqrt(1.0-t*t);\n}\n\n//点pと直線abとの距離を求める\ndouble pld(Point p , Point a , Point b){\n\treturn fabs(cross(b - a,p - a))/abs(b-a);\n}\n\n//点pと線分abとの距離を求める\ndouble psd(Point p , Point a , Point b){\n\tif( dot( b-a , p-a ) < EPS) return abs(p-a);\n\tif( dot( a-b , p-b ) < EPS) return abs(p-b);\n\treturn fabs(cross( b-a , p-a )) / abs(b-a);\n}\n\n//線分交点計算\nPoint interpointS(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint b=b2-b1;\n\tdouble d1=fabs(cross(b , a1-b1));\n\tdouble d2=fabs(cross(b , a2-b1));\n\tdouble t=d1 / (d1 + d2);\n\tPoint a=a2-a1;\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線交点計算\nPoint interpointL(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint a=a2-a1;\n\tPoint b=b2-b1;\n\tdouble t=cross(b , b1-a1) / cross(b , a);\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線abと円及び球 |x-c|=rの交点を求める 　球の場合は型Point→Sに変更するだけ\nvoid interpointLC(Point a , Point b , Point c , double r , Point ans[]){\n\tif(pld(c , a , b) > r + EPS) return;\n\tPoint v=unitVector(b-a);\n\tdouble delta=dot(v,a-c)*dot(v,a-c)-abs(a-c)*abs(a-c)+r*r;\n\tdouble t=-dot(v,a-c);\n\tdouble s=sqrt(delta);\n\tans[0]=a+v*(t+s);\n\tans[1]=a+v*(t-s);\n}\n\n//１次変換集\n\n//ｘ（y=k）に関する対象変換 　k=0でｘ軸による変換\nPoint xTranslate(Point t,double k){\n\treturn Point(t.x , 2*k-t.y);\n}\n\n//ｙ(x=k)に関する対象変換\tk=0でｙ軸による変換\nPoint yTranslate(Point t,double k){\n\treturn Point(2*k-t.x , t.y);\n}\n\n//点Point kに関する対象変換\t\tPoint(0,0)で原点による変換\nPoint oTranslate(Point t,Point k){\n\treturn k+(k-t);\n}\n\n\n\n\n\n//点pを中心としてr(radian)回転\t\tp(0,0)で原点を中心として回転\nPoint rotate(Point t , Point p , double r){\n\t//double r=radians(angle);\n\tdouble ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n\tdouble tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n\treturn Point(ta , tb);\n}\n\n//応用\n//２円 |x-a|=raと|x-b|=rbの交点計算\nvoid interpointCC(Point a , double ra , Point b , double rb , Point ans[]){\n\tdouble di=fabs(abs(a-b));\n\tif(di > ra+rb || di < fabs(ra-rb)) return;\n\tdouble t=(ra*ra-rb*rb+di*di)/(di+di);\n\tdouble rd=acos(t/ra);\n\n\tPoint dv=unitVector(b-a);\n\tPoint g1=rotate(dv , Point(0,0) , rd);\n\tPoint g2=rotate(dv , Point(0,0) , -rd);\n\tans[0]=a+g1*ra;\n\tans[1]=a+g2*ra;\n}\n\n//法線ベクトルを求める\nPoint normalVector(Point p,Point a,Point b){\n\tPoint v=unitVector(b-a);\n\tv = cross(v , p-a) > 0 ?  Point(v.y,(-1)*v.x) : Point((-1)*v.y , v.x);\n\treturn v*pld(p,a,b);\n}\n\n//直線abに関する対象変換\nPoint fTranslate(Point t , Point a , Point b){\n\treturn t+normalVector(t,a,b)*2;\n}\n\n//３角形の面積を求める\ndouble area(Point a, Point b, Point c){\n\treturn fabs(cross(c-a , b-a)*0.5);\n}\n\n//多角形の面積を求める //凸包のソート済みが前提\ndouble polygonArea(Polygon t){\n\tdouble ans=0.0;\n\tfor(unsigned int i=0;i<t.size();i++)\n\t\tans+=cross(t[i] , t[(i+1)%t.size()]);\n\treturn ans/2;\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = static_cast<int>(ps.size());\n    Polygon qs(n * 2);\n    for (int i = 0; i < n; ++i) {\n      while (k > 1 && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    for (int i = n-2, t = k; i >= 0; --i) {\n      while (k > t && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    qs.resize(k-1);\n    return qs;\n}\n\nPolygon tri[100];\nint n, d;\n\nbool isIn(Polygon a, Polygon b)\n{\n\tfor (int i = 0; i < a.size(); i++) if (isInside(b, a[i])) return (true);\n\tfor (int i = 0; i < b.size(); i++) if (isInside(a, b[i])) return (true);\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tif (isIntersect(a[i], a[(i + 1) % a.size()], b[j], b[(j + 1) % b.size()])) return (true);\n\t\t}\n\t}\t\n\treturn (false);\n}\n\nbool check(Polygon a, Polygon b)\n{\n\tdouble di[3];\n\tfor (int i = 0; i < 3; i++){\n\t\tdi[i] = abs(a[i] - a[(i + 1) % 3]);\n\t}\n\t\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\tif (eq(di[i], di[j])){\n\t\t\t\tint cnt[3] = {0};\n\t\t\t\tcnt[i]++; cnt[(i + 1) % 3]++;\n\t\t\t\tcnt[j]++; cnt[(j + 1) % 3]++;\n\t\t\t\tfor (int k = 0; k < 3; k++){\n\t\t\t\t\tif (cnt[k] == 2){\n\t\t\t\t\t\tswap(a[k], a[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (ccw(a[0], a[1], a[2]) == COUNTER_CLOCKWISE) swap(a[0], a[1]);\n\n\tPolygon c;\n\tc.push_back(a[0]); c.push_back(a[1]);\n\t\n\tPoint t = Point((a[0].x + a[1].x) / 2, (a[0].y + a[1].y) / 2);\n\tPoint k = a[2] - t;\n\tc.push_back(a[1] + k * (d / abs(k))); c.push_back(a[0] + k * (d / abs(k)));\n\t\n\treturn (isIn(c, b));\n}\n\nvector<int> G[128], rG[128];\nint ord[128], gr[128];\nbool vis[128];\nint ctr;\n\nvoid addEdge(int src, int dst)\n{\n\tG[src].push_back(dst);\n\trG[dst].push_back(src);\n}\n\nvoid dfs1(int v)\n{\n\tvis[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tif (!vis[G[v][i]]) dfs1(G[v][i]);\n\t}\n\tord[ctr++] = v;\n}\n\nvoid dfs2(int v, int k)\n{\n\tvis[v] = true;\n\tgr[v] = k;\n\tfor (int i = 0; i < rG[v].size(); i++){\n\t\tif (!vis[rG[v][i]]) dfs2(rG[v][i], k);\n\t}\n\t\n}\n\nint scc()\n{\n\tmemset(vis, 0, sizeof(vis));\n\tctr = 0;\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!vis[i]){\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\tint k = 0;\n\tmemset(vis, 0, sizeof(vis));\n\tfor (int i = n - 1; i >= 0; i--){\n\t\tif (!vis[ord[i]]){\n\t\t\tdfs2(ord[i], k++);\n\t\t}\n\t}\n\t\n\tint ret = k;\n\tmemset(vis, 0, sizeof(vis));\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < G[i].size(); j++){\n\t\t\tif (gr[i] != gr[G[i][j]]){\n\t\t\t\tret -= (1 ^ vis[gr[G[i][j]]]);\n\t\t\t\tvis[gr[G[i][j]]] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (ret);\n}\n\nint main()\n{\n\tPoint t;\n\twhile (scanf(\"%d %d\", &n, &d) && n + d){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tscanf(\"%lf %lf\", &t.x, &t.y);\n\t\t\t\ttri[i].push_back(Point(t.x, t.y));\n\t\t\t}\n\t\t\tG[i].clear(); rG[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (i != j && check(tri[i], tri[j])){\n\t\t\t\t\taddEdge(i, j);\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\t\n\t\t\n\t\tprintf(\"%d\\n\", scc());\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<stack>\n#include<complex>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nconst double EPS = 0.01;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > EPS)   return +1;       // counter clockwise\n  if (cross(b, c) < -EPS)   return -1;       // clockwise\n  if (dot(b, c) < -EPS)     return +2;       // c--a--b on line\n  if (norm(b)+EPS < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)+EPS) swap(a, b);\n    if (imag(a) < EPS && EPS < imag(b))\n      if (cross(a, b) < -EPS) in = !in;\n    if (abs(cross(a, b)) < EPS && dot(a, b) < -EPS) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) < 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) < 0;\n}\nbool intersect(G &rect, G &tri){\n\trep(i,3)if(contains(rect,tri[i]))return 1;\n\trep(i,4)if(contains(tri,rect[i]))return 1;\n\trep(i,3){\n\t\tL l(tri[i],tri[(i+1)%3]);\n\t\trep(j,4)if(intersectSS(l,L(rect[i],rect[(i+1)%4])))return 1;\n\t}\n\treturn 0;\n}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight=0) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid visit(const Graph &g, int v, vector< vector<int> >& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  fr(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const Graph& g,\n    vector< vector<int> >& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint main(){\n\tint n;\n\tdouble d;\n\twhile(cin>>n>>d,n){\n\t\tvector<G> tri;\n\t\trep(i,n){\n\t\t\tdouble a,b,c,d,e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tG p; p.pb(P(a,b)); p.pb(P(c,d)); p.pb(P(e,f));\n\t\t\tif(abs(p[2]-p[0])!=abs(p[2]-p[1])){\n\t\t\t\tif(abs(p[2]-p[0])==abs(p[1]-p[0]))swap(p[2],p[0]);\n\t\t\t\telse swap(p[1],p[0]);\n\t\t\t}\n\t\t\tif(ccw(p[0],p[1],p[2])<0)swap(p[0],p[1]);\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\tGraph e(n);\n\t\t\n\t\trep(i,n)rep(j,n)if(i!=j){\n\t\t\t\n\t\t\tG &p=tri[i];\n\t\t\tP m=(p[0]+p[1])*0.5,dir=(p[2]-m)*(d/abs(p[2]-m));\n\t\t\t\n\t\t\tG rect;\n\t\t\trect.pb(p[0]); rect.pb(p[1]);\n\t\t\trect.pb(p[1]+dir); rect.pb(p[0]+dir);\n\t\t\tif(ccw(rect[0],rect[1],rect[2])<0)reverse(rect.begin(),rect.end());\n\t\t\t\n\t\t\tif(intersect(rect,tri[j]))e[i].pb(Edge(i,j));\n\t\t}\n\t\t\n\t\tvector<vector<int> > scc;\n\t\tstronglyConnectedComponents(e,scc);\n\t\tint m=scc.size(),to[100],in[100]={0},ans=0;\n\t\trep(i,m)fr(j,scc[i])to[*j]=i;\n\t\trep(i,n)fr(j,e[i])if(to[i]!=to[j->dst])\n\t\tin[to[j->dst]]++;\n\t\t\n\t\trep(i,m)if(in[i]==0)ans++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\ndouble d,tx[100][3],ty[100][3],bx[100][4],by[100][4];\nint n,f[100];\n\nstruct gr {\n\tint t,f;\n\tint to[100],fr[100];\n};\n\n\ngr g[100];\n\nvoid makebox() {\n\tint i,j,j1,j2,a,a1,a2;\n\tdouble vx1,vy1,vx2,vy2,b;\n\tfor (i=0;i<n;i++) {\n\t\tfor (j=0;j<3;j++) {\n\t\t\tj1=(j+1) % 3; j2=(j+2) % 3;\n\t\t\tif (((tx[i][j]-tx[i][j1])*(tx[i][j]-tx[i][j1])+(ty[i][j]-ty[i][j1])*(ty[i][j]-ty[i][j1]))-((tx[i][j]-tx[i][j2])*(tx[i][j]-tx[i][j2])+(ty[i][j]-ty[i][j2])*(ty[i][j]-ty[i][j2]))==0) a=j;\n\t\t}\n\t\ta1=(a+1) % 3; a2=(a+2) % 3;\n\t\tvx1=tx[i][a]-(tx[i][a1]+tx[i][a2])/2;\n\t\tvy1=ty[i][a]-(ty[i][a1]+ty[i][a2])/2;\n\t\tb=sqrt(vx1*vx1+vy1*vy1);\n\t\tbx[i][0]=tx[i][a1]; by[i][0]=ty[i][a1];\n\t\tbx[i][1]=tx[i][a2]; by[i][1]=ty[i][a2];\n\t\tvx2=d*vx1/b; vy2=d*vy1/b;\n\t\tbx[i][2]=bx[i][1]+vx2; by[i][2]=by[i][1]+vy2;\n\t\tbx[i][3]=bx[i][0]+vx2; by[i][3]=by[i][0]+vy2;\n\t}\n}\nint hit(int n1,int n2) {\n\tint i,j,k;\n\tdouble a,b,mtb,mt,mb,vx1,vy1,vx2,vy2,vx[5],vy[5];\n\tfor (i=0;i<2;i++) { vx[i]=bx[n1][i+1]-bx[n1][i]; vy[i]=by[n1][i+1]-by[n1][i];}\n\tfor (i=0;i<3;i++) { vx[2+i]=tx[n2][(i+1) % 3]-tx[n2][i]; vy[2+i]=ty[n2][(i+1) % 3]-ty[n2][i];}\n\tfor (i=0;i<5;i++) {\n\t\t vx2=-vy[i]; vy2=vx[i];\n\t\t vx1=vx2/sqrt(vx2*vx2+vy2*vy2); vy1=vy2/sqrt(vx2*vx2+vy2*vy2);\n\t\t mtb=0;\n\t\tfor (j=0;j<3;j++) for (k=0;k<4;k++) {\n\t\t vx2=bx[n1][k]-tx[n2][j]; vy2=by[n1][k]-ty[n2][j];\n\t\t a=vx2*vx1+vy2*vy1; if (a<0) a=-a;\n\t\t if (a>mtb) mtb=a;\n\t     }\n\t     a=vx[0]*vx1+vy[0]*vy1; if (a<0) a=-a;\n\t     b=vx[1]*vx1+vy[1]*vy1; if (b<0) b=-b;\n\t     mb=a+b;\n\t     mt=0;\n\t     for (j=0;j<3;j++) { a=(vx[2+j]*vx1+vy[2+j]*vy1)/2; if (a<0) a=-a;  mt+=a;  }\n\t     if (mtb-mt-mb>0.01) return 0;   \n\t\t      }\n\t\t return 1;     \n         }\n         \nvoid  search(int s) {\n\tint i,j,c;\n\tf[s]=1;\n\tfor (i=0;i<g[s].t;i++) if (f[g[s].to[i]]==0) {\n\t\t  c=0;\n\t\t for (j=0;j<g[g[s].to[i]].t;j++)  if (g[g[s].to[i]].to[j]==s) c=1;\n\t\t     if (c==0) g[g[s].to[i]].f=0;\n\t\t     search(g[s].to[i]); \n\t\t }\n\tfor (i=0;i<g[s].f;i++) if (f[g[s].fr[i]]==0) { search(g[s].fr[i]); break;}\n }\n  \nint main() {\n\tint i,j,ans;\n\twhile (true) {\n\tcin >> n >> d;\n\tif (n==0) break;\n    for (i=0;i<n;i++) {\n\t\tfor (j=0;j<3;j++) cin >> tx[i][j] >> ty[i][j];\n\t\tg[i].t=g[i].f=0;\n\t    }\n    makebox();\n    for (i=0;i<n;i++) for (j=0;j<n;j++) if (i!=j) {if (hit(i,j)==1) { g[i].to[g[i].t]=j; g[i].t++; g[j].fr[g[j].f]=i; g[j].f++;}}\n\tfor (i=0;i<n;i++) f[i]=0; ans=0;\n\tfor (i=0;i<n;i++) if (f[i]==0) { ans++; search(i);}\n\tcout << ans << endl;\n    }    \n   return 0;\n}  \t "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<stack>\n#include<complex>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nconst double EPS = 1e-1;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersect(G &rect, G &tri){\n\trep(i,3)if(contains(rect,tri[i]))return 1;\n\trep(i,3){\n\t\tL l(tri[i],tri[(i+1)%3]);\n\t\trep(j,4)if(intersectSS(l,L(rect[i],rect[(i+1)%4])))return 1;\n\t}\n\treturn 0;\n}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight=0) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid visit(const Graph &g, int v, vector< vector<int> >& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  fr(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const Graph& g,\n    vector< vector<int> >& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint main(){\n\tint n;\n\tdouble d;\n\twhile(cin>>n>>d,n){\n\t\tvector<G> tri;\n\t\trep(i,n){\n\t\t\tdouble a,b,c,d,e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tG p; p.pb(P(a,b)); p.pb(P(c,d)); p.pb(P(e,f));\n\t\t\tif(abs(p[2]-p[0])!=abs(p[2]-p[1])){\n\t\t\t\tif(abs(p[2]-p[0])==abs(p[1]-p[0]))swap(p[2],p[0]);\n\t\t\t\telse swap(p[1],p[0]);\n\t\t\t}\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\tGraph e(n);\n\t\t\n\t\trep(i,n)rep(j,n)if(i!=j){\n\t\t\t\n\t\t\tG &p=tri[i];\n\t\t\tP m=(p[0]+p[1])*0.5,dir=(p[2]-m)*(d/abs(p[2]-m));\n\t\t\t\n\t\t\tG rect;\n\t\t\trect.pb(p[0]); rect.pb(p[1]);\n\t\t\trect.pb(p[1]+dir); rect.pb(p[0]+dir);\n\t\t\tif(ccw(rect[0],rect[1],rect[2])<0)reverse(rect.begin(),rect.end());\n\t\t\t\n\t\t\tif(intersect(rect,tri[j]))e[i].pb(Edge(i,j));\n\t\t}\n\t\t\n\t\tvector<vector<int> > scc;\n\t\tstronglyConnectedComponents(e,scc);\n\t\tint m=scc.size(),to[100],in[100]={0},ans=0;\n\t\trep(i,m)fr(j,scc[i])to[*j]=i;\n\t\trep(i,n)fr(j,e[i])if(to[i]!=to[j->dst])\n\t\tin[to[j->dst]]++;\n\t\t\n\t\trep(i,m)if(in[i]==0)ans++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS = 1e-4, INF = 1e12, PI = acos(-1.0);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  G ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) < EPS && EPS < imag(b))\n      if (cross(a, b) < -EPS) in = !in;\n    if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n  }\n  return in ? IN : OUT;\n}\n#include<stack>\nvoid visit(const vector<vi> &g, int v, vector<vi>& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  each(e, g[v]) {\n    int w = *e;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const vector<vi>& g,\n    vector<vi>& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint n, d;\nvector<vi> g;\n\nint main(){\n\twhile(cin >> n >> d, n || d){\n\t\tg.clear(); g.resize(n);\n\t\tvector<G> tri;\n\t\trep(i, n){\n\t\t\tint t;\n\t\t\tG p(3);\n\t\t\tdouble l[3];\n\t\t\trep(j, 3) cin >> p[j].real() >> p[j].imag();\n\t\t\trep(j, 3) l[j] = abs(p[j] - p[(j + 1) % 3]);\n\t\t\trep(j, 3) if(abs(l[j] - l[(j + 1) % 3]) < EPS){\n\t\t\t\tt = (j + 1) % 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswap(p[t], p[(t + 1) % 3]);\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\trep(i, n){\n\t\t\tG &p = tri[i];\n\t\t\tP dir = p[0] - (p[1] + p[2]) * 0.5;\n\t\t\tdir *= d / abs(dir);\n\t\t\t\n\t\t\tG ps;\n\t\t\tps.pb(p[1]); ps.pb(p[2]);\n\t\t\tps.pb(p[1] + dir); ps.pb(p[2] + dir);\n\t\t\tps = convex_hull(ps);\n\t\t\t\n\t\t\trep(j, n){\n\t\t\t\tbool ok = 0;\n\t\t\t\trep(k, 3) if(contains(ps, tri[j][k]) != OUT) ok = 1;\n\t\t\t\tif(ok) g[i].pb(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tmap<int, int> to;\n\t\tvector<vi> scc;\n\t\tstronglyConnectedComponents(g, scc);\n\t\tint m = scc.size();\n\t\tvi in(m);\n\t\t\n\t\trep(i, m) rep(j, scc[i].size()){\n\t\t\tto[scc[i][j]] = i;\n\t\t}\n\t\trep(i, n) rep(j, g[i].size()){\n\t\t\tint a = to[i], b = to[g[i][j]];\n\t\t\tif(a != b) in[b]++;\n\t\t}\n\t\trep(i, m) if(in[i] == 0) ans++;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-2;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nint V;\nvector<vector<int> > G,rG;\nvector<int> vs;\nbool used[100];\nint cmp[100];\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]){\n      dfs(G[v][i]);\n    }\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]){\n      rdfs(rG[v][i],k);\n    }\n  }\n}\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[2])>eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    G=rG=vector<vector<int> >(n);\n    vs.clear();\n    bool e[100][100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<eps;\n\t      e[i][j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    e[i][j]|=!f;\n\t    if(e[i][j]){\n\t      G[i].push_back(j);\n\t      rG[j].push_back(i);\n\t    }\n\t  }\n\t}\n      }\n    }\n    V=n;\n    fill(begin(used),end(used),false);\n    for(int v=0;v<V;v++){\n      if(!used[v]){\n\tdfs(v);\n      }\n    }\n    fill(begin(used),end(used),false);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]]){\n\trdfs(vs[i],k++);\n      }\n    }\n    bool in[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(e[i][j]&&cmp[i]!=cmp[j]){\n\t  in[cmp[j]]=true;\n\t}\n      }\n    }\n    cout<<count(in,in+k,false)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-5;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      /*\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n      */\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[ j].pb(i);\n      }else if (is_intersected_polygon(tri[i],tri[j])){\n\t//\tassert(false);\n\tinedge[i].pb(j);\n\tredge[ j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<cstdlib>\n#include<cmath>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define reep(i,n) reps(i,1,n+1)\n\n#define INF 1000000000\n\ndouble getlength(double dx, double dy){\n\treturn sqrt(dx*dx + dy*dy);\n}\n\nclass Point{\n\tpublic:\n\tdouble x,y;\n\tPoint(double x, double y):x(x),y(y){}\n};\n\nclass Line{\n\tpublic:\n\tdouble cx,cy,r,s;\n\tLine(double cx,double cy,double r,double s):cx(cx),cy(cy),r(r),s(s){}\n\tLine(int x1,int y1,int x2,int y2){\n\t\tcx = (x1+x2)/2.0;\n\t\tcy = (y1+y2)/2.0;\n\t\tr = getlength(x1-x2, y1-y2)/2.0;\n\t\ts = atan2(y2-y1, x2-x1);\n\t}\n\tLine(){}\n\tvoid print(){\n\t\tprintf(\"line cx=%.2lf cy=%.2lf r=%.2lf s=%.2lf\\n\",cx,cy,r,s);\n\t}\n\tbool ishit(double x, double y, double d){\n\t\tx-=cx; y-=cy;\n\t\tdouble nx = cos(s)*x - sin(s)*y;\n\t\tdouble ny = sin(s)*x + cos(s)*y;\n\t\t\n\t\t//printf(\"nx=%.2lf ny=%.2lf\\n\",nx,ny);\n\t\t\n\t\tif(fabs(nx)<=r && 0<=ny && ny<=d)return true;\n\t\treturn false;\n\t}\n\tPoint getpoint(){\n\t\treturn Point(cx+r*cos(s), cy+r*sin(s));\n\t}\n};\n\nclass Tri{\n\tpublic:\n\tLine line[3];\n\tTri(int x1,int y1,int x2,int y2,int x3,int y3){\n\t\tline[0] = Line(x1,y1,x2,y2);\n\t\tline[1] = Line(x2,y2,x3,y3);\n\t\tline[2] = Line(x3,y3,x1,y1);\n\t\tlinesort();\n\t}\n\tvoid linesort(){\n\t\twhile(1){\n\t\t\tif(line[0].r > line[1].r)return;\n\t\t\tLine bin = line[0];\n\t\t\tline[0] = line[1];\n\t\t\tline[1] = line[2];\n\t\t\tline[2] = bin;\n\t\t}\n\t}\n\tPoint getpoint(int num){\n\t\treturn line[num].getpoint();\n\t}\n\tvoid print(){\n\t\tprintf(\"TRIANGLE\\n\");\n\t\trep(i,3) line[i].print();\n\t}\n};\n\nvoid saiki(int now, int& val, int num[100], vector<int> to[100]){\n\tif(num[now]!=-1)return;\n\tnum[now] = val; val++;\n\t\n\trep(i,to[now].size()){\n\t\tsaiki(to[now][i], val, num, to);\n\t}\n}\n\nvoid saiki2(int now,int visit[100],vector<int> ot[100]){\n\tif(visit[now]==1)return;\n\tvisit[now] = 1;\n\t\n\trep(i,ot[now].size()){\n\t\tsaiki2(ot[now][i], visit, ot);\n\t}\n}\n\nint maina(){\n\tint x1,y1,x2,y2,x3,y3;\n\tcin>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\n\tLine line = Line(x1,y1,x2,y2);\n\tline.ishit(x3,y3,1);\n}\n/*\n0 1 1 0 1 1\n*/\n\nint main(){\n\twhile(1){\n\t\tint n,d;\n\t\tcin>>n>>d;\n\t\tif(n==0)break;\n\t\t\n\t\tvector<Tri> tri;\n\t\t\n\t\trep(i,n){\n\t\t\tint x1,y1,x2,y2,x3,y3;\n\t\t\tcin>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\t\t\n\t\t\ttri.push_back(Tri(x1,y1,x2,y2,x3,y3));\n\t\t}\n\t\t\n\t\t//グラフの構成\n\t\tvector<int> to[100];\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tbool hit = false;\n\t\t\t\trep(p,3){\n\t\t\t\t\tPoint pt = tri[j].getpoint(p);\n\t\t\t\t\thit |= tri[i].line[0].ishit(pt.x, pt.y, d);\n\t\t\t\t}\n\t\t\t\tif(hit){\n\t\t\t\t\tto[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\trep(i,n){\n\t\t\tprintf(\"GRAPH \");\n\t\t\trep(j,to[i].size()){\n\t\t\t\tprintf(\"%d \",to[i][j]);\n\t\t\t}puts(\"\");\n\t\t}*/\n\t\t\n\t\t//逆向きグラフの構成\n\t\tvector<int> ot[100];\n\t\trep(i,n){\n\t\t\trep(j,to[i].size()){\n\t\t\t\tot[to[i][j]].push_back(i);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\trep(i,n){\n\t\t\tprintf(\"HPARG \");\n\t\t\trep(j,ot[i].size()){\n\t\t\t\tprintf(\"%d \",ot[i][j]);\n\t\t\t}puts(\"\");\n\t\t}*/\n\t\t\n\t\t//行きがけ数値配布\n\t\tint num[100]; int val=0;\n\t\trep(i,100)num[i]=-1;\n\t\trep(i,n)saiki(i, val, num, to);\n\t\tint start[100];\n\t\trep(i,n)start[num[i]] = i;\n\t\t/*rep(i,n){\n\t\t\tprintf(\"IKI %d\\n\",num[i]);\n\t\t}*/\n\t\t/*\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tprintf(\"sti = %d\\n\",start[i]);\n\t\t}*/\n\t\t\n\t\t//逆向き探索\n\t\tint visit[100]={0}; int ans = 0;\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tif(visit[start[i]]==0){\n\t\t\t\tans++;\n\t\t\t\tsaiki2(start[i], visit, ot);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<unordered_map>\n#define eps 1e-9\nusing namespace std;\n\ntypedef complex<double> point;\ntypedef pair<point, point> pp;\n\n//??????\ndouble dot(point a, point b){\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\n//??????\ndouble cross(point a, point b){\n  return imag(conj(a) * b);\n}\n\n//counter clock wise\nint ccw(point a, point b, point c){\n  if(cross(b - a, c - a) >  eps)return  1;//??????ab????????´\n  if(cross(b - a, c - a) < -eps)return -1;//??????ab????????´\n  if(dot(b - a, c - a) < -eps)return 2;//??´???ab??????a???????????????\n  if(abs(b - a) + eps < abs(c - a))return -2;//??´???ab??????b???????????????\n  return 0;//??´???ab???\n}\ntypedef struct door{\n  double r;\n  point x, y, z, p;\n  point rot(point p, double theta){\n    return point(p.real()*cos(theta) +\n                 p.imag()*sin(theta),\n                 -p.real()*sin(theta) +\n                 p.imag()*cos(theta));\n  }\n  void rectangle(){\n    p = y - x;\n    if(ccw(x, y, z) == -1){\n      p = rot(p, M_PI/2.0);\n    }else if(ccw(x, y, z) == 1){\n      p = rot(p, -M_PI/2.0);\n    }\n    p *= r/abs(p);\n  }\n}door;\n\nclass SCC{\npublic:\n  SCC(vector<vector<int> > g_):g(g_){\n    rg.resize(g.size());\n    for (int i = 0; i < g.size(); i++) {\n      for (int j = 0; j < g[i].size(); j++) {\n        rg[g[i][j]].push_back(i);\n      }\n    }\n  };\n  void makeScc();\n  int size(){return g.size();};\n  int sccSize(){return scc.size();};\n  vector<vector<int> > g, scc;\nprivate:\n  void dfs(int v, bool *used);\n  void rdfs(int v, int k, bool *used);\n  vector<vector<int> > rg;\n  vector<int> vs, cmp;\n};\n\nvoid SCC::makeScc() {\n  bool used[g.size()];\n  memset(used, false, sizeof(used));\n  vs.resize(g.size());\n  cmp.resize(g.size(), -1);\n  for (int i = 0; i < g.size(); i++) {\n    if(not used[i])dfs(i, used);\n  }\n  memset(used, false, sizeof(used));\n  int k = 0;\n  for (int i = vs.size() -  1; i >= 0; i--) {\n    if(not used[vs[i]]) rdfs(vs[i], k++, used);\n  }\n  unordered_map<int, int> hash;\n  for (int i = 0; i < cmp.size(); i++) {\n    hash[i] = cmp[i];\n  }\n  scc.resize(hash.size());\n  for (int i = 0; i < g.size(); i++) {\n    for (int j = 0; j < g[i].size(); j++) {\n      scc[hash[g[i][j]]].push_back(hash[i]);\n    }\n  }\n}\nvoid SCC::dfs(int v, bool *used) {\n  used[v] = true;\n  for (int i = 0; i < g[v].size(); i++) {\n    if(not used[g[v][i]])dfs(g[v][i], used);\n  }\n  vs.push_back(v);\n}\nvoid SCC::rdfs(int v, int k, bool* used){\n  used[v] = true;\n  cmp[v] = k;\n  for (int i = 0; i < rg[v].size(); i++) {\n    if(not used[rg[v][i]])\n      rdfs(rg[v][i], k, used);\n  }\n}\n\nbool isCover(door from, door to){\n  point p[4];\n  p[0] = from.x;\n  p[1] = from.y;\n  p[2] = from.y + from.p;\n  p[3] = from.x + from.p;\n\n  int f = ccw(p[0], p[1], to.x);\n  bool flag = true;\n  for (int i = 1; i < 4; i++) {\n    if(ccw(p[i], p[(i + 1)%4], to.x) != f and\n       ccw(p[i], p[(i + 1)%4], to.x) != 0)\n      flag = false;\n  }\n  if(flag)return true;\n  f = ccw(p[0], p[1], to.y);\n  for (int i = 1; i < 4; i++) {\n    if(ccw(p[i], p[(i + 1)%4], to.y) != f and\n       ccw(p[i], p[(i + 1)%4], to.y) != 0)\n      return false;\n  }\n  return true;\n}\n\n\n\n\nint main(){\n  int n, r;\n  while(std::cin >> n >> r, n){\n    door d[n];\n    for (int i = 0; i < n; i++) {\n      int a, b;\n      std::cin >> a >> b;\n      d[i].x = point(a, b);\n    \n      std::cin >> a >> b;\n      d[i].y = point(a, b);\n    \n      std::cin >> a >> b;\n      d[i].z = point(a, b);\n      d[i].r = r;\n      d[i].rectangle();\n    }\n    vector<vector<int> > g(n), rg(n);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if(isCover(d[i], d[j])){\n          g[i].push_back(j);\n          rg[j].push_back(i);\n        }\n      }\n    }\n    SCC dag(g);\n    dag.makeScc();\n    int ans = 0;\n    for (int i = 0; i < dag.sccSize(); i++) {\n      if(dag.scc[i].size() == 0)ans++;\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-1;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<-eps ) && //-EPS\n        ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <-eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-9;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0)\n\t    swap(rect[i][0],rect[i][1]);\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k])){\n\t    f = true; break;\n\t  }\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int edges[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])edges[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!edges[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<stack>\n#include<complex>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nconst double EPS = 0.1;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > EPS)   return +1;       // counter clockwise\n  if (cross(b, c) < -EPS)   return -1;       // clockwise\n  if (dot(b, c) < -EPS)     return +2;       // c--a--b on line\n  if (norm(b)+EPS < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)+EPS) swap(a, b);\n    if (imag(a) < EPS && EPS < imag(b))\n      if (cross(a, b) < -EPS) in = !in;\n    if (abs(cross(a, b)) < EPS && dot(a, b) < -EPS) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) < 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) < 0;\n}\nbool intersect(G &rect, G &tri){\n\trep(i,3)if(contains(rect,tri[i]))return 1;\n\trep(i,4)if(contains(tri,rect[i]))return 1;\n\trep(i,3){\n\t\tL l(tri[i],tri[(i+1)%3]);\n\t\trep(j,4)if(intersectSS(l,L(rect[i],rect[(i+1)%4])))return 1;\n\t}\n\treturn 0;\n}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight=0) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid visit(const Graph &g, int v, vector< vector<int> >& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  fr(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const Graph& g,\n    vector< vector<int> >& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint main(){\n\tint n;\n\tdouble d;\n\twhile(cin>>n>>d,n){\n\t\tvector<G> tri;\n\t\trep(i,n){\n\t\t\tdouble a,b,c,d,e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tG p; p.pb(P(a,b)); p.pb(P(c,d)); p.pb(P(e,f));\n\t\t\tif(abs(p[2]-p[0])!=abs(p[2]-p[1])){\n\t\t\t\tif(abs(p[2]-p[0])==abs(p[1]-p[0]))swap(p[2],p[0]);\n\t\t\t\telse swap(p[1],p[0]);\n\t\t\t}\n\t\t\tif(ccw(p[0],p[1],p[2])<0)swap(p[0],p[1]);\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\tGraph e(n);\n\t\t\n\t\trep(i,n)rep(j,n)if(i!=j){\n\t\t\t\n\t\t\tG &p=tri[i];\n\t\t\tP m=(p[0]+p[1])*0.5,dir=(p[2]-m)*(d/abs(p[2]-m));\n\t\t\t\n\t\t\tG rect;\n\t\t\trect.pb(p[0]); rect.pb(p[1]);\n\t\t\trect.pb(p[1]+dir); rect.pb(p[0]+dir);\n\t\t\tif(ccw(rect[0],rect[1],rect[2])<0)reverse(rect.begin(),rect.end());\n\t\t\t\n\t\t\tif(intersect(rect,tri[j]))e[i].pb(Edge(i,j));\n\t\t}\n\t\t\n\t\tvector<vector<int> > scc;\n\t\tstronglyConnectedComponents(e,scc);\n\t\tint m=scc.size(),to[100],in[100]={0},ans=0;\n\t\trep(i,m)fr(j,scc[i])to[*j]=i;\n\t\trep(i,n)fr(j,e[i])if(to[i]!=to[j->dst])\n\t\tin[to[j->dst]]++;\n\t\t\n\t\trep(i,m)if(in[i]==0)ans++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-8;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nPoly tri[110];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nvector<P> convex_hull(vector<P> v){\n  int n = v.size(), k = 0;\n  sort(v.begin(),v.end());\n  vector<P> r(2*n);\n  for(int i=0;i<n;i++){\n    while(k>1 && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= EPS)k--;\n    r[k++] = v[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= EPS)k--;\n    r[k++] = v[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\nbool cross_poly(Poly a, Poly b){\n  int n1 = a.size(), n2 = b.size();\n  rep(i,n2)if(inter_pos(a,b[i]))return true;\n  rep(i,n1)if(inter_pos(b,a[i]))return true;\n  rep(i,n1)rep(j,n2)\n    if(is_cp(L(a[i],a[(i+1)%n1]),L(b[j],b[(j+1)%n2])))return true;\n  return false;\n}\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      tri[i].resize(3);\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n      tri[i] = convex_hull(tri[i]);\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]); break;\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n      rect[i] = convex_hull(rect[i]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\tif(cross_poly(rect[i],tri[j])){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS = 0.01, INF = 1e12, PI = acos(-1.0);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  G ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) < EPS && EPS < imag(b))\n      if (cross(a, b) < -EPS) in = !in;\n    if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n  }\n  return in ? IN : OUT;\n}\n#include<stack>\nvoid visit(const vector<vi> &g, int v, vector<vi>& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  each(e, g[v]) {\n    int w = *e;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const vector<vi>& g,\n    vector<vi>& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint n, d;\nvector<vi> g;\n\nint main(){\n\twhile(cin >> n >> d, n || d){\n\t\tg.clear(); g.resize(n);\n\t\tvector<G> tri;\n\t\trep(i, n){\n\t\t\tint t;\n\t\t\tG p(3);\n\t\t\tdouble l[3];\n\t\t\trep(j, 3) cin >> p[j].real() >> p[j].imag();\n\t\t\trep(j, 3) l[j] = abs(p[j] - p[(j + 1) % 3]);\n\t\t\trep(j, 3) if(abs(l[j] - l[(j + 1) % 3]) < EPS){\n\t\t\t\tt = (j + 1) % 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswap(p[t], p[(t + 1) % 3]);\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\trep(i, n){\n\t\t\tG &p = tri[i];\n\t\t\tP dir = p[0] - (p[1] + p[2]) * 0.5;\n\t\t\tdir *= d / abs(dir);\n\t\t\t\n\t\t\tG ps;\n\t\t\tps.pb(p[1]); ps.pb(p[2]);\n\t\t\tps.pb(p[1] + dir); ps.pb(p[2] + dir);\n\t\t\tps = convex_hull(ps);\n\t\t\t\n\t\t\trep(j, n){\n\t\t\t\tbool ok = 0;\n\t\t\t\trep(k, 3) if(contains(ps, tri[j][k]) != OUT) ok = 1;\n\t\t\t\tif(ok) g[i].pb(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tmap<int, int> to;\n\t\tvector<vi> scc;\n\t\tstronglyConnectedComponents(g, scc);\n\t\tint m = scc.size();\n\t\tvi in(m);\n\t\t\n\t\trep(i, m) rep(j, scc[i].size()){\n\t\t\tto[scc[i][j]] = i;\n\t\t}\n\t\trep(i, n) rep(j, g[i].size()){\n\t\t\tint a = to[i], b = to[g[i][j]];\n\t\t\tif(a != b) in[b]++;\n\t\t}\n\t\trep(i, m) if(in[i] == 0) ans++;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-8 + 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}*/\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\t/*for (int i = 0; i < g.size(); i++){\n\t\tSegment s(curr(g, i), next(g, i));\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(s, h[j]) <= EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}*/\n\tfor (int i = 0; i < h.size(); i++){\n\t\tSegment s(curr(h, i), next(h, i));\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(s, g[j]) <= EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tbool f = false;\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\t\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t\tf = true;\n\t\t}\n\t\tassert(f);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to] = 1;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値, Polygonのメンバ変数\n#include<algorithm> // min(), sort(), reverse()\n \nconst double EPS = 1e-10;\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\nclass Polygon;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    const Point normalize() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n    void print() const;\n};\nbool operator==(const Point& lhs, const Point& rhs);\nbool operator!=(const Point& lhs, const Point& rhs);\nbool operator<(const Point& lhs, const Point& rhs);\nbool operator>(const Point& lhs, const Point& rhs);\nbool operator<=(const Point& lhs, const Point& rhs);\nbool operator>=(const Point& lhs, const Point& rhs);\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Segment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Segment&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Segment&) const;\n    bool orthogonal(const Line&) const;\n    POSITION ccw(const Point&) const;\n    void print() const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Line(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Segment&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Segment&) const;\n    bool orthogonal(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n    void print() const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool in(const Point&) const;\n    bool out(const Point&) const;\n    bool include(const Point&) const;\n    bool include(const Segment&) const;\n    bool include(const Line&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    std::vector<Point> crosspoint(const Circle&) const;\n    void print() const;\n};\nclass Polygon {\n    std::vector<Point> point;\npublic:\n    Polygon() {}\n    explicit Polygon(std::vector<Point> p) :point(p) {}\n    const std::vector<Point>& vertex() const {return point;}\n    const Point& vertex(int i) const {return point.at(i);}\n    const std::vector<Segment> edge() const {\n        std::vector<Segment> result;\n        for(int i = 0; i < size(); ++i) result.push_back(Segment(vertex(i), vertex((i + 1) % size())));\n        return result;\n    }\n    const Segment edge(int i) const {return Segment(vertex(i), vertex((i + 1) % size()));}\n    int size() const {return point.size();}\n    void add(const Point&);\n    double area() const;\n    bool convex() const;\n    bool include(const Point&) const;\n    bool intersect(const Polygon&) const;\n    bool on_edge(const Point&) const;\n    const Polygon convex_hull() const;\n    void print() const;\n};\n// Point\nbool operator==(const Point& lhs, const Point& rhs) {return lhs.x() == rhs.x() && lhs.y() == rhs.y();}\nbool operator!=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() || lhs.y() != rhs.y();}\nbool operator<(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() < rhs.y();}\nbool operator>(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() > rhs.y();}\nbool operator<=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() <= rhs.y();}\nbool operator>=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() >= rhs.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\nconst Point Point::normalize() const {return abs() == 0.0 ? Point(0.0, 0.0) : Point(x(), y()) / abs();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return COUNTER_CLOCKWISE;\n    if(v1.cross(v2) < -EPS) return CLOCKWISE;\n    if(v1.dot(v2) < -EPS) return ONLINE_BACK;\n    if(v2.norm() - v1.norm() > EPS) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nvoid Point::print() const {std::cout << x() << \", \" << y() << std::endl;}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    return std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    return std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nbool Segment::parallel(const Line& l) const {line().parallel(l);}\nbool Segment::parallel(const Segment& s) const {return line().parallel(s.line());}\nbool Segment::orthogonal(const Line& l) const {return line().orthogonal(l);}\nbool Segment::orthogonal(const Segment& s) const {return line().orthogonal(s.line());}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\nvoid Segment::print() const {std::cout << \"source: \"; source().print(); std::cout << \"target: \"; target().print();}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nbool Line::parallel(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dxl - dyl * dx) <= EPS;\n}\nbool Line::parallel(const Segment& s) const {return parallel(s.line());}\nbool Line::orthogonal(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dyl + dxl * dx) <= EPS;\n}\nbool Line::orthogonal(const Segment& s) const {return orthogonal(s.line());}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) return l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\nvoid Line::print() const {std::cout << \"source: \"; source().print(); std::cout << \"target: \"; target().print();}\n// Circle\nbool Circle::in(const Point& p) const {return center().distance(p) < r() - EPS;}\nbool Circle::out(const Point& p) const {return r() + EPS < center().distance(p);}\nbool Circle::include(const Point& p) const {return center().distance(p) <= r() + EPS;}\nbool Circle::include(const Segment& s) const {return center().distance(s) <= r() + EPS;}\nbool Circle::include(const Line& l) const {return center().distance(l) <= r() + EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) <= r() - c.r() + EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) <= r() + c.r() + EPS;}\nstd::vector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    std::vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\nvoid Circle::print() const {std::cout << \"radius: \" << r() << \" - point: \"; center().print();}\n// Polygon\nvoid Polygon::add(const Point& p) {point.push_back(p);}\ndouble Polygon::area() const {\n    double sum = 0.0;\n    for(int i = 0; i < size(); ++i) sum += vertex(i).cross(vertex((i+1) % size()));\n    return fabs(sum) / 2.0;\n}\nbool Polygon::convex() const {\n    POSITION direction = ONLINE_BACK;\n    for(int i = 1; i < size(); ++i) {\n        POSITION d = vertex(i - 1).ccw(vertex(i), vertex((i + 1) % size()));\n        if(d != CLOCKWISE && d != COUNTER_CLOCKWISE) continue;\n        if(direction == ONLINE_BACK) direction = d;\n        if(direction != d) return false;\n    }\n    return true;\n}\nbool Polygon::include(const Point& p) const {\n    bool in = false;\n    for(int i = 0; i < size(); ++i) {\n        Point a = vertex(i) - p;\n        Point b = vertex((i + 1) % size()) - p;\n        if(a.y() > b.y()) std::swap(a, b);\n        if(a.y() <= 0.0 && 0 < b.y() && a.cross(b) < 0.0) in = !in;\n        if(fabs(a.cross(b)) <= EPS && a.dot(b) <= EPS) return true;\n    }\n    return in;\n}\nbool Polygon::intersect(const Polygon& p) const {\n    for(const auto& e1: edge()) for(const auto& e2: p.edge()) if(e1.intersect(e2)) return true;\n    return false;\n}\nbool Polygon::on_edge(const Point& p) const {\n    for(int i = 0; i < size(); ++i) if(vertex(i).ccw(vertex((i + 1) % size()), p) == ON_SEGMENT) return true;\n    return false;\n}\nconst Polygon Polygon::convex_hull() const {                // Andrew's Monotone Chain\n    Polygon result;\n    std::vector<Point> res;\n    std::vector<Point> original = vertex();\n    sort(original.begin(), original.end());\n    original.insert(original.end(), original.rbegin() + 1, original.rend());\n    for(const auto& v: original) {\n        while(res.size() >= 2 && res[res.size() - 2].ccw(res[res.size() - 1], v) == CLOCKWISE) res.pop_back();\n        res.push_back(v);\n    }\n    res.pop_back();\n    for(const auto& v: res) result.add(v);\n    return result;\n}\nvoid Polygon::print() const {for(const auto& v: vertex()) std::cout << v.x() << \", \" << v.y() << std::endl;}\n \n////////////////////////////////////////////////////////////////////////////////\n \nusing namespace std;\n \nint main() {\n    int n, d;\n    while(cin >> n >> d, n | d) {\n        vector<Polygon> triangle(n);\n        for(auto &t: triangle) {\n            vector<Point> vertex(3);\n            for(auto &v: vertex) {\n                double x, y;\n                cin >> x >> y;\n                v = Point(x, y);\n            }\n            if(vertex[0].distance(vertex[1]) == vertex[0].distance(vertex[2])) swap(vertex[0], vertex[2]);\n            if(vertex[1].distance(vertex[0]) == vertex[1].distance(vertex[2])) swap(vertex[1], vertex[2]);\n            for(const auto &v: vertex) t.add(v);\n        }\n \n        vector<Polygon> light(n);\n        for(int i = 0; i < triangle.size(); ++i) {\n            Point n = (triangle[i].vertex(1) - triangle[i].vertex(0)).normalize();\n            if(triangle[i].vertex(0).ccw(triangle[i].vertex(1), triangle[i].vertex(2)) > 0) n = Point(-n.y(), n.x());\n            else                                                                            n = Point(n.y(), -n.x());\n            light[i].add(triangle[i].vertex(0));\n            light[i].add(triangle[i].vertex(0) + (n * d));\n            light[i].add(triangle[i].vertex(1) + (n * d));\n            light[i].add(triangle[i].vertex(1));\n        }\n \n        vector<int> indegree(n, 0);\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if(i == j) continue;\n                // 辺の交差判定\n                for(const auto &l: light[i].edge()) {\n                    for(const auto &t: triangle[j].edge())\n                        if(l.intersect(t)) ++indegree[j];\n                }\n                // 点の包含判定\n                for(const auto &v: light[i].vertex()) {\n                    if(triangle[j].include(v)) ++indegree[j];\n                }\n                for(const auto &v: triangle[j].vertex()) {\n                    if(light[i].include(v)) ++indegree[j];\n                }\n                // 線分と点の距離が0.01以下\n                for(const auto &l: light[i].edge()) {\n                    for(const auto &t: triangle[j].edge())\n                        if(l.distance(t) <= 0.01) ++indegree[j];\n                }\n            }\n        }\n        cout << count(indegree.begin(), indegree.end(), 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-8 + 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tSegment s(curr(g, i), next(g, i));\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(s, h[j]) <= EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tSegment s(curr(h, i), next(h, i));\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(s, g[j]) <= EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(norm(b - a), norm(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tbool f = false;\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\t\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t\tf = true;\n\t\t}\n\t\tassert(f);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-8;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tif (contains(g, h[0])) return true;\n\tif (contains(h, g[0])) return true;\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc()\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tvector<int> cmp(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>> sccgraph = scc();\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0) res++;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-1;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n        ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n        ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n      if (is_intersected_polygon(tri[i],tri[j])){\n\tassert(false);\n      }\n\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    d+=0.0001;\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\n#define EPS 0.01\n\ntypedef complex<double> point;\ntypedef const point &refpoint;\n\n\nint n;\nvector<vector<point> > trgs, sqrs;\nvector<int> to[100], rto[100];\nvector<int> vs;\nbool used[100];\nint cmp[100];\n\n\ndouble dot(refpoint a, refpoint b){\n\treturn real(a) * real(b) + imag(a) * imag(b);\n}\n\ndouble cross(refpoint a, refpoint b){\n\treturn real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble distance_l_p(refpoint a, refpoint b, refpoint c){\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\ndouble distance_ls_p(refpoint a, refpoint b, refpoint c){\n\tif( dot(b - a, c - a) <= 0.0 ) return abs(c - a);\n\tif( dot(a - b, c - b) <= 0.0 ) return abs(c - b);\n\treturn distance_l_p(a, b, c);\n}\n\nbool contains(const vector<point> &plg, refpoint pts){\n\tint cnt = 0;\n\tdouble y = imag(pts);\n\n\tfor(int i = 0; i < plg.size(); ++i){\n\t\tint j = (i + 1 == plg.size() ? 0: i + 1);\n\n\t\tif( distance_ls_p(plg[i], plg[j], pts) <= EPS ){\n\t\t\treturn true;\n\t\t}\n\n\t\tdouble dyi = imag(plg[i]) - y;\n\t\tdouble dyj = y - imag(plg[j]);\n\t\tdouble tx = (dyi * real(plg[j]) + dyj * real(plg[i])) / (dyi + dyj);\n\n\t\tif(imag(plg[i]) >= y && imag(plg[j]) < y){\n\t\t\tif( tx < real(pts) ) ++cnt;\n\t\t}\n\t\telse if(imag(plg[i]) < y && imag(plg[j]) >= y){\n\t\t\tif( tx < real(pts) ) --cnt;\n\t\t}\n\t}\n\t\n\treturn (cnt % 2 != 0);\n}\n\nbool contact(const vector<point> &plg1, const vector<point> &plg2){\n\tfor(int i = 0; i < plg1.size(); ++i){\n\t\tif( contains(plg2, plg1[i]) ) return true;\n\t}\n\tfor(int i = 0; i < plg2.size(); ++i){\n\t\tif( contains(plg1, plg2[i]) ) return true;\n\t}\n\treturn false;\n}\n\nvector<point> square(const vector<point> &trg, double d){\n\tvector<point> ret(4);\n\n\tdouble norms[3];\n\tfor(int i = 0; i < 3; ++i){\n\t\tnorms[i] = norm(trg[i] - trg[(i + 1) % 3]);\n\t}\n\n\tint idx = 2;\n\tfor(int i = 1; i < 3; ++i){\n\t\tif(norms[0] == norms[i]){\n\t\t\tidx = 2 - i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint other0 = (idx + 1) % 3;\n\tint other1 = (idx + 2) % 3;\n\t\n\tret[0] = trg[other0];\n\tret[1] = trg[other1];\n\t\n\tpoint dif = polar(d, arg(ret[1] - ret[0]) + asin(1.0));\n\n\tif( cross(ret[1] - ret[0], trg[idx] - ret[0]) >= 0.0 ){\n\t\tret[2] = ret[1] + dif;\n\t\tret[3] = ret[0] + dif;\n\t}\n\telse{\n\t\tret[2] = ret[1] - dif;\n\t\tret[3] = ret[0] - dif;\n\t}\n\n\treturn ret;\n}\n\nvoid dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < to[v].size(); ++i){\n\t\tif( !used[ to[v][i] ] )\tdfs( to[v][i] );\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n\tused[v] = true;\n\tcmp[v] = k;\n\n\tfor(int i = 0; i < rto[v].size(); ++i){\n\t\tif( !used[ rto[v][i] ] ) rdfs( rto[v][i], k );\n\t}\n}\n\nint scc(){\n\tvs.clear();\n\t\n\tfor(int v = 0; v < n; ++v){\n\t\tif( !used[v] ) dfs(v);\n\t}\n\n\tmemset(used, 0, 100);\n\tint k = 0;\n\tfor(int i = vs.size() - 1; i >= 0; --i){\n\t\tif( !used[ vs[i] ] ) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\n\nint solve(){\n\tfor(int i = 0; i < n; ++i){\n\t\tto[i].clear();\n\t\trto[i].clear();\n\t\tused[i] = false;\n\t\tcmp[i] = 0;\n\t}\n\n\tfor(int i = 0; i < n; ++i){\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif( i != j && contact(sqrs[i], trgs[j]) ){\n\t\t\t\tto[i].push_back(j);\n\t\t\t\trto[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint k = scc();\n\tvector<int> rcount(k);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tfor(int j = 0; j < to[i].size(); ++j){\n\t\t\tif( cmp[i] != cmp[ to[i][j] ] ){\n\t\t\t\t++rcount[ cmp[ to[i][j] ] ];\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\tfor(int i = 0; i < k; ++i){\n\t\tif( rcount[i] == 0 ) ++ret;\n\t}\n\n\treturn ret;\n}\n\n\nint main(){\n\tvector<point> trg(3);\n\ttrgs.reserve(100);\n\tsqrs.reserve(100);\n\n\tint x, y;\n\tdouble d;\n\tfor( ; scanf(\"%d%lf\", &n, &d), n; ){\n\t\ttrgs.clear();\n\t\tsqrs.clear();\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < 3; ++j){\n\t\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t\ttrg[j] = point(x, y);\n\t\t\t}\n\n\t\t\ttrgs.push_back(trg);\n\t\t\tsqrs.push_back( square(trg, d) );\n\t\t}\n\n\t\tprintf(\"%d\\n\", solve() );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass UnionFindTree\n{\n    vector<int> parent; // em[h\n    vector<int> rank;   // ØÌ³ÌãÀ\n    int find(int x){\n        if(parent[x] == x)\n            return x;\n        return parent[x] = find(parent[x]);\n    }\npublic:\n    UnionFindTree(int n){ // RXgN^\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        rank.assign(n, 0);\n    }\n    void unite(int x, int y){ // xÆyÌO[vð¹\n        if((x = find(x)) != (y = find(y))){\n            if(rank[x] < rank[y])\n                parent[x] = y;\n            else{\n                parent[y] = x;\n                if(rank[x] == rank[y])\n                    ++ rank[x];\n            }\n        }\n    }\n    bool same(int x, int y){ // xÆyÌO[vª¯¶©ð²×é\n        return find(x) == find(y);\n    }\n    int num(){ // O[vÌðÔ·\n        vector<bool> root(parent.size(), false);\n        for(unsigned i=0; i<parent.size(); ++i)\n            root[find(i)] = true;\n        return count(root.begin(), root.end(), true);\n    }\n};\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\ndouble segmentPointDist(const Point& a1, const Point& a2, const Point& p)\n{\n    if((a2-a1).dot(p-a1) < 0)\n        return a1.dist(p);\n    else if((a1-a2).dot(p-a2) < 0)\n        return a2.dist(p);\n    else\n        return abs((a2-a1).cross(p-a1)) / a1.dist(a2);\n}\n\ndouble segmentsDist(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) < -EPS) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) < -EPS))\n        return 0.0;\n\n    double ret = segmentPointDist(a1, a2, b1);\n    ret = min(ret, segmentPointDist(a1, a2, b2));\n    ret = min(ret, segmentPointDist(b1, b2, a1));\n    ret = min(ret, segmentPointDist(b1, b2, a2));\n    return ret;\n}\n\nbool convexContain(const vector<Point>& cp, const Point& p)\n{\n    int n = cp.size();\n    bool ret1 = true;\n    bool ret2 = true;\n    for(int i=0; i<n; ++i){\n        double a = (cp[(i+1)%n] - cp[i]).cross(p - cp[i]);\n        if(a < -EPS)\n            ret1 = false;\n        if(a > EPS)\n            ret2 = false;\n    }\n    return ret1 || ret2;\n}\n\nbool polygonsCollide(const vector<Point>& cp1, const vector<Point>& cp2)\n{\n    int n = cp1.size();\n    int m = cp2.size();\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<m; ++j){\n            if(segmentsDist(cp1[i], cp1[(i+1)%n], cp2[j], cp2[(j+1)%m]) < 0.01 + EPS)\n                return true;\n        }\n    }\n\n    return convexContain(cp1, cp2[0]) || convexContain(cp2, cp1[0]);\n}\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Point> > p(n, vector<Point>(3));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<3; ++j){\n                cin >> p[i][j].x >> p[i][j].y;\n            }\n            if(p[i][0].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][1], p[i][2]);\n            if(p[i][1].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][0], p[i][2]);\n            if((p[i][1] - p[i][0]).cross(p[i][2] - p[i][0]) < 0)\n                swap(p[i][0], p[i][1]);\n        }\n\n        UnionFindTree uft(n);\n        vector<bool> check(n, false);\n        for(int i=0; i<n; ++i){\n            Point v = p[i][1] - p[i][0];\n            v = v / v.length() * d;\n            swap(v.y, v.x);\n            v.x *= -1;\n\n            vector<Point> p1(4);\n            p1[0] = p[i][0];\n            p1[1] = p[i][0] + v;\n            p1[2] = p[i][1] + v;\n            p1[3] = p[i][1];\n\n            for(int j=0; j<n; ++j){\n                if(j == i)\n                    continue;\n                if(polygonsCollide(p1, p[j])){\n                    uft.unite(i, j);\n                    check[j] = true;\n                }\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            if(!check[i])\n                ++ ret;\n            else{\n                bool b = true;\n                for(int j=0; j<n; ++j){\n                    if(uft.same(i, j) && !check[j])\n                        b = false;\n                }\n                if(b)\n                    ++ ret;\n                check[i] = false;\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n \n#define MAX_N (128)\n#define EPS (0.01)\n#define SQ(X) ((X) * (X))\n \nusing namespace std;\n \nclass Triangle {\n    public:\n        double x[3], y[3];\n        int no;\n};\n \nclass Point {\n    public:\n        double x, y;\n         \n        Point operator - (Point &a){\n            Point ret;\n            ret.x = x - a.x;\n            ret.y = y - a.y;\n            return (ret);\n        }\n};\n \nvector<int> G[MAX_N];\nvector<int> rG[MAX_N];\nvector<int> compress[MAX_N];\nvector<int> vs;\nbool used[MAX_N];\nbool group[MAX_N];\nint cmp[MAX_N];\nint N;\n \nvoid addEdge(int from, int to)\n{\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n \nvoid dfs(int v)\n{\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++){\n        if (!used[G[v][i]]){\n            dfs(G[v][i]);\n        }\n    }\n    vs.push_back(v);\n}\n \nvoid revDfs(int v, int k)\n{\n    used[v] = true;\n    cmp[v] = k;\n    for (int i = 0; i < rG[v].size(); i++){\n        if (!used[rG[v][i]]){\n            revDfs(rG[v][i], k);\n        }\n    }\n}\n \nint scc()\n{\n    int ret;\n    memset(used, 0, sizeof(used));\n    vs.clear();\n     \n    for (int i = 0; i < N; i++){\n        if (!used[i]){\n            dfs(i);\n        }\n    }\n     \n    memset(used, 0, sizeof(used));\n     \n    ret = 0;\n    for (int i = vs.size() - 1; i >= 0; i--){\n        if (!used[vs[i]]){\n            revDfs(vs[i], ret++);\n        }\n    }\n     \n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < G[i].size(); j++){\n            if (cmp[i] != cmp[G[i][j]]){\n                compress[cmp[G[i][j]]].push_back(cmp[i]);\n            }\n        }\n    }\n     \n    return (ret);\n}\n \ndouble inProduct(Point a, Point b)\n{\n    return (a.x * b.x + a.y * b.y);\n}\n \ndouble getSize(Point a)\n{\n    return (sqrt(SQ(a.x) + SQ(a.y)));\n}\n \nbool checkCross(Point *p, Point k)\n{\n\tdouble minX, minY, maxX, maxY;\n\t\n\tmaxX = max(max(p[0].x, p[1].x), max(p[2].x, p[3].x));\n\tminX = min(min(p[0].x, p[1].x), min(p[2].x, p[3].x));\n\tmaxY = max(max(p[0].y, p[1].y), max(p[2].y, p[3].y));\n\tminY = min(min(p[0].y, p[1].y), min(p[2].y, p[3].y));\n\t\n\tbool checkX = minX - k.x <= EPS && k.x - maxX <= EPS;\n\tbool checkY = minY - k.y <= EPS && k.y - maxY <= EPS;\n    return (checkX && checkY);\n}\n \nvoid judgeAdj(Triangle a, Triangle b, double dist)\n{\n    double len;\n    Point p[4];\n     \n    len = 0.0;\n    for (int i = 0; i < 3; i++){\n        for (int j = i + 1; j < 3; j++){\n            if (len < SQ(a.x[i] - a.x[j]) + SQ(a.y[i] - a.y[j])){\n                len = SQ(a.x[i] - a.x[j]) + SQ(a.y[i] - a.y[j]);\n                p[0].x = a.x[i], p[0].y = a.y[i];\n                p[1].x = a.x[j], p[1].y = a.y[j];\n            }\n        }\n    }\n    //printf(\"%lf %lf %lf %lf\\n\", p[0].x, p[0].y, p[1].x, p[1].y);\n    Point e, sa;\n     \n    e.x = 0, e.y = 1;\n    sa = p[0] - p[1];\n    double theta = acos(inProduct(e, sa) / (getSize(e) * getSize(sa)));\n    theta = min(theta, M_PI - theta);\n    //printf(\"theta = %lf\\n\", theta);\n     \n    p[2].x = p[0].x + dist * cos(theta), p[2].y = p[0].y + dist * sin(theta);\n    p[3].x = p[1].x + dist * cos(theta), p[3].y = p[1].y + dist * sin(theta);\n     \n    bool cross = false;\n     \n    for (int i = 0; i < 3; i++){\n\t\tPoint k;\n        k.x = b.x[i], k.y = b.y[i];\n\t\tcross |= checkCross(p, k);\n    }\n     \n    if (cross == true){\n        //printf(\"hoge, %d, %d\\n\", a.no, b.no);\n        addEdge(a.no, b.no);\n    }\n     \n}\n \nint main()\n{\n    int n, d;\n    Triangle data[128];\n     \n    while (1){\n         \n        scanf(\"%d%d\", &n, &d);\n         \n        N = n;\n        if (n + d == 0){\n            break;\n        }\n         \n        for (int i = 0; i < n; i++){\n            data[i].no = i;\n            for (int j = 0; j < 3; j++){\n                scanf(\"%lf%lf\", &data[i].x[j], &data[i].y[j]);\n            }\n        }\n         \n        for (int i = 0; i < n; i++){\n            G[i].clear();\n            rG[i].clear();\n            compress[i].clear();\n        }\n         \n        for (int i = 0; i < n; i++){\n            for (int j = 0; j < n; j++){\n                if (i != j){\n                    judgeAdj(data[i], data[j], d);\n                }\n            }\n        }\n         \n        int k = scc();\n         \n        int ans = 0;\n        memset(used, 0, sizeof(used));\n         \n        for (int i = 0; i < k; i++){\n            if (compress[i].size() == 0){\n                ans++;\n            }\n        }\n         \n        printf(\"%d\\n\", ans);\n    }\n     \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nint g[110][110];\nPt p[110][3];\nint UF[110];\nint v[110];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[i][i]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble ax,bx,cx,ay,by,cy;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n\t\t\tdouble A=(bx-cx)*(bx-cx)+(by-cy)*(by-cy);\n\t\t\tdouble B=(ax-cx)*(ax-cx)+(ay-cy)*(ay-cy);\n\t\t\tdouble C=(ax-bx)*(ax-bx)+(ay-by)*(ay-by);\n\t\t\tif(ABS(A-B)<EPS){\n\t\t\t\tp[i][0]=Pt(ax,ay);p[i][1]=Pt(bx,by);p[i][2]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(B-C)<EPS){\n\t\t\t\tp[i][2]=Pt(ax,ay);p[i][0]=Pt(bx,by);p[i][1]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(C-A)<EPS){\n\t\t\t\tp[i][1]=Pt(ax,ay);p[i][2]=Pt(bx,by);p[i][0]=Pt(cx,cy);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)if(iSP(p[i][0],p[i][2],p[i][1])==-1)swap(p[i][0],p[i][1]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tif(i==j)continue;\n\t\t\tPt t[4];\n\t\t\tt[0]=p[i][0];\n\t\t\tt[1]=p[i][1];\n\t\t\tt[3]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[3]=t[0]+t[3]/t[3].ABS()*(double)b;\n\t\t\tt[2]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[2]=t[1]+t[2]/t[2].ABS()*(double)b;\n\t\t\n\t\t\tbool ok=false;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tbool L=false;\n\t\t\t\tbool R=false;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][k]+(p[j][(k+1)%3]-p[j][k])*1000000.0))L=true;\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][(k+1)%3],p[j][(k+1)%3]+(p[j][k]-p[j][(k+1)%3])*1000000.0))R=true;\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][(k+1)%3]))ok=true;\n\t\t\t\t}\n\t\t\t\tif(L&&R)ok=true;\n\t\t\t}\n\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\tbool L=false;\n\t\t\t\tbool R=false;\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tif(iSS(t[l],t[l]+(t[(l+1)%4]-t[l])*1000000.0,p[j][k],p[j][(k+1)%3]))L=true;\n\t\t\t\t\tif(iSS(t[(l+1)%4],t[(l+1)%4]+(t[l]-t[(l+1)%4])*1000000.0,p[j][k],p[j][(k+1)%3]))R=true;\n\t\t\t\t}\n\t\t\t\tif(L&&R)ok=true;\n\t\t\t}\n\t\t\t\n\t\t\tif(ok){\n\t\t\t\tg[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]|=g[i][k]&g[k][j];\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)if(g[i][j]&&g[j][i])UNION(i,j);\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++)v[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(FIND(i)!=FIND(j)&&g[j][i])ok=false;\n\t\t\t}\n\t\t\tif(ok&&!v[FIND(i)]){\n\t\t\t\tret++;v[FIND(i)]=1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-8, AD = 1e-2;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0){\n\t    swap(rect[i][0],rect[i][1]); break;\n\t  }\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k])){\n\t    f = true; break;\n\t  }\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3)if(seg_p_dis(rseg,tri[j][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,3){\n\t    L tseg = L(tri[j][k],rect[j][(k+1)%3]);\n\t    rep(l,4)if(seg_p_dis(tseg,rect[i][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int edges[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])edges[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!edges[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst double EPS = 0.01;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n//????????´???????£???????????????????(??????????????£???????????????)\nenum{NO_HIT=0, HIT, A_IN_B, B_IN_A};\nint HitPol_Pol(const polygon& a, const polygon& b){\n\tbool f = true, hit = false;\n\trep(i, a.size()){\n\t\tif(!contains(b, a[i])) f = false;\n\t\telse hit = true;\n\t}\n\tif(f) return A_IN_B;\n\tf = true;\n\trep(i, b.size()){\n\t\tif(!contains(a, b[i])) f = false;\n\t\telse hit = true;\n\t}\n\tif(f) return B_IN_A;\n\tif(hit) return HIT;\n\trep(i, a.size()) rep(j, b.size()){\n\t\tL la(curr(a, i), next(a, i)), lb(curr(b, j), next(b, j));\n\t\tif(intersectSS(la, lb)) return HIT;\n\t}\n\treturn NO_HIT;\n}\n//point???theta???????????¢\npoint spinP(const point& p, double theta){\n\treturn p*complex<double>(cos(theta),sin(theta));\n}\npoint spinPExtend(const point& p, double theta, double rate){\n\treturn p*complex<double>(rate*cos(theta),rate*sin(theta));\n}\n\nstruct SCC{//O(V+E)\n    static const int MAX_V = 1010;\n    int V;\n    vector<int> G[MAX_V], rG[MAX_V];\n    vector<int> vs;\n    bool used[MAX_V];\n    int cmp[MAX_V];\n    vector<vector<int> > res;\n \n \n    SCC(int v) : V(v){};\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n \n    void dfs(int v){\n        used[v] = true;\n        for(int i = 0; i < G[v].size(); i++){\n            if(!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v] = true;\n        cmp[v] = k;\n        for(int i = 0; i < rG[v].size(); i++){\n            if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n \n    int scc(){\n        memset(used, 0, sizeof(used));\n        vs.clear();\n        for(int v = 0; v < V; v++){\n            if(!used[v]) dfs(v);\n        }\n        memset(used, 0, sizeof(used));\n        int k = 0;\n        for(int i = vs.size() - 1; i >= 0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++);\n        }\n \n        res.clear();\n        res.resize(k);\n        for(int i = 0; i < V; i++){\n            res[cmp[i]].push_back(i);\n        }\n        return k;\n    }\n};\n\nint main(){\n\tint n, d;\n\twhile(cin >> n >> d && (n+d)){\n\t\tvector<polygon> tri(n);\n\t\trep(i, n){\n\t\t\tdouble x, y;\n\t\t\trep(j, 3){\n\t\t\t\tcin >> x >> y;\n\t\t\t\ttri[i].pb({x, y});\n\t\t\t}\n\t\t}\n\t\tvector<polygon> pol(n);\n\t\trep(i, n){\n\t\t\tdouble dist[3];\n\t\t\trep(j, 3){\n\t\t\t\tdist[j] = abs(curr(tri[i], j)-next(tri[i], j));\n\t\t\t}\n\t\t\trep(j, 3) {\n\t\t\t\tif(abs(dist[j] - dist[(j+1)%3])<1e-8){\n\t\t\t\t\tpol[i].pb(tri[i][j]);\n\t\t\t\t\tpol[i].pb(tri[i][(j+2)%3]);\n\t\t\t\t\tpol[i].pb(spinPExtend(pol[i][0]-pol[i][1], (ccw(pol[i][1], pol[i][0], tri[i][(j+1)%3])> 0)?PI/2:PI/2*3, d/abs(pol[i][1]-pol[i][0]))+pol[i][1]);\n\t\t\t\t\tpol[i].pb(pol[i][2]+pol[i][0]-pol[i][1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSCC scc(n);\n\t\trep(i, n) rep(j, i){\n\t\t\tassert(pol[i].size()==4);\n\t\t\tassert(tri[i].size()==3);\n\t\t\tassert(pol[j].size()==4);\n\t\t\tassert(tri[j].size()==3);\n\t\t\tif(HitPol_Pol(pol[i], tri[j])>0) scc.add_edge(i, j);\n\t\t\tif(HitPol_Pol(tri[i], pol[j])>0) scc.add_edge(j, i);\n\t\t}\n\t\tscc.scc();\n\t\tvector<int> f(scc.res.size(), 1);\n\t\trep(i, n) rep(j, i){\n\t\t\tif(scc.cmp[i] == scc.cmp[j]) continue;\n\t\t\tif(HitPol_Pol(pol[i], tri[j])>0) f[scc.cmp[j]] = 0;\n\t\t\telse if(HitPol_Pol(tri[i], pol[j])>0) f[scc.cmp[i]] = 0;\n\t\t}\n\t\tcout<<accumulate(all(f), 0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef int Weight;\nconst Weight INF = 1 << 28;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge() {}\n\tEdge(int src, int dst, Weight weight = 1): src(src), dst(dst), weight(weight) {}\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n\nvoid addEdge(Graph &g, int src, int dst, int weight = 1)\n{\n\tg[src].push_back(Edge(src, dst, weight));\n};\n\nGraph transpose(const Graph &g)\n{\n\tGraph rg(g.size());\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\taddEdge(rg, g[i][j].dst, g[i][j].src, g[i][j].weight);\n\t\t}\n\t}\n\treturn rg;\n}\n\nstd::vector<Weight> dijkstra(const Graph &g, int src){\n\tstd::vector<Weight> dist(g.size(), INF);\n\tstd::priority_queue<std::pair<Weight, int>,\n\t                    std::vector<std::pair<Weight, int> >,\n\t\t\t\t\t\tstd::greater<std::pair<Weight, int> > > pq;\n\t\n\tdist[src] = Weight(0);\n\tpq.push(std::make_pair(Weight(0), src));\n\t\n\twhile (pq.size()){\n\t\tint cur = pq.top().second;\n\t\tWeight sum = pq.top().first;\n\t\tpq.pop();\n\t\tif (dist[cur] < sum) continue;\n\t\t\n\t\tfor (int i = 0; i < g[cur].size(); i++){\n\t\t\tconst Edge &e = g[cur][i];\n\t\t\tif (dist[e.dst] > sum + e.weight){\n\t\t\t\tdist[e.dst] = sum + e.weight;\n\t\t\t\tpq.push(std::make_pair(sum + e.weight, e.dst));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dist;\n}\n\nvoid dfs_(const Graph &g, int v, bool *used, std::vector<int> &vs)\n{\n\tused[v] = true;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) dfs_(g, to, used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs_(const Graph &g, int v, int k, bool *used, std::vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) rdfs_(g, to, k, used, cmp);\n\t}\n}\n\nint scc(const Graph &g, std::vector<int> &cmp)\n{\n\tGraph rg = transpose(g);\n\tstd::vector<int> vs;\n\tbool *used = new bool[g.size()];\n\tcmp.resize(g.size());\n\t\n\tmemset(used, false, g.size());\n\tfor (int v = 0; v < g.size(); v++){\n\t\tif (!used[v]) dfs_(g, v, used, vs);\n\t}\n\t\n\tmemset(used, false, g.size());\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs_(rg, vs[i], k++, used, cmp);\n\t}\n\t\n\tdelete used;\n\treturn k;\n}\n\n#include <bits/stdc++.h>\n\nnamespace geo {\n\n// ???????????§??????\n\ntypedef std::complex<double> Point;\n\nstruct Segment {\n\tPoint p1, p2;\n\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n};\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef std::vector<Point> Polygon;\n\n// ?????°, ??????\n\nconst double PI = acos(-1);\nconst double EPS = 1e-2;\nconst double INF = 1e12;\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE \t\t= -1;\nconst int ONLINE_BACK\t\t= 2;\nconst int ONLINE_FRONT\t\t= -2;\nconst int ON_SEGMENT\t\t= 0;\nconst int OUT\t\t\t\t= 0;\nconst int ON\t\t\t\t= 1;\nconst int IN\t\t\t\t= 2;\n\ninline double square(double a){return a * a;}\ninline bool equal(double a, double b){return std::abs(a - b) < EPS;}\ninline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\ninline double norm(const Point &a){return square(a.real()) + square(a.imag());}\ninline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\ninline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\ninline double toDeg(double t){return t / PI * 180;}\ninline double toRad(double t){return t / 180 * PI;}\n\n#define curr(v, i) v[i]\n#define next(v, i) v[(i + 1) % v.size()]\n#define prev(v, i) v[(i - 1 + (int)v.size()) % v.size()]\n\n\n// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n// ????§?????????????????????? Point rp ?????£??\\????????????\n\nbool cmpx(const Point &a, const Point &b){\n\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\treturn b.imag() < b.imag();\n}\n\nbool cmpy(const Point &a, const Point &b){\n\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\treturn a.real() < b.real();\n}\n\nPoint rp;\nbool cmparg(const Point &a, const Point &b){\n\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\tif (!equal(rada, radb)) return rada < radb;\n\treturn norm(a) < norm(b);\n}\n\n\n// ??´???, ??????\n\nbool orthgonal(const Vector &a, const Vector &b){\n\treturn equal(dot(a, b), 0.0);\n}\n\nbool parallel(const Vector &a, const Vector &b){\n\treturn equal(cross(a, b), 0.0);\n}\n\n\n// ????°?, ?°???±\n\nPoint project(const Segment &s, const Point &p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(const Segment &s, const Point &p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\n\n// ??????????????????\n\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n\n// ?????¢\n\ndouble distanceLP(const Line &l, const Point &p){\n\treturn std::abs(cross(l.p2 - l.p1, p - l.p1) / std::abs(l.p2 - l.p1));\n}\n\ndouble distanceSP(const Segment &s, const Point &p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return std::abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return std::abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\nbool intersect(const Segment &s1, const Segment &s2);\ndouble distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn std::min(\n\t\tstd::min(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\tstd::min(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t);\n}\n\n\n// ????????????\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &s){\n\t// ???????????° (0 ~ 2) ?????????\n\tdouble dist = distanceSP(s, c.p) - c.r;\n\tif (equal(dist, 0.0)) return 1;\n\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\nint intersect(const Circle &c1, const Circle &c2){\n\t// ???????????° (0 ~ 2) ?????????\n\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\tif (equal(dist, 0.0)) return 1;\n\tif (dist < 0.0) return 2;\n\treturn 0;\n}\n\n\n// ??????\n\nPoint crossPoint(const Segment &s1, const Segment &s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = std::abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = std::abs(cross(base, s1.p2 - s2.p1));\n\t\n\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\tassert(!equal(d1 + d2, 0.0));\n\t\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nstd::vector<Point> crossPoints(const Circle &c, const Line &l){\n\tstd::vector<Point> res;\n\tif (!intersect(c, l)) return res;\n\t\n\tVector pr = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / std::abs(l.p2 - l.p1);\n\tdouble base = std::sqrt(c.r * c.r - norm(pr - c.p));\n\tres.push_back(pr + e * base);\n\tres.push_back(pr - e * base);\n\tif (equalVector(res[0], res[1])) res.pop_back();\n\treturn res;\n}\n\nstd::vector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\tstd::vector<Point> res;\n\tif (!intersect(c1, c2)) return res;\n\t\n\tdouble d = std::abs(c1.p - c2.p);\n\tdouble a = std::acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\tdouble t = std::arg(c2.p - c1.p);\n\tres.push_back(c1.p + std::polar(c1.r, t + a));\n\tres.push_back(c1.p + std::polar(c1.r, t - a));\n\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\n\treturn res;\n}\n\n\n// ??????\n\nint contains(const Polygon &g, const Point &p){\n\tint n = g.size();\n\tbool res = false;\n\tfor (int i = 0; i < n; i++){\n\t\tPoint a = g[i] - p;\n\t\tPoint b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t}\n\treturn res ? IN : OUT;\n}\n\n\n// ??????\n\nPolygon convexHull(std::vector<Point> s){\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tstd::sort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\t\n\tfor (int i = 2; i < s.size(); i++){\n\t\tint n = u.size();\n\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\tu.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t\n\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\tint n = l.size();\n\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\tl.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t\n\tstd::reverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\tl.push_back(u[i]);\n\t}\n\t\n\treturn l;\n}\n\t\n\n// ???????§???¢??????\n\nPolygon convexCut(const Polygon &g, const Line &l){\n\tPolygon res;\n\tfor (int i = 0; i < g.size(); i++){\n\t\tconst Point &a = curr(g, i);\n\t\tconst Point &b = next(g, i);\n\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\tres.push_back(a);\n\t\t}\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\n}\n\nnamespace std {\nbool operator < (const geo::Point &a, const geo::Point &b){\n\treturn geo::cmpx(a, b);\n}\n}\n\nbool intersect(const geo::Polygon &g, const geo::Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tgeo::Segment s(curr(g, i), next(g, i));\n\t\t\tgeo::Segment t(curr(h, j), next(h, j));\n\t\t\tif (geo::intersect(s, t)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (geo::contains(h, curr(g, i))) return true;\n\t}\n\t\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (geo::contains(g, curr(h, i))) return true;\n\t}\n\t\n\treturn false;\n}\n\nint n;\ndouble d;\nstd::vector<geo::Polygon> tris;\nstd::vector<geo::Polygon> sqrs;\n\nvoid solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tgeo::Point &a = curr(tris[i], j),\n\t\t\t\t\t   &b = prev(tris[i], j),\n\t\t\t\t\t   &c = next(tris[i], j);\n\t\t\tif (geo::equal(std::abs(a - b), std::abs(a - c))){\n\t\t\t\tstd::swap(tris[i][j], tris[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsqrs.assign(n, geo::Polygon(4));\n\tfor (int i = 0; i < n; i++){\n\t\tgeo::Vector normal = tris[i][2] - (tris[i][0] + tris[i][1]) / 2.0;\n\t\tnormal = normal / std::abs(normal) * d;\n\t\t\n\t\tsqrs[i][0] = tris[i][0];\n\t\tsqrs[i][1] = tris[i][1];\n\t\tsqrs[i][2] = tris[i][1] + normal;\n\t\tsqrs[i][3] = tris[i][0] + normal;\n\t}\n\t\n\tGraph g(n);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqrs[i], tris[j])){\n\t\t\t\taddEdge(g, i, j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstd::vector<int> cmp;\n\tint k = scc(g, cmp);\n\t\n\tstd::vector<int> v(k, 1);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\tint src = g[i][j].src;\n\t\t\tint dst = g[i][j].dst;\n\t\t\tif (src != dst) v[cmp[dst]] = 0;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < k; i++){\n\t\tres += v[i];\n\t}\n\t\n\tstd::printf(\"%d\\n\", res);\n}\n\nint main()\n{\n\twhile (std::scanf(\"%d %lf\", &n, &d), n){\n\t\ttris.assign(n, geo::Polygon(3));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tdouble x, y;\n\t\t\t\tstd::cin >> x >> y;\n\t\t\t\ttris[i][j] = geo::Point(x, y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-3;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[0])<eps||fabs(l[2]-l[0])<eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    bool c[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<-eps;\n\t      c[j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    c[j]|=!f;\n\t  }\n\t}\n      }\n    }\n    cout<<max<int>(1,count(c,c+n,false))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-2;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      break;\n    }\n  }while(next_permutation(in,in+3));\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-2;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nint V;\nvector<vector<int> > G,rG;\nvector<int> vs;\nbool used[100];\nint cmp[100];\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]){\n      dfs(G[v][i]);\n    }\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]){\n      rdfs(rG[v][i],k);\n    }\n  }\n}\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[2])>eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    G=rG=vector<vector<int> >(n);\n    vs.clear();\n    bool e[100][100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<-eps;\n\t      e[i][j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    e[i][j]|=!f;\n\t    if(e[i][j]){\n\t      G[i].push_back(j);\n\t      rG[j].push_back(i);\n\t    }\n\t  }\n\t}\n      }\n    }\n    V=n;\n    fill(begin(used),end(used),false);\n    for(int v=0;v<V;v++){\n      if(!used[v]){\n\tdfs(v);\n      }\n    }\n    fill(begin(used),end(used),false);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]]){\n\trdfs(vs[i],k++);\n      }\n    }\n    bool in[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(e[i][j]&&cmp[i]!=cmp[j]){\n\t  in[cmp[j]]=true;\n\t}\n      }\n    }\n    cout<<count(in,in+k,false)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nint g[110][110];\nPt p[110][3];\nint UF[110];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[i][i]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble ax,bx,cx,ay,by,cy;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n\t\t\tdouble A=(bx-cx)*(bx-cx)+(by-cy)*(by-cy);\n\t\t\tdouble B=(ax-cx)*(ax-cx)+(ay-cy)*(ay-cy);\n\t\t\tdouble C=(ax-bx)*(ax-bx)+(ay-by)*(ay-by);\n\t\t\tif(ABS(A-B)<EPS){\n\t\t\t\tp[i][0]=Pt(ax,ay);p[i][1]=Pt(bx,by);p[i][2]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(B-C)<EPS){\n\t\t\t\tp[i][2]=Pt(ax,ay);p[i][0]=Pt(bx,by);p[i][1]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(C-A)<EPS){\n\t\t\t\tp[i][1]=Pt(ax,ay);p[i][2]=Pt(bx,by);p[i][0]=Pt(cx,cy);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)if(iSP(p[i][0],p[i][2],p[i][1])==-1)swap(p[i][0],p[i][1]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tif(i==j)continue;\n\t\t\tPt t[4];\n\t\t\tt[0]=p[i][0];\n\t\t\tt[1]=p[i][1];\n\t\t\tt[3]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[3]=t[0]+t[3]/t[3].ABS()*(double)b;\n\t\t\tt[2]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[2]=t[1]+t[2]/t[2].ABS()*(double)b;\n\t\t\n\t\t\tbool ok=false;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tbool L=false;\n\t\t\t\tbool R=false;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][k]+(p[j][(k+1)%3]-p[j][k])*1000000.0))L=true;\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][(k+1)%3],p[j][(k+1)%3]+(p[j][k]-p[j][(k+1)%3])*1000000.0))R=true;\n\t\t\t\t}\n\t\t\t\tif(L&&R)ok=true;\n\t\t\t}\n\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\tbool L=false;\n\t\t\t\tbool R=false;\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tif(iSS(t[l],t[l]+(t[(l+1)%4]-t[l])*1000000.0,p[j][k],p[j][(k+1)%3]))L=true;\n\t\t\t\t\tif(iSS(t[(l+1)%4],t[(l+1)%4]+(t[l]-t[(l+1)%4])*1000000.0,p[j][k],p[j][(k+1)%3]))R=true;\n\t\t\t\t}\n\t\t\t\tif(L&&R)ok=true;\n\t\t\t}\n\t\t\t\n\t\t\tif(ok){\n\t\t\t\tg[i][j]=1;\n\t\t//\t\tprintf(\"%d %d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]|=g[i][k]&g[k][j];\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)if(g[i][j]&&g[j][i])UNION(i,j);\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(FIND(i)!=FIND(j)&&g[j][i])ok=false;\n\t\t\t}\n\t\t\tif(ok)ret++;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n        ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      /*\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n      */\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }else if (is_intersected_polygon(tri[i],tri[j])){\n\t//\tassert(false);\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    d+=0.0001;\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nint g[110][110];\nPt p[110][3];\nint UF[110];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[i][i]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble ax,bx,cx,ay,by,cy;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n\t\t\tdouble A=(bx-cx)*(bx-cx)+(by-cy)*(by-cy);\n\t\t\tdouble B=(ax-cx)*(ax-cx)+(ay-cy)*(ay-cy);\n\t\t\tdouble C=(ax-bx)*(ax-bx)+(ay-by)*(ay-by);\n\t\t\tif(ABS(A-B)<EPS){\n\t\t\t\tp[i][0]=Pt(ax,ay);p[i][1]=Pt(bx,by);p[i][2]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(B-C)<EPS){\n\t\t\t\tp[i][2]=Pt(ax,ay);p[i][0]=Pt(bx,by);p[i][1]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(C-A)<EPS){\n\t\t\t\tp[i][1]=Pt(ax,ay);p[i][2]=Pt(bx,by);p[i][0]=Pt(cx,cy);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)if(iSP(p[i][0],p[i][2],p[i][1])==-1)swap(p[i][0],p[i][1]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tif(i==j)continue;\n\t\t\tPt t[4];\n\t\t\tt[0]=p[i][0];\n\t\t\tt[1]=p[i][1];\n\t\t\tt[3]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[3]=t[0]+t[3]/t[3].ABS()*(double)b;\n\t\t\tt[2]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[2]=t[1]+t[2]/t[2].ABS()*(double)b;\n\t\t\tbool ok=false;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][k]+(p[j][(k+1)%3]-p[j][k])*10000.0)&&\n\t\t\t\t\tiSS(t[l],t[(l+1)%4],p[j][(k+1)%3],p[j][(k+1)%3]+(p[j][k]-p[j][(k+1)%3])*10000.0))ok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tg[i][j]=1;\n\t\t//\t\tprintf(\"%d %d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]|=g[i][k]&g[k][j];\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)if(g[i][j]&&g[j][i])UNION(i,j);\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(FIND(i)!=FIND(j)&&g[j][i])ok=false;\n\t\t\t}\n\t\t\tif(ok)ret++;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS = 1e-5, INF = 1e12, PI = acos(-1.0);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  G ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) < EPS && EPS < imag(b))\n      if (cross(a, b) < -EPS) in = !in;\n    if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n  }\n  return in ? IN : OUT;\n}\n#include<stack>\nvoid visit(const vector<vi> &g, int v, vector<vi>& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  each(e, g[v]) {\n    int w = *e;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const vector<vi>& g,\n    vector<vi>& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint n, d;\nvector<vi> g;\n\nint main(){\n\twhile(cin >> n >> d, n || d){\n\t\tg.clear(); g.resize(n);\n\t\tvector<G> tri;\n\t\trep(i, n){\n\t\t\tint t;\n\t\t\tG p(3);\n\t\t\tdouble l[3];\n\t\t\trep(j, 3) cin >> p[j].real() >> p[j].imag();\n\t\t\trep(j, 3) l[j] = abs(p[j] - p[(j + 1) % 3]);\n\t\t\trep(j, 3) if(abs(l[j] - l[(j + 1) % 3]) < EPS){\n\t\t\t\tt = (j + 1) % 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswap(p[t], p[(t + 1) % 3]);\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\trep(i, n){\n\t\t\tG &p = tri[i];\n\t\t\tP dir = p[0] - (p[1] + p[2]) * 0.5;\n\t\t\tdir *= d / abs(dir);\n\t\t\t\n\t\t\tG ps;\n\t\t\tps.pb(p[1]); ps.pb(p[2]);\n\t\t\tps.pb(p[1] + dir); ps.pb(p[2] + dir);\n\t\t\tps = convex_hull(ps);\n\t\t\t\n\t\t\trep(j, n){\n\t\t\t\tbool ok = 0;\n\t\t\t\trep(k, 3) if(contains(ps, tri[j][k]) != OUT) ok = 1;\n\t\t\t\tif(ok) g[i].pb(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tmap<int, int> to;\n\t\tvector<vi> scc;\n\t\tstronglyConnectedComponents(g, scc);\n\t\tint m = scc.size();\n\t\tvi in(m);\n\t\t\n\t\trep(i, m) rep(j, scc[i].size()){\n\t\t\tto[scc[i][j]] = i;\n\t\t}\n\t\trep(i, n) rep(j, g[i].size()){\n\t\t\tint a = to[i], b = to[g[i][j]];\n\t\t\tif(a != b) in[b]++;\n\t\t}\n\t\trep(i, m) if(in[i] == 0) ans++;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tSegment s(curr(g, i), next(g, i));\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distance(s, h[j]) <= EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tSegment s(curr(h, i), next(h, i));\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distance(s, g[j]) <= EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tbool f = false;\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\t\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t\tf = true;\n\t\t}\n\t\tassert(f);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to] = 1;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nstruct coor {\n\tdouble x, y;\n};\nstruct tri {\n\tcoor p[3];\n\tcoor rec[4];\n};\n\nint n, d;\nvector<tri> v;\nvector<vector<int> > edge;\n\nconst double EPS = 1e-9;\nconst double ERR = 1e-2;\n\ntemplate<class T>\nT sqr(T x) {\n\treturn x * x;\n}\n\ndouble dist(coor a, coor b) {\n\treturn sqrt(sqr(a.x-b.x) + sqr(a.y-b.y));\n}\n\ndouble dist_lp(coor c, coor a, coor b) {\n\tcoor v0, v1;\n\tv0.x = b.x - a.x; v0.y = b.y - a.y;\n\tv1.x = c.x - a.x; v1.y = c.y - a.y;\n\n\tif(sqr(dist(a,b)) + sqr(dist(a,c)) - sqr(dist(c,b)) > 0\n\t\t\t&& sqr(dist(a,b)) + sqr(dist(b,c)) - sqr(dist(c,a)) > 0) {\n\t\tdouble cross;\n\t\tcross = fabs(v0.x * v1.y - v0.y * v1.x);\n\t\treturn cross / dist(a,b);\n\t}\n\n\treturn min(dist(a,c), dist(b,c));\n}\n\nbool in_poly(coor p, coor poly[], int sz) {\n\tdouble sign = +0.0;\n\tfor(int i = 0; i < sz; i++) {\n\t\tcoor v0, v1;\n\t\tv0.x = poly[i].x - p.x; v0.y = poly[i].y - p.y;\n\t\tv1.x = poly[(i+1)%sz].x - p.x; v1.y = poly[(i+1)%sz].y - p.y;;\n\n\t\tif(i != 0 && sign * (v0.x * v1.y - v0.y * v1.x) < EPS) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tsign = (v0.x * v1.y - v0.y * v1.x);\n\n\t\tif(i == sz-1) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < sz; i++) {\n\t\tif(dist_lp(p,poly[i], poly[(i+1)%sz]) <= ERR + EPS) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool seg_cross(coor a, coor b, coor c, coor d) {\n\tcoor v0, v1, v2;\n\t\n\tv0.x = a.x - c.x; v0.y = a.y - c.y;\n\tv1.x = b.x - c.x; v1.y = b.y - c.y;\n\tv2.x = d.x - c.x; v2.y = d.y - c.y;\n\n\tdouble s, t;\n\ts = (v0.x * v2.y - v0.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\tt = - (v1.x * v2.y - v1.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\n\tif(s + t > 1-EPS && s > -EPS && t > -EPS) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool exist_edge(tri from, tri to) {\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(in_poly(to.p[i], from.rec, 4)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(in_poly(from.rec[i], to.p, 3)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 3; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tif(seg_cross(to.p[i], to.p[(i+1)%3], from.rec[j], from.rec[(j+1)%4])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool visited[128];\nbool touch[128];\n\nvoid check(int i, int s) {\n\tif(i != s && touch[i])\n\t\ttouch[i] = false;\n\tif(visited[i])\n\t\treturn;\n\tvisited[i] = true;\n\tfor(int j = 0; j < (int)edge[i].size(); j++) {\n\t\tcheck(edge[i][j], s);\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> d, n || d) {\n\t\tv.clear();\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tvisited[i] = touch[i] = false;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttri in;\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tcoor c;\n\t\t\t\tcin >> c.x >> c.y;\n\t\t\t\tin.p[j] = c;\n\t\t\t}\n\n\t\t\tbool flg = true;\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tif(fabs(dist(in.p[(0+j)%3],in.p[(1+j)%3]) - dist(in.p[(1+j)%3], in.p[(2+j)%3])) < EPS) {\n\t\t\t\t\tflg = false;\n\t\t\t\t\tswap(in.p[(1+j)%3], in.p[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg) abort();\n\n\t\t\tcoor add;\n\t\t\tadd.x =\t(in.p[1].x - in.p[0].x) + (in.p[1].x - in.p[2].x);\n\t\t\tadd.y = (in.p[1].y - in.p[0].y) + (in.p[1].y - in.p[2].y);\n\n\t\t\tdouble addlen;\n\t\t\taddlen = sqrt(sqr(add.x) + sqr(add.y));\n\t\t\tadd.x = add.x * d / addlen;\n\t\t\tadd.y = add.y * d / addlen;\n\n\t\t\tin.rec[0].x = in.p[0].x; in.rec[0].y = in.p[0].y;\n\t\t\tin.rec[1].x = in.p[2].x; in.rec[1].y = in.p[2].y;\n\t\t\tin.rec[2].x = in.p[2].x + add.x; in.rec[2].y = in.p[2].y + add.y;\n\t\t\tin.rec[3].x = in.p[0].x + add.x; in.rec[3].y = in.p[0].y + add.y;\n\n\t\t\tv.push_back(in);\n\t\t}\n\n\t\tfor(int i = 0; i < (int)v.size(); i++) {\n\t\t\tfor(int j = 0; j < (int)v.size(); j++) {\n\t\t\t\tif(i != j) {\n\t\t\t\t\tif(exist_edge(v[i], v[j])) {\n\t\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\ttouch[i] = true;\n\t\t\t\tcheck(i, i);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(touch[i])\n\t\t\t\tres++;\n\t\t}\n\t\tcout <<  res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass UnionFindTree\n{\n    vector<int> parent; // em[h\n    vector<int> rank;   // ØÌ³ÌãÀ\n    int find(int x){\n        if(parent[x] == x)\n            return x;\n        return parent[x] = find(parent[x]);\n    }\npublic:\n    UnionFindTree(int n){ // RXgN^\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        rank.assign(n, 0);\n    }\n    void unite(int x, int y){ // xÆyÌO[vð¹\n        if((x = find(x)) != (y = find(y))){\n            if(rank[x] < rank[y])\n                parent[x] = y;\n            else{\n                parent[y] = x;\n                if(rank[x] == rank[y])\n                    ++ rank[x];\n            }\n        }\n    }\n    bool same(int x, int y){ // xÆyÌO[vª¯¶©ð²×é\n        return find(x) == find(y);\n    }\n    int num(){ // O[vÌðÔ·\n        vector<bool> root(parent.size(), false);\n        for(unsigned i=0; i<parent.size(); ++i)\n            root[find(i)] = true;\n        return count(root.begin(), root.end(), true);\n    }\n};\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\nbool convexContain(const vector<Point>& cp, const Point& p)\n{\n    int n = cp.size();\n    bool ret1 = true;\n    bool ret2 = true;\n    for(int i=0; i<n; ++i){\n        double a = (cp[(i+1)%n] - cp[i]).cross(p - cp[i]);\n        if(a < -EPS)\n            ret1 = false;\n        if(a > EPS)\n            ret2 = false;\n    }\n    return ret1 || ret2;\n}\n\ndouble segmentPointDist(const Point& a1, const Point& a2, const Point& p)\n{\n    if((a2-a1).dot(p-a1) < 0){\n        return a1.dist(p);\n    }else if((a1-a2).dot(p-a2) < 0){\n        return a2.dist(p);\n    }else{\n        return abs((a2-a1).cross(p-a1)) / a1.dist(a2);\n    }\n}\n\ndouble segmentsDist(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) < -EPS) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) < -EPS))\n        return 0.0;\n\n    double ret = segmentPointDist(a1, a2, b1);\n    ret = min(ret, segmentPointDist(a1, a2, b2));\n    ret = min(ret, segmentPointDist(b1, b2, a1));\n    ret = min(ret, segmentPointDist(b1, b2, a2));\n    return ret;\n}\n\nbool polygonsCollide(const vector<Point>& cp1, const vector<Point>& cp2)\n{\n    int n = cp1.size();\n    int m = cp2.size();\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<m; ++j){\n            if(segmentsDist(cp1[i], cp1[(i+1)%n], cp2[j], cp2[(j+1)%m]) < 0.01 + EPS)\n                return true;\n        }\n    }\n\n    return false;\n}\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Point> > p(n, vector<Point>(3));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<3; ++j){\n                cin >> p[i][j].x >> p[i][j].y;\n            }\n            if(p[i][0].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][1], p[i][2]);\n            if(p[i][1].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][0], p[i][2]);\n        }\n\n        UnionFindTree uft(n);\n        vector<bool> check(n, false);\n        for(int i=0; i<n; ++i){\n            Point v = p[i][0] - p[i][1];\n            v = v / v.length() * d;\n            swap(v.y, v.x);\n            v.y *= -1;\n\n            vector<Point> p1(4);\n            p1[0] = p[i][0];\n            p1[1] = p[i][0] + v;\n            p1[2] = p[i][1] + v;\n            p1[3] = p[i][1];\n            if(!convexContain(p1, p[i][2])){\n                p1[1] = p[i][0] - v;\n                p1[2] = p[i][1] - v;\n            }\n\n            for(int j=0; j<n; ++j){\n                if(j == i)\n                    continue;\n                if(polygonsCollide(p1, p[j])){\n                    uft.unite(i, j);\n                    check[j] = true;\n                }\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            if(!check[i])\n                ++ ret;\n            else{\n                bool b = true;\n                for(int j=0; j<n; ++j){\n                    if(uft.same(i, j) && !check[j])\n                        b = false;\n                }\n                if(b)\n                    ++ ret;\n                check[i] = false;\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cfloat>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define EPS (1e-8)\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint ( double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n\tPoint operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n\tPoint operator * ( double a ){ return Point(x*a, y*a); }\n\tdouble abs() { return sqrt(norm());}\n\tdouble norm() { return x*x + y*y; }\n\tbool operator < ( const Point &p ) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == ( const Point &p ) const {\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs(Vector a) {return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b) {return (sqrt(norm(a - b)));}\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\ndouble eq(double a, double b)\n{\n\treturn (fabs(a - b) <= EPS);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n//3点の位置関係を求める\nint ccw( Point p0, Point p1, Point p2 ){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( norm(a) < norm(b) ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//A = p2 - p1, B = p4 - p3が交差するか\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n\n\n//多角形の中に点があるか\nbool isInside(Polygon gon, Point p ){\n\tfor ( int i = 0; i < gon.size(); i++ ){\n\t\tif ( ccw(gon[i], gon[(i+1)%gon.size()], p) == CLOCKWISE ) return (false);\n\t}\n\treturn (true);\n}\n\n//単位ベクトルを求める\nPoint unitVector(Point t){\n\tdouble u=abs(t);\n\treturn Point(t.x/u , t.y/u);\n}\n//cosθを求める\ndouble getcos(Point a , Point b){\n\treturn (dot(a,b) / (abs(a)*abs(b)));\n}\n\n//sinθを求める\ndouble getsin(Point a , Point b){\n\tdouble t=getcos(a,b);\n\treturn sqrt(1.0-t*t);\n}\n\n//点pと直線abとの距離を求める\ndouble pld(Point p , Point a , Point b){\n\treturn fabs(cross(b - a,p - a))/abs(b-a);\n}\n\n//点pと線分abとの距離を求める\ndouble psd(Point p , Point a , Point b){\n\tif( dot( b-a , p-a ) < EPS) return abs(p-a);\n\tif( dot( a-b , p-b ) < EPS) return abs(p-b);\n\treturn fabs(cross( b-a , p-a )) / abs(b-a);\n}\n\n//線分交点計算\nPoint interpointS(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint b=b2-b1;\n\tdouble d1=fabs(cross(b , a1-b1));\n\tdouble d2=fabs(cross(b , a2-b1));\n\tdouble t=d1 / (d1 + d2);\n\tPoint a=a2-a1;\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線交点計算\nPoint interpointL(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint a=a2-a1;\n\tPoint b=b2-b1;\n\tdouble t=cross(b , b1-a1) / cross(b , a);\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線abと円及び球 |x-c|=rの交点を求める 　球の場合は型Point→Sに変更するだけ\nvoid interpointLC(Point a , Point b , Point c , double r , Point ans[]){\n\tif(pld(c , a , b) > r + EPS) return;\n\tPoint v=unitVector(b-a);\n\tdouble delta=dot(v,a-c)*dot(v,a-c)-abs(a-c)*abs(a-c)+r*r;\n\tdouble t=-dot(v,a-c);\n\tdouble s=sqrt(delta);\n\tans[0]=a+v*(t+s);\n\tans[1]=a+v*(t-s);\n}\n\n//１次変換集\n\n//ｘ（y=k）に関する対象変換 　k=0でｘ軸による変換\nPoint xTranslate(Point t,double k){\n\treturn Point(t.x , 2*k-t.y);\n}\n\n//ｙ(x=k)に関する対象変換\tk=0でｙ軸による変換\nPoint yTranslate(Point t,double k){\n\treturn Point(2*k-t.x , t.y);\n}\n\n//点Point kに関する対象変換\t\tPoint(0,0)で原点による変換\nPoint oTranslate(Point t,Point k){\n\treturn k+(k-t);\n}\n\n\n\n\n\n//点pを中心としてr(radian)回転\t\tp(0,0)で原点を中心として回転\nPoint rotate(Point t , Point p , double r){\n\t//double r=radians(angle);\n\tdouble ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n\tdouble tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n\treturn Point(ta , tb);\n}\n\n//応用\n//２円 |x-a|=raと|x-b|=rbの交点計算\nvoid interpointCC(Point a , double ra , Point b , double rb , Point ans[]){\n\tdouble di=fabs(abs(a-b));\n\tif(di > ra+rb || di < fabs(ra-rb)) return;\n\tdouble t=(ra*ra-rb*rb+di*di)/(di+di);\n\tdouble rd=acos(t/ra);\n\n\tPoint dv=unitVector(b-a);\n\tPoint g1=rotate(dv , Point(0,0) , rd);\n\tPoint g2=rotate(dv , Point(0,0) , -rd);\n\tans[0]=a+g1*ra;\n\tans[1]=a+g2*ra;\n}\n\n//法線ベクトルを求める\nPoint normalVector(Point p,Point a,Point b){\n\tPoint v=unitVector(b-a);\n\tv = cross(v , p-a) > 0 ?  Point(v.y,(-1)*v.x) : Point((-1)*v.y , v.x);\n\treturn v*pld(p,a,b);\n}\n\n//直線abに関する対象変換\nPoint fTranslate(Point t , Point a , Point b){\n\treturn t+normalVector(t,a,b)*2;\n}\n\n//３角形の面積を求める\ndouble area(Point a, Point b, Point c){\n\treturn fabs(cross(c-a , b-a)*0.5);\n}\n\n//多角形の面積を求める //凸包のソート済みが前提\ndouble polygonArea(Polygon t){\n\tdouble ans=0.0;\n\tfor(unsigned int i=0;i<t.size();i++)\n\t\tans+=cross(t[i] , t[(i+1)%t.size()]);\n\treturn ans/2;\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = static_cast<int>(ps.size());\n    Polygon qs(n * 2);\n    for (int i = 0; i < n; ++i) {\n      while (k > 1 && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    for (int i = n-2, t = k; i >= 0; --i) {\n      while (k > t && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    qs.resize(k-1);\n    return qs;\n}\n\nPolygon tri[100];\nint n, d;\n\nbool isIn(Polygon a, Polygon b)\n{\n\tfor (int i = 0; i < a.size(); i++) if (isInside(b, a[i])) return (true);\n\tfor (int i = 0; i < b.size(); i++) if (isInside(a, b[i])) return (true);\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tif (isIntersect(a[i], a[(i + 1) % a.size()], b[j], b[(j + 1) % b.size()])) return (true);\n\t\t}\n\t}\t\n\treturn (false);\n}\n\nPolygon normalize(Polygon a)\n{\n\tdouble di[3];\n\t\n\tif (abs(a[0] - a[1]) == abs(a[1] - a[2]))\n\t\tswap(a[1], a[2]);\n\telse if (abs(a[0] - a[2]) == abs(a[0] - a[1]))\n\t\tswap(a[0], a[2]);\n\t\n\tif (ccw(a[0], a[1], a[2]) != COUNTER_CLOCKWISE) swap(a[0], a[1]);\n\t\n\treturn (a);\n}\n\nbool check(Polygon a, Polygon b)\n{\n\tPolygon c;\n\tc.push_back(a[0]); c.push_back(a[1]);\n\t\n\tPoint t = Point((a[0].x + a[1].x) / 2, (a[0].y + a[1].y) / 2);\n\tPoint k = a[2] - t;\n\tc.push_back(a[1] + k * (d / abs(k))); c.push_back(a[0] + k * (d / abs(k)));\n\t\n\treturn (isIn(c, b));\n}\n\nvector<int> G[128], rG[128];\nint ord[128], gr[128];\nbool vis[128];\nint ctr;\n\nvoid addEdge(int src, int dst)\n{\n\tG[src].push_back(dst);\n\trG[dst].push_back(src);\n}\n\nvoid dfs1(int v)\n{\n\tvis[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tif (!vis[G[v][i]]) dfs1(G[v][i]);\n\t}\n\tord[ctr++] = v;\n}\n\nvoid dfs2(int v, int k)\n{\n\tvis[v] = true;\n\tgr[v] = k;\n\tfor (int i = 0; i < rG[v].size(); i++){\n\t\tif (!vis[rG[v][i]]) dfs2(rG[v][i], k);\n\t}\n\t\n}\n\nint scc()\n{\n\t\n\tmemset(vis, 0, sizeof(vis));\n\tctr = 0;\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!vis[i]){\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\tint k = 0;\n\tmemset(vis, 0, sizeof(vis));\n\tfor (int i = n - 1; i >= 0; i--){\n\t\tif (!vis[ord[i]]){\n\t\t\tdfs2(ord[i], k++);\n\t\t}\n\t}\n\t\n\tint ret = k;\n\tmemset(vis, 0, sizeof(vis));\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < G[i].size(); j++){\n\t\t\tif (gr[i] != gr[G[i][j]]){\n\t\t\t\tret -= (1 ^ vis[gr[G[i][j]]]);\n\t\t\t\tvis[gr[G[i][j]]] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (ret);\n}\n\nint main()\n{\n\tPoint t;\n\twhile (scanf(\"%d %d\", &n, &d) && n + d){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tscanf(\"%lf %lf\", &t.x, &t.y);\n\t\t\t\ttri[i].push_back(Point(t.x, t.y));\n\t\t\t}\n\t\t\ttri[i] = normalize(tri[i]);\n\t\t\tG[i].clear(); rG[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (i != j && check(tri[i], tri[j])){\n\t\t\t\t\taddEdge(i, j);\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\t\n\t\t\n\t\tprintf(\"%d\\n\", scc());\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid stronglyConnectedComponents(const vector<vector<int> >& edges1, vector<vector<int> >& nodes, vector<vector<int> >& edges2)\n{\n    const int n = edges1.size();\n\n    class Func{\n        vector<int> num, low;\n        vector<bool> isStk;\n        stack<int> stk;\n        int time;\n    public:\n        Func(int n){\n            num.assign(n, 0);\n            low.assign(n, 0);\n            isStk.assign(n, false);\n            time = 0;\n        }\n        void visit(const vector<vector<int> >& edges, int v, vector<vector<int> >& nodes){\n            if(num[v] != 0)\n                return;\n            num[v] = low[v] = ++ time;\n            stk.push(v);\n            isStk[v] = true;\n            for(unsigned i=0; i<edges[v].size(); ++i){\n                int w = edges[v][i];\n                visit(edges, w, nodes);\n                if(isStk[w])\n                    low[v] = min(low[v], low[w]);\n            }\n            if(low[v] == num[v]){\n                nodes.push_back(vector<int>());\n                for(;;){\n                    int w = stk.top();\n                    stk.pop();\n                    isStk[w] = false;\n                    nodes.back().push_back(w);\n                    if(v == w)\n                        break;\n                }\n            }\n        }\n    }func(n);\n\n    for(int i=0; i<n; ++i)\n        func.visit(edges1, i, nodes);\n    reverse(nodes.begin(), nodes.end()); // DAGÉ·é½ßÉ½]³¹é\n\n    const int m = nodes.size();\n    vector<int> index(n); // ³ÌOtÌe¸_ÌDAGÉ¨¯é¸_\n    for(int i=0; i<m; ++i){\n        for(unsigned j=0; j<nodes[i].size(); ++j)\n            index[nodes[i][j]] = i;\n    }\n    edges2.assign(m, vector<int>());\n    vector<vector<bool> > check(m, vector<bool>(m, false));\n    for(int i=0; i<n; ++i){\n        for(unsigned j=0; j<edges1[i].size(); ++j){\n            int v = index[i];\n            int w = index[edges1[i][j]];\n            if(v != w && !check[v][w]){\n                edges2[v].push_back(w);\n                check[v][w] = true;\n            }\n        }\n    }\n}\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\ndouble segmentPointDist(const Point& a1, const Point& a2, const Point& p)\n{\n    if((a2-a1).dot(p-a1) < 0)\n        return a1.dist(p);\n    else if((a1-a2).dot(p-a2) < 0)\n        return a2.dist(p);\n    else\n        return abs((a2-a1).cross(p-a1)) / a1.dist(a2);\n}\n\ndouble segmentsDist(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) < -EPS) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) < -EPS))\n        return 0.0;\n\n    double ret = segmentPointDist(a1, a2, b1);\n    ret = min(ret, segmentPointDist(a1, a2, b2));\n    ret = min(ret, segmentPointDist(b1, b2, a1));\n    ret = min(ret, segmentPointDist(b1, b2, a2));\n    return ret;\n}\n\nbool convexContain(const vector<Point>& cp, const Point& p)\n{\n    int n = cp.size();\n    bool ret1 = true;\n    bool ret2 = true;\n    for(int i=0; i<n; ++i){\n        double a = (cp[(i+1)%n] - cp[i]).cross(p - cp[i]);\n        if(a < -EPS)\n            ret1 = false;\n        if(a > EPS)\n            ret2 = false;\n    }\n    return ret1 || ret2;\n}\n\nbool polygonsCollide(const vector<Point>& cp1, const vector<Point>& cp2)\n{\n    int n = cp1.size();\n    int m = cp2.size();\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<m; ++j){\n            if(segmentsDist(cp1[i], cp1[(i+1)%n], cp2[j], cp2[(j+1)%m]) < 0.01 + EPS)\n                return true;\n        }\n    }\n\n    return convexContain(cp1, cp2[0]) || convexContain(cp2, cp1[0]);\n}\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Point> > p(n, vector<Point>(3));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<3; ++j){\n                cin >> p[i][j].x >> p[i][j].y;\n            }\n            if(p[i][0].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][1], p[i][2]);\n            if(p[i][1].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][0], p[i][2]);\n            if((p[i][1] - p[i][0]).cross(p[i][2] - p[i][0]) < 0)\n                swap(p[i][0], p[i][1]);\n        }\n\n        vector<vector<int> > edges(n);\n        for(int i=0; i<n; ++i){\n            Point v = p[i][1] - p[i][0];\n            v = v / v.length() * d;\n            swap(v.y, v.x);\n            v.x *= -1;\n\n            vector<Point> p1(4);\n            p1[0] = p[i][0];\n            p1[1] = p[i][0] + v;\n            p1[2] = p[i][1] + v;\n            p1[3] = p[i][1];\n\n            for(int j=0; j<n; ++j){\n                if(j == i)\n                    continue;\n                if(polygonsCollide(p1, p[j]))\n                    edges[i].push_back(j);\n            }\n        }\n\n        vector<vector<int> > nodes, edges2;\n        stronglyConnectedComponents(edges, nodes, edges2);\n\n        int m = edges2.size();\n        vector<bool> check(m, false);\n        int ret = m;\n        for(int i=0; i<m; ++i){\n            for(unsigned j=0; j<edges2[i].size(); ++j){\n                if(!check[edges2[i][j]]){\n                    check[edges2[i][j]] = true;\n                    -- ret;\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<stack>\n#include<complex>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nconst double EPS = 0.1;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool intersectSS(const L &s, const L &t) {\n\t\n\trep(i,2)rep(j,2)if(abs(abs(s[i]-t[i]))<EPS)return 1;\n\t\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) < 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) < 0;\n}\nbool intersect(G &rect, G &tri){\n\trep(i,3)if(contains(rect,tri[i]))return 1;\n\trep(i,4)if(contains(tri,rect[i]))return 1;\n\trep(i,3){\n\t\tL l(tri[i],tri[(i+1)%3]);\n\t\trep(j,4)if(intersectSS(l,L(rect[i],rect[(i+1)%4])))return 1;\n\t}\n\treturn 0;\n}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight=0) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid visit(const Graph &g, int v, vector< vector<int> >& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  fr(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const Graph& g,\n    vector< vector<int> >& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint main(){\n\tint n;\n\tdouble d;\n\twhile(cin>>n>>d,n){\n\t\tvector<G> tri;\n\t\trep(i,n){\n\t\t\tdouble a,b,c,d,e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tG p; p.pb(P(a,b)); p.pb(P(c,d)); p.pb(P(e,f));\n\t\t\tif(abs(p[2]-p[0])!=abs(p[2]-p[1])){\n\t\t\t\tif(abs(p[2]-p[0])==abs(p[1]-p[0]))swap(p[2],p[0]);\n\t\t\t\telse swap(p[1],p[0]);\n\t\t\t}\n\t\t\tif(ccw(p[0],p[1],p[2])<0)swap(p[0],p[1]);\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\tGraph e(n);\n\t\t\n\t\trep(i,n)rep(j,n)if(i!=j){\n\t\t\t\n\t\t\tG &p=tri[i];\n\t\t\tP m=(p[0]+p[1])*0.5,dir=(p[2]-m)*(d/abs(p[2]-m));\n\t\t\t\n\t\t\tG rect;\n\t\t\trect.pb(p[0]); rect.pb(p[1]);\n\t\t\trect.pb(p[1]+dir); rect.pb(p[0]+dir);\n\t\t\tif(ccw(rect[0],rect[1],rect[2])<0)reverse(rect.begin(),rect.end());\n\t\t\t\n\t\t\tif(intersect(rect,tri[j]))e[i].pb(Edge(i,j));\n\t\t}\n\t\t\n\t\tvector<vector<int> > scc;\n\t\tstronglyConnectedComponents(e,scc);\n\t\tint m=scc.size(),to[100],in[100]={0},ans=0;\n\t\trep(i,m)fr(j,scc[i])to[*j]=i;\n\t\trep(i,n)fr(j,e[i])if(to[i]!=to[j->dst])\n\t\tin[to[j->dst]]++;\n\t\t\n\t\trep(i,m)if(in[i]==0)ans++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cfloat>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define EPS (1e-8)\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint ( double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n\tPoint operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n\tPoint operator * ( double a ){ return Point(x*a, y*a); }\n\tdouble abs() { return sqrt(norm());}\n\tdouble norm() { return x*x + y*y; }\n\tbool operator < ( const Point &p ) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == ( const Point &p ) const {\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs(Vector a) {return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b) {return (sqrt(norm(a - b)));}\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\ndouble eq(double a, double b)\n{\n\treturn (fabs(a - b) <= EPS);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n//3点の位置関係を求める\nint ccw( Point p0, Point p1, Point p2 ){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( norm(a) < norm(b) ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//A = p2 - p1, B = p4 - p3が交差するか\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n\n\n//多角形の中に点があるか\nbool isInside(Polygon gon, Point p ){\n\tfor ( int i = 0; i < gon.size(); i++ ){\n\t\tif ( ccw(gon[i], gon[(i+1)%gon.size()], p) == CLOCKWISE ) return (false);\n\t}\n\treturn (true);\n}\n\n//単位ベクトルを求める\nPoint unitVector(Point t){\n\tdouble u=abs(t);\n\treturn Point(t.x/u , t.y/u);\n}\n//cosθを求める\ndouble getcos(Point a , Point b){\n\treturn (dot(a,b) / (abs(a)*abs(b)));\n}\n\n//sinθを求める\ndouble getsin(Point a , Point b){\n\tdouble t=getcos(a,b);\n\treturn sqrt(1.0-t*t);\n}\n\n//点pと直線abとの距離を求める\ndouble pld(Point p , Point a , Point b){\n\treturn fabs(cross(b - a,p - a))/abs(b-a);\n}\n\n//点pと線分abとの距離を求める\ndouble psd(Point p , Point a , Point b){\n\tif( dot( b-a , p-a ) < EPS) return abs(p-a);\n\tif( dot( a-b , p-b ) < EPS) return abs(p-b);\n\treturn fabs(cross( b-a , p-a )) / abs(b-a);\n}\n\n//線分交点計算\nPoint interpointS(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint b=b2-b1;\n\tdouble d1=fabs(cross(b , a1-b1));\n\tdouble d2=fabs(cross(b , a2-b1));\n\tdouble t=d1 / (d1 + d2);\n\tPoint a=a2-a1;\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線交点計算\nPoint interpointL(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint a=a2-a1;\n\tPoint b=b2-b1;\n\tdouble t=cross(b , b1-a1) / cross(b , a);\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線abと円及び球 |x-c|=rの交点を求める 　球の場合は型Point→Sに変更するだけ\nvoid interpointLC(Point a , Point b , Point c , double r , Point ans[]){\n\tif(pld(c , a , b) > r + EPS) return;\n\tPoint v=unitVector(b-a);\n\tdouble delta=dot(v,a-c)*dot(v,a-c)-abs(a-c)*abs(a-c)+r*r;\n\tdouble t=-dot(v,a-c);\n\tdouble s=sqrt(delta);\n\tans[0]=a+v*(t+s);\n\tans[1]=a+v*(t-s);\n}\n\n//１次変換集\n\n//ｘ（y=k）に関する対象変換 　k=0でｘ軸による変換\nPoint xTranslate(Point t,double k){\n\treturn Point(t.x , 2*k-t.y);\n}\n\n//ｙ(x=k)に関する対象変換\tk=0でｙ軸による変換\nPoint yTranslate(Point t,double k){\n\treturn Point(2*k-t.x , t.y);\n}\n\n//点Point kに関する対象変換\t\tPoint(0,0)で原点による変換\nPoint oTranslate(Point t,Point k){\n\treturn k+(k-t);\n}\n\n\n\n\n\n//点pを中心としてr(radian)回転\t\tp(0,0)で原点を中心として回転\nPoint rotate(Point t , Point p , double r){\n\t//double r=radians(angle);\n\tdouble ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n\tdouble tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n\treturn Point(ta , tb);\n}\n\n//応用\n//２円 |x-a|=raと|x-b|=rbの交点計算\nvoid interpointCC(Point a , double ra , Point b , double rb , Point ans[]){\n\tdouble di=fabs(abs(a-b));\n\tif(di > ra+rb || di < fabs(ra-rb)) return;\n\tdouble t=(ra*ra-rb*rb+di*di)/(di+di);\n\tdouble rd=acos(t/ra);\n\n\tPoint dv=unitVector(b-a);\n\tPoint g1=rotate(dv , Point(0,0) , rd);\n\tPoint g2=rotate(dv , Point(0,0) , -rd);\n\tans[0]=a+g1*ra;\n\tans[1]=a+g2*ra;\n}\n\n//法線ベクトルを求める\nPoint normalVector(Point p,Point a,Point b){\n\tPoint v=unitVector(b-a);\n\tv = cross(v , p-a) > 0 ?  Point(v.y,(-1)*v.x) : Point((-1)*v.y , v.x);\n\treturn v*pld(p,a,b);\n}\n\n//直線abに関する対象変換\nPoint fTranslate(Point t , Point a , Point b){\n\treturn t+normalVector(t,a,b)*2;\n}\n\n//３角形の面積を求める\ndouble area(Point a, Point b, Point c){\n\treturn fabs(cross(c-a , b-a)*0.5);\n}\n\n//多角形の面積を求める //凸包のソート済みが前提\ndouble polygonArea(Polygon t){\n\tdouble ans=0.0;\n\tfor(unsigned int i=0;i<t.size();i++)\n\t\tans+=cross(t[i] , t[(i+1)%t.size()]);\n\treturn ans/2;\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = static_cast<int>(ps.size());\n    Polygon qs(n * 2);\n    for (int i = 0; i < n; ++i) {\n      while (k > 1 && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    for (int i = n-2, t = k; i >= 0; --i) {\n      while (k > t && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    qs.resize(k-1);\n    return qs;\n}\n\nPolygon tri[100];\nint n, d;\n\nbool isIn(Polygon a, Polygon b)\n{\n\tfor (int i = 0; i < a.size(); i++) if (isInside(b, a[i])) return (true);\n\tfor (int i = 0; i < b.size(); i++) if (isInside(a, b[i])) return (true);\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tif (isIntersect(a[i], a[(i + 1) % a.size()], b[i], b[(i + 1) % b.size()])) return (true);\n\t\t}\n\t}\t\n\treturn (false);\n}\n\nbool check(Polygon a, Polygon b)\n{\n\tdouble di[3];\n\tfor (int i = 0; i < 3; i++){\n\t\tdi[i] = abs(a[i] - a[(i + 1) % 3]);\n\t}\n\t\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\tif (eq(di[i], di[j])){\n\t\t\t\tint cnt[3] = {0};\n\t\t\t\tcnt[i]++; cnt[(i + 1) % 3]++;\n\t\t\t\tcnt[j]++; cnt[(j + 1) % 3]++;\n\t\t\t\tfor (int k = 0; k < 3; k++){\n\t\t\t\t\tif (cnt[k] == 2){\n\t\t\t\t\t\tswap(a[k], a[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPolygon c;\n\tc.push_back(a[0]); c.push_back(a[1]);\n\t\n\tPoint t = Point((a[0].x + a[1].x) / 2, (a[0].y + a[1].y) / 2);\n\tPoint k = a[2] - t;\n\tc.push_back(a[0] + k * (d / abs(k))); c.push_back(a[1] + k * (d / abs(k)));\n\t\n\treturn (isIn(c, b));\n}\n\nvector<int> G[128], rG[128];\nint ord[128], gr[128];\nbool vis[128];\nint ctr;\n\nvoid addEdge(int src, int dst)\n{\n\tG[src].push_back(dst);\n\trG[dst].push_back(src);\n}\n\nvoid dfs1(int v)\n{\n\tvis[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tif (!vis[G[v][i]]) dfs1(G[v][i]);\n\t}\n\tord[ctr++] = v;\n}\n\nvoid dfs2(int v, int k)\n{\n\tvis[v] = true;\n\tgr[v] = k;\n\tfor (int i = 0; i < rG[v].size(); i++){\n\t\tif (!vis[rG[v][i]]) dfs2(rG[v][i], k);\n\t}\n\t\n}\n\nint scc()\n{\n\tmemset(vis, 0, sizeof(vis));\n\tctr = 0;\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!vis[i]){\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\tint k = 0;\n\tmemset(vis, 0, sizeof(vis));\n\tfor (int i = n - 1; i >= 0; i--){\n\t\tif (!vis[ord[i]]){\n\t\t\tdfs2(ord[i], k++);\n\t\t}\n\t}\n\t\n\tint ret = k;\n\tmemset(vis, 0, sizeof(vis));\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < G[i].size(); j++){\n\t\t\tif (gr[i] != gr[G[i][j]]){\n\t\t\t\tret -= (1 ^ vis[gr[G[i][j]]]);\n\t\t\t\tvis[gr[G[i][j]]] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (ret);\n}\n\nint main()\n{\n\tPoint t;\n\twhile (scanf(\"%d %d\", &n, &d) && n + d){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tscanf(\"%lf %lf\", &t.x, &t.y);\n\t\t\t\ttri[i].push_back(Point(t.x, t.y));\n\t\t\t}\n\t\t\tG[i].clear(); rG[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (i != j && check(tri[i], tri[j])){\n\t\t\t\t\taddEdge(i, j);\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\t\n\t\t\n\t\tprintf(\"%d\\n\", scc());\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n\nint main(){\n  int n,d;\n  int x,y;\n  int cnt = 0;\n  while(cin >> n >> d){\n    if(cnt>=13)cerr << n << \" \" << d << endl;\n    assert(n+d>0);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tcin >> x >> y;\n\tif(cnt>=13)cerr << x << \" \" << y << ((j==2)?'\\n':' ');\n      }\n    }\n    cnt++;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst double EPS = 0.01;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n//????????´???????£???????????????????(??????????????£???????????????)\nenum{NO_HIT=0, HIT, A_IN_B, B_IN_A};\nint HitPol_Pol(const polygon& a, const polygon& b){\n\tbool f = true, hit = false;\n\trep(i, a.size()){\n\t\tif(!contains(b, a[i])) f = false;\n\t\telse hit = true;\n\t}\n\tif(f) return A_IN_B;\n\tf = true;\n\trep(i, b.size()){\n\t\tif(!contains(a, b[i])) f = false;\n\t\telse hit = true;\n\t}\n\tif(f) return B_IN_A;\n\tif(hit) return HIT;\n\trep(i, a.size()) rep(j, b.size()){\n\t\tL la(curr(a, i), next(a, i)), lb(curr(b, j), next(b, j));\n\t\tif(intersectSS(la, lb)) return HIT;\n\t}\n\treturn NO_HIT;\n}\n//point???theta???????????¢\npoint spinP(const point& p, double theta){\n\treturn p*complex<double>(cos(theta),sin(theta));\n}\npoint spinPExtend(const point& p, double theta, double rate){\n\treturn p*complex<double>(rate*cos(theta),rate*sin(theta));\n}\n\nstruct SCC{//O(V+E)\n    static const int MAX_V = 1010;\n    int V;\n    vector<int> G[MAX_V], rG[MAX_V];\n    vector<int> vs;\n    bool used[MAX_V];\n    int cmp[MAX_V];\n    vector<vector<int> > res;\n \n \n    SCC(int v) : V(v){};\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n \n    void dfs(int v){\n        used[v] = true;\n        for(int i = 0; i < G[v].size(); i++){\n            if(!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v] = true;\n        cmp[v] = k;\n        for(int i = 0; i < rG[v].size(); i++){\n            if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n \n    int scc(){\n        memset(used, 0, sizeof(used));\n        vs.clear();\n        for(int v = 0; v < V; v++){\n            if(!used[v]) dfs(v);\n        }\n        memset(used, 0, sizeof(used));\n        int k = 0;\n        for(int i = vs.size() - 1; i >= 0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++);\n        }\n \n        res.clear();\n        res.resize(k);\n        for(int i = 0; i < V; i++){\n            res[cmp[i]].push_back(i);\n        }\n        return k;\n    }\n};\n\nint main(){\n\tint n, d;\n\twhile(cin >> n >> d && (n+d)){\n\t\tvector<polygon> tri(n);\n\t\trep(i, n){\n\t\t\tdouble x, y;\n\t\t\trep(j, 3){\n\t\t\t\tcin >> x >> y;\n\t\t\t\ttri[i].pb({x, y});\n\t\t\t}\n\t\t}\n\t\tvector<polygon> pol(n);\n\t\trep(i, n){\n\t\t\tdouble dist[3];\n\t\t\trep(j, 3){\n\t\t\t\tdist[j] = abs(curr(tri[i], j)-next(tri[i], j));\n\t\t\t}\n\t\t\trep(j, 3) {\n\t\t\t\tif(abs(dist[j] - dist[(j+1)%3])<1e-8){\n\t\t\t\t\tpol[i].pb(tri[i][j]);\n\t\t\t\t\tpol[i].pb(tri[i][(j+2)%3]);\n\t\t\t\t\tpol[i].pb(spinPExtend(pol[i][0]-pol[i][1], (ccw(pol[i][1], pol[i][0], tri[i][(j+1)%3])> 0)?PI/2:-PI/2, d/abs(pol[i][1]-pol[i][0]))+pol[i][1]);\n\t\t\t\t\tpol[i].pb(pol[i][2]+pol[i][0]-pol[i][1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSCC scc(n);\n\t\trep(i, n) rep(j, i){\n\t\t\tif(HitPol_Pol(pol[i], tri[j])>0) scc.add_edge(i, j);\n\t\t\tif(HitPol_Pol(tri[i], pol[j])>0) scc.add_edge(j, i);\n\t\t}\n\t\tscc.scc();\n\t\tvector<int> f(scc.res.size(), 1);\n\t\trep(i, n) rep(j, i){\n\t\t\tassert(scc.cmp[i]<f.size());\n\t\t\tassert(scc.cmp[j]<f.size());\n\t\t\tif(scc.cmp[i] == scc.cmp[j]) continue;\n\t\t\tif(HitPol_Pol(pol[i], tri[j])!=NO_HIT) f[scc.cmp[j]] = 0;\n\t\t\telse if(HitPol_Pol(tri[i], pol[j])!=NO_HIT) f[scc.cmp[i]] = 0;\n\t\t}\n\t\tcout<<accumulate(all(f), 0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n        ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    d+=0.000001;\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-2)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) + SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G &a, G &b)\n{\t\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a.size(); i++){\n\t\tif (contains(b, a[i])){\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int i = 0; i < b.size(); i++){\n\t\tif (contains(a, b[i])){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tvector<int> toi(V);\n\tfor (int i = 0; i < V; i++){\n\t\ttoi[tps[i]] = i;\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tint v = tps[i];\n\t\tif (!used[v]) res++;\n\t\tfor (int to : sccgraph[v]){\n\t\t\tused[toi[to]] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-1;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<-eps ) && //-EPS\n        ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <-eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-3;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < 1e-10){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      break;\n    }\n  }while(next_permutation(in,in+3));\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS = 1e-9, INF = 1e12, PI = acos(-1.0);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  G ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n#include<stack>\nvoid visit(const vector<vi> &g, int v, vector<vi>& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  each(e, g[v]) {\n    int w = *e;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const vector<vi>& g,\n    vector<vi>& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint n, d;\nvector<vi> g;\n\nint main(){\n\twhile(cin >> n >> d, n || d){\n\t\tg.clear(); g.resize(n);\n\t\tvector<G> tri;\n\t\trep(i, n){\n\t\t\tint t = -1;\n\t\t\tG p(3);\n\t\t\tdouble l[3];\n\t\t\trep(j, 3) cin >> p[j].real() >> p[j].imag();\n\t\t\trep(j, 3) l[j] = abs(p[j] - p[(j + 1) % 3]);\n\t\t\trep(j, 3) if(abs(l[j] - l[(j + 1) % 3]) < EPS){\n\t\t\t\tt = (j + 1) % 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tassert(t >= 0);\n\t\t\tif(t) swap(p[t], p[(t + 1) % 3]);\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\trep(i, n){\n\t\t\tG &p = tri[i];\n\t\t\tP dir = p[0] - (p[1] + p[2]) * 0.5;\n\t\t\tdir *= d / abs(dir);\n\t\t\t\n\t\t\tG ps;\n\t\t\tps.pb(p[1]); ps.pb(p[2]);\n\t\t\tps.pb(p[1] + dir); ps.pb(p[2] + dir);\n\t\t\tps = convex_hull(ps);\n\t\t\t\n\t\t\trep(j, n){\n\t\t\t\tbool ok = 0;\n\t\t\t\trep(k, 3){\n\t\t\t\t\trep(l, 4) if(distanceSP(L(ps[l], ps[(l + 1) % 4]), tri[j][k])\n\t\t\t\t\t\t< 0.01) ok = 1;\n\t\t\t\t\tif(contains(ps, tri[j][k]) != OUT) ok = 1;\n\t\t\t\t}\n\t\t\t\tif(ok) g[i].pb(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tmap<int, int> to;\n\t\tvector<vi> scc;\n\t\tstronglyConnectedComponents(g, scc);\n\t\tint m = scc.size();\n\t\tvi in(m);\n\t\t\n\t\trep(i, m) rep(j, scc[i].size()){\n\t\t\tto[scc[i][j]] = i;\n\t\t}\n\t\trep(i, n) rep(j, g[i].size()){\n\t\t\tint a = to[i], b = to[g[i][j]];\n\t\t\tif(a != b) in[b]++;\n\t\t}\n\t\trep(i, m) if(in[i] == 0) ans++;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-8, AD = 1e-2;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0){\n\t    swap(rect[i][0],rect[i][1]); break;\n\t  }\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k])){\n\t    f = true; break;\n\t  }\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3)if(seg_p_dis(rseg,tri[j][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int edges[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])edges[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!edges[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n        ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      /*\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n      */\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }else if (is_intersected_polygon(tri[i],tri[j])){\n\tassert(false);\n      }\n\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    d+=0.0001;\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-8, AD = 1e-2;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nD area(P a,P b,P c){\n  return abs(cross(a,b)+cross(b,c)+cross(c,a));\n}\n\nbool inter_pos(Poly p,P x,D A){\n  D a = 0; int s = p.size();\n  rep(i,n)a += area(p[i],p[(i+1)%s],x);\n  return (a==A);\n}\n\n/*\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n*/\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0){\n\t    swap(rect[i][0],rect[i][1]); break;\n\t  }\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k],abs(rect[i][0]-rect[i][1])*d)){\n\t    f = true; break;\n\t  }\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3)if(seg_p_dis(rseg,tri[j][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,3){\n\t    L tseg = L(tri[j][k],rect[j][(k+1)%3]);\n\t    rep(l,4)if(seg_p_dis(tseg,rect[i][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    // if (abs(a-b)<EPS) return 0;\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L() {}\n};\ntypedef vector<P> G;\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSS2(const L &s, const L &t) { // 接しているやつは交差と考えない\n  REP(i, 2) {\n    if (ccw(s[0], s[1], t[i]) == 0) {\n      int c = ccw(s[0],s[1],t[!i]);\n      if (s[0] == t[i]) {\n        if (c!=-2&&c) return 0;\n      } else if (s[1] == t[i]) {\n        if (c!=2&&c) return 0;\n      } else if (abs(c)==1) return 0;\n    }\n  }\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + P(2,0) * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\nbool convex_contain(const G &g, const P &p) { // 半時計回りを仮定\n  REP(i,g.size())\n    if (ccw(g[i], next(g, i), p) == -1 && distanceSP(L(g[i],next(g,i)), p) > 0.01) return 0;\n  return 1;\n}\n\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nbool intersectGG(const G &g1, const G &g2) {\n  if (convex_contain(g1, g2[0])) return 1;\n  if (convex_contain(g2, g1[0])) return 1;\n  REP(i,g1.size()) REP(j,g2.size()) {\n    if (distanceSS(L(g1[i], next(g1, i)), L(g2[j], next(g2, j))) <= 0.01) return 1;\n  }\n  return 0;\n}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid visit(const Graph &g, int v, vector< vector<int> >& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  FOR(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const Graph& g,\n    vector< vector<int> >& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  REP(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\n// 強連結成分を縮約する\nGraph edgeContractionAndSort(const Graph &g) {\n  int n = g.size();\n  vector<vector<int> > scc;\n  stronglyConnectedComponents(g, scc);\n  int m = scc.size();\n  vector<int> cmp(n);\n  REP(i,m) FOR(jt, scc[i])\n    cmp[*jt] = i;\n  map<pii, bool> mp;\n  Graph res(m);\n  REP(i,n) {\n    int a = cmp[i];\n    FOR(it,g[i]) {\n      int b = cmp[it->dst];\n      if (a != b) {\n        if (mp.count(pii(a,b)) == 0) {\n          mp[pii(a,b)] = 1;\n          res[a].push_back(Edge(a,b,1));\n        }\n      }\n    }\n  }\n  return res;\n}\n\n\nG triangle[100];\nint deg[100];\n\nint main() {\n  int n, d;\n  while(cin>>n>>d,n||d) {\n    REP(i,n) {\n      triangle[i].clear();\n      REP(j,3) {\n        P p; cin >> p.real() >> p.imag();\n        triangle[i].push_back(p);\n      }\n      if (abs(abs(triangle[i][0]-triangle[i][1]) - abs(triangle[i][0]-triangle[i][2])) < EPS) {\n        swap(triangle[i][0], triangle[i][2]);\n      }\n      if (abs(abs(triangle[i][1]-triangle[i][0]) - abs(triangle[i][1]-triangle[i][2])) < EPS) {\n        swap(triangle[i][1], triangle[i][2]);\n      }\n      if (cross(triangle[i][1]-triangle[i][0], triangle[i][2]-triangle[i][0]) < 0) {\n        swap(triangle[i][0], triangle[i][1]);\n      }\n      // REP(j,3) cout << triangle[i][j] << \" \";\n      // cout << endl;\n    }\n    Graph g(n);\n    REP(i,n) {\n      G rect;\n      P p = triangle[i][1] - triangle[i][0];\n      p /= abs(p);\n      p *= P(0,1);\n      p *= d;\n      rect.push_back(triangle[i][0]);\n      rect.push_back(triangle[i][1]);\n      rect.push_back(triangle[i][1] + p);\n      rect.push_back(triangle[i][0] + p);\n      REP(j,n) {\n        if (i == j) continue;\n        if (intersectGG(rect, triangle[j])) {\n          //cout << i << \" \" << j << endl;\n          g[i].push_back(Edge(i,j,0));\n        }\n      }\n    }\n    Graph g2 = edgeContractionAndSort(g);\n    memset(deg,0,sizeof(deg));\n    FOR(it, g2) {\n      FOR(e, *it) {\n        deg[e->dst]++;\n      }\n    }\n    int ans = 0;\n    REP(i,g2.size()) {\n      if (deg[i] == 0) ans++;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 200;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-7\n;\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      //if (     cross(a[in[0]]-a[in[1]],a[in[2]]-a[in[1]]) >=0)\n      //\tassert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])>=0);\n      //      else assert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])<=0);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  //assert(false);\n  return ret;\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<-eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <-eps))return true;\n  else return false;\n}\n\n#define DSS distance_ls_p\ndouble distance_ss_p(P a,P b,P c,P d){\n  return min(  min( DSS(a,b,c),DSS(a,b,d)),min(DSS(c,d,a),DSS(c,d,b)));\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri,double d){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }else {\n\trep(k,tri[j].size()){\n\t  if (is_in(tri[i],tri[j][k])&&\n\t      (distance_ss_p(sq[i][0],sq[i][1],tri[j][0],tri[j][1])<d+eps ||\n\t       distance_ss_p(sq[i][0],sq[i][1],tri[j][1],tri[j][2])<d+eps||\n\t       distance_ss_p(sq[i][0],sq[i][1],tri[j][2],tri[j][0])<d+eps)\n\t      ){\n\t    assert(false);\n\t    inedge[i].pb(j);\n\t    redge[j].pb(i);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in,d);\n\n\n    //rep(i,n){rep(j,sq[i].size())cout<< sq[i][j];cout << endl;}\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-1;\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      //if (     cross(a[in[0]]-a[in[1]],a[in[2]]-a[in[1]]) >=0)\n      //\tassert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])>=0);\n      //      else assert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])<=0);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  //assert(false);\n  return ret;\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<-eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <-eps))return true;\n  else return false;\n}\n\n#define DSS distance_ls_p\ndouble distance_ss_p(P a,P b,P c,P d){\n  return min(  min( DSS(a,b,c),DSS(a,b,d)),min(DSS(c,d,a),DSS(c,d,b)));\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri,double d){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }else {\n\trep(k,tri[j].size()){\n\t  if (is_in(tri[i],tri[j][k])&&\n\t      (distance_ss_p(sq[i][0],sq[i][1],tri[j][0],tri[j][1])<d+eps ||\n\t       distance_ss_p(sq[i][0],sq[i][1],tri[j][1],tri[j][2])<d+eps||\n\t       distance_ss_p(sq[i][0],sq[i][1],tri[j][2],tri[j][0])<d+eps)\n\t      ){\n\t    assert(false);\n\t    inedge[i].pb(j);\n\t    redge[j].pb(i);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in,d);\n\n\n    //rep(i,n){rep(j,sq[i].size())cout<< sq[i][j];cout << endl;}\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n        ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    d+=0.0001;\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n\nint main(){\n  int n,d;\n  int x,y;\n  while(cin >> n >> d){\n    cerr << n << \" \" << d << endl;\n    assert(n+d>0);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tcin >> x >> y;\n\tcerr << x << \" \" << y << ((j==2)?'\\n':' ');\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-2;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nint g[110][110];\nPt p[110][3];\nint UF[110];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[i][i]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble ax,bx,cx,ay,by,cy;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n\t\t\tdouble A=(bx-cx)*(bx-cx)+(by-cy)*(by-cy);\n\t\t\tdouble B=(ax-cx)*(ax-cx)+(ay-cy)*(ay-cy);\n\t\t\tdouble C=(ax-bx)*(ax-bx)+(ay-by)*(ay-by);\n\t\t\tif(ABS(A-B)<EPS){\n\t\t\t\tp[i][0]=Pt(ax,ay);p[i][1]=Pt(bx,by);p[i][2]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(B-C)<EPS){\n\t\t\t\tp[i][2]=Pt(ax,ay);p[i][0]=Pt(bx,by);p[i][1]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(C-A)<EPS){\n\t\t\t\tp[i][1]=Pt(ax,ay);p[i][2]=Pt(bx,by);p[i][0]=Pt(cx,cy);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)if(iSP(p[i][0],p[i][2],p[i][1])==-1)swap(p[i][0],p[i][1]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tif(i==j)continue;\n\t\t\tPt t[4];\n\t\t\tt[0]=p[i][0];\n\t\t\tt[1]=p[i][1];\n\t\t\tt[3]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[3]=t[0]+t[3]/t[3].ABS()*(double)b;\n\t\t\tt[2]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[2]=t[1]+t[2]/t[2].ABS()*(double)b;\n\t\t\n\t\t\tbool ok=false;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tbool L=false;\n\t\t\t\tbool R=false;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][k]+(p[j][(k+1)%3]-p[j][k])*1000000.0))L=true;\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][(k+1)%3],p[j][(k+1)%3]+(p[j][k]-p[j][(k+1)%3])*1000000.0))R=true;\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][(k+1)%3]))ok=true;\n\t\t\t\t}\n\t\t\t\tif(L&&R)ok=true;\n\t\t\t}\n\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\tbool L=false;\n\t\t\t\tbool R=false;\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tif(iSS(t[l],t[l]+(t[(l+1)%4]-t[l])*1000000.0,p[j][k],p[j][(k+1)%3]))L=true;\n\t\t\t\t\tif(iSS(t[(l+1)%4],t[(l+1)%4]+(t[l]-t[(l+1)%4])*1000000.0,p[j][k],p[j][(k+1)%3]))R=true;\n\t\t\t\t}\n\t\t\t\tif(L&&R)ok=true;\n\t\t\t}\n\t\t\t\n\t\t\tif(ok){\n\t\t\t\tg[i][j]=1;\n\t\t//\t\tprintf(\"%d %d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]|=g[i][k]&g[k][j];\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)if(g[i][j]&&g[j][i])UNION(i,j);\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(FIND(i)!=FIND(j)&&g[j][i])ok=false;\n\t\t\t}\n\t\t\tif(ok)ret++;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-1;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[2])>eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    bool c[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<-eps;\n\t      c[j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    c[j]|=!f;\n\t  }\n\t}\n      }\n    }\n    cout<<max<int>(1,count(c,c+n,false))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\n#define MAX_N (128)\n#define EPS (1e-5)\n#define SQ(X) ((X) * (X))\n#define EQ(a, b) (fabs(a - b) <= EPS)\n#define D1 (-1)\n#define D2 (1)\n#define ONLINE (0)\n\nusing namespace std;\n\nclass Triangle {\n\tpublic:\n        double x[3], y[3];\n\t    int no;\n};\n\nclass Point {\n    public:\n    \tdouble x, y;\n        \n\t    Point operator - (Point &a){\n            Point ret;\n\t\t    ret.x = x - a.x;\n\t\t    ret.y = y - a.y;\n\t\t    return (ret);\n\t    }\n};\n\nvector<int> G[MAX_N];\nvector<int> rG[MAX_N];\nvector<int> compress[MAX_N];\nvector<int> vs;\nbool used[MAX_N];\nbool group[MAX_N];\nint cmp[MAX_N];\nint N;\n\nvoid addEdge(int from, int to)\n{\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v)\n{\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++){\n        if (!used[G[v][i]]){\n            dfs(G[v][i]);\n        }\n    }\n    vs.push_back(v);\n}\n\nvoid revDfs(int v, int k)\n{\n    used[v] = true;\n    cmp[v] = k;\n    for (int i = 0; i < rG[v].size(); i++){\n        if (!used[rG[v][i]]){\n            revDfs(rG[v][i], k);\n        }\n    }\n}\n\nint scc()\n{\n    int ret;\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    \n    for (int i = 0; i < N; i++){\n        if (!used[i]){\n            dfs(i);\n        }\n    }\n    \n    memset(used, 0, sizeof(used));\n    \n    ret = 0;\n    for (int i = vs.size() - 1; i >= 0; i--){\n        if (!used[vs[i]]){\n            revDfs(vs[i], ret++);\n        }\n    }\n    \n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < G[i].size(); j++){\n            if (cmp[i] != cmp[G[i][j]]){\n                compress[cmp[G[i][j]]].push_back(cmp[i]);\n            }\n        }\n    }\n    \n    return (ret);\n}\n\ndouble inProduct(Point a, Point b)\n{\n\treturn (a.x * b.x + a.y * b.y);\n}\n\ndouble getSize(Point a)\n{\n\treturn (sqrt(SQ(a.x) + SQ(a.y)));\n}\n\nint checkCross(Point p1, Point p2, Point p3)\n{\n    Point vecA = p2 - p1, vecB = p3 - p1;\n    double D = vecA.x * vecB.y - vecB.x * vecA.y;\n    if (EQ(0, D)){\n        return (ONLINE);\n    }\n    else if (D > 0){\n        return (D1);\n    }\n    return (D2);\n}\n\nvoid judgeAdj(Triangle a, Triangle b, double dist)\n{\n\tdouble len;\n\tPoint p[4];\n\t\n\tlen = 0.0;\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\tif (len < SQ(a.x[i] - a.x[j]) + SQ(a.y[i] - a.y[j])){\n\t\t\t\tlen = SQ(a.x[i] - a.x[j]) + SQ(a.y[i] - a.y[j]);\n\t\t\t\tp[0].x = a.x[i], p[0].y = a.y[i];\n\t\t\t\tp[1].x = a.x[j], p[1].y = a.y[j];\n\t\t\t}\n\t\t}\n\t}\n    //printf(\"%lf %lf %lf %lf\\n\", p[0].x, p[0].y, p[1].x, p[1].y);\n\tPoint e, sa;\n\t\n    e.x = 0, e.y = 1;\n\tsa = p[0] - p[1];\n\tdouble theta = acos(inProduct(e, sa) / (getSize(e) * getSize(sa)));\n    if (fabs(theta - M_PI) < EPS){\n        theta = 0;\n    }\n\t//printf(\"theta = %lf\\n\", theta);\n    \n\tp[2].x = p[0].x + dist * cos(theta), p[2].y = p[0].y + dist * sin(theta);\n\tp[3].x = p[1].x + dist * cos(theta), p[3].y = p[1].y + dist * sin(theta);\n\t\n\tbool cross = false;\n\t\n    for (int i = 0; i < 3; i++){\n        bool judge = true;\n        Point k;\n        k.x = b.x[i], k.y = b.y[i];\n    \tjudge &= (checkCross(p[0], p[1], k) * checkCross(p[2], p[3], k) <= 0);\n\t    judge &= (checkCross(p[0], p[2], k) * checkCross(p[1], p[3], k) <= 0);\n        cross |= judge;\n    }\n    \n\tif (cross == true){\n        //printf(\"hoge, %d, %d\\n\", a.no, b.no);\n\t\taddEdge(a.no, b.no);\n\t}\n\t\n}\n\nint main()\n{\n\tint n, d;\n\tTriangle data[128];\n\t\n\twhile (1){\n\t\t\n\t\tscanf(\"%d%d\", &n, &d);\n\t\t\n        N = n;\n\t\tif (n + d == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tdata[i].no = i;\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tscanf(\"%lf%lf\", &data[i].x[j], &data[i].y[j]);\n\t\t\t}\n\t\t}\n\t\t\n        for (int i = 0; i < n; i++){\n            G[i].clear();\n            rG[i].clear();\n            compress[i].clear();\n        }\n        \n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n                if (i != j){\n    \t\t\t\tjudgeAdj(data[i], data[j], d);\n                }\n\t\t\t}\n\t\t}\n\t\t\n\t\tint k = scc();\n    \t\n    \tint ans = 0;\n    \tmemset(used, 0, sizeof(used));\n    \t\n    \tfor (int i = 0; i < k; i++){\n        \tif (compress[i].size() == 0){\n        \t    ans++;\n        \t}\n    \t}\n    \t\n    \tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-10;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < 1e-10){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      break;\n    }\n  }while(next_permutation(in,in+3));\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\n\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\nbool ccwtest(Point p,Point q,Point r){ return cross3p(p,q,r) > 0; }\nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble angle(Point a,Point b,Point c) {\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p){\n  if((int)poly.size() == 0)return false;\n  rep(i,poly.size()) if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++) {\n    if( equals(cross(poly[i]-p,poly[(i+1)%poly.size()]-p),0.0) ) continue; // ３点が平行だとangleがnanを返しsumがnanになり死ぬ\n    if( cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0 ) sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n    else                                                 sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n  }\n  const double eps = 1e-5;\n  return (fabs(sum - 2*M_PI) < eps || fabs(sum + 2*M_PI) < eps);\n}  \n\n\nconst int MAX_V = 200;\nint V,cmp[MAX_V];\ndouble d;\nPoint ps[MAX_V][3];\nvector<Polygon> poly;\nvector<int> G[MAX_V],rG[MAX_V],vs;\nbool used[MAX_V];\n\nvoid add_edge(int s,int t){\n  G[s].push_back(t);\n  rG[t].push_back(s);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++) if( !used[G[v][i]] ) dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i=0;i<rG[v].size();i++) if( !used[rG[v][i]] ) rdfs(rG[v][i],k);\n}\n\nint scc(){\n  rep(i,V) used[i] = false;\n  vs.clear();\n  rep(v,V) if( !used[v] ) dfs(v);\n  rep(i,V) used[i] = false;\n  int k = 0;\n  for(int i=(int)vs.size()-1;i>=0;i--) if( !used[vs[i]] ) rdfs(vs[i],k++);\n  return k;\n}\n\n\nbool check(int a,int b) {\n  rep(i,(int)poly[a].size()) {\n    Segment seg1 = Segment(poly[a][i],poly[a][(i+1)%poly[a].size()]);\n    rep(j,3){\n      Segment seg2 = Segment(ps[b][j],ps[b][(j+1)%3]);\n      if( equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) ) {\n        if( onSegment(seg1.p1,seg1.p2,seg2.p1) || onSegment(seg1.p1,seg1.p2,seg2.p2) ||\n            onSegment(seg2.p1,seg2.p2,seg1.p1) || onSegment(seg2.p1,seg2.p2,seg1.p2) ) return true;\n      } else if( intersectSS(seg1,seg2) ) return true;\n    }\n  }\n  rep(i,3) if( inPolygon(poly[a],ps[b][i]) ) return true;\n  return false;\n}\n\nvoid converter(int index){\n  Polygon temp;\n  rep(i,3) {\n    double dist[2] = {abs(ps[index][(i+1)%3]-ps[index][(i+2)%3]),\n                      abs(ps[index][(i+2)%3]-ps[index][i])};\n    if( equals(dist[0],dist[1]) ) {\n      Point p = projection(Line(ps[index][i],ps[index][(i+1)%3]),ps[index][(i+2)%3]);\n      Point e = ( ps[index][(i+2)%3] - p ) / abs( ps[index][(i+2)%3] - p );\n      temp.push_back(ps[index][i]);\n      temp.push_back(ps[index][(i+1)%3]);\n      temp.push_back(ps[index][(i+1)%3] + e * d);\n      temp.push_back(ps[index][i] + e * d);\n      break;\n    }\n  }\n  assert( !temp.empty() );\n  poly.push_back(temp);\n}\n\nint nV;\nstruct Edge { int to; };\n\nvoid draw(vector<vector<Edge> > &nG,int cur){ \n  rep(i,(int)nG[cur].size()){\n    if( !used[nG[cur][i].to] ) {\n      used[nG[cur][i].to] = true;\n      draw(nG,nG[cur][i].to);\n    }\n  }\n}\n\ntemplate<typename T>\nbool visit(const T& G,int v,vector<int>& order,vector<int>& color){\n  color[v] = 1;\n  for(__typeof((G[v]).begin()) e = G[v].begin();e != G[v].end();e++){\n      if(color[e->to] == 2)continue;//このvisit以外のvisitで訪れた\n      if(color[e->to] == 1)return false;//このvisitで訪れた\n      if(!visit(G,e->to,order,color))return false;\n    }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\ntemplate<typename T>\nbool topologicalSort(const T& G,vector<int>& order){\n  int SizeG = G.size();\n  vector<int> color(SizeG); \n  for(int u=0;u<SizeG;u++) if(!color[u] && !visit(G,u,order,color)) return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\n\nvoid compute(){\n  poly.clear(), vs.clear();\n  rep(i,V) G[i].clear(), rG[i].clear(), used[i] = false;\n  \n  rep(i,V) converter(i);\n\n  rep(i,V) rep(j,V) if( i != j && check(i,j) ) add_edge(i,j);\n\n  nV = scc();\n\n  vector<vector<Edge> > nG(nV,vector<Edge>());\n  rep(i,V) rep(j,(int)G[i].size()) {\n    if( cmp[i] == cmp[G[i][j]] ) continue;\n    nG[cmp[i]].push_back((Edge){cmp[G[i][j]]});\n  }\n\n  vector<int> order;\n  assert( topologicalSort(nG,order) );\n  memset(used,false,sizeof(used));\n  int answer = 0;\n  \n  rep(i,nV) if( !used[order[i]] ){\n    used[order[i]] = true;\n    ++answer;\n    draw(nG,order[i]);\n  }\n  cout << answer << endl;\n}\n\nint main(){\n  while( cin >> V >> d, (V|(int)d) ){\n    rep(i,V) rep(j,3) cin >> ps[i][j].x >> ps[i][j].y;\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,edge[i].size()){\n      int you=component[edge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-10;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      break;\n    }\n  }while(next_permutation(in,in+3));\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[i].pb(j);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<unordered_map>\n#define eps 1e-9\nusing namespace std;\n\ntypedef complex<double> point;\ntypedef pair<point, point> pp;\n\n//??????\ndouble dot(point a, point b){\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\n//??????\ndouble cross(point a, point b){\n  return imag(conj(a) * b);\n}\n\n//counter clock wise\nint ccw(point a, point b, point c){\n  if(cross(b - a, c - a) >  eps)return  1;//??????ab????????´\n  if(cross(b - a, c - a) < -eps)return -1;//??????ab????????´\n  if(dot(b - a, c - a) < -eps)return 2;//??´???ab??????a???????????????\n  if(abs(b - a) + eps < abs(c - a))return -2;//??´???ab??????b???????????????\n  return 0;//??´???ab???\n}\ntypedef struct door{\n  double r;\n  point x, y, z, a, b;\n  point rot(point p, double theta){\n    return point(p.real()*cos(theta) +\n                 p.imag()*sin(theta),\n                 -p.real()*sin(theta) +\n                 p.imag()*cos(theta));\n  }\n  void rectangle(){\n    point p = y - x;\n    if(ccw(x, y, z) == -1){\n      p = rot(p, M_PI/2.0);\n    }else if(ccw(x, y, z) == 1){\n      p = rot(p, -M_PI/2.0);\n    }\n    p *= r/abs(p);\n    a = y;\n    b = x + p;\n  }\n}door;\n\nbool isCover(door from, door to){\n  point p[4];\n  p[0] = from.x;\n  p[1] = from.y;\n  p[2] = from.y + (from.b - from.x);\n  p[3] = from.b;\n\n  int f = ccw(p[0], p[1], to.x);\n  bool flag = true;\n  for (int i = 1; i < 4; i++) {\n    if(ccw(p[i], p[(i + 1)%4], to.x) != f and\n       ccw(p[i], p[(i + 1)%4], to.x) != 0)\n      flag = false;\n  }\n  if(flag)return true;\n  f = ccw(p[0], p[1], to.y);\n  for (int i = 1; i < 4; i++) {\n    if(ccw(p[i], p[(i + 1)%4], to.y) != f and\n       ccw(p[i], p[(i + 1)%4], to.y) != 0)\n      return false;\n  }\n  return true;\n}\n\nvoid dfs(vector<vector<int> > &g,\n         vector<int> &vs, int v, bool* used){\n  used[v] = true;\n  for (int i = 0; i < g[v].size(); i++) {\n    if(not used[g[v][i]])dfs(g, vs, g[v][i], used);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(vector<vector<int> > &rg,\n          vector<int> &cmp, int v, int k, bool* used){\n  used[v] = true;\n  cmp[v] = k;\n  for (int i = 0; i < rg[v].size(); i++) {\n    if(not used[rg[v][i]])\n      rdfs(rg, cmp, rg[v][i], k, used);\n  }\n}\n\nvector<vector<int> > scc(vector<vector<int> > &g,\n                         vector<vector<int> > &rg){\n  bool used[g.size()];\n  memset(used, false, sizeof(used));\n  vector<int> vs, cmp(g.size(), -1);\n  for (int i = 0; i < g.size(); i++) {\n    if(not used[i])dfs(g, vs, i, used);\n  }\n  memset(used, false, sizeof(used));\n  int k = 0;\n  for (int i = vs.size() -  1; i >= 0; i--) {\n    if(not used[vs[i]]) rdfs(rg, cmp, vs[i], k++, used);\n  }\n  unordered_map<int, int> hash;\n  for (int i = 0; i < cmp.size(); i++) {\n    hash[i] = cmp[i];\n  }\n  vector<vector<int> > res(hash.size());\n  for (int i = 0; i < g.size(); i++) {\n    for (int j = 0; j < g[i].size(); j++) {\n      res[hash[i]].push_back(hash[g[i][j]]);\n    }\n  }\n  // for (int i = 0; i < res.size(); i++) {\n  //   std::cout << \"res[\" << i << \"]:\" << std::endl;\n  //   for (int j = 0; j < res[i].size(); j++) {\n  //     std::cout << res[i][j] << std::endl;\n  //   }\n  // }\n  return res;\n}\n\nint main(){\n  int n, r;\n  while(std::cin >> n >> r, n){\n    door d[n];\n    for (int i = 0; i < n; i++) {\n      int a, b;\n      std::cin >> a >> b;\n      d[i].x = point(a, b);\n    \n      std::cin >> a >> b;\n      d[i].y = point(a, b);\n    \n      std::cin >> a >> b;\n      d[i].z = point(a, b);\n      d[i].r = r;\n      d[i].rectangle();\n    }\n    vector<vector<int> > g(n), rg(n);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if(isCover(d[i], d[j])){\n          g[i].push_back(j);\n        }\n      }\n    }\n    for (int i = 0; i < g.size(); i++) {\n      for (int j = 0; j < g[i].size(); j++) {\n        rg[g[i][j]].push_back(i);\n      }\n    }\n    vector<vector<int> > dag = scc(g, rg);\n    int ans = 0;\n    for (int i = 0; i < dag.size(); i++) {\n      if(dag[i].size() == 0)ans++;\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n        ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    d+=0.01;\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-5;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return distance_ls_p(a,b,c) < 0.01+eps;\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n\tcross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\n\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<-eps ) && //-EPS\n\t( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <-eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n\n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-9;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nint g[110][110];\nPt p[110][3];\nint UF[110];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[i][i]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble ax,bx,cx,ay,by,cy;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n\t\t\tdouble A=(bx-cx)*(bx-cx)+(by-cy)*(by-cy);\n\t\t\tdouble B=(ax-cx)*(ax-cx)+(ay-cy)*(ay-cy);\n\t\t\tdouble C=(ax-bx)*(ax-bx)+(ay-by)*(ay-by);\n\t\t\tif(ABS(A-B)<EPS){\n\t\t\t\tp[i][0]=Pt(ax,ay);p[i][1]=Pt(bx,by);p[i][2]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(B-C)<EPS){\n\t\t\t\tp[i][2]=Pt(ax,ay);p[i][0]=Pt(bx,by);p[i][1]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(C-A)<EPS){\n\t\t\t\tp[i][1]=Pt(ax,ay);p[i][2]=Pt(bx,by);p[i][0]=Pt(cx,cy);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)if(iSP(p[i][0],p[i][2],p[i][1])==-1)swap(p[i][0],p[i][1]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tif(i==j)continue;\n\t\t\tPt t[4];\n\t\t\tt[0]=p[i][0];\n\t\t\tt[1]=p[i][1];\n\t\t\tt[3]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[3]=t[0]+t[3]/t[3].ABS()*(double)b;\n\t\t\tt[2]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[2]=t[1]+t[2]/t[2].ABS()*(double)b;\n\t\t\tbool ok=false;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][k]+(p[j][(k+1)%3]-p[j][k])*10000.0)&&\n\t\t\t\t\tiSS(t[l],t[(l+1)%4],p[j][(k+1)%3],p[j][(k+1)%3]+(p[j][k]-p[j][(k+1)%3])*10000.0))ok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tg[i][j]=1;\n\t\t//\t\tprintf(\"%d %d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]|=g[i][k]&g[k][j];\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)if(g[i][j]&&g[j][i])UNION(i,j);\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(FIND(i)!=FIND(j)&&g[j][i])ok=false;\n\t\t\t}\n\t\t\tif(ok)ret++;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst double EPS = 0.01;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n//????????´???????£???????????????????(??????????????£???????????????)\nenum{NO_HIT=0, HIT, A_IN_B, B_IN_A};\nint HitPol_Pol(const polygon& a, const polygon& b){\n\tbool f = true, hit = false;\n\trep(i, a.size()){\n\t\tif(!contains(b, a[i])) f = false;\n\t\telse hit = true;\n\t}\n\tif(f) return A_IN_B;\n\tf = true;\n\trep(i, b.size()){\n\t\tif(!contains(a, b[i])) f = false;\n\t\telse hit = true;\n\t}\n\tif(f) return B_IN_A;\n\tif(hit) return HIT;\n\trep(i, a.size()) rep(j, b.size()){\n\t\tL la(curr(a, i), next(a, i)), lb(curr(b, j), next(b, j));\n\t\tif(intersectSS(la, lb)) return HIT;\n\t}\n\treturn NO_HIT;\n}\n//point???theta???????????¢\npoint spinP(const point& p, double theta){\n\treturn p*complex<double>(cos(theta),sin(theta));\n}\npoint spinPExtend(const point& p, double theta, double rate){\n\treturn p*complex<double>(rate*cos(theta),rate*sin(theta));\n}\n\nstruct SCC{//O(V+E)\n    static const int MAX_V = 1010;\n    int V;\n    vector<int> G[MAX_V], rG[MAX_V];\n    vector<int> vs;\n    bool used[MAX_V];\n    int cmp[MAX_V];\n    vector<vector<int> > res;\n \n \n    SCC(int v) : V(v){};\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n \n    void dfs(int v){\n        used[v] = true;\n        for(int i = 0; i < G[v].size(); i++){\n            if(!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v] = true;\n        cmp[v] = k;\n        for(int i = 0; i < rG[v].size(); i++){\n            if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n \n    int scc(){\n        memset(used, 0, sizeof(used));\n        vs.clear();\n        for(int v = 0; v < V; v++){\n            if(!used[v]) dfs(v);\n        }\n        memset(used, 0, sizeof(used));\n        int k = 0;\n        for(int i = vs.size() - 1; i >= 0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++);\n        }\n \n        res.clear();\n        res.resize(k);\n        for(int i = 0; i < V; i++){\n            res[cmp[i]].push_back(i);\n        }\n        return k;\n    }\n};\n\nint main(){\n\tint n, d;\n\twhile(cin >> n >> d && (n+d)){\n\t\tvector<polygon> tri(n);\n\t\trep(i, n){\n\t\t\tdouble x, y;\n\t\t\trep(j, 3){\n\t\t\t\tcin >> x >> y;\n\t\t\t\ttri[i].pb({x, y});\n\t\t\t}\n\t\t}\n\t\tvector<polygon> pol(n);\n\t\trep(i, n){\n\t\t\tdouble dist[3];\n\t\t\trep(j, 3){\n\t\t\t\tdist[j] = abs(curr(tri[i], j)-next(tri[i], j));\n\t\t\t}\n\t\t\trep(j, 3) {\n\t\t\t\tif(abs(dist[j] - dist[(j+1)%3])<EPS){\n\t\t\t\t\tpol[i].pb(tri[i][j]);\n\t\t\t\t\tpol[i].pb(tri[i][(j+2)%3]);\n\t\t\t\t\tpol[i].pb(spinPExtend(pol[i][0]-pol[i][1], (ccw(pol[i][1], pol[i][0], tri[i][(j+1)%3])> 0)?PI/2:PI/2*3, d/abs(pol[i][1]-pol[i][0]))+pol[i][1]);\n\t\t\t\t\tpol[i].pb(pol[i][2]+pol[i][0]-pol[i][1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSCC scc(n);\n\t\trep(i, n) rep(j, i){\n\t\t\tif(HitPol_Pol(pol[i], tri[j]) > 0 && HitPol_Pol(tri[i], pol[j])>0) scc.add_edge(i, j), scc.add_edge(j, i);\n\t\t\telse if(HitPol_Pol(pol[i], tri[j])>0) scc.add_edge(i, j);\n\t\t\telse if(HitPol_Pol(tri[i], pol[j])>0) scc.add_edge(j, i);\n\t\t}\n\t\tscc.scc();\n\t\tvector<int> f(scc.res.size(), 1);\n\t\trep(i, n) rep(j, i){\n\t\t\tif(scc.cmp[i] == scc.cmp[j]) continue;\n\t\t\tif(HitPol_Pol(pol[i], tri[j])>0) f[scc.cmp[j]] = 0;\n\t\t\telse if(HitPol_Pol(tri[i], pol[j])>0) f[scc.cmp[i]] = 0;\n\t\t}\n\t\tcout<<accumulate(all(f), 0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\n#include <cstring>\n\n// ???, ????????????\ntypedef std::complex<double> Point;\ntypedef Point Vector;\n\nnamespace std {\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\t\n\tistream& operator >> (istream &is, Point &a){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\ta = Point(x, y);\n\t\treturn is;\n\t}\n\t\n\tostream& operator << (ostream &os, Point a){\n\t\treturn os << a.real() << \" \" << a.imag();\n\t}\n}\n\n// ??´???\nstruct Line {\n\tPoint p1, p2;\n\tLine(){}\n\tLine(const Point &p1, const Point &p2): p1(p1), p2(p2){}\n};\ntypedef Line Segment;\n\nnamespace std {\n\tistream& operator >> (istream &is, Line &a){\n\t\treturn is >> a.p1 >> a.p2;\n\t}\n}\n\n// ???\nstruct Circle {\n\tPoint p; double r;\n\tCircle(){}\n\tCircle(const Point &p, double r): p(p), r(r){}\n};\n\nnamespace std {\n\tistream& operator >> (istream &is, Circle &a){\n\t\treturn is >> a.p >> a.r;\n\t}\n}\n\n// ????§???¢\ntypedef std::vector<Point> Polygon;\n\nconst double EPS = 1e-12;\nconst double INF = 1e12;\nconst double PI = acos(-1.0);\n\n// ????????¨??????????????¢???\nenum CCW {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0,\n};\n\n// ?????¢????£????????????¢???\nenum {\n\tOUT = 0,\n\tON = 1,\n\tIN = 2,\n};\n\n\n// a ??? 2 ??? (a ^ 2)\ndouble SQ(double a);\n\n// ?????????????????????????????¢??°\nbool EQ(double a, double b);\nbool NEQ(double a, double b);\nbool LT(double a, double b);\nbool GT(double a, double b);\nbool LEQ(double a, double b);\nbool GEQ(double a, double b);\n\n// ??§?????? <=> ?????°?????????\ndouble toDeg(double t);\ndouble toRad(double t);\n\n// ????????? (dot(a, a))\ndouble norm(const Vector &a);\n\n// ??????, ??????\ndouble dot(const Vector &a, const Vector &b);\ndouble cross(const Vector &a, const Vector &b);\n\n// ??´???, ??????\nbool orthogonal(const Segment &s1, const Segment &s2);\nbool parallel(const Segment &s1, const Segment &s2);\n\n// ?°???±, ????°?\nPoint project(const Line &l, const Point &p);\nPoint reflect(const Line &l, const Point &p);\n\n// ?????? (p0, p1) ??¨??? p2 ???????????¢???\nint ccw(const Point &p0, const Point &p1, const Point &p2);\n\n// ????????????\nbool intersectLP(const Line &l, const Point &p);\nbool intersectLL(const Line &l1, const Line &l2);\nbool intersectLS(const Line &l, const Segment &s);\nbool intersectSP(const Segment &s, const Point &p);\nbool intersectSS(const Segment &s1, const Segment &s2);\nint intersectCP(const Circle &c, const Point &p);\nbool intersectCL(const Circle &c, const Line &l);\nint intersectCS(const Circle &c, const Segment &s);\nint intersectCC(const Circle &c1, const Circle &c2);\n\n// ?????¢\ndouble distanceLP(const Line &l, const Point &p);\ndouble distanceLL(const Line &l1, const Line &l2);\ndouble distanceLS(const Line &l, const Segment &s);\ndouble distanceSP(const Segment &s, const Point &p);\ndouble distanceSS(const Segment &s1, const Segment &s2);\ndouble distanceCP(const Circle &c, const Point &p);\ndouble distanceCL(const Circle &c, const Line &l);\ndouble distanceCS(const Circle &c, const Segment &s);\ndouble distanceCC(const Circle &c1, const Circle &c2);\n\n// ??????\nPoint crossPointLL(const Line &l1, const Line &l2);\nPoint crossPointLS(const Line &l, const Segment &s);\nPoint crossPointSS(const Segment &s1, const Segment &s2);\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l);\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s);\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2);\n\n\ndouble SQ(double a){\n\treturn a * a;\n}\n\nbool EQ(double a, double b){\n\treturn std::abs(a - b) < EPS;\n}\n\nbool NEQ(double a, double b){\n\treturn !EQ(a, b);\n}\n\nbool LT(double a, double b){\n\treturn a - b < -EPS;\n}\n\nbool GT(double a, double b){\n\treturn a - b > EPS;\n}\n\nbool LEQ(double a, double b){\n\treturn !GT(a, b);\n}\n\nbool GEQ(double a, double b){\n\treturn !LT(a, b);\n}\n\ndouble toDeg(double t){\n\treturn t * 180 / PI;\n}\n\ndouble toRad(double t){\n\treturn t / 180 * PI;\n}\n\ndouble norm(const Vector &a){\n\treturn SQ(a.real()) + SQ(a.imag());\n}\n\ndouble dot(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).real();\n}\n\ndouble cross(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).imag();\n}\n\n// AOJ CGL_2_A\nbool orthogonal(const Segment &s1, const Segment &s2){\n\treturn EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_2_A\nbool parallel(const Segment &s1, const Segment &s2){\n\treturn EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_1_A\nPoint project(const Line &l, const Point &p){\n\tVector base = l.p2 - l.p1;\n\tdouble r = dot(p - l.p1, base) / norm(base);\n\treturn l.p1 + base * r;\n}\n\n// AOJ CGL_1_B\nPoint reflect(const Line &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2.0;\n}\n\n// AOJ CGL_1_C\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (GT(cross(a, b), 0.0)) return COUNTER_CLOCKWISE;\n\tif (LT(cross(a, b), 0.0)) return CLOCKWISE;\n\tif (LT(dot(a, b), 0.0)) return ONLINE_BACK;\n\tif (LT(norm(a), norm(b))) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersectLP(const Line &l, const Point &p){\n\treturn LEQ(std::abs(cross(l.p1 - p, l.p2 - p)), 0.0);\n}\n\nbool intersectLL(const Line &l1, const Line &l2){\n\treturn !parallel(l1, l2) || LEQ(std::abs(cross(l1.p2 - l1.p1, l2.p1 - l1.p1)), 0.0);\n}\n\nbool intersectLS(const Line &l, const Segment &s){\n\treturn LEQ(cross(l.p2 - l.p1, s.p1 - l.p1) * cross(l.p2 - l.p1, s.p2 - l.p1), 0.0);\n}\n\nbool intersectSP(const Segment &s, const Point &p){\n\treturn norm(s.p1 - p) + norm(s.p2 - p) - norm(s.p2 - s.p1) < EPS;\n}\n\n// CGL_2_B\nbool intersectSS(const Segment &s1, const Segment &s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\nint intersectCP(const Circle &c, const Point &p){\n\tdouble dd = norm(c.p - p);\n\tif (LT(dd, SQ(c.r))) return IN;\n\tif (EQ(dd, SQ(c.r))) return ON;\n\treturn OUT;\n}\n\nbool intersectCL(const Circle &c, const Line &l){\n\tdouble d = distanceLP(l, c.p);\n\treturn LEQ(d, c.r);\n}\n\nint intersectCS(const Circle &c, const Segment &s){\n\tdouble dd1 = norm(c.p - s.p1);\n\tdouble dd2 = norm(c.p - s.p2);\n\tif (LT(dd1, SQ(c.r)) && LT(dd2, SQ(c.r))) return IN;\n\tif (GT(distanceCS(c, s), 0.0)) return OUT;\n\treturn ON;\n}\n\n// c1 ??? c2 ???????????????????????¨??? IN\n// c1 ??? c2 ????????£???????????¨??? ON\n// c1 ??? c2 ?????????????????¨??? OUT\nint intersectCC(const Circle &c1, const Circle &c2){\n\tif (GT(norm(c1.p - c2.p), SQ(c1.r + c2.r))) return OUT;\n\tif (LT(norm(c1.p - c2.p), SQ(c2.r))) return IN;\n\tif (LT(norm(c1.p - c2.p), SQ(c1.r))) return OUT;\n\treturn ON;\n}\n\ndouble distanceLP(const Line &l, const Point &p){\n\treturn std::abs(cross(l.p2 - l.p1, p - l.p1)) / std::abs(l.p2 - l.p1);\n}\n\ndouble distanceLL(const Line &l1, const Line &l2){\n\tif (intersectLL(l1, l2)) return 0.0;\n\treturn distanceLP(l1, l2.p1);\n}\n\ndouble distanceLS(const Line &l, const Segment &s){\n\tif (intersectLS(l, s)) return 0.0;\n\treturn std::min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\n\ndouble distanceSP(const Segment &s, const Point &p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return std::abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return std::abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\n// AOJ CGL_2_D\ndouble distanceSS(const Segment &s1, const Segment &s2){\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn std::min(\n\t\tstd::min(\n\t\t\tdistanceSP(s1, s2.p1),\n\t\t\tdistanceSP(s1, s2.p2)\n\t\t),\n\t\tstd::min(\n\t\t\tdistanceSP(s2, s1.p1),\n\t\t\tdistanceSP(s2, s1.p2)\n\t\t)\n\t);\n}\n\ndouble distanceCP(const Circle &c, const Point &p){\n\treturn std::abs(std::abs(c.p - p) - c.r);\n} \n\ndouble distanceCL(const Circle &c, const Line &l){\n\tif (intersectCL(c, l)) return 0.0;\n\treturn distanceLP(l, c.p) - c.r;\n}\n\ndouble distanceCS(const Circle &c, const Segment &s){\n\tif (intersectCS(c, s)) return 0.0;\n\treturn std::min(distanceCP(c, s.p1), distanceCP(c, s.p2));\n}\n\ndouble distanceCC(const Circle &c1, const Circle &c2){\n\tif (intersectCC(c1, c2) == ON) return 0.0;\n\tif (intersectCC(c1, c2) == IN){\n\t\treturn c2.r - (std::abs(c1.p - c2.p) + c1.r);\n\t}\n\tif (intersectCC(c2, c1) == IN){\n\t\treturn c1.r - (std::abs(c1.p - c2.p) + c2.r);\n\t}\n\treturn (c1.r + c2.r) - (c1.r + c2.r);\n}\n\nPoint crossPointLL(const Line &l1, const Line &l2){\n\tassert(intersectLL(l1, l2));\n\tVector base = l2.p2 - l2.p1;\n\tdouble d1 = std::abs(cross(base, l1.p1 - l2.p1));\n\tdouble d2 = std::abs(cross(base, l1.p2 - l2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn l1.p1 + (l1.p2 - l1.p1) * t;\n}\n\nPoint crossPointLS(const Line &l, const Segment &s){\n\tassert(intersectLS(l, s));\n\treturn crossPointLL(l, s);\n}\n\nPoint crossPointSS(const Segment &s1, const Segment &s2){\n\tassert(intersectSS(s1, s2));\n\treturn crossPointSS(s1, s2);\n}\n\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l){\n\tif (!intersectCL(c, l)) return std::vector<Point>();\n\tstd::vector<Point> ret;\n\tVector proj = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / std::abs(l.p2 - l.p1);\n\tdouble base = sqrt(SQ(c.r) - norm(proj - c.p));\n\tret.push_back(proj + e * base);\n\tret.push_back(proj - e * base);\n\treturn ret;\n}\n\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s){\n\tstd::vector<Point> ret = crossPointCL(c, s);\n\tfor (int i = 0; i < ret.size(); i++){\n\t\tif (!intersectCP(c, ret[i])){\n\t\t\tswap(ret[i], ret.back());\n\t\t\tret.pop_back();\n\t\t\ti--;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2){\n\tif (!intersectCC(c1, c2)) return std::vector<Point>();\n\tstd::vector<Point> ret;\n\tdouble d = std::abs(c1.p - c2.p);\n\tdouble a = std::acos((SQ(c1.r) + SQ(d) - SQ(c2.r)) / (2 * c1.r * d));\n\tdouble t = std::arg(c2.p - c1.p);\n\tret.push_back(c1.p + std::polar(c1.r, t + a));\n\tret.push_back(c1.p + std::polar(c1.r, t - a));\n\treturn ret;\n}\n\nnamespace {\nenum {DIRECTED, UNDIRECTED};\nconst int GRAPH_TYPE = DIRECTED;\n\ntypedef int Weight;\nconst Weight INF = 1 << 28;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge() {}\n\tEdge(int src, int dst, Weight weight = 1): src(src), dst(dst), weight(weight) {}\n\tbool operator < (const Edge &t) const { return weight < t.weight; }\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n\nvoid addEdge(Graph &g, int src, int dst, int weight = 1)\n{\n\tg[src].emplace_back(Edge(src, dst, weight));\n\tif (GRAPH_TYPE == UNDIRECTED) g[dst].emplace_back(Edge(dst, src, weight));\n};\n\nGraph transpose(const Graph &g)\n{\n\tGraph rg(g.size());\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\taddEdge(rg, g[i][j].dst, g[i][j].src, g[i][j].weight);\n\t\t}\n\t}\n\treturn rg;\n}\n\nvoid dfs_(const Graph &g, int v, bool *used, std::vector<int> &vs)\n{\n\tused[v] = true;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) dfs_(g, to, used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs_(const Graph &g, int v, int k, bool *used, std::vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) rdfs_(g, to, k, used, cmp);\n\t}\n}\n\nint scc(const Graph &g, std::vector<int> &cmp)\n{\n\tGraph rg = transpose(g);\n\tstd::vector<int> vs;\n\tbool *used = new bool[g.size()];\n\tcmp.resize(g.size());\n\t\n\tstd::memset(used, false, g.size());\n\tfor (int v = 0; v < g.size(); v++){\n\t\tif (!used[v]) dfs_(g, v, used, vs);\n\t}\n\t\n\tstd::memset(used, false, g.size());\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs_(rg, vs[i], k++, used, cmp);\n\t}\n\t\n\tdelete used;\n\treturn k;\n}\n}\n\n\nusing namespace std;\n\nint n;\ndouble d;\nvector<Polygon> tri;\nvector<Polygon> rect;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment s(g[i], g[(i + 1) % g.size()]);\n\t\t\tSegment t(h[j], h[(j + 1) % h.size()]);\n\t\t\tif (intersectSS(s, t)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint solve()\n{\n\trect.assign(n, Polygon(4));\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tif (EQ(norm(tri[i][j] - tri[i][(j + 1) % 3]), norm(tri[i][j] - tri[i][(j + 2) % 3]))){\n\t\t\t\tswap(tri[i][0], tri[i][j]);\n\t\t\t}\n\t\t}\n\t\tif (ccw(tri[i][1], tri[i][2], tri[i][0]) == CLOCKWISE){\n\t\t\tswap(tri[i][1], tri[i][2]);\n\t\t}\n\t\t\n\t\tVector s = tri[i][2] - tri[i][1];\n\t\tVector normal = s / abs(s) * Vector(0, 1) * d;\n\t\trect[i][0] = tri[i][1];\n\t\trect[i][1] = tri[i][2];\n\t\trect[i][2] = tri[i][2] + normal;\n\t\trect[i][3] = tri[i][1] + normal;\n\t}\n\t\n\tGraph graph(n);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(rect[i], tri[j])){\n\t\t\t\taddEdge(graph, i, j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tint v = scc(graph, cmp);\n\tGraph sccgraph(v);\n\tint mat[100][100] = {};\n\tint in[100] = {};\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < graph[i].size(); j++){\n\t\t\tint src = cmp[i];\n\t\t\tint dst = cmp[graph[i][j].dst];\n\t\t\tif (src == dst) continue;\n\t\t\tif (mat[src][dst]++) continue;\n\t\t\tin[dst]++;\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < v; i++){\n\t\tif (in[i] == 0) res++;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tstd::cout << std::fixed << std::setprecision(12);\n\t\n\twhile (cin >> n >> d, n){\n\t\ttri.assign(n, Polygon(3));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-10;\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      //if (     cross(a[in[0]]-a[in[1]],a[in[2]]-a[in[1]]) >=0)\n      //\tassert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])>=0);\n      //      else assert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])<=0);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  //assert(false);\n  return ret;\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\n#define DSS distance_ls_p\ndouble distance_ss_p(P a,P b,P c,P d){\n  return min(  min( DSS(a,b,c),DSS(a,b,d)),min(DSS(c,d,a),DSS(c,d,b)));\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n      rep(k,tri[j].size()){\n\tif (is_in(tri[i],tri[j][k])&&\n\t    (distance_ss_p(sq[i][0],sq[i][1],tri[j][0],tri[j][1])||\n\t     distance_ss_p(sq[i][0],sq[i][1],tri[j][1],tri[j][2])||\n\t     distance_ss_p(sq[i][0],sq[i][1],tri[j][2],tri[j][0]))\n\t    ){\n\t  assert(false);\n\t  inedge[i].pb(j);\n\t  redge[j].pb(i);\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n\n\n    //rep(i,n){rep(j,sq[i].size())cout<< sq[i][j];cout << endl;}\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS = 0.01, INF = 1e12, PI = acos(-1.0);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > EPS)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < -EPS)   return -1;\t\t// clockwise\n\tif(dot(b, c) < -EPS)     return +2;\t\t// c--a--b on line\n\tif(norm(b) + EPS < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  G ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n#include<stack>\nvoid visit(const vector<vi> &g, int v, vector<vi>& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  each(e, g[v]) {\n    int w = *e;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const vector<vi>& g,\n    vector<vi>& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint n, d;\nvector<vi> g;\n\nint main(){\n\twhile(cin >> n >> d, n || d){\n\t\tg.clear(); g.resize(n);\n\t\tvector<G> tri;\n\t\trep(i, n){\n\t\t\tint t;\n\t\t\tG p(3);\n\t\t\tdouble l[3];\n\t\t\trep(j, 3) cin >> p[j].real() >> p[j].imag();\n\t\t\trep(j, 3) l[j] = abs(p[j] - p[(j + 1) % 3]);\n\t\t\trep(j, 3) if(abs(l[j] - l[(j + 1) % 3]) < EPS){\n\t\t\t\tt = (j + 1) % 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswap(p[t], p[(t + 1) % 3]);\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\trep(i, n){\n\t\t\tG &p = tri[i];\n\t\t\tP dir = p[0] - (p[1] + p[2]) * 0.5;\n\t\t\tdir *= d / abs(dir);\n\t\t\t\n\t\t\tG ps;\n\t\t\tps.pb(p[1]); ps.pb(p[2]);\n\t\t\tps.pb(p[1] + dir); ps.pb(p[2] + dir);\n\t\t\tps = convex_hull(ps);\n\t\t\t\n\t\t\trep(j, n){\n\t\t\t\tbool ok = 0;\n\t\t\t\trep(k, 3) if(contains(ps, tri[j][k]) != OUT) ok = 1;\n\t\t\t\tif(ok) g[i].pb(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tmap<int, int> to;\n\t\tvector<vi> scc;\n\t\tstronglyConnectedComponents(g, scc);\n\t\tint m = scc.size();\n\t\tvi in(m);\n\t\t\n\t\trep(i, m) rep(j, scc[i].size()){\n\t\t\tto[scc[i][j]] = i;\n\t\t}\n\t\trep(i, n) rep(j, g[i].size()){\n\t\t\tint a = to[i], b = to[g[i][j]];\n\t\t\tif(a != b) in[b]++;\n\t\t}\n\t\trep(i, m) if(in[i] == 0) ans++;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)==real(b)?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\nconst D EPS = 1e-8;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nPoly tri[110];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nvector<P> convex_hull(vector<P> v){\n  int n = v.size(), k = 0;\n  sort(v.begin(),v.end());\n  vector<P> r(2*n);\n  for(int i=0;i<n;i++){\n    while(k>1 && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= EPS)k--;\n    r[k++] = v[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= EPS)k--;\n    r[k++] = v[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      tri[i].resize(3);\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n      tri[i] = convex_hull(tri[i]);\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0){\n\t    swap(rect[i][0],rect[i][1]); break;\n\t  }\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n      rect[i] = convex_hull(rect[i]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k])){\n\t    f = true; break;\n\t  }\n\n\tif(!f){\n\t  rep(k,4)\n\t    if(inter_pos(tri[j],rect[i][k])){\n\t      f = true;\n\t      break;\n\t    }\n\t}\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-2)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) + SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G &a, G &b)\n{\t\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a.size(); i++){\n\t\tif (contains(b, a[i])){\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int i = 0; i < b.size(); i++){\n\t\tif (contains(a, b[i])){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tvector<int> toi(V);\n\tfor (int i = 0; i < V; i++){\n\t\ttoi[tps[i]] = i;\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tint v = tps[i];\n\t\tif (!used[v]) res++;\n\t\tfor (int to : sccgraph[v]){\n\t\t\tused[to] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tbool f = false;\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\t\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t\tf = true;\n\t\t}\n\t\tassert(f);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (indeg[cmp[i]] == 0) res++;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-1;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tif (contains(g, h[0])) return true;\n\tif (contains(h, g[0])) return true;\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc()\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tvector<int> cmp(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tbool f = false;\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t\tf = true;\n\t\t}\n\t\tassert(f);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>> sccgraph = scc();\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0) res++;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass UnionFindTree\n{\n    vector<int> parent; // em[h\n    vector<int> rank;   // ØÌ³ÌãÀ\n    int find(int x){\n        if(parent[x] == x)\n            return x;\n        return parent[x] = find(parent[x]);\n    }\npublic:\n    UnionFindTree(int n){ // RXgN^\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        rank.assign(n, 0);\n    }\n    void unite(int x, int y){ // xÆyÌO[vð¹\n        if((x = find(x)) != (y = find(y))){\n            if(rank[x] < rank[y])\n                parent[x] = y;\n            else{\n                parent[y] = x;\n                if(rank[x] == rank[y])\n                    ++ rank[x];\n            }\n        }\n    }\n    bool same(int x, int y){ // xÆyÌO[vª¯¶©ð²×é\n        return find(x) == find(y);\n    }\n    int num(){ // O[vÌðÔ·\n        vector<bool> root(parent.size(), false);\n        for(unsigned i=0; i<parent.size(); ++i)\n            root[find(i)] = true;\n        return count(root.begin(), root.end(), true);\n    }\n};\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\nbool convexContain(const vector<Point>& cp, const Point& p)\n{\n    int n = cp.size();\n    bool ret1 = true;\n    bool ret2 = true;\n    for(int i=0; i<n; ++i){\n        double a = (cp[(i+1)%n] - cp[i]).cross(p - cp[i]);\n        if(a < -EPS)\n            ret1 = false;\n        if(a > EPS)\n            ret2 = false;\n    }\n    return ret1 || ret2;\n}\n\nbool segmentsCollide(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(min(a1.x, a2.x) > max(b1.x, b2.x) + EPS || min(b1.x, b2.x) > max(a1.x, a2.x) + EPS || min(a1.y, a2.y) > max(b1.y, b2.y) + EPS || min(b1.y, b2.y) > max(a1.y, a2.y) + EPS)\n        return false;\n\n    return ((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) <= EPS) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) <= EPS);\n}\n\nbool polygonsCollide(const vector<Point>& cp1, const vector<Point>& cp2)\n{\n    int n = cp1.size();\n    int m = cp2.size();\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<m; ++j){\n            if(segmentsCollide(cp1[i], cp1[(i+1)%n], cp2[j], cp2[(j+1)%m]))\n                return true;\n        }\n    }\n\n    return convexContain(cp1, cp2[0]) || convexContain(cp2, cp1[0]);\n}\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Point> > p(n, vector<Point>(3));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<3; ++j){\n                cin >> p[i][j].x >> p[i][j].y;\n            }\n            if(p[i][0].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][1], p[i][2]);\n            if(p[i][1].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][0], p[i][2]);\n        }\n\n        UnionFindTree uft(n);\n        vector<bool> check(n, false);\n        for(int i=0; i<n; ++i){\n            Point v = p[i][0] - p[i][1];\n            v = v / v.length() * d;\n            swap(v.y, v.x);\n            v.y *= -1;\n\n            vector<Point> p1(4);\n            p1[0] = p[i][0];\n            p1[1] = p[i][0] + v;\n            p1[2] = p[i][1] + v;\n            p1[3] = p[i][1];\n            if(!convexContain(p1, p[i][2])){\n                p1[1] = p[i][0] - v;\n                p1[2] = p[i][1] - v;\n            }\n\n            for(int j=0; j<n; ++j){\n                if(j == i)\n                    continue;\n                if(polygonsCollide(p1, p[j])){\n                    uft.unite(i, j);\n                    check[j] = true;\n                }\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            if(!check[i])\n                ++ ret;\n            else{\n                bool b = true;\n                for(int j=0; j<n; ++j){\n                    if(uft.same(i, j) && !check[j])\n                        b = false;\n                }\n                if(b)\n                    ++ ret;\n                check[i] = false;\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,postorder[i].order);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n\tcross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<-eps ) && //-EPS\n\t( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <-eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\nusing real = double;\nstatic constexpr real EPS = 1e-9;\nstruct Point {\n    real x, y;\n    Point& operator+=(const Point a) { x += a.x; y += a.y;  return *this; }\n    Point& operator-=(const Point a) { x -= a.x; y -= a.y;  return *this; }\n    Point& operator*=(const real k) { x *= k; y *= k;  return *this; }\n    Point& operator/=(const real k) { x /= k; y /= k;  return *this; }\n    Point operator+(const Point a) const {return Point(*this) += a; }\n    Point operator-(const Point a) const {return Point(*this) -= a; }\n    Point operator*(const real k) const {return Point(*this) *= k; }\n    Point operator/(const real k) const {return Point(*this) /= k; }\n    bool operator<(const Point &a) const { return (x != a.x ? x < a.x : y < a.y); }\n    explicit Point(real a = 0, real b = 0) : x(a), y(b) {};\n};\n\nbool sorty(Point a, Point b){\n    return (a.y != b.y ? a.y < b.y : a.x < b.x);\n}\n\nistream& operator>> (istream& s, Point& P){\n    s >> P.x >> P.y;\n    return s;\n}\n\ninline real dot(Point a, Point b){ return a.x*b.x + a.y*b.y; }\ninline real cross(Point a, Point b){ return a.x*b.y - a.y*b.x; }\ninline real abs(Point a){ return sqrt(dot(a, a)); }\n\n\nreal angle(Point A, Point B){\n    return acos(dot(A, B)/abs(A)/abs(B));\n}\n\n\n\nstatic constexpr int COUNTER_CLOCKWISE = 1;\nstatic constexpr int CLOCKWISE = -1;\nstatic constexpr int ONLINE_BACK = 2;\nstatic constexpr int ONLINE_FRONT = -2;\nstatic constexpr int ON_SEGMENT = 0;\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(b, c) < -EPS) return CLOCKWISE;\n    if(dot(b, c) < 0) return ONLINE_BACK;\n    if(abs(b) < abs(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nstruct Segment {\n    Point a, b;\n    Segment(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Line {\n    Point a, b;\n    Line(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Circle{\n    Point c; real r;\n    Circle(Point c, real r): c(c), r(r) {};\n};\n\nusing Polygon = vector<Point>;\n\nbool intersect(Segment s, Segment t){\n    return (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n            ccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool intersect(Segment s, Line t){\n    int a = ccw(t.a, t.b, s.a), b = ccw(t.a, t.b, s.b);\n    return (!(a&1) || !(b&1) || a != b);\n}\n\nPoint polar(double r, double t){\n    return Point(r*cos(t), r*sin(t));\n}\n\ndouble arg(Point p){\n    return atan2(p.y, p.x);\n}\n\nstatic constexpr int CONTAIN = 0;\nstatic constexpr int INSCRIBE = 1;\nstatic constexpr int INTERSECT = 2;\nstatic constexpr int CIRCUMSCRIBED = 3;\nstatic constexpr int SEPARATE = 4;\n\nint intersect(Circle c1, Circle c2){\n    if(c1.r < c2.r) swap(c1, c2);\n    real d = abs(c1.c-c2.c);\n    real r = c1.r + c2.r;\n    if(fabs(d-r) < EPS) return CIRCUMSCRIBED;\n    if(d > r) return SEPARATE;\n    if(fabs(d+c2.r-c1.r) < EPS) return INSCRIBE;\n    if(d+c2.r < c1.r) return CONTAIN;\n    return INTERSECT;\n}\n\nreal distance(Line l, Point c){\n    return abs(cross(l.b-l.a, c-l.a)/abs(l.b-l.a));\n}\n\n\nreal distance(Segment s, Point c){\n    if(dot(s.b-s.a, c-s.a) < EPS) return abs(c-s.a);\n    if(dot(s.a-s.b, c-s.b) < EPS) return abs(c-s.b);\n    return abs(cross(s.b-s.a, c-s.a)) / abs(s.a-s.b);\n}\n\nreal distance(Segment s, Segment t){\n    if(intersect(s, t)) return 0.0;\n    return min({distance(s, t.a), distance(s, t.b),\n                distance(t, s.a), distance(t, s.b)});\n}\n\n\nPoint project(Line l, Point p){\n    Point Q = l.b-l.a;\n    return l.a + Q*(dot(p-l.a, Q) / dot(Q, Q));\n}\n\n\nPoint project(Segment s, Point p){\n    Point Q = s.b-s.a;\n    return s.a + Q*(dot(p-s.a, Q) / dot(Q, Q));\n}\n\nPoint refrect(Segment s, Point p){\n    Point Q = project(s, p);\n    return Q*2-p;\n}\n\nbool isOrthogonal(Segment s, Segment t){\n    return fabs(dot(s.b-s.a, t.b-t.a)) < EPS;\n}\n\nbool isparallel(Segment s, Segment t){\n    return fabs(cross(s.b-s.a, t.b-t.a)) < EPS;\n}\n\n\nPoint crossPoint(Segment s, Segment t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPoint crossPoint(Line s, Line t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPolygon crossPoint(Circle c, Line l){\n    Point p = project(l, c.c), q = (l.b-l.a)/abs(l.b-l.a);\n    if(abs(distance(l, c.c)-c.r) < EPS){\n        return {p};\n    }\n    double k = sqrt(c.r*c.r-dot(p-c.c, p-c.c));\n    return {p-q*k, p+q*k};\n}\n\nPolygon crossPoint(Circle c, Segment s){\n    auto tmp = crossPoint(c, Line(s.a, s.b));\n    Polygon ret;\n    for (auto &&i : tmp) {\n        if(distance(s, i) < EPS) ret.emplace_back(i);\n    }\n    return ret;\n}\n\n\nPolygon crossPoint(Circle c1, Circle c2){\n    double d = abs(c1.c-c2.c);\n    double a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t = arg(c2.c-c1.c);\n    return {c1.c+polar(c1.r, t+a), c1.c+polar(c1.r, t-a)};\n}\n\nPolygon tangent(Circle c1, Point p){\n    Circle c2 = Circle(p, sqrt(dot(c1.c-p, c1.c-p)-c1.r*c1.r));\n    return crossPoint(c1, c2);\n}\nvector<Line> tangent(Circle c1, Circle c2){\n    vector<Line> ret;\n    if(c1.r < c2.r) swap(c1, c2);\n    double k = dot(c1.c-c2.c, c1.c-c2.c);\n    if(abs(k) < EPS) return {};\n    Point u = (c2.c-c1.c)/sqrt(k);\n    Point v(-u.y, u.x);\n    for (auto &&i : {-1, 1}) {\n        double h = (c1.r+i*c2.r)/sqrt(k);\n        if(abs(h*h-1) < EPS){\n            ret.emplace_back(c1.c+u*c1.r, c1.c+(u+v)*c1.r);\n        }else if(h*h < 1){\n            Point u2 = u*h, v2 = v*sqrt(1-h*h);\n            ret.emplace_back(c1.c+(u2+v2)*c1.r, c2.c-(u2+v2)*c2.r*i);\n            ret.emplace_back(c1.c+(u2-v2)*c1.r, c2.c-(u2-v2)*c2.r*i);\n        }\n    }\n    return ret;\n}\n\nreal area(Polygon v){\n    if(v.size() < 3) return 0.0;\n    real ans = 0.0;\n    for (int i = 0; i < v.size(); ++i) {\n        ans += cross(v[i], v[(i+1)%v.size()]);\n    }\n    return ans/2;\n}\n\nstruct SCC {\n    vector<vector<int>> G, G_r, G_out;\n    vector<int> vs, used, cmp;\n    SCC() = default;\n    explicit SCC(int n) : G(n), G_r(n), G_out(n), used(n), cmp(n) {}\n\n    void add_edge(int a, int b){\n        G[a].emplace_back(b);\n        G_r[b].emplace_back(a);\n    }\n\n    void dfs(int v){\n        used[v] = 1;\n        for (auto &&u : G[v]) if(!used[u]) dfs(u);\n        vs.emplace_back(v);\n    }\n\n    void dfs_r(int v, int k){\n        used[v] = 1;\n        cmp[v] = k;\n        for (auto &&u : G_r[v]) if(!used[u]) dfs_r(u, k);\n    }\n\n    int build() {\n        int n = G.size();\n        for (int i = 0; i < n; ++i) if(!used[i]) dfs(i);\n        fill(used.begin(),used.end(), 0);\n        int k = 0;\n        for (int i = n - 1; i >= 0; --i) {\n            if(!used[vs[i]]){\n                dfs_r(vs[i], k++);\n            }\n        }\n        G_out.resize(k);\n        for (int i = 0; i < n; ++i) {\n            for (auto &&j : G[i]) {\n                if(cmp[i] != cmp[j]){\n                    G_out[cmp[i]].emplace_back(cmp[j]);\n                }\n            }\n        }\n        for (int i = 0; i < k; ++i) {\n            sort(G_out[i].begin(), G_out[i].end());\n            G_out[i].erase(unique(G_out[i].begin(), G_out[i].end()), G_out[i].end());\n        }\n        return k;\n    }\n\n    int operator[](int k) const { return cmp[k]; }\n};\n\nint contains(Polygon v, Point p){\n    int n = v.size();\n    bool x = false;\n    static constexpr int IN = 2;\n    static constexpr int ON = 1;\n    static constexpr int OUT = 0;\n    for (int i = 0; i < n; ++i) {\n        Point a = v[i]-p, b = v[(i+1)%n]-p;\n        if(fabs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n        if(a.y > b.y) swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return (x?IN:OUT);\n}\n\nPolygon convex_hull(Polygon v){\n    int n = v.size();\n    sort(v.begin(),v.end(), sorty);\n    int k = 0;\n    Polygon ret(n*2);\n    for (int i = 0; i < n; ++i) {\n        while(k > 1 && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    for(int i = n-2, t=k; i >= 0; i--){\n        while(k > t && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    ret.resize(k-1);\n    return ret;\n}\n\nvoid solve(int n, int d){\n    vector<Polygon> v(n, Polygon(3));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> v[i][j];\n        }\n        double l[3];\n        int cur = 0;\n        for (int j = 0; j < 3; ++j) {\n            l[j] = abs(v[i][j] - v[i][(j+1)%3]);\n        }\n        for (int j = 0; j < 3; ++j) {\n            if(abs(l[j] - l[(j + 1) % 3]) < EPS){\n                cur = (j+1)%3;\n                break;\n            }\n        }\n        swap(v[i][0], v[i][cur]);\n    }\n    SCC G(n);\n    for (int i = 0; i < n; ++i) {\n        Point P = v[i][0] - (v[i][1]+v[i][2])/2;\n        P = P/abs(P)*d;\n        Polygon X{v[i][1], v[i][2], v[i][1]+P, v[i][2]+P};\n        X = convex_hull(X);\n        for (int j = 0; j < n; ++j) {\n            if(i == j) continue;\n            int ok = 0;\n            for (int k = 0; k < 3; ++k) {\n                for (int l = 0; l < 4; ++l) {\n                    if(distance(Segment(X[l], X[(l+1)&3]), v[j][k]) < 0.01) ok = 1;\n                    if(contains(X, v[j][k])) ok = 1;\n                }\n            }\n            if(ok) G.add_edge(i, j);\n        }\n    }\n\n    G.build();\n    vector<int> deg(G.G_out.size());\n    for (int i = 0; i < G.G_out.size(); ++i) {\n        for (auto &&j : G.G_out[i]) {\n            deg[j]++;\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < G.G_out.size(); ++i) {\n        if(!deg[i]) ans++;\n    }\n    cout << ans << \"\\n\";\n}\n\n\nint main() {\n    int n, d;\n    while(cin >> n >> d, n){\n        solve(n, d);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS = 0.01, INF = 1e12, PI = acos(-1.0);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  G ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n#include<stack>\nvoid visit(const vector<vi> &g, int v, vector<vi>& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  each(e, g[v]) {\n    int w = *e;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const vector<vi>& g,\n    vector<vi>& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint n, d;\nvector<vi> g;\n\nint main(){\n\twhile(cin >> n >> d, n){\n\t\tg.clear(); g.resize(n);\n\t\tvector<G> tri;\n\t\trep(i, n){\n\t\t\tint t;\n\t\t\tG p(3);\n\t\t\tdouble l[3];\n\t\t\trep(j, 3) cin >> p[j].real() >> p[j].imag();\n\t\t\trep(j, 3) l[j] = abs(p[j] - p[(j + 1) % 3]);\n\t\t\trep(j, 3) if(abs(l[j] - l[(j + 1) % 3]) < EPS){\n\t\t\t\tt = (j + 1) % 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswap(p[t], p[(t + 1) % 3]);\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\trep(i, n){\n\t\t\tG &p = tri[i];\n\t\t\tP dir = p[0] - (p[1] + p[2]) * 0.5;\n\t\t\tdir *= d / abs(dir);\n\t\t\t\n\t\t\tG ps;\n\t\t\tps.pb(p[1]); ps.pb(p[2]);\n\t\t\tps.pb(p[1] + dir); ps.pb(p[2] + dir);\n\t\t\tps = convex_hull(ps);\n\t\t\t\n\t\t\trep(j, n){\n\t\t\t\tbool ok = 0;\n\t\t\t\trep(k, 3) if(contains(ps, tri[j][k]) != OUT) ok = 1;\n\t\t\t\tif(ok) g[i].pb(j);\n\t\t\t}\n\t\t}\n\t\tmap<int, int> to;\n\t\tvector<vi> scc;\n\t\tstronglyConnectedComponents(g, scc);\n\t\tint m = scc.size();\n\t\tvi in(m);\n\t\t\n\t\trep(i, m) rep(j, scc[i].size()){\n\t\t\tto[scc[i][j]] = i;\n\t\t}\n\t\trep(i, n) rep(j, g[i].size()){\n\t\t\tint a = to[i], b = to[g[i][j]];\n\t\t\tif(a != b) in[b]++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\trep(i, m) if(in[i] == 0) ans++;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(Segment(curr(g, i), next(g, i)), h[j]) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(Segment(curr(h, i), next(h, i)), g[j]) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tif (contains(g, h[0])) return true;\n\tif (contains(h, g[0])) return true;\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc()\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tvector<int> cmp(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tbool f = false;\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\t\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t\tf = true;\n\t\t}\n\t\tassert(f);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>> sccgraph = scc();\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0) res++;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-1;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[0])<eps||fabs(l[2]-l[0])<eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    bool c[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<-eps;\n\t      c[j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    c[j]|=!f;\n\t  }\n\t}\n      }\n    }\n    cout<<max<int>(1,count(c,c+n,false))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cfloat>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define EPS (1e-8)\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint ( double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n\tPoint operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n\tPoint operator * ( double a ){ return Point(x*a, y*a); }\n\tdouble abs() { return sqrt(norm());}\n\tdouble norm() { return x*x + y*y; }\n\tbool operator < ( const Point &p ) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == ( const Point &p ) const {\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs(Vector a) {return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b) {return (sqrt(norm(a - b)));}\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\ndouble eq(double a, double b)\n{\n\treturn (fabs(a - b) <= EPS);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n//3点の位置関係を求める\nint ccw( Point p0, Point p1, Point p2 ){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( norm(a) < norm(b) ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//A = p2 - p1, B = p4 - p3が交差するか\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n\n\n//多角形の中に点があるか\nbool isInside(Polygon gon, Point p ){\n\tfor ( int i = 0; i < gon.size(); i++ ){\n\t\tif ( ccw(gon[i], gon[(i+1)%gon.size()], p) == CLOCKWISE ) return (false);\n\t}\n\treturn (true);\n}\n\n//単位ベクトルを求める\nPoint unitVector(Point t){\n\tdouble u=abs(t);\n\treturn Point(t.x/u , t.y/u);\n}\n//cosθを求める\ndouble getcos(Point a , Point b){\n\treturn (dot(a,b) / (abs(a)*abs(b)));\n}\n\n//sinθを求める\ndouble getsin(Point a , Point b){\n\tdouble t=getcos(a,b);\n\treturn sqrt(1.0-t*t);\n}\n\n//点pと直線abとの距離を求める\ndouble pld(Point p , Point a , Point b){\n\treturn fabs(cross(b - a,p - a))/abs(b-a);\n}\n\n//点pと線分abとの距離を求める\ndouble psd(Point p , Point a , Point b){\n\tif( dot( b-a , p-a ) < EPS) return abs(p-a);\n\tif( dot( a-b , p-b ) < EPS) return abs(p-b);\n\treturn fabs(cross( b-a , p-a )) / abs(b-a);\n}\n\n//線分交点計算\nPoint interpointS(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint b=b2-b1;\n\tdouble d1=fabs(cross(b , a1-b1));\n\tdouble d2=fabs(cross(b , a2-b1));\n\tdouble t=d1 / (d1 + d2);\n\tPoint a=a2-a1;\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線交点計算\nPoint interpointL(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint a=a2-a1;\n\tPoint b=b2-b1;\n\tdouble t=cross(b , b1-a1) / cross(b , a);\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線abと円及び球 |x-c|=rの交点を求める 　球の場合は型Point→Sに変更するだけ\nvoid interpointLC(Point a , Point b , Point c , double r , Point ans[]){\n\tif(pld(c , a , b) > r + EPS) return;\n\tPoint v=unitVector(b-a);\n\tdouble delta=dot(v,a-c)*dot(v,a-c)-abs(a-c)*abs(a-c)+r*r;\n\tdouble t=-dot(v,a-c);\n\tdouble s=sqrt(delta);\n\tans[0]=a+v*(t+s);\n\tans[1]=a+v*(t-s);\n}\n\n//１次変換集\n\n//ｘ（y=k）に関する対象変換 　k=0でｘ軸による変換\nPoint xTranslate(Point t,double k){\n\treturn Point(t.x , 2*k-t.y);\n}\n\n//ｙ(x=k)に関する対象変換\tk=0でｙ軸による変換\nPoint yTranslate(Point t,double k){\n\treturn Point(2*k-t.x , t.y);\n}\n\n//点Point kに関する対象変換\t\tPoint(0,0)で原点による変換\nPoint oTranslate(Point t,Point k){\n\treturn k+(k-t);\n}\n\n\n\n\n\n//点pを中心としてr(radian)回転\t\tp(0,0)で原点を中心として回転\nPoint rotate(Point t , Point p , double r){\n\t//double r=radians(angle);\n\tdouble ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n\tdouble tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n\treturn Point(ta , tb);\n}\n\n//応用\n//２円 |x-a|=raと|x-b|=rbの交点計算\nvoid interpointCC(Point a , double ra , Point b , double rb , Point ans[]){\n\tdouble di=fabs(abs(a-b));\n\tif(di > ra+rb || di < fabs(ra-rb)) return;\n\tdouble t=(ra*ra-rb*rb+di*di)/(di+di);\n\tdouble rd=acos(t/ra);\n\n\tPoint dv=unitVector(b-a);\n\tPoint g1=rotate(dv , Point(0,0) , rd);\n\tPoint g2=rotate(dv , Point(0,0) , -rd);\n\tans[0]=a+g1*ra;\n\tans[1]=a+g2*ra;\n}\n\n//法線ベクトルを求める\nPoint normalVector(Point p,Point a,Point b){\n\tPoint v=unitVector(b-a);\n\tv = cross(v , p-a) > 0 ?  Point(v.y,(-1)*v.x) : Point((-1)*v.y , v.x);\n\treturn v*pld(p,a,b);\n}\n\n//直線abに関する対象変換\nPoint fTranslate(Point t , Point a , Point b){\n\treturn t+normalVector(t,a,b)*2;\n}\n\n//３角形の面積を求める\ndouble area(Point a, Point b, Point c){\n\treturn fabs(cross(c-a , b-a)*0.5);\n}\n\n//多角形の面積を求める //凸包のソート済みが前提\ndouble polygonArea(Polygon t){\n\tdouble ans=0.0;\n\tfor(unsigned int i=0;i<t.size();i++)\n\t\tans+=cross(t[i] , t[(i+1)%t.size()]);\n\treturn ans/2;\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = static_cast<int>(ps.size());\n    Polygon qs(n * 2);\n    for (int i = 0; i < n; ++i) {\n      while (k > 1 && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    for (int i = n-2, t = k; i >= 0; --i) {\n      while (k > t && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    qs.resize(k-1);\n    return qs;\n}\n\nPolygon tri[100];\nint n, d;\n\nbool isIn(Polygon a, Polygon b)\n{\n\tfor (int i = 0; i < a.size(); i++) if (isInside(b, a[i])) return (true);\n\tfor (int i = 0; i < b.size(); i++) if (isInside(a, b[i])) return (true);\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tif (isIntersect(a[i], a[(i + 1) % a.size()], b[j], b[(j + 1) % b.size()])) return (true);\n\t\t}\n\t}\t\n\treturn (false);\n}\n\nPolygon normalize(Polygon a)\n{\n\tdouble di[3];\n\tfor (int i = 0; i < 3; i++){\n\t\tdi[i] = abs(a[i] - a[(i + 1) % 3]);\n\t}\n\t\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\tif (eq(di[i], di[j])){\n\t\t\t\tint cnt[3] = {0};\n\t\t\t\tcnt[i]++; cnt[(i + 1) % 3]++;\n\t\t\t\tcnt[j]++; cnt[(j + 1) % 3]++;\n\t\t\t\tfor (int k = 0; k < 3; k++){\n\t\t\t\t\tif (cnt[k] == 2){\n\t\t\t\t\t\tswap(a[k], a[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (ccw(a[0], a[1], a[2]) != COUNTER_CLOCKWISE) swap(a[0], a[1]);\n\t\n\treturn (a);\n}\n\nbool check(Polygon a, Polygon b)\n{\n\tPolygon c;\n\tc.push_back(a[0]); c.push_back(a[1]);\n\t\n\tPoint t = Point((a[0].x + a[1].x) / 2, (a[0].y + a[1].y) / 2);\n\tPoint k = a[2] - t;\n\tc.push_back(a[1] + k * (d / abs(k))); c.push_back(a[0] + k * (d / abs(k)));\n\t\n\treturn (isIn(c, b));\n}\n\nvector<int> G[128], rG[128];\nint ord[128], gr[128];\nbool vis[128];\nint ctr;\n\nvoid addEdge(int src, int dst)\n{\n\tG[src].push_back(dst);\n\trG[dst].push_back(src);\n}\n\nvoid dfs1(int v)\n{\n\tvis[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tif (!vis[G[v][i]]) dfs1(G[v][i]);\n\t}\n\tord[ctr++] = v;\n}\n\nvoid dfs2(int v, int k)\n{\n\tvis[v] = true;\n\tgr[v] = k;\n\tfor (int i = 0; i < rG[v].size(); i++){\n\t\tif (!vis[rG[v][i]]) dfs2(rG[v][i], k);\n\t}\n\t\n}\n\nint scc()\n{\n\tmemset(vis, 0, sizeof(vis));\n\tctr = 0;\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!vis[i]){\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\tint k = 0;\n\tmemset(vis, 0, sizeof(vis));\n\tfor (int i = n - 1; i >= 0; i--){\n\t\tif (!vis[ord[i]]){\n\t\t\tdfs2(ord[i], k++);\n\t\t}\n\t}\n\t\n\tint ret = k;\n\tmemset(vis, 0, sizeof(vis));\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < G[i].size(); j++){\n\t\t\tif (gr[i] != gr[G[i][j]]){\n\t\t\t\tret -= (1 ^ vis[gr[G[i][j]]]);\n\t\t\t\tvis[gr[G[i][j]]] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (ret);\n}\n\nint main()\n{\n\tPoint t;\n\twhile (scanf(\"%d %d\", &n, &d) && n + d){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tscanf(\"%lf %lf\", &t.x, &t.y);\n\t\t\t\ttri[i].push_back(Point(t.x, t.y));\n\t\t\t}\n\t\t\ttri[i] = normalize(tri[i]);\n\t\t\tG[i].clear(); rG[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (i != j && check(tri[i], tri[j])){\n\t\t\t\t\taddEdge(i, j);\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\t\n\t\t\n\t\tprintf(\"%d\\n\", scc());\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tif (contains(g, h[0])) return true;\n\tif (contains(h, g[0])) return true;\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc()\n{\n\tvector<int> vs;\n\tvector<bool> used(n);\n\tvector<int> cmp(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>> sccgraph = scc();\n\t\n\tvector<int> indeg(sccgraph.size());\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0) res++;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}*/\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\t/*for (int i = 0; i < g.size(); i++){\n\t\tSegment s(curr(g, i), next(g, i));\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(s, h[j]) <= EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}*/\n\tfor (int i = 0; i < h.size(); i++){\n\t\tSegment s(curr(h, i), next(h, i));\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(s, g[j]) <= EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tbool f = false;\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\t\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t\tf = true;\n\t\t}\n\t\tassert(f);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to] = 1;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<stack>\n#include<complex>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nconst double EPS = 1e-1;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > EPS)   return +1;       // counter clockwise\n  if (cross(b, c) < EPS)   return -1;       // clockwise\n\tassert(0);\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)+EPS) swap(a, b);\n    if (imag(a) < -EPS && EPS < imag(b))\n      if (cross(a, b) < -EPS) in = !in;\n    if (abs(cross(a, b)) < EPS  && dot(a, b) < EPS) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) < EPS &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) < EPS;\n}\nbool intersect(G &rect, G &tri){\n\trep(i,3)if(contains(rect,tri[i]))return 1;\n\trep(i,3){\n\t\tL l(tri[i],tri[(i+1)%3]);\n\t\trep(j,4)if(intersectSS(l,L(rect[i],rect[(i+1)%4])))return 1;\n\t}\n\treturn 0;\n}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight=0) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid visit(const Graph &g, int v, vector< vector<int> >& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  fr(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const Graph& g,\n    vector< vector<int> >& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint main(){\n\tint n;\n\tdouble d;\n\twhile(cin>>n>>d,n){\n\t\tvector<G> tri;\n\t\trep(i,n){\n\t\t\tdouble a,b,c,d,e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tG p; p.pb(P(a,b)); p.pb(P(c,d)); p.pb(P(e,f));\n\t\t\tif(abs(p[2]-p[0])!=abs(p[2]-p[1])){\n\t\t\t\tif(abs(p[2]-p[0])==abs(p[1]-p[0]))swap(p[2],p[0]);\n\t\t\t\telse swap(p[1],p[0]);\n\t\t\t}\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\tGraph e(n);\n\t\t\n\t\trep(i,n)rep(j,n)if(i!=j){\n\t\t\t\n\t\t\tG &p=tri[i];\n\t\t\tP m=(p[0]+p[1])*0.5,dir=(p[2]-m)*(d/abs(p[2]-m));\n\t\t\t\n\t\t\tG rect;\n\t\t\trect.pb(p[0]); rect.pb(p[1]);\n\t\t\trect.pb(p[1]+dir); rect.pb(p[0]+dir);\n\t\t\tif(ccw(rect[0],rect[1],rect[2])<0)reverse(rect.begin(),rect.end());\n\t\t\t\n\t\t\tif(intersect(rect,tri[j]))e[i].pb(Edge(i,j));\n\t\t}\n\t\t\n\t\tvector<vector<int> > scc;\n\t\tstronglyConnectedComponents(e,scc);\n\t\tint m=scc.size(),to[100],in[100]={0},ans=0;\n\t\trep(i,m)fr(j,scc[i])to[*j]=i;\n\t\trep(i,n)fr(j,e[i])if(to[i]!=to[j->dst])\n\t\tin[to[j->dst]]++;\n\t\t\n\t\trep(i,m)if(in[i]==0)ans++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tif (contains(g, h[0])) return true;\n\tif (contains(h, g[0])) return true;\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc()\n{\n\tvector<int> vs;\n\tvector<bool> used(n);\n\tvector<int> cmp(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>> sccgraph = scc();\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0) res++;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tbool f = false;\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\t\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t\tf = true;\n\t\t}\n\t\tassert(f);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to] = 1;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <cassert>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nconst double EPS = 0.01;\n\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\n \ndouble area(vector<P> p){\n\tdouble S = 0 ; \n\tp.push_back(p[0]);\n\t/*　多角形の面積公式 (反時計回りの場合) */\n\tfor(int i = 0 ; i < p.size()-1 ; i++){\n\t\tS += (p[i].real() - p[i+1].real()) * (p[i].imag()+p[i+1].imag());\n\t}\n\tS /= 2.0;\n\treturn S;\n}\nbool contains(vector<P> &a,P b){\n\t//b = (-10000,-10000);\n\tdouble ans = 0;\n\tfor(int i = 0 ; i < a.size() ; i++){\n\t\tvector<P> w;\n\t\tw.push_back(a[i]);\n\t\tw.push_back(a[(i+1)%a.size()]);\n\t\tw.push_back(b);\n\t\tans += abs(area(w));\n\t}\n\tans = abs(ans);\n\t//cout << a[0] << \" \" << a[1] << \" \" << a[2] << \" \" << a[3] << \" \" << b << \" \" << (fabs(abs(area(a)) - ans ) < EPS) << endl;\n\t//cout << ans << \" \" << abs(area(a)) << \" \" << a.size() << endl;\n\treturn fabs(abs(area(a)) - ans ) < EPS;\n}\n\n/*\n\t幾何: \n\t\t・凸多角形の点包含判定\n\t\t・凸多角形同士の線分交差判定\n\tグラフ:\n\t\t・強連結成分分解\n\t\t・入次数数える\n*/\n\nint n;\n\n\nbool eq(double a,double b){\n\treturn fabs(a-b) < EPS;\n}\n\nint wf[100][100]={};\n\nint main(){\n\tdouble d;\n\twhile(cin >> n >> d && n ){\n\t\tmemset(wf,0,sizeof(wf));\n\t\tfor(int i = 0 ; i < n ; i++) \n\t\t\twf[i][i] = 1;\n\t\tvector<G> g(n);\n\t\tvector<G> g2(n);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x1,x2,x3,y1,y2,y3;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\t\tg[i].push_back(P(x1,y1));\n\t\t\tg[i].push_back(P(x2,y2));\n\t\t\tg[i].push_back(P(x3,y3));\n\t\t\tdouble A = abs( P(x2,y2) - P(x1,y1) );\n\t\t\tdouble B = abs( P(x2,y2) - P(x3,y3) );\n\t\t\tdouble C = abs( P(x3,y3) - P(x1,y1) );\n\t\t\tL l(P(-1,-1),P(-1,-1));\n\t\t\tif( eq(A,B) ) l = L( P(x3,y3) , P(x1,y1) );\n\t\t\telse if( eq(A,C) ) l = L( P(x2,y2) , P(x3,y3) );\n\t\t\telse if( eq(B,C) ) l = L( P(x2,y2) , P(x1,y1) );\n\t\t\telse while(1){}\n\t\t\t\n\t\t\tassert( !( eq(A,B) && eq(B,C) ) );\n\t\t\tP r = l[1] - l[0];\n\t\t\tr = P(-r.imag(),r.real());\n\t\t\tr /= abs(r);\n\t\t\t\n\t\t\t//cout << A << \" \" << B << \" \" << C << \" \" << l[0] << \"-\" << l[1] << \" \" << r << endl;\n\t\t\tfor(int coef = -1 ; coef <= 1 ; coef += 2 ){\n\t\t\t\tvector<P> XX;\n\t\t\t\tXX.push_back(l[0]);\n\t\t\t\tXX.push_back(l[0] + coef * d * r );\n\t\t\t\tXX.push_back(l[1] + coef * d * r );\t\t\t\n\t\t\t\tXX.push_back(l[1]);\n\t\t\t\tint ok = 1;\n\t\t\t\t\n\t\t\t\tfor(int j = 0 ; j < 3 ; j++){\n\t\t\t\t\tif( !contains(XX,g[i][j]) ){\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( ok ) {\n\t\t\t\t\tif( g2[i].size() ) assert(0);\n\t\t\t\t\tg2[i] = XX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif( i != j ) {\n\t\t\t\t\tint ok = 0;\n\t\t\t\t\tfor(int l = 0 ; l < 3 ; l++){\n\t\t\t\t\t\tif( contains(g2[i],g[j][l]) ){\n\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0 ; k < 4 ; k++){\n\t\t\t\t\t\tfor(int l = k+1 ; l < 4 ; l++){\n\t\t\t\t\t\t\tfor(int m = 0 ; m < 3 ; m++){\n\t\t\t\t\t\t\t\tfor(int o = m+1 ; o < 3 ; o++){\n\t\t\t\t\t\t\t\t\tif( intersectSS(L(g2[i][k],g2[i][l]),L(g[j][m],g[j][o])) ){\n\t\t\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( ok ) {\n\t\t\t\t\t\twf[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\t\tfor(int k = 0 ; k < n ; k++)\n\t\t\t\t\twf[j][k] |= wf[j][i] & wf[i][k];\n\t\n\t\t\n\t\tint in[100] = {} , id[100] = {} , cur = 0;\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tid[i] = -1;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif( id[i] == -1 ){\n\t\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\t\tif( wf[i][j] & wf[j][i] ){\n\t\t\t\t\t\tid[j] = cur;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif(wf[i][j] && id[i] != id[j]) in[j]++;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif( !in[i] ){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-1;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\t//if (intersect(u, v)) return true;\n\t\t\tif (distance(u, v) < EPS) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tSegment s(curr(g, i), next(g, i));\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(s, h[j]) < 0.01 + EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tSegment s(curr(h, i), next(h, i));\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(s, g[j]) < 0.01 + EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs(0);\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(norm(b - a), norm(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tVector a = tri[i][1] - tri[i][0];\n\t\tVector nv = tri[i][0] + (a / 2.0);\n\t\tnv = tri[i][2] - nv;\n\t\tnv /= abs(nv);\n\t\tnv *= d;\n\t\t\n\t\tsqr[i][0] = tri[i][0];\n\t\tsqr[i][1] = tri[i][1];\n\t\tsqr[i][2] = tri[i][1] + nv;\n\t\tsqr[i][3] = tri[i][0] + nv;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tsqr[i].resize(4);\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-7\n ;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<unordered_map>\n#define eps 1e-9\nusing namespace std;\n\ntypedef complex<double> point;\ntypedef pair<point, point> pp;\n\n//??????\ndouble dot(point a, point b){\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\n//??????\ndouble cross(point a, point b){\n  return imag(conj(a) * b);\n}\n\n//counter clock wise\nint ccw(point a, point b, point c){\n  if(cross(b - a, c - a) >  eps)return  1;//??????ab????????´\n  if(cross(b - a, c - a) < -eps)return -1;//??????ab????????´\n  if(dot(b - a, c - a) < -eps)return 2;//??´???ab??????a???????????????\n  if(abs(b - a) + eps < abs(c - a))return -2;//??´???ab??????b???????????????\n  return 0;//??´???ab???\n}\ntypedef struct door{\n  double r;\n  point x, y, z, a, b;\n  point rot(point p, double theta){\n    return point(p.real()*cos(theta) +\n                 p.imag()*sin(theta),\n                 -p.real()*sin(theta) +\n                 p.imag()*cos(theta));\n  }\n  void rectangle(){\n    point p = y - x;\n    if(ccw(x, y, z) == -1){\n      p = rot(p, M_PI/2.0);\n    }else if(ccw(x, y, z) == 1){\n      p = rot(p, -M_PI/2.0);\n    }\n    p *= r/abs(p);\n    a = y;\n    b = x + p;\n  }\n}door;\n\nbool isCover(door from, door to){\n  point p[4];\n  p[0] = from.x;\n  p[1] = from.y;\n  p[2] = from.y + (from.b - from.x);\n  p[3] = from.b;\n\n  int f = ccw(p[0], p[1], to.x);\n  bool flag = true;\n  for (int i = 1; i < 4; i++) {\n    if(ccw(p[i], p[(i + 1)%4], to.x) != f and\n       ccw(p[i], p[(i + 1)%4], to.x) != 0)\n      flag = false;\n  }\n  if(flag)return true;\n  f = ccw(p[0], p[1], to.y);\n  for (int i = 1; i < 4; i++) {\n    if(ccw(p[i], p[(i + 1)%4], to.y) != f and\n       ccw(p[i], p[(i + 1)%4], to.y) != 0)\n      return false;\n  }\n  return true;\n}\n\nvoid dfs(vector<vector<int> > &g,\n         vector<int> &vs, int v, bool* used){\n  used[v] = true;\n  for (int i = 0; i < g[v].size(); i++) {\n    if(not used[g[v][i]])dfs(g, vs, g[v][i], used);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(vector<vector<int> > &rg,\n          vector<int> &cmp, int v, int k, bool* used){\n  used[v] = true;\n  cmp[v] = k;\n  for (int i = 0; i < rg[v].size(); i++) {\n    if(not used[rg[v][i]])\n      rdfs(rg, cmp, rg[v][i], k, used);\n  }\n}\n\nvector<vector<int> > scc(vector<vector<int> > &g,\n                         vector<vector<int> > &rg){\n  bool used[g.size()];\n  memset(used, false, sizeof(used));\n  vector<int> vs, cmp(g.size(), -1);\n  for (int i = 0; i < g.size(); i++) {\n    if(not used[i])dfs(g, vs, i, used);\n  }\n  memset(used, false, sizeof(used));\n  int k = 0;\n  for (int i = vs.size() -  1; i >= 0; i--) {\n    if(not used[vs[i]]) rdfs(rg, cmp, vs[i], k++, used);\n  }\n  unordered_map<int, int> hash;\n  for (int i = 0; i < cmp.size(); i++) {\n    hash[i] = cmp[i];\n  }\n  vector<vector<int> > res(hash.size());\n  for (int i = 0; i < g.size(); i++) {\n    for (int j = 0; j < g[i].size(); j++) {\n      res[hash[i]].push_back(hash[g[i][j]]);\n    }\n  }\n  // for (int i = 0; i < res.size(); i++) {\n  //   std::cout << \"res[\" << i << \"]:\" << std::endl;\n  //   for (int j = 0; j < res[i].size(); j++) {\n  //     std::cout << res[i][j] << std::endl;\n  //   }\n  // }\n  return res;\n}\n\nint main(){\n  int n, r;\n  while(std::cin >> n >> r, n){\n    door d[n];\n    for (int i = 0; i < n; i++) {\n      int a, b;\n      std::cin >> a >> b;\n      d[i].x = point(a, b);\n    \n      std::cin >> a >> b;\n      d[i].y = point(a, b);\n    \n      std::cin >> a >> b;\n      d[i].z = point(a, b);\n      d[i].r = r;\n      d[i].rectangle();\n    }\n    vector<vector<int> > g(n), rg(n);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if(isCover(d[i], d[j])){\n          g[i].push_back(j);\n        }\n      }\n    }\n    for (int i = 0; i < g.size(); i++) {\n      for (int j = 0; j < g[i].size(); j++) {\n        rg[g[i][j]].push_back(i);\n      }\n    }\n    vector<vector<int> > dag = scc(g, rg);\n    int ans = 0;\n    for (int i = 0; i < dag.size(); i++) {\n      if(dag[i].size() == 0)ans++;\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-1;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\t//if (intersect(u, v)) return true;\n\t\t\tif (distance(u, v) < EPS) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tSegment s(curr(g, i), next(g, i));\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(s, h[j]) < 0.01 + EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tSegment s(curr(h, i), next(h, i));\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(s, g[j]) < 0.01 + EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs(0);\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(norm(b - a), norm(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tVector a = tri[i][1] - tri[i][0];\n\t\tVector nv = tri[i][0] + (a / 2.0);\n\t\tnv = tri[i][2] - nv;\n\t\tnv /= abs(nv);\n\t\tnv *= d;\n\t\t\n\t\tsqr[i][0] = tri[i][0];\n\t\tsqr[i][1] = tri[i][1];\n\t\tsqr[i][2] = tri[i][1] + nv;\n\t\tsqr[i][3] = tri[i][0] + nv;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tsqr[i].resize(4);\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-9;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0)\n\t    swap(rect[i][0],rect[i][1]);\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k])){\n\t    f = true; break;\n\t  }\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int edges[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])edges[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!edges[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\n#define MAX_N (128)\n#define EPS (1e-5)\n#define SQ(X) ((X) * (X))\n#define EQ(a, b) (fabs(a - b) <= EPS)\n#define D1 (-1)\n#define D2 (1)\n#define ONLINE (0)\n\nusing namespace std;\n\nclass Triangle {\n\tpublic:\n        double x[3], y[3];\n\t    int no;\n};\n\nclass Point {\n    public:\n    \tdouble x, y;\n        \n\t    Point operator - (Point &a){\n            Point ret;\n\t\t    ret.x = x - a.x;\n\t\t    ret.y = y - a.y;\n\t\t    return (ret);\n\t    }\n};\n\nvector<int> G[MAX_N];\nvector<int> rG[MAX_N];\nvector<int> compress[MAX_N];\nvector<int> vs;\nbool used[MAX_N];\nbool group[MAX_N];\nint cmp[MAX_N];\nint N;\n\nvoid addEdge(int from, int to)\n{\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v)\n{\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++){\n        if (!used[G[v][i]]){\n            dfs(G[v][i]);\n        }\n    }\n    vs.push_back(v);\n}\n\nvoid revDfs(int v, int k)\n{\n    used[v] = true;\n    cmp[v] = k;\n    for (int i = 0; i < rG[v].size(); i++){\n        if (!used[rG[v][i]]){\n            revDfs(rG[v][i], k);\n        }\n    }\n}\n\nint scc()\n{\n    int ret;\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    \n    for (int i = 0; i < N; i++){\n        if (!used[i]){\n            dfs(i);\n        }\n    }\n    \n    memset(used, 0, sizeof(used));\n    \n    ret = 0;\n    for (int i = vs.size() - 1; i >= 0; i--){\n        if (!used[vs[i]]){\n            revDfs(vs[i], ret++);\n        }\n    }\n    \n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < G[i].size(); j++){\n            if (cmp[i] != cmp[G[i][j]]){\n                compress[cmp[G[i][j]]].push_back(cmp[i]);\n            }\n        }\n    }\n    \n    return (ret);\n}\n\ndouble inProduct(Point a, Point b)\n{\n\treturn (a.x * b.x + a.y * b.y);\n}\n\ndouble getSize(Point a)\n{\n\treturn (sqrt(SQ(a.x) + SQ(a.y)));\n}\n\nint checkCross(Point p1, Point p2, Point p3)\n{\n    Point vecA = p2 - p1, vecB = p3 - p1;\n    double D = vecA.x * vecB.y - vecB.x * vecA.y;\n    if (EQ(0, D)){\n        return (ONLINE);\n    }\n    else if (D > 0){\n        return (D1);\n    }\n    return (D2);\n}\n\nvoid judgeAdj(Triangle a, Triangle b, double dist)\n{\n\tdouble len;\n\tPoint p[4];\n\t\n\tlen = 0.0;\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\tif (len < SQ(a.x[i] - a.x[j]) + SQ(a.y[i] - a.y[j])){\n\t\t\t\tlen = SQ(a.x[i] - a.x[j]) + SQ(a.y[i] - a.y[j]);\n\t\t\t\tp[0].x = a.x[i], p[0].y = a.y[i];\n\t\t\t\tp[1].x = a.x[j], p[1].y = a.y[j];\n\t\t\t}\n\t\t}\n\t}\n    //printf(\"%lf %lf %lf %lf\\n\", p[0].x, p[0].y, p[1].x, p[1].y);\n\tPoint e, sa;\n\t\n    e.x = 0, e.y = 1;\n\tsa = p[0] - p[1];\n\tdouble theta = acos(inProduct(e, sa) / (getSize(e) * getSize(sa)));\n    theta = min(theta, M_PI - theta);\n\t//printf(\"theta = %lf\\n\", theta);\n    \n\tp[2].x = p[0].x + dist * cos(theta), p[2].y = p[0].y + dist * sin(theta);\n\tp[3].x = p[1].x + dist * cos(theta), p[3].y = p[1].y + dist * sin(theta);\n\t\n\tbool cross = false;\n\t\n    for (int i = 0; i < 3; i++){\n        bool judge = true;\n        Point k;\n        k.x = b.x[i], k.y = b.y[i];\n    \tjudge &= (checkCross(p[0], p[1], k) * checkCross(p[2], p[3], k) <= 0);\n\t    judge &= (checkCross(p[0], p[2], k) * checkCross(p[1], p[3], k) <= 0);\n        cross |= judge;\n    }\n    \n\tif (cross == true){\n        //printf(\"hoge, %d, %d\\n\", a.no, b.no);\n\t\taddEdge(a.no, b.no);\n\t}\n\t\n}\n\nint main()\n{\n\tint n, d;\n\tTriangle data[128];\n\t\n\twhile (1){\n\t\t\n\t\tscanf(\"%d%d\", &n, &d);\n\t\t\n        N = n;\n\t\tif (n + d == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tdata[i].no = i;\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tscanf(\"%lf%lf\", &data[i].x[j], &data[i].y[j]);\n\t\t\t}\n\t\t}\n\t\t\n        for (int i = 0; i < n; i++){\n            G[i].clear();\n            rG[i].clear();\n            compress[i].clear();\n        }\n        \n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n                if (i != j){\n    \t\t\t\tjudgeAdj(data[i], data[j], d);\n                }\n\t\t\t}\n\t\t}\n\t\t\n\t\tint k = scc();\n    \t\n    \tint ans = 0;\n    \tmemset(used, 0, sizeof(used));\n    \t\n    \tfor (int i = 0; i < k; i++){\n        \tif (compress[i].size() == 0){\n        \t    ans++;\n        \t}\n    \t}\n    \t\n    \tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<unordered_map>\n#define eps 1e-9\nusing namespace std;\n\ntypedef complex<double> point;\n\n//??????\ndouble dot(point a, point b){\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\n//??????\ndouble cross(point a, point b){\n  return imag(conj(a) * b);\n}\n\n//counter clock wise\nint ccw(point a, point b, point c){\n  if(cross(b - a, c - a) >  eps)return  1;//??????ab????????´\n  if(cross(b - a, c - a) < -eps)return -1;//??????ab????????´\n  if(dot(b - a, c - a) < -eps)return 2;//??´???ab??????a???????????????\n  if(abs(b - a) + eps < abs(c - a))return -2;//??´???ab??????b???????????????\n  return 0;//??´???ab???\n}\ntypedef struct door{\n  double r;\n  point x, y, z, p;\n  point rot(point p, double theta){\n    return point(p.real()*cos(theta) +\n                 p.imag()*sin(theta),\n                 -p.real()*sin(theta) +\n                 p.imag()*cos(theta));\n  }\n  void rectangle(){\n    p = y - x;\n    if(ccw(x, y, z) == -1){\n      p = rot(p, M_PI/2.0);\n    }else if(ccw(x, y, z) == 1){\n      p = rot(p, -M_PI/2.0);\n    }\n    p *= r/abs(p);\n  }\n}door;\n\nclass SCC{\npublic:\n  SCC(vector<vector<int> > g_):g(g_){\n    rg.resize(g.size());\n    for (int i = 0; i < g.size(); i++) {\n      for (int j = 0; j < g[i].size(); j++) {\n        rg[g[i][j]].push_back(i);\n      }\n    }\n  };\n  void makeScc();\n  int size(){return g.size();};\n  int sccSize(){return scc.size();};\n  vector<vector<int> > g, scc;\nprivate:\n  void dfs(int v, bool *used);\n  void rdfs(int v, int k, bool *used);\n  vector<vector<int> > rg;\n  vector<int> vs, cmp;\n};\n\nvoid SCC::makeScc() {\n  bool used[g.size()];\n  memset(used, false, sizeof(used));\n  vs.resize(g.size());\n  cmp.resize(g.size(), -1);\n  for (int i = 0; i < g.size(); i++) {\n    if(not used[i])dfs(i, used);\n  }\n  memset(used, false, sizeof(used));\n  int k = 0;\n  for (int i = vs.size() -  1; i >= 0; i--) {\n    if(not used[vs[i]]) rdfs(vs[i], k++, used);\n  }\n  unordered_map<int, int> hash;\n  for (int i = 0; i < cmp.size(); i++) {\n    hash[i] = cmp[i];\n  }\n  scc.resize(hash.size());\n  for (int i = 0; i < g.size(); i++) {\n    for (int j = 0; j < g[i].size(); j++) {\n      scc[hash[g[i][j]]].push_back(hash[i]);\n    }\n  }\n}\nvoid SCC::dfs(int v, bool *used) {\n  used[v] = true;\n  for (int i = 0; i < g[v].size(); i++) {\n    if(not used[g[v][i]])dfs(g[v][i], used);\n  }\n  vs.push_back(v);\n}\nvoid SCC::rdfs(int v, int k, bool* used){\n  used[v] = true;\n  cmp[v] = k;\n  for (int i = 0; i < rg[v].size(); i++) {\n    if(not used[rg[v][i]])\n      rdfs(rg[v][i], k, used);\n  }\n}\n\nbool isCover(door from, door to){\n  point p[4];\n  p[0] = from.x;\n  p[1] = from.y;\n  p[2] = from.y + from.p;\n  p[3] = from.x + from.p;\n\n  int f = ccw(p[0], p[1], to.x);\n  bool flag = true;\n  if(f != 1 and f != -1 and f != 0)flag = false;\n  for (int i = 1; i < 4; i++) {\n    if(ccw(p[i], p[(i + 1)%4], to.x) != f and\n       ccw(p[i], p[(i + 1)%4], to.x) != 0)\n      flag = false;\n  }\n  if(flag)return true;\n  f = ccw(p[0], p[1], to.y);\n  if(f != 1 and f != -1 and f != 0)return 0;\n  for (int i = 1; i < 4; i++) {\n    if(ccw(p[i], p[(i + 1)%4], to.y) != f and\n       ccw(p[i], p[(i + 1)%4], to.y) != 0)\n      return false;\n  }\n  return true;\n}\n\n\n\n\nint main(){\n  int n, r;\n  while(std::cin >> n >> r, n){\n    door d[n];\n    for (int i = 0; i < n; i++) {\n      int a, b;\n      std::cin >> a >> b;\n      d[i].x = point(a, b);\n    \n      std::cin >> a >> b;\n      d[i].y = point(a, b);\n    \n      std::cin >> a >> b;\n      d[i].z = point(a, b);\n      d[i].r = r;\n      d[i].rectangle();\n    }\n    vector<vector<int> > g(n), rg(n);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if(isCover(d[i], d[j])){\n          g[i].push_back(j);\n          rg[j].push_back(i);\n        }\n      }\n    }\n    SCC dag(g);\n    dag.makeScc();\n    int ans = 0;\n    for (int i = 0; i < dag.sccSize(); i++) {\n      if(dag.scc[i].size() == 0)ans++;\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-6)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) * SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G &a, G &b)\n{\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)) return true;\n\t\t}\n\t}\n\tfor (int i = 0; i < a.size(); i++){\n\t\tif (contains(b, a[i])) return true;\n\t}\n\tfor (int i = 0; i < b.size(); i++){\n\t\tif (contains(a, b[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) res++;\n\t\tfor (int to : sccgraph[i]){\n\t\t\tused[to] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-8, AD = 1e-2;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(abs(cross(a.sc-a.fs,b.sc-b.fs))<EPS)\n    return (min(min(seg_p_dis(a,b.fs),seg_p_dis(a,b.sc)),\n\t\tmin(seg_p_dis(b,a.fs),seg_p_dis(b,a.sc)))<EPS);\n  if(cross(a.sc-a.fs,b.fs-a.fs)*cross(a.sc-a.fs,b.sc-a.fs)>0)return false;\n  if(cross(a.fs-a.sc,b.fs-a.sc)*cross(a.fs-a.sc,b.sc-a.sc)>0)return false;\n  if(cross(b.sc-b.fs,a.fs-b.fs)*cross(b.sc-b.fs,a.sc-b.fs)>0)return false;\n  return (cross(b.fs-b.sc,a.fs-b.sc)*cross(b.fs-b.sc,a.sc-b.sc)>0);\n}\n\n/*\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n*/\n\nD area(P a,P b,P c){\n  return abs(cross(a,b)+cross(b,c)+cross(c,a));\n}\n\nbool inter_pos(Poly p,P x,D A){\n  D a = 0; int s = p.size();\n  rep(i,n)a += area(p[i],p[(i+1)%s],x);\n  return (a==A);\n}\n\n/*\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n*/\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0){\n\t    swap(rect[i][0],rect[i][1]); break;\n\t  }\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k],abs(rect[i][0]-rect[i][1])*d)){\n\t    f = true; break;\n\t  }\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3)if(seg_p_dis(rseg,tri[j][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,3){\n\t    L tseg = L(tri[j][k],rect[j][(k+1)%3]);\n\t    rep(l,4)if(seg_p_dis(tseg,rect[i][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-3;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nint V;\nvector<vector<int> > G,rG;\nvector<int> vs;\nbool used[100];\nint cmp[100];\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]){\n      dfs(G[v][i]);\n    }\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]){\n      rdfs(rG[v][i],k);\n    }\n  }\n}\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[2])>eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    G=rG=vector<vector<int> >(n);\n    vs.clear();\n    bool e[100][100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<-eps;\n\t      e[i][j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    e[i][j]|=!f;\n\t    if(e[i][j]){\n\t      G[i].push_back(j);\n\t      rG[j].push_back(i);\n\t    }\n\t  }\n\t}\n      }\n    }\n    V=n;\n    fill(begin(used),end(used),false);\n    for(int v=0;v<V;v++){\n      if(!used[v]){\n\tdfs(v);\n      }\n    }\n    fill(begin(used),end(used),false);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]]){\n\trdfs(vs[i],k++);\n      }\n    }\n    bool in[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(e[i][j]&&cmp[i]!=cmp[j]){\n\t  in[j]=true;\n\t}\n      }\n    }\n    cout<<count(in,in+k,false)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-5;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[0])<eps||fabs(l[2]-l[0])<eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    bool c[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<-eps;\n\t      c[j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    c[j]|=!f;\n\t  }\n\t}\n      }\n    }\n    cout<<max<int>(1,count(c,c+n,false))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-10;\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      //if (     cross(a[in[0]]-a[in[1]],a[in[2]]-a[in[1]]) >=0)\n      //\tassert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])>=0);\n      //      else assert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])<=0);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  //assert(false);\n  return ret;\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\n#define DSS distance_ls_p\ndouble distance_ss_p(P a,P b,P c,P d){\n  return min(  min( DSS(a,b,c),DSS(a,b,d)),min(DSS(c,d,a),DSS(c,d,b)));\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri,double d){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }else {\n\trep(k,tri[j].size()){\n\t  if (is_in(tri[i],tri[j][k])&&\n\t      (distance_ss_p(sq[i][0],sq[i][1],tri[j][0],tri[j][1])<d+eps ||\n\t       distance_ss_p(sq[i][0],sq[i][1],tri[j][1],tri[j][2])<d+eps||\n\t       distance_ss_p(sq[i][0],sq[i][1],tri[j][2],tri[j][0])<d+eps)\n\t      ){\n\t    assert(false);\n\t    inedge[i].pb(j);\n\t    redge[j].pb(i);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in,d);\n\n\n    //rep(i,n){rep(j,sq[i].size())cout<< sq[i][j];cout << endl;}\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 101;\nconst double EPS = 0.01;\nconst double PI = acos(-1.0);\n\n// 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n\n// 点クラス\nstruct P {\n\tdouble x, y;\n\tP(double x_, double y_) { x = x_; y = y_; }\n\tP(){}\n\t// 加算, 減算, スカラー倍\n\tP operator+(const P& a) const {\n\t\treturn P(x + a.x, y + a.y);\n\t}\n\tP operator-(const P& a) const {\n\t\treturn P(x - a.x, y - a.y);\n\t}\n\tP operator*(const P& a) const {\n\t\treturn P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP operator*(double c) const {\n\t\treturn P(x * c, y * c);\n\t}\n\tP operator/(const P& a) const {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\treturn P(x_, y_);\n\t}\n\tP operator/(double c) const {\n\t\treturn P(x / c, y / c);\n\t}\n\tP& operator+=(const P& a) {\n\t\tx += a.x; y += a.y;\n\t}\n\tP& operator-=(const P& a) {\n\t\tx -= a.x; y -= a.y;\n\t}\n\tP& operator*=(const P& a) {\n\t\t*this = P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP& operator*=(double c) {\n\t\t*this = P(x * c, y * c);\n\t}\n\tP& operator/=(const P& a) {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\t*this = P(x_, y_);\n\t}\n\tP& operator/=(double c) {\n\t\t*this = P(x / c, y / c);\n\t}\n};\nP operator*(double c, P a){\n\treturn P(a.x * c, a.y * c);\n}\n// 比較演算子\nbool operator==(const P& a, const P& b) {\n\treturn equal(a.x, b.x) && equal(a.y, b.y);\n}\nbool operator!=(const P& a, const P& b) {\n\treturn !(a == b);\n}\nbool operator<(const P& a, const P& b) {\n\treturn (a.x != b.x)? a.x < b.x : a.y < b.y;\n}\n\n// 原点からの距離(絶対値)\ndouble abs(P a) {\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\n\n// ベクトル a の単位ベクトルを求める\nP unit(P a) {\n\treturn a / abs(a);\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n\tb -= a, c -= a;\n\tif( cross(b,c) >  EPS ) return CCW; // CCW : 反時計回り\n\tif( cross(b,c) < -EPS ) return CW;  // CW : 時計回り\n\tif( dot(b, c)  < -EPS ) return +2;  // c--a--b on line\n\tif( dot(b, b)  + EPS < dot(c, c) ) return -2; // a--b--c on line \n\treturn ON;\n}\n\n// 直線クラス\nstruct Line : public vector<P> {\n\tLine(){}\n\tLine(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tLine(const vector<P>& vp){\n\t\t(*this) = vp;\n\t}\n};\n\n// 2つの直線の平行判定\nbool is_parallel(const Line& a, const Line& b) {\n\treturn equal( cross( a[0] - a[1] , b[0] - b[1] ), 0.0 );\n}\n\n// 線分 s と 線分 t の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\t   ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\n// 線分 (a, b) 上に点 p があるかどうか\nbool contain(P a, P b, const P& p) {\n\treturn abs(a - p) + abs(b - p) - abs(b - a) < EPS;\n}\n\nstruct Triangle{\nprivate:\n\t// 余弦定理から 3 つの角の角度を求める (内部の関数で使用)\n\tdouble law_of_cos(double a, double b, double c) {\n\t\treturn acos( (b*b + c*c - a*a) / (2.0 * b * c) );\n\t}\n\t// 点 a , b を端点とする線分に点 c が含まれているかどうか\n\tbool contain(P a, P b, P c) {\n\t\treturn abs(a - c) + abs(b - c) - abs(b - a) < EPS;\n\t}\npublic:\n\t// 3 つの頂点\n\tP a, b, c;\n\t// 3 つの辺の長さ\n\tdouble edgeA, edgeB, edgeC;\n\t// 3 つの角の角度 (ラジアン)\n\tdouble angleA,angleB,angleC;\n\t// コンストラクタで初期化\n\tTriangle(P p1, P p2, P p3) {\n\t\ta = p1; b = p2; c = p3;\n\t\tedgeB = abs(c-a);\n\t\tedgeA = abs(b-c);\n\t\tedgeC = abs(a-b);\n\t\tangleA = law_of_cos( edgeA, edgeB, edgeC );\n\t\tangleB = law_of_cos( edgeB, edgeC, edgeA );\n\t\tangleC = law_of_cos( edgeC, edgeA, edgeB );\n\t}\n\t// 点 p が三角形の辺上にあるかどうか\n\tbool on_boundary(P p) {\n\t\treturn contain(a, b, p) || contain(b, c, p) || contain(c, a, p);\n\t}\n\t// 点 p が三角形の内部にあるかどうか ( AOJ 0012 で検証済み )\n\tbool is_inside(P p) {\n\t\t// 辺上にあるとき\n\t\tif( this->on_boundary(p) ) return true;\n\t\t\n\t\tTriangle t1( a , b , p );\n\t\tTriangle t2( b , c , p );\n\t\tTriangle t3( c , a , p );\n\t\t// 角APB + 角BPB + 角CPA が 360度なら 点 p は三角形の内部にある\n\t\treturn equal( t1.angleC + t2.angleC + t3.angleC , 2.0 * PI );\n\t}\n};\n\n\n\nint n, d;\ndouble x1[MAX_N], x2[MAX_N], x3[MAX_N], x4[MAX_N], x5[MAX_N];\ndouble y1_[MAX_N], y2[MAX_N], y3[MAX_N], y4[MAX_N], y5[MAX_N];\nvector<int> G[MAX_N];\nvector<int> rG[MAX_N];\nvector<int> vs;\nbool used[MAX_N] = {0};\nint cmp[MAX_N], u[MAX_N];\n \nvoid dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0 ; i < G[v].size() ; i++ ){\n\t\tif( !used[G[v][i]] ) dfs(G[v][i]);\n\t}\n\tvs.push_back(v);\n}\n \nvoid rdfs(int v, int k){\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor(int i = 0 ; i < rG[v].size() ; i++ ){\n\t\tif( !used[rG[v][i]] ) rdfs(rG[v][i], k); \n\t}\n}\n \nint scc(){\n\tfill(used, used + MAX_N, false);\n\tvs.clear();\n\tfor(int i = 0 ; i < n ; i++ ){\n\t\tif( !used[i] ) dfs(i);\n\t}\n\tfill(used, used + MAX_N, false);\n\tint k = 0;\n\tfor(int i = vs.size() - 1 ; i >= 0 ; i-- ){\n\t\tif( !used[vs[i]] ) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\n\n// i の矩形が j の三角形と接するかどうか\nbool is_intersect(int i, int j){\n\tvector<Line> l1, l2;\n\tl1.push_back(Line(P(x1[i], y1_[i]), P(x2[i], y2[i])));\n\tl1.push_back(Line(P(x1[i], y1_[i]), P(x4[i], y4[i])));\n\tl1.push_back(Line(P(x3[i], y3[i]), P(x5[i], y5[i])));\n\tl1.push_back(Line(P(x4[i], y4[i]), P(x5[i], y5[i])));\n\t\n\tl2.push_back(Line(P(x1[j], y1_[j]), P(x2[j], y2[j])));\n\tl2.push_back(Line(P(x2[j], y2[j]), P(x3[j], y3[j])));\n\tl2.push_back(Line(P(x3[j], y3[j]), P(x1[j], y1_[j])));\n\tfor(int a=0 ; a < l1.size() ; a++ ){\n\t\tfor(int b=0 ; b < l2.size() ; b++ ){\n\t\t\t/*cout << \"(\" << l1[a][0].x << \",\" << l1[a][0].y << \")\";\n\t\t\tcout << \", (\" << l1[a][1].x << \",\" << l1[a][1].y << \") - \";\n\t\t\tcout << \"(\" << l2[b][0].x << \",\" << l2[b][0].y << \")\";\n\t\t\tcout << \", (\" << l2[b][1].x << \",\" << l2[b][1].y << \")\" << endl;*/\n\t\t\t// 矩形と三角形の線分が交差しているかどうか\n\t\t\tif( !is_parallel(l1[a], l2[b]) && intersectSS(l1[a], l2[b]) ){\n\t\t\t\t//cout << \"line intersect!\" << endl;\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<P> sect;\n\tsect.push_back(P(x1[i], y1_[i]));\n\tsect.push_back(P(x2[i], y2[i]));\n\tsect.push_back(P(x4[i], y4[i]));\n\tsect.push_back(P(x5[i], y5[i]));\n\t\n\tvector<P> T;\n\tT.push_back(P(x1[j], y1_[j]));\n\tT.push_back(P(x2[j], y2[j]));\n\tT.push_back(P(x3[j], y3[j]));\n\tfor(int k=0 ; k < T.size() ; k++ ){\n\t\tTriangle t1(sect[0], sect[1], sect[2]);\n\t\tTriangle t2(sect[3], sect[1], sect[2]);\n\t\tif( t1.is_inside(T[k]) || t2.is_inside(T[k]) ) {\n\t\t\t/*cout << \"contain\" << endl << \"sect:\" << endl;\n\t\t\tcout << \"(\" << sect[0].x << \",\" << sect[0].y << \")\" << endl;\n\t\t\tcout << \"(\" << sect[1].x << \",\" << sect[1].y << \")\" << endl;\n\t\t\tcout << \"(\" << sect[2].x << \",\" << sect[2].y << \")\" << endl;\n\t\t\tcout << \"(\" << sect[3].x << \",\" << sect[3].y << \")\" << endl;\n\t\t\tcout << \"P:\" << \"(\" << T[k].x << \",\" << T[k].y << \")\" << endl;*/\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint solve(){\n\t// 矩形を求める\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tP p1(x1[i], y1_[i]), p2(x2[i], y2[i]), p3(x3[i], y3[i]);\n\t\tP mp = (p1 + p2) / 2.0;\n\t\tP pp = unit(p3 - mp) * d;\n\t\tP p4 = p1 + pp;\n\t\tP p5 = p2 + pp;\n\t\tx4[i] = p4.x, y4[i] = p4.y, x5[i] = p5.x, y5[i] = p5.y;\n\t}\n\t// 三角形から出る光(矩形)が他の三角形と接しているか\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\tif( i == j ) continue;\n\t\t\t\n\t\t\t// i の矩形が j の三角形と接するとき\n\t\t\tif( is_intersect(i, j) ){\n\t\t\t\t//cout << \"i:\" << i << \", j:\" << j << endl;\n\t\t\t\tG[i].push_back(j);\n\t\t\t\trG[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// 強連結成分分解(蟻本に頼った)をして, 入次数0の頂点の数を数える\n\tint k = scc();\n\tfor(int i = 0 ; i < n ; i++ ){\n\t\tu[cmp[i]] = i;\n\t}\n\tfill(used, used + MAX_N, false);\n\tint ans = 0;\n\tfor(int i = 0 ; i < k ; i++ ){\n\t\tif( !used[u[i]] ){\n\t\t\tdfs(u[i]);\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\twhile( cin >> n >> d, n || d ){\n\t\tfill(G, G + MAX_N, vector<int>());\n\t\tfill(rG, rG + MAX_N, vector<int>());\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tcin >> x1[i] >> y1_[i] >> x2[i] >> y2[i] >> x3[i] >> y3[i];\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 0.02;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nint g[110][110];\nPt p[110][3];\nint UF[110];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[i][i]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble ax,bx,cx,ay,by,cy;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n\t\t\tdouble A=(bx-cx)*(bx-cx)+(by-cy)*(by-cy);\n\t\t\tdouble B=(ax-cx)*(ax-cx)+(ay-cy)*(ay-cy);\n\t\t\tdouble C=(ax-bx)*(ax-bx)+(ay-by)*(ay-by);\n\t\t\tif(ABS(A-B)<EPS){\n\t\t\t\tp[i][0]=Pt(ax,ay);p[i][1]=Pt(bx,by);p[i][2]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(B-C)<EPS){\n\t\t\t\tp[i][2]=Pt(ax,ay);p[i][0]=Pt(bx,by);p[i][1]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(C-A)<EPS){\n\t\t\t\tp[i][1]=Pt(ax,ay);p[i][2]=Pt(bx,by);p[i][0]=Pt(cx,cy);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)if(iSP(p[i][0],p[i][2],p[i][1])==-1)swap(p[i][0],p[i][1]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tif(i==j)continue;\n\t\t\tPt t[4];\n\t\t\tt[0]=p[i][0];\n\t\t\tt[1]=p[i][1];\n\t\t\tt[3]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[3]=t[0]+t[3]/t[3].ABS()*(double)b;\n\t\t\tt[2]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[2]=t[1]+t[2]/t[2].ABS()*(double)b;\n\t\t\tbool ok=false;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][k]+(p[j][(k+1)%3]-p[j][k])*10000.0)&&\n\t\t\t\t\tiSS(t[l],t[(l+1)%4],p[j][(k+1)%3],p[j][(k+1)%3]+(p[j][k]-p[j][(k+1)%3])*10000.0))ok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tg[i][j]=1;\n\t\t//\t\tprintf(\"%d %d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]|=g[i][k]&g[k][j];\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)if(g[i][j]&&g[j][i])UNION(i,j);\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(FIND(i)!=FIND(j)&&g[j][i])ok=false;\n\t\t\t}\n\t\t\tif(ok)ret++;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nint g[110][110];\nPt p[110][3];\nint UF[110];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[i][i]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble ax,bx,cx,ay,by,cy;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n\t\t\tdouble A=(bx-cx)*(bx-cx)+(by-cy)*(by-cy);\n\t\t\tdouble B=(ax-cx)*(ax-cx)+(ay-cy)*(ay-cy);\n\t\t\tdouble C=(ax-bx)*(ax-bx)+(ay-by)*(ay-by);\n\t\t\tif(ABS(A-B)<EPS){\n\t\t\t\tp[i][0]=Pt(ax,ay);p[i][1]=Pt(bx,by);p[i][2]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(B-C)<EPS){\n\t\t\t\tp[i][2]=Pt(ax,ay);p[i][0]=Pt(bx,by);p[i][1]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(C-A)<EPS){\n\t\t\t\tp[i][1]=Pt(ax,ay);p[i][2]=Pt(bx,by);p[i][0]=Pt(cx,cy);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)if(iSP(p[i][0],p[i][2],p[i][1])==-1)swap(p[i][0],p[i][1]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tif(i==j)continue;\n\t\t\tPt t[4];\n\t\t\tt[0]=p[i][0];\n\t\t\tt[1]=p[i][1];\n\t\t\tt[3]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[3]=t[0]+t[3]/t[3].ABS()*(double)b;\n\t\t\tt[2]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[2]=t[1]+t[2]/t[2].ABS()*(double)b;\n\t\t\tbool ok=false;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][k]+(p[j][(k+1)%3]-p[j][k])*1000000.0)&&\n\t\t\t\t\tiSS(t[l],t[(l+1)%4],p[j][(k+1)%3],p[j][(k+1)%3]+(p[j][k]-p[j][(k+1)%3])*1000000.0))ok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tg[i][j]=1;\n\t\t//\t\tprintf(\"%d %d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]|=g[i][k]&g[k][j];\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)if(g[i][j]&&g[j][i])UNION(i,j);\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(FIND(i)!=FIND(j)&&g[j][i])ok=false;\n\t\t\t}\n\t\t\tif(ok)ret++;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-2)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) + SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G &a, G &b)\n{\t\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a.size(); i++){\n\t\tif (contains(b, a[i])){\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int i = 0; i < b.size(); i++){\n\t\tif (contains(a, b[i])){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) res++;\n\t\tused[i] = true;\n\t\tfor (int to : sccgraph[i]){\n\t\t\tused[to] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-5;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0)\n\t    swap(rect[i][0],rect[i][1]);\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k])){\n\t    f = true; break;\n\t  }\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int edges[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])edges[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!edges[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-9, AD = 1e-2;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0){\n\t    swap(rect[i][0],rect[i][1]); break;\n\t  }\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k])){\n\t    f = true; break;\n\t  }\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3)if(seg_p_dis(rseg,tri[j][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,3){\n\t    L tseg = L(tri[j][k],rect[j][(k+1)%3]);\n\t    rep(l,4)if(seg_p_dis(tseg,rect[i][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<stack>\n#include<complex>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nconst double EPS = 0.01;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > EPS)   return +1;       // counter clockwise\n  if (cross(b, c) < EPS)   return -1;       // clockwise\n\tif (dot(b, c) < EPS)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)-EPS) return -2;       // a--b--c on line\n  return 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)+EPS) swap(a, b);\n    if (imag(a) < -EPS && EPS < imag(b))\n      if (cross(a, b) < -EPS) in = !in;\n    if (abs(cross(a, b)) < EPS  && dot(a, b) < EPS) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) < EPS &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) < EPS;\n}\nbool intersect(G &rect, G &tri){\n\trep(i,3)if(contains(rect,tri[i]))return 1;\n\trep(i,4)if(contains(tri,rect[i]))return 1;\n\trep(i,3){\n\t\tL l(tri[i],tri[(i+1)%3]);\n\t\trep(j,4)if(intersectSS(l,L(rect[i],rect[(i+1)%4])))return 1;\n\t}\n\treturn 0;\n}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight=0) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid visit(const Graph &g, int v, vector< vector<int> >& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  fr(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const Graph& g,\n    vector< vector<int> >& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint main(){\n\tint n;\n\tdouble d;\n\twhile(cin>>n>>d,n){\n\t\tvector<G> tri;\n\t\trep(i,n){\n\t\t\tdouble a,b,c,d,e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tG p; p.pb(P(a,b)); p.pb(P(c,d)); p.pb(P(e,f));\n\t\t\tif(abs(abs(p[2]-p[0])-abs(p[2]-p[1]))>EPS){\n\t\t\t\tif(abs(abs(p[2]-p[0])-abs(p[1]-p[0]))<EPS)swap(p[2],p[0]);\n\t\t\t\telse swap(p[1],p[0]);\n\t\t\t}\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\tGraph e(n);\n\t\t\n\t\trep(i,n)rep(j,n)if(i!=j){\n\t\t\t\n\t\t\tG &p=tri[i];\n\t\t\tP m=(p[0]+p[1])*0.5,dir=(p[2]-m)*(d/abs(p[2]-m));\n\t\t\t\n\t\t\tG rect;\n\t\t\trect.pb(p[0]); rect.pb(p[1]);\n\t\t\trect.pb(p[1]+dir); rect.pb(p[0]+dir);\n\t\t\tif(ccw(rect[0],rect[1],rect[2])<0)reverse(rect.begin(),rect.end());\n\t\t\t\n\t\t\tif(intersect(rect,tri[j]))e[i].pb(Edge(i,j));\n\t\t}\n\t\t\n\t\tvector<vector<int> > scc;\n\t\tstronglyConnectedComponents(e,scc);\n\t\tint m=scc.size(),to[100],in[100]={0},ans=0;\n\t\trep(i,m)fr(j,scc[i])to[*j]=i;\n\t\trep(i,n)fr(j,e[i])if(to[i]!=to[j->dst])\n\t\tin[to[j->dst]]++;\n\t\t\n\t\trep(i,m)if(in[i]==0)ans++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(Segment(curr(g, i), next(g, i)), h[j]) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(Segment(curr(h, i), next(h, i)), g[j]) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tif (contains(g, h[0])) return true;\n\tif (contains(h, g[0])) return true;\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc()\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tvector<int> cmp(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tbool f = false;\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\t\n\t\t\tVector s = a / a;\n\t\t\tVector t = nv / a;\n\t\t\tif (dot(s, t) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t\tf = true;\n\t\t}\n\t\tassert(f);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>> sccgraph = scc();\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0) res++;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nint g[110][110];\nPt p[110][3];\nint UF[110];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[i][i]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble ax,bx,cx,ay,by,cy;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n\t\t\tdouble A=(bx-cx)*(bx-cx)+(by-cy)*(by-cy);\n\t\t\tdouble B=(ax-cx)*(ax-cx)+(ay-cy)*(ay-cy);\n\t\t\tdouble C=(ax-bx)*(ax-bx)+(ay-by)*(ay-by);\n\t\t\tif(ABS(A-B)<EPS){\n\t\t\t\tp[i][0]=Pt(ax,ay);p[i][1]=Pt(bx,by);p[i][2]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(B-C)<EPS){\n\t\t\t\tp[i][2]=Pt(ax,ay);p[i][0]=Pt(bx,by);p[i][1]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(C-A)<EPS){\n\t\t\t\tp[i][1]=Pt(ax,ay);p[i][2]=Pt(bx,by);p[i][0]=Pt(cx,cy);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)if(iSP(p[i][0],p[i][2],p[i][1])==-1)swap(p[i][0],p[i][1]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tif(i==j)continue;\n\t\t\tPt t[4];\n\t\t\tt[0]=p[i][0];\n\t\t\tt[1]=p[i][1];\n\t\t\tt[3]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[3]=t[0]+t[3]/t[3].ABS()*(double)b;\n\t\t\tt[2]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[2]=t[1]+t[2]/t[2].ABS()*(double)b;\n\t\t\n\t\t\tbool ok=false;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tbool L=false;\n\t\t\t\tbool R=false;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][k]+(p[j][(k+1)%3]-p[j][k])*1000000.0))L=true;\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][(k+1)%3],p[j][(k+1)%3]+(p[j][k]-p[j][(k+1)%3])*1000000.0))R=true;\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][(k+1)%3]))ok=true;\n\t\t\t\t}\n\t\t\t\tif(L&&R)ok=true;\n\t\t\t}\n\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\tbool L=false;\n\t\t\t\tbool R=false;\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tif(iSS(t[l],t[l]+(t[(l+1)%4]-t[l])*1000000.0,p[j][k],p[j][(k+1)%3]))L=true;\n\t\t\t\t\tif(iSS(t[(l+1)%4],t[(l+1)%4]+(t[l]-t[(l+1)%4])*1000000.0,p[j][k],p[j][(k+1)%3]))R=true;\n\t\t\t\t}\n\t\t\t\tif(L&&R)ok=true;\n\t\t\t}\n\t\t\t\n\t\t\tif(ok){\n\t\t\t\tg[i][j]=1;\n\t\t//\t\tprintf(\"%d %d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]|=g[i][k]&g[k][j];\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)if(g[i][j]&&g[j][i])UNION(i,j);\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(FIND(i)!=FIND(j)&&g[j][i])ok=false;\n\t\t\t}\n\t\t\tif(ok)ret++;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct coor {\n\tdouble x, y;\n};\nstruct tri {\n\tcoor p[3];\n\tcoor rec[4];\n};\n\nint n, d;\nvector<tri> v;\nvector<vector<int> > edge;\n\nconst double EPS = 1e-9;\nconst double ERR = 1e-2;\n\ntemplate<class T>\nT sqr(T x) {\n\treturn x * x;\n}\n\ndouble dist(coor a, coor b) {\n\treturn sqrt(sqr(a.x-b.x) + sqr(a.y-b.y));\n}\n\ndouble dist_lp(coor c, coor a, coor b) {\n\tcoor v0, v1;\n\tv0.x = b.x - a.x; v0.y = b.y - a.y;\n\tv1.x = c.x - a.x; v1.y = c.y - a.y;\n\n\tif(sqr(dist(a,b)) + sqr(dist(a,c)) - sqr(dist(c,b)) > 0\n\t\t\t&& sqr(dist(a,b)) + sqr(dist(b,c)) - sqr(dist(c,a)) > 0) {\n\t\tdouble cross;\n\t\tcross = fabs(v0.x * v1.y - v0.y * v1.x);\n\t\treturn cross / dist(a,b);\n\t}\n\n\treturn min(dist(a,c), dist(b,c));\n}\n\nbool in_rect(coor p, coor rect[]) {\n\tdouble sign = +0.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tcoor v0, v1;\n\t\tv0.x = rect[i].x - p.x; v0.y = rect[i].y - p.y;\n\t\tv1.x = rect[(i+1)%4].x - p.x; v1.y = rect[(i+1)%4].y - p.y;;\n\n\t\tif(i != 0 && sign * (v0.x * v1.y - v0.y * v1.x) < EPS) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tsign = (v0.x * v1.y - v0.y * v1.x);\n\n\t\tif(i == 3) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(dist_lp(p,rect[i], rect[(i+1)%4]) <= ERR + EPS) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool exist_edge(tri from, tri to) {\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(in_rect(to.p[i], from.rec))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool visited[128];\nbool touch[128];\n\nvoid check(int i, int s) {\n\tif(i != s && touch[i])\n\t\ttouch[i] = false;\n\tif(visited[i])\n\t\treturn;\n\tvisited[i] = true;\n\tfor(int j = 0; j < edge[i].size(); j++) {\n\t\tcheck(edge[i][j], s);\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> d, n || d) {\n\t\tv.clear();\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tvisited[i] = touch[i] = false;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttri in;\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tcoor c;\n\t\t\t\tcin >> c.x >> c.y;\n\t\t\t\tin.p[j] = c;\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tif(fabs(dist(in.p[(0+j)%3],in.p[(1+j)%3]) - dist(in.p[(1+j)%3], in.p[(2+j)%3])) < ERR) {\n\t\t\t\t\tswap(in.p[(1+j)%3], in.p[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcoor add;\n\t\t\tadd.x =\t(in.p[1].x - in.p[0].x) + (in.p[1].x - in.p[2].x);\n\t\t\tadd.y = (in.p[1].y - in.p[0].y) + (in.p[1].y - in.p[2].y);\n\n\t\t\tdouble addlen;\n\t\t\taddlen = sqrt(sqr(add.x) + sqr(add.y));\n\t\t\tadd.x = add.x * d / addlen;\n\t\t\tadd.y = add.y * d / addlen;\n\n\t\t\tin.rec[0].x = in.p[0].x; in.rec[0].y = in.p[0].y;\n\t\t\tin.rec[1].x = in.p[2].x; in.rec[1].y = in.p[2].y;\n\t\t\tin.rec[2].x = in.p[2].x + add.x; in.rec[2].y = in.p[2].y + add.y;\n\t\t\tin.rec[3].x = in.p[0].x + add.x; in.rec[3].y = in.p[0].y + add.y;\n\n\t\t\tv.push_back(in);\n\t\t}\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\t\tif(i != j) {\n\t\t\t\t\tif(exist_edge(v[i], v[j])) {\n\t\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\ttouch[i] = true;\n\t\t\t\tcheck(i, i);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(touch[i])\n\t\t\t\tres++;\n\t\t}\n\t\tcout <<  res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\n#define MAX_N (128)\n#define EPS (0.01)\n#define SQ(X) ((X) * (X))\n\nusing namespace std;\n\nclass Triangle {\n\tpublic:\n        double x[3], y[3];\n\t    int no;\n};\n\nclass Point {\n    public:\n    \tdouble x, y;\n        \n\t    Point operator - (Point &a){\n            Point ret;\n\t\t    ret.x = x - a.x;\n\t\t    ret.y = y - a.y;\n\t\t    return (ret);\n\t    }\n};\n\nvector<int> G[MAX_N];\nvector<int> rG[MAX_N];\nvector<int> compress[MAX_N];\nvector<int> vs;\nbool used[MAX_N];\nbool group[MAX_N];\nint cmp[MAX_N];\nint N;\n\nvoid addEdge(int from, int to)\n{\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v)\n{\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++){\n        if (!used[G[v][i]]){\n            dfs(G[v][i]);\n        }\n    }\n    vs.push_back(v);\n}\n\nvoid revDfs(int v, int k)\n{\n    used[v] = true;\n    cmp[v] = k;\n    for (int i = 0; i < rG[v].size(); i++){\n        if (!used[rG[v][i]]){\n            revDfs(rG[v][i], k);\n        }\n    }\n}\n\nint scc()\n{\n    int ret;\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    \n    for (int i = 0; i < N; i++){\n        if (!used[i]){\n            dfs(i);\n        }\n    }\n    \n    memset(used, 0, sizeof(used));\n    \n    ret = 0;\n    for (int i = vs.size() - 1; i >= 0; i--){\n        if (!used[vs[i]]){\n            revDfs(vs[i], ret++);\n        }\n    }\n    \n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < G[i].size(); j++){\n            if (cmp[i] != cmp[G[i][j]]){\n                compress[cmp[G[i][j]]].push_back(cmp[i]);\n            }\n        }\n    }\n    \n    return (ret);\n}\n\ndouble inProduct(Point a, Point b)\n{\n\treturn (a.x * b.x + a.y * b.y);\n}\n\ndouble getSize(Point a)\n{\n\treturn (sqrt(SQ(a.x) + SQ(a.y)));\n}\n\nbool checkCross(Point p1, Point p2, Point p3, Point p4)\n{\n    double check1 = (p2.x - p1.x) * (p4.y - p3.y) - (p2.y - p1.y) * (p4.x - p3.x);\n    \n    Point pq = p3 - p1;\n    \n    double check2 = (p4.y - p3.y) * pq.x - (p4.x - p3.x) * pq.y;\n    double check3 = (p2.y - p1.y) * pq.x - (p2.x - p1.x) * pq.y;\n    \n    \n    if (check1 > EPS){\n        return (0 <= check3 / check1 && check3 / check1 <= 1 + EPS && 0 <= check2 / check1 && check2 / check1 <= 1 + EPS);\n    }\n    \n    return (fabs(check2) <= EPS && fabs(check3) <= EPS);\n}\n\nvoid judgeAdj(Triangle a, Triangle b, double dist)\n{\n\tdouble len;\n\tPoint p[4];\n\t\n\tlen = 0.0;\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\tif (len < SQ(a.x[i] - a.x[j]) + SQ(a.y[i] - a.y[j])){\n\t\t\t\tlen = SQ(a.x[i] - a.x[j]) + SQ(a.y[i] - a.y[j]);\n\t\t\t\tp[0].x = a.x[i], p[0].y = a.y[i];\n\t\t\t\tp[1].x = a.x[j], p[1].y = a.y[j];\n\t\t\t}\n\t\t}\n\t}\n    //printf(\"%lf %lf %lf %lf\\n\", p[0].x, p[0].y, p[1].x, p[1].y);\n\tPoint e, sa;\n\t\n    e.x = 0, e.y = 1;\n\tsa = p[0] - p[1];\n\tdouble theta = acos(inProduct(e, sa) / (getSize(e) * getSize(sa)));\n    theta = min(theta, M_PI - theta);\n\t//printf(\"theta = %lf\\n\", theta);\n    \n\tp[2].x = p[0].x + dist * cos(theta), p[2].y = p[0].y + dist * sin(theta);\n\tp[3].x = p[1].x + dist * cos(theta), p[3].y = p[1].y + dist * sin(theta);\n\t\n\tbool cross = false;\n\t\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = i + 1; j < 3; j++){\n            Point k[2];\n            k[0].x = b.x[i], k[0].y = b.y[i];\n            k[1].x = b.x[j], k[1].y = b.y[j];\n\t\t\tcross |= checkCross(k[0], k[1], p[0], p[1]);\n\t\t\tcross |= checkCross(k[0], k[1], p[0], p[2]);\n\t\t\tcross |= checkCross(k[0], k[1], p[1], p[3]);\n\t\t\tcross |= checkCross(k[0], k[1], p[2], p[3]);\n\t\t}\n\t}\n\t\n\tif (cross == true){\n        //printf(\"hoge, %d, %d\\n\", a.no, b.no);\n\t\taddEdge(a.no, b.no);\n\t}\n\t\n}\n\nint main()\n{\n\tint n, d;\n\tTriangle data[128];\n\t\n\twhile (1){\n\t\t\n\t\tscanf(\"%d%d\", &n, &d);\n\t\t\n        N = n;\n\t\tif (n + d == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tdata[i].no = i;\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tscanf(\"%lf%lf\", &data[i].x[j], &data[i].y[j]);\n\t\t\t}\n\t\t}\n\t\t\n        for (int i = 0; i < n; i++){\n            G[i].clear();\n            rG[i].clear();\n            compress[i].clear();\n        }\n        \n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n                if (i != j){\n    \t\t\t\tjudgeAdj(data[i], data[j], d);\n                }\n\t\t\t}\n\t\t}\n\t\t\n\t\tint k = scc();\n    \t\n    \tint ans = 0;\n    \tmemset(used, 0, sizeof(used));\n    \t\n    \tfor (int i = 0; i < k; i++){\n        \tif (compress[i].size() == 0){\n        \t    ans++;\n        \t}\n    \t}\n    \t\n    \tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contain(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contain(g, h[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc()\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tvector<int> cmp(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tbool f = false;\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\t\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t\tf = true;\n\t\t}\n\t\tassert(f);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>> sccgraph = scc();\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0) res++;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-9, AD = 1e-2;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0){\n\t    swap(rect[i][0],rect[i][1]); break;\n\t  }\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k])){\n\t    f = true; break;\n\t  }\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3)if(seg_p_dis(rseg,tri[j][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,3){\n\t    L tseg = L(tri[j][k],rect[j][(k+1)%3]);\n\t    rep(l,4)if(seg_p_dis(tseg,rect[i][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-2)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) * SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G a, G b)\n{\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)) return true;\n\t\t}\n\t}\n\tfor (int i = 0; i < a.size(); i++){\n\t\tif (contains(b, a[i])) return true;\n\t}\n\tfor (int i = 0; i < b.size(); i++){\n\t\tif (contains(a, b[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) res++;\n\t\tfor (int to : sccgraph[i]){\n\t\t\tused[to] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\n\n#define N 100\n#define min(a,b) (a<b?a:b)\n\ntypedef unsigned int uint;\n\ndouble outerpro(double x1, double y1, double x2, double y2) {\n\treturn x1*y2-x2*y1;\n}\ndouble dist(double x1, double y1, double x2, double y2) {\n\tdouble xx = x2-x1, yy = y2-y1;\n\treturn xx*xx+yy*yy;\n}\nstruct POS {\n\tdouble x, y;\n\tPOS(double ax, double ay) : x(ax), y(ay) {};\n\tPOS() {};\n};\nstruct iTriangle {\n\tPOS p[3], n;\n\tvoid set(int d) {\n\t\tPOS q[3]; double dis[3], disab;\n\t\tfor(int i=0; i<3; ++i) q[i] = p[i];\n\t\tfor(int i=0; i<3; ++i) {\n\t\t\tdis[i] = dist(q[i].x, q[i].y, q[(i+1)%3].x, q[(i+1)%3].y);\n\t\t\t\n\t\t}\n\t\tfor(int i=0; i<3; ++i) {\n\t\t\tif(dis[(i+1)%3]-dis[i]<0.01) {\n\t\t\t\tfor(int k=0; k<3; ++k) p[k] = q[(i+k+2)%3];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdisab = sqrt(dist(p[2].x, p[2].y, p[1].x, p[1].y));\n\t\tif(outerpro(p[2].x-p[1].x, p[2].y-p[1].y, p[0].x-p[1].x, p[0].y-p[1].y)>=0) {\n\t\t\tn.x = -(p[2].y-p[1].y)*(double)d/disab; n.y = (p[2].x-p[1].x)*(double)d/disab;\n\t\t}else {\n\t\t\tn.x = (p[2].y-p[1].y)*(double)d/disab; n.y = -(p[2].x-p[1].x)*(double)d/disab;\n\t\t}\n\t}\n\tbool isinner(double x, double y) {\n\t\tdouble o[3];\n\t\tfor(int i=0; i<3; ++i) {\n\t\t\to[i] = outerpro(p[(i+1)%3].x-p[i].x, p[(i+1)%3].y-p[i].y, x-p[i].x, y-p[i].y);\n\t\t}\n\t\treturn ((o[0]>=0.0&&o[1]>=0.0&&o[2]>=0.0)||(o[0]<=0.0&&o[1]<=0.0&&o[2]<=0.0));\n\t}\n\tbool isninner(iTriangle t) {\n\t\tdouble o[4];\n\t\tfor(int i=0; i<3; ++i) {\n\t\t\to[0] = outerpro(p[2].x-p[1].x, p[2].y-p[1].y, t.p[i].x-p[1].x, t.p[i].y-p[1].y);\n\t\t\to[1] = outerpro(n.x, n.y, t.p[i].x-p[2].x, t.p[i].y-p[2].y);\n\t\t\to[2] = outerpro(p[1].x-p[2].x, p[1].y-p[2].y, t.p[i].x-(p[2].x+n.x), t.p[i].y-(p[2].y+n.y));\n\t\t\to[3] = outerpro(-n.x, -n.y, t.p[i].x-(p[1].x+n.x), t.p[i].y-(p[1].y+n.y));\n\t\t\tif ((o[0]>=0.0&&o[1]>=0.0&&o[2]>=0.0&&o[3]>=0.0)||(o[0]<=0.0&&o[1]<=0.0&&o[2]<=0.0&&o[3]<=0.0)) return true;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nclass UnionFind {\n\tint parent[N];\npublic:\n\tvoid init(int n) {\n\t\tfor(int i=0; i<n; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif(parent[x]==x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tint Union(int x, int y) {\n\t\tif(find(x)<find(y)) {\n\t\t\tparent[find(y)] = parent[find(x)];\n\t\t}else {\n\t\t\tparent[find(x)] = parent[find(y)];\n\t\t}\n\t\treturn min(find(x), find(y));\n\t}\n\tint count(int n) {\n\t\tint gr[N], c=0;\n\t\tfor(int i=0; i<n; ++i) gr[i] = 0;\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tif(!gr[find(i)]) {\n\t\t\t\tc++; gr[find(i)] = 1;\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n};\n\nvector<int> g[N], gf[N];\nUnionFind uf;\nint n;\n\nvoid solve(int s, int t) {\n\tfor(uint i=0; i<g[t].size(); ++i) {\n\t\tif(uf.find(g[t][i])!=uf.find(s)) {\n\t\t\tuf.Union(g[t][i], s);\n\t\t\tsolve(s, g[t][i]);\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, d;\n\tiTriangle iTri[N];\n\tiTriangle t;\n\tbool f;\n\twhile(1) {\n\t\tcin >> n >> d;\n\t\tif(!n&&!d) break;\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tfor(int j=0; j<3; ++j) cin >> iTri[i].p[j].x >> iTri[i].p[j].y;\n\t\t\tiTri[i].set(d); g[i].clear(); gf[i].clear();\n\t\t}\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tfor(int j=0; j<n; ++j) {\n\t\t\t\tif(i==j) continue;\n\t\t\t\tf = false;\n\t\t\t\tfor(int k=1; k<=2; ++k) {\n\t\t\t\t\tif(iTri[j].isinner(iTri[i].p[k].x+iTri[i].n.x, iTri[i].p[k].y+iTri[i].n.y)) {\n\t\t\t\t\t\tf = true; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f||iTri[i].isninner(iTri[j])) f = true;\n\t\t\t\tif(f) {\n\t\t\t\t\tg[i].push_back(j); gf[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tuf.init(n);\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tif(uf.find(i)==i) solve(i, i);\n\t\t}\n\t\tcout << uf.count(n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-3\n ;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\n#include <cstring>\n\n// ???, ????????????\ntypedef std::complex<double> Point;\ntypedef Point Vector;\n\nnamespace std {\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\t\n\tistream& operator >> (istream &is, Point &a){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\ta = Point(x, y);\n\t\treturn is;\n\t}\n\t\n\tostream& operator << (ostream &os, Point a){\n\t\treturn os << a.real() << \" \" << a.imag();\n\t}\n}\n\n// ??´???\nstruct Line {\n\tPoint p1, p2;\n\tLine(){}\n\tLine(const Point &p1, const Point &p2): p1(p1), p2(p2){}\n};\ntypedef Line Segment;\n\nnamespace std {\n\tistream& operator >> (istream &is, Line &a){\n\t\treturn is >> a.p1 >> a.p2;\n\t}\n}\n\n// ???\nstruct Circle {\n\tPoint p; double r;\n\tCircle(){}\n\tCircle(const Point &p, double r): p(p), r(r){}\n};\n\nnamespace std {\n\tistream& operator >> (istream &is, Circle &a){\n\t\treturn is >> a.p >> a.r;\n\t}\n}\n\n// ????§???¢\ntypedef std::vector<Point> Polygon;\n\nconst double EPS = 1e-2;\nconst double INF = 1e12;\nconst double PI = acos(-1.0);\n\n// ????????¨??????????????¢???\nenum CCW {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0,\n};\n\n// ?????¢????£????????????¢???\nenum {\n\tOUT = 0,\n\tON = 1,\n\tIN = 2,\n};\n\n\n// a ??? 2 ??? (a ^ 2)\ndouble SQ(double a);\n\n// ?????????????????????????????¢??°\nbool EQ(double a, double b);\nbool NEQ(double a, double b);\nbool LT(double a, double b);\nbool GT(double a, double b);\nbool LEQ(double a, double b);\nbool GEQ(double a, double b);\n\n// ??§?????? <=> ?????°?????????\ndouble toDeg(double t);\ndouble toRad(double t);\n\n// ????????? (dot(a, a))\ndouble norm(const Vector &a);\n\n// ??????, ??????\ndouble dot(const Vector &a, const Vector &b);\ndouble cross(const Vector &a, const Vector &b);\n\n// ??´???, ??????\nbool orthogonal(const Segment &s1, const Segment &s2);\nbool parallel(const Segment &s1, const Segment &s2);\n\n// ?°???±, ????°?\nPoint project(const Line &l, const Point &p);\nPoint reflect(const Line &l, const Point &p);\n\n// ?????? (p0, p1) ??¨??? p2 ???????????¢???\nint ccw(const Point &p0, const Point &p1, const Point &p2);\n\n// ????????????\nbool intersectLP(const Line &l, const Point &p);\nbool intersectLL(const Line &l1, const Line &l2);\nbool intersectLS(const Line &l, const Segment &s);\nbool intersectSP(const Segment &s, const Point &p);\nbool intersectSS(const Segment &s1, const Segment &s2);\nint intersectCP(const Circle &c, const Point &p);\nbool intersectCL(const Circle &c, const Line &l);\nint intersectCS(const Circle &c, const Segment &s);\nint intersectCC(const Circle &c1, const Circle &c2);\n\n// ?????¢\ndouble distanceLP(const Line &l, const Point &p);\ndouble distanceLL(const Line &l1, const Line &l2);\ndouble distanceLS(const Line &l, const Segment &s);\ndouble distanceSP(const Segment &s, const Point &p);\ndouble distanceSS(const Segment &s1, const Segment &s2);\ndouble distanceCP(const Circle &c, const Point &p);\ndouble distanceCL(const Circle &c, const Line &l);\ndouble distanceCS(const Circle &c, const Segment &s);\ndouble distanceCC(const Circle &c1, const Circle &c2);\n\n// ??????\nPoint crossPointLL(const Line &l1, const Line &l2);\nPoint crossPointLS(const Line &l, const Segment &s);\nPoint crossPointSS(const Segment &s1, const Segment &s2);\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l);\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s);\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2);\n\n\ndouble SQ(double a){\n\treturn a * a;\n}\n\nbool EQ(double a, double b){\n\treturn std::abs(a - b) < EPS;\n}\n\nbool NEQ(double a, double b){\n\treturn !EQ(a, b);\n}\n\nbool LT(double a, double b){\n\treturn a - b < -EPS;\n}\n\nbool GT(double a, double b){\n\treturn a - b > EPS;\n}\n\nbool LEQ(double a, double b){\n\treturn !GT(a, b);\n}\n\nbool GEQ(double a, double b){\n\treturn !LT(a, b);\n}\n\ndouble toDeg(double t){\n\treturn t * 180 / PI;\n}\n\ndouble toRad(double t){\n\treturn t / 180 * PI;\n}\n\ndouble norm(const Vector &a){\n\treturn SQ(a.real()) + SQ(a.imag());\n}\n\ndouble dot(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).real();\n}\n\ndouble cross(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).imag();\n}\n\n// AOJ CGL_2_A\nbool orthogonal(const Segment &s1, const Segment &s2){\n\treturn EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_2_A\nbool parallel(const Segment &s1, const Segment &s2){\n\treturn EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_1_A\nPoint project(const Line &l, const Point &p){\n\tVector base = l.p2 - l.p1;\n\tdouble r = dot(p - l.p1, base) / norm(base);\n\treturn l.p1 + base * r;\n}\n\n// AOJ CGL_1_B\nPoint reflect(const Line &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2.0;\n}\n\n// AOJ CGL_1_C\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (GT(cross(a, b), 0.0)) return COUNTER_CLOCKWISE;\n\tif (LT(cross(a, b), 0.0)) return CLOCKWISE;\n\tif (LT(dot(a, b), 0.0)) return ONLINE_BACK;\n\tif (LT(norm(a), norm(b))) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersectLP(const Line &l, const Point &p){\n\treturn LEQ(std::abs(cross(l.p1 - p, l.p2 - p)), 0.0);\n}\n\nbool intersectLL(const Line &l1, const Line &l2){\n\treturn !parallel(l1, l2) || LEQ(std::abs(cross(l1.p2 - l1.p1, l2.p1 - l1.p1)), 0.0);\n}\n\nbool intersectLS(const Line &l, const Segment &s){\n\treturn LEQ(cross(l.p2 - l.p1, s.p1 - l.p1) * cross(l.p2 - l.p1, s.p2 - l.p1), 0.0);\n}\n\nbool intersectSP(const Segment &s, const Point &p){\n\treturn norm(s.p1 - p) + norm(s.p2 - p) - norm(s.p2 - s.p1) < EPS;\n}\n\n// CGL_2_B\nbool intersectSS(const Segment &s1, const Segment &s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\nint intersectCP(const Circle &c, const Point &p){\n\tdouble dd = norm(c.p - p);\n\tif (LT(dd, SQ(c.r))) return IN;\n\tif (EQ(dd, SQ(c.r))) return ON;\n\treturn OUT;\n}\n\nbool intersectCL(const Circle &c, const Line &l){\n\tdouble d = distanceLP(l, c.p);\n\treturn LEQ(d, c.r);\n}\n\nint intersectCS(const Circle &c, const Segment &s){\n\tdouble dd1 = norm(c.p - s.p1);\n\tdouble dd2 = norm(c.p - s.p2);\n\tif (LT(dd1, SQ(c.r)) && LT(dd2, SQ(c.r))) return IN;\n\tif (GT(distanceCS(c, s), 0.0)) return OUT;\n\treturn ON;\n}\n\n// c1 ??? c2 ???????????????????????¨??? IN\n// c1 ??? c2 ????????£???????????¨??? ON\n// c1 ??? c2 ?????????????????¨??? OUT\nint intersectCC(const Circle &c1, const Circle &c2){\n\tif (GT(norm(c1.p - c2.p), SQ(c1.r + c2.r))) return OUT;\n\tif (LT(norm(c1.p - c2.p), SQ(c2.r))) return IN;\n\tif (LT(norm(c1.p - c2.p), SQ(c1.r))) return OUT;\n\treturn ON;\n}\n\ndouble distanceLP(const Line &l, const Point &p){\n\treturn std::abs(cross(l.p2 - l.p1, p - l.p1)) / std::abs(l.p2 - l.p1);\n}\n\ndouble distanceLL(const Line &l1, const Line &l2){\n\tif (intersectLL(l1, l2)) return 0.0;\n\treturn distanceLP(l1, l2.p1);\n}\n\ndouble distanceLS(const Line &l, const Segment &s){\n\tif (intersectLS(l, s)) return 0.0;\n\treturn std::min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\n\ndouble distanceSP(const Segment &s, const Point &p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return std::abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return std::abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\n// AOJ CGL_2_D\ndouble distanceSS(const Segment &s1, const Segment &s2){\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn std::min(\n\t\tstd::min(\n\t\t\tdistanceSP(s1, s2.p1),\n\t\t\tdistanceSP(s1, s2.p2)\n\t\t),\n\t\tstd::min(\n\t\t\tdistanceSP(s2, s1.p1),\n\t\t\tdistanceSP(s2, s1.p2)\n\t\t)\n\t);\n}\n\ndouble distanceCP(const Circle &c, const Point &p){\n\treturn std::abs(std::abs(c.p - p) - c.r);\n} \n\ndouble distanceCL(const Circle &c, const Line &l){\n\tif (intersectCL(c, l)) return 0.0;\n\treturn distanceLP(l, c.p) - c.r;\n}\n\ndouble distanceCS(const Circle &c, const Segment &s){\n\tif (intersectCS(c, s)) return 0.0;\n\treturn std::min(distanceCP(c, s.p1), distanceCP(c, s.p2));\n}\n\ndouble distanceCC(const Circle &c1, const Circle &c2){\n\tif (intersectCC(c1, c2) == ON) return 0.0;\n\tif (intersectCC(c1, c2) == IN){\n\t\treturn c2.r - (std::abs(c1.p - c2.p) + c1.r);\n\t}\n\tif (intersectCC(c2, c1) == IN){\n\t\treturn c1.r - (std::abs(c1.p - c2.p) + c2.r);\n\t}\n\treturn (c1.r + c2.r) - (c1.r + c2.r);\n}\n\nPoint crossPointLL(const Line &l1, const Line &l2){\n\tassert(intersectLL(l1, l2));\n\tVector base = l2.p2 - l2.p1;\n\tdouble d1 = std::abs(cross(base, l1.p1 - l2.p1));\n\tdouble d2 = std::abs(cross(base, l1.p2 - l2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn l1.p1 + (l1.p2 - l1.p1) * t;\n}\n\nPoint crossPointLS(const Line &l, const Segment &s){\n\tassert(intersectLS(l, s));\n\treturn crossPointLL(l, s);\n}\n\nPoint crossPointSS(const Segment &s1, const Segment &s2){\n\tassert(intersectSS(s1, s2));\n\treturn crossPointSS(s1, s2);\n}\n\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l){\n\tif (!intersectCL(c, l)) return std::vector<Point>();\n\tstd::vector<Point> ret;\n\tVector proj = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / std::abs(l.p2 - l.p1);\n\tdouble base = sqrt(SQ(c.r) - norm(proj - c.p));\n\tret.push_back(proj + e * base);\n\tret.push_back(proj - e * base);\n\treturn ret;\n}\n\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s){\n\tstd::vector<Point> ret = crossPointCL(c, s);\n\tfor (int i = 0; i < ret.size(); i++){\n\t\tif (!intersectCP(c, ret[i])){\n\t\t\tswap(ret[i], ret.back());\n\t\t\tret.pop_back();\n\t\t\ti--;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2){\n\tif (!intersectCC(c1, c2)) return std::vector<Point>();\n\tstd::vector<Point> ret;\n\tdouble d = std::abs(c1.p - c2.p);\n\tdouble a = std::acos((SQ(c1.r) + SQ(d) - SQ(c2.r)) / (2 * c1.r * d));\n\tdouble t = std::arg(c2.p - c1.p);\n\tret.push_back(c1.p + std::polar(c1.r, t + a));\n\tret.push_back(c1.p + std::polar(c1.r, t - a));\n\treturn ret;\n}\n\nnamespace {\nenum {DIRECTED, UNDIRECTED};\nconst int GRAPH_TYPE = DIRECTED;\n\ntypedef int Weight;\nconst Weight INF = 1 << 28;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge() {}\n\tEdge(int src, int dst, Weight weight = 1): src(src), dst(dst), weight(weight) {}\n\tbool operator < (const Edge &t) const { return weight < t.weight; }\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n\nvoid addEdge(Graph &g, int src, int dst, int weight = 1)\n{\n\tg[src].push_back(Edge(src, dst, weight));\n\tif (GRAPH_TYPE == UNDIRECTED) g[dst].push_back(Edge(dst, src, weight));\n};\n\nGraph transpose(const Graph &g)\n{\n\tGraph rg(g.size());\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\taddEdge(rg, g[i][j].dst, g[i][j].src, g[i][j].weight);\n\t\t}\n\t}\n\treturn rg;\n}\n\nvoid dfs_(const Graph &g, int v, bool *used, std::vector<int> &vs)\n{\n\tused[v] = true;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) dfs_(g, to, used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs_(const Graph &g, int v, int k, bool *used, std::vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) rdfs_(g, to, k, used, cmp);\n\t}\n}\n\nint scc(const Graph &g, std::vector<int> &cmp)\n{\n\tGraph rg = transpose(g);\n\tstd::vector<int> vs;\n\tbool *used = new bool[g.size()];\n\tcmp.resize(g.size());\n\t\n\tstd::memset(used, false, g.size());\n\tfor (int v = 0; v < g.size(); v++){\n\t\tif (!used[v]) dfs_(g, v, used, vs);\n\t}\n\t\n\tstd::memset(used, false, g.size());\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs_(rg, vs[i], k++, used, cmp);\n\t}\n\t\n\tdelete used;\n\treturn k;\n}\n}\n\n\nusing namespace std;\n\nint n;\ndouble d;\nvector<Polygon> tri;\nvector<Polygon> rect;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment s(g[i], g[(i + 1) % g.size()]);\n\t\t\tSegment t(h[j], h[(j + 1) % h.size()]);\n\t\t\tif (intersectSS(s, t)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint solve()\n{\n\trect.assign(n, Polygon(4));\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tif (EQ(norm(tri[i][j] - tri[i][(j + 1) % 3]), norm(tri[i][j] - tri[i][(j + 2) % 3]))){\n\t\t\t\tswap(tri[i][0], tri[i][j]);\n\t\t\t}\n\t\t}\n\t\tif (ccw(tri[i][1], tri[i][2], tri[i][0]) == CLOCKWISE){\n\t\t\tswap(tri[i][1], tri[i][2]);\n\t\t}\n\t\t\n\t\tVector s = tri[i][2] - tri[i][1];\n\t\tVector normal = s / abs(s) * Vector(0, 1) * d;\n\t\trect[i][0] = tri[i][1];\n\t\trect[i][1] = tri[i][2];\n\t\trect[i][2] = tri[i][2] + normal;\n\t\trect[i][3] = tri[i][1] + normal;\n\t}\n\t\n\tGraph graph(n);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(rect[i], tri[j])){\n\t\t\t\taddEdge(graph, i, j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tint v = scc(graph, cmp);\n\tint mat[100][100] = {};\n\tint in[100] = {};\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < graph[i].size(); j++){\n\t\t\tint src = cmp[i];\n\t\t\tint dst = cmp[graph[i][j].dst];\n\t\t\tif (src == dst) continue;\n\t\t\tif (mat[src][dst]++) continue;\n\t\t\tin[dst]++;\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < v; i++){\n\t\tif (in[i] == 0) res++;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tstd::cout << std::fixed << std::setprecision(12);\n\t\n\twhile (cin >> n >> d, n){\n\t\ttri.assign(n, Polygon(3));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cfloat>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define EPS (1e-8)\n\nclass Point{\npublic:\n\tdouble x, y;\n\tPoint ( double x = 0, double y = 0): x(x), y(y){}\n\tPoint operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n\tPoint operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n\tPoint operator * ( double a ){ return Point(x*a, y*a); }\n\tdouble abs() { return sqrt(norm());}\n\tdouble norm() { return x*x + y*y; }\n\tbool operator < ( const Point &p ) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\tbool operator == ( const Point &p ) const {\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs(Vector a) {return (sqrt(norm(a)));}\ndouble abs(Vector a, Vector b) {return (sqrt(norm(a - b)));}\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\ndouble eq(double a, double b)\n{\n\treturn (fabs(a - b) <= EPS);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n//3点の位置関係を求める\nint ccw( Point p0, Point p1, Point p2 ){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif ( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif ( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif ( norm(a) < norm(b) ) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//A = p2 - p1, B = p4 - p3が交差するか\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n\treturn ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\n\n\n//多角形の中に点があるか\nbool isInside(Polygon gon, Point p ){\n\tfor ( int i = 0; i < gon.size(); i++ ){\n\t\tif ( ccw(gon[i], gon[(i+1)%gon.size()], p) == CLOCKWISE ) return (false);\n\t}\n\treturn (true);\n}\n\n//単位ベクトルを求める\nPoint unitVector(Point t){\n\tdouble u=abs(t);\n\treturn Point(t.x/u , t.y/u);\n}\n//cosθを求める\ndouble getcos(Point a , Point b){\n\treturn (dot(a,b) / (abs(a)*abs(b)));\n}\n\n//sinθを求める\ndouble getsin(Point a , Point b){\n\tdouble t=getcos(a,b);\n\treturn sqrt(1.0-t*t);\n}\n\n//点pと直線abとの距離を求める\ndouble pld(Point p , Point a , Point b){\n\treturn fabs(cross(b - a,p - a))/abs(b-a);\n}\n\n//点pと線分abとの距離を求める\ndouble psd(Point p , Point a , Point b){\n\tif( dot( b-a , p-a ) < EPS) return abs(p-a);\n\tif( dot( a-b , p-b ) < EPS) return abs(p-b);\n\treturn fabs(cross( b-a , p-a )) / abs(b-a);\n}\n\n//線分交点計算\nPoint interpointS(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint b=b2-b1;\n\tdouble d1=fabs(cross(b , a1-b1));\n\tdouble d2=fabs(cross(b , a2-b1));\n\tdouble t=d1 / (d1 + d2);\n\tPoint a=a2-a1;\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線交点計算\nPoint interpointL(Point a1 , Point a2 , Point b1 , Point b2){\n\tPoint a=a2-a1;\n\tPoint b=b2-b1;\n\tdouble t=cross(b , b1-a1) / cross(b , a);\n\tPoint v=a*t;\n\treturn a1+v;\n}\n\n//直線abと円及び球 |x-c|=rの交点を求める 　球の場合は型Point→Sに変更するだけ\nvoid interpointLC(Point a , Point b , Point c , double r , Point ans[]){\n\tif(pld(c , a , b) > r + EPS) return;\n\tPoint v=unitVector(b-a);\n\tdouble delta=dot(v,a-c)*dot(v,a-c)-abs(a-c)*abs(a-c)+r*r;\n\tdouble t=-dot(v,a-c);\n\tdouble s=sqrt(delta);\n\tans[0]=a+v*(t+s);\n\tans[1]=a+v*(t-s);\n}\n\n//１次変換集\n\n//ｘ（y=k）に関する対象変換 　k=0でｘ軸による変換\nPoint xTranslate(Point t,double k){\n\treturn Point(t.x , 2*k-t.y);\n}\n\n//ｙ(x=k)に関する対象変換\tk=0でｙ軸による変換\nPoint yTranslate(Point t,double k){\n\treturn Point(2*k-t.x , t.y);\n}\n\n//点Point kに関する対象変換\t\tPoint(0,0)で原点による変換\nPoint oTranslate(Point t,Point k){\n\treturn k+(k-t);\n}\n\n\n\n\n\n//点pを中心としてr(radian)回転\t\tp(0,0)で原点を中心として回転\nPoint rotate(Point t , Point p , double r){\n\t//double r=radians(angle);\n\tdouble ta=cos(r)*(t.x-p.x)-sin(r)*(t.y-p.y)+p.x;\n\tdouble tb=sin(r)*(t.x-p.x)+cos(r)*(t.y-p.y)+p.y;\n\treturn Point(ta , tb);\n}\n\n//応用\n//２円 |x-a|=raと|x-b|=rbの交点計算\nvoid interpointCC(Point a , double ra , Point b , double rb , Point ans[]){\n\tdouble di=fabs(abs(a-b));\n\tif(di > ra+rb || di < fabs(ra-rb)) return;\n\tdouble t=(ra*ra-rb*rb+di*di)/(di+di);\n\tdouble rd=acos(t/ra);\n\n\tPoint dv=unitVector(b-a);\n\tPoint g1=rotate(dv , Point(0,0) , rd);\n\tPoint g2=rotate(dv , Point(0,0) , -rd);\n\tans[0]=a+g1*ra;\n\tans[1]=a+g2*ra;\n}\n\n//法線ベクトルを求める\nPoint normalVector(Point p,Point a,Point b){\n\tPoint v=unitVector(b-a);\n\tv = cross(v , p-a) > 0 ?  Point(v.y,(-1)*v.x) : Point((-1)*v.y , v.x);\n\treturn v*pld(p,a,b);\n}\n\n//直線abに関する対象変換\nPoint fTranslate(Point t , Point a , Point b){\n\treturn t+normalVector(t,a,b)*2;\n}\n\n//３角形の面積を求める\ndouble area(Point a, Point b, Point c){\n\treturn fabs(cross(c-a , b-a)*0.5);\n}\n\n//多角形の面積を求める //凸包のソート済みが前提\ndouble polygonArea(Polygon t){\n\tdouble ans=0.0;\n\tfor(unsigned int i=0;i<t.size();i++)\n\t\tans+=cross(t[i] , t[(i+1)%t.size()]);\n\treturn ans/2;\n}\n\nPolygon conhel(Polygon& ps)\n{\n    sort(ps.begin(), ps.end());\n    int k = 0, n = static_cast<int>(ps.size());\n    Polygon qs(n * 2);\n    for (int i = 0; i < n; ++i) {\n      while (k > 1 && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    for (int i = n-2, t = k; i >= 0; --i) {\n      while (k > t && cross(qs[k-1] - qs[k-2], ps[i] - qs[k-1]) < EPS)\n\t--k;\n      qs[k++] = ps[i];\n    }\n\n    qs.resize(k-1);\n    return qs;\n}\n\nPolygon tri[100];\nint n, d;\n\nbool isIn(Polygon a, Polygon b)\n{\n\tfor (int i = 0; i < a.size(); i++) if (isInside(b, a[i])) return (true);\n\tfor (int i = 0; i < b.size(); i++) if (isInside(a, b[i])) return (true);\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tif (isIntersect(a[i], a[(i + 1) % a.size()], b[j], b[(j + 1) % b.size()])) return (true);\n\t\t}\n\t}\n\treturn (false);\n}\n\nPolygon normalize(Polygon a)\n{\n\tif (eq(abs(a[0] - a[1]), abs(a[1] - a[2])))\n\t\tswap(a[1], a[2]);\n\telse if (eq(abs(a[0] - a[2]), abs(a[0] - a[1])))\n\t\tswap(a[0], a[2]);\n\t\n\tif (ccw(a[0], a[1], a[2]) != COUNTER_CLOCKWISE) swap(a[0], a[1]);\n\t\n\treturn (a);\n}\n\nbool check(Polygon a, Polygon b)\n{\n\tPolygon c;\n\tc.push_back(a[0]); c.push_back(a[1]);\n\t\n\tPoint t = Point((a[0].x + a[1].x) / 2, (a[0].y + a[1].y) / 2);\n\tPoint k = a[2] - t;\n\tc.push_back(a[1] + unitVector(k) * d); c.push_back(a[0] + unitVector(k) * d);\n\t\n\treturn (isIn(c, b));\n}\n\nvector<int> G[128], rG[128];\nint ord[128], gr[128];\nbool vis[128];\nint ctr;\n\nvoid addEdge(int src, int dst)\n{\n\tG[src].push_back(dst);\n\trG[dst].push_back(src);\n}\n\nvoid dfs1(int v)\n{\n\tvis[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tif (!vis[G[v][i]]) dfs1(G[v][i]);\n\t}\n\tord[ctr++] = v;\n}\n\nvoid dfs2(int v, int k)\n{\n\tvis[v] = true;\n\tgr[v] = k;\n\tfor (int i = 0; i < rG[v].size(); i++){\n\t\tif (!vis[rG[v][i]]) dfs2(rG[v][i], k);\n\t}\n\t\n}\n\nint scc()\n{\n\t\n\tmemset(vis, 0, sizeof(vis));\n\tctr = 0;\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!vis[i]){\n\t\t\tdfs1(i);\n\t\t}\n\t}\n\t\n\tint k = 0;\n\tmemset(vis, 0, sizeof(vis));\n\tfor (int i = n - 1; i >= 0; i--){\n\t\tif (!vis[ord[i]]){\n\t\t\tdfs2(ord[i], k++);\n\t\t}\n\t}\n\t\n\tint ret = k;\n\tmemset(vis, 0, sizeof(vis));\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < G[i].size(); j++){\n\t\t\tif (gr[i] != gr[G[i][j]]){\n\t\t\t\tret -= (1 ^ vis[gr[G[i][j]]]);\n\t\t\t\tvis[gr[G[i][j]]] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (ret);\n}\n\nint main()\n{\n\tPoint t;\n\twhile (scanf(\"%d %d\", &n, &d) && n + d){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].clear();\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tscanf(\"%lf %lf\", &t.x, &t.y);\n\t\t\t\ttri[i].push_back(Point(t.x, t.y));\n\t\t\t}\n\t\t\ttri[i] = normalize(tri[i]);\n\t\t\tG[i].clear(); rG[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (i != j && check(tri[i], tri[j])){\n\t\t\t\t\taddEdge(i, j);\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\t\n\t\t\n\t\tprintf(\"%d\\n\", scc());\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, const Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-6;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tSegment s(curr(g, i), next(g, i));\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(s, h[j]) < 0.01){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tSegment s(curr(h, i), next(h, i));\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(s, g[j]) < 0.01){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(norm(b - a), norm(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tVector a = tri[i][1] - tri[i][0];\n\t\tVector nv = tri[i][0] + (a / 2.0);\n\t\tnv = tri[i][2] - nv;\n\t\tnv /= abs(nv);\n\t\tnv *= d;\n\t\t\n\t\tsqr[i][0] = tri[i][0];\n\t\tsqr[i][1] = tri[i][1];\n\t\tsqr[i][2] = tri[i][1] + nv;\n\t\tsqr[i][3] = tri[i][0] + nv;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tsqr[i].resize(4);\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef int Weight;\nconst Weight INF = 1 << 28;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge() {}\n\tEdge(int src, int dst, Weight weight = 1): src(src), dst(dst), weight(weight) {}\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n\nvoid addEdge(Graph &g, int src, int dst, int weight = 1)\n{\n\tg[src].push_back(Edge(src, dst, weight));\n};\n\nGraph transpose(const Graph &g)\n{\n\tGraph rg(g.size());\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\taddEdge(rg, g[i][j].dst, g[i][j].src, g[i][j].weight);\n\t\t}\n\t}\n\treturn rg;\n}\n\nstd::vector<Weight> dijkstra(const Graph &g, int src){\n\tstd::vector<Weight> dist(g.size(), INF);\n\tstd::priority_queue<std::pair<Weight, int>,\n\t                    std::vector<std::pair<Weight, int> >,\n\t\t\t\t\t\tstd::greater<std::pair<Weight, int> > > pq;\n\t\n\tdist[src] = Weight(0);\n\tpq.push(std::make_pair(Weight(0), src));\n\t\n\twhile (pq.size()){\n\t\tint cur = pq.top().second;\n\t\tWeight sum = pq.top().first;\n\t\tpq.pop();\n\t\tif (dist[cur] < sum) continue;\n\t\t\n\t\tfor (int i = 0; i < g[cur].size(); i++){\n\t\t\tconst Edge &e = g[cur][i];\n\t\t\tif (dist[e.dst] > sum + e.weight){\n\t\t\t\tdist[e.dst] = sum + e.weight;\n\t\t\t\tpq.push(std::make_pair(sum + e.weight, e.dst));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dist;\n}\n\nvoid dfs_(const Graph &g, int v, bool *used, std::vector<int> &vs)\n{\n\tused[v] = true;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) dfs_(g, to, used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs_(const Graph &g, int v, int k, bool *used, std::vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) rdfs_(g, to, k, used, cmp);\n\t}\n}\n\nint scc(const Graph &g, std::vector<int> &cmp)\n{\n\tGraph rg = transpose(g);\n\tstd::vector<int> vs;\n\tbool *used = new bool[g.size()];\n\tcmp.resize(g.size());\n\t\n\tmemset(used, false, g.size());\n\tfor (int v = 0; v < g.size(); v++){\n\t\tif (!used[v]) dfs_(g, v, used, vs);\n\t}\n\t\n\tmemset(used, false, g.size());\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs_(rg, vs[i], k++, used, cmp);\n\t}\n\t\n\tdelete used;\n\treturn k;\n}\n\n#include <bits/stdc++.h>\n\nnamespace geo {\n\n// ???????????§??????\n\ntypedef std::complex<double> Point;\n\nstruct Segment {\n\tPoint p1, p2;\n\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n};\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef std::vector<Point> Polygon;\n\n// ?????°, ??????\n\nconst double PI = acos(-1);\nconst double EPS = 1e-12;\nconst double INF = 1e12;\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE \t\t= -1;\nconst int ONLINE_BACK\t\t= 2;\nconst int ONLINE_FRONT\t\t= -2;\nconst int ON_SEGMENT\t\t= 0;\nconst int OUT\t\t\t\t= 0;\nconst int ON\t\t\t\t= 1;\nconst int IN\t\t\t\t= 2;\n\ninline double square(double a){return a * a;}\ninline bool equal(double a, double b){return abs(a - b) < EPS;}\ninline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\ninline double norm(const Point &a){return square(a.real()) + square(a.imag());}\ninline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\ninline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\ninline double toDeg(double t){return t / PI * 180;}\ninline double toRad(double t){return t / 180 * PI;}\n\n#define curr(v, i) v[i]\n#define next(v, i) v[(i + 1) % v.size()]\n#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\n\n// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n// ????§?????????????????????? Point rp ?????£??\\????????????\n\nbool cmpx(const Point &a, const Point &b){\n\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\treturn b.imag() < b.imag();\n}\n\nbool cmpy(const Point &a, const Point &b){\n\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\treturn a.real() < b.real();\n}\n\nPoint rp;\nbool cmparg(const Point &a, const Point &b){\n\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\tif (!equal(rada, radb)) return rada < radb;\n\treturn norm(a) < norm(b);\n}\n\n\n// ??´???, ??????\n\nbool orthgonal(const Vector &a, const Vector &b){\n\treturn equal(dot(a, b), 0.0);\n}\n\nbool parallel(const Vector &a, const Vector &b){\n\treturn equal(cross(a, b), 0.0);\n}\n\n\n// ????°?, ?°???±\n\nPoint project(const Segment &s, const Point &p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(const Segment &s, const Point &p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\n\n// ??????????????????\n\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n\n// ?????¢\n\ndouble distanceLP(const Line &l, const Point &p){\n\treturn std::abs(cross(l.p2 - l.p1, p - l.p1) / std::abs(l.p2 - l.p1));\n}\n\ndouble distanceSP(const Segment &s, const Point &p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return std::abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return std::abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\nbool intersect(const Segment &s1, const Segment &s2);\ndouble distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn std::min(\n\t\tstd::min(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\tstd::min(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t);\n}\n\n\n// ????????????\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &s){\n\t// ???????????° (0 ~ 2) ?????????\n\tdouble dist = distanceSP(s, c.p) - c.r;\n\tif (equal(dist, 0.0)) return 1;\n\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\nint intersect(const Circle &c1, const Circle &c2){\n\t// ???????????° (0 ~ 2) ?????????\n\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\tif (equal(dist, 0.0)) return 1;\n\tif (dist < 0.0) return 2;\n\treturn 0;\n}\n\n\n// ??????\n\nPoint crossPoint(const Segment &s1, const Segment &s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = std::abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = std::abs(cross(base, s1.p2 - s2.p1));\n\t\n\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\tassert(!equal(d1 + d2, 0.0));\n\t\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nstd::vector<Point> crossPoints(const Circle &c, const Line &l){\n\tstd::vector<Point> res;\n\tif (!intersect(c, l)) return res;\n\t\n\tVector pr = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / std::abs(l.p2 - l.p1);\n\tdouble base = std::sqrt(c.r * c.r - norm(pr - c.p));\n\tres.push_back(pr + e * base);\n\tres.push_back(pr - e * base);\n\tif (equalVector(res[0], res[1])) res.pop_back();\n\treturn res;\n}\n\nstd::vector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\tstd::vector<Point> res;\n\tif (!intersect(c1, c2)) return res;\n\t\n\tdouble d = std::abs(c1.p - c2.p);\n\tdouble a = std::acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\tdouble t = std::arg(c2.p - c1.p);\n\tres.push_back(c1.p + std::polar(c1.r, t + a));\n\tres.push_back(c1.p + std::polar(c1.r, t - a));\n\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\n\treturn res;\n}\n\n\n// ??????\n\nint contains(const Polygon &g, const Point &p){\n\tint n = g.size();\n\tbool res = false;\n\tfor (int i = 0; i < n; i++){\n\t\tPoint a = g[i] - p;\n\t\tPoint b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t}\n\treturn res ? IN : OUT;\n}\n\n\n// ??????\n\nPolygon convexHull(std::vector<Point> s){\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tstd::sort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\t\n\tfor (int i = 2; i < s.size(); i++){\n\t\tint n = u.size();\n\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\tu.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t\n\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\tint n = l.size();\n\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\tl.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t\n\tstd::reverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\tl.push_back(u[i]);\n\t}\n\t\n\treturn l;\n}\n\t\n\n// ???????§???¢??????\n\nPolygon convexCut(const Polygon &g, const Line &l){\n\tPolygon res;\n\tfor (int i = 0; i < g.size(); i++){\n\t\tconst Point &a = curr(g, i);\n\t\tconst Point &b = next(g, i);\n\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\tres.push_back(a);\n\t\t}\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\n}\n\nnamespace std {\nbool operator < (const geo::Point &a, const geo::Point &b){\n\treturn geo::cmpx(a, b);\n}\n}\n\nbool intersect(const geo::Polygon &g, const geo::Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tgeo::Segment s(curr(g, i), next(g, i));\n\t\t\tgeo::Segment t(curr(h, j), next(h, j));\n\t\t\tif (geo::intersect(s, t)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (geo::contains(h, curr(g, i))) return true;\n\t}\n\t\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (geo::contains(g, curr(h, i))) return true;\n\t}\n\t\n\treturn false;\n}\n\nint n;\ndouble d;\nstd::vector<geo::Polygon> tris;\nstd::vector<geo::Polygon> sqrs;\n\nvoid solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tgeo::Point &a = curr(tris[i], j),\n\t\t\t\t\t   &b = prev(tris[i], j),\n\t\t\t\t\t   &c = next(tris[i], j);\n\t\t\tif (geo::equal(std::abs(a - b), std::abs(a - c))){\n\t\t\t\tstd::swap(tris[i][j], tris[i][0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsqrs.assign(n, geo::Polygon(4));\n\tfor (int i = 0; i < n; i++){\n\t\tgeo::Vector A = tris[i][0] - tris[i][1];\n\t\tgeo::Vector B = tris[i][2] - tris[i][1];\n\t\tgeo::Vector normal;\n\t\t\n\t\tif (geo::dot(B, A * geo::Vector(0, 1)) > geo::dot(B, A * geo::Vector(0, -1))){\n\t\t\tnormal = A * geo::Vector(0, 1) / std::abs(A) * d;\n\t\t}\n\t\telse normal = A * geo::Vector(0, -1) / std::abs(A) * d;\n\t\t\n\t\tsqrs[i][0] = tris[i][0];\n\t\tsqrs[i][1] = tris[i][1];\n\t\tsqrs[i][2] = tris[i][1] + normal;\n\t\tsqrs[i][3] = tris[i][0] + normal;\n\t}\n\t\n\tGraph g(n);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqrs[i], tris[j])){\n\t\t\t\taddEdge(g, i, j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstd::vector<int> cmp;\n\tint k = scc(g, cmp);\n\t\n\tstd::vector<int> v(k, 1);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\tint src = g[i][j].src;\n\t\t\tint dst = g[i][j].dst;\n\t\t\tif (src != dst) v[cmp[dst]] = 0;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < k; i++){\n\t\tres += v[i];\n\t}\n\t\n\tstd::printf(\"%d\\n\", res);\n}\n\nint main()\n{\n\twhile (std::scanf(\"%d %lf\", &n, &d), n){\n\t\ttris.assign(n, geo::Polygon(3));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tdouble x, y;\n\t\t\t\tstd::cin >> x >> y;\n\t\t\t\ttris[i][j] = geo::Point(x, y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<cfloat>\n#include<tuple>\n#include<set>\n#include<stack>\n#include<algorithm>\n\nconst double INF = DBL_MAX / 3.0;\n\nconst double EPS = 1e-10;\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Polygon;\n// member\nclass Point {\ndouble x_value, y_value;\npublic:\nPoint() :x_value(0.0), y_value(0.0) {}\nPoint(double d) :x_value(d), y_value(d) {}\nPoint(double a, double b) :x_value(a), y_value(b) {}\ndouble x() const {return x_value;}\ndouble y() const {return y_value;}\ndouble x(double d) {return x_value = d;}\ndouble y(double d) {return y_value = d;}\nconst Point operator-() const;\nconst Point& operator=(const Point&);\nconst Point& operator+=(const Point&);\nconst Point& operator-=(const Point&);\nconst Point& operator*=(const Point&);\nconst Point& operator/=(const Point&);\ndouble dot(const Point&) const;\ndouble cross(const Point&) const;\ndouble abs() const;\ndouble norm() const;\nconst Point normalize() const;\ndouble distance(const Point&) const;\ndouble distance(const Segment&) const;\ndouble distance(const Line&) const;\nbool intersect(const Point&) const;\nbool intersect(const Segment&) const;\nbool intersect(const Line&) const;\nconst Point projection(const Line&) const;\nconst Point reflection(const Line&) const;\nPOSITION ccw(const Point&, const Point&) const;\n};\nbool operator==(const Point& lhs, const Point& rhs);\nbool operator!=(const Point& lhs, const Point& rhs);\nbool operator<(const Point& lhs, const Point& rhs);\nbool operator>(const Point& lhs, const Point& rhs);\nbool operator<=(const Point& lhs, const Point& rhs);\nbool operator>=(const Point& lhs, const Point& rhs);\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\nPoint source_point, target_point;\npublic:\nSegment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\nSegment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\nconst Point& source() const {return source_point;}\nconst Point& target() const {return target_point;}\nconst Point& source(const Point& p) {return source_point = p;}\nconst Point& target(const Point& p) {return target_point = p;}\nconst Line line() const;\ndouble distance(const Point&) const;\ndouble distance(const Segment&) const;\ndouble distance(const Line&) const;\nbool intersect(const Point&) const;\nbool intersect(const Segment&) const;\nbool intersect(const Line&) const;\nPOSITION ccw(const Point&) const;\n};\nclass Line {\nPoint source_point, target_point;\npublic:\nLine(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\nLine(const Point& a, const Point& b) :source_point(a), target_point(b) {}\nconst Point& source() const {return source_point;}\nconst Point& target() const {return target_point;}\nconst Point& source(const Point& p) {return source_point = p;}\nconst Point& target(const Point& p) {return target_point = p;}\nconst Segment segment() const;\ndouble distance(const Point&) const;\ndouble distance(const Segment&) const;\ndouble distance(const Line&) const;\nbool intersect(const Point&) const;\nbool intersect(const Segment&) const;\nbool intersect(const Line&) const;\nconst Point projection(const Point&) const;\nconst Point reflection(const Point&) const;\nconst Point crosspoint(const Line&) const;\nPOSITION ccw(const Point&) const;\n};\nclass Polygon {\nstd::vector<Point> point;\npublic:\nPolygon() {}\nexplicit Polygon(std::vector<Point> p) :point(p) {}\nconst std::vector<Point>& vertex() const {return point;}\nconst Point& vertex(int i) const {return point.at(i);}\nconst std::vector<Segment> edge() const {\nstd::vector<Segment> result;\nfor(int i = 0; i < size(); ++i) result.push_back(Segment(vertex(i), vertex((i + 1) % size())));\nreturn result;\n}\nconst Segment edge(int i) const {return Segment(vertex(i), vertex((i + 1) % size()));}\nint size() const {return point.size();}\nvoid add(const Point&);\ndouble area() const;\nbool convex() const;\nbool include(const Point&) const;\nbool intersect(const Polygon&) const;\nbool on_edge(const Point&) const;\nconst Polygon convex_hull() const;\n};\n// Point\nbool operator==(const Point& lhs, const Point& rhs) {return lhs.x() == rhs.x() && lhs.y() == rhs.y();}\nbool operator!=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() || lhs.y() != rhs.y();}\nbool operator<(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() < rhs.y();}\nbool operator>(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() > rhs.y();}\nbool operator<=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() < rhs.x() : lhs.y() <= rhs.y();}\nbool operator>=(const Point& lhs, const Point& rhs) {return lhs.x() != rhs.x() ? lhs.x() > rhs.x() : lhs.y() >= rhs.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\nconst Point Point::normalize() const {return abs() == 0.0 ? Point(0.0, 0.0) : Point(x(), y()) / abs();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\nconst Point& a = *this;\nPoint v1 = b - a;\nPoint v2 = p - a;\nif(v1.cross(v2) > EPS) return COUNTER_CLOCKWISE;\nif(v1.cross(v2) < -EPS) return CLOCKWISE;\nif(v1.dot(v2) < -EPS) return ONLINE_BACK;\nif(v2.norm() - v1.norm() > EPS) return ONLINE_FRONT;\nreturn ON_SEGMENT;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\nPoint q = line().projection(p);\nif(intersect(q)) return q.distance(p);\nreturn std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\nif(intersect(s)) return 0.0;\ndouble a = distance(s.source());\ndouble b = distance(s.target());\ndouble c = s.distance(source());\ndouble d = s.distance(target());\nreturn std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\nbool a = ccw(s.source()) * ccw(s.target()) <= 0;\nbool b = s.ccw(source()) * s.ccw(target()) <= 0;\nreturn a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\nif(intersect(s)) return 0.0;\ndouble a = distance(s.source());\ndouble b = distance(s.target());\nreturn a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\nPoint v1 = source() - p;\nPoint v2 = target() - p;\nreturn fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\nPoint v1 = target() - source();\nPoint v2 = s.source() - source();\nPoint v3 = s.target() - source();\nreturn v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\nPoint v1 = target() - source();\nPoint v2 = l.target() - l.source();\nPoint v3 = l.source() - source();\nreturn fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\nPoint v1 = p - source();\nPoint v2 = source() - target();\nreturn Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\nreturn p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\nPoint v1 = target() - source();\nPoint v2 = l.target() - l.source();\nPoint v3 = target() - l.source();\ndouble a = v1.cross(v2);\ndouble b = v1.cross(v3);\nif(fabs(a) <= EPS && fabs(b) <= EPS) return l.source();\nreturn l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Polygon\nvoid Polygon::add(const Point& p) {point.push_back(p);}\ndouble Polygon::area() const {\ndouble sum = 0.0;\nfor(int i = 0; i < size(); ++i) sum += vertex(i).cross(vertex((i+1) % size()));\nreturn fabs(sum) / 2.0;\n}\nbool Polygon::convex() const {\nPOSITION direction = ONLINE_BACK;\nfor(int i = 1; i < size(); ++i) {\nPOSITION d = vertex(i - 1).ccw(vertex(i), vertex((i + 1) % size()));\nif(d != CLOCKWISE && d != COUNTER_CLOCKWISE) continue;\nif(direction == ONLINE_BACK) direction = d;\nif(direction != d) return false;\n}\nreturn true;\n}\nbool Polygon::include(const Point& p) const {\nbool in = false;\nfor(int i = 0; i < size(); ++i) {\nPoint a = vertex(i) - p;\nPoint b = vertex((i + 1) % size()) - p;\nif(a.y() > b.y()) std::swap(a, b);\nif(a.y() <= 0.0 && 0 < b.y() && a.cross(b) < 0.0) in = !in;\nif(fabs(a.cross(b)) <= EPS && a.dot(b) <= EPS) return true;\n}\nreturn in;\n}\nbool Polygon::intersect(const Polygon& p) const {\nfor(const auto& e1: edge()) for(const auto& e2: p.edge()) if(e1.intersect(e2)) return true;\nreturn false;\n}\nbool Polygon::on_edge(const Point& p) const {\nfor(int i = 0; i < size(); ++i) if(vertex(i).ccw(vertex((i + 1) % size()), p) == ON_SEGMENT) return true;\nreturn false;\n}\nconst Polygon Polygon::convex_hull() const {                // Andrew's Monotone Chain\nPolygon result;\nstd::vector<Point> res;\nstd::vector<Point> original = vertex();\nsort(original.begin(), original.end());\noriginal.insert(original.end(), original.rbegin() + 1, original.rend());\nfor(const auto& v: original) {\nwhile(res.size() >= 2 && res[res.size() - 2].ccw(res[res.size() - 1], v) == CLOCKWISE) res.pop_back();\nres.push_back(v);\n}\nres.pop_back();\nfor(const auto& v: res) result.add(v);\nreturn result;\n}\n\n// Edge\nclass Edge {\nint from_value, to_value;\ndouble weight_value;\npublic:\nEdge() {}\nEdge(int f, int t, double w) :from_value(f), to_value(t), weight_value(w) {}\nint from() const {return from_value;}\nint to() const {return to_value;}\ndouble weight() const {return weight_value;}\n};\n\n// Graph\nclass Graph {\nint size_value;\nstd::vector<std::vector<Edge>> edge_value;\n\npublic:\nexplicit Graph(int s) :size_value(s) {edge_value.resize(s);}\n\nint size() const {return size_value;}\nconst std::vector<Edge>& edge(int v) const {return edge_value[v];}\n\nvoid add(const Edge& e);\nvoid add(int from, int to, double weight);\npublic:\nstd::vector<std::vector<int>> Kosaraju() const;\nprivate:\nvoid Kosaraju_dfs_postorder(int from, std::vector<bool>& visited, std::stack<int>& order) const;\nstd::vector<int> Kosaraju_dfs_decompose(const std::vector<std::vector<Edge>>& reverse_edge, int from, std::vector<bool>& visited) const;\n};\n\n// implements\nvoid Graph::add(const Edge& e) {edge_value[e.from()].push_back(e);}\nvoid Graph::add(int from, int to, double weight) {edge_value[from].push_back(Edge(from, to, weight));}\nstd::vector<std::vector<int>> Graph::Kosaraju() const {\nstd::vector<std::vector<int>> result;\nstd::vector<bool> visited(size(), false);\nstd::stack<int> order;\nfor(int v = 0; v < size(); ++v) if(!visited[v]) Kosaraju_dfs_postorder(v, visited, order);\nstd::vector<std::vector<Edge>> reverse_edge(size(), std::vector<Edge>());\nfor(int v = 0; v < size(); ++v) for(const auto& e: edge(v)) reverse_edge[e.to()].push_back(Edge(e.to(), e.from(), e.weight()));\nvisited = std::vector<bool>(size(), false);\nwhile(!order.empty()) {\nint v = order.top();\norder.pop();\nif(visited[v]) continue;\nresult.push_back(Kosaraju_dfs_decompose(reverse_edge, v, visited));\n}\nreturn result;\n}\nvoid Graph::Kosaraju_dfs_postorder(int from, std::vector<bool>& visited, std::stack<int>& order) const {\nvisited[from] = true;\nfor(const auto& e: edge(from)) if(!visited[e.to()]) Kosaraju_dfs_postorder(e.to(), visited, order);\norder.push(from);\n}\nstd::vector<int> Graph::Kosaraju_dfs_decompose(const std::vector<std::vector<Edge>>& reverse_edge, int from, std::vector<bool>& visited) const {\nstd::vector<int> result;\nresult.push_back(from);\nvisited[from] = true;\nfor(const auto& e: reverse_edge[from]) {\nif(visited[e.to()]) continue;\nstd::vector<int> add = Kosaraju_dfs_decompose(reverse_edge, e.to(), visited);\nresult.insert(result.end(), add.begin(), add.end());\n}\nreturn result;\n}\n\nusing namespace std; \nint main() {\nint n, d;\nwhile(cin >> n >> d, n | d) {\nvector<Polygon> triangle(n);\nfor(auto &t: triangle) {\nvector<Point> vertex(3);\nfor(auto &v: vertex) {\ndouble x, y;\ncin >> x >> y;\nv = Point(x, y);\n}\nif(vertex[0].distance(vertex[1]) == vertex[0].distance(vertex[2])) swap(vertex[0], vertex[2]);\nif(vertex[1].distance(vertex[0]) == vertex[1].distance(vertex[2])) swap(vertex[1], vertex[2]);\nfor(const auto &v: vertex) t.add(v);\n}\n\nvector<Polygon> light(n);\nfor(int i = 0; i < triangle.size(); ++i) {\nPoint n = (triangle[i].vertex(1) - triangle[i].vertex(0)).normalize();\nif(triangle[i].vertex(0).ccw(triangle[i].vertex(1), triangle[i].vertex(2)) > 0) n = Point(-n.y(), n.x());\nelse                                                                            n = Point(n.y(), -n.x());\nlight[i].add(triangle[i].vertex(0));\nlight[i].add(triangle[i].vertex(0) + (n * d));\nlight[i].add(triangle[i].vertex(1) + (n * d));\nlight[i].add(triangle[i].vertex(1));\n}\n\nGraph g(n);\nvector<int> indegree(n, 0);\nfor(int i = 0; i < n; ++i) {\nfor(int j = 0; j < n; ++j) {\nif(i == j) continue;\nbool shine = false;\n\n// 辺の交差判定\nfor(const auto &l: light[i].edge())\nfor(const auto &t: triangle[j].edge())\nif(l.intersect(t)) shine = true;\n// 点の包含判定\nfor(const auto &v: light[i].vertex())\nif(triangle[j].include(v)) shine = true;\nfor(const auto &v: triangle[j].vertex())\nif(light[i].include(v)) shine = true;\n// 線分と点の距離が0.01以下\nfor(const auto &l: light[i].edge())\nfor(const auto &t: triangle[j].edge())\nif(l.distance(t) <= 0.01) shine = true;\n\nif(!shine) continue;\ng.add(Edge(i, j, 1));\n++indegree[j];\n}\n}\n\nint answer = 0;\nfor(const auto& scc: g.Kosaraju()) {\nbool ok = true;\nfor(const auto& v: scc) ok &= indegree[v] == 0;\nif(ok) ++answer;\n}\ncout << answer << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS = 0.01, INF = 1e12, PI = acos(-1.0);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > EPS)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < -EPS)   return -1;\t\t// clockwise\n\tif(dot(b, c) < -EPS)     return +2;\t\t// c--a--b on line\n\tif(norm(b) + EPS < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  G ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n#include<stack>\nvoid visit(const vector<vi> &g, int v, vector<vi>& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  each(e, g[v]) {\n    int w = *e;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const vector<vi>& g,\n    vector<vi>& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint n, d;\nvector<vi> g;\n\nint main(){\n\twhile(cin >> n >> d, n){\n\t\tg.clear(); g.resize(n);\n\t\tvector<G> tri;\n\t\trep(i, n){\n\t\t\tint t;\n\t\t\tG p(3);\n\t\t\tdouble l[3];\n\t\t\trep(j, 3) cin >> p[j].real() >> p[j].imag();\n\t\t\trep(j, 3) l[j] = abs(p[j] - p[(j + 1) % 3]);\n\t\t\trep(j, 3) if(abs(l[j] - l[(j + 1) % 3]) < EPS){\n\t\t\t\tt = (j + 1) % 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswap(p[t], p[(t + 1) % 3]);\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\trep(i, n){\n\t\t\tG &p = tri[i];\n\t\t\tP dir = p[0] - (p[1] + p[2]) * 0.5;\n\t\t\tdir *= d / abs(dir);\n\t\t\t\n\t\t\tG ps;\n\t\t\tps.pb(p[1]); ps.pb(p[2]);\n\t\t\tps.pb(p[1] + dir); ps.pb(p[2] + dir);\n\t\t\tps = convex_hull(ps);\n\t\t\t\n\t\t\trep(j, n){\n\t\t\t\tbool ok = 0;\n\t\t\t\trep(k, 3) if(contains(ps, tri[j][k]) != OUT) ok = 1;\n\t\t\t\tif(ok) g[i].pb(j);\n\t\t\t}\n\t\t}\n\t\tmap<int, int> to;\n\t\tvector<vi> scc;\n\t\tstronglyConnectedComponents(g, scc);\n\t\tint m = scc.size();\n\t\tvi in(m);\n\t\t\n\t\trep(i, m) rep(j, scc[i].size()){\n\t\t\tto[scc[i][j]] = i;\n\t\t}\n\t\trep(i, n) rep(j, g[i].size()){\n\t\t\tint a = to[i], b = to[g[i][j]];\n\t\t\tif(a != b) in[b]++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\trep(i, m) if(in[i] == 0) ans++;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-2)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) + SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G &a, G &b)\n{\t\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a.size(); i++){\n\t\tif (contains(b, a[i])){\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int i = 0; i < b.size(); i++){\n\t\tif (contains(a, b[i])){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tint v = tps[i];\n\t\tif (!used[v]) res++;\n\t\tfor (int to : sccgraph[v]){\n\t\t\tused[tps[to]] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\n#include <cstring>\n\n// ???, ????????????\ntypedef std::complex<double> Point;\ntypedef Point Vector;\n\nnamespace std {\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\t\n\tistream& operator >> (istream &is, Point &a){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\ta = Point(x, y);\n\t\treturn is;\n\t}\n\t\n\tostream& operator << (ostream &os, Point a){\n\t\treturn os << a.real() << \" \" << a.imag();\n\t}\n}\n\n// ??´???\nstruct Line {\n\tPoint p1, p2;\n\tLine(){}\n\tLine(const Point &p1, const Point &p2): p1(p1), p2(p2){}\n};\ntypedef Line Segment;\n\nnamespace std {\n\tistream& operator >> (istream &is, Line &a){\n\t\treturn is >> a.p1 >> a.p2;\n\t}\n}\n\n// ???\nstruct Circle {\n\tPoint p; double r;\n\tCircle(){}\n\tCircle(const Point &p, double r): p(p), r(r){}\n};\n\nnamespace std {\n\tistream& operator >> (istream &is, Circle &a){\n\t\treturn is >> a.p >> a.r;\n\t}\n}\n\n// ????§???¢\ntypedef std::vector<Point> Polygon;\n\nconst double EPS = 1e-4;\nconst double INF = 1e12;\nconst double PI = acos(-1.0);\n\n// ????????¨??????????????¢???\nenum CCW {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0,\n};\n\n// ?????¢????£????????????¢???\nenum {\n\tOUT = 0,\n\tON = 1,\n\tIN = 2,\n};\n\n\n// a ??? 2 ??? (a ^ 2)\ndouble SQ(double a);\n\n// ?????????????????????????????¢??°\nbool EQ(double a, double b);\nbool NEQ(double a, double b);\nbool LT(double a, double b);\nbool GT(double a, double b);\nbool LEQ(double a, double b);\nbool GEQ(double a, double b);\n\n// ??§?????? <=> ?????°?????????\ndouble toDeg(double t);\ndouble toRad(double t);\n\n// ????????? (dot(a, a))\ndouble norm(const Vector &a);\n\n// ??????, ??????\ndouble dot(const Vector &a, const Vector &b);\ndouble cross(const Vector &a, const Vector &b);\n\n// ??´???, ??????\nbool orthogonal(const Segment &s1, const Segment &s2);\nbool parallel(const Segment &s1, const Segment &s2);\n\n// ?°???±, ????°?\nPoint project(const Line &l, const Point &p);\nPoint reflect(const Line &l, const Point &p);\n\n// ?????? (p0, p1) ??¨??? p2 ???????????¢???\nint ccw(const Point &p0, const Point &p1, const Point &p2);\n\n// ????????????\nbool intersectLP(const Line &l, const Point &p);\nbool intersectLL(const Line &l1, const Line &l2);\nbool intersectLS(const Line &l, const Segment &s);\nbool intersectSP(const Segment &s, const Point &p);\nbool intersectSS(const Segment &s1, const Segment &s2);\nint intersectCP(const Circle &c, const Point &p);\nbool intersectCL(const Circle &c, const Line &l);\nint intersectCS(const Circle &c, const Segment &s);\nint intersectCC(const Circle &c1, const Circle &c2);\n\n// ?????¢\ndouble distanceLP(const Line &l, const Point &p);\ndouble distanceLL(const Line &l1, const Line &l2);\ndouble distanceLS(const Line &l, const Segment &s);\ndouble distanceSP(const Segment &s, const Point &p);\ndouble distanceSS(const Segment &s1, const Segment &s2);\ndouble distanceCP(const Circle &c, const Point &p);\ndouble distanceCL(const Circle &c, const Line &l);\ndouble distanceCS(const Circle &c, const Segment &s);\ndouble distanceCC(const Circle &c1, const Circle &c2);\n\n// ??????\nPoint crossPointLL(const Line &l1, const Line &l2);\nPoint crossPointLS(const Line &l, const Segment &s);\nPoint crossPointSS(const Segment &s1, const Segment &s2);\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l);\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s);\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2);\n\n\ndouble SQ(double a){\n\treturn a * a;\n}\n\nbool EQ(double a, double b){\n\treturn std::abs(a - b) < EPS;\n}\n\nbool NEQ(double a, double b){\n\treturn !EQ(a, b);\n}\n\nbool LT(double a, double b){\n\treturn a - b < -EPS;\n}\n\nbool GT(double a, double b){\n\treturn a - b > EPS;\n}\n\nbool LEQ(double a, double b){\n\treturn !GT(a, b);\n}\n\nbool GEQ(double a, double b){\n\treturn !LT(a, b);\n}\n\ndouble toDeg(double t){\n\treturn t * 180 / PI;\n}\n\ndouble toRad(double t){\n\treturn t / 180 * PI;\n}\n\ndouble norm(const Vector &a){\n\treturn SQ(a.real()) + SQ(a.imag());\n}\n\ndouble dot(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).real();\n}\n\ndouble cross(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).imag();\n}\n\n// AOJ CGL_2_A\nbool orthogonal(const Segment &s1, const Segment &s2){\n\treturn EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_2_A\nbool parallel(const Segment &s1, const Segment &s2){\n\treturn EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_1_A\nPoint project(const Line &l, const Point &p){\n\tVector base = l.p2 - l.p1;\n\tdouble r = dot(p - l.p1, base) / norm(base);\n\treturn l.p1 + base * r;\n}\n\n// AOJ CGL_1_B\nPoint reflect(const Line &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2.0;\n}\n\n// AOJ CGL_1_C\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (GT(cross(a, b), 0.0)) return COUNTER_CLOCKWISE;\n\tif (LT(cross(a, b), 0.0)) return CLOCKWISE;\n\tif (LT(dot(a, b), 0.0)) return ONLINE_BACK;\n\tif (LT(norm(a), norm(b))) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersectLP(const Line &l, const Point &p){\n\treturn LEQ(std::abs(cross(l.p1 - p, l.p2 - p)), 0.0);\n}\n\nbool intersectLL(const Line &l1, const Line &l2){\n\treturn !parallel(l1, l2) || LEQ(std::abs(cross(l1.p2 - l1.p1, l2.p1 - l1.p1)), 0.0);\n}\n\nbool intersectLS(const Line &l, const Segment &s){\n\treturn LEQ(cross(l.p2 - l.p1, s.p1 - l.p1) * cross(l.p2 - l.p1, s.p2 - l.p1), 0.0);\n}\n\nbool intersectSP(const Segment &s, const Point &p){\n\treturn norm(s.p1 - p) + norm(s.p2 - p) - norm(s.p2 - s.p1) < EPS;\n}\n\n// CGL_2_B\nbool intersectSS(const Segment &s1, const Segment &s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\nint intersectCP(const Circle &c, const Point &p){\n\tdouble dd = norm(c.p - p);\n\tif (LT(dd, SQ(c.r))) return IN;\n\tif (EQ(dd, SQ(c.r))) return ON;\n\treturn OUT;\n}\n\nbool intersectCL(const Circle &c, const Line &l){\n\tdouble d = distanceLP(l, c.p);\n\treturn LEQ(d, c.r);\n}\n\nint intersectCS(const Circle &c, const Segment &s){\n\tdouble dd1 = norm(c.p - s.p1);\n\tdouble dd2 = norm(c.p - s.p2);\n\tif (LT(dd1, SQ(c.r)) && LT(dd2, SQ(c.r))) return IN;\n\tif (GT(distanceCS(c, s), 0.0)) return OUT;\n\treturn ON;\n}\n\n// c1 ??? c2 ???????????????????????¨??? IN\n// c1 ??? c2 ????????£???????????¨??? ON\n// c1 ??? c2 ?????????????????¨??? OUT\nint intersectCC(const Circle &c1, const Circle &c2){\n\tif (GT(norm(c1.p - c2.p), SQ(c1.r + c2.r))) return OUT;\n\tif (LT(norm(c1.p - c2.p), SQ(c2.r))) return IN;\n\tif (LT(norm(c1.p - c2.p), SQ(c1.r))) return OUT;\n\treturn ON;\n}\n\ndouble distanceLP(const Line &l, const Point &p){\n\treturn std::abs(cross(l.p2 - l.p1, p - l.p1)) / std::abs(l.p2 - l.p1);\n}\n\ndouble distanceLL(const Line &l1, const Line &l2){\n\tif (intersectLL(l1, l2)) return 0.0;\n\treturn distanceLP(l1, l2.p1);\n}\n\ndouble distanceLS(const Line &l, const Segment &s){\n\tif (intersectLS(l, s)) return 0.0;\n\treturn std::min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\n\ndouble distanceSP(const Segment &s, const Point &p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return std::abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return std::abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\n// AOJ CGL_2_D\ndouble distanceSS(const Segment &s1, const Segment &s2){\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn std::min(\n\t\tstd::min(\n\t\t\tdistanceSP(s1, s2.p1),\n\t\t\tdistanceSP(s1, s2.p2)\n\t\t),\n\t\tstd::min(\n\t\t\tdistanceSP(s2, s1.p1),\n\t\t\tdistanceSP(s2, s1.p2)\n\t\t)\n\t);\n}\n\ndouble distanceCP(const Circle &c, const Point &p){\n\treturn std::abs(std::abs(c.p - p) - c.r);\n} \n\ndouble distanceCL(const Circle &c, const Line &l){\n\tif (intersectCL(c, l)) return 0.0;\n\treturn distanceLP(l, c.p) - c.r;\n}\n\ndouble distanceCS(const Circle &c, const Segment &s){\n\tif (intersectCS(c, s)) return 0.0;\n\treturn std::min(distanceCP(c, s.p1), distanceCP(c, s.p2));\n}\n\ndouble distanceCC(const Circle &c1, const Circle &c2){\n\tif (intersectCC(c1, c2) == ON) return 0.0;\n\tif (intersectCC(c1, c2) == IN){\n\t\treturn c2.r - (std::abs(c1.p - c2.p) + c1.r);\n\t}\n\tif (intersectCC(c2, c1) == IN){\n\t\treturn c1.r - (std::abs(c1.p - c2.p) + c2.r);\n\t}\n\treturn (c1.r + c2.r) - (c1.r + c2.r);\n}\n\nPoint crossPointLL(const Line &l1, const Line &l2){\n\tassert(intersectLL(l1, l2));\n\tVector base = l2.p2 - l2.p1;\n\tdouble d1 = std::abs(cross(base, l1.p1 - l2.p1));\n\tdouble d2 = std::abs(cross(base, l1.p2 - l2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn l1.p1 + (l1.p2 - l1.p1) * t;\n}\n\nPoint crossPointLS(const Line &l, const Segment &s){\n\tassert(intersectLS(l, s));\n\treturn crossPointLL(l, s);\n}\n\nPoint crossPointSS(const Segment &s1, const Segment &s2){\n\tassert(intersectSS(s1, s2));\n\treturn crossPointSS(s1, s2);\n}\n\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l){\n\tif (!intersectCL(c, l)) return std::vector<Point>();\n\tstd::vector<Point> ret;\n\tVector proj = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / std::abs(l.p2 - l.p1);\n\tdouble base = sqrt(SQ(c.r) - norm(proj - c.p));\n\tret.push_back(proj + e * base);\n\tret.push_back(proj - e * base);\n\treturn ret;\n}\n\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s){\n\tstd::vector<Point> ret = crossPointCL(c, s);\n\tfor (int i = 0; i < ret.size(); i++){\n\t\tif (!intersectCP(c, ret[i])){\n\t\t\tswap(ret[i], ret.back());\n\t\t\tret.pop_back();\n\t\t\ti--;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2){\n\tif (!intersectCC(c1, c2)) return std::vector<Point>();\n\tstd::vector<Point> ret;\n\tdouble d = std::abs(c1.p - c2.p);\n\tdouble a = std::acos((SQ(c1.r) + SQ(d) - SQ(c2.r)) / (2 * c1.r * d));\n\tdouble t = std::arg(c2.p - c1.p);\n\tret.push_back(c1.p + std::polar(c1.r, t + a));\n\tret.push_back(c1.p + std::polar(c1.r, t - a));\n\treturn ret;\n}\n\nnamespace {\nenum {DIRECTED, UNDIRECTED};\nconst int GRAPH_TYPE = DIRECTED;\n\ntypedef int Weight;\nconst Weight INF = 1 << 28;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge() {}\n\tEdge(int src, int dst, Weight weight = 1): src(src), dst(dst), weight(weight) {}\n\tbool operator < (const Edge &t) const { return weight < t.weight; }\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n\nvoid addEdge(Graph &g, int src, int dst, int weight = 1)\n{\n\tg[src].push_back(Edge(src, dst, weight));\n\tif (GRAPH_TYPE == UNDIRECTED) g[dst].push_back(Edge(dst, src, weight));\n};\n\nGraph transpose(const Graph &g)\n{\n\tGraph rg(g.size());\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\taddEdge(rg, g[i][j].dst, g[i][j].src, g[i][j].weight);\n\t\t}\n\t}\n\treturn rg;\n}\n\nvoid dfs_(const Graph &g, int v, bool *used, std::vector<int> &vs)\n{\n\tused[v] = true;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) dfs_(g, to, used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs_(const Graph &g, int v, int k, bool *used, std::vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) rdfs_(g, to, k, used, cmp);\n\t}\n}\n\nint scc(const Graph &g, std::vector<int> &cmp)\n{\n\tGraph rg = transpose(g);\n\tstd::vector<int> vs;\n\tbool *used = new bool[g.size()];\n\tcmp.resize(g.size());\n\t\n\tstd::memset(used, false, g.size());\n\tfor (int v = 0; v < g.size(); v++){\n\t\tif (!used[v]) dfs_(g, v, used, vs);\n\t}\n\t\n\tstd::memset(used, false, g.size());\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs_(rg, vs[i], k++, used, cmp);\n\t}\n\t\n\tdelete used;\n\treturn k;\n}\n}\n\n\nusing namespace std;\n\nint n;\ndouble d;\nvector<Polygon> tri;\nvector<Polygon> rect;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment s(g[i], g[(i + 1) % g.size()]);\n\t\t\tSegment t(h[j], h[(j + 1) % h.size()]);\n\t\t\tif (LEQ(distanceSS(s, t), 0.01)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint solve()\n{\n\trect.assign(n, Polygon(4));\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tif (EQ(norm(tri[i][j] - tri[i][(j + 1) % 3]), norm(tri[i][j] - tri[i][(j + 2) % 3]))){\n\t\t\t\tswap(tri[i][0], tri[i][j]);\n\t\t\t}\n\t\t}\n\t\tif (ccw(tri[i][1], tri[i][2], tri[i][0]) == CLOCKWISE){\n\t\t\tswap(tri[i][1], tri[i][2]);\n\t\t}\n\t\t\n\t\tVector s = tri[i][2] - tri[i][1];\n\t\tVector normal = s / abs(s) * Vector(0, 1) * d;\n\t\trect[i][0] = tri[i][1];\n\t\trect[i][1] = tri[i][2];\n\t\trect[i][2] = tri[i][2] + normal;\n\t\trect[i][3] = tri[i][1] + normal;\n\t}\n\t\n\tGraph graph(n);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(rect[i], tri[j])){\n\t\t\t\taddEdge(graph, i, j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tint v = scc(graph, cmp);\n\tint mat[100][100] = {};\n\tint in[100] = {};\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < graph[i].size(); j++){\n\t\t\tint src = cmp[i];\n\t\t\tint dst = cmp[graph[i][j].dst];\n\t\t\tif (src == dst) continue;\n\t\t\tif (mat[src][dst]++) continue;\n\t\t\tin[dst]++;\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < v; i++){\n\t\tif (in[i] == 0) res++;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tstd::cout << std::fixed << std::setprecision(12);\n\t\n\twhile (cin >> n >> d, n){\n\t\ttri.assign(n, Polygon(3));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-5, AD = 1e-2;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0){\n\t    swap(rect[i][0],rect[i][1]); break;\n\t  }\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k])){\n\t    f = true; break;\n\t  }\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3)if(seg_p_dis(rseg,tri[j][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,3){\n\t    L tseg = L(tri[j][k],rect[j][(k+1)%3]);\n\t    rep(l,4)if(seg_p_dis(tseg,rect[i][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "3 4\n1 0 3 0 2 1\n2 3 2 5 3 4\n5 3 5 5 6 4\n3 2\n1 0 3 0 2 1\n2 3 2 5 3 4\n5 3 5 5 6 4\n0 0"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\n#include <cstring>\n\n// ???, ????????????\ntypedef std::complex<double> Point;\ntypedef Point Vector;\n\nnamespace std {\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\t\n\tistream& operator >> (istream &is, Point &a){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\ta = Point(x, y);\n\t\treturn is;\n\t}\n\t\n\tostream& operator << (ostream &os, Point a){\n\t\treturn os << a.real() << \" \" << a.imag();\n\t}\n}\n\n// ??´???\nstruct Line {\n\tPoint p1, p2;\n\tLine(){}\n\tLine(const Point &p1, const Point &p2): p1(p1), p2(p2){}\n};\ntypedef Line Segment;\n\nnamespace std {\n\tistream& operator >> (istream &is, Line &a){\n\t\treturn is >> a.p1 >> a.p2;\n\t}\n}\n\n// ???\nstruct Circle {\n\tPoint p; double r;\n\tCircle(){}\n\tCircle(const Point &p, double r): p(p), r(r){}\n};\n\nnamespace std {\n\tistream& operator >> (istream &is, Circle &a){\n\t\treturn is >> a.p >> a.r;\n\t}\n}\n\n// ????§???¢\ntypedef std::vector<Point> Polygon;\n\nconst double EPS = 1e-12;\nconst double INF = 1e12;\nconst double PI = acos(-1.0);\n\n// ????????¨??????????????¢???\nenum CCW {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0,\n};\n\n// ?????¢????£????????????¢???\nenum {\n\tOUT = 0,\n\tON = 1,\n\tIN = 2,\n};\n\n\n// a ??? 2 ??? (a ^ 2)\ndouble SQ(double a);\n\n// ?????????????????????????????¢??°\nbool EQ(double a, double b);\nbool NEQ(double a, double b);\nbool LT(double a, double b);\nbool GT(double a, double b);\nbool LEQ(double a, double b);\nbool GEQ(double a, double b);\n\n// ??§?????? <=> ?????°?????????\ndouble toDeg(double t);\ndouble toRad(double t);\n\n// ????????? (dot(a, a))\ndouble norm(const Vector &a);\n\n// ??????, ??????\ndouble dot(const Vector &a, const Vector &b);\ndouble cross(const Vector &a, const Vector &b);\n\n// ??´???, ??????\nbool orthogonal(const Segment &s1, const Segment &s2);\nbool parallel(const Segment &s1, const Segment &s2);\n\n// ?°???±, ????°?\nPoint project(const Line &l, const Point &p);\nPoint reflect(const Line &l, const Point &p);\n\n// ?????? (p0, p1) ??¨??? p2 ???????????¢???\nint ccw(const Point &p0, const Point &p1, const Point &p2);\n\n// ????????????\nbool intersectLP(const Line &l, const Point &p);\nbool intersectLL(const Line &l1, const Line &l2);\nbool intersectLS(const Line &l, const Segment &s);\nbool intersectSP(const Segment &s, const Point &p);\nbool intersectSS(const Segment &s1, const Segment &s2);\nint intersectCP(const Circle &c, const Point &p);\nbool intersectCL(const Circle &c, const Line &l);\nint intersectCS(const Circle &c, const Segment &s);\nint intersectCC(const Circle &c1, const Circle &c2);\n\n// ?????¢\ndouble distanceLP(const Line &l, const Point &p);\ndouble distanceLL(const Line &l1, const Line &l2);\ndouble distanceLS(const Line &l, const Segment &s);\ndouble distanceSP(const Segment &s, const Point &p);\ndouble distanceSS(const Segment &s1, const Segment &s2);\ndouble distanceCP(const Circle &c, const Point &p);\ndouble distanceCL(const Circle &c, const Line &l);\ndouble distanceCS(const Circle &c, const Segment &s);\ndouble distanceCC(const Circle &c1, const Circle &c2);\n\n// ??????\nPoint crossPointLL(const Line &l1, const Line &l2);\nPoint crossPointLS(const Line &l, const Segment &s);\nPoint crossPointSS(const Segment &s1, const Segment &s2);\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l);\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s);\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2);\n\n\ndouble SQ(double a){\n\treturn a * a;\n}\n\nbool EQ(double a, double b){\n\treturn std::abs(a - b) < EPS;\n}\n\nbool NEQ(double a, double b){\n\treturn !EQ(a, b);\n}\n\nbool LT(double a, double b){\n\treturn a - b < -EPS;\n}\n\nbool GT(double a, double b){\n\treturn a - b > EPS;\n}\n\nbool LEQ(double a, double b){\n\treturn !GT(a, b);\n}\n\nbool GEQ(double a, double b){\n\treturn !LT(a, b);\n}\n\ndouble toDeg(double t){\n\treturn t * 180 / PI;\n}\n\ndouble toRad(double t){\n\treturn t / 180 * PI;\n}\n\ndouble norm(const Vector &a){\n\treturn SQ(a.real()) + SQ(a.imag());\n}\n\ndouble dot(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).real();\n}\n\ndouble cross(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).imag();\n}\n\n// AOJ CGL_2_A\nbool orthogonal(const Segment &s1, const Segment &s2){\n\treturn EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_2_A\nbool parallel(const Segment &s1, const Segment &s2){\n\treturn EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_1_A\nPoint project(const Line &l, const Point &p){\n\tVector base = l.p2 - l.p1;\n\tdouble r = dot(p - l.p1, base) / norm(base);\n\treturn l.p1 + base * r;\n}\n\n// AOJ CGL_1_B\nPoint reflect(const Line &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2.0;\n}\n\n// AOJ CGL_1_C\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (GT(cross(a, b), 0.0)) return COUNTER_CLOCKWISE;\n\tif (LT(cross(a, b), 0.0)) return CLOCKWISE;\n\tif (LT(dot(a, b), 0.0)) return ONLINE_BACK;\n\tif (LT(norm(a), norm(b))) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersectLP(const Line &l, const Point &p){\n\treturn LEQ(std::abs(cross(l.p1 - p, l.p2 - p)), 0.0);\n}\n\nbool intersectLL(const Line &l1, const Line &l2){\n\treturn !parallel(l1, l2) || LEQ(std::abs(cross(l1.p2 - l1.p1, l2.p1 - l1.p1)), 0.0);\n}\n\nbool intersectLS(const Line &l, const Segment &s){\n\treturn LEQ(cross(l.p2 - l.p1, s.p1 - l.p1) * cross(l.p2 - l.p1, s.p2 - l.p1), 0.0);\n}\n\nbool intersectSP(const Segment &s, const Point &p){\n\treturn norm(s.p1 - p) + norm(s.p2 - p) - norm(s.p2 - s.p1) < EPS;\n}\n\n// CGL_2_B\nbool intersectSS(const Segment &s1, const Segment &s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\nint intersectCP(const Circle &c, const Point &p){\n\tdouble dd = norm(c.p - p);\n\tif (LT(dd, SQ(c.r))) return IN;\n\tif (EQ(dd, SQ(c.r))) return ON;\n\treturn OUT;\n}\n\nbool intersectCL(const Circle &c, const Line &l){\n\tdouble d = distanceLP(l, c.p);\n\treturn LEQ(d, c.r);\n}\n\nint intersectCS(const Circle &c, const Segment &s){\n\tdouble dd1 = norm(c.p - s.p1);\n\tdouble dd2 = norm(c.p - s.p2);\n\tif (LT(dd1, SQ(c.r)) && LT(dd2, SQ(c.r))) return IN;\n\tif (GT(distanceCS(c, s), 0.0)) return OUT;\n\treturn ON;\n}\n\n// c1 ??? c2 ???????????????????????¨??? IN\n// c1 ??? c2 ????????£???????????¨??? ON\n// c1 ??? c2 ?????????????????¨??? OUT\nint intersectCC(const Circle &c1, const Circle &c2){\n\tif (GT(norm(c1.p - c2.p), SQ(c1.r + c2.r))) return OUT;\n\tif (LT(norm(c1.p - c2.p), SQ(c2.r))) return IN;\n\tif (LT(norm(c1.p - c2.p), SQ(c1.r))) return OUT;\n\treturn ON;\n}\n\ndouble distanceLP(const Line &l, const Point &p){\n\treturn std::abs(cross(l.p2 - l.p1, p - l.p1)) / std::abs(l.p2 - l.p1);\n}\n\ndouble distanceLL(const Line &l1, const Line &l2){\n\tif (intersectLL(l1, l2)) return 0.0;\n\treturn distanceLP(l1, l2.p1);\n}\n\ndouble distanceLS(const Line &l, const Segment &s){\n\tif (intersectLS(l, s)) return 0.0;\n\treturn std::min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\n\ndouble distanceSP(const Segment &s, const Point &p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return std::abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return std::abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\n// AOJ CGL_2_D\ndouble distanceSS(const Segment &s1, const Segment &s2){\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn std::min(\n\t\tstd::min(\n\t\t\tdistanceSP(s1, s2.p1),\n\t\t\tdistanceSP(s1, s2.p2)\n\t\t),\n\t\tstd::min(\n\t\t\tdistanceSP(s2, s1.p1),\n\t\t\tdistanceSP(s2, s1.p2)\n\t\t)\n\t);\n}\n\ndouble distanceCP(const Circle &c, const Point &p){\n\treturn std::abs(std::abs(c.p - p) - c.r);\n} \n\ndouble distanceCL(const Circle &c, const Line &l){\n\tif (intersectCL(c, l)) return 0.0;\n\treturn distanceLP(l, c.p) - c.r;\n}\n\ndouble distanceCS(const Circle &c, const Segment &s){\n\tif (intersectCS(c, s)) return 0.0;\n\treturn std::min(distanceCP(c, s.p1), distanceCP(c, s.p2));\n}\n\ndouble distanceCC(const Circle &c1, const Circle &c2){\n\tif (intersectCC(c1, c2) == ON) return 0.0;\n\tif (intersectCC(c1, c2) == IN){\n\t\treturn c2.r - (std::abs(c1.p - c2.p) + c1.r);\n\t}\n\tif (intersectCC(c2, c1) == IN){\n\t\treturn c1.r - (std::abs(c1.p - c2.p) + c2.r);\n\t}\n\treturn (c1.r + c2.r) - (c1.r + c2.r);\n}\n\nPoint crossPointLL(const Line &l1, const Line &l2){\n\tassert(intersectLL(l1, l2));\n\tVector base = l2.p2 - l2.p1;\n\tdouble d1 = std::abs(cross(base, l1.p1 - l2.p1));\n\tdouble d2 = std::abs(cross(base, l1.p2 - l2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn l1.p1 + (l1.p2 - l1.p1) * t;\n}\n\nPoint crossPointLS(const Line &l, const Segment &s){\n\tassert(intersectLS(l, s));\n\treturn crossPointLL(l, s);\n}\n\nPoint crossPointSS(const Segment &s1, const Segment &s2){\n\tassert(intersectSS(s1, s2));\n\treturn crossPointSS(s1, s2);\n}\n\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l){\n\tif (!intersectCL(c, l)) return std::vector<Point>();\n\tstd::vector<Point> ret;\n\tVector proj = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / std::abs(l.p2 - l.p1);\n\tdouble base = sqrt(SQ(c.r) - norm(proj - c.p));\n\tret.push_back(proj + e * base);\n\tret.push_back(proj - e * base);\n\treturn ret;\n}\n\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s){\n\tstd::vector<Point> ret = crossPointCL(c, s);\n\tfor (int i = 0; i < ret.size(); i++){\n\t\tif (!intersectCP(c, ret[i])){\n\t\t\tswap(ret[i], ret.back());\n\t\t\tret.pop_back();\n\t\t\ti--;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2){\n\tif (!intersectCC(c1, c2)) return std::vector<Point>();\n\tstd::vector<Point> ret;\n\tdouble d = std::abs(c1.p - c2.p);\n\tdouble a = std::acos((SQ(c1.r) + SQ(d) - SQ(c2.r)) / (2 * c1.r * d));\n\tdouble t = std::arg(c2.p - c1.p);\n\tret.push_back(c1.p + std::polar(c1.r, t + a));\n\tret.push_back(c1.p + std::polar(c1.r, t - a));\n\treturn ret;\n}\n\nnamespace {\nenum {DIRECTED, UNDIRECTED};\nconst int GRAPH_TYPE = DIRECTED;\n\ntypedef int Weight;\nconst Weight INF = 1 << 28;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge() {}\n\tEdge(int src, int dst, Weight weight = 1): src(src), dst(dst), weight(weight) {}\n\tbool operator < (const Edge &t) const { return weight < t.weight; }\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n\nvoid addEdge(Graph &g, int src, int dst, int weight = 1)\n{\n\tg[src].push_back(Edge(src, dst, weight));\n\tif (GRAPH_TYPE == UNDIRECTED) g[dst].push_back(Edge(dst, src, weight));\n};\n\nGraph transpose(const Graph &g)\n{\n\tGraph rg(g.size());\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\taddEdge(rg, g[i][j].dst, g[i][j].src, g[i][j].weight);\n\t\t}\n\t}\n\treturn rg;\n}\n\nvoid dfs_(const Graph &g, int v, bool *used, std::vector<int> &vs)\n{\n\tused[v] = true;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) dfs_(g, to, used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs_(const Graph &g, int v, int k, bool *used, std::vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) rdfs_(g, to, k, used, cmp);\n\t}\n}\n\nint scc(const Graph &g, std::vector<int> &cmp)\n{\n\tGraph rg = transpose(g);\n\tstd::vector<int> vs;\n\tbool *used = new bool[g.size()];\n\tcmp.resize(g.size());\n\t\n\tstd::memset(used, false, g.size());\n\tfor (int v = 0; v < g.size(); v++){\n\t\tif (!used[v]) dfs_(g, v, used, vs);\n\t}\n\t\n\tstd::memset(used, false, g.size());\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs_(rg, vs[i], k++, used, cmp);\n\t}\n\t\n\tdelete used;\n\treturn k;\n}\n}\n\n\nusing namespace std;\n\nint n;\ndouble d;\nvector<Polygon> tri;\nvector<Polygon> rect;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment s(g[i], g[(i + 1) % g.size()]);\n\t\t\tSegment t(h[j], h[(j + 1) % h.size()]);\n\t\t\tif (LEQ(distanceSS(s, t), 0.01)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint solve()\n{\n\trect.assign(n, Polygon(4));\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tif (EQ(norm(tri[i][j] - tri[i][(j + 1) % 3]), norm(tri[i][j] - tri[i][(j + 2) % 3]))){\n\t\t\t\tswap(tri[i][0], tri[i][j]);\n\t\t\t}\n\t\t}\n\t\tif (ccw(tri[i][1], tri[i][2], tri[i][0]) == CLOCKWISE){\n\t\t\tswap(tri[i][1], tri[i][2]);\n\t\t}\n\t\t\n\t\tVector s = tri[i][2] - tri[i][1];\n\t\tVector normal = s / abs(s) * Vector(0, 1) * d;\n\t\trect[i][0] = tri[i][1];\n\t\trect[i][1] = tri[i][2];\n\t\trect[i][2] = tri[i][2] + normal;\n\t\trect[i][3] = tri[i][1] + normal;\n\t}\n\t\n\tGraph graph(n);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(rect[i], tri[j])){\n\t\t\t\taddEdge(graph, i, j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tint v = scc(graph, cmp);\n\tint mat[100][100] = {};\n\tint in[100] = {};\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < graph[i].size(); j++){\n\t\t\tint src = cmp[i];\n\t\t\tint dst = cmp[graph[i][j].dst];\n\t\t\tif (src == dst) continue;\n\t\t\tif (mat[src][dst]++) continue;\n\t\t\tin[dst]++;\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < v; i++){\n\t\tif (in[i] == 0) res++;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tstd::cout << std::fixed << std::setprecision(12);\n\t\n\twhile (cin >> n >> d, n){\n\t\ttri.assign(n, Polygon(3));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst double EPS = 0.01;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n//????????´???????£???????????????????(??????????????£???????????????)\nenum{NO_HIT=0, HIT, A_IN_B, B_IN_A};\nint HitPol_Pol(const polygon& a, const polygon& b){\n\tbool f = true, hit = false;\n\trep(i, a.size()){\n\t\tif(!contains(b, a[i])) f = false;\n\t\telse hit = true;\n\t}\n\tif(f) return A_IN_B;\n\tf = true;\n\trep(i, b.size()){\n\t\tif(!contains(a, b[i])) f = false;\n\t\telse hit = true;\n\t}\n\tif(f) return B_IN_A;\n\tif(hit) return HIT;\n\trep(i, a.size()) rep(j, b.size()){\n\t\tL la(curr(a, i), next(a, i)), lb(curr(b, j), next(b, j));\n\t\tif(intersectSS(la, lb)) return HIT;\n\t}\n\treturn NO_HIT;\n}\n//point???theta???????????¢\npoint spinP(const point& p, double theta){\n\treturn p*complex<double>(cos(theta),sin(theta));\n}\npoint spinPExtend(const point& p, double theta, double rate){\n\treturn p*complex<double>(rate*cos(theta),rate*sin(theta));\n}\n\nstruct SCC{//O(V+E)\n    static const int MAX_V = 1010;\n    int V;\n    vector<int> G[MAX_V], rG[MAX_V];\n    vector<int> vs;\n    bool used[MAX_V];\n    int cmp[MAX_V];\n    vector<vector<int> > res;\n \n \n    SCC(int v) : V(v){};\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n \n    void dfs(int v){\n        used[v] = true;\n        for(int i = 0; i < G[v].size(); i++){\n            if(!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v] = true;\n        cmp[v] = k;\n        for(int i = 0; i < rG[v].size(); i++){\n            if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n \n    int scc(){\n        memset(used, 0, sizeof(used));\n        vs.clear();\n        for(int v = 0; v < V; v++){\n            if(!used[v]) dfs(v);\n        }\n        memset(used, 0, sizeof(used));\n        int k = 0;\n        for(int i = vs.size() - 1; i >= 0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++);\n        }\n \n        res.clear();\n        res.resize(k);\n        for(int i = 0; i < V; i++){\n            res[cmp[i]].push_back(i);\n        }\n        return k;\n    }\n};\n\nint main(){\n\tint n, d;\n\twhile(cin >> n >> d && (n+d)){\n\t\tvector<polygon> tri(n);\n\t\trep(i, n){\n\t\t\tdouble x, y;\n\t\t\trep(j, 3){\n\t\t\t\tcin >> x >> y;\n\t\t\t\ttri[i].pb({x, y});\n\t\t\t}\n\t\t}\n\t\tvector<polygon> pol(n);\n\t\trep(i, n){\n\t\t\tdouble dist[3];\n\t\t\trep(j, 3){\n\t\t\t\tdist[j] = abs(curr(tri[i], j)-next(tri[i], j));\n\t\t\t}\n\t\t\trep(j, 3) {\n\t\t\t\tif(abs(dist[j] - dist[(j+1)%3])<1e-8){\n\t\t\t\t\tpol[i].pb(tri[i][j]);\n\t\t\t\t\tpol[i].pb(tri[i][(j+2)%3]);\n\t\t\t\t\tpol[i].pb(spinPExtend(pol[i][0]-pol[i][1], (ccw(pol[i][1], pol[i][0], tri[i][(j+1)%3])> 0)?PI/2:PI/2*3, d/abs(pol[i][1]-pol[i][0]))+pol[i][1]);\n\t\t\t\t\tpol[i].pb(pol[i][2]+pol[i][0]-pol[i][1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSCC scc(n);\n\t\trep(i, n) rep(j, i){\n\t\t\tif(HitPol_Pol(pol[i], tri[j])>0) scc.add_edge(i, j);\n\t\t\tif(HitPol_Pol(tri[i], pol[j])>0) scc.add_edge(j, i);\n\t\t}\n\t\tscc.scc();\n\t\tvector<int> f(scc.res.size(), 1);\n\t\trep(i, n) rep(j, i){\n\t\t\tif(scc.cmp[i] == scc.cmp[j]) continue;\n\t\t\tif(HitPol_Pol(pol[i], tri[j])!=NO_HIT) f[scc.cmp[j]] = 0;\n\t\t\telse if(HitPol_Pol(tri[i], pol[j])!=NO_HIT) f[scc.cmp[i]] = 0;\n\t\t}\n\t\tcout<<accumulate(all(f), 0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n        ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      /*\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n      */\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }else if (is_intersected_polygon(tri[i],tri[j])){\n\t//\tassert(false);\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    d+=0.0001;\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < (int)n; i++)\n//#define EPS (1e-8)\n#define EPS 0.01\n#define equals(a, b) (fabs((a) - (b)) <= EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n\n#define MAX 100\n\nclass Point{\n    public:\n    double x, y;\n    \n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) <= EPS && fabs(y-p.y) <= EPS;\n    }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ) { return sqrt(norm(a)); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t     ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool isInside(Polygon gon, Point p ){\n    for ( int i = 0; i < gon.size(); i++ ){\n\tif ( ccw(gon[i], gon[(i+1)%gon.size()], p) == CLOCKWISE ) return false;\n    }\n    return true;\n}\n\nclass Triangle{\n    public:\n    vector<Point> P;\n    Triangle(){ P.resize(3);}\n\n    void normalize(){\n\tvector<Point> tmp(3);\n\tif ( norm(P[0]-P[1]) == norm(P[0]-P[2]) ){\n\t    tmp[0] = P[1]; tmp[1] = P[2]; tmp[2] = P[0];\n\t} else if ( norm(P[1]-P[0]) == norm(P[1]-P[2]) ){\n\t    tmp[0] = P[0]; tmp[1] = P[2]; tmp[2] = P[1];\n\t} else if ( norm(P[2]-P[0]) == norm(P[2]-P[1]) ){\n\t    tmp[0] = P[0]; tmp[1] = P[1]; tmp[2] = P[2];\n\t}\n\tP = tmp;\n\tif ( ccw(P[0], P[1], P[2]) != COUNTER_CLOCKWISE ) {\n\t    swap(P[0], P[1]);\n\t}\n    }\n\n    double getArea(){\n\tdouble a = abs(P[0]-P[1]); \n\tdouble b = abs(P[0]-P[2]); \n\tdouble c = abs(P[2]-P[1]); \n\tassert(!(a==b && a==c && b==c));\n\tdouble s= (a + b + c)/2.0;\n\treturn sqrt(s*(s-a)*(s-b)*(s-c));\n    }\n\n};\n\nclass Graph{\npublic:\n    int n;\n    vector<vector<int> > adj;\n    Graph(int n = 0):n(n){\n\tadj.resize(n);\n\trep(i, n) adj[i].clear();\n    }\n    void connect(int i, int j){ adj[i].push_back(j); }\n    void transpose(){\n\tvector<vector<int> > nadj;\n\tnadj.resize(n);\n\trep(i, n) nadj[i].clear();\n\trep(i, n) rep(j, adj[i].size())\tnadj[adj[i][j]].push_back(i);\n\trep(i, n) adj[i] = nadj[i];\n    }\n};\n\nint n;\ndouble d;\nTriangle T[MAX];\n\nGraph g;\nint visited[MAX], finish[MAX], t;\nvector<int> com;\n\nbool overlapPolygon(Polygon p1, Polygon p2){\n    rep(i, p1.size()) if ( isInside(p2, p1[i]) ) return true;\n    rep(i, p2.size()) if ( isInside(p1, p2[i]) ) return true;\n    rep(i, p1.size()) rep(j, p2.size()){\n      if ( isIntersect(p1[i], p1[(i+1)%p1.size()], p2[j], p2[(j+1)%p2.size()])) return true;\n    }\n    return false;\n}\n\nbool overlap( int t1, int t2){\n    Triangle s = T[t1];\n    vector<Point> rect, tri;\n    Point c = Point((s.P[0].x+s.P[1].x)/2, (s.P[0].y+s.P[1].y)/2);\n    Vector v = s.P[2] - c;\n    double a = v.abs();\n    v.x = d*v.x/a;\n    v.y = d*v.y/a;\n    Point l = s.P[0] + v;\n    Point r = s.P[1] + v;\n    rect.push_back(s.P[1]);\n    rect.push_back(r);\n    rect.push_back(l);\n    rect.push_back(s.P[0]);\n\n    assert( isInside(rect, s.P[0]) &&\n\t    isInside(rect, s.P[1]) &&\n\t    isInside(rect, s.P[2]));\n\n    tri = T[t2].P;\n    return overlapPolygon(rect, tri);\n}\n\nvoid dfs(int &u){\n    visited[u] = t++;\n    rep(i, g.adj[u].size()){\n\tint v = g.adj[u][i];\n\tif ( visited[v] == -1 ) dfs(v);\n    }\n    finish[u] = t++;\n}\n\nvoid dfsT(int &u){\n    com.push_back(u);\n    visited[u] = 1;\n    rep(i, g.adj[u].size()){\n\tint v = g.adj[u][i];\n\tif ( visited[v] == 0 ) dfsT(v);\n    }\n}\n\nvoid makeGraph(){\n    g = Graph(n);\n    rep(i, n) rep(j, n){\n\tif ( i != j && overlap(i, j) ) {\n\t    g.connect(i, j);\n\t}\n    }\n}\n\nint scc(){\n    int id[MAX];\n    bool indeg[MAX];\n\n    rep(i, n) visited[i] = finish[i] = -1;\n    t = 0;\n    rep(i, n) if ( visited[i] == -1 ) dfs(i);\n\n    g.transpose();\n    \n    vector<pair<int, int> > order;\n    rep(i, n) order.push_back(make_pair(finish[i], i));\n    sort(order.begin(), order.end());\n    \n    rep(i, n) visited[i] = 0;\n    \n    int ncom = 0;\n    \n    for ( int i = n-1; i >= 0; i-- ){\n\tint u = order[i].second;\n\tcom.clear();\n\tif ( visited[u] == 0 ) {\n\t    dfsT(u);\n\t    rep(c, com.size()) id[com[c]] = ncom;\n\t    ncom++;\n\t}\n    }\n    \n    int cnt = 0;\n    g.transpose();\n\n    rep(i, ncom) indeg[i] = false;\n    \n    rep(u, n) rep(i, g.adj[u].size()){\n\tint v = g.adj[u][i];\n\tif ( id[v] != id[u] ) indeg[id[v]] = true;\n    }\n    rep(i, ncom) if (!indeg[i]) cnt++;\n    \n    return cnt;\n}\n\nmain(){\n    while( cin >> n >> d && n ){\n\trep(i, n){\n\t    Triangle t;\n\t    rep(j, 3) cin >> t.P[j].x >> t.P[j].y;\n\t    t.normalize();\n\t    T[i] = t;\n\t}\n\tdouble a = T[0].getArea();\n\tfor ( int i = 0; i < n-1; i++ ){\n\t    for ( int j = i+1; j < n; j++ ){\n\n\t\tTriangle t1 = T[i];\n\t\tTriangle t2 = T[j];\n\t\tfor ( int a= 0; a < 3; a++ ){\n\t\t    for ( int b = 0; b < 3; b++ ){\n\t\t\tPoint p1 = t1.P[a];\n\t\t\tPoint p2 = t1.P[(a+1)%3];\n\t\t\tPoint p3 = t2.P[b];\n\t\t\tPoint p4 = t2.P[(b+1)%3];\n\t\t \n\t\t    }\n\n\t\t}\n\n\t    }\n\t}\n\n\tmakeGraph();\n\tcout << scc() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <cassert>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nconst double EPS = 0.01;\n\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\n \ndouble area(vector<P> p){\n\tdouble S = 0 ; \n\tp.push_back(p[0]);\n\t/*　多角形の面積公式 (反時計回りの場合) */\n\tfor(int i = 0 ; i < p.size()-1 ; i++){\n\t\tS += (p[i].real() - p[i+1].real()) * (p[i].imag()+p[i+1].imag());\n\t}\n\tS /= 2.0;\n\treturn S;\n}\nbool contains(vector<P> &a,P b){\n\t//b = (-10000,-10000);\n\tdouble ans = 0;\n\tfor(int i = 0 ; i < a.size() ; i++){\n\t\tvector<P> w;\n\t\tw.push_back(a[i]);\n\t\tw.push_back(a[(i+1)%a.size()]);\n\t\tw.push_back(b);\n\t\tans += abs(area(w));\n\t}\n\tans = abs(ans);\n\t//cout << a[0] << \" \" << a[1] << \" \" << a[2] << \" \" << a[3] << \" \" << b << \" \" << (fabs(abs(area(a)) - ans ) < EPS) << endl;\n\t//cout << ans << \" \" << abs(area(a)) << \" \" << a.size() << endl;\n\treturn fabs(abs(area(a)) - ans ) < EPS;\n}\n\n/*\n\t幾何: \n\t\t・凸多角形の点包含判定\n\t\t・凸多角形同士の線分交差判定\n\tグラフ:\n\t\t・強連結成分分解\n\t\t・入次数数える\n*/\n\nint n;\n\n\nbool eq(double a,double b){\n\treturn fabs(a-b) < EPS;\n}\n\nint wf[100][100]={};\n\nint main(){\n\tdouble d;\n\twhile(cin >> n >> d && n ){\n\t\tmemset(wf,0,sizeof(wf));\n\t\tfor(int i = 0 ; i < n ; i++) \n\t\t\twf[i][i] = 1;\n\t\tvector<G> g(n);\n\t\tvector<G> g2(n);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x1,x2,x3,y1,y2,y3;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\t\tg[i].push_back(P(x1,y1));\n\t\t\tg[i].push_back(P(x2,y2));\n\t\t\tg[i].push_back(P(x3,y3));\n\t\t\tdouble A = abs( P(x2,y2) - P(x1,y1) );\n\t\t\tdouble B = abs( P(x2,y2) - P(x3,y3) );\n\t\t\tdouble C = abs( P(x3,y3) - P(x1,y1) );\n\t\t\tL l(P(-1,-1),P(-1,-1));\n\t\t\tif( eq(A,B) ) l = L( P(x3,y3) , P(x1,y1) );\n\t\t\telse if( eq(A,C) ) l = L( P(x2,y2) , P(x3,y3) );\n\t\t\telse if( eq(B,C) ) l = L( P(x2,y2) , P(x1,y1) );\n\t\t\telse while(1){}\n\t\t\t\n\t\t\tassert( !( eq(A,B) && eq(B,C) ) );\n\t\t\tP r = l[1] - l[0];\n\t\t\tr = P(-r.imag(),r.real());\n\t\t\tr /= abs(r);\n\t\t\t\n\t\t\t//cout << A << \" \" << B << \" \" << C << \" \" << l[0] << \"-\" << l[1] << \" \" << r << endl;\n\t\t\tfor(int coef = -1 ; coef <= 1 ; coef += 2 ){\n\t\t\t\tvector<P> XX;\n\t\t\t\tXX.push_back(l[0]);\n\t\t\t\tXX.push_back(l[0] + coef * d * r );\n\t\t\t\tXX.push_back(l[1] + coef * d * r );\t\t\t\n\t\t\t\tXX.push_back(l[1]);\n\t\t\t\tint ok = 1;\n\t\t\t\t\n\t\t\t\tfor(int j = 0 ; j < 3 ; j++){\n\t\t\t\t\tif( !contains(XX,g[i][j]) ){\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( ok ) {\n\t\t\t\t\tif( g2[i].size() ) assert(0);\n\t\t\t\t\tg2[i] = XX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif( i != j ) {\n\t\t\t\t\tint ok = 0;\n\t\t\t\t\tfor(int l = 0 ; l < 3 ; l++){\n\t\t\t\t\t\tif( contains(g2[i],g[j][l]) ){\n\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0 ; k < 4 ; k++){\n\t\t\t\t\t\tfor(int l = k+1 ; l < 4 ; l++){\n\t\t\t\t\t\t\tfor(int m = 0 ; m < 3 ; m++){\n\t\t\t\t\t\t\t\tfor(int o = m+1 ; o < 3 ; o++){\n\t\t\t\t\t\t\t\t\tif( intersectSS(L(g2[i][k],g2[i][l]),L(g[j][m],g[j][o])) ){\n\t\t\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( ok ) {\n\t\t\t\t\t\twf[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\t\tfor(int k = 0 ; k < n ; k++)\n\t\t\t\t\twf[j][k] |= wf[j][i] & wf[i][k];\n\t\n\t\t\n\t\tint in[100] = {} , id[100] = {} , cur = 0;\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tid[i] = -1;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif( id[i] == -1 ){\n\t\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\t\tif( wf[i][j] & wf[j][i] ){\n\t\t\t\t\t\tid[j] = cur;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur++;\n\t\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif(wf[i][j] && id[i] != id[j]) in[j]++;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif( !in[i] ){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-2\n ;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-8, AD = 1e-2;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  if(seg_p_dis(L(a,b),c)<AD+EPS)return 0;\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0)\n\t    swap(rect[i][0],rect[i][1]);\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k])){\n\t    f = true; break;\n\t  }\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int edges[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])edges[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!edges[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-8, AD = 1e-2;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(abs(cross(a.sc-a.fs,b.sc-b.fs))<EPS)\n    return (min(min(seg_p_dis(a,b.fs),seg_p_dis(a,b.sc)),\n\t\tmin(seg_p_dis(b,a.fs),seg_p_dis(b,a.sc)))<EPS);\n  if(cross(a.sc-a.fs,b.fs-a.fs)*cross(a.sc-a.fs,b.sc-a.fs)>0)return false;\n  if(cross(a.fs-a.sc,b.fs-a.sc)*cross(a.fs-a.sc,b.sc-a.sc)>0)return false;\n  if(cross(b.sc-b.fs,a.fs-b.fs)*cross(b.sc-b.fs,a.sc-b.fs)>0)return false;\n  return (cross(b.fs-b.sc,a.fs-b.sc)*cross(b.fs-b.sc,a.sc-b.sc)>0);\n}\n\n/*\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n*/\n\nD area(P a,P b,P c){\n  return abs(cross(a,b)+cross(b,c)+cross(c,a));\n}\n\nbool inter_pos(Poly p,P x,D A){\n  D a = 0; int s = p.size();\n  rep(i,n)a += area(p[i],p[(i+1)%s],x);\n  return (abs(a-A)<EPS);\n}\n\n/*\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n*/\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0){\n\t    swap(rect[i][0],rect[i][1]); break;\n\t  }\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k],abs(rect[i][0]-rect[i][1])*d)){\n\t    f = true; break;\n\t  }\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3)if(seg_p_dis(rseg,tri[j][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,3){\n\t    L tseg = L(tri[j][k],rect[j][(k+1)%3]);\n\t    rep(l,4)if(seg_p_dis(tseg,rect[i][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-8, AD = 1e-2;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0){\n\t    swap(rect[i][0],rect[i][1]); break;\n\t  }\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k])){\n\t    f = true; break;\n\t  }\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3)if(seg_p_dis(rseg,tri[j][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,3){\n\t    L tseg = L(tri[j][k],rect[j][(k+1)%3]);\n\t    rep(l,4)if(seg_p_dis(tseg,rect[i][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-6;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tSegment s(curr(g, i), next(g, i));\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(s, h[j]) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tSegment s(curr(h, i), next(h, i));\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(s, g[j]) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(norm(b - a), norm(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = (a * v * d) / abs(a);\n\t\t\t\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\tassert(res);\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tsqr[i].resize(4);\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct coor {\n\tdouble x, y;\n};\nstruct tri {\n\tcoor p[3];\n\tcoor rec[4];\n};\n\nint n, d;\nvector<tri> v;\nvector<vector<int> > edge;\n\nconst double EPS = 1e-9;\nconst double ERR = 1e-2;\n\ntemplate<class T>\nT sqr(T x) {\n\treturn x * x;\n}\n\ndouble dist(coor a, coor b) {\n\treturn sqrt(sqr(a.x-b.x) + sqr(a.y-b.y));\n}\n\ndouble dist_lp(coor c, coor a, coor b) {\n\tcoor v0, v1;\n\tv0.x = b.x - a.x; v0.y = b.y - a.y;\n\tv1.x = c.x - a.x; v1.y = c.y - a.y;\n\n\tif(sqr(dist(a,b)) + sqr(dist(a,c)) - sqr(dist(c,b)) > 0\n\t\t\t&& sqr(dist(a,b)) + sqr(dist(b,c)) - sqr(dist(c,a)) > 0) {\n\t\tdouble cross;\n\t\tcross = fabs(v0.x * v1.y - v0.y * v1.x);\n\t\treturn cross / dist(a,b);\n\t}\n\n\treturn min(dist(a,c), dist(b,c));\n}\n\nbool in_poly(coor p, coor poly[], int sz) {\n\tdouble sign = +0.0;\n\tfor(int i = 0; i < sz; i++) {\n\t\tcoor v0, v1;\n\t\tv0.x = poly[i].x - p.x; v0.y = poly[i].y - p.y;\n\t\tv1.x = poly[(i+1)%sz].x - p.x; v1.y = poly[(i+1)%sz].y - p.y;;\n\n\t\tif(i != 0 && sign * (v0.x * v1.y - v0.y * v1.x) < EPS) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tsign = (v0.x * v1.y - v0.y * v1.x);\n\n\t\tif(i == sz-1) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < sz; i++) {\n\t\tif(dist_lp(p,poly[i], poly[(i+1)%sz]) <= ERR + EPS) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool exist_edge(tri from, tri to) {\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(in_poly(to.p[i], from.rec, 4))\n\t\t\treturn true;\n\t}\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(in_poly(from.rec[i], to.p, 3))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool visited[128];\nbool touch[128];\n\nvoid check(int i, int s) {\n\tif(i != s && touch[i])\n\t\ttouch[i] = false;\n\tif(visited[i])\n\t\treturn;\n\tvisited[i] = true;\n\tfor(int j = 0; j < edge[i].size(); j++) {\n\t\tcheck(edge[i][j], s);\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> d, n || d) {\n\t\tv.clear();\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tvisited[i] = touch[i] = false;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttri in;\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tcoor c;\n\t\t\t\tcin >> c.x >> c.y;\n\t\t\t\tin.p[j] = c;\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tif(fabs(dist(in.p[(0+j)%3],in.p[(1+j)%3]) - dist(in.p[(1+j)%3], in.p[(2+j)%3])) < ERR) {\n\t\t\t\t\tswap(in.p[(1+j)%3], in.p[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcoor add;\n\t\t\tadd.x =\t(in.p[1].x - in.p[0].x) + (in.p[1].x - in.p[2].x);\n\t\t\tadd.y = (in.p[1].y - in.p[0].y) + (in.p[1].y - in.p[2].y);\n\n\t\t\tdouble addlen;\n\t\t\taddlen = sqrt(sqr(add.x) + sqr(add.y));\n\t\t\tadd.x = add.x * d / addlen;\n\t\t\tadd.y = add.y * d / addlen;\n\n\t\t\tin.rec[0].x = in.p[0].x; in.rec[0].y = in.p[0].y;\n\t\t\tin.rec[1].x = in.p[2].x; in.rec[1].y = in.p[2].y;\n\t\t\tin.rec[2].x = in.p[2].x + add.x; in.rec[2].y = in.p[2].y + add.y;\n\t\t\tin.rec[3].x = in.p[0].x + add.x; in.rec[3].y = in.p[0].y + add.y;\n\n\t\t\tv.push_back(in);\n\t\t}\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\t\tif(i != j) {\n\t\t\t\t\tif(exist_edge(v[i], v[j])) {\n\t\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint i_ = (i+5)%n;\n\t\t\tif(!visited[i_]) {\n\t\t\t\ttouch[i_] = true;\n\t\t\t\tcheck(i_, i_);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(touch[i])\n\t\t\t\tres++;\n\t\t}\n\t\tcout <<  res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst double EPS = 0.01;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n\n//????????´???????£???????????????????(??????????????£???????????????)\nenum{NO_HIT=0, HIT, A_IN_B, B_IN_A};\nint HitPol_Pol(const polygon& a, const polygon& b){\n\tbool f = true, hit = false;\n\trep(i, a.size()){\n\t\tif(!contains(b, a[i])) f = false;\n\t\telse hit = true;\n\t}\n\tif(f) return A_IN_B;\n\tf = true;\n\trep(i, b.size()){\n\t\tif(!contains(a, b[i])) f = false;\n\t\telse hit = true;\n\t}\n\tif(f) return B_IN_A;\n\tif(hit) return HIT;\n\trep(i, a.size()) rep(j, b.size()){\n\t\tL la(curr(a, i), next(a, i)), lb(curr(b, j), next(b, j));\n\t\tif(intersectSS(la, lb)) return HIT;\n\t}\n\treturn NO_HIT;\n}\n//point???theta???????????¢\npoint spinP(const point& p, double theta){\n\treturn p*complex<double>(cos(theta),sin(theta));\n}\npoint spinPExtend(const point& p, double theta, double rate){\n\treturn p*complex<double>(rate*cos(theta),rate*sin(theta));\n}\n\nstruct SCC{//O(V+E)\n    static const int MAX_V = 1010;\n    int V;\n    vector<int> G[MAX_V], rG[MAX_V];\n    vector<int> vs;\n    bool used[MAX_V];\n    int cmp[MAX_V];\n    vector<vector<int> > res;\n \n \n    SCC(int v) : V(v){};\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n \n    void dfs(int v){\n        used[v] = true;\n        for(int i = 0; i < G[v].size(); i++){\n            if(!used[G[v][i]]) dfs(G[v][i]);\n        }\n        vs.push_back(v);\n    }\n    void rdfs(int v, int k){\n        used[v] = true;\n        cmp[v] = k;\n        for(int i = 0; i < rG[v].size(); i++){\n            if(!used[rG[v][i]]) rdfs(rG[v][i], k);\n        }\n    }\n \n    int scc(){\n        memset(used, 0, sizeof(used));\n        vs.clear();\n        for(int v = 0; v < V; v++){\n            if(!used[v]) dfs(v);\n        }\n        memset(used, 0, sizeof(used));\n        int k = 0;\n        for(int i = vs.size() - 1; i >= 0; i--){\n            if(!used[vs[i]]) rdfs(vs[i], k++);\n        }\n \n        res.clear();\n        res.resize(k);\n        for(int i = 0; i < V; i++){\n            res[cmp[i]].push_back(i);\n        }\n        return k;\n    }\n};\n\nint main(){\n\tint n, d;\n\twhile(cin >> n >> d && (n+d)){\n\t\tvector<polygon> tri(n);\n\t\trep(i, n){\n\t\t\tdouble x, y;\n\t\t\trep(j, 3){\n\t\t\t\tcin >> x >> y;\n\t\t\t\ttri[i].pb({x, y});\n\t\t\t}\n\t\t}\n\t\tvector<polygon> pol(n);\n\t\trep(i, n){\n\t\t\tdouble dist[3];\n\t\t\trep(j, 3){\n\t\t\t\tdist[j] = abs(curr(tri[i], j)-next(tri[i], j));\n\t\t\t}\n\t\t\trep(j, 3) {\n\t\t\t\tif(abs(dist[j] - dist[(j+1)%3])<1e-8){\n\t\t\t\t\tpol[i].pb(tri[i][j]);\n\t\t\t\t\tpol[i].pb(tri[i][(j+2)%3]);\n\t\t\t\t\tpol[i].pb(spinPExtend(pol[i][0]-pol[i][1], (ccw(pol[i][1], pol[i][0], tri[i][(j+1)%3])> 0)?PI/2:PI/2*3, d/abs(pol[i][1]-pol[i][0]))+pol[i][1]);\n\t\t\t\t\tpol[i].pb(pol[i][2]+pol[i][0]-pol[i][1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSCC scc(n);\n\t\trep(i, n) rep(j, i){\n\t\t\tif(HitPol_Pol(pol[i], tri[j]) > 0 && HitPol_Pol(tri[i], pol[j])>0) scc.add_edge(i, j), scc.add_edge(j, i);\n\t\t\telse if(HitPol_Pol(pol[i], tri[j])>0) scc.add_edge(i, j);\n\t\t\telse if(HitPol_Pol(tri[i], pol[j])>0) scc.add_edge(j, i);\n\t\t}\n\t\tscc.scc();\n\t\tvector<int> f(scc.res.size(), 1);\n\t\trep(i, n) rep(j, i){\n\t\t\tif(scc.cmp[i] == scc.cmp[j]) continue;\n\t\t\tif(HitPol_Pol(pol[i], tri[j])>0) f[scc.cmp[j]] = 0;\n\t\t\telse if(HitPol_Pol(tri[i], pol[j])>0) f[scc.cmp[i]] = 0;\n\t\t}\n\t\tcout<<accumulate(all(f), 0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nint g[110][110];\nPt p[110][3];\nint UF[110];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[i][i]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble ax,bx,cx,ay,by,cy;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n\t\t\tdouble A=(bx-cx)*(bx-cx)+(by-cy)*(by-cy);\n\t\t\tdouble B=(ax-cx)*(ax-cx)+(ay-cy)*(ay-cy);\n\t\t\tdouble C=(ax-bx)*(ax-bx)+(ay-by)*(ay-by);\n\t\t\tif(ABS(A-B)<EPS){\n\t\t\t\tp[i][0]=Pt(ax,ay);p[i][1]=Pt(bx,by);p[i][2]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(B-C)<EPS){\n\t\t\t\tp[i][2]=Pt(ax,ay);p[i][0]=Pt(bx,by);p[i][1]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(C-A)<EPS){\n\t\t\t\tp[i][1]=Pt(ax,ay);p[i][2]=Pt(bx,by);p[i][0]=Pt(cx,cy);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)if(iSP(p[i][0],p[i][2],p[i][1])==-1)swap(p[i][0],p[i][1]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tif(i==j)continue;\n\t\t\tPt t[4];\n\t\t\tt[0]=p[i][0];\n\t\t\tt[1]=p[i][1];\n\t\t\tt[3]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[3]=t[0]+t[3]/t[3].ABS()*(double)b;\n\t\t\tt[2]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[2]=t[1]+t[2]/t[2].ABS()*(double)b;\n\t\t\tbool ok=false;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tbool L=false;\n\t\t\t\tbool R=false;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][k]+(p[j][(k+1)%3]-p[j][k])*1000000.0))L=true;\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][(k+1)%3],p[j][(k+1)%3]+(p[j][k]-p[j][(k+1)%3])*1000000.0))R=true;\n\t\t\t\t}\n\t\t\t\tif(L&&R)ok=true;\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tg[i][j]=1;\n\t\t//\t\tprintf(\"%d %d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]|=g[i][k]&g[k][j];\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)if(g[i][j]&&g[j][i])UNION(i,j);\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(FIND(i)!=FIND(j)&&g[j][i])ok=false;\n\t\t\t}\n\t\t\tif(ok)ret++;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-2;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nint g[110][110];\nPt p[110][3];\nint UF[110];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[i][i]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble ax,bx,cx,ay,by,cy;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n\t\t\tdouble A=(bx-cx)*(bx-cx)+(by-cy)*(by-cy);\n\t\t\tdouble B=(ax-cx)*(ax-cx)+(ay-cy)*(ay-cy);\n\t\t\tdouble C=(ax-bx)*(ax-bx)+(ay-by)*(ay-by);\n\t\t\tif(ABS(A-B)<EPS){\n\t\t\t\tp[i][0]=Pt(ax,ay);p[i][1]=Pt(bx,by);p[i][2]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(B-C)<EPS){\n\t\t\t\tp[i][2]=Pt(ax,ay);p[i][0]=Pt(bx,by);p[i][1]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(C-A)<EPS){\n\t\t\t\tp[i][1]=Pt(ax,ay);p[i][2]=Pt(bx,by);p[i][0]=Pt(cx,cy);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)if(iSP(p[i][0],p[i][2],p[i][1])==-1)swap(p[i][0],p[i][1]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tif(i==j)continue;\n\t\t\tPt t[4];\n\t\t\tt[0]=p[i][0];\n\t\t\tt[1]=p[i][1];\n\t\t\tt[3]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[3]=t[0]+t[3]/t[3].ABS()*(double)b;\n\t\t\tt[2]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[2]=t[1]+t[2]/t[2].ABS()*(double)b;\n\t\t\n\t\t\tbool ok=false;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tbool L=false;\n\t\t\t\tbool R=false;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][k]+(p[j][(k+1)%3]-p[j][k])*1000000.0))L=true;\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][(k+1)%3],p[j][(k+1)%3]+(p[j][k]-p[j][(k+1)%3])*1000000.0))R=true;\n\t\t\t\t}\n\t\t\t\tif(L&&R)ok=true;\n\t\t\t}\n\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\tbool L=false;\n\t\t\t\tbool R=false;\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tif(iSS(t[l],t[l]+(t[(l+1)%4]-t[l])*1000000.0,p[j][k],p[j][(k+1)%3]))L=true;\n\t\t\t\t\tif(iSS(t[(l+1)%4],t[(l+1)%4]+(t[l]-t[(l+1)%4])*1000000.0,p[j][k],p[j][(k+1)%3]))R=true;\n\t\t\t\t}\n\t\t\t\tif(L&&R)ok=true;\n\t\t\t}\n\t\t\t\n\t\t\tif(ok){\n\t\t\t\tg[i][j]=1;\n\t\t//\t\tprintf(\"%d %d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]|=g[i][k]&g[k][j];\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)if(g[i][j]&&g[j][i])UNION(i,j);\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(FIND(i)!=FIND(j)&&g[j][i])ok=false;\n\t\t\t}\n\t\t\tif(ok)ret++;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-2)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) * SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\tif (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\tassert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nbool mergeIfAble(S &s1, S s2){\n\tif (!parallel(s1, s2)) return false;\n\tif (abs(ccw(s1.p1, s2.p1, s1.p2)) == 1) return false;\n\tif (ccw(s1.p1, s1.p2, s2.p1) == ONLINE_FRONT ||\n\t\tccw(s2.p1, s2.p2, s1.p1) == ONLINE_FRONT){\n\t\treturn false;\n\t}\n\ts1 = S(min(s1.p1, s2.p1), max(s1.p2, s2.p2));\n\treturn true;\n}\nvoid merge(vector<S> &ss){\n\tfor (int i = 0; i < ss.size(); i++){\n\t\tif (ss[i].p2 < ss[i].p1){\n\t\t\tswap(ss[i].p1, ss[i].p2);\n\t\t}\n\t}\n\tfor (int i = 0; i < ss.size(); i++){\n\t\tfor (int j = i + 1; j < ss.size(); j++){\n\t\t\tif (mergeIfAble(ss[i], ss[j])){\n\t\t\t\tss[j--] = ss.back();\n\t\t\t\tss.pop_back();\n\t\t\t}\n\t\t}\n\t}\n}\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\nG convexHull(vector<P> s){\n\tif (s.size() < 3) return s;\n\tG u, l;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tfor (int i = 2; i < s.size(); i++){\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\tl.push_back(u[i]);\n\t}\n\treturn l;\n}\n\nGraph SArrangement(const vector<S> &ss, vector<P> &ps){\n\tfor (int i = 0; i < ss.size(); i++){\n\t\tps.push_back(ss[i].p1);\n\t\tps.push_back(ss[i].p2);\n\t\tfor (int j = i + 1; j < ss.size(); j++){\n\t\t\tif (intersectSS(ss[i], ss[j])){\n\t\t\t\tps.push_back(crossP(ss[i], ss[j]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(ps.begin(), ps.end());\n\tps.erase(unique(ps.begin(), ps.end()), ps.end());\n\tGraph g(ps.size());\n\tfor (int i = 0; i < ss.size(); i++){\n\t\tvector<pair<D, int> > v;\n\t\tfor (int j = 0; j < ps.size(); j++){\n\t\t\tif (PonS(ss[i], ps[j])){\n\t\t\t\tv.push_back(make_pair(norm(ss[i].p1 - ps[i]), j));\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tfor (int j = 0; j < (int)v.size() - 1; j++){\n\t\t\tint a = v[j].second, b = v[j + 1].second;\n\t\t\tD c = abs(ps[a] - ps[b]);\n\t\t\tg[a].push_back(Edge(b, c));\n\t\t\tg[b].push_back(Edge(a, c));\n\t\t}\n\t}\n\treturn g;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G a, G b)\n{\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)) return true;\n\t\t}\n\t\tif (contains(b, a[i])) return true;\n\t}\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) res++;\n\t\tfor (int to : sccgraph[i]){\n\t\t\tused[to] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev から cur へ行って next へ行く際の角度を求める\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //同じセグメントかもよ\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \nbool isConvex(vector<Point> p) {\n  int sz = (int)p.size();\n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft) return false;\n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c) {\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p){\n  if((int)poly.size() == 0)return false;\n  rep(i,poly.size()) if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++) {\n    if( equals(cross(poly[i]-p,poly[(i+1)%poly.size()]-p),0.0) ) continue; // ３点が平行だとangleがnanを返しsumがnanになり死ぬ\n    if( cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0 ) sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n    else                                                 sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n  }\n  // あまり誤差を厳しくしすぎると良くないので以下のほうが良い \n  const double eps = 1e-5;\n  return (fabs(sum - 2*M_PI) < eps || fabs(sum + 2*M_PI) < eps);\n}  \n\n\nconst int MAX_V = 200;\nint V,cmp[MAX_V];\ndouble d;\nPoint ps[MAX_V][3];\nvector<Polygon> poly;\nvector<int> G[MAX_V],rG[MAX_V],vs;\nbool used[MAX_V];\n\nvoid add_edge(int s,int t){\n  G[s].push_back(t);\n  rG[t].push_back(s);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++) if( !used[G[v][i]] ) dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  for(int i=0;i<rG[v].size();i++) if( !used[rG[v][i]] ) rdfs(rG[v][i],k);\n}\n\nint scc(){\n  rep(i,V) used[i] = false;\n  vs.clear();\n  rep(v,V) if( !used[v] ) dfs(v);\n  rep(i,V) used[i] = false;\n  int k = 0;\n  for(int i=(int)vs.size()-1;i>=0;i--) if( !used[vs[i]] ) rdfs(vs[i],k++);\n  return k;\n}\n\n\nbool check(int a,int b) {\n  rep(i,(int)poly[a].size()) {\n    Segment seg1 = Segment(poly[a][i],poly[a][(i+1)%poly[a].size()]);\n    rep(j,3){\n      Segment seg2 = Segment(ps[b][j],ps[b][(j+1)%3]);\n      if( equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) ) {\n        if( onSegment(seg1.p1,seg1.p2,seg2.p1) || onSegment(seg1.p1,seg1.p2,seg2.p2) ||\n            onSegment(seg2.p1,seg2.p2,seg1.p1) || onSegment(seg2.p1,seg2.p2,seg1.p2) ) return true;\n      } else if( intersectSS(seg1,seg2) ) return true;\n    }\n  }\n  rep(i,3) if( inPolygon(poly[a],ps[b][i]) ) return true;\n  return false;\n}\n\nvoid converter(int index){\n  Polygon temp;\n  rep(i,3) {\n    double dist[2] = {abs(ps[index][(i+1)%3]-ps[index][(i+2)%3]),\n                      abs(ps[index][(i+2)%3]-ps[index][i])};\n    if( equals(dist[0],dist[1]) ) {\n      Point p = projection(Line(ps[index][i],ps[index][(i+1)%3]),ps[index][(i+2)%3]);\n      Point e = ( ps[index][(i+2)%3] - p ) / abs( ps[index][(i+2)%3] - p );\n      temp.push_back(ps[index][i]);\n      temp.push_back(ps[index][(i+1)%3]);\n      temp.push_back(ps[index][(i+1)%3] + e * d);\n      temp.push_back(ps[index][i] + e * d);\n      break;\n    }\n  }\n  assert( !temp.empty() );\n  poly.push_back(temp);\n}\n\nint nV;\nstruct Edge { int to; };\n\nvoid draw(vector<vector<Edge> > &nG,int cur){ \n  rep(i,(int)nG[cur].size()){\n    if( !used[nG[cur][i].to] ) {\n      used[nG[cur][i].to] = true;\n      draw(nG,nG[cur][i].to);\n    }\n  }\n}\n\ntemplate<typename T>\nbool visit(const T& G,int v,vector<int>& order,vector<int>& color){\n  color[v] = 1;\n  for(__typeof((G[v]).begin()) e = G[v].begin();e != G[v].end();e++){\n      if(color[e->to] == 2)continue;//このvisit以外のvisitで訪れた\n      if(color[e->to] == 1)return false;//このvisitで訪れた\n      if(!visit(G,e->to,order,color))return false;\n    }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\ntemplate<typename T>\nbool topologicalSort(const T& G,vector<int>& order){\n  int SizeG = G.size();\n  vector<int> color(SizeG); \n  for(int u=0;u<SizeG;u++) if(!color[u] && !visit(G,u,order,color)) return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\n\nvoid compute(){\n  poly.clear(), vs.clear();\n  rep(i,V) G[i].clear(), rG[i].clear(), used[i] = false;\n  \n  rep(i,V) converter(i);\n\n  rep(i,V) rep(j,V) if( i != j && check(i,j) ) add_edge(i,j);\n\n  nV = scc();\n\n  vector<vector<Edge> > nG(nV,vector<Edge>());\n  rep(i,V) rep(j,(int)G[i].size()) {\n    if( cmp[i] == cmp[G[i][j]] ) continue;\n    nG[cmp[i]].push_back((Edge){cmp[G[i][j]]});\n  }\n\n  vector<int> order;\n  assert( topologicalSort(nG,order) );\n  memset(used,false,sizeof(used));\n  int answer = 0;\n  \n  rep(i,nV) if( !used[order[i]] ){\n    used[order[i]] = true;\n    ++answer;\n    draw(nG,order[i]);\n  }\n  cout << answer << endl;\n}\n\nint main(){\n  while( cin >> V >> d, (V|(int)d) ){\n    rep(i,V) rep(j,3) cin >> ps[i][j].x >> ps[i][j].y;\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e+1;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nint V;\nvector<vector<int> > G,rG;\nvector<int> vs;\nbool used[100];\nint cmp[100];\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]){\n      dfs(G[v][i]);\n    }\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]){\n      rdfs(rG[v][i],k);\n    }\n  }\n}\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[2])>eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    G=rG=vector<vector<int> >(n);\n    vs.clear();\n    bool e[100][100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<eps;\n\t      e[i][j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    e[i][j]|=!f;\n\t    if(e[i][j]){\n\t      G[i].push_back(j);\n\t      rG[j].push_back(i);\n\t    }\n\t  }\n\t}\n      }\n    }\n    V=n;\n    fill(begin(used),end(used),false);\n    for(int v=0;v<V;v++){\n      if(!used[v]){\n\tdfs(v);\n      }\n    }\n    fill(begin(used),end(used),false);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]]){\n\trdfs(vs[i],k++);\n      }\n    }\n    bool in[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(e[i][j]&&cmp[i]!=cmp[j]){\n\t  in[cmp[j]]=true;\n\t}\n      }\n    }\n    cout<<count(in,in+k,false)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-4\n\n\n ;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <cassert>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nconst double EPS = 0.001;\n\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\n \ndouble area(vector<P> p){\n\tdouble S = 0 ; \n\tp.push_back(p[0]);\n\t/*　多角形の面積公式 (反時計回りの場合) */\n\tfor(int i = 0 ; i < p.size()-1 ; i++){\n\t\tS += (p[i].real() - p[i+1].real()) * (p[i].imag()+p[i+1].imag());\n\t}\n\tS /= 2.0;\n\treturn S;\n}\nbool contains(vector<P> &a,P b){\n\t//b = (-10000,-10000);\n\tdouble ans = 0;\n\tfor(int i = 0 ; i < a.size() ; i++){\n\t\tvector<P> w;\n\t\tw.push_back(a[i]);\n\t\tw.push_back(a[(i+1)%a.size()]);\n\t\tw.push_back(b);\n\t\tans += abs(area(w));\n\t}\n\tans = abs(ans);\n\t//cout << a[0] << \" \" << a[1] << \" \" << a[2] << \" \" << a[3] << \" \" << b << \" \" << (fabs(abs(area(a)) - ans ) < EPS) << endl;\n\t//cout << ans << \" \" << abs(area(a)) << \" \" << a.size() << endl;\n\treturn fabs(abs(area(a)) - ans ) < EPS;\n}\n\n/*\n\t幾何: \n\t\t・凸多角形の点包含判定\n\t\t・凸多角形同士の線分交差判定\n\tグラフ:\n\t\t・強連結成分分解\n\t\t・入次数数える\n*/\n\nint N;\n\n\nbool eq(double a,double b){\n\treturn fabs(a-b) < 1e-9;\n}\n\nint done[100] ={};\nint wf[100][100]={};\n\nint dfs(int pos){\n\tif( done[pos] ) return 0;\n\telse done[pos] = 1;\n\tfor(int i = 0 ; i < 100 ; i++){\n\t\tif(wf[pos][i])dfs(i);\n\t}\n}\nint main(){\n\tint n;\n\tdouble d;\n\twhile(cin >> n >> d && n ){\n\t\tmemset(done,0,sizeof(done));\n\t\tmemset(wf,0,sizeof(wf));\n\t\t\n\t\tvector<G> g(n);\n\t\tvector<G> g2(n);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x1,x2,x3,y1,y2,y3;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\t\tg[i].push_back(P(x1,y1));\n\t\t\tg[i].push_back(P(x2,y2));\n\t\t\tg[i].push_back(P(x3,y3));\n\t\t\tdouble A = abs( P(x2,y2) - P(x1,y1) );\n\t\t\tdouble B = abs( P(x2,y2) - P(x3,y3) );\n\t\t\tdouble C = abs( P(x3,y3) - P(x1,y1) );\n\t\t\tL l(P(-1,-1),P(-1,-1));\n\t\t\tif( eq(A,B) ) l = L( P(x3,y3) , P(x1,y1) );\n\t\t\telse if( eq(A,C) ) l = L( P(x2,y2) , P(x3,y3) );\n\t\t\telse if( eq(B,C) ) l = L( P(x2,y2) , P(x1,y1) );\n\t\t\telse while(1){}\n\t\t\t\n\t\t\tP r = l[1] - l[0];\n\t\t\tr = P(-r.imag(),r.real());\n\t\t\tr /= abs(r);\n\t\t\t\n\t\t\t//cout << A << \" \" << B << \" \" << C << \" \" << l[0] << \"-\" << l[1] << \" \" << r << endl;\n\t\t\tfor(int coef = -1 ; coef <= 1 ; coef += 2 ){\n\t\t\t\tvector<P> XX;\n\t\t\t\tXX.push_back(l[0]);\n\t\t\t\tXX.push_back(l[0] + coef * d * r );\n\t\t\t\tXX.push_back(l[1] + coef * d * r );\t\t\t\n\t\t\t\tXX.push_back(l[1]);\n\t\t\t\tint ok = 1;\n\t\t\t\t\n\t\t\t\tfor(int j = 0 ; j < 3 ; j++){\n\t\t\t\t\tif( !contains(XX,g[i][j]) ){\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( ok ) {\n\t\t\t\t\tif( g2[i].size() ) assert(0);\n\t\t\t\t\tg2[i] = XX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif( i != j ) {\n\t\t\t\t\tint ok = 0;\n\t\t\t\t\tfor(int l = 0 ; l < 3 ; l++){\n\t\t\t\t\t\tif( contains(g2[i],g[j][l]) ){\n\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0 ; k < 4 ; k++){\n\t\t\t\t\t\tfor(int l = k+1 ; l < 4 ; l++){\n\t\t\t\t\t\t\tfor(int m = 0 ; m < 3 ; m++){\n\t\t\t\t\t\t\t\tfor(int o = m+1 ; o < 3 ; o++){\n\t\t\t\t\t\t\t\t\tif( intersectSS(L(g2[i][k],g2[i][l]),L(g[j][m],g[j][o])) ){\n\t\t\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( ok ) {\n\t\t\t\t\t\twf[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\t\tfor(int k = 0 ; k < n ; k++)\n\t\t\t\t\twf[j][k] |= wf[j][i] & wf[i][k];\n\t\tint in[100] = {};\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif(wf[i][j]) in[j]++;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif( !done[i] && !in[i] ){\n\t\t\t\tdfs(i);\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif( !done[i] ){\n\t\t\t\tdfs(i);\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <cassert>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nconst double EPS = 0.01;\n\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\n \ndouble area(vector<P> p){\n\tdouble S = 0 ; \n\tp.push_back(p[0]);\n\t/*　多角形の面積公式 (反時計回りの場合) */\n\tfor(int i = 0 ; i < p.size()-1 ; i++){\n\t\tS += (p[i].real() - p[i+1].real()) * (p[i].imag()+p[i+1].imag());\n\t}\n\tS /= 2.0;\n\treturn S;\n}\nbool contains(vector<P> &a,P b){\n\t//b = (-10000,-10000);\n\tdouble ans = 0;\n\tfor(int i = 0 ; i < a.size() ; i++){\n\t\tvector<P> w;\n\t\tw.push_back(a[i]);\n\t\tw.push_back(a[(i+1)%a.size()]);\n\t\tw.push_back(b);\n\t\tans += abs(area(w));\n\t}\n\tans = abs(ans);\n\t//cout << a[0] << \" \" << a[1] << \" \" << a[2] << \" \" << a[3] << \" \" << b << \" \" << (fabs(abs(area(a)) - ans ) < EPS) << endl;\n\t//cout << ans << \" \" << abs(area(a)) << \" \" << a.size() << endl;\n\treturn fabs(abs(area(a)) - ans ) < EPS;\n}\n\n/*\n\t幾何: \n\t\t・凸多角形の点包含判定\n\t\t・凸多角形同士の線分交差判定\n\tグラフ:\n\t\t・強連結成分分解\n\t\t・入次数数える\n*/\n\nint n;\n\n\nbool eq(double a,double b){\n\treturn fabs(a-b) < EPS;\n}\n\nint wf[100][100]={};\n\nint main(){\n\tdouble d;\n\twhile(cin >> n >> d && n ){\n\t\tmemset(wf,0,sizeof(wf));\n\t\tfor(int i = 0 ; i < n ; i++) \n\t\t\twf[i][i] = 1;\n\t\tvector<G> g(n);\n\t\tvector<G> g2(n);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x1,x2,x3,y1,y2,y3;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\t\t\tg[i].push_back(P(x1,y1));\n\t\t\tg[i].push_back(P(x2,y2));\n\t\t\tg[i].push_back(P(x3,y3));\n\t\t\tdouble A = abs( P(x2,y2) - P(x1,y1) );\n\t\t\tdouble B = abs( P(x2,y2) - P(x3,y3) );\n\t\t\tdouble C = abs( P(x3,y3) - P(x1,y1) );\n\t\t\tL l(P(-1,-1),P(-1,-1));\n\t\t\tif( eq(A,B) ) l = L( P(x3,y3) , P(x1,y1) );\n\t\t\telse if( eq(A,C) ) l = L( P(x2,y2) , P(x3,y3) );\n\t\t\telse if( eq(B,C) ) l = L( P(x2,y2) , P(x1,y1) );\n\t\t\telse while(1){}\n\t\t\t\n\t\t\tassert( !( eq(A,B) && eq(B,C) ) );\n\t\t\tP r = l[1] - l[0];\n\t\t\tr = P(-r.imag(),r.real());\n\t\t\tr /= abs(r);\n\t\t\t\n\t\t\t//cout << A << \" \" << B << \" \" << C << \" \" << l[0] << \"-\" << l[1] << \" \" << r << endl;\n\t\t\tfor(int coef = -1 ; coef <= 1 ; coef += 2 ){\n\t\t\t\tvector<P> XX;\n\t\t\t\tXX.push_back(l[0]);\n\t\t\t\tXX.push_back(l[0] + coef * d * r );\n\t\t\t\tXX.push_back(l[1] + coef * d * r );\t\t\t\n\t\t\t\tXX.push_back(l[1]);\n\t\t\t\tint ok = 1;\n\t\t\t\t\n\t\t\t\tfor(int j = 0 ; j < 3 ; j++){\n\t\t\t\t\tif( !contains(XX,g[i][j]) ){\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( ok ) {\n\t\t\t\t\tif( g2[i].size() ) assert(0);\n\t\t\t\t\tg2[i] = XX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif( i != j ) {\n\t\t\t\t\tint ok = 0;\n\t\t\t\t\tfor(int l = 0 ; l < 3 ; l++){\n\t\t\t\t\t\tif( contains(g2[i],g[j][l]) ){\n\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0 ; k < 4 ; k++){\n\t\t\t\t\t\tfor(int l = k+1 ; l < 4 ; l++){\n\t\t\t\t\t\t\tfor(int m = 0 ; m < 3 ; m++){\n\t\t\t\t\t\t\t\tfor(int o = m+1 ; o < 3 ; o++){\n\t\t\t\t\t\t\t\t\tif( intersectSS(L(g2[i][k],g2[i][l]),L(g[j][m],g[j][o])) ){\n\t\t\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( ok ) {\n\t\t\t\t\t\twf[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\t\tfor(int k = 0 ; k < n ; k++)\n\t\t\t\t\twf[j][k] |= wf[j][i] & wf[i][k];\n\t\n\t\t\n\t\tint in[100] = {} , id[100] = {} , cur = 0;\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tid[i] = -1;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif( id[i] == -1 ){\n\t\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\t\tif( wf[i][j] & wf[j][i] ){\n\t\t\t\t\t\tid[j] = cur;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tif(wf[i][j] && id[i] != id[j]) in[id[j]]++;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < cur ; i++){\n\t\t\tif( !in[i] ){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-0;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nint V;\nvector<vector<int> > G,rG;\nvector<int> vs;\nbool used[100];\nint cmp[100];\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]){\n      dfs(G[v][i]);\n    }\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]){\n      rdfs(rG[v][i],k);\n    }\n  }\n}\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[2])>eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    G=rG=vector<vector<int> >(n);\n    vs.clear();\n    bool e[100][100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<eps;\n\t      e[i][j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    e[i][j]|=!f;\n\t    if(e[i][j]){\n\t      G[i].push_back(j);\n\t      rG[j].push_back(i);\n\t    }\n\t  }\n\t}\n      }\n    }\n    V=n;\n    fill(begin(used),end(used),false);\n    for(int v=0;v<V;v++){\n      if(!used[v]){\n\tdfs(v);\n      }\n    }\n    fill(begin(used),end(used),false);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]]){\n\trdfs(vs[i],k++);\n      }\n    }\n    bool in[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(e[i][j]&&cmp[i]!=cmp[j]){\n\t  in[cmp[j]]=true;\n\t}\n      }\n    }\n    cout<<count(in,in+k,false)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-8;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tif (contains(g, h[0])) return true;\n\tif (contains(h, g[0])) return true;\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc()\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tvector<int> cmp(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>> sccgraph = scc();\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0) res++;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) < -eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) <-eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS = 1e-8, INF = 1e12, PI = acos(-1.0);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  G ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n#include<stack>\nvoid visit(const vector<vi> &g, int v, vector<vi>& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  each(e, g[v]) {\n    int w = *e;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const vector<vi>& g,\n    vector<vi>& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint n, d;\nvector<vi> g;\n\nint main(){\n\twhile(cin >> n >> d, n){\n\t\tg.clear(); g.resize(n);\n\t\tvector<G> tri;\n\t\trep(i, n){\n\t\t\tint t;\n\t\t\tG p(3);\n\t\t\tdouble l[3];\n\t\t\trep(j, 3) cin >> p[j].real() >> p[j].imag();\n\t\t\trep(j, 3) l[j] = abs(p[j] - p[(j + 1) % 3]);\n\t\t\trep(j, 3) if(abs(l[j] - l[(j + 1) % 3]) < EPS){\n\t\t\t\tt = (j + 1) % 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswap(p[t], p[(t + 1) % 3]);\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\trep(i, n){\n\t\t\tG &p = tri[i];\n\t\t\tP dir = p[0] - (p[1] + p[2]) * 0.5;\n\t\t\tdir *= d / abs(dir);\n\t\t\t\n\t\t\tG ps;\n\t\t\tps.pb(p[1]); ps.pb(p[2]);\n\t\t\tps.pb(p[1] + dir); ps.pb(p[2] + dir);\n\t\t\tps = convex_hull(ps);\n\t\t\t\n\t\t\trep(j, n){\n\t\t\t\tbool ok = 0;\n\t\t\t\trep(k, 3) if(contains(ps, tri[j][k]) != OUT) ok = 1;\n\t\t\t\tif(ok) g[i].pb(j);\n\t\t\t}\n\t\t}\n\t\tmap<int, int> to;\n\t\tvector<vi> scc;\n\t\tstronglyConnectedComponents(g, scc);\n\t\tint m = scc.size();\n\t\tvi in(m);\n\t\t\n\t\trep(i, m) rep(j, scc[i].size()){\n\t\t\tto[scc[i][j]] = i;\n\t\t}\n\t\trep(i, n) rep(j, g[i].size()){\n\t\t\tint a = to[i], b = to[g[i][j]];\n\t\t\tif(a != b) in[b]++;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\trep(i, m) if(in[i] == 0) ans++;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-1)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) * SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G &a, G &b)\n{\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)) return true;\n\t\t}\n\t}\n\tfor (int i = 0; i < a.size(); i++){\n\t\tif (contains(b, a[i])) return true;\n\t}\n\tfor (int i = 0; i < b.size(); i++){\n\t\tif (contains(a, b[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) res++;\n\t\tfor (int to : sccgraph[i]){\n\t\t\tused[to] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(Segment(curr(g, i), next(g, i)), h[j]) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(Segment(curr(h, i), next(h, i)), g[j]) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tif (contains(g, h[0])) return true;\n\tif (contains(h, g[0])) return true;\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc()\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tvector<int> cmp(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tbool f = false;\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t\tf = true;\n\t\t}\n\t\tassert(f);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>> sccgraph = scc();\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0) res++;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-3)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev から cur へ行って next へ行く際の角度を求める\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //同じセグメントかもよ\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \nbool isConvex(vector<Point> p) {\n  int sz = (int)p.size();\n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft) return false;\n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c) {\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p){\n  if((int)poly.size() == 0)return false;\n  rep(i,poly.size()) if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++) {\n    if( equals(cross(poly[i]-p,poly[(i+1)%poly.size()]-p),0.0) ) continue; // ３点が平行だとangleがnanを返しsumがnanになり死ぬ\n    if( cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0 ) sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n    else                                                 sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n  }\n  // あまり誤差を厳しくしすぎると良くないので以下のほうが良い \n  const double eps = 1e-3;\n  return (fabs(sum - 2*M_PI) < eps || fabs(sum + 2*M_PI) < eps);\n}  \n\n\nconst int MAX_V = 200;\nint V,cmp[MAX_V];\ndouble d;\nPoint ps[MAX_V][3];\nvector<Polygon> poly;\nvector<int> G[MAX_V],rG[MAX_V],vs;\nbool used[MAX_V];\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  rep(i,(int)G[v].size()) if( !used[G[v][i]] ) dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  rep(i,(int)rG[v].size()) if( !used[rG[v][i]] ) rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  rep(v,V) if( !used[v] ) dfs(v);\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = (int)vs.size()-1; i >= 0 ; i-- ) if( !used[vs[i]] ) rdfs(vs[i],k++);\n  return k;\n}\n\nbool check(int a,int b) {\n  rep(i,(int)poly[a].size()) {\n    Segment seg1 = Segment(poly[a][i],poly[a][(i+1)%poly.size()]);\n    rep(j,3){\n      Segment seg2 = Segment(ps[b][j],ps[b][(j+1)%3]);\n      if( equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) ) {\n        if( onSegment(seg1.p1,seg1.p2,seg2.p1) || onSegment(seg1.p1,seg1.p2,seg2.p2) ||\n            onSegment(seg2.p1,seg2.p2,seg1.p1) || onSegment(seg2.p1,seg2.p2,seg1.p2) ) return true;\n      } else if( intersectSS(seg1,seg2) ) return true;\n    }\n  }\n  rep(i,3) if( inPolygon(poly[a],ps[b][i]) ) return true;\n  return false;\n}\n\nvoid converter(int index){\n  Polygon temp;\n  rep(i,3) {\n    double dist[2] = {abs(ps[index][(i+1)%3]-ps[index][(i+2)%3]),\n                      abs(ps[index][(i+2)%3]-ps[index][i])};\n    if( equals(dist[0],dist[1]) ) {\n      Point p = projection(Line(ps[index][i],ps[index][(i+1)%3]),ps[index][(i+2)%3]);\n      Point e = ( ps[index][(i+2)%3] - p ) / abs( ps[index][(i+2)%3] - p );\n      temp.push_back(ps[index][i]);\n      temp.push_back(ps[index][(i+1)%3]);\n      temp.push_back(ps[index][(i+1)%3] + e * d);\n      temp.push_back(ps[index][i] + e * d);\n      break;\n    }\n  }\n  assert( !temp.empty() );\n  poly.push_back(temp);\n}\n\nint nV;\nvector<int> nG[MAX_V];\n\nvoid draw(int cur){\n  rep(i,(int)nG[cur].size()){\n    if( !used[nG[cur][i]] ) {\n      used[nG[cur][i]] = true;\n      dfs(nG[cur][i]);\n    }\n  }\n}\n\nvoid compute(){\n  poly.clear(), vs.clear();\n  rep(i,V) G[i].clear(), rG[i].clear(), nG[i].clear(), used[i] = false;\n  \n  rep(i,V) converter(i);\n  \n  rep(i,V) rep(j,V) if( i != j && check(i,j) ) G[i].push_back(j);\n  \n  nV = scc();\n  \n  rep(i,V) rep(j,(int)G[i].size()) {\n    if( cmp[i] == cmp[G[i][j]] ) continue;\n    nG[cmp[i]].push_back(cmp[G[i][j]]);\n  }\n  memset(used,false,sizeof(used));\n  int answer = 0;\n  rep(i,V) if( !used[i] ){\n    used[i] = true;\n    ++answer;\n    draw(i);\n  }\n  cout << answer << endl;\n}\n\nint main(){\n  while( cin >> V >> d, (V|(int)d) ){\n    rep(i,V) rep(j,3) cin >> ps[i][j].x >> ps[i][j].y;\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef int Weight;\nconst Weight INF = 1 << 28;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge() {}\n\tEdge(int src, int dst, Weight weight = 1): src(src), dst(dst), weight(weight) {}\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n\nvoid addEdge(Graph &g, int src, int dst, int weight = 1)\n{\n\tg[src].push_back(Edge(src, dst, weight));\n};\n\nGraph transpose(const Graph &g)\n{\n\tGraph rg(g.size());\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\taddEdge(rg, g[i][j].dst, g[i][j].src, g[i][j].weight);\n\t\t}\n\t}\n\treturn rg;\n}\n\nstd::vector<Weight> dijkstra(const Graph &g, int src){\n\tstd::vector<Weight> dist(g.size(), INF);\n\tstd::priority_queue<std::pair<Weight, int>,\n\t                    std::vector<std::pair<Weight, int> >,\n\t\t\t\t\t\tstd::greater<std::pair<Weight, int> > > pq;\n\t\n\tdist[src] = Weight(0);\n\tpq.push(std::make_pair(Weight(0), src));\n\t\n\twhile (pq.size()){\n\t\tint cur = pq.top().second;\n\t\tWeight sum = pq.top().first;\n\t\tpq.pop();\n\t\tif (dist[cur] < sum) continue;\n\t\t\n\t\tfor (int i = 0; i < g[cur].size(); i++){\n\t\t\tconst Edge &e = g[cur][i];\n\t\t\tif (dist[e.dst] > sum + e.weight){\n\t\t\t\tdist[e.dst] = sum + e.weight;\n\t\t\t\tpq.push(std::make_pair(sum + e.weight, e.dst));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dist;\n}\n\nvoid dfs_(const Graph &g, int v, bool *used, std::vector<int> &vs)\n{\n\tused[v] = true;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) dfs_(g, to, used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs_(const Graph &g, int v, int k, bool *used, std::vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) rdfs_(g, to, k, used, cmp);\n\t}\n}\n\nint scc(const Graph &g, std::vector<int> &cmp)\n{\n\tGraph rg = transpose(g);\n\tstd::vector<int> vs;\n\tbool *used = new bool[g.size()];\n\tcmp.resize(g.size());\n\t\n\tmemset(used, false, g.size());\n\tfor (int v = 0; v < g.size(); v++){\n\t\tif (!used[v]) dfs_(g, v, used, vs);\n\t}\n\t\n\tmemset(used, false, g.size());\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs_(rg, vs[i], k++, used, cmp);\n\t}\n\t\n\tdelete used;\n\treturn k;\n}\n\n#include <bits/stdc++.h>\n\nnamespace geo {\n\n// ???????????§??????\n\ntypedef std::complex<double> Point;\n\nstruct Segment {\n\tPoint p1, p2;\n\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n};\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef std::vector<Point> Polygon;\n\n// ?????°, ??????\n\nconst double PI = acos(-1);\nconst double EPS = 1e-12;\nconst double INF = 1e12;\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE \t\t= -1;\nconst int ONLINE_BACK\t\t= 2;\nconst int ONLINE_FRONT\t\t= -2;\nconst int ON_SEGMENT\t\t= 0;\nconst int OUT\t\t\t\t= 0;\nconst int ON\t\t\t\t= 1;\nconst int IN\t\t\t\t= 2;\n\ninline double square(double a){return a * a;}\ninline bool equal(double a, double b){return std::abs(a - b) < EPS;}\ninline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\ninline double norm(const Point &a){return square(a.real()) + square(a.imag());}\ninline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\ninline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\ninline double toDeg(double t){return t / PI * 180;}\ninline double toRad(double t){return t / 180 * PI;}\n\n#define curr(v, i) v[i]\n#define next(v, i) v[(i + 1) % v.size()]\n#define prev(v, i) v[(i - 1 + (int)v.size()) % v.size()]\n\n\n// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n// ????§?????????????????????? Point rp ?????£??\\????????????\n\nbool cmpx(const Point &a, const Point &b){\n\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\treturn b.imag() < b.imag();\n}\n\nbool cmpy(const Point &a, const Point &b){\n\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\treturn a.real() < b.real();\n}\n\nPoint rp;\nbool cmparg(const Point &a, const Point &b){\n\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\tif (!equal(rada, radb)) return rada < radb;\n\treturn norm(a) < norm(b);\n}\n\n\n// ??´???, ??????\n\nbool orthgonal(const Vector &a, const Vector &b){\n\treturn equal(dot(a, b), 0.0);\n}\n\nbool parallel(const Vector &a, const Vector &b){\n\treturn equal(cross(a, b), 0.0);\n}\n\n\n// ????°?, ?°???±\n\nPoint project(const Segment &s, const Point &p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(const Segment &s, const Point &p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\n\n// ??????????????????\n\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n\n// ?????¢\n\ndouble distanceLP(const Line &l, const Point &p){\n\treturn std::abs(cross(l.p2 - l.p1, p - l.p1) / std::abs(l.p2 - l.p1));\n}\n\ndouble distanceSP(const Segment &s, const Point &p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return std::abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return std::abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\nbool intersect(const Segment &s1, const Segment &s2);\ndouble distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn std::min(\n\t\tstd::min(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\tstd::min(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t);\n}\n\n\n// ????????????\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &s){\n\t// ???????????° (0 ~ 2) ?????????\n\tdouble dist = distanceSP(s, c.p) - c.r;\n\tif (equal(dist, 0.0)) return 1;\n\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\nint intersect(const Circle &c1, const Circle &c2){\n\t// ???????????° (0 ~ 2) ?????????\n\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\tif (equal(dist, 0.0)) return 1;\n\tif (dist < 0.0) return 2;\n\treturn 0;\n}\n\n\n// ??????\n\nPoint crossPoint(const Segment &s1, const Segment &s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = std::abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = std::abs(cross(base, s1.p2 - s2.p1));\n\t\n\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\tassert(!equal(d1 + d2, 0.0));\n\t\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nstd::vector<Point> crossPoints(const Circle &c, const Line &l){\n\tstd::vector<Point> res;\n\tif (!intersect(c, l)) return res;\n\t\n\tVector pr = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / std::abs(l.p2 - l.p1);\n\tdouble base = std::sqrt(c.r * c.r - norm(pr - c.p));\n\tres.push_back(pr + e * base);\n\tres.push_back(pr - e * base);\n\tif (equalVector(res[0], res[1])) res.pop_back();\n\treturn res;\n}\n\nstd::vector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\tstd::vector<Point> res;\n\tif (!intersect(c1, c2)) return res;\n\t\n\tdouble d = std::abs(c1.p - c2.p);\n\tdouble a = std::acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\tdouble t = std::arg(c2.p - c1.p);\n\tres.push_back(c1.p + std::polar(c1.r, t + a));\n\tres.push_back(c1.p + std::polar(c1.r, t - a));\n\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\n\treturn res;\n}\n\n\n// ??????\n\nint contains(const Polygon &g, const Point &p){\n\tint n = g.size();\n\tbool res = false;\n\tfor (int i = 0; i < n; i++){\n\t\tPoint a = g[i] - p;\n\t\tPoint b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t}\n\treturn res ? IN : OUT;\n}\n\n\n// ??????\n\nPolygon convexHull(std::vector<Point> s){\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tstd::sort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\t\n\tfor (int i = 2; i < s.size(); i++){\n\t\tint n = u.size();\n\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\tu.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t\n\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\tint n = l.size();\n\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\tl.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t\n\tstd::reverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\tl.push_back(u[i]);\n\t}\n\t\n\treturn l;\n}\n\t\n\n// ???????§???¢??????\n\nPolygon convexCut(const Polygon &g, const Line &l){\n\tPolygon res;\n\tfor (int i = 0; i < g.size(); i++){\n\t\tconst Point &a = curr(g, i);\n\t\tconst Point &b = next(g, i);\n\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\tres.push_back(a);\n\t\t}\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\n}\n\nnamespace std {\nbool operator < (const geo::Point &a, const geo::Point &b){\n\treturn geo::cmpx(a, b);\n}\n}\n\nbool intersect(const geo::Polygon &g, const geo::Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tgeo::Segment s(curr(g, i), next(g, i));\n\t\t\tgeo::Segment t(curr(h, j), next(h, j));\n\t\t\tif (geo::intersect(s, t)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (geo::contains(h, curr(g, i))) return true;\n\t}\n\t\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (geo::contains(g, curr(h, i))) return true;\n\t}\n\t\n\treturn false;\n}\n\nint n;\ndouble d;\nstd::vector<geo::Polygon> tris;\nstd::vector<geo::Polygon> sqrs;\n\nvoid solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tgeo::Point &a = curr(tris[i], j),\n\t\t\t\t\t   &b = prev(tris[i], j),\n\t\t\t\t\t   &c = next(tris[i], j);\n\t\t\tif (geo::equal(std::abs(a - b), std::abs(a - c))){\n\t\t\t\tstd::swap(tris[i][j], tris[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsqrs.assign(n, geo::Polygon(4));\n\tfor (int i = 0; i < n; i++){\n\t\tgeo::Vector normal = tris[i][2] - (tris[i][0] + tris[i][1]) / 2.0;\n\t\tnormal = normal / std::abs(normal) * d;\n\t\t\n\t\tsqrs[i][0] = tris[i][0];\n\t\tsqrs[i][1] = tris[i][1];\n\t\tsqrs[i][2] = tris[i][1] + normal;\n\t\tsqrs[i][3] = tris[i][0] + normal;\n\t}\n\t\n\tGraph g(n);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqrs[i], tris[j])){\n\t\t\t\taddEdge(g, i, j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstd::vector<int> cmp;\n\tint k = scc(g, cmp);\n\t\n\tstd::vector<int> v(k, 1);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\tint src = g[i][j].src;\n\t\t\tint dst = g[i][j].dst;\n\t\t\tif (src != dst) v[cmp[dst]] = 0;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < k; i++){\n\t\tres += v[i];\n\t}\n\t\n\tstd::printf(\"%d\\n\", res);\n}\n\nint main()\n{\n\twhile (std::scanf(\"%d %lf\", &n, &d), n){\n\t\ttris.assign(n, geo::Polygon(3));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tdouble x, y;\n\t\t\t\tstd::cin >> x >> y;\n\t\t\t\ttris[i][j] = geo::Point(x, y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass UnionFindTree\n{\n    vector<int> parent; // em[h\n    vector<int> rank;   // ØÌ³ÌãÀ\n    int find(int x){\n        if(parent[x] == x)\n            return x;\n        return parent[x] = find(parent[x]);\n    }\npublic:\n    UnionFindTree(int n){ // RXgN^\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        rank.assign(n, 0);\n    }\n    void unite(int x, int y){ // xÆyÌO[vð¹\n        if((x = find(x)) != (y = find(y))){\n            if(rank[x] < rank[y])\n                parent[x] = y;\n            else{\n                parent[y] = x;\n                if(rank[x] == rank[y])\n                    ++ rank[x];\n            }\n        }\n    }\n    bool same(int x, int y){ // xÆyÌO[vª¯¶©ð²×é\n        return find(x) == find(y);\n    }\n    int num(){ // O[vÌðÔ·\n        vector<bool> root(parent.size(), false);\n        for(unsigned i=0; i<parent.size(); ++i)\n            root[find(i)] = true;\n        return count(root.begin(), root.end(), true);\n    }\n};\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\nbool convexContain(const vector<Point>& cp, const Point& p)\n{\n    int n = cp.size();\n    bool ret1 = true;\n    bool ret2 = true;\n    for(int i=0; i<n; ++i){\n        double a = (cp[(i+1)%n] - cp[i]).cross(p - cp[i]);\n        if(a < -EPS)\n            ret1 = false;\n        if(a > EPS)\n            ret2 = false;\n    }\n    return ret1 || ret2;\n}\n\ndouble segmentPointDist(const Point& a1, const Point& a2, const Point& p)\n{\n    if((a2-a1).dot(p-a1) < 0){\n        return a1.dist(p);\n    }else if((a1-a2).dot(p-a2) < 0){\n        return a2.dist(p);\n    }else{\n        return abs((a2-a1).cross(p-a1)) / a1.dist(a2);\n    }\n}\n\ndouble segmentsDist(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) < -EPS) && ((b2-b1).cross(a1-b1) * (b2-b1).cross(a2-b1) < -EPS))\n        return 0.0;\n\n    double ret = segmentPointDist(a1, a2, b1);\n    ret = min(ret, segmentPointDist(a1, a2, b2));\n    ret = min(ret, segmentPointDist(b1, b2, a1));\n    ret = min(ret, segmentPointDist(b1, b2, a2));\n    return ret;\n}\n\nbool polygonsCollide(const vector<Point>& cp1, const vector<Point>& cp2)\n{\n    int n = cp1.size();\n    int m = cp2.size();\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<m; ++j){\n            if(segmentsDist(cp1[i], cp1[(i+1)%n], cp2[j], cp2[(j+1)%m]) < 0.01 + EPS)\n                return true;\n        }\n    }\n\n    return convexContain(cp1, cp2[0]) || convexContain(cp2, cp1[0]);\n}\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Point> > p(n, vector<Point>(3));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<3; ++j){\n                cin >> p[i][j].x >> p[i][j].y;\n            }\n            if(p[i][0].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][1], p[i][2]);\n            if(p[i][1].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][0], p[i][2]);\n        }\n\n        UnionFindTree uft(n);\n        vector<bool> check(n, false);\n        for(int i=0; i<n; ++i){\n            Point v = p[i][0] - p[i][1];\n            v = v / v.length() * d;\n            swap(v.y, v.x);\n            v.y *= -1;\n\n            vector<Point> p1(4);\n            p1[0] = p[i][0];\n            p1[1] = p[i][0] + v;\n            p1[2] = p[i][1] + v;\n            p1[3] = p[i][1];\n            if(!convexContain(p1, p[i][2])){\n                p1[1] = p[i][0] - v;\n                p1[2] = p[i][1] - v;\n            }\n\n            for(int j=0; j<n; ++j){\n                if(j == i)\n                    continue;\n                if(polygonsCollide(p1, p[j])){\n                    uft.unite(i, j);\n                    check[j] = true;\n                }\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            if(!check[i])\n                ++ ret;\n            else{\n                bool b = true;\n                for(int j=0; j<n; ++j){\n                    if(uft.same(i, j) && !check[j])\n                        b = false;\n                }\n                if(b)\n                    ++ ret;\n                check[i] = false;\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\n#include <cstring>\n\n// ???, ????????????\ntypedef std::complex<double> Point;\ntypedef Point Vector;\n\nnamespace std {\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\t\n\tistream& operator >> (istream &is, Point &a){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\ta = Point(x, y);\n\t\treturn is;\n\t}\n\t\n\tostream& operator << (ostream &os, Point a){\n\t\treturn os << a.real() << \" \" << a.imag();\n\t}\n}\n\n// ??´???\nstruct Line {\n\tPoint p1, p2;\n\tLine(){}\n\tLine(const Point &p1, const Point &p2): p1(p1), p2(p2){}\n};\ntypedef Line Segment;\n\nnamespace std {\n\tistream& operator >> (istream &is, Line &a){\n\t\treturn is >> a.p1 >> a.p2;\n\t}\n}\n\n// ???\nstruct Circle {\n\tPoint p; double r;\n\tCircle(){}\n\tCircle(const Point &p, double r): p(p), r(r){}\n};\n\nnamespace std {\n\tistream& operator >> (istream &is, Circle &a){\n\t\treturn is >> a.p >> a.r;\n\t}\n}\n\n// ????§???¢\ntypedef std::vector<Point> Polygon;\n\nconst double EPS = 0.005;\nconst double INF = 1e12;\nconst double PI = acos(-1.0);\n\n// ????????¨??????????????¢???\nenum CCW {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0,\n};\n\n// ?????¢????£????????????¢???\nenum {\n\tOUT = 0,\n\tON = 1,\n\tIN = 2,\n};\n\n\n// a ??? 2 ??? (a ^ 2)\ndouble SQ(double a);\n\n// ?????????????????????????????¢??°\nbool EQ(double a, double b);\nbool NEQ(double a, double b);\nbool LT(double a, double b);\nbool GT(double a, double b);\nbool LEQ(double a, double b);\nbool GEQ(double a, double b);\n\n// ??§?????? <=> ?????°?????????\ndouble toDeg(double t);\ndouble toRad(double t);\n\n// ????????? (dot(a, a))\ndouble norm(const Vector &a);\n\n// ??????, ??????\ndouble dot(const Vector &a, const Vector &b);\ndouble cross(const Vector &a, const Vector &b);\n\n// ??´???, ??????\nbool orthogonal(const Segment &s1, const Segment &s2);\nbool parallel(const Segment &s1, const Segment &s2);\n\n// ?°???±, ????°?\nPoint project(const Line &l, const Point &p);\nPoint reflect(const Line &l, const Point &p);\n\n// ?????? (p0, p1) ??¨??? p2 ???????????¢???\nint ccw(const Point &p0, const Point &p1, const Point &p2);\n\n// ????????????\nbool intersectLP(const Line &l, const Point &p);\nbool intersectLL(const Line &l1, const Line &l2);\nbool intersectLS(const Line &l, const Segment &s);\nbool intersectSP(const Segment &s, const Point &p);\nbool intersectSS(const Segment &s1, const Segment &s2);\nint intersectCP(const Circle &c, const Point &p);\nbool intersectCL(const Circle &c, const Line &l);\nint intersectCS(const Circle &c, const Segment &s);\nint intersectCC(const Circle &c1, const Circle &c2);\n\n// ?????¢\ndouble distanceLP(const Line &l, const Point &p);\ndouble distanceLL(const Line &l1, const Line &l2);\ndouble distanceLS(const Line &l, const Segment &s);\ndouble distanceSP(const Segment &s, const Point &p);\ndouble distanceSS(const Segment &s1, const Segment &s2);\ndouble distanceCP(const Circle &c, const Point &p);\ndouble distanceCL(const Circle &c, const Line &l);\ndouble distanceCS(const Circle &c, const Segment &s);\ndouble distanceCC(const Circle &c1, const Circle &c2);\n\n// ??????\nPoint crossPointLL(const Line &l1, const Line &l2);\nPoint crossPointLS(const Line &l, const Segment &s);\nPoint crossPointSS(const Segment &s1, const Segment &s2);\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l);\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s);\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2);\n\n\ndouble SQ(double a){\n\treturn a * a;\n}\n\nbool EQ(double a, double b){\n\treturn std::abs(a - b) < EPS;\n}\n\nbool NEQ(double a, double b){\n\treturn !EQ(a, b);\n}\n\nbool LT(double a, double b){\n\treturn a - b < -EPS;\n}\n\nbool GT(double a, double b){\n\treturn a - b > EPS;\n}\n\nbool LEQ(double a, double b){\n\treturn !GT(a, b);\n}\n\nbool GEQ(double a, double b){\n\treturn !LT(a, b);\n}\n\ndouble toDeg(double t){\n\treturn t * 180 / PI;\n}\n\ndouble toRad(double t){\n\treturn t / 180 * PI;\n}\n\ndouble norm(const Vector &a){\n\treturn SQ(a.real()) + SQ(a.imag());\n}\n\ndouble dot(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).real();\n}\n\ndouble cross(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).imag();\n}\n\n// AOJ CGL_2_A\nbool orthogonal(const Segment &s1, const Segment &s2){\n\treturn EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_2_A\nbool parallel(const Segment &s1, const Segment &s2){\n\treturn EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_1_A\nPoint project(const Line &l, const Point &p){\n\tVector base = l.p2 - l.p1;\n\tdouble r = dot(p - l.p1, base) / norm(base);\n\treturn l.p1 + base * r;\n}\n\n// AOJ CGL_1_B\nPoint reflect(const Line &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2.0;\n}\n\n// AOJ CGL_1_C\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (GT(cross(a, b), 0.0)) return COUNTER_CLOCKWISE;\n\tif (LT(cross(a, b), 0.0)) return CLOCKWISE;\n\tif (LT(dot(a, b), 0.0)) return ONLINE_BACK;\n\tif (LT(norm(a), norm(b))) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersectLP(const Line &l, const Point &p){\n\treturn LEQ(std::abs(cross(l.p1 - p, l.p2 - p)), 0.0);\n}\n\nbool intersectLL(const Line &l1, const Line &l2){\n\treturn !parallel(l1, l2) || LEQ(std::abs(cross(l1.p2 - l1.p1, l2.p1 - l1.p1)), 0.0);\n}\n\nbool intersectLS(const Line &l, const Segment &s){\n\treturn LEQ(cross(l.p2 - l.p1, s.p1 - l.p1) * cross(l.p2 - l.p1, s.p2 - l.p1), 0.0);\n}\n\nbool intersectSP(const Segment &s, const Point &p){\n\treturn norm(s.p1 - p) + norm(s.p2 - p) - norm(s.p2 - s.p1) < EPS;\n}\n\n// CGL_2_B\nbool intersectSS(const Segment &s1, const Segment &s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\nint intersectCP(const Circle &c, const Point &p){\n\tdouble dd = norm(c.p - p);\n\tif (LT(dd, SQ(c.r))) return IN;\n\tif (EQ(dd, SQ(c.r))) return ON;\n\treturn OUT;\n}\n\nbool intersectCL(const Circle &c, const Line &l){\n\tdouble d = distanceLP(l, c.p);\n\treturn LEQ(d, c.r);\n}\n\nint intersectCS(const Circle &c, const Segment &s){\n\tdouble dd1 = norm(c.p - s.p1);\n\tdouble dd2 = norm(c.p - s.p2);\n\tif (LT(dd1, SQ(c.r)) && LT(dd2, SQ(c.r))) return IN;\n\tif (GT(distanceCS(c, s), 0.0)) return OUT;\n\treturn ON;\n}\n\n// c1 ??? c2 ???????????????????????¨??? IN\n// c1 ??? c2 ????????£???????????¨??? ON\n// c1 ??? c2 ?????????????????¨??? OUT\nint intersectCC(const Circle &c1, const Circle &c2){\n\tif (GT(norm(c1.p - c2.p), SQ(c1.r + c2.r))) return OUT;\n\tif (LT(norm(c1.p - c2.p), SQ(c2.r))) return IN;\n\tif (LT(norm(c1.p - c2.p), SQ(c1.r))) return OUT;\n\treturn ON;\n}\n\ndouble distanceLP(const Line &l, const Point &p){\n\treturn std::abs(cross(l.p2 - l.p1, p - l.p1)) / std::abs(l.p2 - l.p1);\n}\n\ndouble distanceLL(const Line &l1, const Line &l2){\n\tif (intersectLL(l1, l2)) return 0.0;\n\treturn distanceLP(l1, l2.p1);\n}\n\ndouble distanceLS(const Line &l, const Segment &s){\n\tif (intersectLS(l, s)) return 0.0;\n\treturn std::min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\n\ndouble distanceSP(const Segment &s, const Point &p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return std::abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return std::abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\n// AOJ CGL_2_D\ndouble distanceSS(const Segment &s1, const Segment &s2){\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn std::min(\n\t\tstd::min(\n\t\t\tdistanceSP(s1, s2.p1),\n\t\t\tdistanceSP(s1, s2.p2)\n\t\t),\n\t\tstd::min(\n\t\t\tdistanceSP(s2, s1.p1),\n\t\t\tdistanceSP(s2, s1.p2)\n\t\t)\n\t);\n}\n\ndouble distanceCP(const Circle &c, const Point &p){\n\treturn std::abs(std::abs(c.p - p) - c.r);\n} \n\ndouble distanceCL(const Circle &c, const Line &l){\n\tif (intersectCL(c, l)) return 0.0;\n\treturn distanceLP(l, c.p) - c.r;\n}\n\ndouble distanceCS(const Circle &c, const Segment &s){\n\tif (intersectCS(c, s)) return 0.0;\n\treturn std::min(distanceCP(c, s.p1), distanceCP(c, s.p2));\n}\n\ndouble distanceCC(const Circle &c1, const Circle &c2){\n\tif (intersectCC(c1, c2) == ON) return 0.0;\n\tif (intersectCC(c1, c2) == IN){\n\t\treturn c2.r - (std::abs(c1.p - c2.p) + c1.r);\n\t}\n\tif (intersectCC(c2, c1) == IN){\n\t\treturn c1.r - (std::abs(c1.p - c2.p) + c2.r);\n\t}\n\treturn (c1.r + c2.r) - (c1.r + c2.r);\n}\n\nPoint crossPointLL(const Line &l1, const Line &l2){\n\tassert(intersectLL(l1, l2));\n\tVector base = l2.p2 - l2.p1;\n\tdouble d1 = std::abs(cross(base, l1.p1 - l2.p1));\n\tdouble d2 = std::abs(cross(base, l1.p2 - l2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn l1.p1 + (l1.p2 - l1.p1) * t;\n}\n\nPoint crossPointLS(const Line &l, const Segment &s){\n\tassert(intersectLS(l, s));\n\treturn crossPointLL(l, s);\n}\n\nPoint crossPointSS(const Segment &s1, const Segment &s2){\n\tassert(intersectSS(s1, s2));\n\treturn crossPointSS(s1, s2);\n}\n\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l){\n\tif (!intersectCL(c, l)) return std::vector<Point>();\n\tstd::vector<Point> ret;\n\tVector proj = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / std::abs(l.p2 - l.p1);\n\tdouble base = sqrt(SQ(c.r) - norm(proj - c.p));\n\tret.push_back(proj + e * base);\n\tret.push_back(proj - e * base);\n\treturn ret;\n}\n\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s){\n\tstd::vector<Point> ret = crossPointCL(c, s);\n\tfor (int i = 0; i < ret.size(); i++){\n\t\tif (!intersectCP(c, ret[i])){\n\t\t\tswap(ret[i], ret.back());\n\t\t\tret.pop_back();\n\t\t\ti--;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2){\n\tif (!intersectCC(c1, c2)) return std::vector<Point>();\n\tstd::vector<Point> ret;\n\tdouble d = std::abs(c1.p - c2.p);\n\tdouble a = std::acos((SQ(c1.r) + SQ(d) - SQ(c2.r)) / (2 * c1.r * d));\n\tdouble t = std::arg(c2.p - c1.p);\n\tret.push_back(c1.p + std::polar(c1.r, t + a));\n\tret.push_back(c1.p + std::polar(c1.r, t - a));\n\treturn ret;\n}\n\nnamespace {\nenum {DIRECTED, UNDIRECTED};\nconst int GRAPH_TYPE = DIRECTED;\n\ntypedef int Weight;\nconst Weight INF = 1 << 28;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge() {}\n\tEdge(int src, int dst, Weight weight = 1): src(src), dst(dst), weight(weight) {}\n\tbool operator < (const Edge &t) const { return weight < t.weight; }\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n\nvoid addEdge(Graph &g, int src, int dst, int weight = 1)\n{\n\tg[src].push_back(Edge(src, dst, weight));\n\tif (GRAPH_TYPE == UNDIRECTED) g[dst].push_back(Edge(dst, src, weight));\n};\n\nGraph transpose(const Graph &g)\n{\n\tGraph rg(g.size());\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\taddEdge(rg, g[i][j].dst, g[i][j].src, g[i][j].weight);\n\t\t}\n\t}\n\treturn rg;\n}\n\nvoid dfs_(const Graph &g, int v, bool *used, std::vector<int> &vs)\n{\n\tused[v] = true;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) dfs_(g, to, used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs_(const Graph &g, int v, int k, bool *used, std::vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) rdfs_(g, to, k, used, cmp);\n\t}\n}\n\nint scc(const Graph &g, std::vector<int> &cmp)\n{\n\tGraph rg = transpose(g);\n\tstd::vector<int> vs;\n\tbool *used = new bool[g.size()];\n\tcmp.resize(g.size());\n\t\n\tstd::memset(used, false, g.size());\n\tfor (int v = 0; v < g.size(); v++){\n\t\tif (!used[v]) dfs_(g, v, used, vs);\n\t}\n\t\n\tstd::memset(used, false, g.size());\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs_(rg, vs[i], k++, used, cmp);\n\t}\n\t\n\tdelete used;\n\treturn k;\n}\n}\n\n\nusing namespace std;\n\nint n;\ndouble d;\nvector<Polygon> tri;\nvector<Polygon> rect;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment s(g[i], g[(i + 1) % g.size()]);\n\t\t\tSegment t(h[j], h[(j + 1) % h.size()]);\n\t\t\tif (intersectSS(s, t)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint solve()\n{\n\trect.assign(n, Polygon(4));\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tif (EQ(norm(tri[i][j] - tri[i][(j + 1) % 3]), norm(tri[i][j] - tri[i][(j + 2) % 3]))){\n\t\t\t\tswap(tri[i][0], tri[i][j]);\n\t\t\t}\n\t\t}\n\t\tif (ccw(tri[i][1], tri[i][2], tri[i][0]) == CLOCKWISE){\n\t\t\tswap(tri[i][1], tri[i][2]);\n\t\t}\n\t\t\n\t\tVector s = tri[i][2] - tri[i][1];\n\t\tVector normal = s / abs(s) * Vector(0, 1) * d;\n\t\trect[i][0] = tri[i][1];\n\t\trect[i][1] = tri[i][2];\n\t\trect[i][2] = tri[i][2] + normal;\n\t\trect[i][3] = tri[i][1] + normal;\n\t}\n\t\n\tGraph graph(n);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(rect[i], tri[j])){\n\t\t\t\taddEdge(graph, i, j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tint v = scc(graph, cmp);\n\tint mat[100][100] = {};\n\tint in[100] = {};\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < graph[i].size(); j++){\n\t\t\tint src = cmp[i];\n\t\t\tint dst = cmp[graph[i][j].dst];\n\t\t\tif (src == dst) continue;\n\t\t\tif (mat[src][dst]++) continue;\n\t\t\tin[dst]++;\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < v; i++){\n\t\tif (in[i] == 0) res++;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tstd::cout << std::fixed << std::setprecision(12);\n\t\n\twhile (cin >> n >> d, n){\n\t\ttri.assign(n, Polygon(3));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-3;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      break;\n    }\n  }while(next_permutation(in,in+3));\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-6\n ;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct coor {\n\tdouble x, y;\n};\nstruct tri {\n\tcoor p[3];\n\tcoor rec[4];\n};\n\nint n, d;\nvector<tri> v;\nvector<vector<int> > edge;\n\nconst double EPS = 1e-9;\nconst double ERR = 1e-2;\n\ntemplate<class T>\nT sqr(T x) {\n\treturn x * x;\n}\n\ndouble dist(coor a, coor b) {\n\treturn sqrt(sqr(a.x-b.x) + sqr(a.y-b.y));\n}\n\ndouble dist_lp(coor c, coor a, coor b) {\n\tcoor v0, v1;\n\tv0.x = b.x - a.x; v0.y = b.y - a.y;\n\tv1.x = c.x - a.x; v1.y = c.y - a.y;\n\n\tif(sqr(dist(a,b)) + sqr(dist(a,c)) - sqr(dist(c,b)) > 0\n\t\t\t&& sqr(dist(a,b)) + sqr(dist(b,c)) - sqr(dist(c,a)) > 0) {\n\t\tdouble cross;\n\t\tcross = fabs(v0.x * v1.y - v0.y * v1.x);\n\t\treturn cross / dist(a,b);\n\t}\n\n\treturn min(dist(a,c), dist(b,c));\n}\n\nbool in_rect(coor p, coor rect[]) {\n\tdouble sign = +0.0;\n\tfor(int i = 0; i < 4; i++) {\n\t\tcoor v0, v1;\n\t\tv0.x = rect[i].x - p.x; v0.y = rect[i].y - p.y;\n\t\tv1.x = rect[(i+1)%4].x - p.x; v1.y = rect[(i+1)%4].y - p.y;;\n\n\t\tif(i != 0 && sign * (v0.x * v1.y - v0.y * v1.x) < EPS) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tsign = (v0.x * v1.y - v0.y * v1.x);\n\n\t\tif(i == 3) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(dist_lp(p,rect[i], rect[(i+1)%4]) <= ERR) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool exist_edge(tri from, tri to) {\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(in_rect(to.p[i], from.rec))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool visited[128];\nbool touch[128];\n\nvoid check(int i, int s) {\n\tif(i != s && touch[i])\n\t\ttouch[i] = false;\n\tif(visited[i])\n\t\treturn;\n\tvisited[i] = true;\n\tfor(int j = 0; j < edge[i].size(); j++) {\n\t\tcheck(edge[i][j], s);\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> d, n || d) {\n\t\tv.clear();\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tvisited[i] = touch[i] = false;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttri in;\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tcoor c;\n\t\t\t\tcin >> c.x >> c.y;\n\t\t\t\tin.p[j] = c;\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tif(fabs(dist(in.p[(0+j)%3],in.p[(1+j)%3]) - dist(in.p[(1+j)%3], in.p[(2+j)%3])) < ERR) {\n\t\t\t\t\tswap(in.p[(1+j)%3], in.p[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcoor add;\n\t\t\tadd.x =\t(in.p[1].x - in.p[0].x) + (in.p[1].x - in.p[2].x);\n\t\t\tadd.y = (in.p[1].y - in.p[0].y) + (in.p[1].y - in.p[2].y);\n\n\t\t\tdouble addlen;\n\t\t\taddlen = sqrt(sqr(add.x) + sqr(add.y));\n\t\t\tadd.x = add.x * d / addlen;\n\t\t\tadd.y = add.y * d / addlen;\n\n\t\t\tin.rec[0].x = in.p[0].x; in.rec[0].y = in.p[0].y;\n\t\t\tin.rec[1].x = in.p[2].x; in.rec[1].y = in.p[2].y;\n\t\t\tin.rec[2].x = in.p[2].x + add.x; in.rec[2].y = in.p[2].y + add.y;\n\t\t\tin.rec[3].x = in.p[0].x + add.x; in.rec[3].y = in.p[0].y + add.y;\n\n\t\t\tv.push_back(in);\n\t\t}\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\t\tif(i != j) {\n\t\t\t\t\tif(exist_edge(v[i], v[j])) {\n\t\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\ttouch[i] = true;\n\t\t\t\tcheck(i, i);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(touch[i])\n\t\t\t\tres++;\n\t\t}\n\t\tcout <<  res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-8)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) + SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G &a, G &b)\n{\t\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < a.size(); i++){\n\t\tif (contains(b, a[i])){\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int i = 0; i < b.size(); i++){\n\t\tif (contains(a, b[i])){\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) res++;\n\t\tused[i] = true;\n\t\tfor (int to : sccgraph[i]){\n\t\t\tused[to] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n        ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      /*\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n      */\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }else if (is_intersected_polygon(tri[i],tri[j])){\n\t//\tassert(false);\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n\n\tinedge[j].pb(i);\n\tredge[i].pb(j);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    d+=0.0001;\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-10;\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      //if (     cross(a[in[0]]-a[in[1]],a[in[2]]-a[in[1]]) >=0)\n      //\tassert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])>=0);\n      //      else assert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])<=0);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  //assert(false);\n  return ret;\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <eps))return true;\n  else return false;\n}\n\n#define DSS distance_ls_p\ndouble distance_ss_p(P a,P b,P c,P d){\n  return min(  min( DSS(a,b,c),DSS(a,b,d)),min(DSS(c,d,a),DSS(c,d,b)));\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri,double d){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n      rep(k,tri[j].size()){\n\tif (is_in(tri[i],tri[j][k])&&\n\t    (distance_ss_p(sq[i][0],sq[i][1],tri[j][0],tri[j][1])<d+eps ||\n\t     distance_ss_p(sq[i][0],sq[i][1],tri[j][1],tri[j][2])<d+eps||\n\t     distance_ss_p(sq[i][0],sq[i][1],tri[j][2],tri[j][0])<d+eps)\n\t    ){\n\t  assert(false);\n\t  inedge[i].pb(j);\n\t  redge[j].pb(i);\n\t  break;\n\t}\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in,d);\n\n\n    //rep(i,n){rep(j,sq[i].size())cout<< sq[i][j];cout << endl;}\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nstruct coor {\n\tdouble x, y;\n};\nstruct tri {\n\tcoor p[3];\n\tcoor rec[4];\n};\n\nint n, d;\nvector<tri> v;\nvector<vector<int> > edge;\n\nconst double EPS = 1e-9;\nconst double ERR = 1e-2;\n\ntemplate<class T>\nT sqr(T x) {\n\treturn x * x;\n}\n\ndouble dist(coor a, coor b) {\n\treturn sqrt(sqr(a.x-b.x) + sqr(a.y-b.y));\n}\n\ndouble dist_lp(coor c, coor a, coor b) {\n\tcoor v0, v1;\n\tv0.x = b.x - a.x; v0.y = b.y - a.y;\n\tv1.x = c.x - a.x; v1.y = c.y - a.y;\n\n\tif(sqr(dist(a,b)) + sqr(dist(a,c)) - sqr(dist(c,b)) > 0\n\t\t\t&& sqr(dist(a,b)) + sqr(dist(b,c)) - sqr(dist(c,a)) > 0) {\n\t\tdouble cross;\n\t\tcross = fabs(v0.x * v1.y - v0.y * v1.x);\n\t\treturn cross / dist(a,b);\n\t}\n\n\treturn min(dist(a,c), dist(b,c));\n}\n\nbool in_poly(coor p, coor poly[], int sz) {\n\tdouble sign = +0.0;\n\tfor(int i = 0; i < sz; i++) {\n\t\tcoor v0, v1;\n\t\tv0.x = poly[i].x - p.x; v0.y = poly[i].y - p.y;\n\t\tv1.x = poly[(i+1)%sz].x - p.x; v1.y = poly[(i+1)%sz].y - p.y;;\n\n\t\tif(i != 0 && sign * (v0.x * v1.y - v0.y * v1.x) < EPS) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tsign = (v0.x * v1.y - v0.y * v1.x);\n\n\t\tif(i == sz-1) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < sz; i++) {\n\t\tif(dist_lp(p,poly[i], poly[(i+1)%sz]) <= ERR + EPS) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool seg_cross(coor a, coor b, coor c, coor d) {\n\tcoor v0, v1, v2;\n\t\n\tv0.x = a.x - c.x; v0.y = a.y - c.y;\n\tv1.x = b.x - c.x; v1.y = b.y - c.y;\n\tv2.x = d.x - c.x; v2.y = d.y - c.y;\n\n\tdouble s, t;\n\ts = (v0.x * v2.y - v0.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\tt = - (v1.x * v2.y - v1.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\n\tif(s + t > 1-EPS && s > -EPS && t > -EPS) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool exist_edge(tri from, tri to) {\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(in_poly(to.p[i], from.rec, 4)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(in_poly(from.rec[i], to.p, 3)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 3; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tif(seg_cross(to.p[i], to.p[(i+1)%3], from.rec[j], from.rec[(j+1)%4])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool visited[128];\nbool touch[128];\n\nvoid check(int i, int s) {\n\tif(i != s && touch[i])\n\t\ttouch[i] = false;\n\tif(visited[i])\n\t\treturn;\n\tvisited[i] = true;\n\tfor(int j = 0; j < (int)edge[i].size(); j++) {\n\t\tcheck(edge[i][j], s);\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> d, n || d) {\n\t\tv.clear();\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tvisited[i] = touch[i] = false;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttri in;\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tcoor c;\n\t\t\t\tcin >> c.x >> c.y;\n\t\t\t\tin.p[j] = c;\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tif(fabs(dist(in.p[(0+j)%3],in.p[(1+j)%3]) - dist(in.p[(1+j)%3], in.p[(2+j)%3])) < EPS) {\n\t\t\t\t\tswap(in.p[(1+j)%3], in.p[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcoor add;\n\t\t\t/*\n\t\t\tadd.x =\t(in.p[1].x - in.p[0].x) + (in.p[1].x - in.p[2].x);\n\t\t\tadd.y = (in.p[1].y - in.p[0].y) + (in.p[1].y - in.p[2].y);\n\t\t\t// */\n\t\t\t//*\n\t\t\tint sign = -1;\n\t\t\tif((in.p[2].x - in.p[0].x)*(in.p[1].y - in.p[0].y) - (in.p[2].y - in.p[0].y)*(in.p[1].x - in.p[0].x) < 0)\n\t\t\t\tsign = 1;\n\t\t\tadd.x =\t(in.p[2].y - in.p[0].y) * sign;\n\t\t\tadd.y = -(in.p[2].x - in.p[0].x) * sign;\n\t\t\t// */\n\n\t\t\tdouble addlen;\n\t\t\taddlen = sqrt(sqr(add.x) + sqr(add.y));\n\t\t\tadd.x = add.x * d / addlen;\n\t\t\tadd.y = add.y * d / addlen;\n\n\t\t\tin.rec[0].x = in.p[0].x; in.rec[0].y = in.p[0].y;\n\t\t\tin.rec[1].x = in.p[2].x; in.rec[1].y = in.p[2].y;\n\t\t\tin.rec[2].x = in.p[2].x + add.x; in.rec[2].y = in.p[2].y + add.y;\n\t\t\tin.rec[3].x = in.p[0].x + add.x; in.rec[3].y = in.p[0].y + add.y;\n\n\t\t\tv.push_back(in);\n\t\t}\n\n\t\tfor(int i = 0; i < (int)v.size(); i++) {\n\t\t\tfor(int j = 0; j < (int)v.size(); j++) {\n\t\t\t\tif(i != j) {\n\t\t\t\t\tif(exist_edge(v[i], v[j])) {\n\t\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\ttouch[i] = true;\n\t\t\t\tcheck(i, i);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(touch[i])\n\t\t\t\tres++;\n\t\t}\n\t\tcout <<  res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-2;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(Segment(curr(g, i), next(g, i)), h[j]) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(Segment(curr(h, i), next(h, i)), g[j]) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tif (contains(g, h[0])) return true;\n\tif (contains(h, g[0])) return true;\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc()\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tvector<int> cmp(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout << abs(tri[i][2] - tri[i][0]) << \" \" << abs(tri[i][2] - tri[i][1]) << endl;\n\t\tassert(equal(abs(tri[i][2] - tri[i][0]), abs(tri[i][2] - tri[i][1])));\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tbool f = false;\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\t\n\t\t\tVector t = tri[i][2] - tri[i][0];\n\t\t\tVector s = nv;\n\t\t\tt /= s;\n\t\t\ts /= s;\n\t\t\t\n\t\t\tif (dot(s, t) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t\tf = true;\n\t\t}\n\t\tassert(f);\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>> sccgraph = scc();\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0) res++;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev から cur へ行って next へ行く際の角度を求める\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //同じセグメントかもよ\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \nbool isConvex(vector<Point> p) {\n  int sz = (int)p.size();\n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft) return false;\n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c) {\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p){\n  if((int)poly.size() == 0)return false;\n  rep(i,poly.size()) if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++) {\n    if( equals(cross(poly[i]-p,poly[(i+1)%poly.size()]-p),0.0) ) continue; // ３点が平行だとangleがnanを返しsumがnanになり死ぬ\n    if( cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0 ) sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n    else                                                 sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n  }\n  // あまり誤差を厳しくしすぎると良くないので以下のほうが良い \n  const double eps = 1e-5;\n  return (fabs(sum - 2*M_PI) < eps || fabs(sum + 2*M_PI) < eps);\n}  \n\n\nconst int MAX_V = 200;\nint V,cmp[MAX_V];\ndouble d;\nPoint ps[MAX_V][3];\nvector<Polygon> poly;\nvector<int> G[MAX_V],rG[MAX_V],vs;\nbool used[MAX_V];\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v] = true;\n  rep(i,(int)G[v].size()) if( !used[G[v][i]] ) dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v] = true;\n  cmp[v] = k;\n  rep(i,(int)rG[v].size()) if( !used[rG[v][i]] ) rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  rep(v,V) if( !used[v] ) dfs(v);\n  memset(used,0,sizeof(used));\n  int k = 0;\n  for(int i = (int)vs.size()-1; i >= 0 ; i-- ) if( !used[vs[i]] ) rdfs(vs[i],k++);\n  return k;\n}\n\nbool check(int a,int b) {\n  rep(i,(int)poly[a].size()) {\n    Segment seg1 = Segment(poly[a][i],poly[a][(i+1)%poly.size()]);\n    rep(j,3){\n      Segment seg2 = Segment(ps[b][j],ps[b][(j+1)%3]);\n      if( equals(cross(seg1.p1-seg1.p2,seg2.p1-seg2.p2),0.0) ) {\n        if( onSegment(seg1.p1,seg1.p2,seg2.p1) || onSegment(seg1.p1,seg1.p2,seg2.p2) ||\n            onSegment(seg2.p1,seg2.p2,seg1.p1) || onSegment(seg2.p1,seg2.p2,seg1.p2) ) return true;\n      } else if( intersectSS(seg1,seg2) ) return true;\n    }\n  }\n  rep(i,3) if( inPolygon(poly[a],ps[b][i]) ) return true;\n  return false;\n}\n\nvoid converter(int index){\n  Polygon temp;\n  rep(i,3) {\n    double dist[2] = {abs(ps[index][(i+1)%3]-ps[index][(i+2)%3]),\n                      abs(ps[index][(i+2)%3]-ps[index][i])};\n    if( equals(dist[0],dist[1]) ) {\n      Point p = projection(Line(ps[index][i],ps[index][(i+1)%3]),ps[index][(i+2)%3]);\n      Point e = ( ps[index][(i+2)%3] - p ) / abs( ps[index][(i+2)%3] - p );\n      temp.push_back(ps[index][i]);\n      temp.push_back(ps[index][(i+1)%3]);\n      temp.push_back(ps[index][(i+1)%3] + e * d);\n      temp.push_back(ps[index][i] + e * d);\n      break;\n    }\n  }\n  assert( !temp.empty() );\n  poly.push_back(temp);\n}\n\nint nV;\nvector<int> nG[MAX_V];\n\nvoid draw(int cur){\n  rep(i,(int)nG[cur].size()){\n    if( !used[nG[cur][i]] ) {\n      used[nG[cur][i]] = true;\n      dfs(nG[cur][i]);\n    }\n  }\n}\n\nvoid compute(){\n  poly.clear(), vs.clear();\n  rep(i,V) G[i].clear(), rG[i].clear(), nG[i].clear(), used[i] = false;\n  \n  rep(i,V) converter(i);\n  \n  rep(i,V) rep(j,V) if( i != j && check(i,j) ) G[i].push_back(j);\n  \n  nV = scc();\n  \n  rep(i,V) rep(j,(int)G[i].size()) {\n    if( cmp[i] == cmp[G[i][j]] ) continue;\n    nG[cmp[i]].push_back(cmp[G[i][j]]);\n  }\n  memset(used,false,sizeof(used));\n  int answer = 0;\n  rep(i,V) if( !used[i] ){\n    used[i] = true;\n    ++answer;\n    draw(i);\n  }\n  cout << answer << endl;\n}\n\nint main(){\n  while( cin >> V >> d, (V|(int)d) ){\n    rep(i,V) rep(j,3) cin >> ps[i][j].x >> ps[i][j].y;\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-9;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[0])<eps||fabs(l[2]-l[0])<eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    bool c[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<-eps;\n\t      c[j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    c[j]|=!f;\n\t  }\n\t}\n      }\n    }\n    cout<<max<int>(1,count(c,c+n,false))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)==real(b)?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\nconst D EPS = 1e-9, AD = 1e-2;\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nP tri[110][5];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\npair<P,P> norm(P p){return make_pair(p*P(0,1),p*P(0,-1));}\n\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nvector<P> convex_hull(vector<P> v){\n  int n = v.size(), k = 0;\n  sort(v.begin(),v.end());\n  vector<P> r(2*n);\n  for(int i=0;i<n;i++){\n    while(k>1 && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= EPS)k--;\n    r[k++] = v[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= EPS)k--;\n    r[k++] = v[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\nD seg_p_dis(L a,P x){\n  if(dot(a.sc-a.fs,x-a.fs)<EPS)return abs(x-a.fs);\n  if(dot(a.fs-a.sc,x-a.sc)<EPS)return abs(x-a.sc);\n  return abs(cross(a.sc-a.fs,x-a.fs))/abs(a.sc-a.fs);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(abs(cross(a.sc-a.fs,b.sc-b.fs))<EPS)\n    return (min(min(seg_p_dis(a,b.fs),seg_p_dis(a,b.sc)),\n\t\tmin(seg_p_dis(b,a.fs),seg_p_dis(b,a.sc)))<EPS);\n  if(cross(a.sc-a.fs,b.fs-a.fs)*cross(a.sc-a.fs,b.sc-a.fs)>0)return false;\n  if(cross(a.fs-a.sc,b.fs-a.sc)*cross(a.fs-a.sc,b.sc-a.sc)>0)return false;\n  if(cross(b.sc-b.fs,a.fs-b.fs)*cross(b.sc-b.fs,a.sc-b.fs)>0)return false;\n  return (cross(b.fs-b.sc,a.fs-b.sc)*cross(b.fs-b.sc,a.sc-b.sc)>0);\n}\n\n/*\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n*/\n\nD area(P a,P b,P c){\n  return abs(cross(a,b)+cross(b,c)+cross(c,a));\n}\n\nbool inter_pos(Poly p,P x,D A){\n  D a = 0; int s = p.size();\n  rep(i,n)a += area(p[i],p[(i+1)%s],x);\n  return EQ(a,A);\n}\n\n/*\nbool inter_pos(Poly p,P x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n*/\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(cin >> n >> d, n+d){\n    rep(i,n){\n      cin >> tri[i][0].real() >> tri[i][0].imag();\n      cin >> tri[i][1].real() >> tri[i][1].imag();\n      cin >> tri[i][2].real() >> tri[i][2].imag();\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]);\n\t  if(cross(tri[i][n1]-tri[i][j],tri[i][n2]-tri[i][j])+EPS<0){\n\t    swap(rect[i][0],rect[i][1]); break;\n\t  }\n\t}\n      }\n\n      P ver = (D)d*unit(norm(rect[i][0]-rect[i][1]).sc);\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n      rect[i] = convex_hull(rect[i]);\n    }\n\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      rep(j,n){\n\tif(i==j)continue;\n\n\tbool f = false;\n\trep(k,3)\n\t  if(inter_pos(rect[i],tri[j][k],abs(rect[i][0]-rect[i][1])*d)){\n\t    f = true; break;\n\t  }\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3)if(seg_p_dis(rseg,tri[j][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,3){\n\t    L tseg = L(tri[j][k],rect[j][(k+1)%3]);\n\t    rep(l,4)if(seg_p_dis(tseg,rect[i][l])<AD+EPS){\n\t      f = true; break;\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(!f){\n\t  rep(k,4){\n\t    L rseg = L(rect[i][k],rect[i][(k+1)%4]);\n\t    rep(l,3){\n\t      L tseg = L(tri[j][l],tri[j][(l+1)%3]);\n\t      if(is_cp(rseg,tseg)){\n\t\tf = true; break;\n\t      }\n\t    }\n\t    if(f)break;\n\t  }\n\t}\n\n\tif(f){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n\n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    cout << res << endl;\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<-eps ) && //-EPS\n        ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <-eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble eps=1e-1;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nint V;\nvector<vector<int> > G,rG;\nvector<int> vs;\nbool used[100];\nint cmp[100];\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    if(!used[G[v][i]]){\n      dfs(G[v][i]);\n    }\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++){\n    if(!used[rG[v][i]]){\n      rdfs(rG[v][i],k);\n    }\n  }\n}\n\nint main(){\n  for(int n,d;cin>>n>>d,n;){\n    P p[100][3];\n    P r[100][4];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<3;j++){\n\tdouble x,y;\n\tcin>>x>>y;\n\tp[i][j]=P(x,y);\n      }\n      if(cross(p[i][1]-p[i][0],p[i][2]-p[i][0])<0){\n\treverse(p[i],p[i+1]);\n      }\n      double l[3];\n      for(int j=0;j<3;j++){\n\tl[j]=abs(p[i][j]-p[i][(j+1)%3]);\n      }\n      while(fabs(l[1]-l[2])>eps){\n\trotate(p[i],p[i]+1,p[i+1]);\n\trotate(l,l+1,l+3);\n      }\n      r[i][0]=p[i][0];\n      r[i][1]=p[i][1];\n      r[i][2]=p[i][1]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n      r[i][3]=p[i][0]+polar(d*1.,arg((p[i][1]-p[i][0])*P(0,1)));\n    }\n    G=rG=vector<vector<int> >(n);\n    vs.clear();\n    bool e[100][100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i!=j){\n\t  for(int k=0;k<3;k++){\n\t    bool f=false;\n\t    for(int l=0;l<4;l++){\n\t      P l1=r[i][(l+1)%4]-r[i][l];\n\t      P l2=p[j][(k+1)%3]-p[j][k];\n\t      f|=cross(l1,p[j][k]-r[i][l])<-eps;\n\t      e[i][j]|=cross(p[j][(k+1)%3]-r[i][l],l1)*cross(p[j][k]-r[i][l],l1)<eps&&cross(r[i][(l+1)%4]-p[j][k],l2)*cross(r[i][l]-p[j][k],l2)<eps;\n\t    }\n\t    e[i][j]|=!f;\n\t    if(e[i][j]){\n\t      G[i].push_back(j);\n\t      rG[j].push_back(i);\n\t    }\n\t  }\n\t}\n      }\n    }\n    V=n;\n    fill(begin(used),end(used),false);\n    for(int v=0;v<V;v++){\n      if(!used[v]){\n\tdfs(v);\n      }\n    }\n    fill(begin(used),end(used),false);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]]){\n\trdfs(vs[i],k++);\n      }\n    }\n    bool in[100]={};\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(e[i][j]&&cmp[i]!=cmp[j]){\n\t  in[cmp[j]]=true;\n\t}\n      }\n    }\n    cout<<count(in,in+k,false)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<stack>\n#include<complex>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nconst double EPS = 0.1;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > EPS)   return +1;       // counter clockwise\n  if (cross(b, c) < -EPS)   return -1;       // clockwise\n  if (dot(b, c) < -EPS)     return +2;       // c--a--b on line\n  if (norm(b)+EPS < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)+EPS) swap(a, b);\n    if (imag(a) < EPS && EPS < imag(b))\n      if (cross(a, b) < -EPS) in = !in;\n    if (abs(cross(a, b)) < EPS && dot(a, b) < -EPS) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool intersectSS(const L &s, const L &t) {\n\t\n\trep(i,2)rep(j,2)if(abs(abs(s[i]-t[i]))<EPS)return 1;\n\t\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) < 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) < 0;\n}\nbool intersect(G &rect, G &tri){\n\trep(i,3)if(contains(rect,tri[i]))return 1;\n\trep(i,4)if(contains(tri,rect[i]))return 1;\n\trep(i,3){\n\t\tL l(tri[i],tri[(i+1)%3]);\n\t\trep(j,4)if(intersectSS(l,L(rect[i],rect[(i+1)%4])))return 1;\n\t}\n\treturn 0;\n}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight=0) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid visit(const Graph &g, int v, vector< vector<int> >& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  fr(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const Graph& g,\n    vector< vector<int> >& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint main(){\n\tint n;\n\tdouble d;\n\twhile(cin>>n>>d,n){\n\t\tvector<G> tri;\n\t\trep(i,n){\n\t\t\tdouble a,b,c,d,e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tG p; p.pb(P(a,b)); p.pb(P(c,d)); p.pb(P(e,f));\n\t\t\tif(abs(p[2]-p[0])!=abs(p[2]-p[1])){\n\t\t\t\tif(abs(p[2]-p[0])==abs(p[1]-p[0]))swap(p[2],p[0]);\n\t\t\t\telse swap(p[1],p[0]);\n\t\t\t}\n\t\t\tif(ccw(p[0],p[1],p[2])<0)swap(p[0],p[1]);\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\tGraph e(n);\n\t\t\n\t\trep(i,n)rep(j,n)if(i!=j){\n\t\t\t\n\t\t\tG &p=tri[i];\n\t\t\tP m=(p[0]+p[1])*0.5,dir=(p[2]-m)*(d/abs(p[2]-m));\n\t\t\t\n\t\t\tG rect;\n\t\t\trect.pb(p[0]); rect.pb(p[1]);\n\t\t\trect.pb(p[1]+dir); rect.pb(p[0]+dir);\n\t\t\tif(ccw(rect[0],rect[1],rect[2])<0)reverse(rect.begin(),rect.end());\n\t\t\t\n\t\t\tif(intersect(rect,tri[j]))e[i].pb(Edge(i,j));\n\t\t}\n\t\t\n\t\tvector<vector<int> > scc;\n\t\tstronglyConnectedComponents(e,scc);\n\t\tint m=scc.size(),to[100],in[100]={0},ans=0;\n\t\trep(i,m)fr(j,scc[i])to[*j]=i;\n\t\trep(i,n)fr(j,e[i])if(to[i]!=to[j->dst])\n\t\tin[to[j->dst]]++;\n\t\t\n\t\trep(i,m)if(in[i]==0)ans++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<unordered_map>\n#define eps 1e-9\nusing namespace std;\n\ntypedef complex<double> point;\ntypedef pair<point, point> pp;\n\n//??????\ndouble dot(point a, point b){\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\n//??????\ndouble cross(point a, point b){\n  return imag(conj(a) * b);\n}\n\n//counter clock wise\nint ccw(point a, point b, point c){\n  if(cross(b - a, c - a) >  eps)return  1;//??????ab????????´\n  if(cross(b - a, c - a) < -eps)return -1;//??????ab????????´\n  if(dot(b - a, c - a) < -eps)return 2;//??´???ab??????a???????????????\n  if(abs(b - a) + eps < abs(c - a))return -2;//??´???ab??????b???????????????\n  return 0;//??´???ab???\n}\ntypedef struct door{\n  double r;\n  point x, y, z, a, b;\n  point rot(point p, double theta){\n    return point(p.real()*cos(theta) +\n                 p.imag()*sin(theta),\n                 -p.real()*sin(theta) +\n                 p.imag()*cos(theta));\n  }\n  void rectangle(){\n    point p = y - x;\n    if(ccw(x, y, z) == -1){\n      p = rot(p, M_PI/2.0);\n    }else if(ccw(x, y, z) == 1){\n      p = rot(p, -M_PI/2.0);\n    }\n    p *= r/abs(p);\n    a = y;\n    b = x + p;\n  }\n}door;\n\nbool isCover(door from, door to){\n  point p[4];\n  p[0] = from.x;\n  p[1] = from.y;\n  p[2] = from.y + (from.b - from.x);\n  p[3] = from.b;\n\n  int f = ccw(p[0], p[1], to.x);\n  bool flag = true;\n  for (int i = 1; i < 4; i++) {\n    if(ccw(p[i], p[(i + 1)%4], to.x) != f and\n       ccw(p[i], p[(i + 1)%4], to.x) != 0)\n      flag = false;\n  }\n  if(flag)return true;\n  f = ccw(p[0], p[1], to.y);\n  for (int i = 1; i < 4; i++) {\n    if(ccw(p[i], p[(i + 1)%4], to.y) != f and\n       ccw(p[i], p[(i + 1)%4], to.y) != 0)\n      return false;\n  }\n  return true;\n}\n\nvoid dfs(vector<vector<int> > &g,\n         vector<int> &vs, int v, bool* used){\n  used[v] = true;\n  for (int i = 0; i < g[v].size(); i++) {\n    if(not used[g[v][i]])dfs(g, vs, g[v][i], used);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(vector<vector<int> > &rg,\n          vector<int> &cmp, int v, int k, bool* used){\n  used[v] = true;\n  cmp[v] = k;\n  for (int i = 0; i < rg[v].size(); i++) {\n    if(not used[rg[v][i]])\n      rdfs(rg, cmp, rg[v][i], k, used);\n  }\n}\n\nvector<vector<int> > scc(vector<vector<int> > &g,\n                         vector<vector<int> > &rg){\n  bool used[g.size()];\n  memset(used, false, sizeof(used));\n  vector<int> vs, cmp(g.size(), -1);\n  for (int i = 0; i < g.size(); i++) {\n    if(not used[i])dfs(g, vs, i, used);\n  }\n  memset(used, false, sizeof(used));\n  int k = 0;\n  for (int i = vs.size() -  1; i >= 0; i--) {\n    if(not used[vs[i]]) rdfs(rg, cmp, vs[i], k++, used);\n  }\n  unordered_map<int, int> hash;\n  for (int i = 0; i < cmp.size(); i++) {\n    hash[i] = cmp[i];\n  }\n  vector<vector<int> > res(hash.size());\n  for (int i = 0; i < g.size(); i++) {\n    for (int j = 0; j < g[i].size(); j++) {\n      res[hash[g[i][j]]].push_back(hash[i]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n, r;\n  while(std::cin >> n >> r, n){\n    door d[n];\n    for (int i = 0; i < n; i++) {\n      int a, b;\n      std::cin >> a >> b;\n      d[i].x = point(a, b);\n    \n      std::cin >> a >> b;\n      d[i].y = point(a, b);\n    \n      std::cin >> a >> b;\n      d[i].z = point(a, b);\n      d[i].r = r;\n      d[i].rectangle();\n    }\n    vector<vector<int> > g(n), rg(n);\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if(isCover(d[i], d[j])){\n          g[i].push_back(j);\n        }\n      }\n    }\n    // for (int i = 0; i < g.size(); i++) {\n    //   std::cout << \"g[\" << i << \"]:\" << std::endl;\n    //   for (int j = 0; j < g[i].size(); j++) {\n    //     std::cout << g[i][j] << std::endl;\n    //   }\n    // }\n    for (int i = 0; i < g.size(); i++) {\n      for (int j = 0; j < g[i].size(); j++) {\n        rg[g[i][j]].push_back(i);\n      }\n    }\n    vector<vector<int> > dag = scc(g, rg);\n    int ans = 0;\n    for (int i = 0; i < dag.size(); i++) {\n      if(dag[i].size() == 0)ans++;\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass UnionFindTree\n{\n    vector<int> parent; // em[h\n    vector<int> rank;   // ØÌ³ÌãÀ\n    int find(int x){\n        if(parent[x] == x)\n            return x;\n        return parent[x] = find(parent[x]);\n    }\npublic:\n    UnionFindTree(int n){ // RXgN^\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        rank.assign(n, 0);\n    }\n    void unite(int x, int y){ // xÆyÌO[vð¹\n        if((x = find(x)) != (y = find(y))){\n            if(rank[x] < rank[y])\n                parent[x] = y;\n            else{\n                parent[y] = x;\n                if(rank[x] == rank[y])\n                    ++ rank[x];\n            }\n        }\n    }\n    bool same(int x, int y){ // xÆyÌO[vª¯¶©ð²×é\n        return find(x) == find(y);\n    }\n    int num(){ // O[vÌðÔ·\n        vector<bool> root(parent.size(), false);\n        for(unsigned i=0; i<parent.size(); ++i)\n            root[find(i)] = true;\n        return count(root.begin(), root.end(), true);\n    }\n};\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\nbool convexContain(const vector<Point>& cp, const Point& p)\n{\n    int n = cp.size();\n    bool ret1 = true;\n    bool ret2 = true;\n    for(int i=0; i<n; ++i){\n        double a = (cp[(i+1)%n] - cp[i]).cross(p - cp[i]);\n        if(a < -EPS)\n            ret1 = false;\n        if(a > EPS)\n            ret2 = false;\n    }\n    return ret1 || ret2;\n}\n\ndouble segmentPointDist(const Point& a1, const Point& a2, const Point& p)\n{\n    if((a2-a1).dot(p-a1) < 0){\n        return a1.dist(p);\n    }else if((a1-a2).dot(p-a2) < 0){\n        return a2.dist(p);\n    }else{\n        return abs((a2-a1).cross(p-a1)) / a1.dist(a2);\n    }\n}\n\ndouble segmentsDist(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(min(a1.x, a2.x) > max(b1.x, b2.x) || min(b1.x, b2.x) > max(a1.x, a2.x) || min(a1.y, a2.y) > max(b1.y, b2.y) || min(b1.y, b2.y) > max(a1.y, a2.y))\n        return 0.0;\n\n    double ret = segmentPointDist(a1, a2, b1);\n    ret = min(ret, segmentPointDist(a1, a2, b2));\n    ret = min(ret, segmentPointDist(b1, b2, a1));\n    ret = min(ret, segmentPointDist(b1, b2, a2));\n    return ret;\n}\n\nbool polygonsCollide(const vector<Point>& cp1, const vector<Point>& cp2)\n{\n    int n = cp1.size();\n    int m = cp2.size();\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<m; ++j){\n            if(segmentsDist(cp1[i], cp1[(i+1)%n], cp2[j], cp2[(j+1)%m]) < 0.01 + EPS)\n                return true;\n        }\n    }\n\n    return convexContain(cp1, cp2[0]) || convexContain(cp2, cp1[0]);\n}\n\nint main()\n{\n    for(;;){\n        int n, d;\n        cin >> n >> d;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Point> > p(n, vector<Point>(3));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<3; ++j){\n                cin >> p[i][j].x >> p[i][j].y;\n            }\n            if(p[i][0].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][1], p[i][2]);\n            if(p[i][1].dist(p[i][2]) > p[i][0].dist(p[i][1]))\n                swap(p[i][0], p[i][2]);\n        }\n\n        vector<vector<Point> > rect(n, vector<Point>(4));\n        for(int i=0; i<n; ++i){\n\n        }\n\n        UnionFindTree uft(n);\n        vector<bool> check(n, false);\n        for(int i=0; i<n; ++i){\n            Point v = p[i][0] - p[i][1];\n            v = v / v.length() * d;\n            swap(v.y, v.x);\n            v.y *= -1;\n\n            vector<Point> p1(4);\n            p1[0] = p[i][0];\n            p1[1] = p[i][0] + v;\n            p1[2] = p[i][1] + v;\n            p1[3] = p[i][1];\n            if(!convexContain(p1, p[i][2])){\n                p1[1] = p[i][0] - v;\n                p1[2] = p[i][1] - v;\n            }\n\n            for(int j=0; j<n; ++j){\n                if(j == i)\n                    continue;\n                if(polygonsCollide(p1, p[j])){\n                    uft.unite(i, j);\n                    check[j] = true;\n                }\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            if(!check[i])\n                ++ ret;\n            else{\n                bool b = true;\n                for(int j=0; j<n; ++j){\n                    if(uft.same(i, j) && !check[j])\n                        b = false;\n                }\n                if(b)\n                    ++ ret;\n                check[i] = false;\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,edge[i].size()){\n      int you=component[edge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-5;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < 1e-10){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      break;\n    }\n  }while(next_permutation(in,in+3));\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[i].pb(j);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    /*\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define x() real()\n#define y() imag()\n#define EPS (1e-1)\n#define INF (1e12)\n#define SQ(a) ((a) * (a))\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define EQV(a, b) (EQ((a).x(), (b).x()) && EQ((a).y(), (b).y()))\n\nenum {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0\n};\nenum {OUT, ON, IN};\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef P V;\nnamespace std {\n\tbool operator < (const P &a, const P &b){\n\t\tif (a.x() != b.x()) return a.x() < b.x();\n\t\treturn a.y() < b.y();\n\t}\n}\nstruct S{\n\tP p1, p2;\n\tS(){}\n\tS(P p1, P p2): p1(p1), p2(p2){}\n};\ntypedef S L;\ntypedef S PP;\nstruct C{\n\tP p;\n\tD r;\n\tC(){}\n\tC(P p, D r): p(p), r(r){}\n};\ntypedef vector<P> G;\nstruct Edge {\n\tint to;\n\tD cost;\n\tEdge(){}\n\tEdge(int to, D cost = 0.0): to(to), cost(cost){}\n\tbool operator < (const Edge &t) const {\n\t\treturn cost > t.cost;\n\t}\n};\ntypedef vector<vector<Edge> > Graph;\n\ninline D inD(){\n\tD d;\n\tscanf(\"%lf\", &d);\n\treturn d;\n}\ninline P inP(){\n\tD x = inD(), y = inD();\n\treturn P(x, y);\n}\ninline S inS(){\n\tP p1(inP());\n\tP p2(inP());\n\treturn S(p1, p2);\n}\ninline C inC(){\n\tP p(inP());\n\tD r(inD());\n\treturn C(p, r);\n}\n\nD norm(P a){\n\treturn SQ(a.x()) * SQ(a.y());\n}\nD dot(P a, P b){\n\treturn (conj(a) * b).x();\n}\nD cross(P a, P b){\n\treturn (conj(a) * b).y();\n}\nbool orthogonal(L a, L b){\n\treturn EQ( dot(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool parallel(L a, L b){\n\treturn EQ( cross(a.p1 - a.p2, b.p1 - b.p2), 0.0 );\n}\nbool PonL(L l, P p){\n\treturn EQ( cross(l.p1 - l.p2, p - l.p2), 0.0 );\n}\nbool PonS(S s, P p){\n\treturn EQ( cross(s.p1 - s.p2, p - s.p2), 0.0 ) &&\n\t\t(dot(s.p1 - s.p2, p - s.p2) > -EPS) &&\n\t\t(dot(s.p2 - s.p1, p - s.p1) > -EPS);\n}\nP project(S s, P p){\n\tV base = s.p2 - s.p1;\n\tD r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\nP reflect(S s, P p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\nint ccw(P p0, P p1, P p2){\n\tP a = p1 - p0;\n\tP b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\nbool intersectLL(L l1, L l2){\n\treturn !parallel(l1, l2) ||\n\t\tabs( cross(l1.p1 - l1.p2, l2.p1 - l2.p2) ) < EPS;\n}\nbool intersectLS(L l, S s){\n\treturn cross(l.p2 - l.p1, s.p1) * cross(l.p2 - l.p1, s.p2) < EPS;\n}\nbool intersectSS(S s1, S s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\nbool intersectCC(C c1, C c2){\n\treturn abs(c1.p - c1.p) - (c1.r + c2.r) < EPS;\n}\nD distanceLP(L l, P p){\n\treturn abs( cross(l.p2 - l.p1, p - l.p1) ) / abs(l.p2 - l.p1);\n}\nD distanceLL(L l1, L l2){\n\treturn intersectLL(l1, l2) ? 0 : distanceLP(l1, l2.p1);\n}\nD distanceLS(L l, S s){\n\treturn intersectLS(l, s) ? \n\t\t0 :\n\t\tmin(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\nD distanceSP(S s, P p){\n\tP pr = project(s, p);\n\tif (PonS(s, pr)) return abs(pr - p);\n\treturn min( abs(s.p1 - p), abs(s.p2 - p) );\n}\nD distanceSS(S s1, S s2){\n\tif (intersectSS(s1, s2)) return 0;\n\treturn min(\n\t\tmin(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tmin(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n/*\nbool intersect(G g1, G g2){\n\tfor (int i = 0; i < g1.size(); i++){\n\t\tfor (int j = 0; j < g2.size(); j++){\n\t\t\tS s1(g1[i], g1[(i + 1) % g1.size()]);\n\t\t\tS s2(g2[j], g2[(j + 1) % g2.size()]);\n\t\t\tif (intersect(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool intersect(G g, S s){\n\tfor (int i = 0; i < g.size(); i++){\n\t\tS s0(g[i], g[(i + 1) % g.size()]);\n\t\tif (intersect(s, s0)) return true;\n\t}\n\treturn false;\n}\n*/\n\nP crossP(S s1, S s2){\n\tassert(intersectSS(s1, s2));\n\tP base = s2.p2 - s2.p1;\n\tD d1 = abs(cross(base, s1.p1 - s2.p1));\n\tD d2 = abs(cross(base, s1.p2 - s2.p1));\n\tD t = d1 / (d1 + d2);\n\t\n\t/*if (isnan(t)){\n\t\t//printf(\"%f %f %f %f %f %f %f %f\\n\", s1.p1.x(), s1.p1.y(), s1.p2.x(), s1.p2.y(), s2.p1.x(), s2.p1.y(), s2.p2.x(), s2.p2.y());\n\t\tif (EQV(s1.p1, s2.p1)) return s1.p1;\n\t\tif (EQV(s1.p1, s2.p2)) return s1.p1;\n\t\tif (EQV(s1.p2, s2.p1)) return s1.p2;\n\t\tif (EQV(s1.p2, s2.p2)) return s1.p2;\n\t}*/\n\t\n\tP p = s1.p1 + (s1.p2 - s1.p1) * t;\n\t//assert(!isnan(p.x()));\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPP crossPP(C c, L l){\n\tP pr = project(l, c.p);\n\tP e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tD base = sqrt( SQ(c.r) - norm(pr - c.p) );\n\treturn PP(pr + e * base, pr - e * base);\n}\nPP crossPP(C c1, C c2){\n\tD d = abs(c1.p - c2.p);\n\tD a = acos( SQ(c1.r) + SQ(d) - SQ(c2.r) ) / (2 * c2.r * d);\n\tD t = arg(c2.p - c1.p);\n\treturn PP( c1.p + polar(c1.r, t + a), c1.p + polar(c1.r, t - a) );\n}\n\nint contains(G &g, P p){\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++){\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.y() > b.y()) swap(a, b);\n\t\tif (a.y() < EPS && EPS < b.y() && cross(a, b) > EPS) x != x;\n\t}\n\treturn x ? IN : OUT;\n}\n\n\nint n, d;\nG tri[100];\nG rect[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\n\nvector<int> vs;\nbool used[100];\nint cmp[100];\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to);\n\t}\n\tvs.push_back(v);\n}\nvoid rdfs(int v, int k)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k);\n\t}\n}\nint scc()\n{\n\tvs.clear();\n\tfill_n(used, 100, false);\n\tfor (int v = 0; v < n; v++){\n\t\tif (!used[v]) dfs(v);\n\t}\n\tfill_n(used, 100, false);\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++);\n\t}\n\treturn k;\n}\nvoid topoSort(vector<vector<int>>& graph, int v, vector<int> &tps)\n{\n\tused[v] = true;\n\tfor (auto to : graph[v]){\n\t\tif (!used[to]) topoSort(graph, to, tps);\n\t}\n\ttps.push_back(v);\n}\n\nbool intersects(G &a, G &b)\n{\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < b.size(); j++){\n\t\t\tS sa = S(a[i], a[(i + 1) % a.size()]);\n\t\t\tS sb = S(b[j], b[(j + 1) % b.size()]);\n\t\t\tif (intersectSS(sa, sb)) return true;\n\t\t}\n\t}\n\tfor (int i = 0; i < a.size(); i++){\n\t\tif (contains(b, a[i])) return true;\n\t}\n\tfor (int i = 0; i < b.size(); i++){\n\t\tif (contains(a, b[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tP &a = t[j];\n\t\t\tP &b = t[(j + 1) % 3];\n\t\t\tP &c = t[(j + 2) % 3];\n\t\t\t\n\t\t\t// ?????? = t[0] -> t[1]\n\t\t\t// ?????? = t[2]\n\t\t\tif (EQ(abs(b - a), abs(c - a))){\n\t\t\t\tswap(t[2], a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ????????¢?????????\n\tfor (int i = 0; i < n; i++){\n\t\tG &t = tri[i];\n\t\tG &r = rect[i];\n\t\t\n\t\tP v = t[1] - t[0];\n\t\tP v1 = v * P(0, 1) / abs(v) * (D)d;\n\t\tP v2 = v * P(0, -1) / abs(v) * (D)d;\n\t\tif (dot(t[2] - t[0], v2) > 0) v1 = v2;\n\t\tr.resize(4);\n\t\tr[0] = t[0];\n\t\tr[1] = t[1];\n\t\tr[2] = t[1] + v1;\n\t\tr[3] = t[0] + v1;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersects(rect[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint V = scc();\n\tvector<vector<int>> sccgraph(V);\n\tvector<vector<int>> rsccgraph(V);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tsccgraph[cmp[i]].push_back(cmp[to]);\n\t\t\trsccgraph[cmp[to]].push_back(cmp[i]);\n\t\t}\n\t}\n\t\n\tvector<int> tps;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) topoSort(rsccgraph, i, tps);\n\t}\n\t\n\tint res = 0;\n\tfill_n(used, 100, false);\n\tfor (int i = 0; i < V; i++){\n\t\tif (!used[i]) res++;\n\t\tfor (int to : sccgraph[i]){\n\t\t\tused[to] = true;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &d), n){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\ttri[i].clear();\n\t\t\trect[i].clear();\n\t\t\tgraph[i].clear();\n\t\t\trgraph[i].clear();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\ttri[i].push_back(inP());\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nstruct coor {\n\tdouble x, y;\n};\nstruct tri {\n\tcoor p[3];\n\tcoor rec[4];\n};\n\nint n, d;\nvector<tri> v;\nvector<vector<int> > edge;\n\nconst double EPS = 1e-9;\nconst double ERR = 1e-2;\n\ntemplate<class T>\nT sqr(T x) {\n\treturn x * x;\n}\n\ndouble dist(coor a, coor b) {\n\treturn sqrt(sqr(a.x-b.x) + sqr(a.y-b.y));\n}\n\ndouble dist_lp(coor c, coor a, coor b) {\n\tcoor v0, v1;\n\tv0.x = b.x - a.x; v0.y = b.y - a.y;\n\tv1.x = c.x - a.x; v1.y = c.y - a.y;\n\n\tif(sqr(dist(a,b)) + sqr(dist(a,c)) - sqr(dist(c,b)) > 0\n\t\t\t&& sqr(dist(a,b)) + sqr(dist(b,c)) - sqr(dist(c,a)) > 0) {\n\t\tdouble cross;\n\t\tcross = fabs(v0.x * v1.y - v0.y * v1.x);\n\t\treturn cross / dist(a,b);\n\t}\n\n\treturn min(dist(a,c), dist(b,c));\n}\n\nbool in_poly(coor p, coor poly[], int sz) {\n\tdouble sign = +0.0;\n\tfor(int i = 0; i < sz; i++) {\n\t\tcoor v0, v1;\n\t\tv0.x = poly[i].x - p.x; v0.y = poly[i].y - p.y;\n\t\tv1.x = poly[(i+1)%sz].x - p.x; v1.y = poly[(i+1)%sz].y - p.y;;\n\n\t\tif(i != 0 && sign * (v0.x * v1.y - v0.y * v1.x) < EPS*EPS) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tsign = (v0.x * v1.y - v0.y * v1.x);\n\n\t\tif(i == sz-1) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < sz; i++) {\n\t\tif(dist_lp(p,poly[i], poly[(i+1)%sz]) <= ERR + EPS) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool seg_cross(coor a, coor b, coor c, coor d) {\n\tcoor v0, v1, v2;\n\t\n\tv0.x = a.x - c.x; v0.y = a.y - c.y;\n\tv1.x = b.x - c.x; v1.y = b.y - c.y;\n\tv2.x = d.x - c.x; v2.y = d.y - c.y;\n\n\tdouble s, t;\n\ts = (v0.x * v2.y - v0.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\tt = - (v1.x * v2.y - v1.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\n\tif(s + t > 1-EPS && s > -EPS && t > -EPS) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool exist_edge(tri from, tri to) {\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(in_poly(to.p[i], from.rec, 4)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(in_poly(from.rec[i], to.p, 3)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 3; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tif(seg_cross(to.p[i], to.p[(i+1)%3], from.rec[j], from.rec[(j+1)%4])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool visited[128];\nbool touch[128];\nbool path[128];\n\nvoid check(int i, int s) {\n\tif(i != s && touch[i])\n\t\ttouch[i] = false;\n\tif(path[i])\n\t\treturn;\n\tvisited[i] = true;\n\tpath[i] = true;\n\tfor(int j = 0; j < (int)edge[i].size(); j++) {\n\t\tcheck(edge[i][j], s);\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> d, n || d) {\n\t\tv.clear();\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tvisited[i] = touch[i] = path[i] = false;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttri in;\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tcoor c;\n\t\t\t\tcin >> c.x >> c.y;\n\t\t\t\tin.p[j] = c;\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tif(fabs(dist(in.p[(0+j)%3],in.p[(1+j)%3]) - dist(in.p[(1+j)%3], in.p[(2+j)%3])) < EPS) {\n\t\t\t\t\tswap(in.p[(1+j)%3], in.p[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcoor add;\n\t\t\tadd.x =\t(in.p[1].x - in.p[0].x) + (in.p[1].x - in.p[2].x);\n\t\t\tadd.y = (in.p[1].y - in.p[0].y) + (in.p[1].y - in.p[2].y);\n\n\t\t\tdouble addlen;\n\t\t\taddlen = sqrt(sqr(add.x) + sqr(add.y));\n\t\t\tadd.x = add.x * d / addlen;\n\t\t\tadd.y = add.y * d / addlen;\n\n\t\t\tin.rec[0].x = in.p[0].x; in.rec[0].y = in.p[0].y;\n\t\t\tin.rec[1].x = in.p[2].x; in.rec[1].y = in.p[2].y;\n\t\t\tin.rec[2].x = in.p[2].x + add.x; in.rec[2].y = in.p[2].y + add.y;\n\t\t\tin.rec[3].x = in.p[0].x + add.x; in.rec[3].y = in.p[0].y + add.y;\n\n\t\t\tv.push_back(in);\n\t\t}\n\n\t\tfor(int i = 0; i < (int)v.size(); i++) {\n\t\t\tfor(int j = 0; j < (int)v.size(); j++) {\n\t\t\t\tif(i != j) {\n\t\t\t\t\tif(exist_edge(v[i], v[j])) {\n\t\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\ttouch[i] = true;\n\t\t\t\tcheck(i, i);\n\t\t\t}\n\t\t\tfor(int j = 0; j < 128; j++) {\n\t\t\t\tpath[j] = false;\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(touch[i])\n\t\t\t\tres++;\n\t\t}\n\t\tcout <<  res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,postorder[i].order);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-9;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n\tcross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<-eps ) && //-EPS\n\t( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <-eps))return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in);\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-5;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n    break;\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-3;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nint g[110][110];\nPt p[110][3];\nint UF[110];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[i][i]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble ax,bx,cx,ay,by,cy;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n\t\t\tdouble A=(bx-cx)*(bx-cx)+(by-cy)*(by-cy);\n\t\t\tdouble B=(ax-cx)*(ax-cx)+(ay-cy)*(ay-cy);\n\t\t\tdouble C=(ax-bx)*(ax-bx)+(ay-by)*(ay-by);\n\t\t\tif(ABS(A-B)<EPS){\n\t\t\t\tp[i][0]=Pt(ax,ay);p[i][1]=Pt(bx,by);p[i][2]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(B-C)<EPS){\n\t\t\t\tp[i][2]=Pt(ax,ay);p[i][0]=Pt(bx,by);p[i][1]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(C-A)<EPS){\n\t\t\t\tp[i][1]=Pt(ax,ay);p[i][2]=Pt(bx,by);p[i][0]=Pt(cx,cy);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)if(iSP(p[i][0],p[i][2],p[i][1])==-1)swap(p[i][0],p[i][1]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tif(i==j)continue;\n\t\t\tPt t[4];\n\t\t\tt[0]=p[i][0];\n\t\t\tt[1]=p[i][1];\n\t\t\tt[3]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[3]=t[0]+t[3]/t[3].ABS()*(double)b;\n\t\t\tt[2]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[2]=t[1]+t[2]/t[2].ABS()*(double)b;\n\t\t\n\t\t\tbool ok=false;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tbool L=false;\n\t\t\t\tbool R=false;\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][k]+(p[j][(k+1)%3]-p[j][k])*1000000.0))L=true;\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][(k+1)%3],p[j][(k+1)%3]+(p[j][k]-p[j][(k+1)%3])*1000000.0))R=true;\n\t\t\t\t}\n\t\t\t\tif(L&&R)ok=true;\n\t\t\t}\n\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\tbool L=false;\n\t\t\t\tbool R=false;\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tif(iSS(t[l],t[l]+(t[(l+1)%4]-t[l])*1000000.0,p[j][k],p[j][(k+1)%3]))L=true;\n\t\t\t\t\tif(iSS(t[(l+1)%4],t[(l+1)%4]+(t[l]-t[(l+1)%4])*1000000.0,p[j][k],p[j][(k+1)%3]))R=true;\n\t\t\t\t}\n\t\t\t\tif(L&&R)ok=true;\n\t\t\t}\n\t\t\t\n\t\t\tif(ok){\n\t\t\t\tg[i][j]=1;\n\t\t//\t\tprintf(\"%d %d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]|=g[i][k]&g[k][j];\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)if(g[i][j]&&g[j][i])UNION(i,j);\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(FIND(i)!=FIND(j)&&g[j][i])ok=false;\n\t\t\t}\n\t\t\tif(ok)ret++;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-8;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tif (contains(g, h[0])) return true;\n\tif (contains(h, g[0])) return true;\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc()\n{\n\tvector<int> vs;\n\tvector<bool> used(n);\n\tvector<int> cmp(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(abs(b - a), abs(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int>> sccgraph = scc();\n\t\n\tvector<int> indeg(sccgraph.size());\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0) res++;\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\n#define MAX_N (128)\n#define EPS (0.01)\n#define SQ(X) ((X) * (X))\n\nusing namespace std;\n\nclass Triangle {\n\tpublic:\n        double x[3], y[3];\n\t    int no;\n};\n\nclass Point {\n    public:\n    \tdouble x, y;\n        \n\t    Point operator - (Point &a){\n            Point ret;\n\t\t    ret.x = x - a.x;\n\t\t    ret.y = y - a.y;\n\t\t    return (ret);\n\t    }\n};\n\nvector<int> G[MAX_N];\nvector<int> rG[MAX_N];\nvector<int> compress[MAX_N];\nvector<int> vs;\nbool used[MAX_N];\nbool group[MAX_N];\nint cmp[MAX_N];\nint N;\n\nvoid addEdge(int from, int to)\n{\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v)\n{\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++){\n        if (!used[G[v][i]]){\n            dfs(G[v][i]);\n        }\n    }\n    vs.push_back(v);\n}\n\nvoid revDfs(int v, int k)\n{\n    used[v] = true;\n    cmp[v] = k;\n    for (int i = 0; i < rG[v].size(); i++){\n        if (!used[rG[v][i]]){\n            revDfs(rG[v][i], k);\n        }\n    }\n}\n\nint scc()\n{\n    int ret;\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    \n    for (int i = 0; i < N; i++){\n        if (!used[i]){\n            dfs(i);\n        }\n    }\n    \n    memset(used, 0, sizeof(used));\n    \n    ret = 0;\n    for (int i = vs.size() - 1; i >= 0; i--){\n        if (!used[vs[i]]){\n            revDfs(vs[i], ret++);\n        }\n    }\n    \n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < G[i].size(); j++){\n            if (cmp[i] != cmp[G[i][j]]){\n                compress[cmp[G[i][j]]].push_back(cmp[i]);\n            }\n        }\n    }\n    \n    return (ret);\n}\n\ndouble inProduct(Point a, Point b)\n{\n\treturn (a.x * b.x + a.y * b.y);\n}\n\ndouble getSize(Point a)\n{\n\treturn (sqrt(SQ(a.x) + SQ(a.y)));\n}\n\nbool checkCross(Point p1, Point p2, Point p3, Point p4)\n{\n    double check1 = (p2.x - p1.x) * (p4.y - p3.y) - (p2.y - p1.y) * (p4.x - p3.x);\n    \n    Point pq = p3 - p1;\n    \n    double check2 = (p4.y - p3.y) * pq.x - (p4.x - p3.x) * pq.y;\n    double check3 = (p2.y - p1.y) * pq.x - (p2.x - p1.x) * pq.y;\n    \n    \n    if (check1 > EPS){\n        return (0 <= check3 / check1 && check3 / check1 <= 1 && 0 <= check2 / check1 && check2 / check1 <= 1);\n    }\n    \n    return (fabs(check2) <= EPS && fabs(check3) <= EPS);\n}\n\nvoid judgeAdj(Triangle a, Triangle b, double dist)\n{\n\tdouble len;\n\tPoint p[4];\n\t\n\tlen = 0.0;\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = i + 1; j < 3; j++){\n\t\t\tif (len < SQ(a.x[i] - a.x[j]) + SQ(a.y[i] - a.y[j])){\n\t\t\t\tlen = SQ(a.x[i] - a.x[j]) + SQ(a.y[i] - a.y[j]);\n\t\t\t\tp[0].x = a.x[i], p[0].y = a.y[i];\n\t\t\t\tp[1].x = a.x[j], p[1].y = a.y[j];\n\t\t\t}\n\t\t}\n\t}\n    //printf(\"%lf %lf %lf %lf\\n\", p[0].x, p[0].y, p[1].x, p[1].y);\n\tPoint e, sa;\n\t\n    e.x = 0, e.y = 1;\n\tsa = p[0] - p[1];\n\tdouble theta = acos(inProduct(e, sa) / (getSize(e) * getSize(sa)));\n    theta = min(theta, M_PI - theta);\n\t//printf(\"theta = %lf\\n\", theta);\n    \n\tp[2].x = p[0].x + dist * cos(theta), p[2].y = p[0].y + dist * sin(theta);\n\tp[3].x = p[1].x + dist * cos(theta), p[3].y = p[1].y + dist * sin(theta);\n\t\n\tbool cross = false;\n\t\n\tfor (int i = 0; i < 3; i++){\n\t\tfor (int j = i + 1; j < 3; j++){\n            Point k[2];\n            k[0].x = b.x[i], k[0].y = b.y[i];\n            k[1].x = b.x[j], k[1].y = b.y[j];\n\t\t\tcross |= checkCross(k[0], k[1], p[0], p[1]);\n\t\t\tcross |= checkCross(k[0], k[1], p[0], p[2]);\n\t\t\tcross |= checkCross(k[0], k[1], p[1], p[3]);\n\t\t\tcross |= checkCross(k[0], k[1], p[2], p[3]);\n\t\t}\n\t}\n\t\n\tif (cross == true){\n        //printf(\"hoge, %d, %d\\n\", a.no, b.no);\n\t\taddEdge(a.no, b.no);\n\t}\n\t\n}\n\nint main()\n{\n\tint n, d;\n\tTriangle data[128];\n\t\n\twhile (1){\n\t\t\n\t\tscanf(\"%d %d\", &n, &d);\n\t\t\n        N = n;\n\t\tif (n + d == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tdata[i].no = i;\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tscanf(\"%lf%lf\", &data[i].x[j], &data[i].y[j]);\n\t\t\t}\n\t\t}\n\t\t\n        for (int i = 0; i < n; i++){\n            G[i].clear();\n            rG[i].clear();\n            compress[i].clear();\n        }\n        \n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n                if (i != j){\n    \t\t\t\tjudgeAdj(data[i], data[j], d);\n                }\n\t\t\t}\n\t\t}\n\t\t\n\t\tint k = scc();\n    \t\n    \tint ans = 0;\n    \tmemset(used, 0, sizeof(used));\n    \t\n    \tfor (int i = 0; i < k; i++){\n        \tif (compress[i].size() == 0){\n        \t    ans++;\n        \t}\n    \t}\n    \t\n    \tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-2;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n    double x, y;\n    Pt() {}\n    Pt(double x, double y) : x(x), y(y) {}\n    Pt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n    Pt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n    Pt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n    Pt operator-() const { return Pt(-x, -y); }\n    Pt operator*(const double &k) const { return Pt(x * k, y * k); }\n    Pt operator/(const double &k) const { return Pt(x / k, y / k); }\n    double ABS() const { return sqrt(x * x + y * y); }\n    double abs2() const { return x * x + y * y; }\n    double arg() const { return atan2(y, x); }\n    double dot(const Pt &a) const { return x * a.x + y * a.y; }\n    double det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n    int s = sig((b - a).det(c - a));\n    if (s) return s;\n    if (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n    if (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n    return 0;\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n    return (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nint g[110][110];\nPt p[110][3];\nint UF[110];\nint FIND(int a){\n    if(UF[a]<0)return a;\n    return UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n    a=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint v[100];\nint main(){\n    int a,b;\n    while(scanf(\"%d%d\",&a,&b),a){\n        for(int i=0;i<a;i++)UF[i]=-1;\n        for(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n        for(int i=0;i<a;i++)g[i][i]=1;\n        for(int i=0;i<a;i++){\n            double ax,bx,cx,ay,by,cy;\n            scanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n            double A=(bx-cx)*(bx-cx)+(by-cy)*(by-cy);\n            double B=(ax-cx)*(ax-cx)+(ay-cy)*(ay-cy);\n            double C=(ax-bx)*(ax-bx)+(ay-by)*(ay-by);\n            if(ABS(A-B)<EPS){\n                p[i][0]=Pt(ax,ay);p[i][1]=Pt(bx,by);p[i][2]=Pt(cx,cy);\n            }\n            if(ABS(B-C)<EPS){\n                p[i][2]=Pt(ax,ay);p[i][0]=Pt(bx,by);p[i][1]=Pt(cx,cy);\n            }\n            if(ABS(C-A)<EPS){\n                p[i][1]=Pt(ax,ay);p[i][2]=Pt(bx,by);p[i][0]=Pt(cx,cy);\n            }\n        }\n        for(int i=0;i<a;i++)if(iSP(p[i][0],p[i][2],p[i][1])==-1)swap(p[i][0],p[i][1]);\n        for(int i=0;i<a;i++)for(int j=0;j<a;j++){\n            if(i==j)continue;\n            Pt t[4];\n            t[0]=p[i][0];\n            t[1]=p[i][1];\n            t[3]=(t[1]-t[0])*Pt(0,-1);\n            t[3]=t[0]+t[3]/t[3].ABS()*(double)b;\n            t[2]=(t[1]-t[0])*Pt(0,-1);\n            t[2]=t[1]+t[2]/t[2].ABS()*(double)b;\n            bool ok=false;\n            for(int k=0;k<3;k++){\n                for(int l=0;l<4;l++){\n                    if(iSS(t[l],t[(l+1)%4],p[j][k],p[j][k]+(p[j][(k+1)%3]-p[j][k])*10000.0)&&\n                    iSS(t[l],t[(l+1)%4],p[j][(k+1)%3],p[j][(k+1)%3]+(p[j][k]-p[j][(k+1)%3])*10000.0))ok=true;\n                }\n            }\n            if(ok){\n                g[i][j]=1;\n        //      printf(\"%d %d\\n\",i,j);\n            }\n        }\n        for(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n            g[i][j]|=g[i][k]&g[k][j];\n        for(int i=0;i<a;i++)for(int j=0;j<a;j++)if(g[i][j]&&g[j][i])UNION(i,j);\n        int ret=0;for(int i=0;i<a;i++)v[i]=0;\n        for(int i=0;i<a;i++){\n            bool ok=true;\n            for(int j=0;j<a;j++){\n                if(FIND(i)!=FIND(j)&&g[j][i])ok=false;\n            }\n            if(ok&&!v[FIND(i)]){ret++;v[FIND(i)]=1;}\n        }\n        printf(\"%d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<stack>\n#include<complex>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nconst double EPS = 0.01;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) < 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) < 0;\n}\nbool intersect(G &rect, G &tri){\n\trep(i,3)if(contains(rect,tri[i]))return 1;\n\trep(i,4)if(contains(tri,rect[i]))return 1;\n\trep(i,3){\n\t\tL l(tri[i],tri[(i+1)%3]);\n\t\trep(j,4)if(intersectSS(l,L(rect[i],rect[(i+1)%4])))return 1;\n\t}\n\treturn 0;\n}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight=0) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid visit(const Graph &g, int v, vector< vector<int> >& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  fr(e, g[v]) {\n    int w = e->dst;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const Graph& g,\n    vector< vector<int> >& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint main(){\n\tint n;\n\tdouble d;\n\twhile(cin>>n>>d,n){\n\t\tvector<G> tri;\n\t\trep(i,n){\n\t\t\tdouble a,b,c,d,e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tG p; p.pb(P(a,b)); p.pb(P(c,d)); p.pb(P(e,f));\n\t\t\tif(abs(p[2]-p[0])!=abs(p[2]-p[1])){\n\t\t\t\tif(abs(p[2]-p[0])==abs(p[1]-p[0]))swap(p[2],p[0]);\n\t\t\t\telse swap(p[1],p[0]);\n\t\t\t}\n\t\t\tif(ccw(p[0],p[1],p[2])<0)swap(p[0],p[1]);\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\tGraph e(n);\n\t\t\n\t\trep(i,n)rep(j,n)if(i!=j){\n\t\t\t\n\t\t\tG &p=tri[i];\n\t\t\tP m=(p[0]+p[1])*0.5,dir=(p[2]-m)*(d/abs(p[2]-m));\n\t\t\t\n\t\t\tG rect;\n\t\t\trect.pb(p[0]); rect.pb(p[1]);\n\t\t\trect.pb(p[1]+dir); rect.pb(p[0]+dir);\n\t\t\tif(ccw(rect[0],rect[1],rect[2])<0)reverse(rect.begin(),rect.end());\n\t\t\t\n\t\t\tif(intersect(rect,tri[j]))e[i].pb(Edge(i,j));\n\t\t}\n\t\t\n\t\tvector<vector<int> > scc;\n\t\tstronglyConnectedComponents(e,scc);\n\t\tint m=scc.size(),to[100],in[100]={0},ans=0;\n\t\trep(i,m)fr(j,scc[i])to[*j]=i;\n\t\trep(i,n)fr(j,e[i])if(to[i]!=to[j->dst])\n\t\tin[to[j->dst]]++;\n\t\t\n\t\trep(i,m)if(in[i]==0)ans++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-2;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nint g[110][110];\nPt p[110][3];\nint UF[110];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g[i][i]=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble ax,bx,cx,ay,by,cy;\n\t\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&bx,&by,&cx,&cy);\n\t\t\tdouble A=(bx-cx)*(bx-cx)+(by-cy)*(by-cy);\n\t\t\tdouble B=(ax-cx)*(ax-cx)+(ay-cy)*(ay-cy);\n\t\t\tdouble C=(ax-bx)*(ax-bx)+(ay-by)*(ay-by);\n\t\t\tif(ABS(A-B)<EPS){\n\t\t\t\tp[i][0]=Pt(ax,ay);p[i][1]=Pt(bx,by);p[i][2]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(B-C)<EPS){\n\t\t\t\tp[i][2]=Pt(ax,ay);p[i][0]=Pt(bx,by);p[i][1]=Pt(cx,cy);\n\t\t\t}\n\t\t\tif(ABS(C-A)<EPS){\n\t\t\t\tp[i][1]=Pt(ax,ay);p[i][2]=Pt(bx,by);p[i][0]=Pt(cx,cy);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)if(iSP(p[i][0],p[i][2],p[i][1])==-1)swap(p[i][0],p[i][1]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tif(i==j)continue;\n\t\t\tPt t[4];\n\t\t\tt[0]=p[i][0];\n\t\t\tt[1]=p[i][1];\n\t\t\tt[3]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[3]=t[0]+t[3]/t[3].ABS()*(double)b;\n\t\t\tt[2]=(t[1]-t[0])*Pt(0,-1);\n\t\t\tt[2]=t[1]+t[2]/t[2].ABS()*(double)b;\n\t\t\tbool ok=false;\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tif(iSS(t[l],t[(l+1)%4],p[j][k],p[j][k]+(p[j][(k+1)%3]-p[j][k])*10000.0)&&\n\t\t\t\t\tiSS(t[l],t[(l+1)%4],p[j][(k+1)%3],p[j][(k+1)%3]+(p[j][k]-p[j][(k+1)%3])*10000.0))ok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tg[i][j]=1;\n\t\t//\t\tprintf(\"%d %d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]|=g[i][k]&g[k][j];\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)if(g[i][j]&&g[j][i])UNION(i,j);\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(FIND(i)!=FIND(j)&&g[j][i])ok=false;\n\t\t\t}\n\t\t\tif(ok)ret++;\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef int Weight;\nconst Weight INF = 1 << 28;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge() {}\n\tEdge(int src, int dst, Weight weight = 1): src(src), dst(dst), weight(weight) {}\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n\nvoid addEdge(Graph &g, int src, int dst, int weight = 1)\n{\n\tg[src].push_back(Edge(src, dst, weight));\n};\n\nGraph transpose(const Graph &g)\n{\n\tGraph rg(g.size());\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\taddEdge(rg, g[i][j].dst, g[i][j].src, g[i][j].weight);\n\t\t}\n\t}\n\treturn rg;\n}\n\nstd::vector<Weight> dijkstra(const Graph &g, int src){\n\tstd::vector<Weight> dist(g.size(), INF);\n\tstd::priority_queue<std::pair<Weight, int>,\n\t                    std::vector<std::pair<Weight, int> >,\n\t\t\t\t\t\tstd::greater<std::pair<Weight, int> > > pq;\n\t\n\tdist[src] = Weight(0);\n\tpq.push(std::make_pair(Weight(0), src));\n\t\n\twhile (pq.size()){\n\t\tint cur = pq.top().second;\n\t\tWeight sum = pq.top().first;\n\t\tpq.pop();\n\t\tif (dist[cur] < sum) continue;\n\t\t\n\t\tfor (int i = 0; i < g[cur].size(); i++){\n\t\t\tconst Edge &e = g[cur][i];\n\t\t\tif (dist[e.dst] > sum + e.weight){\n\t\t\t\tdist[e.dst] = sum + e.weight;\n\t\t\t\tpq.push(std::make_pair(sum + e.weight, e.dst));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dist;\n}\n\nvoid dfs_(const Graph &g, int v, bool *used, std::vector<int> &vs)\n{\n\tused[v] = true;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) dfs_(g, to, used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs_(const Graph &g, int v, int k, bool *used, std::vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) rdfs_(g, to, k, used, cmp);\n\t}\n}\n\nint scc(const Graph &g, std::vector<int> &cmp)\n{\n\tGraph rg = transpose(g);\n\tstd::vector<int> vs;\n\tbool *used = new bool[g.size()];\n\tcmp.resize(g.size());\n\t\n\tmemset(used, false, g.size());\n\tfor (int v = 0; v < g.size(); v++){\n\t\tif (!used[v]) dfs_(g, v, used, vs);\n\t}\n\t\n\tmemset(used, false, g.size());\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs_(rg, vs[i], k++, used, cmp);\n\t}\n\t\n\tdelete used;\n\treturn k;\n}\n\n#include <bits/stdc++.h>\n\nnamespace geo {\n\n// ???????????§??????\n\ntypedef std::complex<double> Point;\n\nstruct Segment {\n\tPoint p1, p2;\n\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n};\n\nstruct Circle {\n\tPoint p;\n\tdouble r;\n\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef std::vector<Point> Polygon;\n\n// ?????°, ??????\n\nconst double PI = acos(-1);\nconst double EPS = 1e-2;\nconst double INF = 1e12;\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE \t\t= -1;\nconst int ONLINE_BACK\t\t= 2;\nconst int ONLINE_FRONT\t\t= -2;\nconst int ON_SEGMENT\t\t= 0;\nconst int OUT\t\t\t\t= 0;\nconst int ON\t\t\t\t= 1;\nconst int IN\t\t\t\t= 2;\n\ninline double square(double a){return a * a;}\ninline bool equal(double a, double b){return std::abs(a - b) < EPS;}\ninline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\ninline double norm(const Point &a){return square(a.real()) + square(a.imag());}\ninline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\ninline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\ninline double toDeg(double t){return t / PI * 180;}\ninline double toRad(double t){return t / 180 * PI;}\n\n#define curr(v, i) v[i]\n#define next(v, i) v[(i + 1) % v.size()]\n#define prev(v, i) v[(i - 1 + (int)v.size()) % v.size()]\n\n\n// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n// ????§?????????????????????? Point rp ?????£??\\????????????\n\nbool cmpx(const Point &a, const Point &b){\n\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\treturn b.imag() < b.imag();\n}\n\nbool cmpy(const Point &a, const Point &b){\n\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\treturn a.real() < b.real();\n}\n\nPoint rp;\nbool cmparg(const Point &a, const Point &b){\n\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\tif (!equal(rada, radb)) return rada < radb;\n\treturn norm(a) < norm(b);\n}\n\n\n// ??´???, ??????\n\nbool orthgonal(const Vector &a, const Vector &b){\n\treturn equal(dot(a, b), 0.0);\n}\n\nbool parallel(const Vector &a, const Vector &b){\n\treturn equal(cross(a, b), 0.0);\n}\n\n\n// ????°?, ?°???±\n\nPoint project(const Segment &s, const Point &p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(const Segment &s, const Point &p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\n\n// ??????????????????\n\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n\n// ?????¢\n\ndouble distanceLP(const Line &l, const Point &p){\n\treturn std::abs(cross(l.p2 - l.p1, p - l.p1) / std::abs(l.p2 - l.p1));\n}\n\ndouble distanceSP(const Segment &s, const Point &p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return std::abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return std::abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\nbool intersect(const Segment &s1, const Segment &s2);\ndouble distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn std::min(\n\t\tstd::min(distanceSP(s1, s2.p1), distanceSP(s1, s2.p2)),\n\t\tstd::min(distanceSP(s2, s1.p1), distanceSP(s2, s1.p2))\n\t);\n}\n\n\n// ????????????\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &s){\n\t// ???????????° (0 ~ 2) ?????????\n\tdouble dist = distanceSP(s, c.p) - c.r;\n\tif (equal(dist, 0.0)) return 1;\n\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\nint intersect(const Circle &c1, const Circle &c2){\n\t// ???????????° (0 ~ 2) ?????????\n\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\tif (equal(dist, 0.0)) return 1;\n\tif (dist < 0.0) return 2;\n\treturn 0;\n}\n\n\n// ??????\n\nPoint crossPoint(const Segment &s1, const Segment &s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = std::abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = std::abs(cross(base, s1.p2 - s2.p1));\n\t\n\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\tassert(!equal(d1 + d2, 0.0));\n\t\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nstd::vector<Point> crossPoints(const Circle &c, const Line &l){\n\tstd::vector<Point> res;\n\tif (!intersect(c, l)) return res;\n\t\n\tVector pr = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / std::abs(l.p2 - l.p1);\n\tdouble base = std::sqrt(c.r * c.r - norm(pr - c.p));\n\tres.push_back(pr + e * base);\n\tres.push_back(pr - e * base);\n\tif (equalVector(res[0], res[1])) res.pop_back();\n\treturn res;\n}\n\nstd::vector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\tstd::vector<Point> res;\n\tif (!intersect(c1, c2)) return res;\n\t\n\tdouble d = std::abs(c1.p - c2.p);\n\tdouble a = std::acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\tdouble t = std::arg(c2.p - c1.p);\n\tres.push_back(c1.p + std::polar(c1.r, t + a));\n\tres.push_back(c1.p + std::polar(c1.r, t - a));\n\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\n\treturn res;\n}\n\n\n// ??????\n\nint contains(const Polygon &g, const Point &p){\n\tint n = g.size();\n\tbool res = false;\n\tfor (int i = 0; i < n; i++){\n\t\tPoint a = g[i] - p;\n\t\tPoint b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t}\n\treturn res ? IN : OUT;\n}\n\n\n// ??????\n\nPolygon convexHull(std::vector<Point> s){\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tstd::sort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\t\n\tfor (int i = 2; i < s.size(); i++){\n\t\tint n = u.size();\n\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\tu.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t\n\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\tint n = l.size();\n\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\tl.pop_back();\n\t\t\tn--;\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t\n\tstd::reverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\tl.push_back(u[i]);\n\t}\n\t\n\treturn l;\n}\n\t\n\n// ???????§???¢??????\n\nPolygon convexCut(const Polygon &g, const Line &l){\n\tPolygon res;\n\tfor (int i = 0; i < g.size(); i++){\n\t\tconst Point &a = curr(g, i);\n\t\tconst Point &b = next(g, i);\n\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\tres.push_back(a);\n\t\t}\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\n}\n\nnamespace std {\nbool operator < (const geo::Point &a, const geo::Point &b){\n\treturn geo::cmpx(a, b);\n}\n}\n\nbool intersect(const geo::Polygon &g, const geo::Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tgeo::Segment s(curr(g, i), next(g, i));\n\t\t\tgeo::Segment t(curr(h, j), next(h, j));\n\t\t\t//if (geo::intersect(s, t)) return true;\n\t\t\tif (geo::distance(s, t) < 0.01 + geo::EPS) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (geo::contains(h, curr(g, i))) return true;\n\t}\n\t\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (geo::contains(g, curr(h, i))) return true;\n\t}\n\t\n\treturn false;\n}\n\nint n;\ndouble d;\nstd::vector<geo::Polygon> tris;\nstd::vector<geo::Polygon> sqrs;\n\nvoid solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tgeo::Point &a = curr(tris[i], j),\n\t\t\t\t\t   &b = prev(tris[i], j),\n\t\t\t\t\t   &c = next(tris[i], j);\n\t\t\tif (geo::equal(std::abs(a - b), std::abs(a - c))){\n\t\t\t\tstd::swap(tris[i][j], tris[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsqrs.assign(n, geo::Polygon(4));\n\tfor (int i = 0; i < n; i++){\n\t\tgeo::Vector normal = tris[i][2] - (tris[i][0] + tris[i][1]) / 2.0;\n\t\tnormal = normal / std::abs(normal) * d;\n\t\t\n\t\tsqrs[i][0] = tris[i][0];\n\t\tsqrs[i][1] = tris[i][1];\n\t\tsqrs[i][2] = tris[i][1] + normal;\n\t\tsqrs[i][3] = tris[i][0] + normal;\n\t}\n\t\n\tGraph g(n);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqrs[i], tris[j])){\n\t\t\t\taddEdge(g, i, j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstd::vector<int> cmp;\n\tint k = scc(g, cmp);\n\t\n\tstd::vector<int> v(k, 1);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\tint src = g[i][j].src;\n\t\t\tint dst = g[i][j].dst;\n\t\t\tif (src != dst) v[cmp[dst]] = 0;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < k; i++){\n\t\tres += v[i];\n\t}\n\t\n\tstd::printf(\"%d\\n\", res);\n}\n\nint main()\n{\n\twhile (std::scanf(\"%d %lf\", &n, &d), n){\n\t\ttris.assign(n, geo::Polygon(3));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tdouble x, y;\n\t\t\t\tstd::cin >> x >> y;\n\t\t\t\ttris[i][j] = geo::Point(x, y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\n#include <cstring>\n\n// ???, ????????????\ntypedef std::complex<double> Point;\ntypedef Point Vector;\n\nnamespace std {\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\t\n\tistream& operator >> (istream &is, Point &a){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\ta = Point(x, y);\n\t\treturn is;\n\t}\n\t\n\tostream& operator << (ostream &os, Point a){\n\t\treturn os << a.real() << \" \" << a.imag();\n\t}\n}\n\n// ??´???\nstruct Line {\n\tPoint p1, p2;\n\tLine(){}\n\tLine(const Point &p1, const Point &p2): p1(p1), p2(p2){}\n};\ntypedef Line Segment;\n\nnamespace std {\n\tistream& operator >> (istream &is, Line &a){\n\t\treturn is >> a.p1 >> a.p2;\n\t}\n}\n\n// ???\nstruct Circle {\n\tPoint p; double r;\n\tCircle(){}\n\tCircle(const Point &p, double r): p(p), r(r){}\n};\n\nnamespace std {\n\tistream& operator >> (istream &is, Circle &a){\n\t\treturn is >> a.p >> a.r;\n\t}\n}\n\n// ????§???¢\ntypedef std::vector<Point> Polygon;\n\nconst double EPS = 1e-4;\nconst double INF = 1e12;\nconst double PI = acos(-1.0);\n\n// ????????¨??????????????¢???\nenum CCW {\n\tCOUNTER_CLOCKWISE = 1,\n\tCLOCKWISE = -1,\n\tONLINE_BACK = 2,\n\tONLINE_FRONT = -2,\n\tON_SEGMENT = 0,\n};\n\n// ?????¢????£????????????¢???\nenum {\n\tOUT = 0,\n\tON = 1,\n\tIN = 2,\n};\n\n\n// a ??? 2 ??? (a ^ 2)\ndouble SQ(double a);\n\n// ?????????????????????????????¢??°\nbool EQ(double a, double b);\nbool NEQ(double a, double b);\nbool LT(double a, double b);\nbool GT(double a, double b);\nbool LEQ(double a, double b);\nbool GEQ(double a, double b);\n\n// ??§?????? <=> ?????°?????????\ndouble toDeg(double t);\ndouble toRad(double t);\n\n// ????????? (dot(a, a))\ndouble norm(const Vector &a);\n\n// ??????, ??????\ndouble dot(const Vector &a, const Vector &b);\ndouble cross(const Vector &a, const Vector &b);\n\n// ??´???, ??????\nbool orthogonal(const Segment &s1, const Segment &s2);\nbool parallel(const Segment &s1, const Segment &s2);\n\n// ?°???±, ????°?\nPoint project(const Line &l, const Point &p);\nPoint reflect(const Line &l, const Point &p);\n\n// ?????? (p0, p1) ??¨??? p2 ???????????¢???\nint ccw(const Point &p0, const Point &p1, const Point &p2);\n\n// ????????????\nbool intersectLP(const Line &l, const Point &p);\nbool intersectLL(const Line &l1, const Line &l2);\nbool intersectLS(const Line &l, const Segment &s);\nbool intersectSP(const Segment &s, const Point &p);\nbool intersectSS(const Segment &s1, const Segment &s2);\nint intersectCP(const Circle &c, const Point &p);\nbool intersectCL(const Circle &c, const Line &l);\nint intersectCS(const Circle &c, const Segment &s);\nint intersectCC(const Circle &c1, const Circle &c2);\n\n// ?????¢\ndouble distanceLP(const Line &l, const Point &p);\ndouble distanceLL(const Line &l1, const Line &l2);\ndouble distanceLS(const Line &l, const Segment &s);\ndouble distanceSP(const Segment &s, const Point &p);\ndouble distanceSS(const Segment &s1, const Segment &s2);\ndouble distanceCP(const Circle &c, const Point &p);\ndouble distanceCL(const Circle &c, const Line &l);\ndouble distanceCS(const Circle &c, const Segment &s);\ndouble distanceCC(const Circle &c1, const Circle &c2);\n\n// ??????\nPoint crossPointLL(const Line &l1, const Line &l2);\nPoint crossPointLS(const Line &l, const Segment &s);\nPoint crossPointSS(const Segment &s1, const Segment &s2);\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l);\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s);\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2);\n\n\ndouble SQ(double a){\n\treturn a * a;\n}\n\nbool EQ(double a, double b){\n\treturn std::abs(a - b) < EPS;\n}\n\nbool NEQ(double a, double b){\n\treturn !EQ(a, b);\n}\n\nbool LT(double a, double b){\n\treturn a - b < -EPS;\n}\n\nbool GT(double a, double b){\n\treturn a - b > EPS;\n}\n\nbool LEQ(double a, double b){\n\treturn !GT(a, b);\n}\n\nbool GEQ(double a, double b){\n\treturn !LT(a, b);\n}\n\ndouble toDeg(double t){\n\treturn t * 180 / PI;\n}\n\ndouble toRad(double t){\n\treturn t / 180 * PI;\n}\n\ndouble norm(const Vector &a){\n\treturn SQ(a.real()) + SQ(a.imag());\n}\n\ndouble dot(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).real();\n}\n\ndouble cross(const Vector &a, const Vector &b){\n\treturn (conj(a) * b).imag();\n}\n\n// AOJ CGL_2_A\nbool orthogonal(const Segment &s1, const Segment &s2){\n\treturn EQ(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_2_A\nbool parallel(const Segment &s1, const Segment &s2){\n\treturn EQ(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n// AOJ CGL_1_A\nPoint project(const Line &l, const Point &p){\n\tVector base = l.p2 - l.p1;\n\tdouble r = dot(p - l.p1, base) / norm(base);\n\treturn l.p1 + base * r;\n}\n\n// AOJ CGL_1_B\nPoint reflect(const Line &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2.0;\n}\n\n// AOJ CGL_1_C\nint ccw(const Point &p0, const Point &p1, const Point &p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (GT(cross(a, b), 0.0)) return COUNTER_CLOCKWISE;\n\tif (LT(cross(a, b), 0.0)) return CLOCKWISE;\n\tif (LT(dot(a, b), 0.0)) return ONLINE_BACK;\n\tif (LT(norm(a), norm(b))) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersectLP(const Line &l, const Point &p){\n\treturn LEQ(std::abs(cross(l.p1 - p, l.p2 - p)), 0.0);\n}\n\nbool intersectLL(const Line &l1, const Line &l2){\n\treturn !parallel(l1, l2) || LEQ(std::abs(cross(l1.p2 - l1.p1, l2.p1 - l1.p1)), 0.0);\n}\n\nbool intersectLS(const Line &l, const Segment &s){\n\treturn LEQ(cross(l.p2 - l.p1, s.p1 - l.p1) * cross(l.p2 - l.p1, s.p2 - l.p1), 0.0);\n}\n\nbool intersectSP(const Segment &s, const Point &p){\n\treturn norm(s.p1 - p) + norm(s.p2 - p) - norm(s.p2 - s.p1) < EPS;\n}\n\n// CGL_2_B\nbool intersectSS(const Segment &s1, const Segment &s2){\n\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n}\n\nint intersectCP(const Circle &c, const Point &p){\n\tdouble dd = norm(c.p - p);\n\tif (LT(dd, SQ(c.r))) return IN;\n\tif (EQ(dd, SQ(c.r))) return ON;\n\treturn OUT;\n}\n\nbool intersectCL(const Circle &c, const Line &l){\n\tdouble d = distanceLP(l, c.p);\n\treturn LEQ(d, c.r);\n}\n\nint intersectCS(const Circle &c, const Segment &s){\n\tdouble dd1 = norm(c.p - s.p1);\n\tdouble dd2 = norm(c.p - s.p2);\n\tif (LT(dd1, SQ(c.r)) && LT(dd2, SQ(c.r))) return IN;\n\tif (GT(distanceCS(c, s), 0.0)) return OUT;\n\treturn ON;\n}\n\n// c1 ??? c2 ???????????????????????¨??? IN\n// c1 ??? c2 ????????£???????????¨??? ON\n// c1 ??? c2 ?????????????????¨??? OUT\nint intersectCC(const Circle &c1, const Circle &c2){\n\tif (GT(norm(c1.p - c2.p), SQ(c1.r + c2.r))) return OUT;\n\tif (LT(norm(c1.p - c2.p), SQ(c2.r))) return IN;\n\tif (LT(norm(c1.p - c2.p), SQ(c1.r))) return OUT;\n\treturn ON;\n}\n\ndouble distanceLP(const Line &l, const Point &p){\n\treturn std::abs(cross(l.p2 - l.p1, p - l.p1)) / std::abs(l.p2 - l.p1);\n}\n\ndouble distanceLL(const Line &l1, const Line &l2){\n\tif (intersectLL(l1, l2)) return 0.0;\n\treturn distanceLP(l1, l2.p1);\n}\n\ndouble distanceLS(const Line &l, const Segment &s){\n\tif (intersectLS(l, s)) return 0.0;\n\treturn std::min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\n\ndouble distanceSP(const Segment &s, const Point &p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return std::abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return std::abs(p - s.p2);\n\treturn distanceLP(s, p);\n}\n\n// AOJ CGL_2_D\ndouble distanceSS(const Segment &s1, const Segment &s2){\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn std::min(\n\t\tstd::min(\n\t\t\tdistanceSP(s1, s2.p1),\n\t\t\tdistanceSP(s1, s2.p2)\n\t\t),\n\t\tstd::min(\n\t\t\tdistanceSP(s2, s1.p1),\n\t\t\tdistanceSP(s2, s1.p2)\n\t\t)\n\t);\n}\n\ndouble distanceCP(const Circle &c, const Point &p){\n\treturn std::abs(std::abs(c.p - p) - c.r);\n} \n\ndouble distanceCL(const Circle &c, const Line &l){\n\tif (intersectCL(c, l)) return 0.0;\n\treturn distanceLP(l, c.p) - c.r;\n}\n\ndouble distanceCS(const Circle &c, const Segment &s){\n\tif (intersectCS(c, s)) return 0.0;\n\treturn std::min(distanceCP(c, s.p1), distanceCP(c, s.p2));\n}\n\ndouble distanceCC(const Circle &c1, const Circle &c2){\n\tif (intersectCC(c1, c2) == ON) return 0.0;\n\tif (intersectCC(c1, c2) == IN){\n\t\treturn c2.r - (std::abs(c1.p - c2.p) + c1.r);\n\t}\n\tif (intersectCC(c2, c1) == IN){\n\t\treturn c1.r - (std::abs(c1.p - c2.p) + c2.r);\n\t}\n\treturn (c1.r + c2.r) - (c1.r + c2.r);\n}\n\nPoint crossPointLL(const Line &l1, const Line &l2){\n\tassert(intersectLL(l1, l2));\n\tVector base = l2.p2 - l2.p1;\n\tdouble d1 = std::abs(cross(base, l1.p1 - l2.p1));\n\tdouble d2 = std::abs(cross(base, l1.p2 - l2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn l1.p1 + (l1.p2 - l1.p1) * t;\n}\n\nPoint crossPointLS(const Line &l, const Segment &s){\n\tassert(intersectLS(l, s));\n\treturn crossPointLL(l, s);\n}\n\nPoint crossPointSS(const Segment &s1, const Segment &s2){\n\tassert(intersectSS(s1, s2));\n\treturn crossPointSS(s1, s2);\n}\n\nstd::vector<Point> crossPointCL(const Circle &c, const Line &l){\n\tif (!intersectCL(c, l)) return std::vector<Point>();\n\tstd::vector<Point> ret;\n\tVector proj = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / std::abs(l.p2 - l.p1);\n\tdouble base = sqrt(SQ(c.r) - norm(proj - c.p));\n\tret.push_back(proj + e * base);\n\tret.push_back(proj - e * base);\n\treturn ret;\n}\n\nstd::vector<Point> crossPointCS(const Circle &c, const Segment &s){\n\tstd::vector<Point> ret = crossPointCL(c, s);\n\tfor (int i = 0; i < ret.size(); i++){\n\t\tif (!intersectCP(c, ret[i])){\n\t\t\tswap(ret[i], ret.back());\n\t\t\tret.pop_back();\n\t\t\ti--;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstd::vector<Point> crossPointCC(const Circle &c1, const Circle &c2){\n\tif (!intersectCC(c1, c2)) return std::vector<Point>();\n\tstd::vector<Point> ret;\n\tdouble d = std::abs(c1.p - c2.p);\n\tdouble a = std::acos((SQ(c1.r) + SQ(d) - SQ(c2.r)) / (2 * c1.r * d));\n\tdouble t = std::arg(c2.p - c1.p);\n\tret.push_back(c1.p + std::polar(c1.r, t + a));\n\tret.push_back(c1.p + std::polar(c1.r, t - a));\n\treturn ret;\n}\n\nnamespace {\nenum {DIRECTED, UNDIRECTED};\nconst int GRAPH_TYPE = DIRECTED;\n\ntypedef int Weight;\nconst Weight INF = 1 << 28;\n\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge() {}\n\tEdge(int src, int dst, Weight weight = 1): src(src), dst(dst), weight(weight) {}\n\tbool operator < (const Edge &t) const { return weight < t.weight; }\n};\n\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n\nvoid addEdge(Graph &g, int src, int dst, int weight = 1)\n{\n\tg[src].push_back(Edge(src, dst, weight));\n\tif (GRAPH_TYPE == UNDIRECTED) g[dst].push_back(Edge(dst, src, weight));\n};\n\nGraph transpose(const Graph &g)\n{\n\tGraph rg(g.size());\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < g[i].size(); j++){\n\t\t\taddEdge(rg, g[i][j].dst, g[i][j].src, g[i][j].weight);\n\t\t}\n\t}\n\treturn rg;\n}\n\nvoid dfs_(const Graph &g, int v, bool *used, std::vector<int> &vs)\n{\n\tused[v] = true;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) dfs_(g, to, used, vs);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs_(const Graph &g, int v, int k, bool *used, std::vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tint to = g[v][i].dst;\n\t\tif (!used[to]) rdfs_(g, to, k, used, cmp);\n\t}\n}\n\nint scc(const Graph &g, std::vector<int> &cmp)\n{\n\tGraph rg = transpose(g);\n\tstd::vector<int> vs;\n\tbool *used = new bool[g.size()];\n\tcmp.resize(g.size());\n\t\n\tstd::memset(used, false, g.size());\n\tfor (int v = 0; v < g.size(); v++){\n\t\tif (!used[v]) dfs_(g, v, used, vs);\n\t}\n\t\n\tstd::memset(used, false, g.size());\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs_(rg, vs[i], k++, used, cmp);\n\t}\n\t\n\tdelete used;\n\treturn k;\n}\n}\n\n\nusing namespace std;\n\nint n;\ndouble d;\nvector<Polygon> tri;\nvector<Polygon> rect;\n\nbool contains(const Polygon &g, const Point &p)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tint t = ccw(g[i], g[(i + 1) % g.size()], p);\n\t\tif (t != ON_SEGMENT && t != CLOCKWISE) return false;\n\t}\n\treturn true;\n}\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment s(g[i], g[(i + 1) % g.size()]);\n\t\t\tSegment t(h[j], h[(j + 1) % h.size()]);\n\t\t\tif (LEQ(distanceSS(s, t), 0.01)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\t\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\treturn false;\n}\n\nint solve()\n{\n\trect.assign(n, Polygon(4));\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tif (EQ(norm(tri[i][j] - tri[i][(j + 1) % 3]), norm(tri[i][j] - tri[i][(j + 2) % 3]))){\n\t\t\t\tswap(tri[i][0], tri[i][j]);\n\t\t\t}\n\t\t}\n\t\tif (ccw(tri[i][1], tri[i][2], tri[i][0]) == CLOCKWISE){\n\t\t\tswap(tri[i][1], tri[i][2]);\n\t\t}\n\t\t\n\t\tVector s = tri[i][2] - tri[i][1];\n\t\tVector normal = s / abs(s) * Vector(0, 1) * d;\n\t\trect[i][0] = tri[i][1];\n\t\trect[i][1] = tri[i][2];\n\t\trect[i][2] = tri[i][2] + normal;\n\t\trect[i][3] = tri[i][1] + normal;\n\t}\n\t\n\tGraph graph(n);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(rect[i], tri[j])){\n\t\t\t\taddEdge(graph, i, j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tint v = scc(graph, cmp);\n\tint mat[100][100] = {};\n\tint in[100] = {};\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < graph[i].size(); j++){\n\t\t\tint src = cmp[i];\n\t\t\tint dst = cmp[graph[i][j].dst];\n\t\t\tif (src == dst) continue;\n\t\t\tif (mat[src][dst]++) continue;\n\t\t\tin[dst]++;\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < v; i++){\n\t\tif (in[i] == 0) res++;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tstd::cout << std::fixed << std::setprecision(12);\n\t\n\twhile (cin >> n >> d, n){\n\t\ttri.assign(n, Polygon(3));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS = 1e-9, INF = 1e12, PI = acos(-1.0);\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  G ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const G& g, const P& p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n#include<stack>\nvoid visit(const vector<vi> &g, int v, vector<vi>& scc,\n    stack<int> &S, vector<bool> &inS,\n    vector<int> &low, vector<int> &num, int& time) {\n  low[v] = num[v] = ++time;\n  S.push(v); inS[v] = true;\n  each(e, g[v]) {\n    int w = *e;\n    if (num[w] == 0) {\n      visit(g, w, scc, S, inS, low, num, time);\n      low[v] = min(low[v], low[w]);\n    } else if (inS[w])\n      low[v] = min(low[v], num[w]);\n  }\n  if (low[v] == num[v]) {\n    scc.push_back(vector<int>());\n    while (1) {\n      int w = S.top(); S.pop(); inS[w] = false;\n      scc.back().push_back(w);\n      if (v == w) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const vector<vi>& g,\n    vector<vi>& scc) {\n  const int n = g.size();\n  vector<int> num(n), low(n);\n  stack<int> S;\n  vector<bool> inS(n);\n  int time = 0;\n  rep(u, n) if (num[u] == 0)\n    visit(g, u, scc, S, inS, low, num, time);\n}\n\nint n, d;\nvector<vi> g;\n\nint main(){\n\twhile(cin >> n >> d, n || d){\n\t\tg.clear(); g.resize(n);\n\t\tvector<G> tri;\n\t\trep(i, n){\n\t\t\tint t = -1;\n\t\t\tG p(3);\n\t\t\tdouble l[3];\n\t\t\trep(j, 3) cin >> p[j].real() >> p[j].imag();\n\t\t\trep(j, 3) l[j] = abs(p[j] - p[(j + 1) % 3]);\n\t\t\trep(j, 3) if(abs(l[j] - l[(j + 1) % 3]) < EPS){\n\t\t\t\tt = (j + 1) % 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tassert(t >= 0);\n\t\t\tif(t) swap(p[t], p[0]);\n\t\t\ttri.pb(p);\n\t\t}\n\t\t\n\t\trep(i, n){\n\t\t\tG &p = tri[i];\n\t\t\tP dir = p[0] - (p[1] + p[2]) * 0.5;\n\t\t\tdir *= d / abs(dir);\n\t\t\t\n\t\t\tG ps;\n\t\t\tps.pb(p[1]); ps.pb(p[2]);\n\t\t\tps.pb(p[1] + dir); ps.pb(p[2] + dir);\n\t\t\tps = convex_hull(ps);\n\t\t\t\n\t\t\trep(j, n){\n\t\t\t\tbool ok = 0;\n\t\t\t\trep(k, 3){\n\t\t\t\t\trep(l, 4) if(distanceSP(L(ps[l], ps[(l + 1) % 4]), tri[j][k])\n\t\t\t\t\t\t< 0.01) ok = 1;\n\t\t\t\t\tif(contains(ps, tri[j][k]) != OUT) ok = 1;\n\t\t\t\t}\n\t\t\t\tif(ok) g[i].pb(j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tmap<int, int> to;\n\t\tvector<vi> scc;\n\t\tstronglyConnectedComponents(g, scc);\n\t\tint m = scc.size();\n\t\tvi in(m);\n\t\t\n\t\trep(i, m) rep(j, scc[i].size()){\n\t\t\tto[scc[i][j]] = i;\n\t\t}\n\t\trep(i, n) rep(j, g[i].size()){\n\t\t\tint a = to[i], b = to[g[i][j]];\n\t\t\tif(a != b) in[b]++;\n\t\t}\n\t\trep(i, m) if(in[i] == 0) ans++;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct coor {\n\tdouble x, y;\n};\nstruct tri {\n\tcoor p[3];\n\tcoor rec[4];\n};\n\nint n, d;\nvector<tri> v;\nvector<vector<int> > edge;\n\nconst double EPS = 1e-9;\nconst double ERR = 1e-2;\n\ntemplate<class T>\nT sqr(T x) {\n\treturn x * x;\n}\n\ndouble dist(coor a, coor b) {\n\treturn sqrt(sqr(a.x-b.x) + sqr(a.y-b.y));\n}\n\ndouble dist_lp(coor c, coor a, coor b) {\n\tcoor v0, v1;\n\tv0.x = b.x - a.x; v0.y = b.y - a.y;\n\tv1.x = c.x - a.x; v1.y = c.y - a.y;\n\n\tif(sqr(dist(a,b)) + sqr(dist(a,c)) - sqr(dist(c,b)) > 0\n\t\t\t&& sqr(dist(a,b)) + sqr(dist(b,c)) - sqr(dist(c,a)) > 0) {\n\t\tdouble cross;\n\t\tcross = fabs(v0.x * v1.y - v0.y * v1.x);\n\t\treturn cross / dist(a,b);\n\t}\n\n\treturn min(dist(a,c), dist(b,c));\n}\n\nbool in_poly(coor p, coor poly[], int sz) {\n\tdouble sign = +0.0;\n\tfor(int i = 0; i < sz; i++) {\n\t\tcoor v0, v1;\n\t\tv0.x = poly[i].x - p.x; v0.y = poly[i].y - p.y;\n\t\tv1.x = poly[(i+1)%sz].x - p.x; v1.y = poly[(i+1)%sz].y - p.y;;\n\n\t\tif(i != 0 && sign * (v0.x * v1.y - v0.y * v1.x) < EPS) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tsign = (v0.x * v1.y - v0.y * v1.x);\n\n\t\tif(i == sz-1) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < sz; i++) {\n\t\tif(dist_lp(p,poly[i], poly[(i+1)%sz]) <= ERR + EPS) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool seg_cross(coor a, coor b, coor c, coor d) {\n\tcoor v0, v1, v2;\n\t\n\tv0.x = a.x - c.x; v0.y = a.y - c.y;\n\tv1.x = b.x - c.x; v1.y = b.y - c.y;\n\tv2.x = d.x - c.x; v2.y = d.y - c.y;\n\n\tdouble s, t;\n\ts = (v0.x * v2.y - v0.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\tt = - (v1.x * v2.y - v1.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\n\tif(s + t > 1-ERR && s > -EPS && t > -EPS)\n\t\treturn true;\n\treturn false;\n}\n\nbool exist_edge(tri from, tri to) {\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(in_poly(to.p[i], from.rec, 4))\n\t\t\treturn true;\n\t}\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(in_poly(from.rec[i], to.p, 3))\n\t\t\treturn true;\n\t}\n\n\tfor(int i = 0; i < 3; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tif(seg_cross(to.p[i], to.p[(i+1)%3], from.rec[j], from.rec[(j+1)%4]))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool visited[128];\nbool touch[128];\n\nvoid check(int i, int s) {\n\tif(i != s && touch[i])\n\t\ttouch[i] = false;\n\tif(visited[i])\n\t\treturn;\n\tvisited[i] = true;\n\tfor(int j = 0; j < edge[i].size(); j++) {\n\t\tcheck(edge[i][j], s);\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> d, n || d) {\n\t\tv.clear();\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tvisited[i] = touch[i] = false;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttri in;\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tcoor c;\n\t\t\t\tcin >> c.x >> c.y;\n\t\t\t\tin.p[j] = c;\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tif(fabs(dist(in.p[(0+j)%3],in.p[(1+j)%3]) - dist(in.p[(1+j)%3], in.p[(2+j)%3])) < ERR) {\n\t\t\t\t\tswap(in.p[(1+j)%3], in.p[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcoor add;\n\t\t\tadd.x =\t(in.p[1].x - in.p[0].x) + (in.p[1].x - in.p[2].x);\n\t\t\tadd.y = (in.p[1].y - in.p[0].y) + (in.p[1].y - in.p[2].y);\n\n\t\t\tdouble addlen;\n\t\t\taddlen = sqrt(sqr(add.x) + sqr(add.y));\n\t\t\tadd.x = add.x * d / addlen;\n\t\t\tadd.y = add.y * d / addlen;\n\n\t\t\tin.rec[0].x = in.p[0].x; in.rec[0].y = in.p[0].y;\n\t\t\tin.rec[1].x = in.p[2].x; in.rec[1].y = in.p[2].y;\n\t\t\tin.rec[2].x = in.p[2].x + add.x; in.rec[2].y = in.p[2].y + add.y;\n\t\t\tin.rec[3].x = in.p[0].x + add.x; in.rec[3].y = in.p[0].y + add.y;\n\n\t\t\tv.push_back(in);\n\t\t}\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\t\tif(i != j) {\n\t\t\t\t\tif(exist_edge(v[i], v[j])) {\n\t\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint i_ = (i+5)%n;\n\t\t\tif(!visited[i_]) {\n\t\t\t\ttouch[i_] = true;\n\t\t\t\tcheck(i_, i_);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(touch[i])\n\t\t\t\tres++;\n\t\t}\n\t\tcout <<  res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO a,const PO b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,(int)inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,(int)redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n,map<int,int> &M){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  rep(i,n)M[i]=component[i];\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,(int)edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n  map<int,int> M;\n  int tmpn=scc(n,M);\n  rep(i,n){\n    int me=M[i];\n    rep(j,(int)inedge[i].size()){\n      int you=M[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,(int)in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-1;\n\ndouble cross(P a,P b){\n  return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      //if (     cross(a[in[0]]-a[in[1]],a[in[2]]-a[in[1]]) >=0)\n      //\tassert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])>=0);\n      //      else assert(cross(a[in[0]]-a[in[1]],mid-a[in[1]])<=0);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  //assert(false);\n  return ret;\n}\n\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble distance_ls_p(P a,P b,P c){\n  if (dot(b-a,c-a) < eps)return abs(c-a);\n  if (dot(a-b,c-b) < eps)return abs(c-b);\n  return abs( cross(b-a,c-a))/abs(b-a);\n}\n\nbool isp(P a,P b,P c){\n  return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_in(vector<P> in,P a){\n  int cnt =0;\n  int n = in.size();\n  rep(i,n){\n    P cur = in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag() > next.imag())swap(cur,next);\n    if (cur.imag()<0 && 0<=next.imag() &&\n        cross(next,cur)>=0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if ( isp(a1,a2,b1))return true;\n  if ( isp(a1,a2,b2))return true;\n  if ( isp(b1,b2,a1))return true;\n  if ( isp(b1,b2,a2))return true;\n  if (( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<-eps ) && //-EPS\n      ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)  <-eps))return true;\n  else return false;\n}\n\n#define DSS distance_ls_p\ndouble distance_ss_p(P a,P b,P c,P d){\n  return min(  min( DSS(a,b,c),DSS(a,b,d)),min(DSS(c,d,a),DSS(c,d,b)));\n}\n\nbool is_intersected_polygon(vector<P> a,vector<P> b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,n){\n    rep(j,m){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n        return true;\n    }\n  }\n  rep(i,(int)b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri,double d){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n        inedge[i].pb(j);\n        redge[j].pb(i);\n      }else {\n\trep(k,tri[j].size()){\n\t  if (is_in(tri[i],tri[j][k])&&\n\t      (distance_ss_p(sq[i][0],sq[i][1],tri[j][0],tri[j][1])<d+eps ||\n\t       distance_ss_p(sq[i][0],sq[i][1],tri[j][1],tri[j][2])<d+eps||\n\t       distance_ss_p(sq[i][0],sq[i][1],tri[j][2],tri[j][0])<d+eps)\n\t      ){\n\t    assert(false);\n\t    inedge[i].pb(j);\n\t    redge[j].pb(i);\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n        P tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    makegraph(n,sq,in,d);\n\n\n    //rep(i,n){rep(j,sq[i].size())cout<< sq[i][j];cout << endl;}\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct coor {\n\tdouble x, y;\n};\nstruct tri {\n\tcoor p[3];\n\tcoor rec[4];\n};\n\nint n, d;\nvector<tri> v;\nvector<vector<int> > edge;\n\nconst double EPS = 1e-9;\nconst double ERR = 1e-2;\n\ntemplate<class T>\nT sqr(T x) {\n\treturn x * x;\n}\n\ndouble dist(coor a, coor b) {\n\treturn sqrt(sqr(a.x-b.x) + sqr(a.y-b.y));\n}\n\ndouble dist_lp(coor c, coor a, coor b) {\n\tcoor v0, v1;\n\tv0.x = b.x - a.x; v0.y = b.y - a.y;\n\tv1.x = c.x - a.x; v1.y = c.y - a.y;\n\n\tif(sqr(dist(a,b)) + sqr(dist(a,c)) - sqr(dist(c,b)) > 0\n\t\t\t&& sqr(dist(a,b)) + sqr(dist(b,c)) - sqr(dist(c,a)) > 0) {\n\t\tdouble cross;\n\t\tcross = fabs(v0.x * v1.y - v0.y * v1.x);\n\t\treturn cross / dist(a,b);\n\t}\n\n\treturn min(dist(a,c), dist(b,c));\n}\n\nbool in_poly(coor p, coor poly[], int sz) {\n\tdouble sign = +0.0;\n\tfor(int i = 0; i < sz; i++) {\n\t\tcoor v0, v1;\n\t\tv0.x = poly[i].x - p.x; v0.y = poly[i].y - p.y;\n\t\tv1.x = poly[(i+1)%sz].x - p.x; v1.y = poly[(i+1)%sz].y - p.y;;\n\n\t\tif(i != 0 && sign * (v0.x * v1.y - v0.y * v1.x) < EPS) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tsign = (v0.x * v1.y - v0.y * v1.x);\n\n\t\tif(i == sz-1) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < sz; i++) {\n\t\tif(dist_lp(p,poly[i], poly[(i+1)%sz]) <= ERR + EPS) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool exist_edge(tri from, tri to) {\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(in_poly(to.p[i], from.rec, 4))\n\t\t\treturn true;\n\t}\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(in_poly(to.rec[i], from.p, 3))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool visited[128];\nbool touch[128];\n\nvoid check(int i, int s) {\n\tif(i != s && touch[i])\n\t\ttouch[i] = false;\n\tif(visited[i])\n\t\treturn;\n\tvisited[i] = true;\n\tfor(int j = 0; j < edge[i].size(); j++) {\n\t\tcheck(edge[i][j], s);\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> d, n || d) {\n\t\tv.clear();\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tvisited[i] = touch[i] = false;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttri in;\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tcoor c;\n\t\t\t\tcin >> c.x >> c.y;\n\t\t\t\tin.p[j] = c;\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tif(fabs(dist(in.p[(0+j)%3],in.p[(1+j)%3]) - dist(in.p[(1+j)%3], in.p[(2+j)%3])) < ERR) {\n\t\t\t\t\tswap(in.p[(1+j)%3], in.p[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcoor add;\n\t\t\tadd.x =\t(in.p[1].x - in.p[0].x) + (in.p[1].x - in.p[2].x);\n\t\t\tadd.y = (in.p[1].y - in.p[0].y) + (in.p[1].y - in.p[2].y);\n\n\t\t\tdouble addlen;\n\t\t\taddlen = sqrt(sqr(add.x) + sqr(add.y));\n\t\t\tadd.x = add.x * d / addlen;\n\t\t\tadd.y = add.y * d / addlen;\n\n\t\t\tin.rec[0].x = in.p[0].x; in.rec[0].y = in.p[0].y;\n\t\t\tin.rec[1].x = in.p[2].x; in.rec[1].y = in.p[2].y;\n\t\t\tin.rec[2].x = in.p[2].x + add.x; in.rec[2].y = in.p[2].y + add.y;\n\t\t\tin.rec[3].x = in.p[0].x + add.x; in.rec[3].y = in.p[0].y + add.y;\n\n\t\t\tv.push_back(in);\n\t\t}\n\n\t\tfor(int i = 0; i < v.size(); i++) {\n\t\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\t\tif(i != j) {\n\t\t\t\t\tif(exist_edge(v[i], v[j])) {\n\t\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint i_ = (i+5)%n;\n\t\t\tif(!visited[i_]) {\n\t\t\t\ttouch[i_] = true;\n\t\t\t\tcheck(i_, i_);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(touch[i])\n\t\t\t\tres++;\n\t\t}\n\t\tcout <<  res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(c)   (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n\nconst int N = 100;\n\n//graph part\nvector<int> edge[N];\nbool vis[N];\n\nint ord;\nvector<int> inedge[N];\nvector<int> redge[N];\nint component[N];\nstruct PO{\n  int order,num;\n};\nPO postorder[N];\n\nbool cmp(const PO&a,const PO&b){\n  return a.order > b.order;\n}\n\nvoid sccdfs(int now){\n  vis[now]=1;\n  rep(i,inedge[now].size()){\n    int next=inedge[now][i];\n    if (!vis[next])sccdfs(next);\n  }\n  postorder[now].order=ord++;\n  postorder[now].num=now;\n}\n\nvoid sccbfs(int ini,int comp){\n  queue<int> Q;\n  Q.push(ini);\n  vis[ini]=true;\n  component[ini]=comp;\n  while(!Q.empty()){\n    int now=Q.front();Q.pop();\n    component[now]=comp;\n    rep(i,redge[now].size()){\n      int next=redge[now][i];\n      if (!vis[next])Q.push(next),vis[next]=true;\n    }\n  }\n}\n\nint scc(int n){\n  ord=0;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])sccdfs(i);\n  }\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  sort(postorder,postorder+n,cmp);\n  rep(i,n){\n    int now = postorder[i].num;\n    if (vis[now])continue;\n    sccbfs(now,cnt);\n    cnt++;\n  }\n  return cnt;\n}\n\nvoid tsort(int now,vector<int> &a){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())tsort(edge[now][i],a);\n  a.pb(now);\n}\n\nvoid dfs(int now){\n  if (vis[now])return;\n  vis[now]=true;\n  rep(i,edge[now].size())dfs(edge[now][i]);\n}\n\nint solve(int n){\n\n  int tmpn=scc(n);\n  rep(i,n){\n    int me=component[i];\n    rep(j,inedge[i].size()){\n      int you=component[inedge[i][j]];\n      edge[me].pb(you);\n    }\n  }\n\n  n=tmpn;\n  vector<int> in;\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i])tsort(i,in);\n  }\n  reverse(ALL(in));\n  int cnt=0;\n  rep(i,n)vis[i]=false;\n  rep(i,in.size()){\n    if (!vis[in[i]])dfs(in[i]),cnt++;\n  }\n  return cnt;\n}\n\n\n//geometry part\ntypedef complex<double> P;\nconst double eps = 1e-8 ;\nvector<P> getpolygon(vector<P> a,double d){\n  int in[3]={0,1,2};\n  vector<P> ret;\n  do{\n    if (fabs(abs(a[in[2]]-a[in[1]])-abs(a[in[2]]-a[in[0]])) < eps){\n      P mid =(a[in[0]]+a[in[1]])/2.;\n      P tmp=a[in[2]]-mid;\n      tmp/=abs(tmp);\n      tmp*=d;\n      ret.pb(a[in[0]]);\n      ret.pb(a[in[1]]);\n      ret.pb(a[in[1]]+tmp);\n      ret.pb(a[in[0]]+tmp);\n      return ret;\n    }\n  }while(next_permutation(in,in+3));\n  assert(false);\n  return ret;\n}\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nbool isp(P a,P b,P c){\n  return abs(a-c)+abs(c-b) < abs(a-b)+eps;\n}\n\nbool is_in(vector<P> &in,P &a){\n  int cnt=0;\n  int n=in.size();\n  rep(i,n){\n    P cur=in[i]-a,next=in[(i+1)%n]-a;\n    if (cur.imag()>next.imag())swap(cur,next);\n    if (cur.imag()<0&&0<=next.imag()&&\n\tcross(next,cur) >= 0)cnt++;\n    if (isp(in[i],in[(i+1)%n],a))return true;\n  }\n  if (cnt %2 == 1)return true;\n  else return false;\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n  if (isp(a1,a2,b1)||isp(a1,a2,b2)||\n      isp(b1,b2,a1)||isp(b1,b2,a2))return true;\n  if (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) <eps &&\n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < eps)\n    return true;\n  else return false;\n}\n\nbool is_intersected_polygon(vector<P> &a,vector<P> &b){\n  int n = a.size();\n  int m = b.size();\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_intersected_ls(a[i],a[(i+1)%n],b[j],b[(j+1)%m]))\n\treturn true;\n    }\n  }\n  rep(i,b.size()){\n    if (is_in(a,b[i]))return true;\n  }\n  return false;\n}\n\nvoid makegraph(int n,vector<P> *sq,vector<P> *tri){\n  rep(i,n){\n    rep(j,n){\n      if (i == j)continue;\n      if (is_intersected_polygon(sq[i],tri[j])){\n\tinedge[i].pb(j);\n\tredge[j].pb(i);\n      }\n    }\n  }\n}\n\nmain(){\n  int n;\n  double d;\n  while(cin>>n>>d && n){\n    rep(i,n){\n      edge[i].clear();\n      inedge[i].clear();\n      redge[i].clear();\n    }\n    vector<P> in[n];\n    vector<P> sq[n];\n    rep(i,n){\n      rep(j,3){\n\tP tmp;cin>>tmp.real()>>tmp.imag();in[i].pb(tmp);\n      }\n      sq[i]=getpolygon(in[i],d);\n    }\n    \n    makegraph(n,sq,in);\n    \n    /*\n    cout <<\"inedge \" << endl;\n    rep(i,n){\n      cout << i<<\" : \";\n      rep(j,inedge[i].size())cout << inedge[i][j] <<\" \";cout << endl;\n    }\n    \n    cout <<\"rdge \" << endl;\n    rep(i,n){\n      cout << i <<\" : \";\n      rep(j,redge[i].size())cout << redge[i][j] <<\" \";cout << endl;\n    }\n    */\n\n    cout << solve(n) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<complex>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,a) for(int i=0;i<a;i++)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define pb push_back\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-8;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\nvector<int> g[110];\nvector<int> rg[110];\nvector<int> vs;\nbool use[110];\nint ord[110];\nint n,d;\nPoly tri[110];\nPoly rect[110];\n\nP unit(P p){return p/abs(p);}\nD dot(P x,P y){return real(conj(x)*y);}\nD cross(P x,P y){return imag(conj(x)*y);}\n\nvector<P> convex_hull(vector<P> v){\n  int n = v.size(), k = 0;\n  sort(v.begin(),v.end());\n  vector<P> r(2*n);\n  for(int i=0;i<n;i++){\n    while(k>1 && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= EPS)k--;\n    r[k++] = v[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t && cross(r[k-1]-r[k-2],v[i]-r[k-1]) <= EPS)k--;\n    r[k++] = v[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c)>EPS)return 1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return 2;\n  if(abs(b)<abs(c))return -2;\n  return 0;\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nbool inter_pos(Poly &p,P &x){\n  int s = p.size();\n  if(!s)return false;\n  rep(i,s)if(ccw(p[i],p[(i+1)%s],x)==-1)return false;\n  return true;\n}\n\nbool cross_poly(Poly &a, Poly &b){\n  int n1 = a.size(), n2 = b.size();\n  rep(i,n2)if(inter_pos(a,b[i]))return true;\n  rep(i,n1)if(inter_pos(b,a[i]))return true;\n  rep(i,n1)rep(j,n2)\n    if(is_cp(L(a[i],a[(i+1)%n1]),L(b[j],b[(j+1)%n2])))return true;\n  return false;\n}\n\nvoid fdfs(int v){\n  use[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    if(!use[g[v][i]])fdfs(g[v][i]);\n  }\n  vs.pb(v);\n}\n\nvoid rdfs(int v,int k){\n  use[v] = true;\n  ord[v] = k;\n  for(int i=0;i<rg[v].size();i++){\n    if(!use[rg[v][i]])rdfs(rg[v][i],k);\n  }\n}\n\nint scc(){\n  memset(use,0,sizeof(use));\n  vs.clear();\n  for(int i=0;i<n;i++){\n    if(!use[i])fdfs(i);\n  }\n\n  memset(use,0,sizeof(use));\n  int k = 0;\n  for(int i=vs.size()-1;i>=0;i--){\n    if(!use[vs[i]])rdfs(vs[i],k++);\n  }\n  return k;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&d), n+d){\n    rep(i,n){\n      tri[i].resize(3);\n      scanf(\"%lf%lf\",&tri[i][0].real(),&tri[i][0].imag());\n      scanf(\"%lf%lf\",&tri[i][1].real(),&tri[i][1].imag());\n      scanf(\"%lf%lf\",&tri[i][2].real(),&tri[i][2].imag());\n      tri[i] = convex_hull(tri[i]);\n\n      rect[i].clear();\n      rep(j,3){\n\tint n1 = (j+1)%3, n2 = (j+2)%3;\n\tif(EQ(abs(tri[i][n1]-tri[i][j]),abs(tri[i][n2]-tri[i][j]))){\n\t  rect[i].pb(tri[i][n1]); rect[i].pb(tri[i][n2]); break;\n\t}\n      }\n\n      P ver = (D)d*unit((rect[i][0]-rect[i][1])*P(0,-1));\n      rect[i].pb(ver+rect[i][1]); rect[i].pb(ver+rect[i][0]);\n      rect[i] = convex_hull(rect[i]);\n    }\n\n    rep(i,n){g[i].clear(); rg[i].clear();}\n    rep(i,n){\n      rep(j,n){\n\tif(i==j)continue;\n\tif(cross_poly(rect[i],tri[j])){g[i].pb(j); rg[j].pb(i);}\n      }\n    }\n\n\n    int cmp = scc();\n\n    int in[110] = {0};\n    rep(i,n){\n      rep(j,g[i].size())if(ord[g[i][j]] != ord[i])in[ord[g[i][j]]]++;\n    }\n  \n    int res = 0;\n    rep(i,cmp)if(!in[i])res++;\n    printf(\"%d\\n\",res);\n      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nstruct coor {\n\tdouble x, y;\n};\nstruct tri {\n\tcoor p[3];\n\tcoor rec[4];\n};\n\nint n, d;\nvector<tri> v;\nvector<vector<int> > edge;\n\nconst double EPS = 1e-9;\nconst double ERR = 1e-2;\n\ntemplate<class T>\nT sqr(T x) {\n\treturn x * x;\n}\n\ndouble dist(coor a, coor b) {\n\treturn sqrt(sqr(a.x-b.x) + sqr(a.y-b.y));\n}\n\ndouble dist_lp(coor c, coor a, coor b) {\n\tcoor v0, v1;\n\tv0.x = b.x - a.x; v0.y = b.y - a.y;\n\tv1.x = c.x - a.x; v1.y = c.y - a.y;\n\n\tif(sqr(dist(a,b)) + sqr(dist(a,c)) - sqr(dist(c,b)) > 0\n\t\t\t&& sqr(dist(a,b)) + sqr(dist(b,c)) - sqr(dist(c,a)) > 0) {\n\t\tdouble cross;\n\t\tcross = fabs(v0.x * v1.y - v0.y * v1.x);\n\t\treturn cross / dist(a,b);\n\t}\n\n\treturn min(dist(a,c), dist(b,c));\n}\n\nbool in_poly(coor p, coor poly[], int sz) {\n\tdouble sign = +0.0;\n\tfor(int i = 0; i < sz; i++) {\n\t\tcoor v0, v1;\n\t\tv0.x = poly[i].x - p.x; v0.y = poly[i].y - p.y;\n\t\tv1.x = poly[(i+1)%sz].x - p.x; v1.y = poly[(i+1)%sz].y - p.y;;\n\n\t\tif(i != 0 && sign * (v0.x * v1.y - v0.y * v1.x) < EPS) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tsign = (v0.x * v1.y - v0.y * v1.x);\n\n\t\tif(i == sz-1) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < sz; i++) {\n\t\tif(dist_lp(p,poly[i], poly[(i+1)%sz]) <= /*ERR*/ + EPS) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool seg_cross(coor a, coor b, coor c, coor d) {\n\tcoor v0, v1, v2;\n\t\n\tv0.x = a.x - c.x; v0.y = a.y - c.y;\n\tv1.x = b.x - c.x; v1.y = b.y - c.y;\n\tv2.x = d.x - c.x; v2.y = d.y - c.y;\n\n\tdouble s, t;\n\ts = (v0.x * v2.y - v0.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\tt = - (v1.x * v2.y - v1.y * v2.x) / (v0.x * v1.y - v0.y * v1.x);\n\n\tif(s + t > 1-EPS && s > -EPS && t > -EPS) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool exist_edge(tri from, tri to) {\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(in_poly(to.p[i], from.rec, 4)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor(int i = 0; i < 4; i++) {\n\t\tif(in_poly(from.rec[i], to.p, 3)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 3; i++) {\n\t\tfor(int j = 0; j < 4; j++) {\n\t\t\tif(seg_cross(to.p[i], to.p[(i+1)%3], from.rec[j], from.rec[(j+1)%4])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nbool visited[128];\nbool touch[128];\n\nvoid check(int i, int s) {\n\tif(i != s && touch[i])\n\t\ttouch[i] = false;\n\tif(visited[i])\n\t\treturn;\n\tvisited[i] = true;\n\tfor(int j = 0; j < (int)edge[i].size(); j++) {\n\t\tcheck(edge[i][j], s);\n\t}\n}\n\nint main() {\n\twhile(cin >> n >> d, n || d) {\n\t\tv.clear();\n\t\tedge.clear();\n\t\tedge.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tvisited[i] = touch[i] = false;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ttri in;\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tcoor c;\n\t\t\t\tcin >> c.x >> c.y;\n\t\t\t\tin.p[j] = c;\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < 3; j++) {\n\t\t\t\tif(fabs(dist(in.p[(0+j)%3],in.p[(1+j)%3]) - dist(in.p[(1+j)%3], in.p[(2+j)%3])) < EPS) {\n\t\t\t\t\tswap(in.p[(1+j)%3], in.p[1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcoor add;\n\t\t\tadd.x =\t(in.p[1].x - in.p[0].x) + (in.p[1].x - in.p[2].x);\n\t\t\tadd.y = (in.p[1].y - in.p[0].y) + (in.p[1].y - in.p[2].y);\n\n\t\t\tdouble addlen;\n\t\t\taddlen = sqrt(sqr(add.x) + sqr(add.y));\n\t\t\tadd.x = add.x * d / addlen;\n\t\t\tadd.y = add.y * d / addlen;\n\n\t\t\tin.rec[0].x = in.p[0].x; in.rec[0].y = in.p[0].y;\n\t\t\tin.rec[1].x = in.p[2].x; in.rec[1].y = in.p[2].y;\n\t\t\tin.rec[2].x = in.p[2].x + add.x; in.rec[2].y = in.p[2].y + add.y;\n\t\t\tin.rec[3].x = in.p[0].x + add.x; in.rec[3].y = in.p[0].y + add.y;\n\n\t\t\tv.push_back(in);\n\t\t}\n\n\t\tfor(int i = 0; i < (int)v.size(); i++) {\n\t\t\tfor(int j = 0; j < (int)v.size(); j++) {\n\t\t\t\tif(i != j) {\n\t\t\t\t\tif(exist_edge(v[i], v[j])) {\n\t\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\ttouch[i] = true;\n\t\t\t\tcheck(i, i);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(touch[i])\n\t\t\t\tres++;\n\t\t}\n\t\tcout <<  res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace geometry {\n\t// ???????????§??????\n\t\n\ttypedef complex<double> Point;\n\t\n\tstruct Segment {\n\t\tPoint p1, p2;\n\t\tSegment(const Point &p1 = Point(), const Point &p2 = Point()): p1(p1), p2(p2){}\n\t};\n\t\n\tstruct Circle {\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(const Point &p = Point(), double r = 0.0): p(p), r(r){}\n\t};\n\t\n\ttypedef Point Vector;\n\ttypedef Segment Line;\n\ttypedef vector<Point> Polygon;\n\t\n\t\n\t// ??\\??????\n\t\n\tinline istream & operator >> (istream &is, Point &p){\n\t\tdouble x, y;\n\t\tis >> x >> y;\n\t\tp.real(x), p.imag(y);\n\t\treturn is;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Segment &s){\n\t\treturn is >> s.p1 >> s.p2;\n\t}\n\t\n\tinline istream & operator >> (istream &is, Circle &c){\n\t\treturn is >> c.p >> c.r;\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Segment &s){\n\t\treturn os << \"{\" << s.p1 << \", \" << s.p2 << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Circle &c){\n\t\treturn os << \"{\" << c.p << \", \" << c.r << \"}\";\n\t}\n\t\n\tinline ostream & operator << (ostream &os, Polygon &g){\n\t\tos << \"{\";\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tif (i) os << \", \";\n\t\t\tos << g[i];\n\t\t}\n\t\treturn os << \"}\";\n\t}\n\t\n\t\n\t// ?????°, ??????\n\t\n\tconst double PI = acos(-1);\n\tconst double EPS = 1e-6;\n\tconst double INF = 1e16;\n\tconst int COUNTER_CLOCKWISE = 1;\n\tconst int CLOCKWISE \t\t= -1;\n\tconst int ONLINE_BACK\t\t= 2;\n\tconst int ONLINE_FRONT\t\t= -2;\n\tconst int ON_SEGMENT\t\t= 0;\n\tconst int OUT\t\t\t\t= 0;\n\tconst int ON\t\t\t\t= 1;\n\tconst int IN\t\t\t\t= 2;\n\t\n\tinline double square(double a){return a * a;}\n\tinline bool equal(double a, double b){return abs(a - b) < EPS;}\n\tinline bool equalVector(const Vector &a, const Vector &b){return equal(a.real(), b.real()) && equal(a.imag(), b.imag());}\n\tinline double norm(const Point &a){return square(a.real()) + square(a.imag());}\n\tinline double dot(const Point &a, const Point &b){return (conj(a) * b).real();}\n\tinline double cross(const Point &a, const Point &b){return (conj(a) * b).imag();}\n\tinline double toDeg(double t){return t / PI * 180;}\n\tinline double toRad(double t){return t / 180 * PI;}\n\t\n\t#define curr(v, i) v[i]\n\t#define next(v, i) v[(i + 1) % v.size()]\n\t#define prev(v, i) v[(i - 1 + v.size()) % v.size()]\n\t\n\t\n\t// ????????¢??° (x ??§?¨?, y ??§?¨?, ????§?)\n\t// ????§?????????????????????? Point rp ?????£??\\????????????\n\t\n\tbool cmpx(const Point &a, const Point &b){\n\t\tif (!equal(a.real(), b.real())) return a.real() < b.real();\n\t\treturn b.imag() < b.imag();\n\t}\n\t\n\tbool cmpy(const Point &a, const Point &b){\n\t\tif (!equal(a.imag(), b.imag())) return a.imag() < b.imag();\n\t\treturn a.real() < b.real();\n\t}\n\t\n\tPoint rp;\n\tbool cmparg(const Point &a, const Point &b){\n\t\tdouble rada = arg(a - rp); if (rada < 0.0) rada += 2 * PI;\n\t\tdouble radb = arg(b - rp); if (radb < 0.0) radb += 2 * PI;\n\t\tif (!equal(rada, radb)) return rada < radb;\n\t\treturn norm(a) < norm(b);\n\t}\n\t\n\t\n\t// ??´???, ??????\n\t\n\tbool orthgonal(const Vector &a, const Vector &b){\n\t\treturn equal(dot(a, b), 0.0);\n\t}\n\t\n\tbool parallel(const Vector &a, const Vector &b){\n\t\treturn equal(cross(a, b), 0.0);\n\t}\n\t\n\t\n\t// ????°?, ?°???±\n\t\n\tPoint project(const Segment &s, const Point &p){\n\t\tVector base = s.p2 - s.p1;\n\t\tdouble r = dot(p - s.p1, base) / norm(base);\n\t\treturn s.p1 + base * r;\n\t}\n\t\n\tPoint reflect(const Segment &s, const Point &p){\n\t\treturn p + (project(s, p) - p) * 2.0;\n\t}\n\t\n\t\n\t// ??????????????????\n\t\n\tint ccw(const Point &p0, const Point &p1, const Point &p2){\n\t\tVector a = p1 - p0;\n\t\tVector b = p2 - p0;\n\t\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t\tif (norm(a) > norm(b)) return ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\t\n\t// ?????¢\n\t\n\tdouble distanceLP(const Line &l, const Point &p){\n\t\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n\t}\n\t\n\tdouble distanceSP(const Segment &s, const Point &p){\n\t\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\t\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\t\treturn distanceLP(s, p);\n\t}\n\t\n\tbool intersect(const Segment &s1, const Segment &s2);\n\tdouble distance(const Segment &s1, const Segment &s2){\n\t\tif (intersect(s1, s2)) return 0.0;\n\t\treturn min(\n\t\t\tmin(distanceSP(s1, s2.p1), distance(s1, s2.p2)),\n\t\t\tmin(distanceSP(s2, s1.p1), distance(s2, s1.p2))\n\t\t);\n\t}\n\t\n\t\n\t// ????????????\n\t\n\tbool intersect(const Segment &s1, const Segment &s2){\n\t\treturn ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0;\n\t}\n\t\n\tint intersect(const Circle &c, const Segment &s){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = distanceSP(s, c.p) - c.r;\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\tint intersect(const Circle &c1, const Circle &c2){\n\t\t// ???????????° (0 ~ 2) ?????????\n\t\tdouble dist = abs(c1.p - c2.p) - (c1.r + c2.r);\n\t\tif (equal(dist, 0.0)) return 1;\n\t\tif (dist < 0.0) return 2;\n\t\treturn 0;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPoint crossPoint(const Segment &s1, const Segment &s2){\n\t\tVector base = s2.p2 - s2.p1;\n\t\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\t\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\t\t\n\t\t// !! ????????´?????¶????????????????????\\????????¨ 0 ?????? !!\n\t\tassert(!equal(d1 + d2, 0.0));\n\t\t\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c, const Line &l){\n\t\tvector<Point> res;\n\t\tif (!intersect(c, l)) return res;\n\t\t\n\t\tVector pr = project(l, c.p);\n\t\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\t\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\t\tres.push_back(pr + e * base);\n\t\tres.push_back(pr - e * base);\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t\treturn res;\n\t}\n\t\n\tvector<Point> crossPoints(const Circle &c1, const Circle &c2){\n\t\tvector<Point> res;\n\t\tif (!intersect(c1, c2)) return res;\n\t\t\n\t\tdouble d = abs(c1.p - c2.p);\n\t\tdouble a = acos(square(c1.r) + square(d) - square(c2.r) / (2 * c2.r * d));\n\t\tdouble t = arg(c2.p - c1.p);\n\t\tres.push_back(c1.p + polar(c1.r, t + a));\n\t\tres.push_back(c1.p + polar(c1.r, t - a));\n\t\tif (equalVector(res[0], res[1])) res.pop_back();\n\t}\n\t\n\t\n\t// ??????\n\t\n\tint contains(const Polygon &g, const Point &p){\n\t\tint n = g.size();\n\t\tbool res = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tPoint a = g[i] - p;\n\t\t\tPoint b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) res = !res;\n\t\t}\n\t\treturn res ? IN : OUT;\n\t}\n\t\n\t\n\t// ??????\n\t\n\tPolygon convexHull(vector<Point> s){\n\t\tPolygon u, l;\n\t\tif (s.size() < 3) return s;\n\t\tsort(s.begin(), s.end());\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\t\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tint n = u.size();\n\t\t\twhile (n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tu.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\t\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tint n = l.size();\n\t\t\twhile (n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE){\n\t\t\t\tl.pop_back();\n\t\t\t\tn--;\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\t\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\t\n\t\treturn l;\n\t}\n\t\n\t\n\t// ???????§???¢??????\n\t\n\tPolygon convexCut(const Polygon &g, const Line &l){\n\t\tPolygon res;\n\t\tfor (int i = 0; i < g.size(); i++){\n\t\t\tconst Point &a = curr(g, i);\n\t\t\tconst Point &b = next(g, i);\n\t\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE){\n\t\t\t\tres.push_back(a);\n\t\t\t}\n\t\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\t\tres.push_back(crossPoint(Line(a, b), l));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}\n\nnamespace std {\n\tbool operator < (const geometry::Point &a, const geometry::Point &b){\n\t\treturn geometry::cmpx(a, b);\n\t}\n}\n\n\nusing namespace geometry;\n\nbool intersect(const Polygon &g, const Polygon &h)\n{\n\tfor (int i = 0; i < g.size(); i++){\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tSegment u(curr(g, i), next(g, i));\n\t\t\tSegment v(curr(h, j), next(h, j));\n\t\t\tif (intersect(u, v)) return true;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tif (contains(h, g[i])) return true;\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tif (contains(g, h[i])) return true;\n\t}\n\t\n\tfor (int i = 0; i < g.size(); i++){\n\t\tSegment s(curr(g, i), next(g, i));\n\t\tfor (int j = 0; j < h.size(); j++){\n\t\t\tif (distanceSP(s, h[j]) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < h.size(); i++){\n\t\tSegment s(curr(h, i), next(h, i));\n\t\tfor (int j = 0; j < g.size(); j++){\n\t\t\tif (distanceSP(s, g[j]) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\treturn false;\n}\n\n\nint n;\ndouble d;\nPolygon tri[100];\nPolygon sqr[100];\nvector<int> graph[100];\nvector<int> rgraph[100];\n\nvoid dfs(int v, vector<int> &vs, vector<bool> &used)\n{\n\tused[v] = true;\n\tfor (int to : graph[v]){\n\t\tif (!used[to]) dfs(to, vs, used);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k, vector<bool> &used, vector<int> &cmp)\n{\n\tused[v] = true;\n\tcmp[v] = k;\n\tfor (int to : rgraph[v]){\n\t\tif (!used[to]) rdfs(to, k, used, cmp);\n\t}\n}\n\nvector<vector<int>> scc(vector<int> &cmp)\n{\n\tvector<int> vs;\n\tvector<bool> used(n, false);\n\tcmp.resize(n);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) dfs(i, vs, used);\n\t}\n\t\n\tused.assign(n, false);\n\t\n\tint k = 0;\n\tfor (int i = vs.size() - 1; i >= 0; i--){\n\t\tif (!used[vs[i]]) rdfs(vs[i], k++, used, cmp);\n\t}\n\t\n\tvector<vector<int>> res(k);\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : graph[i]){\n\t\t\tif (cmp[i] == cmp[to]) continue;\n\t\t\tres[cmp[i]].push_back(cmp[to]);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint solve()\n{\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < 3; j++){\n\t\t\tPoint &a = curr(tri[i], j);\n\t\t\tPoint &b = prev(tri[i], j);\n\t\t\tPoint &c = next(tri[i], j);\n\t\t\tif (equal(norm(b - a), norm(c - a))){\n\t\t\t\tswap(a, tri[i][2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tsqr[i].resize(4);\n\t\t\n\t\tvector<Vector> V = {{0, 1}, {0, -1}};\n\t\tfor (auto &v : V){\n\t\t\tVector a = tri[i][1] - tri[i][0];\n\t\t\tVector nv = a / abs(a) * v * d;\n\t\t\t\n\t\t\tif (dot(tri[i][2] - tri[i][0], nv) < 0.0) continue;\n\t\t\t\n\t\t\tsqr[i][0] = tri[i][0];\n\t\t\tsqr[i][1] = tri[i][1];\n\t\t\tsqr[i][2] = tri[i][1] + nv;\n\t\t\tsqr[i][3] = tri[i][0] + nv;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tgraph[i].clear();\n\t\trgraph[i].clear();\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (intersect(sqr[i], tri[j])){\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\trgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> cmp;\n\tvector<vector<int>> sccgraph = scc(cmp);\n\t\n\tvector<int> indeg(sccgraph.size(), 0);\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tfor (int to : sccgraph[i]){\n\t\t\tif (i == to) continue;\n\t\t\tindeg[to]++;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\t\n\tfor (int i = 0; i < sccgraph.size(); i++){\n\t\tif (indeg[i] == 0){\n\t\t\tres++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n >> d, n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\ttri[i].resize(3);\n\t\t\tfor (int j = 0; j < 3; j++){\n\t\t\t\tcin >> tri[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n\nenum CCW{FRONT=0x01,RIGHT=0x02,BACK=0x04,LEFT=0x08,OVER=0x10};\nenum CIRCLE_RELATION{CIRCLE_SAME=0x01,CIRCLE_CONTAIN=0x02,\n\t\t     CIRCLE_NO_CROSS=0x04,CIRCLE_ONE_CROSS=0x08,\n\t\t     CIRCLE_ONE_INSIDE_CROSS=0x10,CIRCLE_TWO_CROSS=0x20};\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n\nconst double infty = 1e40;\nconst double eps = 1e-8;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\n\nbool far(point a, point b){ return abs(b-a)>0; }\nbool near(point a, point b){ return abs(b-a)<=0; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( dot(s.sc-s.fr,x-s.fr)<0 ) return abs(x-s.fr);\n  if( dot(s.fr-s.sc,x-s.sc)<0 ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\ninline int ccw(const point &a, point b, point x){\n  b -= a;\n  x -= a;\n  if( eq(cross(b,x),0.0) && dot(b,x) < 0 ) return BACK;\n  if( eq(cross(b,x),0.0) && abs(b) < abs(x) ) return FRONT;\n  if( eq(cross(b,x),0.0) ) return OVER;\n  if( cross(b,x) > 0 ) return LEFT;\n  if( cross(b,x) < 0 ) return RIGHT;\n}\n\ninline bool intersectedSS(const seg &a, const seg &b)\n{\n  int cwaf=ccw(a.fr,a.sc,b.fr);\n  int cwbf=ccw(b.fr,b.sc,a.fr);\n  int cwas=ccw(a.fr,a.sc,b.sc);\n  int cwbs=ccw(b.fr,b.sc,a.sc);\n  if( cwaf==OVER || cwas==OVER || cwbf==OVER || cwbs==OVER ) return true;\n  return ( cwaf | cwas ) == (LEFT|RIGHT) && ( cwbf | cwbs ) == (LEFT|RIGHT);\n}\n\n/* ツ三ツ角ツ形 */\nstruct triangle{\n  vector<point> p;\n  triangle():p(3,point(0,0)){}\n  triangle(point a,point b,point c){p.push_back(a);p.push_back(b);p.push_back(c);}\n  bool inside(const point &t)const{\n    int ccw01=ccw(p[0],p[1],t),ccw02=ccw(p[1],p[2],t),ccw03=ccw(p[2],p[0],t);\n    return ccw01==ccw02&&ccw02==ccw03;\n  }\n  bool contain(const point &t)const{\n    int ccw01=ccw(p[0],p[1],t),ccw02=ccw(p[1],p[2],t),ccw03=ccw(p[2],p[0],t);\n    if((ccw01|ccw02|ccw03)&OVER)return true;\n    else return ccw01==ccw02&&ccw02==ccw03;\n  }\n};\n\n/* ツ凝ゥツ形 */\nstruct rectangle{\n  vector<point> p;\n  rectangle():p(4,point(0,0)){}\n  rectangle(point a, point b, point c, point d){\n    p.push_back(a);  p.push_back(b);  p.push_back(c);  p.push_back(d);\n  }\n  bool inside(const point &t)const{\n    int ccw01=ccw(p[0],p[1],t),ccw02=ccw(p[1],p[2],t),ccw03=ccw(p[2],p[0],t);\n    return ccw01==ccw02&&ccw02==ccw03;\n  }\n  bool contain(const point &t)const{\n    int ccw01=ccw(p[0],p[1],t),ccw02=ccw(p[1],p[2],t),ccw03=ccw(p[2],p[3],t),ccw04=ccw(p[3],p[0],t);\n    if((ccw01|ccw02|ccw03|ccw04)&OVER)return true;\n    else return ccw01==ccw02&&ccw02==ccw03&&ccw03==ccw04;\n  }\n  bool rayReach(const triangle &t){ // t : traignle\n    for(int i = 0; i < (int)t.p.size(); ++i){\n      if( this->contain(t.p[i]) ) return true;\n    }\n    for(int i = 0; i < 4; ++i){\n      seg s(p[i],p[(i+1)%4]);\n      for(int j = 0; j < (int)t.p.size(); ++j){\n\tseg ss(t.p[j],t.p[(j+1)%t.p.size()]);\n\tif( intersectedSS( s, ss ) ) return true;\n      }\n    }\n    return false;\n  }\n};\n\nrectangle touch(triangle t, elem d)\n{\n  rectangle ret;\n  elem da=abs(t.p[0]-t.p[1]);\n  elem db=abs(t.p[1]-t.p[2]);\n  elem dc=abs(t.p[2]-t.p[0]);\n  \n  if(eq(da,db)){\n    vec v=d*uvec( t.p[1] - (t.p[2]+t.p[0])/2.0 );\n    ret.p[0]=t.p[2]+v;\n    ret.p[1]=t.p[2];\n    ret.p[2]=t.p[0];\n    ret.p[3]=t.p[0]+v;\n  }else if(eq(da,dc)){\n    vec v=d*uvec( t.p[0] - (t.p[1]+t.p[2])/2.0 );\n    ret.p[0]=t.p[1]+v;\n    ret.p[1]=t.p[1];\n    ret.p[2]=t.p[2];\n    ret.p[3]=t.p[2]+v;\n  }else if(eq(db,dc)){\n    vec v=d*uvec( t.p[2] - (t.p[0]+t.p[1])/2.0 );\n    ret.p[0]=t.p[0]+v;\n    ret.p[1]=t.p[0];\n    ret.p[2]=t.p[1];\n    ret.p[3]=t.p[1]+v;\n  }\n  return ret;\n}\n\nstruct Node{\n  vector<int> con;\n};\n\ntypedef vector<Node> Graph;\n\nvoid visit(const Graph &g, int v, vector< vector<int> > &scc,\n\t   stack<int> &S, vector<int> &inS,\n\t   vector<int> &low, vector<int> &num, int &time)\n{\n  low[v] = num[v] = ++time;\n  S.push(v);\n  inS[v]=1;\n  for(int i = 0; i < (int)g[v].con.size(); ++i){\n    int w=g[v].con[i];\n    if(num[w]==0){\n      visit(g,w,scc,S,inS,low,num,time);\n      low[v]=min(low[v],low[w]);\n    }else if(inS[w])\n      low[v]=min(low[v],num[w]);\n  }\n  if(low[v]==num[v]){\n    scc.push_back(vector<int>());\n    while(true){\n      int w=S.top(); S.pop(); inS[w]=0;\n      scc.back().push_back(w);\n      if( v == w ) break;\n    }\n  }\n}\nvoid stronglyConnectedComponents(const Graph &g, vector< vector<int> > &scc)\n{\n  int n = g.size();\n  vector<int> num(n),low(n);\n  stack<int> S;\n  vector<int> inS(n);\n  int time=0;\n  for(int i=0;i<n;++i){\n    if(num[i]==0)\n      visit(g,i,scc,S,inS,low,num,time);\n  }\n}\n\nint solve(const vector<triangle> &vt, elem d)\n{\n  Graph G;\n\n  for(int i = 0; i < (int)vt.size(); ++i){\n    Node node;\n    for(int j = 0; j < (int)vt.size(); ++j){\n      if( i != j ){\n\trectangle R = touch(vt[i],d);\n\tif( R.rayReach( vt[j] ) ){\n\t  node.con.push_back(j);\n\t}\n      }else\n\tnode.con.push_back(j);\n    }\n    G.push_back(node);\n  }\n  \n  vector< vector<int> > scc;\n  stronglyConnectedComponents( G, scc );\n\n  int in[scc.size()];\n  for(int i = 0; i < (int)scc.size(); ++i){\n    in[i] = 0;\n  }\n  Graph DAG;\n  for(int i = 0; i < (int)scc.size(); ++i){\n    Node node;\n    for(int ii = 0; ii < (int)scc[i].size(); ++ii){\n      int from = scc[i][ii];\n      for(int j = 0; j < (int)scc.size(); ++j){\n\tif(i!=j){\n\t  for(int jj = 0; jj < (int)scc[j].size(); ++jj){\n\t    int to = scc[j][jj];\n\t    for(int k = 0; k < (int)G[from].con.size(); ++k){\n\t      if( G[from].con[k] == to ){\n\t\tnode.con.push_back(j);\n\t\tin[j]++;\n\t\tgoto next;\n\t      }\n\t    }\n\t  }\n\tnext:;\n\t}\n      }\n    }\n    DAG.push_back(node);\n  }\n\n  int ret = 0;\n  for(int i = 0; i < (int)DAG.size(); ++i){\n    if( in[i] == 0 ) ++ret;\n  }\n  return ret;\n}\n\nint main(){\n  while(true){\n    int n;\n    elem d;\n    vector<triangle> vt;\n    scanf(\"%d%lf\", &n, &d);\n    if(n==0)break;\n    for(int i = 0; i < n; ++i){\n      double x1,y1,x2,y2,x3,y3;\n      scanf(\"%lf%lf%lf%lf%lf%lf\", &x1, &y1, &x2, &y2, &x3, &y3);\n      point ta(x1,y1),tb(x2,y2),tc(x3,y3);\n      vt.push_back(triangle(ta,tb,tc));\n    }\n    int res = solve( vt, d );\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0237: The Last Door\n// 2018.2.21 bal4u\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define EPS 1e-8\ntypedef struct { double x, y; } PP;\nPP  t[101][5];\nint n, d;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\n#define COUNTER_CLOCKWISE\t 1\n#define CLOCKWISE\t\t\t-1\n#define ONLINE_BACK\t\t\t 2\n#define ONLINE_FRONT\t\t-2\n#define ON_SEG\t\t\t\t 0\n\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\n\nint ccw(PP p0, PP p1, PP p2)\n{\n\tPP a, b;\n\tdouble t;\n\n\ta.x = p1.x - p0.x, a.y = p1.y - p0.y;\n\tb.x = p2.x - p0.x, b.y = p2.y - p0.y;\n\tt = cross(a, b);\n\tif (t >  EPS) return COUNTER_CLOCKWISE;\n\tif (t < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEG;\n}\n\nvoid swap(PP *a, PP *b) { PP t = *a; *a = *b, *b = t; }\n\nvoid normalize()\n{\n\tint i;\n\tPP a, b;\n\tdouble w;\n\n\tfor (i = 0; i < n; i++) {\n\t\ta.x = t[i][1].x - t[i][0].x, a.y = t[i][1].y - t[i][0].y;\n\t\tb.x = t[i][1].x - t[i][2].x, b.y = t[i][1].y - t[i][2].y;\n\t\tif (fabs(norm(a)-norm(b)) < EPS) swap(&t[i][0], &t[i][1]);\n\t\ta.x = t[i][0].x - t[i][2].x, a.y = t[i][0].y - t[i][2].y;\n\t\tif (fabs(norm(a)-norm(b)) < EPS) swap(&t[i][0], &t[i][2]);\n\t\tif (ccw(t[i][0], t[i][1], t[i][2]) != COUNTER_CLOCKWISE) swap(&t[i][1], &t[i][2]);\n\t\ta.x = (t[i][1].x + t[i][2].x) / 2.0, a.y = (t[i][1].y + t[i][2].y) / 2.0;\n\t\tb.x = t[i][0].x - a.x, b.y = t[i][0].y - a.y;\n\t\tw = d / norm(b);\n\t\tt[i][3].x = t[i][2].x + w*b.x, t[i][3].y = t[i][2].y + w*b.y;\n\t\tt[i][4].x = t[i][1].x + w*b.x, t[i][4].y = t[i][1].y + w*b.y;\n\t}\n}\n\nint isIntersect(PP p1, PP p2, PP p3, PP p4)\n{\n\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\n\nint isInside(PP p, PP *gon, int sz)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sz; i++) {\n\t\tj = i+1; if (j == sz) j = 0;\n\t\tif (ccw(gon[i], gon[j], p) == CLOCKWISE ) return 0;\n\t}\n\treturn 1;\n}\n\nint check(int a, int b)\n{\n\tint i, j, ii, jj;\n\n\tfor (i = 1; i <= 4; i++) if (isInside(t[a][i], t[b], 3)) return 1;\n\tfor (i = 0; i < 3; i++) if (isInside(t[b][i], t[a]+1, 4)) return 1;\n\tfor (i = 1; i <= 4; i++) {\n\t\tii = i+1; if (ii == 5) ii = 1;\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tjj = j+1; if (jj == 3) jj = 0;\n\t\t\tif (isIntersect(t[a][i], t[a][ii], t[b][j], t[b][jj])) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n// SCC (Strongly connected components) library\n#define MAX 101\nint g_to[MAX][MAX], g_hi[MAX];\nint r_to[MAX][MAX], r_hi[MAX];\nint ord[MAX], gr[MAX], cnt;\nchar mk[MAX];\n\nvoid addEdge(int s, int d) { g_to[s][g_hi[s]++] = d, r_to[d][r_hi[d]++] = s; }\nvoid dfs(int v) { int i;\n\tmk[v] = 1; for (i = 0; i < g_hi[v]; i++) if (!mk[g_to[v][i]]) dfs(g_to[v][i]); ord[cnt++] = v;\n}\nvoid rdfs(int v, int k) { int i;\n\tmk[v] = 1, gr[v] = k; for (i = 0; i < r_hi[v]; i++) if (!mk[r_to[v][i]]) rdfs(r_to[v][i], k);\n}\n\nint scc() {\tint i, j, k, ans;\n\tmemset(mk, 0, sizeof(mk));\n\tcnt = 0; for (i = 0; i < n; i++) if (!mk[i]) dfs(i);\n\n\tk = 0; memset(mk, 0, sizeof(mk));\n\tfor (i = n-1; i >= 0; i--) if (!mk[ord[i]]) rdfs(ord[i], k++);\n\n\tans = k;\n\tmemset(mk, 0, sizeof(mk));\n\tfor (i = 0; i < n; i++) for (j = 0; j < g_hi[i]; j++) {\n\t\tif (gr[i] != gr[g_to[i][j]]) { ans -= (1 ^ mk[gr[g_to[i][j]]]), mk[gr[g_to[i][j]]] = 1; }\n\t}\n\treturn ans;\n}\n/// SCC above\n\nint main()\n{\n\tint i, j;\n\n\twhile (n = in()) {\n\t\td = in();\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < 3; j++)\tt[i][j].x = in(), t[i][j].y = in();\n\t\t}\n\t\tnormalize();\n\n\t\tmemset(g_hi, 0, sizeof(g_hi)), memset(r_hi, 0, sizeof(r_hi));\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < n; j++) if (i != j) {\n\t\t\tif (check(i, j)) addEdge(i, j);\n\t\t}\t\n\t\tprintf(\"%d\\n\", scc());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0237: The Last Door\n// 2018.2.21 bal4u\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <ctype.h>\n\n#define EPS 0.01\ntypedef struct { double x, y; } PP;\nPP  t[101][5];\nint n, d;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\twhile (!isdigit(c)) c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\n#define COUNTER_CLOCKWISE\t 1\n#define CLOCKWISE\t\t\t-1\n#define ONLINE_BACK\t\t\t 2\n#define ONLINE_FRONT\t\t-2\n#define ON_SEG\t\t\t\t 0\n\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\n\nint ccw(PP p0, PP p1, PP p2)\n{\n\tPP a, b;\n\tdouble t;\n\n\ta.x = p1.x - p0.x, a.y = p1.y - p0.y;\n\tb.x = p2.x - p0.x, b.y = p2.y - p0.y;\n\tt = cross(a, b);\n\tif (t >  EPS) return COUNTER_CLOCKWISE;\n\tif (t < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEG;\n}\n\nvoid swap(PP *a, PP *b) { PP t = *a; *a = *b, *b = t; }\n\nvoid normalize()\n{\n\tint i;\n\tPP a, b;\n\tdouble w;\n\n\tfor (i = 0; i < n; i++) {\n\t\ta.x = t[i][1].x - t[i][0].x, a.y = t[i][1].y - t[i][0].y;\n\t\tb.x = t[i][1].x - t[i][2].x, b.y = t[i][1].y - t[i][2].y;\n\t\tif (fabs(norm(a)-norm(b)) < EPS) swap(&t[i][0], &t[i][1]);\n\t\ta.x = t[i][0].x - t[i][2].x, a.y = t[i][0].y - t[i][2].y;\n\t\tif (fabs(norm(a)-norm(b)) < EPS) swap(&t[i][0], &t[i][2]);\n\t\tif (ccw(t[i][0], t[i][1], t[i][2]) != COUNTER_CLOCKWISE) swap(&t[i][1], &t[i][2]);\n\t\ta.x = (t[i][1].x + t[i][2].x)/2, a.y = (t[i][1].y + t[i][2].y)/2;\n\t\tb.x = t[i][0].x - a.x, b.y = t[i][0].y - a.y;\n\t\tw = d / sqrt(norm(b));\n\t\tt[i][3].x = t[i][2].x + w*b.x, t[i][3].y = t[i][2].y + w*b.y;\n\t\tt[i][4].x = t[i][1].x + w*b.x, t[i][4].y = t[i][1].y + w*b.y;\n\t}\n}\n\nint isIntersect(PP p1, PP p2, PP p3, PP p4)\n{\n\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\n\nint isInside(PP p, PP *gon, int sz)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sz; i++) {\n\t\tj = i+1; if (j == sz) j = 0;\n\t\tif (ccw(gon[i], gon[j], p) == CLOCKWISE ) return 0;\n\t}\n\treturn 1;\n}\n\nint check(int a, int b)\n{\n\tint i, j, ii, jj;\n\n\tfor (i = 1; i <= 4; i++) if (isInside(t[a][i], t[b], 3)) return 1;\n\tfor (i = 0; i < 3; i++) if (isInside(t[b][i], t[a]+1, 4)) return 1;\n\tfor (i = 1; i <= 4; i++) {\n\t\tii = i+1; if (ii == 5) ii = 1;\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tjj = j+1; if (jj == 3) jj = 0;\n\t\t\tif (isIntersect(t[a][i], t[a][ii], t[b][j], t[b][jj])) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n// SCC (Strongly connected components) library\n#define MAX 101\nint g_to[MAX][MAX], g_hi[MAX];\nint r_to[MAX][MAX], r_hi[MAX];\nint ord[MAX], gr[MAX], cnt;\nchar mk[MAX];\n\nvoid dfs(int v) { int i;\n\tmk[v] = 1; for (i = 0; i < g_hi[v]; i++) if (!mk[g_to[v][i]]) dfs(g_to[v][i]); ord[cnt++] = v;\n}\nvoid rdfs(int v, int k) { int i;\n\tmk[v] = 1, gr[v] = k; for (i = 0; i < r_hi[v]; i++) if (!mk[r_to[v][i]]) rdfs(r_to[v][i], k);\n}\n\nint scc() {\tint i, j, k, ans;\n\tmemset(mk, 0, sizeof(mk));\n\tcnt = 0; for (i = 0; i < n; i++) if (!mk[i]) dfs(i);\n\n\tk = 0; memset(mk, 0, sizeof(mk));\n\tfor (i = n-1; i >= 0; i--) if (!mk[ord[i]]) rdfs(ord[i], k++);\n\n\tans = k;\n\tmemset(mk, 0, sizeof(mk));\n\tfor (i = 0; i < n; i++) for (j = 0; j < g_hi[i]; j++) {\n\t\tk = g_to[i][j];\n\t\tif (gr[i] != gr[k]) { ans -= 1 ^ mk[gr[k]], mk[gr[k]] = 1; }\n\t}\n\treturn ans;\n}\n/// SCC above\n\nint main()\n{\n\tint i, j;\n\n\twhile (n = in()) {\n\t\td = in();\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < 3; j++)\tt[i][j].x = in(), t[i][j].y = in();\n\t\t}\n\t\tnormalize();\n\n\t\tmemset(g_hi, 0, sizeof(g_hi)), memset(r_hi, 0, sizeof(r_hi));\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < n; j++) if (i != j) {\n\t\t\tif (check(i, j)) g_to[i][g_hi[i]++] = j, r_to[j][r_hi[j]++] = i;\n\t\t}\t\n\t\tprintf(\"%d\\n\", scc());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0237: The Last Door\n// 2018.2.21 bal4u\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <ctype.h>\n\n#define MAX 102\n#define EPS 0.01\n\ntypedef struct { double x, y; } PP;\nPP  t[MAX][5];\nint n, d;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tif (c == '-') {\n\t\tc = getchar_unlocked();\n\t\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\t\twhile (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\n#define COUNTER_CLOCKWISE\t 1\n#define CLOCKWISE\t\t\t-1\n#define ONLINE_BACK\t\t\t 2\n#define ONLINE_FRONT\t\t-2\n#define ON_SEG\t\t\t\t 0\n\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\n\nint ccw(PP p0, PP p1, PP p2)\n{\n\tPP a, b;\n\tdouble t;\n\n\ta.x = p1.x - p0.x, a.y = p1.y - p0.y;\n\tb.x = p2.x - p0.x, b.y = p2.y - p0.y;\n\tt = cross(a, b);\n\tif (t >  EPS) return COUNTER_CLOCKWISE;\n\tif (t < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEG;\n}\n\nvoid swap(PP *a, PP *b) { PP t = *a; *a = *b, *b = t; }\n\nvoid normalize()\n{\n\tint i;\n\tPP a, b;\n\tdouble w;\n\n\tfor (i = 0; i < n; i++) {\n\t\ta.x = t[i][1].x - t[i][0].x, a.y = t[i][1].y - t[i][0].y;\n\t\tb.x = t[i][1].x - t[i][2].x, b.y = t[i][1].y - t[i][2].y;\n\t\tif (fabs(norm(a)-norm(b)) < EPS) swap(&t[i][0], &t[i][1]);\n\t\ta.x = t[i][0].x - t[i][2].x, a.y = t[i][0].y - t[i][2].y;\n\t\tif (fabs(norm(a)-norm(b)) < EPS) swap(&t[i][0], &t[i][2]);\n\t\tif (ccw(t[i][0], t[i][1], t[i][2]) != COUNTER_CLOCKWISE) swap(&t[i][1], &t[i][2]);\n\t\ta.x = (t[i][1].x + t[i][2].x)/2, a.y = (t[i][1].y + t[i][2].y)/2;\n\t\tb.x = t[i][0].x - a.x, b.y = t[i][0].y - a.y;\n\t\tw = d / sqrt(norm(b));\n\t\tt[i][3].x = t[i][2].x + w*b.x, t[i][3].y = t[i][2].y + w*b.y;\n\t\tt[i][4].x = t[i][1].x + w*b.x, t[i][4].y = t[i][1].y + w*b.y;\n\t}\n}\n\nint isIntersect(PP p1, PP p2, PP p3, PP p4)\n{\n\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\n\nint isInside(PP p, PP *gon, int sz)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sz; i++) {\n\t\tj = i+1; if (j == sz) j = 0;\n\t\tif (ccw(gon[i], gon[j], p) == CLOCKWISE ) return 0;\n\t}\n\treturn 1;\n}\n\nint check(int a, int b)\n{\n\tint i, j, ii, jj;\n\n\tfor (i = 1; i <= 4; i++) if (isInside(t[a][i], t[b], 3)) return 1;\n\tfor (i = 0; i < 3; i++) if (isInside(t[b][i], t[a]+1, 4)) return 1;\n\tfor (i = 1; i <= 4; i++) {\n\t\tii = i+1; if (ii == 5) ii = 1;\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tjj = j+1; if (jj == 3) jj = 0;\n\t\t\tif (isIntersect(t[a][i], t[a][ii], t[b][j], t[b][jj])) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n// SCC (Strongly connected components) library\nint g_to[MAX][MAX], g_hi[MAX];\nint r_to[MAX][MAX], r_hi[MAX];\nint ord[MAX], cmp[MAX], cnt;\nchar mk[MAX];\n\nvoid dfs(int v) { int i;\n\tmk[v] = 1; for (i = 0; i < g_hi[v]; i++) if (!mk[g_to[v][i]]) dfs(g_to[v][i]); ord[cnt++] = v;\n}\nvoid rdfs(int v, int k) { int i;\n\tmk[v] = 1, cmp[v] = k; for (i = 0; i < r_hi[v]; i++) if (!mk[r_to[v][i]]) rdfs(r_to[v][i], k);\n}\n\nint scc() {\tint i, k;\n\tmemset(mk, 0, sizeof(mk));\n\tcnt = 0; for (i = 0; i < n; i++) if (!mk[i]) dfs(i);\n\tk = 0; memset(mk, 0, sizeof(mk));\n\tfor (i = cnt-1; i >= 0; i--) if (!mk[ord[i]]) rdfs(ord[i], k++);\n\treturn k;\n}\n/// SCC above\n\nint main()\n{\n\tint i, j, k, ans;\n\n\twhile (n = in()) {\n\t\td = in();\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < 3; j++)\tt[i][j].x = in(), t[i][j].y = in();\n\t\t}\n\t\tnormalize();\n\n\t\tmemset(g_hi, 0, sizeof(g_hi)), memset(r_hi, 0, sizeof(r_hi));\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < n; j++) if (i != j) {\n\t\t\tif (check(i, j)) g_to[i][g_hi[i]++] = j, r_to[j][r_hi[j]++] = i;\n\t\t}\n\t\t\n\t\tk = scc();\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < g_hi[i]; j++) {\n\t\t\tif (cmp[i] != cmp[g_to[i][j]]) mk[cmp[g_to[i][j]]] = 1;\n\t\t}\n\t\tans = 0; for (i = 0; i < k; i++) if (!mk[i]) ans++;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0237: The Last Door\n// 2018.2.21 bal4u\n\n#include <stdio.h>\n//#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define EPS 1e-8\ntypedef struct { double x, y; } PP;\nPP  t[101][5];\nint n, d;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\n#define COUNTER_CLOCKWISE\t 1\n#define CLOCKWISE\t\t\t-1\n#define ONLINE_BACK\t\t\t 2\n#define ONLINE_FRONT\t\t-2\n#define ON_SEG\t\t\t\t 0\n\ndouble cross(PP a, PP b) { return a.x*b.y - a.y*b.x; }\ndouble dot(PP a, PP b) { return a.x*b.x + a.y*b.y; }\ndouble norm(PP a) { return a.x*a.x + a.y*a.y; }\n\nint ccw(PP p0, PP p1, PP p2)\n{\n\tPP a, b;\n\tdouble t;\n\ta.x = p1.x - p0.x, a.y = p1.y - p0.y;\n\tb.x = p2.x - p0.x, b.y = p2.y - p0.y;\n\tt = cross(a, b);\n\tif (t >  EPS) return COUNTER_CLOCKWISE;\n\tif (t < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEG;\n}\n\nvoid swap(PP *a, PP *b) { PP t = *a; *a = *b, *b = t; }\n\nvoid normalize()\n{\n\tint i;\n\tPP a, b;\n\tdouble w;\n\n\tfor (i = 0; i < n; i++) {\n\t\ta.x = t[i][1].x - t[i][0].x, a.y = t[i][1].y - t[i][0].y;\n\t\tb.x = t[i][1].x - t[i][2].x, b.y = t[i][1].y - t[i][2].y;\n\t\tif (fabs(norm(a)-norm(b)) < EPS) swap(&t[i][0], &t[i][1]);\n\t\ta.x = t[i][0].x - t[i][2].x, a.y = t[i][0].y - t[i][2].y;\n\t\tif (fabs(norm(a)-norm(b)) < EPS) swap(&t[i][0], &t[i][2]);\n\t\tif (ccw(t[i][0], t[i][1], t[i][2]) != COUNTER_CLOCKWISE) swap(&t[i][1], &t[i][2]);\n\t\ta.x = (t[i][1].x + t[i][2].x) / 2.0, a.y = (t[i][1].y + t[i][2].y) / 2.0;\n\t\tb.x = t[i][0].x - a.x, b.y = t[i][0].y - a.y;\n\t\tw = d/norm(b);\n\t\tt[i][3].x = t[i][2].x + w*b.x, t[i][3].y = t[i][2].y + w*b.y;\n\t\tt[i][4].x = t[i][1].x + w*b.x, t[i][4].y = t[i][1].y + w*b.y;\n\t}\n}\n\nint isIntersect(PP p1, PP p2, PP p3, PP p4)\n{\n\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\n\nint isInside(PP p, PP *gon, int sz)\n{\n\tint i, j;\n\tfor (i = 0; i < sz; i++) {\n\t\tj = i+1; if (j == sz) j = 0;\n\t\tif (ccw(gon[i], gon[j], p) == CLOCKWISE ) return 0;\n\t}\n\treturn 1;\n}\n\nint check(int a, int b)\n{\n\tint i, j, ii, jj;\n\n\tfor (i = 1; i <= 4; i++) if (isInside(t[a][i], t[b], 3)) return 1;\n\tfor (i = 0; i < 3; i++) if (isInside(t[b][i], t[a]+1, 4)) return 1;\n\tfor (i = 1; i <= 4; i++) {\n\t\tii = i+1; if (ii == 5) ii = 1;\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tjj = j+1; if (jj == 3) jj = 0;\n\t\t\tif (isIntersect(t[a][i], t[a][ii], t[b][j], t[b][jj])) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n// SCC (Strongly connected components) library\n#define MAX 101\nint g_to[MAX][MAX], g_hi[MAX];\nint r_to[MAX][MAX], r_hi[MAX];\nint ord[MAX], gr[MAX], cnt;\nchar mk[MAX];\n\nvoid addEdge(int s, int d) { g_to[s][g_hi[s]++] = d, r_to[d][r_hi[d]++] = s; }\nvoid dfs(int v) { int i;\n\tmk[v] = 1; for (i = 0; i < g_hi[v]; i++) if (!mk[g_to[v][i]]) dfs(g_to[v][i]); ord[cnt++] = v;\n}\nvoid rdfs(int v, int k) { int i;\n\tmk[v] = 1, gr[v] = k; for (i = 0; i < r_hi[v]; i++) if (!mk[r_to[v][i]]) rdfs(r_to[v][i], k);\n}\n\nint scc() {\tint i, j, k, ans;\n\tmemset(mk, 0, sizeof(mk));\n\tcnt = 0; for (i = 0; i < n; i++) if (!mk[i]) dfs(i);\n\n\tk = 0; memset(mk, 0, sizeof(mk));\n\tfor (i = cnt-1; i >= 0; i--) if (!mk[ord[i]]) rdfs(ord[i], k++);\n\n\tans = k;\n\tmemset(mk, 0, sizeof(mk));\n\tfor (i = 0; i < n; i++) for (j = 0; j < g_hi[i]; j++) {\n\t\tif (gr[i] != gr[g_to[i][j]]) { ans -= (1 ^ mk[gr[g_to[i][j]]]), mk[gr[g_to[i][j]]] = 1; }\n\t}\n\treturn ans;\n}\n/// SCC above\n\nint main()\n{\n\tint i, j;\n\n\twhile (n = in()) {\n\t\td = in();\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < 3; j++)\tt[i][j].x = in(), t[i][j].y = in();\n\t\t}\n\t\tnormalize();\n\n\t\tmemset(g_hi, 0, sizeof(g_hi)), memset(r_hi, 0, sizeof(r_hi));\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < n; j++) if (i != j) {\n\t\t\tif (check(i, j)) addEdge(i, j);\n\t\t}\t\n\t\tprintf(\"%d\\n\", scc());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0237: The Last Door\n// 2018.2.21 bal4u\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <ctype.h>\n\n#define EPS 0.01\ntypedef struct { double x, y; } PP;\nPP  t[101][5];\nint n, d;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\twhile (!isdigit(c)) c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\n#define COUNTER_CLOCKWISE\t 1\n#define CLOCKWISE\t\t\t-1\n#define ONLINE_BACK\t\t\t 2\n#define ONLINE_FRONT\t\t-2\n#define ON_SEG\t\t\t\t 0\n\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\n\nint ccw(PP p0, PP p1, PP p2)\n{\n\tPP a, b;\n\tdouble t;\n\n\ta.x = p1.x - p0.x, a.y = p1.y - p0.y;\n\tb.x = p2.x - p0.x, b.y = p2.y - p0.y;\n\tt = cross(a, b);\n\tif (t >  EPS) return COUNTER_CLOCKWISE;\n\tif (t < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEG;\n}\n\nvoid swap(PP *a, PP *b) { PP t = *a; *a = *b, *b = t; }\n\nvoid normalize()\n{\n\tint i;\n\tPP a, b;\n\tdouble w;\n\n\tfor (i = 0; i < n; i++) {\n\t\ta.x = t[i][1].x - t[i][0].x, a.y = t[i][1].y - t[i][0].y;\n\t\tb.x = t[i][1].x - t[i][2].x, b.y = t[i][1].y - t[i][2].y;\n\t\tif (fabs(norm(a)-norm(b)) < EPS) swap(&t[i][0], &t[i][1]);\n\t\ta.x = t[i][0].x - t[i][2].x, a.y = t[i][0].y - t[i][2].y;\n\t\tif (fabs(norm(a)-norm(b)) < EPS) swap(&t[i][0], &t[i][2]);\n\t\tif (ccw(t[i][0], t[i][1], t[i][2]) != COUNTER_CLOCKWISE) swap(&t[i][1], &t[i][2]);\n\t\ta.x = (t[i][1].x + t[i][2].x)/2, a.y = (t[i][1].y + t[i][2].y)/2;\n\t\tb.x = t[i][0].x - a.x, b.y = t[i][0].y - a.y;\n\t\tw = d / sqrt(norm(b));\n\t\tt[i][3].x = t[i][2].x + w*b.x, t[i][3].y = t[i][2].y + w*b.y;\n\t\tt[i][4].x = t[i][1].x + w*b.x, t[i][4].y = t[i][1].y + w*b.y;\n\t}\n}\n\nint isIntersect(PP p1, PP p2, PP p3, PP p4)\n{\n\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\n\nint isInside(PP p, PP *gon, int sz)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sz; i++) {\n\t\tj = i+1; if (j == sz) j = 0;\n\t\tif (ccw(gon[i], gon[j], p) == CLOCKWISE ) return 0;\n\t}\n\treturn 1;\n}\n\nint check(int a, int b)\n{\n\tint i, j, ii, jj;\n\n\tfor (i = 1; i <= 4; i++) if (isInside(t[a][i], t[b], 3)) return 1;\n\tfor (i = 0; i < 3; i++) if (isInside(t[b][i], t[a]+1, 4)) return 1;\n\tfor (i = 1; i <= 4; i++) {\n\t\tii = i+1; if (ii == 5) ii = 1;\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tjj = j+1; if (jj == 3) jj = 0;\n\t\t\tif (isIntersect(t[a][i], t[a][ii], t[b][j], t[b][jj])) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n// SCC (Strongly connected components) library\n#define MAX 101\nint g_to[MAX][MAX], g_hi[MAX];\nint r_to[MAX][MAX], r_hi[MAX];\nint ord[MAX], cmp[MAX], cnt;\nchar mk[MAX];\n\nvoid dfs(int v) { int i;\n\tmk[v] = 1; for (i = 0; i < g_hi[v]; i++) if (!mk[g_to[v][i]]) dfs(g_to[v][i]); ord[cnt++] = v;\n}\nvoid rdfs(int v, int k) { int i;\n\tmk[v] = 1, cmp[v] = k; for (i = 0; i < r_hi[v]; i++) if (!mk[r_to[v][i]]) rdfs(r_to[v][i], k);\n}\n\nint scc() {\tint i, k;\n\tmemset(mk, 0, sizeof(mk));\n\tcnt = 0; for (i = 0; i < n; i++) if (!mk[i]) dfs(i);\n\tk = 0; memset(mk, 0, sizeof(mk));\n\tfor (i = cnt-1; i >= 0; i--) if (!mk[ord[i]]) rdfs(ord[i], k++);\n\treturn k;\n}\n/// SCC above\n\nint main()\n{\n\tint i, j, k, ans;\n\n\twhile (n = in()) {\n\t\td = in();\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < 3; j++)\tt[i][j].x = in(), t[i][j].y = in();\n\t\t}\n\t\tnormalize();\n\n\t\tmemset(g_hi, 0, sizeof(g_hi)), memset(r_hi, 0, sizeof(r_hi));\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < n; j++) if (i != j) {\n\t\t\tif (check(i, j)) g_to[i][g_hi[i]++] = j, r_to[j][r_hi[j]++] = i;\n\t\t}\n\t\t\n\t\tk = scc();\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < g_hi[i]; j++) {\n\t\t\tif (cmp[i] != cmp[g_to[i][j]]) mk[cmp[g_to[i][j]]] = 1;\n\t\t}\n\t\tans = 0; for (i = 0; i < k; i++) if (!mk[i]) ans++;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0237: The Last Door\n// 2018.2.21 bal4u\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <ctype.h>\n\n#define MAX 102\n#define EPS 1e-5\n\ntypedef struct { double x, y; } PP;\nPP  t[MAX][5];\nint n, d;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\nwhile (c <= ' ') c = getchar_unlocked();\n\tif (c == '-') {\n\t\tc = getchar_unlocked();\n\t\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\t\twhile (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\n#define COUNTER_CLOCKWISE\t 1\n#define CLOCKWISE\t\t\t-1\n#define ONLINE_BACK\t\t\t 2\n#define ONLINE_FRONT\t\t-2\n#define ON_SEG\t\t\t\t 0\n\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble dot(PP a, PP b) { return a.x * b.x + a.y * b.y; }\ndouble norm(PP a) { return a.x * a.x + a.y * a.y; }\n\nint ccw(PP p0, PP p1, PP p2)\n{\n\tPP a, b;\n\tdouble t;\n\n\ta.x = p1.x - p0.x, a.y = p1.y - p0.y;\n\tb.x = p2.x - p0.x, b.y = p2.y - p0.y;\n\tt = cross(a, b);\n\tif (t >  EPS) return COUNTER_CLOCKWISE;\n\tif (t < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (norm(a) < norm(b)) return ONLINE_FRONT;\n\treturn ON_SEG;\n}\n\nvoid swap(PP *a, PP *b) { PP t = *a; *a = *b, *b = t; }\n\nvoid normalize(PP *p)\n{\n\tPP a, b;\n\tdouble w;\n\n\ta.x = p[1].x - p[0].x, a.y = p[1].y - p[0].y;\n\tb.x = p[1].x - p[2].x, b.y = p[1].y - p[2].y;\n\tif (fabs(norm(a)-norm(b)) < EPS) swap(&p[0], &p[1]);\n\ta.x = p[2].x - p[0].x, a.y = p[2].y - p[0].y;\n\tb.x = p[2].x - p[1].x, b.y = p[2].y - p[1].y;\n\tif (fabs(norm(a)-norm(b)) < EPS) swap(&p[0], &p[2]);\n\tif (ccw(p[0], p[1], p[2]) != COUNTER_CLOCKWISE) swap(&p[1], &p[2]);\n\ta.x = (p[1].x + p[2].x)/2, a.y = (p[1].y + p[2].y)/2;\n\tb.x = p[0].x - a.x, b.y = p[0].y - a.y, w = d / sqrt(norm(b));\n\tp[3].x = p[2].x + w*b.x, p[3].y = p[2].y + w*b.y;\n\tp[4].x = p[1].x + w*b.x, p[4].y = p[1].y + w*b.y;\n}\n\nint intersect(PP p1, PP p2, PP p3, PP p4)\n{\n\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n}\n\nint inside(PP p, PP *gon, int sz)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sz; i++) { j = i+1; if (j == sz) j = 0;\n\t\tif (ccw(gon[i], gon[j], p) == CLOCKWISE ) return 0;\n\t}\n\treturn 1;\n}\n\nint check(PP *a, int sa, PP *b, int sb)\n{\n\tint i, j, ii, jj;\n\n\tfor (i = 0; i < sa; i++) if (inside(a[i], b, sb)) return 1;\n\tfor (j = 0; j < sb; j++) if (inside(b[j], a, sa)) return 1;\n\tfor (i = 0; i < sa; i++) { ii = i+1; if (ii == sa) ii = 0;\n\t\tfor (j = 0; j < sb; j++) { jj = j+1; if (jj == sb) jj = 0;\n\t\t\tif (intersect(a[i], a[ii], b[j], b[jj])) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n// SCC (Strongly connected components) library\nint g_to[MAX][MAX], g_hi[MAX];\nint r_to[MAX][MAX], r_hi[MAX];\nint ord[MAX], cmp[MAX], cnt;\nchar mk[MAX];\n\nvoid dfs(int v) { int i;\n\tmk[v] = 1; for (i = 0; i < g_hi[v]; i++) if (!mk[g_to[v][i]]) dfs(g_to[v][i]); ord[cnt++] = v;\n}\nvoid rdfs(int v, int k) { int i;\n\tmk[v] = 1, cmp[v] = k; for (i = 0; i < r_hi[v]; i++) if (!mk[r_to[v][i]]) rdfs(r_to[v][i], k);\n}\n\nint scc() {\tint i, k;\n\tmemset(mk, 0, sizeof(mk));\n\tcnt = 0; for (i = 0; i < n; i++) if (!mk[i]) dfs(i);\n\tk = 0; memset(mk, 0, sizeof(mk));\n\tfor (i = cnt-1; i >= 0; i--) if (!mk[ord[i]]) rdfs(ord[i], k++);\n\treturn k;\n}\n/// SCC above\n\nint main()\n{\n\tint i, j, k, ans;\n\n\twhile (n = in()) {\n\t\td = in();\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < 3; j++)\tt[i][j].x = in(), t[i][j].y = in();\n\t\t\tnormalize(t[i]);\n\t\t}\n\n\t\tmemset(g_hi, 0, sizeof(g_hi)), memset(r_hi, 0, sizeof(r_hi));\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < n; j++) if (i != j) {\n\t\t\tif (check(t[i]+1, 4, t[j], 3)) {\n\t\t\t\tg_to[i][g_hi[i]++] = j, r_to[j][r_hi[j]++] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = scc();\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < g_hi[i]; j++) {\n\t\t\tk = g_to[i][j];\n\t\t\tif (cmp[i] != cmp[k]) ans -= 1^mk[cmp[k]], mk[cmp[k]] = 1;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-8, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tint[] deg;\n\tboolean[] light;\n\tint count;\n\t\n\tvoid lighting(int v){\n\t\tif(light[v])return;\n\t\tlight[v] = true;\n\t\tcount++;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])deg[i]--;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])lighting(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%2]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeg = new int[N];\n\t\t\te = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\tif(e[i][j])deg[j]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tlight = new boolean[N];\n\t\t\tcount = 0;\n\t\t\twhile(count<N){\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\t\treturn deg[o1]-deg[o2];\n\t\t\t\t\t}\n\t\t\t\t});\n//\t\t\t\tdebug(deg);\n\t\t\t\tfor(int i=0;i<N;i++)if(!light[i])q.add(i);\n\t\t\t\tint v = q.poll();\n\t\t\t\tres++;\n\t\t\t\tlighting(v);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-8, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tboolean[][] rev;\n\tboolean[] visit;\n\tint ID;\n\tint[] id;\n\tint[] scc;\n\t\n\tvoid dfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])dfs(i);\n\t\tid[v] = ID++;\n\t}\n\tvoid rdfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tscc[v] = ID;\n\t\tfor(int i=0;i<N;i++)if(rev[v][i])rdfs(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D*2;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%3]))<EPS){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te = new boolean[N][N];\n\t\t\trev = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\trev[j][i] = e[i][j];\n\t\t\t}\n\t\t\tvisit = new boolean[N];\n\t\t\tID = 0;\n\t\t\tid = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(visit[i])continue;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn id[o2]-id[o1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\tscc = new int[N];\n\t\t\tID = 0;\n\t\t\tArrays.fill(visit, false);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(visit[v])continue;\n\t\t\t\trdfs(v);\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j||scc[i]==scc[j]||!e[i][j])continue;\n\t\t\t\tdeg[scc[j]]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<ID;i++)if(deg[i]==0)res++;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-14, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tint[] deg;\n\tboolean[] light;\n\tint count;\n\t\n\tvoid lighting(int v){\n\t\tif(light[v])return;\n\t\tlight[v] = true;\n\t\tcount++;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])deg[i]--;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])lighting(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<1e-8;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<1e-8)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<1e-8)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%2]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeg = new int[N];\n\t\t\te = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\tif(e[i][j])deg[j]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tlight = new boolean[N];\n\t\t\tcount = 0;\n\t\t\twhile(count<N){\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\t\treturn deg[o1]-deg[o2];\n\t\t\t\t\t}\n\t\t\t\t});\n//\t\t\t\tdebug(deg);\n\t\t\t\tfor(int i=0;i<N;i++)if(!light[i])q.add(i);\n\t\t\t\tint v = q.poll();\n\t\t\t\tres++;\n\t\t\t\tlighting(v);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-12, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tboolean[][] rev;\n\tboolean[] visit;\n\tint ID;\n\tint[] id;\n\tint[] scc;\n\t\n\tvoid dfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])dfs(i);\n\t\tid[v] = ID++;\n\t}\n\tvoid rdfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tscc[v] = ID;\n\t\tfor(int i=0;i<N;i++)if(e[i][v])rdfs(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<1e-8;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<1e-8)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<1e-8)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%2]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te = new boolean[N][N];\n\t\t\trev = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\trev[j][i] = e[i][j];\n\t\t\t}\n\t\t\tvisit = new boolean[N];\n\t\t\tID = 0;\n\t\t\tid = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(visit[i])continue;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn id[o2]-id[o1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\tscc = new int[N];\n\t\t\tID = 0;\n\t\t\tArrays.fill(visit, false);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(visit[v])continue;\n\t\t\t\trdfs(v);\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j||scc[i]==scc[j]||!e[i][j])continue;\n\t\t\t\tdeg[scc[j]]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<ID;i++)if(deg[i]==0)res++;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-9, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tint[] deg;\n\tboolean[] light;\n\tint count;\n\t\n\tvoid lighting(int v){\n\t\tif(light[v])return;\n\t\tlight[v] = true;\n\t\tcount++;\n//\t\tfor(int i=0;i<N;i++)if(e[v][i])deg[i]--;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])lighting(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<1e-8;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<1e-8)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<1e-8)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%2]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeg = new int[N];\n\t\t\te = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\tif(e[i][j])deg[j]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tlight = new boolean[N];\n\t\t\tcount = 0;\n\t\t\twhile(count<N){\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\t\treturn deg[o1]-deg[o2];\n\t\t\t\t\t}\n\t\t\t\t});\n//\t\t\t\tdebug(deg);\n\t\t\t\tfor(int i=0;i<N;i++)if(!light[i])q.add(i);\n\t\t\t\tint v = q.poll();\n\t\t\t\tres++;\n\t\t\t\tlighting(v);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-10, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tint[] deg;\n\tboolean[] light;\n\tint count;\n\t\n\tvoid lighting(int v){\n\t\tif(light[v])return;\n\t\tlight[v] = true;\n\t\tcount++;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])deg[i]--;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])lighting(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%2]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeg = new int[N];\n\t\t\te = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\tif(e[i][j])deg[j]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tlight = new boolean[N];\n\t\t\tcount = 0;\n\t\t\twhile(count<N){\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\t\treturn deg[o1]-deg[o2];\n\t\t\t\t\t}\n\t\t\t\t});\n//\t\t\t\tdebug(deg);\n\t\t\t\tfor(int i=0;i<N;i++)if(!light[i])q.add(i);\n\t\t\t\tint v = q.poll();\n\t\t\t\tres++;\n\t\t\t\tlighting(v);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tint[] deg;\n\tboolean[] light;\n\t\n\tvoid lighting(int v){\n\t\tif(light[v])return;\n\t\tlight[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])lighting(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=EPS)return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tint comp(double[] a, double[] b){\n\t\tif(a[0]==b[0])return (int)Math.signum(a[1]-b[1]);\n\t\treturn (int)Math.signum(a[0]-b[0]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%2]))<EPS){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeg = new int[N];\n\t\t\te = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\tif(e[i][j])deg[j]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tlight = new boolean[N];\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn deg[o1]-deg[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(light[v])continue;\n\t\t\t\tres++;\n\t\t\t\tlighting(v);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 0, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tboolean[][] rev;\n\tboolean[] visit;\n\tint ID;\n\tint[] id;\n\tint[] scc;\n\t\n\tvoid dfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])dfs(i);\n\t\tid[v] = ID++;\n\t}\n\tvoid rdfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tscc[v] = ID;\n\t\tfor(int i=0;i<N;i++)if(rev[v][i])rdfs(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D*2;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<0;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%3]))<EPS){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te = new boolean[N][N];\n\t\t\trev = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\trev[j][i] = e[i][j];\n\t\t\t}\n\t\t\tvisit = new boolean[N];\n\t\t\tID = 0;\n\t\t\tid = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(visit[i])continue;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn id[o2]-id[o1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\tscc = new int[N];\n\t\t\tID = 0;\n\t\t\tArrays.fill(visit, false);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(visit[v])continue;\n\t\t\t\trdfs(v);\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j||scc[i]==scc[j]||!e[i][j])continue;\n\t\t\t\tdeg[scc[j]]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<ID;i++)if(deg[i]==0)res++;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-8, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tboolean[][] rev;\n\tboolean[] visit;\n\tint ID;\n\tint[] id;\n\tint[] scc;\n\t\n\tvoid dfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])dfs(i);\n\t\tid[v] = ID++;\n\t}\n\tvoid rdfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tscc[v] = ID;\n\t\tfor(int i=0;i<N;i++)if(rev[v][i])rdfs(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D*2;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<0;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%3]))<EPS){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te = new boolean[N][N];\n\t\t\trev = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\trev[j][i] = e[i][j];\n\t\t\t}\n\t\t\tvisit = new boolean[N];\n\t\t\tID = 0;\n\t\t\tid = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(visit[i])continue;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn id[o2]-id[o1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\tscc = new int[N];\n\t\t\tID = 0;\n\t\t\tArrays.fill(visit, false);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(visit[v])continue;\n\t\t\t\trdfs(v);\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j||scc[i]==scc[j]||!e[i][j])continue;\n\t\t\t\tdeg[scc[j]]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<ID;i++)if(deg[i]==0)res++;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-8, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tboolean[][] rev;\n\tboolean[] visit;\n\tint ID;\n\tint[] id;\n\tint[] scc;\n\t\n\tvoid dfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])dfs(i);\n\t\tid[v] = ID++;\n\t}\n\tvoid rdfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tscc[v] = ID;\n\t\tfor(int i=0;i<N;i++)if(rev[v][i])rdfs(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n//\t\t\tif(a==2&&b==3){\n//\t\t\t\tSystem.out.println(\"!!\");\n////\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], b1));\n////\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], b2));\n//\t\t\t\tSystem.out.println(p[b][j][0]+\",\"+p[b][j][1]+\" \"+p[b][(j+1)%3][0]+\",\"+p[b][(j+1)%3][1]+\" \"+p1[0]+\",\"+p1[1]);\n//\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], p1));\n////\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], p2));\n//\t\t\t}\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tdouble[] A = {5, 3}, B = {8, 3}, C = {8.011, 3};\n//\t\tSystem.out.println(dist(A, B, C));\n//\t\tSystem.out.println(dist(A, B, C)<=T+EPS);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%3]))<EPS){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te = new boolean[N][N];\n\t\t\trev = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\trev[j][i] = e[i][j];\n\t\t\t}\n\t\t\tvisit = new boolean[N];\n\t\t\tID = 0;\n\t\t\tid = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(visit[i])continue;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn id[o2]-id[o1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\tscc = new int[N];\n\t\t\tID = 0;\n\t\t\tArrays.fill(visit, false);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(visit[v])continue;\n\t\t\t\trdfs(v);\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j||scc[i]==scc[j]||!e[i][j])continue;\n\t\t\t\tdeg[scc[j]]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<ID;i++)if(deg[i]==0)res++;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tint[] deg;\n\tboolean[] light;\n\tint count;\n\t\n\tvoid lighting(int v){\n\t\tif(light[v])return;\n\t\tlight[v] = true;\n\t\tcount++;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])deg[i]--;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])lighting(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<=EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<=EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<=EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<1e-8;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<1e-8)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<1e-8)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%2]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeg = new int[N];\n\t\t\te = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\tif(e[i][j])deg[j]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tlight = new boolean[N];\n\t\t\tcount = 0;\n\t\t\twhile(count<N){\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\t\treturn deg[o1]-deg[o2];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor(int i=0;i<N;i++)if(!light[i])q.add(i);\n\t\t\t\tint v = q.poll();\n\t\t\t\tres++;\n\t\t\t\tlighting(v);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-8, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tboolean[][] rev;\n\tboolean[] visit;\n\tint ID;\n\tint[] id;\n\tint[] scc;\n\t\n\tvoid dfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])dfs(i);\n\t\tid[v] = ID++;\n\t}\n\tvoid rdfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tscc[v] = ID;\n\t\tfor(int i=0;i<N;i++)if(rev[v][i])rdfs(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D*2;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\t//A-B, S-Tª¤É½sÌêA2üªÔÌ£ª0©Û©Åð·ð»è·é\n\t\tif(Math.abs(cross(sub(b, a), sub(t, s)))<EPS){\n\t\t\treturn Math.min(dist(a, b, s), Math.min(dist(a, b, t), Math.min(dist(s, t, a), dist(s, t, b))))<EPS;\n\t\t}\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<0;\n\t\t//±±Åex(,,)*ex(,,)<EPSÆ·éÆA(0,0)(1,0)-(2,0)(3.0)Ìæ¤Èê¼üÉÀñÅ¢Äð·µÄ¢È¢àÌàtrueÆÈÁÄµÜ¤\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%3]))<EPS){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te = new boolean[N][N];\n\t\t\trev = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\trev[j][i] = e[i][j];\n\t\t\t}\n\t\t\tvisit = new boolean[N];\n\t\t\tID = 0;\n\t\t\tid = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(visit[i])continue;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn id[o2]-id[o1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\tscc = new int[N];\n\t\t\tID = 0;\n\t\t\tArrays.fill(visit, false);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(visit[v])continue;\n\t\t\t\trdfs(v);\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j||scc[i]==scc[j]||!e[i][j])continue;\n\t\t\t\tdeg[scc[j]]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<ID;i++)if(deg[i]==0)res++;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 0, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tboolean[][] rev;\n\tboolean[] visit;\n\tint ID;\n\tint[] id;\n\tint[] scc;\n\t\n\tvoid dfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])dfs(i);\n\t\tid[v] = ID++;\n\t}\n\tvoid rdfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tscc[v] = ID;\n\t\tfor(int i=0;i<N;i++)if(rev[v][i])rdfs(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D*2;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<0;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<1e-8)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<1e-8)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%3]))<EPS){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te = new boolean[N][N];\n\t\t\trev = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\trev[j][i] = e[i][j];\n\t\t\t}\n\t\t\tvisit = new boolean[N];\n\t\t\tID = 0;\n\t\t\tid = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(visit[i])continue;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn id[o2]-id[o1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\tscc = new int[N];\n\t\t\tID = 0;\n\t\t\tArrays.fill(visit, false);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(visit[v])continue;\n\t\t\t\trdfs(v);\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j||scc[i]==scc[j]||!e[i][j])continue;\n\t\t\t\tdeg[scc[j]]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<ID;i++)if(deg[i]==0)res++;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-12, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tint[] deg;\n\tboolean[] light;\n\tint count;\n\t\n\tvoid lighting(int v){\n\t\tif(light[v])return;\n\t\tlight[v] = true;\n\t\tcount++;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])deg[i]--;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])lighting(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<1e-8;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<1e-8)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<1e-8)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%2]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeg = new int[N];\n\t\t\te = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\tif(e[i][j])deg[j]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tlight = new boolean[N];\n\t\t\tcount = 0;\n\t\t\twhile(count<N){\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\t\treturn deg[o1]-deg[o2];\n\t\t\t\t\t}\n\t\t\t\t});\n//\t\t\t\tdebug(deg);\n\t\t\t\tfor(int i=0;i<N;i++)if(!light[i])q.add(i);\n\t\t\t\tint v = q.poll();\n\t\t\t\tres++;\n\t\t\t\tlighting(v);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tint[] deg;\n\tboolean[] light;\n\t\n\tvoid lighting(int v){\n\t\tif(light[v])return;\n\t\tlight[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])lighting(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=EPS)return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<1e-8)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<1e-8)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tint comp(double[] a, double[] b){\n\t\tif(a[0]==b[0])return (int)Math.signum(a[1]-b[1]);\n\t\treturn (int)Math.signum(a[0]-b[0]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%2]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeg = new int[N];\n\t\t\te = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\tif(e[i][j])deg[j]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tlight = new boolean[N];\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn deg[o1]-deg[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(light[v])continue;\n\t\t\t\tres++;\n\t\t\t\tlighting(v);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-9, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tint[] deg;\n\tboolean[] light;\n\tint count;\n\t\n\tvoid lighting(int v){\n\t\tif(light[v])return;\n\t\tlight[v] = true;\n\t\tcount++;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])deg[i]--;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])lighting(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<1e-8;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<1e-8)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<1e-8)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%2]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeg = new int[N];\n\t\t\te = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\tif(e[i][j])deg[j]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tlight = new boolean[N];\n\t\t\tcount = 0;\n\t\t\twhile(count<N){\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\t\treturn deg[o1]-deg[o2];\n\t\t\t\t\t}\n\t\t\t\t});\n//\t\t\t\tdebug(deg);\n\t\t\t\tfor(int i=0;i<N;i++)if(!light[i])q.add(i);\n\t\t\t\tint v = q.poll();\n\t\t\t\tres++;\n\t\t\t\tlighting(v);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-12+(1e-12)/2, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tint[] deg;\n\tboolean[] light;\n\tint count;\n\t\n\tvoid lighting(int v){\n\t\tif(light[v])return;\n\t\tlight[v] = true;\n\t\tcount++;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])deg[i]--;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])lighting(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%2]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeg = new int[N];\n\t\t\te = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\tif(e[i][j])deg[j]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tlight = new boolean[N];\n\t\t\tcount = 0;\n\t\t\twhile(count<N){\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\t\treturn deg[o1]-deg[o2];\n\t\t\t\t\t}\n\t\t\t\t});\n//\t\t\t\tdebug(deg);\n\t\t\t\tfor(int i=0;i<N;i++)if(!light[i])q.add(i);\n\t\t\t\tint v = q.poll();\n\t\t\t\tres++;\n\t\t\t\tlighting(v);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-12, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tboolean[][] rev;\n\tboolean[] visit;\n\tint ID;\n\tint[] id;\n\tint[] scc;\n\t\n\tvoid dfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])dfs(i);\n\t\tid[v] = ID++;\n\t}\n\tvoid rdfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tscc[v] = ID;\n\t\tfor(int i=0;i<N;i++)if(rev[v][i])rdfs(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n//\t\t\tif(a==2&&b==3){\n//\t\t\t\tSystem.out.println(\"!!\");\n////\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], b1));\n////\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], b2));\n//\t\t\t\tSystem.out.println(p[b][j][0]+\",\"+p[b][j][1]+\" \"+p[b][(j+1)%3][0]+\",\"+p[b][(j+1)%3][1]+\" \"+p1[0]+\",\"+p1[1]);\n//\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], p1));\n////\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], p2));\n//\t\t\t}\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tdouble[] A = {5, 3}, B = {8, 3}, C = {8.011, 3};\n//\t\tSystem.out.println(dist(A, B, C));\n//\t\tSystem.out.println(dist(A, B, C)<=T+EPS);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%3]))<EPS){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te = new boolean[N][N];\n\t\t\trev = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\trev[j][i] = e[i][j];\n\t\t\t}\n\t\t\tvisit = new boolean[N];\n\t\t\tID = 0;\n\t\t\tid = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(visit[i])continue;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn id[o2]-id[o1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\tscc = new int[N];\n\t\t\tID = 0;\n\t\t\tArrays.fill(visit, false);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(visit[v])continue;\n\t\t\t\trdfs(v);\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j||scc[i]==scc[j]||!e[i][j])continue;\n\t\t\t\tdeg[scc[j]]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<ID;i++)if(deg[i]==0)res++;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-12, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tint[] deg;\n\tboolean[] light;\n\tint count;\n\t\n\tvoid lighting(int v){\n\t\tif(light[v])return;\n\t\tlight[v] = true;\n\t\tcount++;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])deg[i]--;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])lighting(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%2]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeg = new int[N];\n\t\t\te = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\tif(e[i][j])deg[j]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tlight = new boolean[N];\n\t\t\tcount = 0;\n\t\t\twhile(count<N){\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\t\treturn deg[o1]-deg[o2];\n\t\t\t\t\t}\n\t\t\t\t});\n//\t\t\t\tdebug(deg);\n\t\t\t\tfor(int i=0;i<N;i++)if(!light[i])q.add(i);\n\t\t\t\tint v = q.poll();\n\t\t\t\tres++;\n\t\t\t\tlighting(v);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-13, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tint[] deg;\n\tboolean[] light;\n\tint count;\n\t\n\tvoid lighting(int v){\n\t\tif(light[v])return;\n\t\tlight[v] = true;\n\t\tcount++;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])deg[i]--;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])lighting(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%2]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeg = new int[N];\n\t\t\te = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\tif(e[i][j])deg[j]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tlight = new boolean[N];\n\t\t\tcount = 0;\n\t\t\twhile(count<N){\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\t\treturn deg[o1]-deg[o2];\n\t\t\t\t\t}\n\t\t\t\t});\n//\t\t\t\tdebug(deg);\n\t\t\t\tfor(int i=0;i<N;i++)if(!light[i])q.add(i);\n\t\t\t\tint v = q.poll();\n\t\t\t\tres++;\n\t\t\t\tlighting(v);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tint[] deg;\n\tboolean[] light;\n\tint count;\n\t\n\tvoid lighting(int v){\n\t\tif(light[v])return;\n\t\tlight[v] = true;\n\t\tcount++;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])deg[i]--;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])lighting(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+2)%3], b1)<=EPS)return true;\n\t\t\tif(dist(p[b][(j+2)%3], p[b][(j+1)%3], b1)<=EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<=0;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<1e-8)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<1e-8)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tint comp(double[] a, double[] b){\n\t\tif(a[0]==b[0])return (int)Math.signum(a[1]-b[1]);\n\t\treturn (int)Math.signum(a[0]-b[0]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%2]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeg = new int[N];\n\t\t\te = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\tif(e[i][j])deg[j]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tlight = new boolean[N];\n\t\t\tcount = 0;\n\t\t\twhile(count<N){\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\t\treturn deg[o1]-deg[o2];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor(int i=0;i<N;i++)if(!light[i])q.add(i);\n\t\t\t\tint v = q.poll();\n\t\t\t\tres++;\n\t\t\t\tlighting(v);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-9, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tboolean[][] rev;\n\tboolean[] visit;\n\tint ID;\n\tint[] id;\n\tint[] scc;\n\t\n\tvoid dfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])dfs(i);\n\t\tid[v] = ID++;\n\t}\n\tvoid rdfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tscc[v] = ID;\n\t\tfor(int i=0;i<N;i++)if(e[i][v])rdfs(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<1e-8;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<1e-8)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<1e-8)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%2]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te = new boolean[N][N];\n\t\t\trev = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\trev[j][i] = e[i][j];\n\t\t\t}\n\t\t\tvisit = new boolean[N];\n\t\t\tID = 0;\n\t\t\tid = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(visit[i])continue;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn id[o2]-id[o1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\tscc = new int[N];\n\t\t\tID = 0;\n\t\t\tArrays.fill(visit, false);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(visit[v])continue;\n\t\t\t\trdfs(v);\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j||scc[i]==scc[j]||!e[i][j])continue;\n\t\t\t\tdeg[scc[j]]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<ID;i++)if(deg[i]==0)res++;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 0, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tboolean[][] rev;\n\tboolean[] visit;\n\tint ID;\n\tint[] id;\n\tint[] scc;\n\t\n\tvoid dfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])dfs(i);\n\t\tid[v] = ID++;\n\t}\n\tvoid rdfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tscc[v] = ID;\n\t\tfor(int i=0;i<N;i++)if(rev[v][i])rdfs(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n//\t\t\tif(a==2&&b==3){\n//\t\t\t\tSystem.out.println(\"!!\");\n////\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], b1));\n////\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], b2));\n//\t\t\t\tSystem.out.println(p[b][j][0]+\",\"+p[b][j][1]+\" \"+p[b][(j+1)%3][0]+\",\"+p[b][(j+1)%3][1]+\" \"+p1[0]+\",\"+p1[1]);\n//\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], p1));\n////\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], p2));\n//\t\t\t}\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tdouble[] A = {5, 3}, B = {8, 3}, C = {8.011, 3};\n//\t\tSystem.out.println(dist(A, B, C));\n//\t\tSystem.out.println(dist(A, B, C)<=T+EPS);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%3]))<EPS){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te = new boolean[N][N];\n\t\t\trev = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\trev[j][i] = e[i][j];\n\t\t\t}\n\t\t\tvisit = new boolean[N];\n\t\t\tID = 0;\n\t\t\tid = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(visit[i])continue;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn id[o2]-id[o1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\tscc = new int[N];\n\t\t\tID = 0;\n\t\t\tArrays.fill(visit, false);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(visit[v])continue;\n\t\t\t\trdfs(v);\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j||scc[i]==scc[j]||!e[i][j])continue;\n\t\t\t\tdeg[scc[j]]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<ID;i++)if(deg[i]==0)res++;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  // constant\n\n  static final double DELTA = 0.01;\n  static final double DELTA2 = DELTA * DELTA;\n\n  // inner classes\n\n  static class Point {\n    double x, y;\n\n    Point(double x, double y) {\n      this.x = x;\n      this.y = y;\n    }\n  }\n\n  // global variables\n\n  // subroutines\n\n  static double dist2(Point v0, Point v1) {\n    double dvx = v1.x - v0.x;\n    double dvy = v1.y - v0.y;\n    return (dvx * dvx + dvy * dvy);\n  }\n\n  static double i_prod(Point v0, Point v1) {\n    return v0.x * v1.x + v0.y * v1.y;\n  }\n\n  static double o_prod(Point v0, Point v1) {\n    return v0.x * v1.y - v0.y * v1.x;\n  }\n\n  static void calc_trglen(Point[] trg, double[] lens) {\n    for (int i = 0; i < 3; i++) {\n      int j = (i + 1) % 3;\n      lens[i] = Math.sqrt(dist2(trg[i], trg[j]));\n    }\n  }\n\n  static Point[] trg2rect(Point[] trg, double[] lens, int d) {\n    Point b0 = null;\n    Point b1 = null;\n    Point nv = null;\n\n    for (int i0 = 0; i0 < 3; i0++) {\n      int i1 = (i0 + 1) % 3;\n      int i2 = (i1 + 1) % 3;\n\n      if (Math.abs(lens[i1] - lens[i2]) <= DELTA) {\n        b0 = trg[i0];\n        b1 = trg[i1];\n        nv = new Point(-b1.y + b0.y, b1.x - b0.x);\n        Point v02 = new Point(trg[i2].x - b0.x, trg[i2].y - b0.y);\n        if (i_prod(nv, v02) < 0) {\n          nv.x = -nv.x;\n          nv.y = -nv.y;\n        }\n        double nvlen = Math.sqrt(nv.x * nv.x + nv.y * nv.y);\n        nv.x *= d / nvlen;\n        nv.y *= d / nvlen;\n      }\n    }\n\n    Point b2 = new Point(b1.x + nv.x, b1.y + nv.y);\n    Point b3 = new Point(b0.x + nv.x, b0.y + nv.y);\n\n    Point[] rect = new Point[4];\n    rect[0] = b0;\n    rect[1] = b1;\n    rect[2] = b2;\n    rect[3] = b3;\n\n    return rect;\n  }\n\n  static boolean inside(Point p0, Point[] trg, double[] lens) {\n    double op = 0.0;\n\n    for (int i = 0; i < 3; i++) {\n      int j = (i + 1) % 3;\n      Point pv = new Point(p0.x - trg[i].x, p0.y - trg[i].y);\n      Point tv = new Point(trg[j].x - trg[i].x, trg[j].y - trg[i].y);\n      double op_d = o_prod(pv, tv) / lens[i];\n\n      if (Math.abs(op_d) > DELTA) {\n        if (op == 0.0)\n          op = op_d;\n        else if (op * op_d < 0)\n          return false;\n      }\n    }\n\n    return true;\n  }\n\n  static boolean cross_lines(Point u0, Point u1, Point v0, Point v1) {\n    if (dist2(u0, v0) <= DELTA2 || dist2(u0, v1) <= DELTA2 ||\n        dist2(u1, v0) <= DELTA2 || dist2(u1, v1) <= DELTA2)\n      return true;\n\n    /*\n      # x = dux * t + u0x = dvx * s + v0x\n      # y = duy * t + u0y = dvy * s + v0y\n      # dux * t - dvx * s = v0x - u0x\n      # duy * t - dvy * s = v0y - u0y\n      # |dux -dvx| |t| = |v0x-u0x|\n      # |duy -dvy| |s|   |v0y-u0y|\n      # det == dux*(-dvy)-(-dvx)*duy = -dux*dvy+dvx*duy\n      # |t| = 1/det * |-dvy dvx| |v0x-u0x|\n      # |s|           |-duy dux| |v0y-u0y|\n    */\n\n    double dux = u1.x - u0.x;\n    double duy = u1.y - u0.y;\n    double dvx = v1.x - v0.x;\n    double dvy = v1.y - v0.y;\n\n    double det = -dux * dvy + dvx * duy;\n    if (Math.abs(det) <= DELTA2) return false;\n\n    double vux = v0.x - u0.x;\n    double vuy = v0.y - u0.y;\n\n    double t = (-dvy * vux + dvx * vuy) / det;\n    double s = (-duy * vux + dux * vuy) / det;\n\n\n    return (t >= 0.0 && t <= 1.0 && s >= 0.0 && s <= 1.0);\n  }\n\n  static boolean cross_trgs(Point[] trg0, double[] lens0,\n                            Point[] trg1, double[] lens1) {\n    for (int i = 0; i < 3; i++)\n      if (inside(trg0[i], trg1, lens1) || inside(trg1[i], trg0, lens0))\n        return true;\n\n    for (int i0 = 0; i0 < 3; i0++) {\n      int j0 = (i0 + 1) % 3;\n      for (int i1 = 0; i1 < 3; i1++) {\n        int j1 = (i1 + 1) % 3;\n        if (cross_lines(trg0[i0], trg0[j0], trg1[i1], trg1[j1]))\n          return true;\n      }\n    }\n\n    return false;\n  }\n\n  static void connected(int id, int i, int n, boolean[][] edges, int[] ids) {\n    if (ids[i] > 0) return;\n\n    ids[i] = id;\n\n    for (int j = 0; j < n; j++)\n      if (ids[j] == 0 && edges[i][j])\n        connected(id, j, n, edges, ids);\n  }\n\n  // main\n  public static final void main(String[] args) throws Exception {\n    Scanner sc = new Scanner(System.in);\n\n    while (true) {\n      int n = sc.nextInt();\n      int d = sc.nextInt();\n      if (n == 0 && d == 0) break;\n\n      Point[][] trgs = new Point[n][3];\n      double[][] trlens = new double[n][3];\n      Point[][] rects = new Point[n][4];\n\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 3; j++) {\n          double x = sc.nextDouble();\n          double y = sc.nextDouble();\n          trgs[i][j] = new Point(x, y);\n        }\n\n        calc_trglen(trgs[i], trlens[i]);\n        rects[i] = trg2rect(trgs[i], trlens[i], d);\n      }\n\n      boolean[][] edges = new boolean[n][n];\n      for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) edges[i][j] = false;\n\n      for (int i = 0; i < n; i++) {\n        Point[] rct = rects[i];\n\n        Point[] rtrg0 = new Point[3];\n        rtrg0[0] = rct[0];\n        rtrg0[1] = rct[1];\n        rtrg0[2] = rct[2];\n        double[] rtlens0 = new double[3];\n        calc_trglen(rtrg0, rtlens0);\n\n        Point[] rtrg1 = new Point[3];\n        rtrg1[0] = rct[0];\n        rtrg1[1] = rct[2];\n        rtrg1[2] = rct[3];\n        double[] rtlens1 = new double[3];\n        calc_trglen(rtrg1, rtlens1);\n\n        for (int j = 0; j < n; j++)\n          if (i != j &&\n              (cross_trgs(trgs[j], trlens[j], rtrg0, rtlens0) ||\n               cross_trgs(trgs[j], trlens[j], rtrg1, rtlens1)))\n            edges[i][j] = edges[j][i] = true;\n      }\n\n      int id = 0;\n      int[] ids = new int[n];\n      Arrays.fill(ids, 0);\n\n      for (int i = 0; i < n; i++)\n        if (ids[i] == 0) {\n          id++;\n          connected(id, i, n, edges, ids);\n        }\n\n      System.out.println(id);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-8, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tboolean[][] rev;\n\tboolean[] visit;\n\tint ID;\n\tint[] id;\n\tint[] scc;\n\t\n\tvoid dfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])dfs(i);\n\t\tid[v] = ID++;\n\t}\n\tvoid rdfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tscc[v] = ID;\n\t\tfor(int i=0;i<N;i++)if(rev[v][i])rdfs(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D*2;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<0;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%3]))<EPS){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te = new boolean[N][N];\n\t\t\trev = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\trev[j][i] = e[i][j];\n\t\t\t}\n\t\t\tvisit = new boolean[N];\n\t\t\tID = 0;\n\t\t\tid = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(visit[i])continue;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn id[o2]-id[o1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\tscc = new int[N];\n\t\t\tID = 0;\n\t\t\tArrays.fill(visit, false);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(visit[v])continue;\n\t\t\t\trdfs(v);\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j||scc[i]==scc[j]||!e[i][j])continue;\n\t\t\t\tdeg[scc[j]]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<ID;i++)if(deg[i]==0)res++;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-8, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tboolean[][] rev;\n\tboolean[] visit;\n\tint ID;\n\tint[] id;\n\tint[] scc;\n\t\n\tvoid dfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])dfs(i);\n\t\tid[v] = ID++;\n\t}\n\tvoid rdfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tscc[v] = ID;\n\t\tfor(int i=0;i<N;i++)if(rev[v][i])rdfs(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D*2;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<0;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%3]))<EPS){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te = new boolean[N][N];\n\t\t\trev = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\trev[j][i] = e[i][j];\n\t\t\t}\n\t\t\tvisit = new boolean[N];\n\t\t\tID = 0;\n\t\t\tid = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(visit[i])continue;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn id[o2]-id[o1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\tscc = new int[N];\n\t\t\tID = 0;\n\t\t\tArrays.fill(visit, false);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(visit[v])continue;\n\t\t\t\trdfs(v);\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j||scc[i]==scc[j]||!e[i][j])continue;\n\t\t\t\tdeg[scc[j]]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<ID;i++)if(deg[i]==0)res++;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-11, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tboolean[][] rev;\n\tboolean[] visit;\n\tint ID;\n\tint[] id;\n\tint[] scc;\n\t\n\tvoid dfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])dfs(i);\n\t\tid[v] = ID++;\n\t}\n\tvoid rdfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tscc[v] = ID;\n\t\tfor(int i=0;i<N;i++)if(rev[v][i])rdfs(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n//\t\t\tif(a==2&&b==3){\n//\t\t\t\tSystem.out.println(\"!!\");\n////\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], b1));\n////\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], b2));\n//\t\t\t\tSystem.out.println(p[b][j][0]+\",\"+p[b][j][1]+\" \"+p[b][(j+1)%3][0]+\",\"+p[b][(j+1)%3][1]+\" \"+p1[0]+\",\"+p1[1]);\n//\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], p1));\n////\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], p2));\n//\t\t\t}\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<EPS;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<EPS)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<EPS)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tdouble[] A = {5, 3}, B = {8, 3}, C = {8.011, 3};\n//\t\tSystem.out.println(dist(A, B, C));\n//\t\tSystem.out.println(dist(A, B, C)<=T+EPS);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%3]))<EPS){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te = new boolean[N][N];\n\t\t\trev = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\trev[j][i] = e[i][j];\n\t\t\t}\n\t\t\tvisit = new boolean[N];\n\t\t\tID = 0;\n\t\t\tid = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(visit[i])continue;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn id[o2]-id[o1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\tscc = new int[N];\n\t\t\tID = 0;\n\t\t\tArrays.fill(visit, false);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(visit[v])continue;\n\t\t\t\trdfs(v);\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j||scc[i]==scc[j]||!e[i][j])continue;\n\t\t\t\tdeg[scc[j]]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<ID;i++)if(deg[i]==0)res++;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-12, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tboolean[][] rev;\n\tboolean[] visit;\n\tint ID;\n\tint[] id;\n\tint[] scc;\n\t\n\tvoid dfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])dfs(i);\n\t\tid[v] = ID++;\n\t}\n\tvoid rdfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tscc[v] = ID;\n\t\tfor(int i=0;i<N;i++)if(rev[v][i])rdfs(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<1e-8;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<1e-8)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<1e-8)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%3]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te = new boolean[N][N];\n\t\t\trev = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\trev[j][i] = e[i][j];\n\t\t\t}\n\t\t\tvisit = new boolean[N];\n\t\t\tID = 0;\n\t\t\tid = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(visit[i])continue;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn id[o2]-id[o1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\tscc = new int[N];\n\t\t\tID = 0;\n\t\t\tArrays.fill(visit, false);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(visit[v])continue;\n\t\t\t\trdfs(v);\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j||scc[i]==scc[j]||!e[i][j])continue;\n\t\t\t\tdeg[scc[j]]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<ID;i++)if(deg[i]==0)res++;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-12, T = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tboolean[][] rev;\n\tboolean[] visit;\n\tint ID;\n\tint[] id;\n\tint[] scc;\n\t\n\tvoid dfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])dfs(i);\n\t\tid[v] = ID++;\n\t}\n\tvoid rdfs(int v){\n\t\tif(visit[v])return;\n\t\tvisit[v] = true;\n\t\tscc[v] = ID;\n\t\tfor(int i=0;i<N;i++)if(rev[v][i])rdfs(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=T+EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n//\t\t\tif(a==2&&b==3){\n//\t\t\t\tSystem.out.println(\"!!\");\n////\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], b1));\n////\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], b2));\n//\t\t\t\tSystem.out.println(p[b][j][0]+\",\"+p[b][j][1]+\" \"+p[b][(j+1)%3][0]+\",\"+p[b][(j+1)%3][1]+\" \"+p1[0]+\",\"+p1[1]);\n//\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], p1));\n////\t\t\t\tSystem.out.println(dist(p[b][j], p[b][(j+1)%3], p2));\n//\t\t\t}\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], b2)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p1)<=T+EPS)return true;\n\t\t\tif(dist(p[b][j], p[b][(j+1)%3], p2)<=T+EPS)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(crossing(b1, b2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(b2, p2, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p2, p1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t\tif(crossing(p1, b1, p[b][j], p[b][(j+1)%3]))return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble ex(double[] a, double[] b, double[] c){\n\t\tdouble[] s1 = sub(b, a), s2 = sub(c, a);\n\t\treturn cross(s1, s2);\n\t}\n\tboolean crossing(double[] a, double[] b, double[] s, double[] t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(s, t, a)*ex(s, t, b)>0)return false;\n\t\treturn ex(t, s, a)*ex(t, s, b)<1e-8;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<1e-8)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<1e-8)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tdouble[] A = {5, 3}, B = {8, 3}, C = {8.011, 3};\n//\t\tSystem.out.println(dist(A, B, C));\n//\t\tSystem.out.println(dist(A, B, C)<=T+EPS);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%3]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te = new boolean[N][N];\n\t\t\trev = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\trev[j][i] = e[i][j];\n\t\t\t}\n\t\t\tvisit = new boolean[N];\n\t\t\tID = 0;\n\t\t\tid = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(visit[i])continue;\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn id[o2]-id[o1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<N;i++)q.add(i);\n\t\t\tscc = new int[N];\n\t\t\tID = 0;\n\t\t\tArrays.fill(visit, false);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(visit[v])continue;\n\t\t\t\trdfs(v);\n\t\t\t\tID++;\n\t\t\t}\n\t\t\tint[] deg = new int[ID];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j||scc[i]==scc[j]||!e[i][j])continue;\n\t\t\t\tdeg[scc[j]]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<ID;i++)if(deg[i]==0)res++;\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//The Last Door\npublic class Main{\n\n\tint N, D;\n\tdouble EPS = 1e-2;\n\tdouble[][][] p;\n\tdouble[][] d;\n\tint[] top;\n\tint[][] bottom;\n\t\n\tboolean[][] e;\n\tint[] deg;\n\tboolean[] light;\n\tint count;\n\t\n\tvoid lighting(int v){\n\t\tif(light[v])return;\n\t\tlight[v] = true;\n\t\tcount++;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])deg[i]--;\n\t\tfor(int i=0;i<N;i++)if(e[v][i])lighting(i);\n\t}\n\t\n\tboolean hit(int a, int b){\n\t\tdouble[] b1 = p[a][bottom[a][0]], b2 = p[a][bottom[a][1]];\n\t\tdouble[] p1 = new double[]{b1[0]+d[a][0], b1[1]+d[a][1]};\n\t\tdouble[] p2 = new double[]{b2[0]+d[a][0], b2[1]+d[a][1]};\n\t\tdouble area = norm(b1, b2)*D;\n\t\tfor(int j=0;j<3;j++){\n\t\t\tdouble s = 0;\n\t\t\ts += area(b1, b2, p[b][j]) + area(b2, p2, p[b][j]) + area(p2, p1, p[b][j]) + area(p1, b1, p[b][j]);\n\t\t\tif(Math.abs(s-area)<1e-8)return true;\n\t\t}\n\t\tfor(int j=0;j<3;j++){\n\t\t\tif(dist(b1, b2, p[b][j])<=EPS)return true;\n\t\t\tif(dist(b2, p2, p[b][j])<=EPS)return true;\n\t\t\tif(dist(p2, p1, p[b][j])<=EPS)return true;\n\t\t\tif(dist(p1, b1, p[b][j])<=EPS)return true;\n\t\t}\n\t\treturn false;\n\t}\n\tdouble dist(double[] a, double[] b, double[] p){\n\t\tif(dot(sub(b, a), sub(p, a))<1e-8)return norm(a, p);\n\t\tif(dot(sub(a, b), sub(p, b))<1e-8)return norm(b, p);\n\t\treturn Math.abs(cross(sub(b, a), sub(p, a)))/norm(a, b);\n\t}\n\tdouble dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tdouble norm(double[] a, double[] b){\n\t\treturn Math.hypot(a[0]-b[0], a[1]-b[1]);\n\t}\n\tint comp(double[] a, double[] b){\n\t\tif(a[0]==b[0])return (int)Math.signum(a[1]-b[1]);\n\t\treturn (int)Math.signum(a[0]-b[0]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble[] mid(double[] a, double[] b){\n\t\treturn new double[]{(a[0]+b[0])/2, (a[1]+b[1])/2};\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tdouble area(double[] a, double[] b, double[] c){\n\t\tdouble res = cross(a, b)+cross(b, c)+cross(c, a);\n\t\treturn Math.abs(res)/2;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); D = sc.nextInt();\n\t\t\tif((N|D)==0)break;\n\t\t\tp = new double[N][3][2];\n\t\t\td = new double[N][2];\n\t\t\ttop = new int[N];\n\t\t\tbottom = new int[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<3;j++)for(int k=0;k<2;k++)p[i][j][k] = sc.nextDouble();\n\t\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\t\tif(Math.abs(norm(p[i][j], p[i][(j+1)%3])-norm(p[i][j], p[i][(j+2)%2]))<1e-8){\n\t\t\t\t\t\ttop[i] = j;\n\t\t\t\t\t\tbottom[i][0] = (j+1)%3; bottom[i][1] = (j+2)%3;\n\t\t\t\t\t\tdouble[] m = mid(p[i][(j+1)%3], p[i][(j+2)%3]);\n\t\t\t\t\t\td[i] = sub(p[i][j], m);\n\t\t\t\t\t\tdouble nor = Math.hypot(d[i][0], d[i][1]);\n\t\t\t\t\t\td[i][0]/=nor; d[i][1]/=nor;\n\t\t\t\t\t\td[i][0]*=D; d[i][1]*=D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeg = new int[N];\n\t\t\te = new boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\te[i][j] = hit(i, j);\n\t\t\t\tif(e[i][j])deg[j]++;\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tlight = new boolean[N];\n\t\t\tcount = 0;\n\t\t\twhile(count<N){\n\t\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\t\treturn deg[o1]-deg[o2];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor(int i=0;i<N;i++)if(!light[i])q.add(i);\n\t\t\t\tint v = q.poll();\n\t\t\t\tres++;\n\t\t\t\tlighting(v);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0237\n{\n    class Program\n    {\n\n        public const double EPS = 1e-10;\n        public const double EPS2 = 1e-2;\n\n        class Triangle\n        {\n            public double[] Vs { get; set; } //三角形の頂点\n            public double[] Beams { get; set; } //三角形から放たれるビームの各頂点\n            public Triangle(double[] vs)\n            {\n                Vs = vs;\n                SetBeam();\n            }\n\n            private void SetBeam()\n            {\n                double ax = Vs[0]; double ay = Vs[1];\n                double bx = Vs[2]; double by = Vs[3];\n                double cx = Vs[4]; double cy = Vs[5];\n                double a = new Vector(bx - cx, by - cy).LengthSquared;\n                double b = new Vector(ax - cx, ay - cy).LengthSquared;\n                double c = new Vector(ax - bx, ay - by).LengthSquared;\n\n                double topX, topY, b1x, b1y, b2x, b2y;\n                if (Math.Abs(a - b) < EPS)\n                {\n                    topX = cx; topY = cy; b1x = ax; b1y = ay; b2x = bx; b2y = by;\n                }\n                else if (Math.Abs(b - c) < EPS)\n                {\n                    topX = ax; topY = ay; b1x = bx; b1y = by; b2x = cx; b2y = cy;\n                }\n                else\n                {\n                    topX = bx; topY = by; b1x = cx; b1y = cy; b2x = ax; b2y = ay;\n                }\n\n                Vector v = new Vector(topX - ((b1x + b2x) / (double)2), topY - ((b1y + b2y) / (double)2));\n                v.Normalize();\n                v *= d;\n                Beams = new double[] { b1x, b1y, b2x, b2y, b2x + v.X, b2y + v.Y, b1x + v.X, b1y + v.Y };\n            }\n        }\n\n        static Triangle[] triangles;\n        static bool[,] adj;\n        static int d;\n        static List<List<int>> scc;\n\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] nd = RArInt();\n                if (nd.Sum() == 0) break;\n                Init(nd);\n                SetGraph();\n                SCC();\n                Console.WriteLine(CalcTouchCount());\n            }\n        }\n\n        private static void Init(int[] nd)\n        {\n            d = nd[1];\n            adj = new bool[nd[0], nd[0]];\n            triangles = new Triangle[nd[0]];\n            for (int i = 0; i < nd[0]; i++) triangles[i] = new Triangle(RArDouble());\n        }\n\n        private static void SetGraph()\n        {\n            for (int i = 0; i < triangles.Length; i++)\n            {\n                for (int j = 0; j < triangles.Length; j++)\n                {\n                    if (i == j) continue;\n                    if (IsPolygonIntersected(triangles[i].Beams, triangles[j].Vs)) adj[i, j] = true;\n                }\n            }\n        }\n\n        private static bool IsPolygonIntersected(double[] rec, double[] tri)\n        {\n            for (int i = 0; i < tri.Length; i += 2)\n            {\n                if (IsPolygonIncludePoint(rec, tri[i], tri[i + 1])) return true;\n            }\n            for (int i = 0; i < rec.Length; i += 2)\n            {\n                if (IsPolygonIncludePoint(tri, rec[i], rec[i + 1])) return true;\n            }\n            return false;\n        }\n\n        public static bool IsPolygonIncludePoint(double[] pol, double px, double py)\n        {\n            Vector p = new Vector(px, py);\n            Vector[] vecs = new Vector[pol.Length / 2];\n            for (int i = 0; i < pol.Length; i += 2) vecs[i / 2] = new Vector(pol[i], pol[i + 1]);\n\n            double[] crossProducts = new double[vecs.Length];\n            for (int i = 0; i < vecs.Length; i++)\n            {\n                Vector next = vecs[(i + 1) % vecs.Length];\n                if (Vector.RangeOfPointAndLineSegment(vecs[i].X, vecs[i].Y, next.X, next.Y, px, py) <= EPS2) return true;\n                crossProducts[i] = Vector.CrossProduct(next - vecs[i], p - next);\n            }\n            return crossProducts.All(x => x >= 0) || crossProducts.All(x => x <= 0);\n        }\n\n        private static void SCC()\n        {\n            bool[] visited = new bool[triangles.Length];\n            Stack<int> order = new Stack<int>();\n            for (int i = 0; i < triangles.Length; i++)\n            {\n                Dfs(i, order, visited);\n            }\n\n            visited = new bool[triangles.Length];\n            scc = new List<List<int>>();\n\n            int idx = 0;\n            while (order.Count() > 0)\n            {\n                int v = order.Pop();\n                if (!visited[v])\n                {\n                    scc.Add(new List<int>());\n                    RDfs(v, idx, visited);\n                    idx++;\n                }\n            }\n        }\n\n        private static void Dfs(int v, Stack<int> order, bool[] visited)\n        {\n            if (!visited[v])\n            {\n                visited[v] = true;\n                for (int i = 0; i < triangles.Length; i++) if (adj[v, i]) Dfs(i, order, visited);\n                order.Push(v);\n            }\n        }\n\n        private static void RDfs(int v, int idx, bool[] visited)\n        {\n            if (!visited[v])\n            {\n                visited[v] = true;\n                for (int i = 0; i < triangles.Length; i++) if (adj[i, v]) RDfs(i, idx, visited);\n                scc[idx].Add(v);\n            }\n        }\n\n        private static int CalcTouchCount()\n        {\n            int res = 0;\n            foreach (var item in scc)\n            {\n                if (!HasInTriangle(item)) res++;\n            }\n            return res;\n        }\n\n        private static bool HasInTriangle(List<int> vs)\n        {\n            foreach (var item in vs)\n            {\n                for (int i = 0; i < triangles.Length; i++)\n                {\n                    if (adj[i, item] && !vs.Any(x=> x == i)) return true;\n                }\n            }\n            return false;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public partial struct Vector : IFormattable\n    {\n\n        #region Internal Fields\t\n        internal double _x;\n        internal double _y;\n        #endregion Internal Fields\t\n\n        #region Public Properties\t\n        public double X { get { return _x; } set { _x = value; } }\n        public double Y { get { return _y; } set { _y = value; } }\n        #endregion Public Properties\n\n        #region Constructors\n        public Vector(double x, double y) { _x = x; _y = y; }\n        public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n        #endregion Constructors\n\n        #region Public Methods\t\n        public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n        public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n        public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n        public override bool Equals(object o)\n        {\n            if ((null == o) || !(o is Vector)) return false;\n            Vector value = (Vector)o;\n            return Vector.Equals(this, value);\n        }\n        public bool Equals(Vector value) { return Vector.Equals(this, value); }\n        public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        #endregion Public Methods\t\n\n        #region Internal Properties\t\n        public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n        public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n        string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n        internal string ConvertToString(string format, IFormatProvider provider)\n        {\n            char separator = ' ';\n            return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n        }\n        #endregion Internal Properties\t\n\n        #region Public Methods\n\n        public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n        public double LengthSquared { get { return _x * _x + _y * _y; } }\n        public void Normalize()\n        {\n            this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n            this /= Length;\n        }\n\n        public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n        public static double AngleBetween(Vector vector1, Vector vector2)\n        {\n            double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n            double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n            return Math.Atan2(sin, cos) * (180 / Math.PI);\n        }\n\n        public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n        public static Vector Rotation(Vector v, double angle, Vector basePoint)\n        {\n            double rad = angle * Math.PI / 180;\n            Vector res = new Vector();\n            res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n            res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n            return res;\n        }\n\n        /// <summary>\n        /// 線分ABと点Pの距離を求める\n        /// </summary>\n        /// <param name=\"sx\">線分ABの始点x座標</param>\n        /// <param name=\"sy\">線分ABの始点y座標</param>\n        /// <param name=\"ex\">線分ABの終点x座標</param>\n        /// <param name=\"ey\">線分ABの終点y座標</param>\n        /// <param name=\"px\">地点Pのx座標</param>\n        /// <param name=\"py\">地点Pのy座標</param>\n        /// <returns></returns>\n        public static double RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n        {\n            Vector A = new Vector(sx, sy);\n            Vector B = new Vector(ex, ey);\n            Vector P = new Vector(px, py);\n            return (P - CalcClosestPointOnLineSegment(A, B, P)).Length;\n        }\n\n        private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n        {\n\n            Vector a = B - A;\n            Vector b = P - A;\n            double r = (a * b) / (a * a);\n\n            if (r <= 0) return A;\n            else if (r >= 1) return B;\n            else return A + r * a;\n        }\n\n        #endregion Public Methods\n\n        #region Public Operators\n\n        public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n        public void Negate() { _x = -_x; _y = -_y; }\n        public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n        public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n        public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n        public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n        public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n        public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n        #endregion Public Operators\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "## constant\n\nDELTA = 0.01\nDELTA2 = DELTA ** 2\n\n### subroutines\n\ndef dist2(v0, v1)\n  (v1[0] - v0[0]) ** 2 + (v1[1] - v0[1]) ** 2\nend\n\ndef i_prod(v0, v1)\n  v0[0] * v1[0] + v0[1] * v1[1]\nend\n\ndef o_prod(v0, v1)\n  v0[0] * v1[1] - v0[1] * v1[0]\nend\n\ndef calc_trglen(trg)\n  if trg[3].nil?\n    for i in (0..2)\n      j = (i + 1) % 3\n      trg[i + 3] = Math.sqrt(dist2(trg[i], trg[j]))\n    end\n  end\n\n  trg[3..5]\nend\n\ndef trg2rect(trg, d)\n  lens = calc_trglen(trg)\n\n  b0 = nil\n  b1 = nil\n  nv = nil\n\n  for i0 in (0..2)\n    i1 = (i0 + 1) % 3\n    i2 = (i1 + 1) % 3\n    if (lens[i1] - lens[i2]).abs <= DELTA\n      b0 = trg[i0]\n      b1 = trg[i1]\n      nv = [-b1[1] + b0[1], b1[0] - b0[0]]\n      v02 = [trg[i2][0] - b0[0], trg[i2][1] - b0[1]]\n      nv = [-nv[0], -nv[1]] if i_prod(nv, v02) < 0\n      nvlen = Math.sqrt(nv[0] ** 2 + nv[1] ** 2)\n      nv[0] *= d / nvlen\n      nv[1] *= d / nvlen\n    end\n  end\n\n  b2 = [b1[0] + nv[0], b1[1] + nv[1]]\n  b3 = [b0[0] + nv[0], b0[1] + nv[1]]\n\n  [b0, b1, b2, b3]\nend\n\ndef inside?(p0, trg)\n  lens = calc_trglen(trg)\n\n  op = nil\n  for i in (0..2)\n    j = (i + 1) % 3\n    pv = [p0[0] - trg[i][0], p0[1] - trg[i][1]]\n    tv = [trg[j][0] - trg[i][0], trg[j][1] - trg[i][1]]\n    op_d = o_prod(pv, tv) / lens[i]\n    if op_d.abs > DELTA\n      if op.nil?\n        op = op_d\n      elsif op * op_d < 0\n        return false\n      end\n    end\n  end\n\n  #p [\"inside?\", p0, trg, true]\n  true\nend\n\ndef cross_lines?(u0, u1, v0, v1)\n  if dist2(u0, v0) <= DELTA2 || dist2(u0, v1) <= DELTA2 ||\n      dist2(u1, v0) <= DELTA2 || dist2(u1, v1) <= DELTA2\n    return true\n  end\n\n  # x = dux * t + u0x = dvx * s + v0x\n  # y = duy * t + u0y = dvy * s + v0y\n  # dux * t - dvx * s = v0x - u0x\n  # duy * t - dvy * s = v0y - u0y\n  # |dux -dvx| |t| = |v0x-u0x|\n  # |duy -dvy| |s|   |v0y-u0y|\n  # det == dux*(-dvy)-(-dvx)*duy = -dux*dvy+dvx*duy\n  # |t| = 1/det * |-dvy dvx| |v0x-u0x|\n  # |s|           |-duy dux| |v0y-u0y|\n\n  dux = u1[0] - u0[0]\n  duy = u1[1] - u0[1]\n  dvx = v1[0] - v0[0]\n  dvy = v1[1] - v0[1]\n\n  det = -dux * dvy + dvx * duy\n  return false if det == 0\n\n  vux = v0[0] - u0[0]\n  vuy = v0[1] - u0[1]\n\n  t = (-dvy * vux + dvx * vuy) / det\n  s = (-duy * vux + dux * vuy) / det\n\n  #p [\"cl?\", u0, u1, v0, v1, t, s]\n  t >= 0.0 && t <= 1.0 && s >= 0.0 && s <= 1.0\nend\n\ndef cross_trgs?(trg0, trg1)\n  for i in (0..2)\n    return true if inside?(trg0[i], trg1) || inside?(trg1[i], trg0)\n  end\n\n  for i0 in (0..2)\n    j0 = (i0 + 1) % 3\n    for i1 in (0..2)\n      j1 = (i1 + 1) % 3\n      return true if cross_lines?(trg0[i0], trg0[j0], trg1[i1], trg1[j1])\n    end\n  end\n  false\nend\n\n### main\n\nwhile true\n  n, d = gets.strip.split(' ').map{|s| s.to_i}\n  break if n == 0 && d == 0\n\n  trgs = []\n  n.times do\n    pts = gets.strip.split(' ').map{|s| s.to_f}\n    trgs << [[pts[0], pts[1]], [pts[2], pts[3]], [pts[4], pts[5]]]\n  end\n  #p trgs\n\n  rects = trgs.map{|trg| trg2rect(trg, d)}\n  #p rects\n\n  origins = n.times.map{true}\n\n  for i in (0...n)\n    rct = rects[i]\n    rtrg0 = [rct[0], rct[1], rct[2]]\n    rtrg1 = [rct[0], rct[2], rct[3]]\n\n    for j in (0...n)\n      next if i == j || ! origins[j]\n\n      if cross_trgs?(trgs[j], rtrg0) || cross_trgs?(trgs[j], rtrg1)\n        #p [i, j]\n        origins[j] = false\n        break\n      end\n    end\n  end\n\n  puts origins.select{|tf| tf}.length\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nDELTA = 0.01\nDELTA2 = DELTA ** 2\n\n### subroutines\n\ndef dist2(v0, v1)\n  (v1[0] - v0[0]) ** 2 + (v1[1] - v0[1]) ** 2\nend\n\ndef i_prod(v0, v1)\n  v0[0] * v1[0] + v0[1] * v1[1]\nend\n\ndef o_prod(v0, v1)\n  v0[0] * v1[1] - v0[1] * v1[0]\nend\n\ndef calc_trglen(trg)\n  if trg[3].nil?\n    for i in (0..2)\n      j = (i + 1) % 3\n      trg[i + 3] = Math.sqrt(dist2(trg[i], trg[j]))\n    end\n  end\n\n  trg[3..5]\nend\n\ndef trg2rect(trg, d)\n  lens = calc_trglen(trg)\n\n  b0 = nil\n  b1 = nil\n  nv = nil\n\n  for i0 in (0..2)\n    i1 = (i0 + 1) % 3\n    i2 = (i1 + 1) % 3\n    if (lens[i1] - lens[i2]).abs <= DELTA\n      b0 = trg[i0]\n      b1 = trg[i1]\n      nv = [-b1[1] + b0[1], b1[0] - b0[0]]\n      v02 = [trg[i2][0] - b0[0], trg[i2][1] - b0[1]]\n      nv = [-nv[0], -nv[1]] if i_prod(nv, v02) < 0\n      nvlen = Math.sqrt(nv[0] ** 2 + nv[1] ** 2)\n      nv[0] *= d / nvlen\n      nv[1] *= d / nvlen\n    end\n  end\n\n  b2 = [b1[0] + nv[0], b1[1] + nv[1]]\n  b3 = [b0[0] + nv[0], b0[1] + nv[1]]\n\n  [b0, b1, b2, b3]\nend\n\ndef inside?(p0, trg)\n  lens = calc_trglen(trg)\n\n  op = nil\n  for i in (0..2)\n    j = (i + 1) % 3\n    pv = [p0[0] - trg[i][0], p0[1] - trg[i][1]]\n    tv = [trg[j][0] - trg[i][0], trg[j][1] - trg[i][1]]\n    op_d = o_prod(pv, tv) / lens[i]\n    if op_d.abs > DELTA\n      if op.nil?\n        op = op_d\n      elsif op * op_d < 0\n        return false\n      end\n    end\n  end\n\n  #p [\"inside?\", p0, trg, true]\n  true\nend\n\ndef cross_lines?(u0, u1, v0, v1)\n  if dist2(u0, v0) <= DELTA2 || dist2(u0, v1) <= DELTA2 ||\n      dist2(u1, v0) <= DELTA2 || dist2(u1, v1) <= DELTA2\n    return true\n  end\n\n  # x = dux * t + u0x = dvx * s + v0x\n  # y = duy * t + u0y = dvy * s + v0y\n  # dux * t - dvx * s = v0x - u0x\n  # duy * t - dvy * s = v0y - u0y\n  # |dux -dvx| |t| = |v0x-u0x|\n  # |duy -dvy| |s|   |v0y-u0y|\n  # det == dux*(-dvy)-(-dvx)*duy = -dux*dvy+dvx*duy\n  # |t| = 1/det * |-dvy dvx| |v0x-u0x|\n  # |s|           |-duy dux| |v0y-u0y|\n\n  dux = u1[0] - u0[0]\n  duy = u1[1] - u0[1]\n  dvx = v1[0] - v0[0]\n  dvy = v1[1] - v0[1]\n\n  det = -dux * dvy + dvx * duy\n  return false if det == 0\n\n  vux = v0[0] - u0[0]\n  vuy = v0[1] - u0[1]\n\n  t = (-dvy * vux + dvx * vuy) / det\n  s = (-duy * vux + dux * vuy) / det\n\n  #p [\"cl?\", u0, u1, v0, v1, t, s]\n  t >= 0.0 && t <= 1.0 && s >= 0.0 && s <= 1.0\nend\n\ndef cross_trgs?(trg0, trg1)\n  for i in (0..2)\n    return true if inside?(trg0[i], trg1) || inside?(trg1[i], trg0)\n  end\n\n  for i0 in (0..2)\n    j0 = (i0 + 1) % 3\n    for i1 in (0..2)\n      j1 = (i1 + 1) % 3\n      return true if cross_lines?(trg0[i0], trg0[j0], trg1[i1], trg1[j1])\n    end\n  end\n  false\nend\n\ndef connected(id, i, n, edges, ids)\n  return if ! ids[i].nil?\n\n  ids[i] = id\n\n  for j in (0...n)\n    if ids[j].nil? && edges[i][j]\n      connected(id, j, n, edges, ids)\n    end\n  end\nend\n\n### main\n\nwhile true\n  n, d = gets.strip.split(' ').map{|s| s.to_i}\n  break if n == 0 && d == 0\n\n  trgs = []\n  n.times do\n    pts = gets.strip.split(' ').map{|s| s.to_f}\n    trgs << [[pts[0], pts[1]], [pts[2], pts[3]], [pts[4], pts[5]]]\n  end\n  #p trgs\n\n  rects = trgs.map{|trg| trg2rect(trg, d)}\n  #p rects\n\n  edges = n.times.map{n.times.map{false}}\n\n  for i in (0...n)\n    rct = rects[i]\n    rtrg0 = [rct[0], rct[1], rct[2]]\n    rtrg1 = [rct[0], rct[2], rct[3]]\n\n    for j in (0...n)\n      next if i == j\n\n      if cross_trgs?(trgs[j], rtrg0) || cross_trgs?(trgs[j], rtrg1)\n        #p [i, j]\n        edges[i][j] = edges[j][i] = true\n      end\n    end\n  end\n  #p edges\n\n  id = 0\n  ids = n.times.map{nil}\n\n  for i in (0...n)\n    if ids[i].nil?\n      connected(id, i, n, edges, ids)\n      id += 1\n    end\n  end\n  #p ids\n\n  puts id\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nDELTA = 0.01\nDELTA2 = DELTA ** 2\n\n### subroutines\n\ndef i_prod(v0, v1)\n  v0[0] * v1[0] + v0[1] * v1[1]\nend\n\ndef o_prod(v0, v1)\n  v0[0] * v1[1] - v0[1] * v1[0]\nend\n\ndef calc_trglen(trg)\n  if trg[3].nil?\n    for i in (0..2)\n      j = (i + 1) % 3\n      x0, y0 = trg[i]\n      x1, y1 = trg[j]\n      trg[i + 3] = Math.sqrt((x1 - x0) ** 2 + (y1 - y0) ** 2)\n    end\n  end\n\n  trg[3..5]\nend\n\ndef trg2rect(trg, d)\n  lens = calc_trglen(trg)\n\n  b0 = nil\n  b1 = nil\n  nv = nil\n\n  for i0 in (0..2)\n    i1 = (i0 + 1) % 3\n    i2 = (i1 + 1) % 3\n    if (lens[i1] - lens[i2]).abs <= DELTA\n      b0 = trg[i0]\n      b1 = trg[i1]\n      nv = [-b1[1] + b0[1], b1[0] - b0[0]]\n      v02 = [trg[i2][0] - b0[0], trg[i2][1] - b0[1]]\n      nv = [-nv[0], -nv[1]] if i_prod(nv, v02) < 0\n      nvlen = Math.sqrt(nv[0] ** 2 + nv[1] ** 2)\n      nv[0] *= d / nvlen\n      nv[1] *= d / nvlen\n    end\n  end\n\n  b2 = [b1[0] + nv[0], b1[1] + nv[1]]\n  b3 = [b0[0] + nv[0], b0[1] + nv[1]]\n\n  [b0, b1, b2, b3]\nend\n\ndef inside?(p0, trg)\n  lens = calc_trglen(trg)\n\n  op = nil\n  for i in (0..2)\n    j = (i + 1) % 3\n    pv = [p0[0] - trg[i][0], p0[1] - trg[i][1]]\n    tv = [trg[j][0] - trg[i][0], trg[j][1] - trg[i][1]]\n    op_d = o_prod(pv, tv) / lens[i]\n    if op_d.abs > DELTA\n      if op.nil?\n        op = op_d\n      elsif op * op_d < 0\n        return false\n      end\n    end\n  end\n\n  #p [\"inside?\", p0, trg, true]\n  true\nend\n\ndef cross_lines?(u0, u1, v0, v1)\n  # x = dux * t + u0x = dvx * s + v0x\n  # y = duy * t + u0y = dvy * s + v0y\n  # dux * t - dvx * s = v0x - u0x\n  # duy * t - dvy * s = v0y - u0y\n  # |dux -dvx| |t| = |v0x-u0x|\n  # |duy -dvy| |s|   |v0y-u0y|\n  # det == dux*(-dvy)-(-dvx)*duy = -dux*dvy+dvx*duy\n  # |t| = 1/det * |-dvy dvx| |v0x-u0x|\n  # |s|           |-duy dux| |v0y-u0y|\n\n  dux = u1[0] - u0[0]\n  duy = u1[1] - u0[1]\n  dvx = v1[0] - v0[0]\n  dvy = v1[1] - v0[1]\n\n  det = -dux * dvy + dvx * duy\n  return false if det == 0\n\n  vux = v0[0] - u0[0]\n  vuy = v0[1] - u0[1]\n\n  t = (-dvy * vux + dvx * vuy) / det\n  s = (-duy * vux + dux * vuy) / det\n\n  #p [\"cl?\", u0, u1, v0, v1, t, s]\n  t >= 0.0 && t <= 1.0 && s >= 0.0 && s <= 1.0\nend\n\ndef cross_trgs?(trg0, trg1)\n  for i in (0..2)\n    return true if inside?(trg0[i], trg1) || inside?(trg1[i], trg0)\n  end\n\n  for i0 in (0..2)\n    j0 = (i0 + 1) % 3\n    for i1 in (0..2)\n      j1 = (i1 + 1) % 3\n      return true if cross_lines?(trg0[i0], trg0[j0], trg1[i1], trg1[j1])\n    end\n  end\n  false\nend\n\n### main\n\nwhile true\n  n, d = gets.strip.split(' ').map{|s| s.to_i}\n  break if n == 0 && d == 0\n\n  trgs = []\n  n.times do\n    pts = gets.strip.split(' ').map{|s| s.to_f}\n    trgs << [[pts[0], pts[1]], [pts[2], pts[3]], [pts[4], pts[5]]]\n  end\n  #p trgs\n\n  rects = trgs.map{|trg| trg2rect(trg, d)}\n  #p rects\n\n  origins = n.times.map{true}\n\n  for i in (0...n)\n    rct = rects[i]\n    rtrg0 = [rct[0], rct[1], rct[2]]\n    rtrg1 = [rct[0], rct[2], rct[3]]\n\n    for j in (0...n)\n      next if i == j || ! origins[j]\n\n      if cross_trgs?(trgs[j], rtrg0) || cross_trgs?(trgs[j], rtrg1)\n        #p [i, j]\n        origins[j] = false\n        break\n      end\n    end\n  end\n\n  puts origins.select{|tf| tf}.length\nend"
  },
  {
    "language": "Python",
    "code": "from itertools import combinations\n\ndef get_dist(x1, y1, x2, y2):\n  return ((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\n\ndef get_base_point(base, point):\n  x1, y1, x2, y2, x3, y3 = point\n  a = get_dist(x1, y1, x2, y2)\n  b = get_dist(x2, y2, x3, y3)\n  c = get_dist(x3, y3, x1, y1)\n  tmp = min(a, b, c, key=lambda x:abs(x - base))\n  if tmp == a:\n    return (x1, y1, x2, y2, x3, y3)\n  if tmp == b:\n    return (x2, y2, x3, y3, x1, y1)\n  if tmp == c:\n    return (x3, y3, x1, y1, x2, y2)\n\n\ndef cross(point1, point2, point3, point4):\n  x1, y1 = point1\n  x2, y2 = point2\n  x3, y3 = point3\n  x4, y4 = point4\n  if (y2 - y1) * (x4 - x3) == (x2 - x1) * (y4 - y3):\n    return False\n  k = ((y1 - y3) * (x4 - x3) - (x1 - x3) * (y4 - y3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1))\n \n  if not (0 <= k <= 1):\n    return False\n \n  x5 = x1 + k * (x2 - x1)\n  y5 = y1 + k * (y2 - y1)\n  if min(x3, x4) <= x5 <= max(x3, x4) and min(y3, y4) <= y5 <= max(y3, y4):\n    return True\n  return False\n\n\ndef touch(tr1, tr2, d, base):\n  tr1 = get_base_point(base, tr1)\n  x1, y1, x2, y2, x3, y3 = tr1\n  v12x, v12y = (x2 - x1, y2 - y1)\n  v13x, v13y = (x3 - x1, y3 - y1)\n  v14x, v14y = v12y * d / (v12x ** 2 + v12y ** 2) ** (1 / 2), -v12x * d / (v12x ** 2 + v12y ** 2) ** (1 / 2)\n  if v14x * v13x + v14y * v13y < 0:\n    v14x *= -1\n    v14y *= -1\n  p1 = (x1, y1)\n  p2 = (x2, y2)\n  p4 = (x1 + v14x, y1 + v14y)\n  p5 = (x2 + v14x, y2 + v14y)\n  x6, y6, x7, y7, x8, y8 = tr2\n  p6 = (x6, y6)\n  p7 = (x7, y7)\n  p8 = (x8, y8)\n  for point1, point2 in combinations((p1, p2, p4, p5), 2):\n    for point3, point4 in combinations((p6, p7, p8), 2):\n      if cross(point1, point2, point3, point4):\n        return True\n\n\ndef bfs(i, visited, edges, order):\n  visited[i] = True\n  for to in edges[i]:\n    if not visited[to]:\n      bfs(to, visited, edges, order)\n  order.append(i)\n\n\nwhile True:\n  n, d = map(int, input().split())\n  if n == 0:\n    break\n  points = [list(map(int, input().split())) for _ in range(n)]\n  \n  point = points[0]\n  a = get_dist(point[0], point[1], point[2], point[3])\n  b = get_dist(point[2], point[3], point[4], point[5])\n  c = get_dist(point[4], point[5], point[0], point[1])\n  base = -1\n  if [a, b, c].count(a) == 1:\n    base = a\n  else:  \n    base = b\n  #print(base)\n  \n  edges = [[] for _ in range(n)]\n  for i, tr1 in enumerate(points):\n    for j, tr2 in enumerate(points):\n      if i != j:\n        if touch(tr1, tr2, d, base):\n          edges[i].append(j)\n\n  order = []\n  visited = [False] * n\n  for i in range(n):\n    if not visited[i]:\n      bfs(i, visited, edges, order)\n  order.reverse()\n  \n\n  visited = [False] * n\n  lst = []\n  cnt = 0\n  for i in order:\n    if not visited[i]:\n      cnt += 1\n      bfs(i, visited, edges, lst)\n  print(cnt)\n"
  },
  {
    "language": "Python",
    "code": "E = 0.01\n\ndef get_dist(x1, y1, x2, y2):\n  return ((x2 - x1) ** 2 + (y2 - y1) ** 2) * (1 / 2)\n\ndef get_base_point(base, point):\n  a = get_dist(point[0], point[1], point[2], point[3])\n  b = get_dist(point[2], point[3], point[4], point[5])\n  c = get_dist(point[4], point[5], point[0], point[1])\n  tmp = min(a, b, c, key=lambda x:abs(x - base))\n  if tmp == a:\n    return (point[0], point[1], point[2], point[3], point[4], point[5])\n  if tmp == b:\n    return (point[2], point[3], point[4], point[5], point[0], point[1])\n  if tmp == c:\n    return (point[4], point[5], point[0], point[1], point[2], point[3])\n\ndef touch(x1, y1, x2, y2, x3, y3, x4, y4, d):\n  k = -((x2 - x1) * (x1 - x4) + (y1 - y4) * (y2 - y1)) / ((x2 - x1) ** 2 + (y2 - y1) ** 2)\n  #print(k)\n  if not (0 <= k <= 1):\n    return False\n  \n  px = x1 + (x2 - x1) * k\n  py = y1 + (y2 - y1) * k\n  #print(px, py)\n  if abs(((px - x4) ** 2 + (py - y4) ** 2) ** (1 / 2)) <= d and (x4 - x1) * (x3 - x1) + (y4 - y1) * (y3 - y1) >= 0:\n    return True\n  else:\n    return False\n\ndef bfs(i, visited, edges, order):\n  visited[i] = True\n  for to in edges[i]:\n    if not visited[to]:\n      bfs(to, visited, edges, order)\n  order.append(i)\n\nwhile True:\n  n, d = map(int, input().split())\n  if n == 0:\n    break\n  points = [list(map(int, input().split())) for _ in range(n)]\n  \n  point = points[0]\n  a = get_dist(point[0], point[1], point[2], point[3])\n  b = get_dist(point[2], point[3], point[4], point[5])\n  c = get_dist(point[4], point[5], point[0], point[1])\n  base = -1\n  if [a, b, c].count(a) == 1:\n    base = a\n  else:  \n    base = b\n  #print(base)\n  \n  edges = [[] for _ in range(n)]\n  for i, point1 in enumerate(points):\n    x1, y1, x2, y2, x3, y3 = get_base_point(base, point1)\n    #print(x1, y1, x2, y2, x3, y3)\n    for j, point2 in enumerate(points):\n      if i != j:\n        for k in range(3):\n          if touch(x1, y1, x2, y2, x3, y3, point2[k * 2], point2[k * 2 + 1], d):\n            #print(\"from\", i, \"to\", j, \"is ok.\")\n            edges[i].append(j)\n            break\n\n  order = []\n  visited = [False] * n\n  for i in range(n):\n    if not visited[i]:\n      bfs(i, visited, edges, order)\n  order.reverse()\n  \n\n  visited = [False] * n\n  lst = []\n  cnt = 0\n  for i in order:\n    if not visited[i]:\n      cnt += 1\n      bfs(i, visited, edges, lst)\n  print(cnt)\n"
  },
  {
    "language": "Python",
    "code": "from itertools import combinations\n\ndef get_dist(x1, y1, x2, y2):\n  return ((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\n\ndef get_base_point(base, point):\n  x1, y1, x2, y2, x3, y3 = point\n  a = get_dist(x1, y1, x2, y2)\n  b = get_dist(x2, y2, x3, y3)\n  c = get_dist(x3, y3, x1, y1)\n  tmp = min(a, b, c, key=lambda x:abs(x - base))\n  if tmp == a:\n    return (x1, y1, x2, y2, x3, y3)\n  if tmp == b:\n    return (x2, y2, x3, y3, x1, y1)\n  if tmp == c:\n    return (x3, y3, x1, y1, x2, y2)\n\n\ndef cross(point1, point2, point3, point4):\n  x1, y1 = point1\n  x2, y2 = point2\n  x3, y3 = point3\n  x4, y4 = point4\n  if (y2 - y1) * (x4 - x3) == (x2 - x1) * (y4 - y3):\n    return False\n  k = ((x1 - y3) * (x4 - x3) - (x1 - x3) * (y4 - y3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1))\n \n  if not (0 <= k <= 1):\n    return False\n \n  x5 = x1 + k * (x2 - x1)\n  y5 = y1 + k * (y2 - y1)\n  if min(x3, x4) <= x5 <= max(x3, x4) and min(y3, y4) <= y5 <= max(y3, y4):\n    return True\n  return False\n\n\ndef touch(tr1, tr2, d, base):\n  tr1 = get_base_point(base, tr1)\n  x1, y1, x2, y2, x3, y3 = tr1\n  v12x, v12y = (x2 - x1, y2 - y1)\n  v13x, v13y = (x3 - x1, y3 - y1)\n  v14x, v14y = v12y * d / (v12x ** 2 + v12y ** 2) ** (1 / 2), -v12x * d / (v12x ** 2 + v12y ** 2) ** (1 / 2)\n  if v14x * v13x + v14y * v13y < 0:\n    v14x *= -1\n    v14y *= -1\n  p1 = (x1, y1)\n  p2 = (x2, y2)\n  p4 = (x1 + v14x, y1 + v14y)\n  p5 = (x2 + v14x, y2 + v14y)\n  x6, y6, x7, y7, x8, y8 = tr2\n  p6 = (x6, y6)\n  p7 = (x7, y7)\n  p8 = (x8, y8)\n  for point1, point2 in combinations((p1, p2, p4, p5), 2):\n    for point3, point4 in combinations((p6, p7, p8), 2):\n      if cross(point1, point2, point3, point4):\n        return True\n\n\ndef bfs(i, visited, edges, order):\n  visited[i] = True\n  for to in edges[i]:\n    if not visited[to]:\n      bfs(to, visited, edges, order)\n  order.append(i)\n\n\nwhile True:\n  n, d = map(int, input().split())\n  if n == 0:\n    break\n  points = [list(map(int, input().split())) for _ in range(n)]\n  \n  point = points[0]\n  a = get_dist(point[0], point[1], point[2], point[3])\n  b = get_dist(point[2], point[3], point[4], point[5])\n  c = get_dist(point[4], point[5], point[0], point[1])\n  base = -1\n  if [a, b, c].count(a) == 1:\n    base = a\n  else:  \n    base = b\n  #print(base)\n  \n  edges = [[] for _ in range(n)]\n  for i, tr1 in enumerate(points):\n    for j, tr2 in enumerate(points):\n      if i != j:\n        if touch(tr1, tr2, d, base):\n          edges[i].append(j)\n\n  order = []\n  visited = [False] * n\n  for i in range(n):\n    if not visited[i]:\n      bfs(i, visited, edges, order)\n  order.reverse()\n  \n\n  visited = [False] * n\n  lst = []\n  cnt = 0\n  for i in order:\n    if not visited[i]:\n      cnt += 1\n      bfs(i, visited, edges, lst)\n  print(cnt)\n"
  },
  {
    "language": "Python",
    "code": "E = 0.01\n\ndef get_dist(x1, y1, x2, y2):\n  return ((x2 - x1) ** 2 + (y2 - y1) ** 2) * (1 / 2)\n\ndef get_base_point(base, point):\n  x1, y1, x2, y2, x3, y3 = point\n  a = get_dist(x1, y1, x2, y2)\n  b = get_dist(x2, y2, x3, y3)\n  c = get_dist(x3, y3, x1, y1)\n  tmp = min(a, b, c, key=lambda x:abs(x - base))\n  if tmp == a:\n    return (x1, y1, x2, y2, x3, y3)\n  if tmp == b:\n    return (x2, y2, x3, y3, x1, y1)\n  if tmp == c:\n    return (x3, y3, x1, y1, x2, y2)\n\ndef touch(x1, y1, x2, y2, x3, y3, x4, y4, d):\n  k = -((x2 - x1) * (x1 - x4) + (y1 - y4) * (y2 - y1)) / ((x2 - x1) ** 2 + (y2 - y1) ** 2)\n  #print(k)\n  if not (0 <= k <= 1):\n    return False\n  \n  px = x1 + (x2 - x1) * k\n  py = y1 + (y2 - y1) * k\n  #print(px, py)\n  if abs(((px - x4) ** 2 + (py - y4) ** 2) ** (1 / 2)) + E <= d and (px - x3) * (px - x4) + (py - y3) * (py - y4) >= 0:\n    return True\n  else:\n    return False\n\ndef bfs(i, visited, edges, order):\n  visited[i] = True\n  for to in edges[i]:\n    if not visited[to]:\n      bfs(to, visited, edges, order)\n  order.append(i)\n\nwhile True:\n  n, d = map(int, input().split())\n  if n == 0:\n    break\n  points = [list(map(int, input().split())) for _ in range(n)]\n  \n  point = points[0]\n  a = get_dist(point[0], point[1], point[2], point[3])\n  b = get_dist(point[2], point[3], point[4], point[5])\n  c = get_dist(point[4], point[5], point[0], point[1])\n  base = -1\n  if [a, b, c].count(a) == 1:\n    base = a\n  else:  \n    base = b\n  #print(base)\n  \n  edges = [[] for _ in range(n)]\n  for i, point1 in enumerate(points):\n    x1, y1, x2, y2, x3, y3 = get_base_point(base, point1)\n    #print(x1, y1, x2, y2, x3, y3)\n    for j, point2 in enumerate(points):\n      if i != j:\n        for k in range(3):\n          if touch(x1, y1, x2, y2, x3, y3, point2[k * 2], point2[k * 2 + 1], d):\n            #print(\"from\", i, \"to\", j, \"is ok.\")\n            edges[i].append(j)\n            break\n\n  order = []\n  visited = [False] * n\n  for i in range(n):\n    if not visited[i]:\n      bfs(i, visited, edges, order)\n  order.reverse()\n  \n\n  visited = [False] * n\n  lst = []\n  cnt = 0\n  for i in order:\n    if not visited[i]:\n      cnt += 1\n      bfs(i, visited, edges, lst)\n  print(cnt)\n"
  },
  {
    "language": "Python",
    "code": "E = 0.01\n\ndef get_dist(x1, y1, x2, y2):\n  return ((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef get_base_point(base, point):\n  x1, y1, x2, y2, x3, y3 = point\n  a = get_dist(x1, y1, x2, y2)\n  b = get_dist(x2, y2, x3, y3)\n  c = get_dist(x3, y3, x1, y1)\n  tmp = min(a, b, c, key=lambda x:abs(x - base))\n  if tmp == a:\n    return (x1, y1, x2, y2, x3, y3)\n  if tmp == b:\n    return (x2, y2, x3, y3, x1, y1)\n  if tmp == c:\n    return (x3, y3, x1, y1, x2, y2)\n\ndef touch(x1, y1, x2, y2, x3, y3, x4, y4, d):\n  k = -((x2 - x1) * (x1 - x4) + (y1 - y4) * (y2 - y1)) / ((x2 - x1) ** 2 + (y2 - y1) ** 2)\n  #print(k)\n  if not (0 - E <= k <= 1 + E):\n    return False\n  \n  px = x1 + (x2 - x1) * k\n  py = y1 + (y2 - y1) * k\n  #print(px, py)\n  if ((px - x4) ** 2 + (py - y4) ** 2) ** (1 / 2) <= d + E and (px - x3) * (px - x4) + (py - y3) * (py - y4) >= 0:\n    return True\n  else:\n    return False\n\ndef bfs(i, visited, edges, order):\n  visited[i] = True\n  for to in edges[i]:\n    if not visited[to]:\n      bfs(to, visited, edges, order)\n  order.append(i)\n\nwhile True:\n  n, d = map(int, input().split())\n  if n == 0:\n    break\n  points = [list(map(int, input().split())) for _ in range(n)]\n  \n  point = points[0]\n  a = get_dist(point[0], point[1], point[2], point[3])\n  b = get_dist(point[2], point[3], point[4], point[5])\n  c = get_dist(point[4], point[5], point[0], point[1])\n  base = -1\n  if [a, b, c].count(a) == 1:\n    base = a\n  else:  \n    base = b\n  #print(base)\n  \n  edges = [[] for _ in range(n)]\n  for i, point1 in enumerate(points):\n    x1, y1, x2, y2, x3, y3 = get_base_point(base, point1)\n    #print(x1, y1, x2, y2, x3, y3)\n    for j, point2 in enumerate(points):\n      if i != j:\n        for k in range(3):\n          if touch(x1, y1, x2, y2, x3, y3, point2[k * 2], point2[k * 2 + 1], d):\n            #print(\"from\", i, \"to\", j, \"is ok.\")\n            edges[i].append(j)\n            break\n\n  order = []\n  visited = [False] * n\n  for i in range(n):\n    if not visited[i]:\n      bfs(i, visited, edges, order)\n  order.reverse()\n  \n\n  visited = [False] * n\n  lst = []\n  cnt = 0\n  for i in order:\n    if not visited[i]:\n      cnt += 1\n      bfs(i, visited, edges, lst)\n  print(cnt)\n"
  },
  {
    "language": "Python",
    "code": "E = 0.01\n\ndef get_dist(x1, y1, x2, y2):\n  return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** (1 / 2)\n\ndef get_base_point(base, point):\n  x1, y1, x2, y2, x3, y3 = point\n  a = get_dist(x1, y1, x2, y2)\n  b = get_dist(x2, y2, x3, y3)\n  c = get_dist(x3, y3, x1, y1)\n  tmp = min(a, b, c, key=lambda x:abs(x - base))\n  if tmp == a:\n    return (x1, y1, x2, y2, x3, y3)\n  if tmp == b:\n    return (x2, y2, x3, y3, x1, y1)\n  if tmp == c:\n    return (x3, y3, x1, y1, x2, y2)\n\ndef touch(x1, y1, x2, y2, x3, y3, x4, y4, d):\n  k = -((x2 - x1) * (x1 - x4) + (y1 - y4) * (y2 - y1)) / ((x2 - x1) ** 2 + (y2 - y1) ** 2)\n  #print(k)\n  if not (0 <= k <= 1):\n    return False\n  \n  px = x1 + (x2 - x1) * k\n  py = y1 + (y2 - y1) * k\n  #print(px, py)\n  if abs(((px - x4) ** 2 + (py - y4) ** 2) ** (1 / 2)) + E <= d and (px - x3) * (px - x4) + (py - y3) * (py - y4) >= 0:\n    return True\n  else:\n    return False\n\ndef bfs(i, visited, edges, order):\n  visited[i] = True\n  for to in edges[i]:\n    if not visited[to]:\n      bfs(to, visited, edges, order)\n  order.append(i)\n\nwhile True:\n  n, d = map(int, input().split())\n  if n == 0:\n    break\n  points = [list(map(int, input().split())) for _ in range(n)]\n  \n  point = points[0]\n  a = get_dist(point[0], point[1], point[2], point[3])\n  b = get_dist(point[2], point[3], point[4], point[5])\n  c = get_dist(point[4], point[5], point[0], point[1])\n  base = -1\n  if [a, b, c].count(a) == 1:\n    base = a\n  else:  \n    base = b\n  #print(base)\n  \n  edges = [[] for _ in range(n)]\n  for i, point1 in enumerate(points):\n    x1, y1, x2, y2, x3, y3 = get_base_point(base, point1)\n    #print(x1, y1, x2, y2, x3, y3)\n    for j, point2 in enumerate(points):\n      if i != j:\n        for k in range(3):\n          if touch(x1, y1, x2, y2, x3, y3, point2[k * 2], point2[k * 2 + 1], d):\n            #print(\"from\", i, \"to\", j, \"is ok.\")\n            edges[i].append(j)\n            break\n\n  order = []\n  visited = [False] * n\n  for i in range(n):\n    if not visited[i]:\n      bfs(i, visited, edges, order)\n  order.reverse()\n  \n\n  visited = [False] * n\n  lst = []\n  cnt = 0\n  for i in order:\n    if not visited[i]:\n      cnt += 1\n      bfs(i, visited, edges, lst)\n  print(cnt)\n"
  },
  {
    "language": "Python",
    "code": "E = 0.01\n\ndef get_dist(x1, y1, x2, y2):\n  return ((x2 - x1) ** 2 + (y2 - y1) ** 2) * (1 / 2)\n\ndef get_base_point(base, point):\n  x1, y1, x2, y2, x3, y3 = point\n  a = get_dist(x1, y1, x2, y2)\n  b = get_dist(x2, y2, x3, y3)\n  c = get_dist(x3, y3, x1, y1)\n  tmp = min(a, b, c, key=lambda x:abs(x - base))\n  if tmp == a:\n    return (x1, y1, x2, y2, x3, y3)\n  if tmp == b:\n    return (x2, y2, x3, y3, x1, y1)\n  if tmp == c:\n    return (x3, y3, x1, y1, x2, y2)\n\ndef touch(x1, y1, x2, y2, x3, y3, x4, y4, d):\n  k = -((x2 - x1) * (x1 - x4) + (y1 - y4) * (y2 - y1)) / ((x2 - x1) ** 2 + (y2 - y1) ** 2)\n  #print(k)\n  if not (0 <= k <= 1):\n    return False\n  \n  px = x1 + (x2 - x1) * k\n  py = y1 + (y2 - y1) * k\n  #print(px, py)\n  if abs(((px - x4) ** 2 + (py - y4) ** 2) ** (1 / 2)) + E <= d and (x4 - x1) * (x3 - x1) + (y4 - y1) * (y3 - y1) >= 0:\n    return True\n  else:\n    return False\n\ndef bfs(i, visited, edges, order):\n  visited[i] = True\n  for to in edges[i]:\n    if not visited[to]:\n      bfs(to, visited, edges, order)\n  order.append(i)\n\nwhile True:\n  n, d = map(int, input().split())\n  if n == 0:\n    break\n  points = [list(map(int, input().split())) for _ in range(n)]\n  \n  point = points[0]\n  a = get_dist(point[0], point[1], point[2], point[3])\n  b = get_dist(point[2], point[3], point[4], point[5])\n  c = get_dist(point[4], point[5], point[0], point[1])\n  base = -1\n  if [a, b, c].count(a) == 1:\n    base = a\n  else:  \n    base = b\n  #print(base)\n  \n  edges = [[] for _ in range(n)]\n  for i, point1 in enumerate(points):\n    x1, y1, x2, y2, x3, y3 = get_base_point(base, point1)\n    #print(x1, y1, x2, y2, x3, y3)\n    for j, point2 in enumerate(points):\n      if i != j:\n        for k in range(3):\n          if touch(x1, y1, x2, y2, x3, y3, point2[k * 2], point2[k * 2 + 1], d):\n            #print(\"from\", i, \"to\", j, \"is ok.\")\n            edges[i].append(j)\n            break\n\n  order = []\n  visited = [False] * n\n  for i in range(n):\n    if not visited[i]:\n      bfs(i, visited, edges, order)\n  order.reverse()\n  \n\n  visited = [False] * n\n  lst = []\n  cnt = 0\n  for i in order:\n    if not visited[i]:\n      cnt += 1\n      bfs(i, visited, edges, lst)\n  print(cnt)\n"
  }
]