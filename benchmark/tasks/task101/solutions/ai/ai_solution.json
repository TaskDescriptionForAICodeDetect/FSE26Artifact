[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdbool.h>\n\n#define EPSILON 0.01\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point a, b, c;\n} Triangle;\n\ntypedef struct {\n    int size;\n    int capacity;\n    int* data;\n} Stack;\n\nStack* create_stack(int capacity) {\n    Stack* stack = (Stack*)malloc(sizeof(Stack));\n    stack->data = (int*)malloc(capacity * sizeof(int));\n    stack->size = 0;\n    stack->capacity = capacity;\n    return stack;\n}\n\nvoid push(Stack* stack, int item) {\n    if (stack->size < stack->capacity) {\n        stack->data[stack->size++] = item;\n    }\n}\n\nint pop(Stack* stack) {\n    if (stack->size > 0) {\n        return stack->data[--stack->size];\n    }\n    return -1;\n}\n\nbool is_empty(Stack* stack) {\n    return stack->size == 0;\n}\n\nvoid free_stack(Stack* stack) {\n    free(stack->data);\n    free(stack);\n}\n\ndouble distance(Point p1, Point p2) {\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\nPoint centroid(Triangle t) {\n    Point center;\n    center.x = (t.a.x + t.b.x + t.c.x) / 3.0;\n    center.y = (t.a.y + t.b.y + t.c.y) / 3.0;\n    return center;\n}\n\nbool is_illuminating(Point p1, Point p2, double d) {\n    return distance(p1, p2) <= d + EPSILON;\n}\n\nvoid dfs(int node, bool* visited, bool* graph, int n) {\n    Stack* stack = create_stack(n);\n    push(stack, node);\n    visited[node] = true;\n\n    while (!is_empty(stack)) {\n        int current = pop(stack);\n        for (int i = 0; i < n; ++i) {\n            if (graph[current * n + i] && !visited[i]) {\n                visited[i] = true;\n                push(stack, i);\n            }\n        }\n    }\n    free_stack(stack);\n}\n\nint main() {\n    int n;\n    double d;\n    scanf(\"%d %lf\", &n, &d);\n\n    Triangle* triangles = (Triangle*)malloc(n * sizeof(Triangle));\n    Point* centers = (Point*)malloc(n * sizeof(Point));\n\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%lf %lf %lf %lf %lf %lf\", &triangles[i].a.x, &triangles[i].a.y,\n              &triangles[i].b.x, &triangles[i].b.y,\n              &triangles[i].c.x, &triangles[i].c.y);\n        centers[i] = centroid(triangles[i]);\n    }\n\n    bool* graph = (bool*)calloc(n * n, sizeof(bool));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i != j && is_illuminating(centers[i], centers[j], d)) {\n                graph[i * n + j] = true;\n            }\n        }\n    }\n\n    bool* visited = (bool*)calloc(n, sizeof(bool));\n    int components = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            dfs(i, visited, graph, n);\n            components++;\n        }\n    }\n\n    printf(\"%d\\n\", components);\n\n    free(triangles);\n    free(centers);\n    free(graph);\n    free(visited);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:37:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CaveDoorIllumination {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n        \n        boolean equals(Point other) {\n            return Math.abs(x - other.x) <= 0.01 && Math.abs(y - other.y) <= 0.01;\n        }\n        \n        double distanceTo(Point other) {\n            return Math.sqrt(Math.pow(x - other.x, 2) + Math.pow(y - other.y, 2));\n        }\n    }\n    \n    static class Triangle {\n        Point a, b, c;\n        boolean illuminated;\n        \n        Triangle(Point a, Point b, Point c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n            this.illuminated = false;\n        }\n    }\n    \n    static boolean trianglesConnected(Triangle t1, Triangle t2, double lightDistance) {\n        Point[] points1 = {t1.a, t1.b, t1.c};\n        Point[] points2 = {t2.a, t2.b, t2.c};\n        \n        for (Point p1 : points1) {\n            for (Point p2 : points2) {\n                if (p1.distanceTo(p2) <= lightDistance) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    static int minimumTouches(Triangle[] triangles, double lightDistance) {\n        int touches = 0;\n        \n        while (true) {\n            boolean allIlluminated = true;\n            for (Triangle t : triangles) {\n                if (!t.illuminated) {\n                    allIlluminated = false;\n                    break;\n                }\n            }\n            if (allIlluminated) break;\n            \n            int bestTriangleIndex = -1;\n            int maxIllumination = 0;\n            \n            for (int i = 0; i < triangles.length; i++) {\n                if (!triangles[i].illuminated) {\n                    int currentIllumination = 0;\n                    triangles[i].illuminated = true;\n                    \n                    for (Triangle t : triangles) {\n                        if (!t.illuminated && trianglesConnected(triangles[i], t, lightDistance)) {\n                            t.illuminated = true;\n                            currentIllumination++;\n                        }\n                    }\n                    \n                    triangles[i].illuminated = false;\n                    \n                    if (currentIllumination > maxIllumination) {\n                        maxIllumination = currentIllumination;\n                        bestTriangleIndex = i;\n                    }\n                }\n            }\n            \n            triangles[bestTriangleIndex].illuminated = true;\n            for (Triangle t : triangles) {\n                if (!t.illuminated && trianglesConnected(triangles[bestTriangleIndex], t, lightDistance)) {\n                    t.illuminated = true;\n                }\n            }\n            \n            touches++;\n        }\n        \n        return touches;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int n = scanner.nextInt();\n        double lightDistance = scanner.nextDouble();\n        \n        Triangle[] triangles = new Triangle[n];\n        \n        for (int i = 0; i < n; i++) {\n            Point a = new Point(scanner.nextDouble(), scanner.nextDouble());\n            Point b = new Point(scanner.nextDouble(), scanner.nextDouble());\n            Point c = new Point(scanner.nextDouble(), scanner.nextDouble());\n            triangles[i] = new Triangle(a, b, c);\n        }\n        \n        System.out.println(minimumTouches(triangles, lightDistance));\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:38:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <unordered_set>\n#include <queue>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    bool operator==(const Point& other) const {\n        return (fabs(x - other.x) <= 0.01 && fabs(y - other.y) <= 0.01);\n    }\n};\n\nstruct Triangle {\n    Point a, b, c;\n    Triangle(Point a, Point b, Point c) : a(a), b(b), c(c) {}\n};\n\ndouble distance(const Point& p1, const Point& p2) {\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\nbool isPointOnLine(const Point& p, const Point& lineStart, const Point& lineEnd) {\n    double cross = (lineEnd.x - lineStart.x) * (p.y - lineStart.y) - (lineEnd.y - lineStart.y) * (p.x - lineStart.x);\n    if (fabs(cross) > 0.01) return false;\n    double dot = (p.x - lineStart.x) * (lineEnd.x - lineStart.x) + (p.y - lineStart.y) * (lineEnd.y - lineStart.y);\n    if (dot < 0) return false;\n    double squaredLength = (lineEnd.x - lineStart.x) * (lineEnd.x - lineStart.x) + (lineEnd.y - lineStart.y) * (lineEnd.y - lineStart.y);\n    if (dot > squaredLength) return false;\n    return true;\n}\n\nbool isIlluminated(const Triangle& t1, const Triangle& t2, double d) {\n    vector<Point> t1Points = {t1.a, t1.b, t1.c};\n    vector<Point> t2Points = {t2.a, t2.b, t2.c};\n    \n    for (const Point& p1 : t1Points) {\n        for (const Point& p2 : t2Points) {\n            if (distance(p1, p2) <= d + 0.01) {\n                return true;\n            }\n        }\n    }\n    \n    for (const Point& p : t2Points) {\n        if (isPointOnLine(p, t1.a, t1.b) || isPointOnLine(p, t1.b, t1.c) || isPointOnLine(p, t1.c, t1.a)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    int n;\n    double d;\n    cin >> n >> d;\n    \n    vector<Triangle> triangles;\n    for (int i = 0; i < n; ++i) {\n        double x1, y1, x2, y2, x3, y3;\n        cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n        triangles.emplace_back(Point(x1, y1), Point(x2, y2), Point(x3, y3));\n    }\n    \n    vector<vector<int>> adj(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i != j && isIlluminated(triangles[i], triangles[j], d)) {\n                adj[i].push_back(j);\n            }\n        }\n    }\n    \n    unordered_set<int> visited;\n    int touches = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        if (visited.find(i) == visited.end()) {\n            queue<int> q;\n            q.push(i);\n            visited.insert(i);\n            touches++;\n            \n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n                \n                for (int v : adj[u]) {\n                    if (visited.find(v) == visited.end()) {\n                        visited.insert(v);\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n    \n    cout << touches << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:38:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdbool.h>\n#include <float.h>\n\n#define EPS 0.01\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point a, b, c;\n} Triangle;\n\ndouble distance(Point p1, Point p2) {\n    return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n}\n\nbool pointsEqual(Point p1, Point p2) {\n    return distance(p1, p2) <= EPS;\n}\n\nbool pointOnLine(Point p, Point start, Point end) {\n    double lineLength = distance(start, end);\n    double d1 = distance(start, p);\n    double d2 = distance(p, end);\n    return fabs(d1 + d2 - lineLength) <= EPS;\n}\n\nbool trianglesConnected(Triangle t1, Triangle t2, double maxDistance) {\n    Point t1Points[] = {t1.a, t1.b, t1.c};\n    Point t2Points[] = {t2.a, t2.b, t2.c};\n\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (distance(t1Points[i], t2Points[j]) <= maxDistance)\n                return true;\n        }\n    }\n    return false;\n}\n\nint minimumTouches(Triangle* triangles, int n, double maxDistance) {\n    bool* touched = calloc(n, sizeof(bool));\n    int touches = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (!touched[i]) {\n            touches++;\n            for (int j = 0; j < n; j++) {\n                if (!touched[j] && trianglesConnected(triangles[i], triangles[j], maxDistance)) {\n                    touched[j] = true;\n                }\n            }\n            touched[i] = true;\n        }\n    }\n\n    free(touched);\n    return touches;\n}\n\nint main() {\n    int n;\n    double maxDistance;\n    scanf(\"%d %lf\", &n, &maxDistance);\n\n    Triangle* triangles = malloc(n * sizeof(Triangle));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf %lf %lf %lf %lf\", \n              &triangles[i].a.x, &triangles[i].a.y, \n              &triangles[i].b.x, &triangles[i].b.y, \n              &triangles[i].c.x, &triangles[i].c.y);\n    }\n\n    int result = minimumTouches(triangles, n, maxDistance);\n    printf(\"%d\\n\", result);\n\n    free(triangles);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:38:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <limits>\n#include <iomanip>\n\nconst double EPS = 0.01;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    \n    bool operator==(const Point& other) const {\n        return std::abs(x - other.x) <= EPS && std::abs(y - other.y) <= EPS;\n    }\n};\n\nstruct Triangle {\n    Point p1, p2, p3;\n    bool illuminated = false;\n};\n\ndouble distance(const Point& a, const Point& b) {\n    return std::sqrt(std::pow(a.x - b.x, 2) + std::pow(a.y - b.y, 2));\n}\n\nbool isPointOnLine(const Point& p, const Point& a, const Point& b) {\n    double crossProduct = std::abs((p.x - a.x) * (b.y - a.y) - (p.y - a.y) * (b.x - a.x));\n    return crossProduct <= EPS * distance(a, b);\n}\n\nbool canIlluminate(const Triangle& source, const Triangle& target, double maxDistance) {\n    std::vector<Point> sourcePoints = {source.p1, source.p2, source.p3};\n    std::vector<Point> targetPoints = {target.p1, target.p2, target.p3};\n    \n    for (const auto& sp : sourcePoints) {\n        for (const auto& tp : targetPoints) {\n            if (distance(sp, tp) <= maxDistance) return true;\n        }\n    }\n    \n    return false;\n}\n\nint minimumTouches(std::vector<Triangle>& triangles, double maxDistance) {\n    int touches = 0;\n    int illuminatedCount = 0;\n    \n    while (illuminatedCount < triangles.size()) {\n        int bestTriangleIndex = -1;\n        int maxNewIlluminations = 0;\n        \n        for (int i = 0; i < triangles.size(); ++i) {\n            if (triangles[i].illuminated) continue;\n            \n            int newIlluminations = 0;\n            for (int j = 0; j < triangles.size(); ++j) {\n                if (!triangles[j].illuminated && canIlluminate(triangles[i], triangles[j], maxDistance)) {\n                    ++newIlluminations;\n                }\n            }\n            \n            if (newIlluminations > maxNewIlluminations) {\n                maxNewIlluminations = newIlluminations;\n                bestTriangleIndex = i;\n            }\n        }\n        \n        if (bestTriangleIndex == -1) break;\n        \n        triangles[bestTriangleIndex].illuminated = true;\n        ++touches;\n        illuminatedCount++;\n        \n        for (int j = 0; j < triangles.size(); ++j) {\n            if (!triangles[j].illuminated && canIlluminate(triangles[bestTriangleIndex], triangles[j], maxDistance)) {\n                triangles[j].illuminated = true;\n                ++illuminatedCount;\n            }\n        }\n    }\n    \n    return illuminatedCount == triangles.size() ? touches : -1;\n}\n\nint main() {\n    int n;\n    double maxDistance;\n    std::cin >> n >> maxDistance;\n    \n    std::vector<Triangle> triangles(n);\n    \n    for (int i = 0; i < n; ++i) {\n        std::cin >> triangles[i].p1.x >> triangles[i].p1.y\n                 >> triangles[i].p2.x >> triangles[i].p2.y\n                 >> triangles[i].p3.x >> triangles[i].p3.y;\n    }\n    \n    int result = minimumTouches(triangles, maxDistance);\n    \n    if (result == -1) {\n        std::cout << \"Cannot illuminate all triangles\" << std::endl;\n    } else {\n        std::cout << result << std::endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:39:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Point {\n    double x, y;\n    Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Triangle {\n    Point a, b, c;\n    Triangle(Point a, Point b, Point c) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n\n    Point getCentroid() {\n        return new Point((a.x + b.x + c.x) / 3, (a.y + b.y + c.y) / 3);\n    }\n}\n\npublic class Main {\n    static final double EPSILON = 0.01;\n\n    static boolean canIlluminate(Point p1, Point p2, double distance) {\n        double dx = p1.x - p2.x;\n        double dy = p1.y - p2.y;\n        double dist = Math.sqrt(dx * dx + dy * dy);\n        return dist <= distance + EPSILON;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        double distance = scanner.nextDouble();\n        List<Triangle> triangles = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            Point a = new Point(scanner.nextDouble(), scanner.nextDouble());\n            Point b = new Point(scanner.nextDouble(), scanner.nextDouble());\n            Point c = new Point(scanner.nextDouble(), scanner.nextDouble());\n            triangles.add(new Triangle(a, b, c));\n        }\n\n        List<Point> centroids = new ArrayList<>();\n        for (Triangle t : triangles) {\n            centroids.add(t.getCentroid());\n        }\n\n        int touches = 0;\n        boolean[] illuminated = new boolean[n];\n\n        for (int i = 0; i < n; i++) {\n            if (!illuminated[i]) {\n                touches++;\n                for (int j = 0; j < n; j++) {\n                    if (canIlluminate(centroids.get(i), centroids.get(j), distance)) {\n                        illuminated[j] = true;\n                    }\n                }\n            }\n        }\n\n        System.out.println(touches);\n    }\n}",
    "timestamp": "2025-08-05 18:39:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\nfrom collections import defaultdict\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef is_close(p1, p2, threshold=0.01):\n    return distance(p1, p2) <= threshold\n\ndef line_contains_point(p1, p2, point, threshold=0.01):\n    # Check if point is close to the line formed by p1, p2\n    if is_close(point, p1) or is_close(point, p2):\n        return True\n    x0, y0 = point\n    x1, y1 = p1\n    x2, y2 = p2\n    line_dist = abs((x2-x1)*(y1-y0) - (x1-x0)*(y2-y1)) / distance(p1, p2)\n    return line_dist <= threshold\n\ndef build_graph(triangles, light_distance):\n    graph = defaultdict(list)\n    n = len(triangles)\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                for vertex in triangles[i]:\n                    for target_vertex in triangles[j]:\n                        if line_contains_point(vertex, target_vertex, target_vertex, 0.01) or is_close(vertex, target_vertex):\n                            graph[i].append(j)\n                            break\n    return graph\n\ndef min_touches_to_illuminate(graph, n):\n    touched = set()\n    def dfs(triangle):\n        if triangle in touched:\n            return\n        touched.add(triangle)\n        for neighbor in graph[triangle]:\n            dfs(neighbor)\n    \n    touches = 0\n    for i in range(n):\n        if i not in touched:\n            touches += 1\n            dfs(i)\n    \n    return touches\n\ndef minimum_touches(n, light_distance, triangles):\n    graph = build_graph(triangles, light_distance)\n    return min_touches_to_illuminate(graph, n)\n\n# Example usage\nn = 3\nlight_distance = 5.0\ntriangles = [\n    [(0, 0), (1, 5), (-1, 5)],\n    [(10, 0), (11, 5), (9, 5)],\n    [(20, 0), (21, 5), (19, 5)]\n]\n\nprint(minimum_touches(n, light_distance, triangles))",
    "timestamp": "2025-08-13 00:13:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Narawanda {\n\n    static class Triangle {\n        double x1, y1, x2, y2, x3, y3;\n\n        Triangle(double x1, double y1, double x2, double y2, double x3, double y3) {\n            this.x1 = x1; this.y1 = y1;\n            this.x2 = x2; this.y2 = y2;\n            this.x3 = x3; this.y3 = y3;\n        }\n\n        boolean connectsTo(Triangle other, double distance) {\n            return distanceBetween(x1, y1, other) <= distance ||\n                    distanceBetween(x2, y2, other) <= distance ||\n                    distanceBetween(x3, y3, other) <= distance;\n        }\n\n        private double distanceBetween(double x, double y, Triangle other) {\n            return Math.min(squaredDistance(x, y, other.x1, other.y1),\n                            Math.min(squaredDistance(x, y, other.x2, other.y2),\n                                     squaredDistance(x, y, other.x3, other.y3)));\n        }\n    }\n\n    static double squaredDistance(double x1, double y1, double x2, double y2) {\n        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int n = Integer.parseInt(br.readLine().trim());\n        double distance = Double.parseDouble(br.readLine().trim());\n\n        Triangle[] triangles = new Triangle[n];\n        \n        for (int i = 0; i < n; i++) {\n            String[] coords = br.readLine().trim().split(\"\\\\s+\");\n            double x1 = Double.parseDouble(coords[0]);\n            double y1 = Double.parseDouble(coords[1]);\n            double x2 = Double.parseDouble(coords[2]);\n            double y2 = Double.parseDouble(coords[3]);\n            double x3 = Double.parseDouble(coords[4]);\n            double y3 = Double.parseDouble(coords[5]);\n\n            triangles[i] = new Triangle(x1, y1, x2, y2, x3, y3);\n        }\n\n        boolean[] touched = new boolean[n];\n        int touches = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (!touched[i]) {\n                touches++;\n                dfs(i, triangles, touched, distance);\n            }\n        }\n\n        System.out.println(touches);\n    }\n\n    public static void dfs(int idx, Triangle[] triangles, boolean[] touched, double distance) {\n        Stack<Integer> stack = new Stack<>();\n        stack.push(idx);\n        touched[idx] = true;\n\n        while (!stack.isEmpty()) {\n            int current = stack.pop();\n\n            for (int i = 0; i < triangles.length; i++) {\n                if (!touched[i] && triangles[current].connectsTo(triangles[i], distance)) {\n                    touched[i] = true;\n                    stack.push(i);\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 00:13:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define MAX_TRIANGLES 1000\n#define EPSILON 0.01\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point vertices[3];\n} Triangle;\n\nint n;\ndouble light_distance;\nTriangle triangles[MAX_TRIANGLES];\nint visited[MAX_TRIANGLES];\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nint are_points_same(Point a, Point b) {\n    return distance(a, b) <= EPSILON;\n}\n\nint can_reach(Triangle *a, Triangle *b) {\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            if (distance(a->vertices[i], b->vertices[j]) <= light_distance + EPSILON) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nvoid dfs(int index) {\n    visited[index] = 1;\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i] && can_reach(&triangles[index], &triangles[i])) {\n            dfs(i);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %lf\", &n, &light_distance);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            scanf(\"%lf %lf\", &triangles[i].vertices[j].x, &triangles[i].vertices[j].y);\n        }\n    }\n\n    int min_touches = 0;\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            dfs(i);\n            min_touches++;\n        }\n    }\n\n    printf(\"%d\\n\", min_touches);\n    return 0;\n}",
    "timestamp": "2025-08-13 00:13:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\nimport itertools\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef is_same_point(p1, p2):\n    return distance(p1, p2) <= 0.01\n\ndef is_point_on_line(p, line_start, line_end):\n    line_length = distance(line_start, line_end)\n    dist_to_start = distance(p, line_start)\n    dist_to_end = distance(p, line_end)\n    return abs(dist_to_start + dist_to_end - line_length) <= 0.01\n\ndef triangles_connected(t1, t2, light_distance):\n    for p1 in t1:\n        for p2 in t2:\n            if distance(p1, p2) <= light_distance:\n                return True\n    \n    for p1 in t1:\n        for p2 in t2:\n            for p3 in t2:\n                if is_point_on_line(p1, p2, p3) and distance(p1, p2) <= light_distance:\n                    return True\n    \n    return False\n\ndef min_touches(triangles, light_distance):\n    n = len(triangles)\n    graph = [[] for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if triangles_connected(triangles[i], triangles[j], light_distance):\n                graph[i].append(j)\n                graph[j].append(i)\n    \n    min_touches = float('inf')\n    \n    for subset_size in range(1, n+1):\n        for subset in itertools.combinations(range(n), subset_size):\n            touched = set(subset)\n            connected = set(subset)\n            \n            while len(connected) < n:\n                max_connections = 0\n                best_candidate = None\n                \n                for triangle in range(n):\n                    if triangle not in connected:\n                        connections = sum(1 for t in touched if triangles_connected(triangles[triangle], triangles[t], light_distance))\n                        if connections > max_connections:\n                            max_connections = connections\n                            best_candidate = triangle\n                \n                if best_candidate is None:\n                    break\n                \n                touched.add(best_candidate)\n                \n                to_connect = [t for t in range(n) if t not in connected and triangles_connected(triangles[best_candidate], triangles[t], light_distance)]\n                connected.update(to_connect)\n            \n            if len(connected) == n:\n                min_touches = min(min_touches, len(touched))\n    \n    return min_touches\n\ndef main():\n    n, light_distance = map(float, input().split())\n    n = int(n)\n    triangles = []\n    \n    for _ in range(n):\n        triangle = []\n        for _ in range(3):\n            x, y = map(float, input().split())\n            triangle.append((x, y))\n        triangles.append(triangle)\n    \n    result = min_touches(triangles, light_distance)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 00:13:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef get_centroid(triangle):\n    x = (triangle[0][0] + triangle[1][0] + triangle[2][0]) / 3\n    y = (triangle[0][1] + triangle[1][1] + triangle[2][1]) / 3\n    return (x, y)\n\ndef solve():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    d = float(input[ptr])\n    ptr += 1\n    \n    triangles = []\n    for _ in range(n):\n        points = []\n        for _ in range(3):\n            x = float(input[ptr])\n            y = float(input[ptr+1])\n            points.append((x, y))\n            ptr += 2\n        triangles.append(points)\n    \n    centroids = [get_centroid(t) for t in triangles]\n    \n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if distance(centroids[i], centroids[j]) <= d + 1e-8:\n                adj[i].append(j)\n    \n    # Greedy set cover approximation\n    uncovered = set(range(n))\n    selected = []\n    while uncovered:\n        best = None\n        best_cover = set()\n        for i in range(n):\n            if i not in uncovered:\n                continue\n            cover = {i}\n            stack = [i]\n            visited = set([i])\n            while stack:\n                u = stack.pop()\n                for v in adj[u]:\n                    if v not in visited:\n                        visited.add(v)\n                        cover.add(v)\n                        stack.append(v)\n            if len(cover) > len(best_cover):\n                best_cover = cover\n                best = i\n        if best is None:\n            break\n        selected.append(best)\n        uncovered -= best_cover\n    \n    print(len(selected))\n\nsolve()",
    "timestamp": "2025-08-13 00:14:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(const Point &a, const Point &b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nbool arePointsEqual(const Point &a, const Point &b) {\n    return distance(a, b) <= 0.01;\n}\n\nbool isPointOnLine(const Point &p, const Point &a, const Point &b) {\n    double d_line = distance(a, b);\n    double d1 = distance(a, p);\n    double d2 = distance(b, p);\n    return fabs(d1 + d2 - d_line) <= 0.01;\n}\n\nbool canIlluminate(const Point &a, const Point &b, double light_dist) {\n    return distance(a, b) <= light_dist;\n}\n\nint minTouches(vector<vector<Point>> &triangles, double light_dist) {\n    int n = triangles.size();\n    vector<bool> visited(n, false);\n    int touches = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            touches++;\n            set<int> toVisit;\n            toVisit.insert(i);\n\n            while (!toVisit.empty()) {\n                int current = *toVisit.begin();\n                toVisit.erase(toVisit.begin());\n                visited[current] = true;\n\n                for (int j = 0; j < n; ++j) {\n                    if (!visited[j]) {\n                        bool connected = false;\n                        for (const auto &p1 : triangles[current]) {\n                            for (const auto &p2 : triangles[j]) {\n                                if (canIlluminate(p1, p2, light_dist)) {\n                                    connected = true;\n                                    break;\n                                }\n                            }\n                            if (connected) break;\n                        }\n                        if (connected) toVisit.insert(j);\n                    }\n                }\n            }\n        }\n    }\n\n    return touches;\n}\n\nint main() {\n    int n;\n    double light_dist;\n    cin >> n >> light_dist;\n\n    vector<vector<Point>> triangles(n, vector<Point>(3));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> triangles[i][j].x >> triangles[i][j].y;\n        }\n    }\n\n    cout << minTouches(triangles, light_dist) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:53:04"
  }
]