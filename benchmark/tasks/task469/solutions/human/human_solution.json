[
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n/*\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n*/\n\ntypedef double Real;\n\nconst Real eps=1e-9;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<=eps;\n}\n\ntemplate<class T> int sgn(T a){\n\tif(eq(a,0.0)) return 0;\n\tif(a>0) return 1;\n\treturn -1;\n}\n\nint N;\nint xs[110],ys[110],us[110],vs[110];\n\n//map<PP,int> cnt;\n\nvector<Real> vals;\nint num;\n\nvoid push(int a,int b,int c,int d,int e,int f,int g,int h){\n\tint A=c*h-d*g;\n\tint B=a*h+c*f-b*g-d*e;\n\tint C=a*f-b*e;\n\tif(A==0){\n\t\tif(B==0){\n\t\t\tif(C==0){\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tReal t=-(Real)C/B;\n\t\tif(sgn(t)>=0){\n\t\t\tvals.push_back(t);\n\t\t}\n\t\treturn;\n\t}\n\tif(B*B-4*A*C<0){\n\t\treturn;\n\t}\n\tif(B*B-4*A*C==0){\n\t\tReal t=-(Real)B/(A*2);\n\t\tif(sgn(t)>=0) vals.push_back(t);\n\t\treturn;\n\t}\n\tReal s=sqrt(B*B-4*A*C);\n\tReal t1=(-B+s)/(A*2);\n\tif(sgn(t1)>=0) vals.push_back(t1);\n\tReal t2=(-B-s)/(A*2);\n\tif(sgn(t2)>=0) vals.push_back(t2);\n}\n\nvoid init(){\n\tvals.clear();\n\tnum=0;\n}\n\nint solve(int id1,int id2){\n//\tprintf(\"%d %d\\n\",id1,id2);\n\tinit();\n\tint x1=xs[id1],y1=ys[id1],u1=us[id1],v1=vs[id1];\n\tint x2=xs[id2],y2=ys[id2],u2=us[id2],v2=vs[id2];\n\tfor(int i=0;i<N;i++){\n\t\tif(i==id1||i==id2) continue;\n\t\tint x=xs[i],y=ys[i],u=us[i],v=vs[i];\n\t\tpush(x1-x,y1-y,u1-u,v1-v,x2-x,y2-y,u2-u,v2-v);\n\t}\n\tint Ma=0;\n\tReal t;\n\tfor(int i=0;i<vals.size();i++){\n\t\tReal v=vals[i];\n\t\tint tmp=0;\n\t\tif(eq(xs[id1]+us[id1]*v,xs[id2]+us[id2]*v)&&eq(ys[id1]+vs[id1]*v,ys[id2]+vs[id2]*v)) continue;\n//\t\tprintf(\"%f\\n\",v);\n\t\tfor(int j=i;j<vals.size();j++){\n\t\t\tif(eq(v,vals[j])){\n\t\t\t\ttmp++;\n\t\t\t}\n\t\t}\n//\t\tif(tmp+num+2==N){\n//\t\t\tprintf(\"%d %d\\n\",id1,id2);\n//\t\t\tprintf(\"%f %d\\n\",v,num);\n//\t\tfor(int j=0;j<N;j++){\n//\t\t\tprintf(\"%f %f\\n\",xs[j]+us[j]*v,ys[j]+vs[j]*v);\n//\t\t}\n//\t\t}\n\t\tMa=max(Ma,tmp);\n\t}\n//\tprintf(\"num=%d\\n\",num);\n\treturn Ma+num+2;\n}\n\nbool all_same(){\n\tfor(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n\t\tif(xs[i]!=xs[j]||ys[i]!=ys[j]||us[i]!=us[j]||vs[i]!=vs[j]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nReal get(int x1,int u1,int x2,int u2){\n\tif(u1==u2){\n\t\tif(x1==x2) return -1;\n\t\telse return -2;\n\t}\n\treturn (Real)(x2-x1)/(u1-u2);\n}\n\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\",xs+i,ys+i,us+i,vs+i);\n\t}\n\tif(N<=2){\n\t\tprintf(\"%d\\n\",N);\n\t\treturn 0;\n\t}\n\tif(all_same()){\n\t\tprintf(\"%d\\n\",N);\n\t\treturn 0;\n\t}\n\tbool flg=false;\n\tfor(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n\t\tReal tx=get(xs[i],us[i],xs[j],us[j]);\n\t\tReal ty=get(ys[i],vs[i],ys[j],vs[j]);\n\t\tif(eq(tx,-2.0)||eq(ty,-2.0)) continue;\n\t\tif(eq(tx,-1.0)&&eq(ty,-1.0)) continue;\n\t\tReal t;\n\t\tif(eq(tx,-1.0)) t=ty;\n\t\telse t=tx;\n\t\tif(eq(tx,-1.0)==false&&eq(tx,t)==false) continue;\n\t\tif(eq(ty,-1.0)==false&&eq(ty,t)==false) continue;\n\t\tif(sgn(t)<0) continue;\n\t\tReal X=xs[0]+t*us[0];\n\t\tReal Y=ys[0]+t*vs[0];\n\t\tbool tmp=true;\n\t\tfor(int k=0;k<N;k++){\n\t\t\tReal cx=xs[k]+t*us[k];\n\t\t\tReal cy=ys[k]+t*vs[k];\n\t\t\tif(eq(X,cx)==false||eq(Y,cy)==false){\n\t\t\t\ttmp=false;\n\t\t\t}\n\t\t}\n\t\tif(tmp) flg=true;\n\t}\n\ted:;\n\tif(flg){\n\t\tprintf(\"%d\\n\",N);\n\t\treturn 0;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n\t\tif(xs[i]==xs[j]&&ys[i]==ys[j]&&us[i]==us[j]&&vs[i]==vs[j]){\n\t\t\tcontinue;\n\t\t}\n\t\tint cur=solve(i,j);\n\t\tans=max(ans,cur);\n\t}\n\tif(ans==0){\n\t\tprintf(\"%d\\n\",N);\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define equals(a,b) fabs((a)-(b)) < EPS\n\nclass Point {\npublic:\n\tlong double x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (long double a) {\n\t\treturn Point(a*x, a*y);\n\t}\n\tPoint operator / (long double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator > (const Point &p)const {\n\t\treturn x != p.x ? x > p.x : y > p.y;\n\t}\n\n\tbool operator ==(const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS  && fabs(y - p.y) < EPS;\n\t}\n};\n\nstruct Line {\n\tPoint p1, p2;\n};\n\nstruct Point2 {\n\tPoint v1, v2;\n};\n\nlong double ABS(Point a) {\n\treturn sqrt(a.x*a.x + a.y*a.y);\n}\n\nlong double cross(Point a,Point b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nlong double distance(Line L, Point P1) {\n\treturn cross(L.p2 - L.p1, P1 - L.p1) / ABS(L.p2 - L.p1);\n}\n\nPoint ichi(Point2 P1, double t) {\n\tPoint D;\n\tD.x = P1.v1.x + P1.v2.x * t;\n\tD.y = P1.v1.y + P1.v2.y * t;\n\treturn D;\n}\n\nlong double binary_search(Point2 P1, Point2 P2, Point2 P3) {\n\tlong double Left = -1.0e+9, Right = 1.0e+9, Mid = 0, H;\n\tLine G1, G2;\n\tPoint E1 = ichi(P1, 0);\n\tPoint E2 = ichi(P2, 0);\n\tPoint E3 = ichi(P3, 0);\n\tPoint F1 = ichi(P1, 1);\n\tPoint F2 = ichi(P2, 1);\n\tPoint F3 = ichi(P3, 1);\n\tG1.p1 = E1; G1.p2 = E2; G2.p1 = F1; G2.p2 = F2;\n\tlong double D1 = distance(G1, E3);\n\tlong double D2 = distance(G2, F3);\n\tif (D1 < D2) {\n\t\twhile (true) {\n\t\t\tMid = (Left + Right) / 2;\n\t\t\tE1 = ichi(P1, Mid);\n\t\t\tE2 = ichi(P2, Mid);\n\t\t\tE3 = ichi(P3, Mid);\n\t\t\tG1.p1 = E1; G1.p2 = E2;\n\t\t\tH = distance(G1, E3);\n\t\t\tif (fabs(H) < EPS) {\n\t\t\t\treturn Mid;\n\t\t\t}\n\t\t\tif (H > 0) {\n\t\t\t\tRight = Mid;\n\t\t\t}\n\t\t\tif (H < 0) {\n\t\t\t\tLeft = Mid;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\twhile (true) {\n\t\t\tMid = (Left + Right) / 2;\n\t\t\tE1 = ichi(P1, Mid);\n\t\t\tE2 = ichi(P2, Mid);\n\t\t\tE3 = ichi(P3, Mid);\n\t\t\tG1.p1 = E1; G1.p2 = E2;\n\t\t\tH = distance(G1, E3);\n\t\t\tif (abs(H) < EPS) {\n\t\t\t\treturn Mid;\n\t\t\t}\n\t\t\tif (H < 0) {\n\t\t\t\tRight = Mid;\n\t\t\t}\n\t\t\tif (H > 0) {\n\t\t\t\tLeft = Mid;\n\t\t\t}\n\t\t}\n\t}\n\treturn Mid;\n}\n\nPoint2 V[300];\nint n;\nint W[300];\nvector<long double>a;\nint sum;\nint maxn;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> V[i].v1.x >> V[i].v1.y >> V[i].v2.x >> V[i].v2.y;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\ta.push_back(binary_search(V[i], V[j], V[k]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(a.begin(), a.end());\n\tsum = 1;\n\tfor (int i = 1; i < a.size(); i++) {\n\t\tif (fabs(a[i] - a[i - 1]) < EPS) {\n\t\t\tsum++;\n\t\t}\n\t\telse {\n\t\t\tsum = 1;\n\t\t}\n\t\tmaxn = max(maxn, sum);\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tW[i] = i*(i + 1)*(i + 2) / 6;\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tif (W[i] >= maxn) {\n\t\t\tcout << i + 2 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\n\n#define INF (1 << 20)\nint main(){\n\tint x[200], y[200], u[200], v[200];\n\tint n;\n\tint result = 0;\n\tint flg = 0;\n\tcin >> n;\n\tif (n == 1 || n == 2) {\n\t\tcout << n << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> u[i] >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (i == j) continue;\n\t\t\tvector<double> tl;\n\t\t\tvector<double> xl;\n\t\t\tvector<double> yl;\n\t\t\tint cnt = 0;\n\t\t\tint xa = x[i] - x[j];\n\t\t\tint ya = y[i] - y[j];\n\t\t\tint ua = u[i] - u[j];\n\t\t\tint va = v[i] - v[j];\n\t\t\tif (xa == 0 && ya == 0 && ua == 0 && va == 0) continue;\n\t\t\tflg = 1;\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tint xb = x[i] - x[k];\n\t\t\t\tint yb = y[i] - y[k];\n\t\t\t\tint ub = u[i] - u[k];\n\t\t\t\tint vb = v[i] - v[k];\n\t\t\t\tdouble a = ua * vb - ub * va;\n\t\t\t\tdouble b = xa * vb + ua * yb - xb * va - ub * ya;\n\t\t\t\tdouble c = xa * yb - xb * ya;\n\t\t\t\tif (a == 0 && b == 0) {\n\t\t\t\t\tif (c == 0) ++cnt;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (a == 0 && b != 0) {\n\t\t\t\t\tdouble t = -c/b;\n\t\t\t\t\ttl.push_back(t);\n\t\t\t\t\txl.push_back(xb + t * ub);\n\t\t\t\t\tyl.push_back(yb + t * vb);\n\t\t\t\t} else if (a != 0) {\n\t\t\t\t\tif (b * b - 4 * a * c < 0) continue;\n\t\t\t\t\tdouble temp = sqrt(b * b - 4 * a * c);\n\t\t\t\t\tif (b * b - 4 * a * c == 0) {\n\t\t\t\t\t\tdouble t = -b/2/a;\n\t\t\t\t\t\ttl.push_back(t);\n\t\t\t\t\t\txl.push_back(xb + t * ub);\n\t\t\t\t\t\tyl.push_back(yb + t * vb);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble t = (-b + temp) / 2 / a;\n\t\t\t\t\ttl.push_back(t);\n\t\t\t\t\txl.push_back(xb + t * ub);\n\t\t\t\t\tyl.push_back(yb + t * vb);\n\t\t\t\t\tt = (-b - temp) / 2 / a;\n\t\t\t\t\ttl.push_back(t);\n\t\t\t\t\txl.push_back(xb + t * ub);\n\t\t\t\t\tyl.push_back(yb + t * vb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ccnt = 0;\n\t\t\tint flgs[1000] = {};\n\t\t\tfor (int k = 0; k < tl.size(); ++k) {\n\t\t\t\tif (tl[k] < 0) continue;\n\t\t\t\tint cccnt = 0;\n\t\t\t\tif (xl[k] == 0 && yl[k] == 0) {\n\t\t\t\t\tif (flgs[k] == 0) flgs[k] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int l = 0; l < tl.size(); ++l) {\n\t\t\t\t\tif (tl[l] < 0) continue;\n\t\t\t\t\tif (fabs(tl[k] - tl[l]) <= 1e-10 && xl[k] * yl[l] == xl[l] * yl[k]) {\n\t\t\t\t\t\t++cccnt;\n\t\t\t\t\t\tflgs[k] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tccnt = max(ccnt, cccnt);\n\t\t\t}\n\t\t\tfor (int k = 0; k < tl.size(); ++k) {\n\t\t\t\tif (flgs[k] == 1) {\n\t\t\t\t\tint asdf = 0;\n\t\t\t\t\tfor (int l = 0; l < tl.size(); ++l) {\n\t\t\t\t\t\tif (fabs(tl[k] - tl[l]) <= 1e-10) ++asdf;\n\t\t\t\t\t}\n\t\t\t\t\tccnt = max(ccnt, asdf);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = max(result, ccnt + cnt);\n\t\t}\n\t}\n\tif (flg == 0) {\n\t\tcout << n << endl;\n\t} else {\n\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\n#define EPS 1e-7\n#define equals(a,b) fabs((a)-(b)) < EPS\n\nclass Point {\npublic:\n\tlong double x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (long double a) {\n\t\treturn Point(a*x, a*y);\n\t}\n\tPoint operator / (long double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator > (const Point &p)const {\n\t\treturn x != p.x ? x > p.x : y > p.y;\n\t}\n\n\tbool operator ==(const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS  && fabs(y - p.y) < EPS;\n\t}\n};\n\nstruct Line {\n\tPoint p1, p2;\n};\n\nstruct Point2 {\n\tPoint v1, v2;\n};\n\nlong double ABS(Point a) {\n\treturn sqrt(a.x*a.x + a.y*a.y);\n}\n\nlong double cross(Point a,Point b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nlong double distance(Line L, Point P1) {\n\treturn cross(L.p2 - L.p1, P1 - L.p1) / ABS(L.p2 - L.p1);\n}\n\nPoint ichi(Point2 P1, double t) {\n\tPoint D;\n\tD.x = P1.v1.x + P1.v2.x * t;\n\tD.y = P1.v1.y + P1.v2.y * t;\n\treturn D;\n}\n\nlong double binary_search(Point2 P1, Point2 P2, Point2 P3) {\n\tlong double Left = -1.0e+9, Right = 1.0e+9, Mid = 0, H;\n\tint cnt = 0;\n\tLine G1, G2;\n\tPoint E1 = ichi(P1, 0);\n\tPoint E2 = ichi(P2, 0);\n\tPoint E3 = ichi(P3, 0);\n\tPoint F1 = ichi(P1, 1);\n\tPoint F2 = ichi(P2, 1);\n\tPoint F3 = ichi(P3, 1);\n\tG1.p1 = E1; G1.p2 = E2; G2.p1 = F1; G2.p2 = F2;\n\tlong double D1 = distance(G1, E3);\n\tlong double D2 = distance(G2, F3);\n\tif (D1 < D2) {\n\t\twhile (true) {\n\t\t\tMid = (Left + Right) / 2;\n\t\t\tE1 = ichi(P1, Mid);\n\t\t\tE2 = ichi(P2, Mid);\n\t\t\tE3 = ichi(P3, Mid);\n\t\t\tG1.p1 = E1; G1.p2 = E2;\n\t\t\tH = distance(G1, E3);\n\t\t\tif (fabs(H) < EPS) {\n\t\t\t\treturn Mid;\n\t\t\t}\n\t\t\tif (H > 0) {\n\t\t\t\tRight = Mid;\n\t\t\t}\n\t\t\tif (H < 0) {\n\t\t\t\tLeft = Mid;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tif (cnt >= 100) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\twhile (true) {\n\t\t\tMid = (Left + Right) / 2;\n\t\t\tE1 = ichi(P1, Mid);\n\t\t\tE2 = ichi(P2, Mid);\n\t\t\tE3 = ichi(P3, Mid);\n\t\t\tG1.p1 = E1; G1.p2 = E2;\n\t\t\tH = distance(G1, E3);\n\t\t\tif (abs(H) < EPS) {\n\t\t\t\treturn Mid;\n\t\t\t}\n\t\t\tif (H < 0) {\n\t\t\t\tRight = Mid;\n\t\t\t}\n\t\t\tif (H > 0) {\n\t\t\t\tLeft = Mid;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tif (cnt >= 100) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn Mid;\n}\n\nPoint2 V[300];\nint n;\nint W[300];\nvector<long double>a;\nint sum;\nint maxn;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> V[i].v1.x >> V[i].v1.y >> V[i].v2.x >> V[i].v2.y;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\ta.push_back(binary_search(V[i], V[j], V[k]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(a.begin(), a.end());\n\tif (a[0] >= 0) { sum = 1; maxn = 1; }\n\tfor (int i = 1; i < a.size(); i++) {\n\t\tif (a[i] >= 0) {\n\t\t\tif (fabs(a[i] - a[i - 1]) < EPS) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum = 1;\n\t\t\t}\n\t\t\tmaxn = max(maxn, sum);\n\t\t}\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tW[i] = i*(i + 1)*(i + 2) / 6;\n\t}\n\tfor (int i = 0; i <= 200; i++) {\n\t\tif (W[i] >= maxn) {\n\t\t\tcout << i + 2 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\n#include <tuple>\nusing namespace std;\n\n#define INF (1 << 20)\n#define EPS (1e-10)\n#define EQ(a,b) (fabs((a)-(b)) < EPS)\n\nint main(){\n\tint x[200], y[200], u[200], v[200];\n\tint n;\n\tint result = 0;\n\tint flg = 0;\n\tcin >> n;\n\tif (n == 1 || n == 2) {\n\t\tcout << n << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> u[i] >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tvector<tuple<double, double, double> > txyl;\n\t\t\tint cnt = 0;\n\t\t\tint xa = x[i] - x[j];\n\t\t\tint ya = y[i] - y[j];\n\t\t\tint ua = u[i] - u[j];\n\t\t\tint va = v[i] - v[j];\n\t\t\tif (xa == 0 && ya == 0 && ua == 0 && va == 0) continue;\n\t\t\tflg = 1;\n\t\t\tint count = 0;\n\t\t\tint tta = INF, ttb = INF;\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tint flga = 0;\n\t\t\t\tint xb = x[i] - x[k];\n\t\t\t\tint yb = y[i] - y[k];\n\t\t\t\tint ub = u[i] - u[k];\n\t\t\t\tint vb = v[i] - v[k];\n\t\t\t\tdouble a = ua * vb - ub * va;\n\t\t\t\tdouble b = xa * vb + ua * yb - xb * va - ub * ya;\n\t\t\t\tdouble c = xa * yb - xb * ya;\n\t\t\t\tif (a == 0 && b == 0) {\n\t\t\t\t\tif (c == 0)\t++cnt;\n\t\t\t\t} else if (a == 0) {\n\t\t\t\t\tdouble t = -c/b;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(t<0);\n\t\t\t\t\t\telse if (tta == INF && ttb == INF) tta = ttb = t,++count;\n\t\t\t\t\t\telse if (tta == t || ttb == t) ++count;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (b * b - 4 * a * c < 0) continue;\n\t\t\t\t\tdouble temp;\n\t\t\t\t\tif (4 * a * c == 0) {\n\t\t\t\t\t\ttemp = fabs(b);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttemp = sqrt(b * b - 4 * a * c);\n\t\t\t\t\t}\n\t\t\t\t\tif (EQ(temp/a,0)) {\n\t\t\t\t\t\tdouble t = -b / 2.0 / a;\n\t\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif(t<0);\n\t\t\t\t\t\t\telse if (tta == INF || ttb == INF) tta = ttb = t,++count;\n\t\t\t\t\t\t\telse if (tta == t || ttb == t) ++count;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble t = (-b + temp) / 2.0 / a;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (t < 0);\n\t\t\t\t\t\telse if (tta == INF) tta = t,++count;\n\t\t\t\t\t\telse if (tta == t || ttb == t) ++count;\n\t\t\t\t\t}\n\t\t\t\t\tt = (-b - temp) / 2.0 / a;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(t<0);\n\t\t\t\t\t\telse if (ttb == INF) ttb = t,++count;\n\t\t\t\t\t\telse if (tta == t || ttb == t) ++count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count + cnt == n) result = n;\n\t\t\tsort(txyl.begin(), txyl.end());\n\t\t\tint kk = 0;\n\t\t\twhile (kk < txyl.size() && get<0>(txyl[kk]) < 0) ++kk;\n\t\t\tint ccnt = 0;\n\t\t\twhile (kk < txyl.size()) {\n\t\t\t\tdouble time = get<0>(txyl[kk]);\n\t\t\t\tint no_line = 0;\n\t\t\t\tfor (int k = kk; k < txyl.size() && EQ(time,get<0>(txyl[k]));++k) {\n\t\t\t\t\tif (EQ(get<1>(txyl[k]),0) && EQ(get<2>(txyl[k]),0)) {\n\t\t\t\t\t\t++no_line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint max_group = 0;\n\t\t\t\tfor (int l = kk; l < txyl.size() && EQ(time,get<0>(txyl[l])); ++l) {\n\t\t\t\t\tint num_group = 0;\n\t\t\t\t\tif (EQ(get<1>(txyl[l]),0) && EQ(get<2>(txyl[l]),0)) continue;\n\t\t\t\t\tfor (int k = kk; k < txyl.size() && EQ(time,get<0>(txyl[k])); ++k) {\n\t\t\t\t\t\tif (EQ(get<1>(txyl[k]),0) && EQ(get<2>(txyl[k]),0)) continue;\n\t\t\t\t\t\tif (EQ(get<1>(txyl[l]) * get<2>(txyl[k]), get<1>(txyl[k]) * get<2>(txyl[l]))) {\n\t\t\t\t\t\t\t++num_group;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmax_group = max(max_group, num_group);\n\t\t\t\t}\n\t\t\t\tccnt = max(ccnt, no_line + max_group);\n\t\t\t\twhile (EQ(get<0>(txyl[kk]), time)) {\n\t\t\t\t\t++kk;\n\t\t\t\t\tif (kk == txyl.size()) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"i:\" << i << \" j:\" << j << \" cnt:\" << cnt << \" ccnt:\" << ccnt << \" txyl:\" << txyl.size() << endl;\n\t\t\tresult = max(result, ccnt + cnt);\n\t\t}\n\t}\n\tif (flg == 0) {\n\t\tcout << n << endl;\n\t} else {\n\t\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\n\n#define INF (1 << 20)\nint main(){\n\tint x[200], y[200], u[200], v[200];\n\tint n;\n\tint result = 0;\n\tcin >> n;\n\tif (n == 1 || n == 2) {\n\t\tcout << n << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> u[i] >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tvector<double> tl;\n\t\t\tvector<int> xl;\n\t\t\tvector<int> yl;\n\t\t\tint cnt = 0;\n\t\t\tint xa = x[i] - x[j];\n\t\t\tint ya = y[i] - y[j];\n\t\t\tint ua = u[i] - u[j];\n\t\t\tint va = v[i] - v[j];\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tint xb = x[i] - x[k];\n\t\t\t\tint yb = y[i] - y[k];\n\t\t\t\tint ub = u[i] - u[k];\n\t\t\t\tint vb = v[i] - v[k];\n\t\t\t\tdouble a = ua * vb - ub * va;\n\t\t\t\tdouble b = xa * vb + ua * yb - xb * va - ub * ya;\n\t\t\t\tdouble c = xa * yb - xb * ya;\n\t\t\t\tif (a == 0 && b == 0) {\n\t\t\t\t\tif (c == 0) ++cnt;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (a == 0 && b != 0) {\n\t\t\t\t\tdouble t = -c/b;\n\t\t\t\t\ttl.push_back(t);\n\t\t\t\t\txl.push_back(xb + t * ub);\n\t\t\t\t\tyl.push_back(yb + t * vb);\n\t\t\t\t} else if (a != 0) {\n\t\t\t\t\tif (b * b - 4 * a * c < 0) continue;\n\t\t\t\t\tdouble temp = sqrt(b * b - 4 * a * c);\n\t\t\t\t\tif (b * b - 4 * a * c == 0) {\n\t\t\t\t\t\tdouble t = -b/2/a;\n\t\t\t\t\t\ttl.push_back(t);\n\t\t\t\t\t\txl.push_back(xb + t * ub);\n\t\t\t\t\t\tyl.push_back(yb + t * vb);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble t = (-b + temp) / 2 / a;\n\t\t\t\t\ttl.push_back(t);\n\t\t\t\t\txl.push_back(xb + t * ub);\n\t\t\t\t\tyl.push_back(yb + t * vb);\n\t\t\t\t\tt = (-b - temp) / 2 / a;\n\t\t\t\t\ttl.push_back(t);\n\t\t\t\t\txl.push_back(xb + t * ub);\n\t\t\t\t\tyl.push_back(yb + t * vb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ccnt = 0;\n\t\t\tfor (int k = 0; k < tl.size(); ++k) {\n\t\t\t\tif (tl[k] < 0) continue;\n\t\t\t\tint cccnt = 0;\n\t\t\t\tfor (int l = k; l < tl.size(); ++l) {\n\t\t\t\t\tif (tl[l] < 0) continue;\n\t\t\t\t\tif (fabs(tl[k] - tl[l]) <= 1e-10 && xl[k] * yl[l] == xl[l] * yl[k]) {\n\t\t\t\t\t\t++cccnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tccnt = max(ccnt, cccnt);\n\t\t\t}\n\t\t\tresult = max(result, ccnt + cnt);\n\t\t}\n\t}\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\n\n#define INF (1 << 20)\nint main(){\n\tint x[200], y[200], u[200], v[200];\n\tint n;\n\tint result = 0;\n\tcin >> n;\n\tif (n == 1 || n == 2) {\n\t\tcout << n << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> u[i] >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tvector<double> tl;\n\t\t\tvector<double> xl;\n\t\t\tvector<double> yl;\n\t\t\tint cnt = 0;\n\t\t\tint xa = x[i] - x[j];\n\t\t\tint ya = y[i] - y[j];\n\t\t\tint ua = u[i] - u[j];\n\t\t\tint va = v[i] - v[j];\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tint xb = x[i] - x[k];\n\t\t\t\tint yb = y[i] - y[k];\n\t\t\t\tint ub = u[i] - u[k];\n\t\t\t\tint vb = v[i] - v[k];\n\t\t\t\tdouble a = ua * vb - ub * va;\n\t\t\t\tdouble b = xa * vb + ua * yb - xb * va - ub * ya;\n\t\t\t\tdouble c = xa * yb - xb * ya;\n\t\t\t\tif (a == 0 && b == 0) {\n\t\t\t\t\tif (c == 0) ++cnt;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (a == 0 && b != 0) {\n\t\t\t\t\tdouble t = -c/b;\n\t\t\t\t\ttl.push_back(t);\n\t\t\t\t\txl.push_back(xb + t * ub);\n\t\t\t\t\tyl.push_back(yb + t * vb);\n\t\t\t\t} else if (a != 0) {\n\t\t\t\t\tif (b * b - 4 * a * c < 0) continue;\n\t\t\t\t\tdouble temp = sqrt(b * b - 4 * a * c);\n\t\t\t\t\tif (b * b - 4 * a * c == 0) {\n\t\t\t\t\t\tdouble t = -b/2/a;\n\t\t\t\t\t\ttl.push_back(t);\n\t\t\t\t\t\txl.push_back(xb + t * ub);\n\t\t\t\t\t\tyl.push_back(yb + t * vb);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble t = (-b + temp) / 2 / a;\n\t\t\t\t\ttl.push_back(t);\n\t\t\t\t\txl.push_back(xb + t * ub);\n\t\t\t\t\tyl.push_back(yb + t * vb);\n\t\t\t\t\tt = (-b - temp) / 2 / a;\n\t\t\t\t\ttl.push_back(t);\n\t\t\t\t\txl.push_back(xb + t * ub);\n\t\t\t\t\tyl.push_back(yb + t * vb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ccnt = 0;\n\t\t\tfor (int k = 0; k < tl.size(); ++k) {\n\t\t\t\tif (tl[k] < 0) continue;\n\t\t\t\tint cccnt = 0;\n\t\t\t\tfor (int l = k; l < tl.size(); ++l) {\n\t\t\t\t\tif (tl[l] < 0) continue;\n\t\t\t\t\tif (fabs(tl[k] - tl[l]) <= 1e-10 && xl[k] * yl[l] == xl[l] * yl[k]) {\n\t\t\t\t\t\t++cccnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tccnt = max(ccnt, cccnt);\n\t\t\t}\n\t\t\tresult = max(result, ccnt + cnt);\n\t\t}\n\t}\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n/*\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n*/\n\ntypedef double Real;\n\nconst Real eps=1e-9;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<=eps;\n}\n\ntemplate<class T> int sgn(T a){\n\tif(eq(a,0.0)) return 0;\n\tif(a>0) return 1;\n\treturn -1;\n}\n\nint N;\nint xs[110],ys[110],us[110],vs[110];\n\n//map<PP,int> cnt;\n\nvector<Real> vals;\nint num;\n\nvoid push(int a,int b,int c,int d,int e,int f,int g,int h){\n\tint A=c*h-d*g;\n\tint B=a*h+c*f-b*g-d*e;\n\tint C=a*f-b*e;\n\tif(A==0){\n\t\tif(B==0){\n\t\t\tif(C==0){\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tReal t=-(Real)C/B;\n\t\tif(sgn(t)>=0){\n\t\t\tvals.push_back(t);\n\t\t}\n\t\treturn;\n\t}\n\tif(B*B-4*A*C<0){\n\t\treturn;\n\t}\n\tif(B*B-4*A*C==0){\n\t\tReal t=-(Real)B/(A*2);\n\t\tif(sgn(t)>=0) vals.push_back(t);\n\t\treturn;\n\t}\n\tReal s=sqrt(B*B-4*A*C);\n\tReal t1=(-B+s)/(A*2);\n\tif(sgn(t1)>=0) vals.push_back(t1);\n\tReal t2=(-B-s)/(A*2);\n\tif(sgn(t2)>=0) vals.push_back(t2);\n}\n\nvoid init(){\n\tvals.clear();\n\tnum=0;\n}\n\nint solve(int id1,int id2){\n//\tprintf(\"%d %d\\n\",id1,id2);\n\tinit();\n\tint x1=xs[id1],y1=ys[id1],u1=us[id1],v1=vs[id1];\n\tint x2=xs[id2],y2=ys[id2],u2=us[id2],v2=vs[id2];\n\tfor(int i=0;i<N;i++){\n\t\tif(i==id1||i==id2) continue;\n\t\tint x=xs[i],y=ys[i],u=us[i],v=vs[i];\n\t\tpush(x1-x,y1-y,u1-u,v1-v,x2-x,y2-y,u2-u,v2-v);\n\t}\n\tint Ma=0;\n\tReal t;\n\tfor(int i=0;i<vals.size();i++){\n\t\tReal v=vals[i];\n\t\tint tmp=0;\n\t\tif(eq(xs[id1]+us[id1]*v,xs[id2]+us[id2]*v)&&eq(ys[id1]+vs[id1]*v,ys[id2]+vs[id2]*v)) continue;\n//\t\tprintf(\"%f\\n\",v);\n\t\tfor(int j=i;j<vals.size();j++){\n\t\t\tif(eq(v,vals[j])){\n\t\t\t\ttmp++;\n\t\t\t}\n\t\t}\n//\t\tif(tmp+num+2==N){\n//\t\t\tprintf(\"%d %d\\n\",id1,id2);\n//\t\t\tprintf(\"%f %d\\n\",v,num);\n//\t\tfor(int j=0;j<N;j++){\n//\t\t\tprintf(\"%f %f\\n\",xs[j]+us[j]*v,ys[j]+vs[j]*v);\n//\t\t}\n//\t\t}\n\t\tMa=max(Ma,tmp);\n\t}\n//\tprintf(\"num=%d\\n\",num);\n\treturn Ma+num+2;\n}\n\nbool all_same(){\n\tfor(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n\t\tif(xs[i]!=xs[j]||ys[i]!=ys[j]||us[i]!=us[j]||vs[i]!=vs[j]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nReal get(int x1,int u1,int x2,int u2){\n\tif(u1==u2){\n\t\tif(x1==x2) return -1;\n\t\telse return -2;\n\t}\n\treturn (Real)(x2-x1)/(u1-u2);\n}\n\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\",xs+i,ys+i,us+i,vs+i);\n\t}\n\tif(N<=2){\n\t\tprintf(\"%d\\n\",N);\n\t\treturn 0;\n\t}\n\tif(all_same()){\n\t\tprintf(\"a%d\\n\",N);\n\t\treturn 0;\n\t}\n\tbool flg=false;\n\tfor(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n\t\tReal tx=get(xs[i],us[i],xs[j],us[j]);\n\t\tReal ty=get(ys[i],vs[i],ys[j],vs[j]);\n\t\tif(eq(tx,-2.0)||eq(ty,-2.0)) continue;\n\t\tif(eq(tx,-1.0)&&eq(ty,-1.0)) continue;\n\t\tReal t;\n\t\tif(eq(tx,-1.0)) t=ty;\n\t\telse t=tx;\n\t\tif(eq(tx,-1.0)==false&&eq(tx,t)==false) continue;\n\t\tif(eq(ty,-1.0)==false&&eq(ty,t)==false) continue;\n\t\tif(sgn(t)<0) continue;\n\t\tReal X=xs[0]+t*us[0];\n\t\tReal Y=ys[0]+t*vs[0];\n\t\tbool tmp=true;\n\t\tfor(int k=0;k<N;k++){\n\t\t\tReal cx=xs[k]+t*us[k];\n\t\t\tReal cy=ys[k]+t*vs[k];\n\t\t\tif(eq(X,cx)==false||eq(Y,cy)==false){\n\t\t\t\ttmp=false;\n\t\t\t}\n\t\t}\n\t\tif(tmp) flg=true;\n\t}\n\ted:;\n\tif(flg){\n\t\tprintf(\"%d\\n\",N);\n\t\treturn 0;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n\t\tif(xs[i]==xs[j]&&ys[i]==ys[j]&&us[i]==us[j]&&vs[i]==vs[j]){\n\t\t\tcontinue;\n\t\t}\n\t\tint cur=solve(i,j);\n\t\tans=max(ans,cur);\n\t}\n\tif(ans==0){\n\t\tprintf(\"%d\\n\",N);\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\n#include <tuple>\nusing namespace std;\n\n#define INF (1 << 20)\n#define EPS (1e-10)\n#define EQ(a,b) (fabs((a)-(b)) < EPS)\n\nint main(){\n\tint x[200], y[200], u[200], v[200];\n\tint n;\n\tint result = 0;\n\tint flg = 0;\n\tcin >> n;\n\tif (n == 1 || n == 2) {\n\t\tcout << n << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> u[i] >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tvector<tuple<double, double, double> > txyl;\n\t\t\tint cnt = 0;\n\t\t\tint xa = x[i] - x[j];\n\t\t\tint ya = y[i] - y[j];\n\t\t\tint ua = u[i] - u[j];\n\t\t\tint va = v[i] - v[j];\n\t\t\tif (xa == 0 && ya == 0 && ua == 0 && va == 0) continue;\n\t\t\tflg = 1;\n\t\t\tint count = 0;\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tint flga = 0;\n\t\t\t\tint xb = x[i] - x[k];\n\t\t\t\tint yb = y[i] - y[k];\n\t\t\t\tint ub = u[i] - u[k];\n\t\t\t\tint vb = v[i] - v[k];\n\t\t\t\tdouble a = ua * vb - ub * va;\n\t\t\t\tdouble b = xa * vb + ua * yb - xb * va - ub * ya;\n\t\t\t\tdouble c = xa * yb - xb * ya;\n\t\t\t\tif (a == 0 && b == 0) {\n\t\t\t\t\tif (c == 0)\t++cnt;\n\t\t\t\t} else if (a == 0) {\n\t\t\t\t\tdouble t = -c/b;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\telse ++count;\n\t\t\t\t} else {\n\t\t\t\t\tif (b * b - 4 * a * c < 0) continue;\n\t\t\t\t\tdouble temp;\n\t\t\t\t\tif (4 * a * c == 0) {\n\t\t\t\t\t\ttemp = fabs(b);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttemp = sqrt(b * b - 4 * a * c);\n\t\t\t\t\t}\n\t\t\t\t\tif (EQ(temp/a,0)) {\n\t\t\t\t\t\tdouble t = -b / 2.0 / a;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\telse ++count;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble t = (-b + temp) / 2.0 / a;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\telse {++count,++flga;}\n\t\t\t\t\tt = (-b - temp) / 2.0 / a;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\telse {if (!flga)++count;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count + cnt == n) result = n;\n\t\t\tsort(txyl.begin(), txyl.end());\n\t\t\tint kk = 0;\n\t\t\twhile (kk < txyl.size() && get<0>(txyl[kk]) < 0) ++kk;\n\t\t\tint ccnt = 0;\n\t\t\twhile (kk < txyl.size()) {\n\t\t\t\tdouble time = get<0>(txyl[kk]);\n\t\t\t\tint no_line = 0;\n\t\t\t\tfor (int k = kk; k < txyl.size() && EQ(time,get<0>(txyl[k]));++k) {\n\t\t\t\t\tif (EQ(get<1>(txyl[k]),0) && EQ(get<2>(txyl[k]),0)) {\n\t\t\t\t\t\t++no_line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint max_group = 0;\n\t\t\t\tfor (int l = kk; l < txyl.size() && EQ(time,get<0>(txyl[l])); ++l) {\n\t\t\t\t\tint num_group = 0;\n\t\t\t\t\tif (EQ(get<1>(txyl[l]),0) && EQ(get<2>(txyl[l]),0)) continue;\n\t\t\t\t\tfor (int k = kk; k < txyl.size() && EQ(time,get<0>(txyl[k])); ++k) {\n\t\t\t\t\t\tif (EQ(get<1>(txyl[k]),0) && EQ(get<2>(txyl[k]),0)) continue;\n\t\t\t\t\t\tif (EQ(get<1>(txyl[l]) * get<2>(txyl[k]), get<1>(txyl[k]) * get<2>(txyl[l]))) {\n\t\t\t\t\t\t\t++num_group;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmax_group = max(max_group, num_group);\n\t\t\t\t}\n\t\t\t\tccnt = max(ccnt, no_line + max_group);\n\t\t\t\twhile (EQ(get<0>(txyl[kk]), time)) {\n\t\t\t\t\t++kk;\n\t\t\t\t\tif (kk == txyl.size()) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"i:\" << i << \" j:\" << j << \" cnt:\" << cnt << \" ccnt:\" << ccnt << \" txyl:\" << txyl.size() << endl;\n\t\t\tresult = max(result, ccnt + cnt);\n\t\t}\n\t}\n\tif (flg == 0) {\n\t\tcout << n << endl;\n\t} else {\n\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\n\n#define INF (1 << 20)\nint main(){\n\tint x[200], y[200], u[200], v[200];\n\tint n;\n\tint result = 0;\n\tcin >> n;\n\tif (n == 1 || n == 2) {\n\t\tcout << n << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> u[i] >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tvector<double> tl;\n\t\t\tvector<int> xl;\n\t\t\tvector<int> yl;\n\t\t\tint cnt = 0;\n\t\t\tint xa = x[i] - x[j];\n\t\t\tint ya = y[i] - y[j];\n\t\t\tint ua = u[i] - u[j];\n\t\t\tint va = v[i] - v[j];\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tint xb = x[i] - x[k];\n\t\t\t\tint yb = y[i] - y[k];\n\t\t\t\tint ub = u[i] - u[k];\n\t\t\t\tint vb = v[i] - v[k];\n\t\t\t\tdouble a = ua * vb - ub * va;\n\t\t\t\tdouble b = xa * vb + ua * yb - xb * va - ub * ya;\n\t\t\t\tdouble c = xa * yb - xb * ya;\n\t\t\t\tif (a == 0 && b == 0) {\n\t\t\t\t\tif (c == 0) ++cnt;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (a == 0 && b != 0) {\n\t\t\t\t\tdouble t = -c/b;\n\t\t\t\t\ttl.push_back(t);\n\t\t\t\t\txl.push_back(xb + t * ub);\n\t\t\t\t\tyl.push_back(yb + t * vb);\n\t\t\t\t} else if (a != 0) {\n\t\t\t\t\tif (b * b - 4 * a * c < 0) continue;\n\t\t\t\t\tdouble temp = sqrt(b * b - 4 * a * c);\n\t\t\t\t\tif (b * b - 4 * a * c == 0) {\n\t\t\t\t\t\tdouble t = -b/2/a;\n\t\t\t\t\t\ttl.push_back(t);\n\t\t\t\t\t\txl.push_back(xb + t * ub);\n\t\t\t\t\t\tyl.push_back(yb + t * vb);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble t = (-b + temp) / 2 / a;\n\t\t\t\t\ttl.push_back(t);\n\t\t\t\t\txl.push_back(xb + t * ub);\n\t\t\t\t\tyl.push_back(yb + t * vb);\n\t\t\t\t\tt = (-b - temp) / 2 / a;\n\t\t\t\t\ttl.push_back(t);\n\t\t\t\t\txl.push_back(xb + t * ub);\n\t\t\t\t\tyl.push_back(yb + t * vb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ccnt = 0;\n\t\t\tfor (int k = 0; k < tl.size(); ++k) {\n\t\t\t\tif (tl[k] < 0) continue;\n\t\t\t\tint cccnt = 0;\n\t\t\t\tfor (int l = k; l < tl.size(); ++l) {\n\t\t\t\t\tif (tl[l] < 0) continue;\n\t\t\t\t\tif (fabs(tl[k] - tl[l]) <= 1e-10 && xl[k] * yl[l] == xl[l] * yl[k]) {\n\t\t\t\t\t\t++cccnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tccnt = max(ccnt, cccnt);\n\t\t\t\tif (ccnt == 4) cout << tl[k] << endl;\n\t\t\t}\n\t\t\tresult = max(result, ccnt + cnt);\n\t\t}\n\t}\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n/*\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n*/\n\ntypedef double Real;\n\nconst Real eps=1e-9;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<=eps;\n}\n\ntemplate<class T> int sgn(T a){\n\tif(eq(a,0.0)) return 0;\n\tif(a>0) return 1;\n\treturn -1;\n}\n\nint N;\nint xs[220],ys[220],us[220],vs[220];\n\n//map<PP,int> cnt;\n\nvector<Real> vals;\nint num;\n\nvoid push(int a,int b,int c,int d,int e,int f,int g,int h){\n\tint A=c*h-d*g;\n\tint B=a*h+c*f-b*g-d*e;\n\tint C=a*f-b*e;\n\tif(A==0){\n\t\tif(B==0){\n\t\t\tif(C==0){\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tReal t=-(Real)C/B;\n\t\tif(sgn(t)>=0){\n\t\t\tvals.push_back(t);\n\t\t}\n\t\treturn;\n\t}\n\tif(B*B-4*A*C<0){\n\t\treturn;\n\t}\n\tif(B*B-4*A*C==0){\n\t\tReal t=-(Real)B/(A*2);\n\t\tif(sgn(t)>=0) vals.push_back(t);\n\t\treturn;\n\t}\n\tReal s=sqrt(B*B-4*A*C);\n\tReal t1=(-B+s)/(A*2);\n\tif(sgn(t1)>=0) vals.push_back(t1);\n\tReal t2=(-B-s)/(A*2);\n\tif(sgn(t2)>=0) vals.push_back(t2);\n}\n\nvoid init(){\n\tvals.clear();\n\tnum=0;\n}\n\nint solve(int id1,int id2){\n//\tprintf(\"%d %d\\n\",id1,id2);\n\tinit();\n\tint x1=xs[id1],y1=ys[id1],u1=us[id1],v1=vs[id1];\n\tint x2=xs[id2],y2=ys[id2],u2=us[id2],v2=vs[id2];\n\tfor(int i=0;i<N;i++){\n\t\tif(i==id1||i==id2) continue;\n\t\tint x=xs[i],y=ys[i],u=us[i],v=vs[i];\n//\t\tprintf(\"%d %d %d %d %d %d %d %d\\n\",x1-x,y1-y,u\n\t\tpush(x1-x,y1-y,u1-u,v1-v,x2-x,y2-y,u2-u,v2-v);\n//\t\tprintf(\"pushed %d\\n\",i);\n\t}\n//\tprintf(\"c\\n\");\n\tint Ma=0;\n\tReal t;\n\tfor(int i=0;i<vals.size();i++){\n\t\tReal v=vals[i];\n\t\tint tmp=0;\n\t\tif(eq(xs[id1]+us[id1]*v,xs[id2]+us[id2]*v)&&eq(ys[id1]+vs[id1]*v,ys[id2]+vs[id2]*v)) continue;\n//\t\tprintf(\"%f\\n\",v);\n\t\tfor(int j=i;j<vals.size();j++){\n\t\t\tif(eq(v,vals[j])){\n\t\t\t\ttmp++;\n\t\t\t}\n\t\t}\n//\t\tif(tmp+num+2==N){\n//\t\t\tprintf(\"%d %d\\n\",id1,id2);\n//\t\t\tprintf(\"%f %d\\n\",v,num);\n//\t\tfor(int j=0;j<N;j++){\n//\t\t\tprintf(\"%f %f\\n\",xs[j]+us[j]*v,ys[j]+vs[j]*v);\n//\t\t}\n//\t\t}\n\t\tMa=max(Ma,tmp);\n\t}\n//\tprintf(\"num=%d\\n\",num);\n\treturn Ma+num+2;\n}\n\nbool all_same(){\n\tfor(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n\t\tif(xs[i]!=xs[j]||ys[i]!=ys[j]||us[i]!=us[j]||vs[i]!=vs[j]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nReal get(int x1,int u1,int x2,int u2){\n\tif(u1==u2){\n\t\tif(x1==x2) return -1;\n\t\telse return -2;\n\t}\n\treturn (Real)(x2-x1)/(u1-u2);\n}\n\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\",xs+i,ys+i,us+i,vs+i);\n\t}\n\tif(N<=2){\n\t\tprintf(\"%d\\n\",N);\n\t\treturn 0;\n\t}\n\tif(all_same()){\n\t\tprintf(\"%d\\n\",N);\n\t\treturn 0;\n\t}\n//\tprintf(\"a\\n\");\n\tbool flg=false;\n\tfor(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n\t\tReal tx=get(xs[i],us[i],xs[j],us[j]);\n\t\tReal ty=get(ys[i],vs[i],ys[j],vs[j]);\n\t\tif(eq(tx,-2.0)||eq(ty,-2.0)) continue;\n\t\tif(eq(tx,-1.0)&&eq(ty,-1.0)) continue;\n\t\tReal t;\n\t\tif(eq(tx,-1.0)) t=ty;\n\t\telse t=tx;\n\t\tif(eq(tx,-1.0)==false&&eq(tx,t)==false) continue;\n\t\tif(eq(ty,-1.0)==false&&eq(ty,t)==false) continue;\n\t\tif(sgn(t)<0) continue;\n\t\tReal X=xs[0]+t*us[0];\n\t\tReal Y=ys[0]+t*vs[0];\n\t\tbool tmp=true;\n\t\tfor(int k=0;k<N;k++){\n\t\t\tReal cx=xs[k]+t*us[k];\n\t\t\tReal cy=ys[k]+t*vs[k];\n\t\t\tif(eq(X,cx)==false||eq(Y,cy)==false){\n\t\t\t\ttmp=false;\n\t\t\t}\n\t\t}\n\t\tif(tmp) flg=true;\n\t}\n//\tprintf(\"b\\n\");\n\ted:;\n\tif(flg){\n\t\tprintf(\"%d\\n\",N);\n\t\treturn 0;\n\t}\n\tint ans=0;\n//\tprintf(\"c\\n\");\n\tfor(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n\t\tif(xs[i]==xs[j]&&ys[i]==ys[j]&&us[i]==us[j]&&vs[i]==vs[j]){\n\t\t\tcontinue;\n\t\t}\n//\t\tprintf(\"a %d %d\\n\",i,j);\n\t\tint cur=solve(i,j);\n\t\tans=max(ans,cur);\n\t}\n//\tprintf(\"d\\n\");\n\tif(ans==0){\n\t\tprintf(\"%d\\n\",N);\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\n#include <tuple>\nusing namespace std;\n\n#define INF (1 << 20)\n#define EPS (1e-10)\n#define EQ(a,b) (fabs((a)-(b)) < EPS)\n\nint main(){\n\tint x[200], y[200], u[200], v[200];\n\tint n;\n\tint result = 0;\n\tint flg = 0;\n\tdouble ta = -1.0;\n\tcin >> n;\n\tif (n == 1 || n == 2) {\n\t\tcout << n << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> u[i] >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tvector<tuple<double, double, double> > txyl;\n\t\t\tint cnt = 0;\n\t\t\tint xa = x[i] - x[j];\n\t\t\tint ya = y[i] - y[j];\n\t\t\tint ua = u[i] - u[j];\n\t\t\tint va = v[i] - v[j];\n\t\t\tif (xa == 0 && ya == 0 && ua == 0 && va == 0) continue;\n\t\t\tflg = 1;\n\t\t\tif (xa * va == ya * va) {\n\t\t\t\tdouble tt;\n\t\t\t\tif (xa != 0) tt = -1.0 * xa / ua;\n\t\t\t\telse tt = -1.0 * ya / va;\n\t\t\t\tif (tt >= 0) {\n\t\t\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\t\t\tif (!EQ(x[0] + tt * u[0],x[k] + tt * u[k]) ||\n\t\t\t\t\t\t\t\t!EQ(y[0] + tt * v[0],y[k] + tt * v[k])) break;\n\t\t\t\t\t\tif (k == n-1) {\n\t\t\t\t\t\t\tcout << n << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tint flga = 0;\n\t\t\t\tint xb = x[i] - x[k];\n\t\t\t\tint yb = y[i] - y[k];\n\t\t\t\tint ub = u[i] - u[k];\n\t\t\t\tint vb = v[i] - v[k];\n\t\t\t\tdouble a = ua * vb - ub * va;\n\t\t\t\tdouble b = xa * vb + ua * yb - xb * va - ub * ya;\n\t\t\t\tdouble c = xa * yb - xb * ya;\n\t\t\t\tif (a == 0 && b == 0) {\n\t\t\t\t\tif (c == 0)\t++cnt;\n\t\t\t\t} else if (a == 0) {\n\t\t\t\t\tdouble t = -c/b;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t} else {\n\t\t\t\t\tif (b * b - 4 * a * c < 0) continue;\n\t\t\t\t\tdouble temp;\n\t\t\t\t\tif (4 * a * c == 0) {\n\t\t\t\t\t\ttemp = fabs(b);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttemp = sqrt(b * b - 4 * a * c);\n\t\t\t\t\t}\n\t\t\t\t\tif (EQ(temp/a,0)) {\n\t\t\t\t\t\tdouble t = -b / 2.0 / a;\n\t\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble t = (-b + temp) / 2.0 / a;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\tt = (-b - temp) / 2.0 / a;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if (count + cnt == n) result = n;\n\t\t\tsort(txyl.begin(), txyl.end());\n\t\t\tint kk = 0;\n\t\t\twhile (kk < txyl.size() && get<0>(txyl[kk]) < 0) ++kk;\n\t\t\tint ccnt = 0;\n\t\t\twhile (kk < txyl.size()) {\n\t\t\t\tdouble time = get<0>(txyl[kk]);\n\t\t\t\tint no_line = 0;\n\t\t\t\tfor (int k = kk; k < txyl.size() && EQ(time,get<0>(txyl[k]));++k) {\n\t\t\t\t\tif (EQ(get<1>(txyl[k]),0) && EQ(get<2>(txyl[k]),0)) {\n\t\t\t\t\t\t++no_line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint max_group = 0;\n\t\t\t\tfor (int l = kk; l < txyl.size() && EQ(time,get<0>(txyl[l])); ++l) {\n\t\t\t\t\tint num_group = 0;\n\t\t\t\t\tif (EQ(get<1>(txyl[l]),0) && EQ(get<2>(txyl[l]),0)) continue;\n\t\t\t\t\tfor (int k = kk; k < txyl.size() && EQ(time,get<0>(txyl[k])); ++k) {\n\t\t\t\t\t\tif (EQ(get<1>(txyl[k]),0) && EQ(get<2>(txyl[k]),0)) continue;\n\t\t\t\t\t\tif (EQ(get<1>(txyl[l]) * get<2>(txyl[k]), get<1>(txyl[k]) * get<2>(txyl[l]))) {\n\t\t\t\t\t\t\t++num_group;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmax_group = max(max_group, num_group);\n\t\t\t\t}\n\t\t\t\tccnt = max(ccnt, no_line + max_group);\n\t\t\t\twhile (EQ(get<0>(txyl[kk]), time)) {\n\t\t\t\t\t++kk;\n\t\t\t\t\tif (kk == txyl.size()) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"i:\" << i << \" j:\" << j << \" cnt:\" << cnt << \" ccnt:\" << ccnt << \" txyl:\" << txyl.size() << endl;\n\t\t\tresult = max(result, ccnt + cnt);\n\t\t}\n\t}\n\tif (flg == 0) {\n\t\tcout << n << endl;\n\t} else {\n\t\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\n#include <tuple>\nusing namespace std;\n\n#define INF (1 << 20)\n#define EPS (1e-10)\n#define EQ(a,b) (fabs((a)-(b)) < EPS)\n\nint main(){\n\tint x[200], y[200], u[200], v[200];\n\tint n;\n\tint result = 0;\n\tint flg = 0;\n\tcin >> n;\n\tif (n == 1 || n == 2) {\n\t\tcout << n << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> u[i] >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tvector<tuple<double, double, double> > txyl;\n\t\t\tint cnt = 0;\n\t\t\tint xa = x[i] - x[j];\n\t\t\tint ya = y[i] - y[j];\n\t\t\tint ua = u[i] - u[j];\n\t\t\tint va = v[i] - v[j];\n\t\t\tif (xa == 0 && ya == 0 && ua == 0 && va == 0) continue;\n\t\t\tflg = 1;\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tint xb = x[i] - x[k];\n\t\t\t\tint yb = y[i] - y[k];\n\t\t\t\tint ub = u[i] - u[k];\n\t\t\t\tint vb = v[i] - v[k];\n\t\t\t\tdouble a = ua * vb - ub * va;\n\t\t\t\tdouble b = xa * vb + ua * yb - xb * va - ub * ya;\n\t\t\t\tdouble c = xa * yb - xb * ya;\n\t\t\t\tif (a == 0 && b == 0) {\n\t\t\t\t\tif (c == 0)\t++cnt;\n\t\t\t\t} else if (a == 0) {\n\t\t\t\t\tdouble t = -c/b;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t} else {\n\t\t\t\t\tif (b * b - 4 * a * c < 0) continue;\n\t\t\t\t\tdouble temp;\n\t\t\t\t\tif (4 * a * c == 0) {\n\t\t\t\t\t\ttemp = fabs(b);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttemp = sqrt(b * b - 4 * a * c);\n\t\t\t\t\t}\n\t\t\t\t\tif (EQ(temp/a,0)) {\n\t\t\t\t\t\tdouble t = -b / 2.0 / a;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble t = (-b + temp) / 2.0 / a;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\tt = (-b - temp) / 2.0 / a;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(txyl.begin(), txyl.end());\n\t\t\tint kk = 0;\n\t\t\twhile (kk < txyl.size() && get<0>(txyl[kk]) < 0) ++kk;\n\t\t\tint ccnt = 0;\n\t\t\twhile (kk < txyl.size()) {\n\t\t\t\tdouble time = get<0>(txyl[kk]);\n\t\t\t\tint no_line = 0;\n\t\t\t\tfor (int k = kk; k < txyl.size() && EQ(time,get<0>(txyl[k]));++k) {\n\t\t\t\t\tif (EQ(get<1>(txyl[k]),0) && EQ(get<2>(txyl[k]),0)) {\n\t\t\t\t\t\t++no_line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint max_group = 0;\n\t\t\t\tfor (int l = kk; l < txyl.size() && EQ(time,get<0>(txyl[l])); ++l) {\n\t\t\t\t\tint num_group = 0;\n\t\t\t\t\tif (EQ(get<1>(txyl[l]),0) && EQ(get<2>(txyl[l]),0)) continue;\n\t\t\t\t\tfor (int k = kk; k < txyl.size() && EQ(time,get<0>(txyl[k])); ++k) {\n\t\t\t\t\t\tif (EQ(get<1>(txyl[k]),0) && EQ(get<2>(txyl[k]),0)) continue;\n\t\t\t\t\t\tif (EQ(get<1>(txyl[l]) * get<2>(txyl[k]), get<1>(txyl[k]) * get<2>(txyl[l]))) {\n\t\t\t\t\t\t\t++num_group;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmax_group = max(max_group, num_group);\n\t\t\t\t}\n\t\t\t\tccnt = max(ccnt, no_line + max_group);\n\t\t\t\twhile (EQ(get<0>(txyl[kk]), time)) {\n\t\t\t\t\t++kk;\n\t\t\t\t\tif (kk == txyl.size()) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"i:\" << i << \" j:\" << j << \" cnt:\" << cnt << \" ccnt:\" << ccnt << \" txyl:\" << txyl.size() << endl;\n\t\t\tresult = max(result, ccnt + cnt);\n\t\t}\n\t}\n\tif (flg == 0) {\n\t\tcout << n << endl;\n\t} else {\n\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld=long double;\nconst ld eps=1e-9;\n\nstruct apple {\n\tpair<int ,int>coors;\n\tpair<int ,int>v;\n};\n\napple operator-(const apple&r, const apple&l) {\n\tapple ans;\n\tans.coors.first=r.coors.first-l.coors.first;\n\tans.coors.second=r.coors.second-l.coors.second;\n\tans.v.first=r.v.first-l.v.first;\n\tans.v.second=r.v.second-l.v.second;\n\treturn ans;\n}\nvector<ld>quad_equa(ld a, ld b, ld c) {\n\tif (abs(a) < eps) {\n\t\tif (abs(b) < eps) {\n\t\t\treturn vector<ld>();\n\t\t}\n\t\telse {\n\t\t\treturn vector<ld>{-c / b};\n\t\t}\n\t}\n\tld root = b*b - 4 * a*c;\n\tif (abs(root) < eps) {\n\t\tld ans = -b / (2 * a);\n\t\treturn vector<ld>(1, ans);\n\t}\n\telse if (root > 0) {\n\t\tld ans = -b / (2 * a);\n\t\tvector<ld>anss(2);\n\t\tanss[0] = ans + sqrt(root) / (2 * a);\n\t\tanss[1] = ans - sqrt(root) / (2 * a);\n\t\tif (anss[0] > anss[1])swap(anss[0], anss[1]);\n\t\treturn anss;\n\t}\n\telse {\n\t\treturn vector<ld>();\n\t}\n}\nvector<pair<ld,ld>> solve(vector<apple>apples) {\n\tapple apple_1=apples[1]-apples[0];\n\tapple apple_2=apples[2]-apples[0];\n\n\tld two=apple_1.v.first*apple_2.v.second-(apple_1.v.second*apple_2.v.first);\n\n\tld one=apple_1.v.first* (apple_2.coors.second) + apple_2.v.second* (apple_1.coors.first)-\n\t\tapple_2.v.first*(apple_1.coors.second)-apple_1.v.second*(apple_2.coors.first);\n\n\tld zero=(apple_1.coors.first)*(apple_2.coors.second)\n\t\t-(apple_1.coors.second)*(apple_2.coors.first);\n\tzero=zero;\n\n\tauto v=quad_equa(two,one,zero);\n\n\tvector<pair<ld,ld>>ans;\n\tfor (auto a : v) {\n\t\tif (a > -eps) {\n\t\t\tans.push_back(make_pair(a-eps,a+eps));\n\t\t}\n\t}\n\tif (abs(two) < eps&&abs(one) < eps&&abs(zero) < eps) {\n\t\tans.emplace_back(-1e8,1e8);\n\t}\n\treturn ans;\n\n}\nclass Compress {\npublic:\n\tbool operator()(const ld&l, const ld&r)const {\n\t\treturn l+eps<r;\n\t}\n};\nint main() {\n\tint N;cin>>N;\n\tvector<pair<apple,int>>apples;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint a,b,c,d;cin>>a>>b>>c>>d;\n\n\t\tapple n_apple{ make_pair(a,b),make_pair(c,d) };\n\t\tauto it = find_if(apples.begin(), apples.end(), [&](const pair<apple,int>&l) {\n\t\t\treturn l.first.coors==n_apple.coors&&l.first.v==n_apple.v;\n\t\t});\n\t\tif (it == apples.end()) {\n\t\t\tapples.push_back(make_pair(apple{ make_pair(a,b),make_pair(c,d) },1));\n\t\t}\n\t\telse {\n\t\t\tit->second++;\n\t\t}\n\n\t}\n\t\n\n\tint ans=0;\n\n\tset<ld,Compress>aset;\n\tfor (int i = 0; i < apples.size(); ++i) {\n\t\tfor (int j = 0; j < apples.size(); ++j) {\n\t\t\tif(i==j)continue;\n\n\t\t\tauto apple_i=apples[i].first;\n\t\t\tauto apple_j=apples[j].first;\n\t\t\tld time=-2;\n\t\t\t\n\t\t\t\t\n\t\t\t\tint dx=apple_i.coors.first-apple_j.coors.first;\n\t\t\t\tint dy=apple_i.coors.second-apple_j.coors.second;\n\t\t\t\tdx=-dx;\n\t\t\t\tdy=-dy;\n\t\t\t\tint dvx=apple_i.v.first-apple_j.v.first;\n\t\t\t\tint dvy=apple_i.v.second-apple_j.v.second;\n\n\t\t\t\tbool ok=true;\n\n\t\t\t\tld time1=-1;\n\t\t\t\tif (dx >= 0 && dvx > 0) {\n\t\t\t\t\ttime1=ld(dx)/dvx;\n\t\t\t\t}\n\t\t\t\telse if (dx == 0 && dvx == 0) {\n\t\t\t\t\ttime1=1e9;\n\t\t\t\t}\n\t\t\t\telse if (dx <= 0 && dvx < 0) {\n\t\t\t\t\ttime1=ld(dx)/dvx;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t\tld time2=-1;\n\t\t\t\tif (dy*dvy > 0) {\n\t\t\t\t\ttime2=ld(dy)/dvy;\n\t\t\t\t}\n\t\t\t\telse if (dy == 0 && dvy == 0) {\n\t\t\t\t\ttime2=1e9;\n\t\t\t\t}\n\t\t\t\telse if (dy == 0 && dvy != 0) {\n\t\t\t\t\ttime2=0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tok=false;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tif(time1>1e8)time1=time2;\n\t\t\t\t\tif(time2>1e8)time2=time1;\n\n\t\t\t\t\tif(abs(time1-time2)<eps)time=time1;\n\t\t\t\t}\n\t\t\t\taset.emplace(time);\n\n\t\t\tmap < ld, int, Compress > mp;\n\t\t\tif (time > -eps) {\n\t\t\t\tmp[time-2*eps]-=1000;\n\t\t\t\tmp[time+2*eps]+=1000;\n\t\t\t}\n\t\t\tfor (int k = 0; k < apples.size(); ++k) {\n\t\t\t\tif(i==k||j==k)continue;\n\t\t\t\tauto apple_k=apples[k].first;\n\n\t\t\t\tauto v = solve(vector<apple>{apple_i, apple_j, apple_k});\n\n\t\t\t\tfor (auto p : v) {\n\n\t\t\t\t\tmp[p.first] += apples[k].second;\n\t\t\t\t\tmp[p.second] -= apples[k].second;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tmp[1]+=0;\n\t\t\tint sum=apples[i].second+apples[j].second;\n\t\t\tfor (auto m : mp) {\n\t\t\t\tif (m.first > -eps) {\n\t\t\t\t\tans=max(ans,sum);\n\t\t\t\t}\n\t\t\t\tsum+=m.second;\n\t\t\t\tif (m.first >= -eps) {\n\t\t\t\t\tans = max(ans, sum);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (apples.size() <=2) {\n\t\tans=N;\n\t}else if (aset.size() == 1 && *aset.begin() > -1) {\n\t\tans=N;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n/*\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n*/\n\ntypedef double Real;\n\nconst Real eps=1e-9;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<=eps;\n}\n\ntemplate<class T> int sgn(T a){\n\tif(eq(a,0.0)) return 0;\n\tif(a>0) return 1;\n\treturn -1;\n}\n\nint N;\nint xs[110],ys[110],us[110],vs[110];\n\n//map<PP,int> cnt;\n\nvector<Real> vals;\nint num;\n\nvoid push(int a,int b,int c,int d,int e,int f,int g,int h){\n\tint A=c*h-d*g;\n\tint B=a*h+c*f-b*g-d*e;\n\tint C=a*f-b*e;\n\tif(A==0){\n\t\tif(B==0){\n\t\t\tif(C==0){\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tReal t=-(Real)C/B;\n\t\tif(sgn(t)>=0){\n\t\t\tvals.push_back(t);\n\t\t}\n\t\treturn;\n\t}\n\tif(B*B-4*A*C<0){\n\t\treturn;\n\t}\n\tif(B*B-4*A*C==0){\n\t\tReal t=-(Real)B/(A*2);\n\t\tif(sgn(t)>=0) vals.push_back(t);\n\t\treturn;\n\t}\n\tReal s=sqrt(B*B-4*A*C);\n\tReal t1=(-B+s)/(A*2);\n\tif(sgn(t1)>=0) vals.push_back(t1);\n\tReal t2=(-B-s)/(A*2);\n\tif(sgn(t2)>=0) vals.push_back(t2);\n}\n\nvoid init(){\n\tvals.clear();\n\tnum=0;\n}\n\nint solve(int id1,int id2){\n//\tprintf(\"%d %d\\n\",id1,id2);\n\tinit();\n\tint x1=xs[id1],y1=ys[id1],u1=us[id1],v1=vs[id1];\n\tint x2=xs[id2],y2=ys[id2],u2=us[id2],v2=vs[id2];\n\tfor(int i=0;i<N;i++){\n\t\tif(i==id1||i==id2) continue;\n\t\tint x=xs[i],y=ys[i],u=us[i],v=vs[i];\n\t\tpush(x1-x,y1-y,u1-u,v1-v,x2-x,y2-y,u2-u,v2-v);\n\t}\n\tint Ma=0;\n\tReal t;\n\tfor(int i=0;i<vals.size();i++){\n\t\tReal v=vals[i];\n\t\tint tmp=0;\n\t\tif(eq(xs[id1]+us[id1]*v,xs[id2]+us[id2]*v)&&eq(ys[id1]+vs[id1]*v,ys[id2]+vs[id2]*v)) continue;\n//\t\tprintf(\"%f\\n\",v);\n\t\tfor(int j=i;j<vals.size();j++){\n\t\t\tif(eq(v,vals[j])){\n\t\t\t\ttmp++;\n\t\t\t}\n\t\t}\n\t\tif(tmp+num+2==N){\n\t\t\tprintf(\"%d %d\\n\",id1,id2);\n\t\t\tprintf(\"%f %d\\n\",v,num);\n\t\tfor(int j=0;j<N;j++){\n\t\t\tprintf(\"%f %f\\n\",xs[j]+us[j]*v,ys[j]+vs[j]*v);\n\t\t}\n\t\t}\n\t\tMa=max(Ma,tmp);\n\t}\n//\tprintf(\"num=%d\\n\",num);\n\treturn Ma+num+2;\n}\n\nbool all_same(){\n\tfor(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n\t\tif(xs[i]!=xs[j]||ys[i]!=ys[j]||us[i]!=us[j]||vs[i]!=vs[j]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nReal get(int x1,int u1,int x2,int u2){\n\tif(u1==u2){\n\t\tif(x1==x2) return -1;\n\t\telse return -2;\n\t}\n\treturn (Real)(x2-x1)/(u1-u2);\n}\n\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d%d%d%d\",xs+i,ys+i,us+i,vs+i);\n\t}\n\tif(N<=2){\n\t\tprintf(\"%d\\n\",N);\n\t\treturn 0;\n\t}\n\tif(all_same()){\n\t\tprintf(\"%d\\n\",N);\n\t\treturn 0;\n\t}\n\tbool flg=true;\n\tfor(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n\t\tReal tx=get(xs[i],us[i],xs[j],us[j]);\n\t\tReal ty=get(ys[i],vs[i],ys[j],vs[j]);\n\t\tif(eq(tx,-2.0)||eq(ty,-2.0)) continue;\n\t\tif(eq(tx,-1.0)&&eq(ty,-1.0)) continue;\n\t\tReal t;\n\t\tif(eq(tx,-1.0)) t=ty;\n\t\telse t=tx;\n\t\tif(eq(tx,-1.0)==false&&eq(tx,t)==false) continue;\n\t\tif(eq(ty,-1.0)==false&&eq(ty,t)==false) continue;\n\t\tReal X=xs[0]+t*us[0];\n\t\tReal Y=ys[0]+t*vs[0];\n\t\tfor(int k=0;k<N;k++){\n\t\t\tReal cx=xs[k]+t*us[k];\n\t\t\tReal cy=ys[k]+t*vs[k];\n\t\t\tif(eq(X,cx)==false||eq(Y,cy)==false){\n\t\t\t\tflg=false;\n\t\t\t\tgoto ed;\n\t\t\t}\n\t\t}\n\t}\n\ted:;\n\tif(flg){\n\t\tprintf(\"%d\\n\",N);\n\t\treturn 0;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n\t\tif(xs[i]==xs[j]&&ys[i]==ys[j]&&us[i]==us[j]&&vs[i]==vs[j]){\n\t\t\tcontinue;\n\t\t}\n\t\tint cur=solve(i,j);\n\t\tans=max(ans,cur);\n\t}\n\tif(ans==0){\n\t\tprintf(\"%d\\n\",N);\n\t}else{\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\n#include <tuple>\nusing namespace std;\n\n#define INF (1 << 20)\n#define EPS (1e-10)\n#define EQ(a,b) (fabs((a)-(b)) < EPS)\n\nint main(){\n\tint x[200], y[200], u[200], v[200];\n\tint n;\n\tint result = 0;\n\tint flg = 0;\n\tcin >> n;\n\tif (n == 1 || n == 2) {\n\t\tcout << n << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> u[i] >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tvector<tuple<double, double, double> > txyl;\n\t\t\tint cnt = 0;\n\t\t\tint xa = x[i] - x[j];\n\t\t\tint ya = y[i] - y[j];\n\t\t\tint ua = u[i] - u[j];\n\t\t\tint va = v[i] - v[j];\n\t\t\tif (xa == 0 && ya == 0 && ua == 0 && va == 0) continue;\n\t\t\tflg = 1;\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tint xb = x[i] - x[k];\n\t\t\t\tint yb = y[i] - y[k];\n\t\t\t\tint ub = u[i] - u[k];\n\t\t\t\tint vb = v[i] - v[k];\n\t\t\t\tdouble a = ua * vb - ub * va;\n\t\t\t\tdouble b = xa * vb + ua * yb - xb * va - ub * ya;\n\t\t\t\tdouble c = xa * yb - xb * ya;\n\t\t\t\tif (a == 0 && b == 0) {\n\t\t\t\t\tif (c == 0)\t++cnt;\n\t\t\t\t} else if (a == 0) {\n\t\t\t\t\tdouble t = -c/b;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t} else {\n\t\t\t\t\tif (b * b - 4 * a * c < 0) continue;\n\t\t\t\t\tdouble temp;\n\t\t\t\t\tif (4 * a * c == 0) {\n\t\t\t\t\t\ttemp = fabs(b);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttemp = sqrt(b * b - 4 * a * c);\n\t\t\t\t\t}\n\t\t\t\t\tif (EQ(temp/a,0)) {\n\t\t\t\t\t\tdouble t = -b / 2.0 / a;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble t = (-b + temp) / 2.0 / a;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\tt = (-b - temp) / 2.0 / a;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(txyl.begin(), txyl.end());\n\t\t\tint kk = 0;\n\t\t\twhile (kk < txyl.size() && get<0>(txyl[kk]) < 0) ++kk;\n\t\t\tint ccnt = 0;\n\t\t\twhile (kk < txyl.size()) {\n\t\t\t\tdouble time = get<0>(txyl[kk]);\n\t\t\t\tint no_line = 0;\n\t\t\t\tfor (int k = kk; k < txyl.size() && EQ(time,get<0>(txyl[k]));++k) {\n\t\t\t\t\tif (EQ(get<1>(txyl[k]),0) && EQ(get<2>(txyl[k]),0)) {\n\t\t\t\t\t\t++no_line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint max_group = 0;\n\t\t\t\tfor (int l = kk; l < txyl.size() && EQ(time,get<0>(txyl[l])); ++l) {\n\t\t\t\t\tint num_group = 0;\n\t\t\t\t\tif (EQ(get<1>(txyl[l]),0) && EQ(get<2>(txyl[l]),0)) continue;\n\t\t\t\t\tfor (int k = kk; k < txyl.size() && EQ(time,get<0>(txyl[k])); ++k) {\n\t\t\t\t\t\tif (EQ(get<1>(txyl[k]),0) && EQ(get<2>(txyl[k]),0)) continue;\n\t\t\t\t\t\tif (EQ(get<1>(txyl[l]) * get<2>(txyl[k]), get<1>(txyl[k]) * get<2>(txyl[l]))) {\n\t\t\t\t\t\t\t++num_group;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmax_group = max(max_group, num_group);\n\t\t\t\t}\n\t\t\t\tccnt = max(ccnt, no_line + max_group);\n\t\t\t\twhile (EQ(get<0>(txyl[kk]), time)) {\n\t\t\t\t\t++kk;\n\t\t\t\t\tif (kk == txyl.size()) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"i:\" << i << \" j:\" << j << \" cnt:\" << cnt << \" ccnt:\" << ccnt << \" txyl:\" << txyl.size() << endl;\n\t\t\tresult = max(result, ccnt + cnt);\n\t\t}\n\t}\n\tif (flg == 0) {\n\t\tcout << n << endl;\n\t} else {\n\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n \nusing namespace std;\n/*\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n*/\n \ntypedef double Real;\n \nconst Real eps=1e-9;\n \ntemplate<class T> bool eq(T a,T b){\n    return abs(a-b)<=eps;\n}\n \ntemplate<class T> int sgn(T a){\n    if(eq(a,0.0)) return 0;\n    if(a>0) return 1;\n    return -1;\n}\n \nint N;\nint xs[220],ys[220],us[220],vs[220];\n \n//map<PP,int> cnt;\n \nvector<Real> vals;\nint num;\n \nvoid push(int a,int b,int c,int d,int e,int f,int g,int h){\n    int A=c*h-d*g;\n    int B=a*h+c*f-b*g-d*e;\n    int C=a*f-b*e;\n    if(A==0){\n        if(B==0){\n            if(C==0){\n                num++;\n            }\n            return;\n        }\n        Real t=-(Real)C/B;\n        if(sgn(t)>=0){\n            vals.push_back(t);\n        }\n        return;\n    }\n    if(B*B-4*A*C<0){\n        return;\n    }\n    if(B*B-4*A*C==0){\n        Real t=-(Real)B/(A*2);\n        if(sgn(t)>=0) vals.push_back(t);\n        return;\n    }\n    Real s=sqrt(B*B-4*A*C);\n    Real t1=(-B+s)/(A*2);\n    if(sgn(t1)>=0) vals.push_back(t1);\n    Real t2=(-B-s)/(A*2);\n    if(sgn(t2)>=0) vals.push_back(t2);\n}\n \nvoid init(){\n    vals.clear();\n    num=0;\n}\n \nint solve(int id1,int id2){\n//  printf(\"%d %d\\n\",id1,id2);\n    init();\n    int x1=xs[id1],y1=ys[id1],u1=us[id1],v1=vs[id1];\n    int x2=xs[id2],y2=ys[id2],u2=us[id2],v2=vs[id2];\n    for(int i=0;i<N;i++){\n        if(i==id1||i==id2) continue;\n        int x=xs[i],y=ys[i],u=us[i],v=vs[i];\n//      printf(\"%d %d %d %d %d %d %d %d\\n\",x1-x,y1-y,u\n        push(x1-x,y1-y,u1-u,v1-v,x2-x,y2-y,u2-u,v2-v);\n//      printf(\"pushed %d\\n\",i);\n    }\n//  printf(\"c\\n\");\n    int Ma=0;\n    Real t;\n    for(int i=0;i<vals.size();i++){\n        Real v=vals[i];\n        int tmp=0;\n        if(eq(xs[id1]+us[id1]*v,xs[id2]+us[id2]*v)&&eq(ys[id1]+vs[id1]*v,ys[id2]+vs[id2]*v)) continue;\n//      printf(\"%f\\n\",v);\n        for(int j=i;j<vals.size();j++){\n            if(eq(v,vals[j])){\n                tmp++;\n            }\n        }\n//      if(tmp+num+2==N){\n//          printf(\"%d %d\\n\",id1,id2);\n//          printf(\"%f %d\\n\",v,num);\n//      for(int j=0;j<N;j++){\n//          printf(\"%f %f\\n\",xs[j]+us[j]*v,ys[j]+vs[j]*v);\n//      }\n//      }\n        Ma=max(Ma,tmp);\n    }\n//  printf(\"num=%d\\n\",num);\n    return Ma+num+2;\n}\n \nbool all_same(){\n    for(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n        if(xs[i]!=xs[j]||ys[i]!=ys[j]||us[i]!=us[j]||vs[i]!=vs[j]){\n            return false;\n        }\n    }\n    return true;\n}\n \nReal get(int x1,int u1,int x2,int u2){\n    if(u1==u2){\n        if(x1==x2) return -1;\n        else return -2;\n    }\n    return (Real)(x2-x1)/(u1-u2);\n}\n \nint main(){\n    scanf(\"%d\",&N);\n    for(int i=0;i<N;i++){\n        scanf(\"%d%d%d%d\",xs+i,ys+i,us+i,vs+i);\n    }\n    if(N<=2){\n        printf(\"%d\\n\",N);\n        return 0;\n    }\n    if(all_same()){\n        printf(\"%d\\n\",N);\n        return 0;\n    }\n//  printf(\"a\\n\");\n    bool flg=false;\n    for(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n        Real tx=get(xs[i],us[i],xs[j],us[j]);\n        Real ty=get(ys[i],vs[i],ys[j],vs[j]);\n        if(eq(tx,-2.0)||eq(ty,-2.0)) continue;\n        if(eq(tx,-1.0)&&eq(ty,-1.0)) continue;\n        Real t;\n        if(eq(tx,-1.0)) t=ty;\n        else t=tx;\n        if(eq(tx,-1.0)==false&&eq(tx,t)==false) continue;\n        if(eq(ty,-1.0)==false&&eq(ty,t)==false) continue;\n        if(sgn(t)<0) continue;\n        Real X=xs[0]+t*us[0];\n        Real Y=ys[0]+t*vs[0];\n        bool tmp=true;\n        for(int k=0;k<N;k++){\n            Real cx=xs[k]+t*us[k];\n            Real cy=ys[k]+t*vs[k];\n            if(eq(X,cx)==false||eq(Y,cy)==false){\n                tmp=false;\n            }\n        }\n        if(tmp) flg=true;\n    }\n//  printf(\"b\\n\");\n    ed:;\n    if(flg){\n        printf(\"%d\\n\",N);\n        return 0;\n    }\n    int ans=0;\n//  printf(\"c\\n\");\n    for(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n        if(xs[i]==xs[j]&&ys[i]==ys[j]&&us[i]==us[j]&&vs[i]==vs[j]){\n            continue;\n        }\n//      printf(\"a %d %d\\n\",i,j);\n        int cur=solve(i,j);\n        ans=max(ans,cur);\n    }\n//  printf(\"d\\n\");\n    if(ans==0){\n        printf(\"%d\\n\",N);\n    }else{\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\n#include <tuple>\nusing namespace std;\n\n#define INF (1 << 20)\n#define EPS (1e-10)\n#define EQ(a,b) (fabs((a)-(b)) < EPS)\n\nint main(){\n\tint x[200], y[200], u[200], v[200];\n\tint n;\n\tint result = 0;\n\tint flg = 0;\n\tcin >> n;\n\tif (n == 1 || n == 2) {\n\t\tcout << n << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> u[i] >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tvector<tuple<double, double, double> > txyl;\n\t\t\tint cnt = 0;\n\t\t\tint xa = x[i] - x[j];\n\t\t\tint ya = y[i] - y[j];\n\t\t\tint ua = u[i] - u[j];\n\t\t\tint va = v[i] - v[j];\n\t\t\tif (xa == 0 && ya == 0) continue;\n\t\t\tflg = 1;\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tint xb = x[i] - x[k];\n\t\t\t\tint yb = y[i] - y[k];\n\t\t\t\tint ub = u[i] - u[k];\n\t\t\t\tint vb = v[i] - v[k];\n\t\t\t\tdouble a = ua * vb - ub * va;\n\t\t\t\tdouble b = xa * vb + ua * yb - xb * va - ub * ya;\n\t\t\t\tdouble c = xa * yb - xb * ya;\n\t\t\t\tif (a == 0 && b == 0) {\n\t\t\t\t\tif (c == 0)\t++cnt;\n\t\t\t\t} else if (a == 0) {\n\t\t\t\t\tdouble t = -c/b;\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t} else {\n\t\t\t\t\tif (b * b - 4 * a * c < 0) continue;\n\t\t\t\t\tdouble temp = sqrt(b * b - 4 * a * c);\n\t\t\t\t\tif (EQ(temp/a,0)) {\n\t\t\t\t\t\tdouble t = -b / 2.0 / a;\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble t = (-b + temp) / 2.0 / a;\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\tt = (-b - temp) / 2.0 / a;\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(txyl.begin(), txyl.end());\n\t\t\tint kk = 0;\n\t\t\twhile (kk < txyl.size() && get<0>(txyl[kk]) < -EPS) ++kk;\n\t\t\tint ccnt = 0;\n\t\t\twhile (kk < txyl.size()) {\n\t\t\t\tdouble time = get<0>(txyl[kk]);\n\t\t\t\tint no_line = 0;\n\t\t\t\tfor (int k = kk; k < txyl.size() && EQ(time,get<0>(txyl[k]));++k) {\n\t\t\t\t\tif (EQ(get<1>(txyl[k]),0) && EQ(get<2>(txyl[k]),0)) {\n\t\t\t\t\t\t++no_line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint max_group = 0;\n\t\t\t\tfor (int l = kk; l < txyl.size() && EQ(time,get<0>(txyl[l])); ++l) {\n\t\t\t\t\tint num_group = 0;\n\t\t\t\t\tif (EQ(get<1>(txyl[l]),0) && EQ(get<2>(txyl[l]),0)) continue;\n\t\t\t\t\tfor (int k = kk; k < txyl.size() && EQ(time,get<0>(txyl[k])); ++k) {\n\t\t\t\t\t\tif (EQ(get<1>(txyl[k]),0) && EQ(get<2>(txyl[k]),0)) continue;\n\t\t\t\t\t\tif (EQ(get<1>(txyl[l]) * get<2>(txyl[k]), get<1>(txyl[k]) * get<2>(txyl[l]))) {\n\t\t\t\t\t\t\t++num_group;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmax_group = max(max_group, num_group);\n\t\t\t\t}\n\t\t\t\tccnt = max(ccnt, no_line + max_group);\n\t\t\t\twhile (EQ(get<0>(txyl[kk]), time)) {\n\t\t\t\t\t++kk;\n\t\t\t\t\tif (kk == txyl.size()) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"i:\" << i << \" j:\" << j << \" cnt:\" << cnt << \" ccnt:\" << ccnt << \" txyl:\" << txyl.size() << endl;\n\t\t\tresult = max(result, ccnt + cnt);\n\t\t}\n\t}\n\tif (flg == 0) {\n\t\tcout << n << endl;\n\t} else {\n\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\n#include <tuple>\nusing namespace std;\n\n#define INF (1 << 20)\n\nint main(){\n\tint x[200], y[200], u[200], v[200];\n\tint n;\n\tint result = 0;\n\tint flg = 0;\n\tcin >> n;\n\tif (n == 1 || n == 2) {\n\t\tcout << n << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> u[i] >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tvector<tuple<double, double, double> > txyl;\n\t\t\tint cnt = 0;\n\t\t\tint xa = x[i] - x[j];\n\t\t\tint ya = y[i] - y[j];\n\t\t\tint ua = u[i] - u[j];\n\t\t\tint va = v[i] - v[j];\n\t\t\tif (xa == 0 && ya == 0 && ua == 0 && va == 0) continue;\n\t\t\tflg = 1;\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tint xb = x[i] - x[k];\n\t\t\t\tint yb = y[i] - y[k];\n\t\t\t\tint ub = u[i] - u[k];\n\t\t\t\tint vb = v[i] - v[k];\n\t\t\t\tdouble a = ua * vb - ub * va;\n\t\t\t\tdouble b = xa * vb + ua * yb - xb * va - ub * ya;\n\t\t\t\tdouble c = xa * yb - xb * ya;\n\t\t\t\tif (fabs(a) <= 1e-10 && fabs(b) <= 1e-10) {\n\t\t\t\t\tif (c == 0)\t++cnt;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (fabs(a) <= 1e-10) {\n\t\t\t\t\tdouble t = -c/b;\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t} else {\n\t\t\t\t\tif (b * b - 4 * a * c < 0) continue;\n\t\t\t\t\tdouble temp = sqrt(b * b - 4 * a * c);\n\t\t\t\t\tif (temp <= 1e-10) {\n\t\t\t\t\t\tdouble t = -b / 2.0 / a;\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble t = (-b + temp) / 2.0 / a;\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\tt = (-b - temp) / 2.0 / a;\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(txyl.begin(), txyl.end());\n\t\t\tint kk = 0;\n\t\t\twhile (kk < txyl.size() && get<0>(txyl[kk]) < 0) ++kk;\n\t\t\tint ccnt = 0;\n\t\t\twhile (kk < txyl.size()) {\n\t\t\t\tdouble time = get<0>(txyl[kk]);\n\t\t\t\tint no_line = 0;\n\t\t\t\tfor (int k = kk; k < txyl.size() && time == get<0>(txyl[k]) ;++k) {\n\t\t\t\t\tif (fabs(get<1>(txyl[k])) <= 1e-10 && fabs(get<2>(txyl[k])) <= 1e-10) {\n\t\t\t\t\t\t++no_line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint max_group = 0;\n\t\t\t\tfor (int l = kk; l < txyl.size() && time == get<0>(txyl[l]); ++l) {\n\t\t\t\t\tint num_group = 0;\n\t\t\t\t\tif (fabs(get<1>(txyl[l])) <= 1e-10 && fabs(get<2>(txyl[l])) <= 1e-10) continue;\n\t\t\t\t\tfor (int k = kk; k < txyl.size() && time == get<0>(txyl[k]); ++k) {\n\t\t\t\t\t\tif (fabs(get<1>(txyl[k])) <= 1e-10 && fabs(get<2>(txyl[k])) <= 1e-10) continue;\n\t\t\t\t\t\tif (fabs(get<1>(txyl[l]) * get<2>(txyl[k]) - get<1>(txyl[k]) * get<2>(txyl[l])) <= 1e-10) {\n\t\t\t\t\t\t\t++num_group;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmax_group = max(max_group, num_group);\n\t\t\t\t}\n\t\t\t\tccnt = max(ccnt, no_line + max_group);\n\t\t\t\twhile (get<0>(txyl[kk]) == time) {\n\t\t\t\t\t++kk;\n\t\t\t\t\tif (kk == txyl.size()) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"i:\" << i << \" j:\" << j << \" cnt:\" << cnt << \" ccnt:\" << ccnt << \" txyl:\" << txyl.size() << endl;\n\t\t\tresult = max(result, ccnt + cnt);\n\t\t}\n\t}\n\tif (flg == 0) {\n\t\tcout << n << endl;\n\t} else {\n\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define equals(a,b) fabs((a)-(b)) < EPS\n\nclass Point {\npublic:\n\tlong double x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (long double a) {\n\t\treturn Point(a*x, a*y);\n\t}\n\tPoint operator / (long double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator > (const Point &p)const {\n\t\treturn x != p.x ? x > p.x : y > p.y;\n\t}\n\n\tbool operator ==(const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS  && fabs(y - p.y) < EPS;\n\t}\n};\n\nstruct Line {\n\tPoint p1, p2;\n};\n\nstruct Point2 {\n\tPoint v1, v2;\n};\n\nlong double ABS(Point a) {\n\treturn sqrt(a.x*a.x + a.y*a.y);\n}\n\nlong double cross(Point a,Point b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nlong double distance(Line L, Point P1) {\n\treturn cross(L.p2 - L.p1, P1 - L.p1) / ABS(L.p2 - L.p1);\n}\n\nPoint ichi(Point2 P1, double t) {\n\tPoint D;\n\tD.x = P1.v1.x + P1.v2.x * t;\n\tD.y = P1.v1.y + P1.v2.y * t;\n\treturn D;\n}\n\nlong double binary_search(Point2 P1, Point2 P2, Point2 P3) {\n\tlong double Left = -1.0e+9, Right = 1.0e+9, Mid = 0, H;\n\tLine G1, G2;\n\tPoint E1 = ichi(P1, 0);\n\tPoint E2 = ichi(P2, 0);\n\tPoint E3 = ichi(P3, 0);\n\tPoint F1 = ichi(P1, 1);\n\tPoint F2 = ichi(P2, 1);\n\tPoint F3 = ichi(P3, 1);\n\tG1.p1 = E1; G1.p2 = E2; G2.p1 = F1; G2.p2 = F2;\n\tlong double D1 = distance(G1, E3);\n\tlong double D2 = distance(G2, F3);\n\tif (D1 < D2) {\n\t\twhile (true) {\n\t\t\tMid = (Left + Right) / 2;\n\t\t\tE1 = ichi(P1, Mid);\n\t\t\tE2 = ichi(P2, Mid);\n\t\t\tE3 = ichi(P3, Mid);\n\t\t\tG1.p1 = E1; G1.p2 = E2;\n\t\t\tH = distance(G1, E3);\n\t\t\tif (fabs(H) < EPS) {\n\t\t\t\treturn Mid;\n\t\t\t}\n\t\t\tif (H > 0) {\n\t\t\t\tRight = Mid;\n\t\t\t}\n\t\t\tif (H < 0) {\n\t\t\t\tLeft = Mid;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\twhile (true) {\n\t\t\tMid = (Left + Right) / 2;\n\t\t\tE1 = ichi(P1, Mid);\n\t\t\tE2 = ichi(P2, Mid);\n\t\t\tE3 = ichi(P3, Mid);\n\t\t\tG1.p1 = E1; G1.p2 = E2;\n\t\t\tH = distance(G1, E3);\n\t\t\tif (abs(H) < EPS) {\n\t\t\t\treturn Mid;\n\t\t\t}\n\t\t\tif (H < 0) {\n\t\t\t\tRight = Mid;\n\t\t\t}\n\t\t\tif (H > 0) {\n\t\t\t\tLeft = Mid;\n\t\t\t}\n\t\t}\n\t}\n\treturn Mid;\n}\n\nPoint2 V[300];\nint n;\nint W[300];\nvector<long double>a;\nint sum;\nint maxn;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> V[i].v1.x >> V[i].v1.y >> V[i].v2.x >> V[i].v2.y;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\ta.push_back(binary_search(V[i], V[j], V[k]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(a.begin(), a.end());\n\tsum = 1;\n\tfor (int i = 1; i < a.size(); i++) {\n\t\tif (fabs(a[i] - a[i - 1]) < EPS) {\n\t\t\tsum++;\n\t\t}\n\t\telse {\n\t\t\tsum = 0;\n\t\t}\n\t\tmaxn = max(maxn, sum);\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tW[i] = i*(i + 1)*(i + 2) / 6;\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tif (W[i] == n) {\n\t\t\tcout << n + 2 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\n#define EPS 1e-7\n#define equals(a,b) fabs((a)-(b)) < EPS\n\nclass Point {\npublic:\n\tlong double x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (long double a) {\n\t\treturn Point(a*x, a*y);\n\t}\n\tPoint operator / (long double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator > (const Point &p)const {\n\t\treturn x != p.x ? x > p.x : y > p.y;\n\t}\n\n\tbool operator ==(const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS  && fabs(y - p.y) < EPS;\n\t}\n};\n\nstruct Line {\n\tPoint p1, p2;\n};\n\nstruct Point2 {\n\tPoint v1, v2;\n};\n\nlong double ABS(Point a) {\n\treturn sqrt(a.x*a.x + a.y*a.y);\n}\n\nlong double cross(Point a,Point b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nlong double distance(Line L, Point P1) {\n\treturn cross(L.p2 - L.p1, P1 - L.p1) / ABS(L.p2 - L.p1);\n}\n\nPoint ichi(Point2 P1, double t) {\n\tPoint D;\n\tD.x = P1.v1.x + P1.v2.x * t;\n\tD.y = P1.v1.y + P1.v2.y * t;\n\treturn D;\n}\n\nlong double binary_search(Point2 P1, Point2 P2, Point2 P3) {\n\tlong double Left = -1.0e+9, Right = 1.0e+9, Mid = 0, H;\n\tbool ok = false;\n\tint cnt = 0;\n\tLine G1, G2;\n\tPoint E1 = ichi(P1, 0);\n\tPoint E2 = ichi(P2, 0);\n\tPoint E3 = ichi(P3, 0);\n\tPoint F1 = ichi(P1, 1);\n\tPoint F2 = ichi(P2, 1);\n\tPoint F3 = ichi(P3, 1);\n\tG1.p1 = E1; G1.p2 = E2; G2.p1 = F1; G2.p2 = F2;\n\tlong double D1 = distance(G1, E3);\n\tlong double D2 = distance(G2, F3);\n\tif (D1 < D2) {\n\tQ:;\n\t\tLeft = -1.0e+9; Right = 1.0e+9; cnt = 0;\n\t\twhile (true) {\n\t\t\tMid = (Left + Right) / 2;\n\t\t\tE1 = ichi(P1, Mid);\n\t\t\tE2 = ichi(P2, Mid);\n\t\t\tE3 = ichi(P3, Mid);\n\t\t\tG1.p1 = E1; G1.p2 = E2;\n\t\t\tH = distance(G1, E3);\n\t\t\tif (fabs(H) < EPS) {\n\t\t\t\treturn Mid;\n\t\t\t}\n\t\t\tif (H > 0) {\n\t\t\t\tRight = Mid;\n\t\t\t}\n\t\t\tif (H < 0) {\n\t\t\t\tLeft = Mid;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tif (cnt >= 100) {\n\t\t\t\tif (ok == true) { return -1; }\n\t\t\t\tok = true;\n\t\t\t\tgoto P;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\tP:;\n\t\tLeft = -1.0e+9; Right = 1.0e+9; cnt = 0;\n\t\twhile (true) {\n\t\t\tMid = (Left + Right) / 2;\n\t\t\tE1 = ichi(P1, Mid);\n\t\t\tE2 = ichi(P2, Mid);\n\t\t\tE3 = ichi(P3, Mid);\n\t\t\tG1.p1 = E1; G1.p2 = E2;\n\t\t\tH = distance(G1, E3);\n\t\t\tif (abs(H) < EPS) {\n\t\t\t\treturn Mid;\n\t\t\t}\n\t\t\tif (H < 0) {\n\t\t\t\tRight = Mid;\n\t\t\t}\n\t\t\tif (H > 0) {\n\t\t\t\tLeft = Mid;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tif (cnt >= 100) {\n\t\t\t\tif (ok == true) { return -1; }\n\t\t\t\tok = true;\n\t\t\t\tgoto Q;\n\t\t\t}\n\t\t}\n\t}\n\treturn Mid;\n}\n\nPoint2 V[300];\nint n;\nint W[300];\nvector<long double>a;\nint sum;\nint maxn;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> V[i].v1.x >> V[i].v1.y >> V[i].v2.x >> V[i].v2.y;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\ta.push_back(binary_search(V[i], V[j], V[k]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(a.begin(), a.end());\n\tif (a[0] >= 0) { sum = 1; maxn = 1; }\n\tfor (int i = 1; i < a.size(); i++) {\n\t\tif (a[i] >= 0) {\n\t\t\tif (fabs(a[i] - a[i - 1]) < EPS) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum = 1;\n\t\t\t}\n\t\t\tmaxn = max(maxn, sum);\n\t\t}\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tW[i] = i*(i + 1)*(i + 2) / 6;\n\t}\n\tfor (int i = 0; i <= 200; i++) {\n\t\tif (W[i] >= maxn) {\n\t\t\tcout << i + 2 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\n#include <tuple>\nusing namespace std;\n\n#define INF (1 << 20)\n\nint main(){\n\tint x[200], y[200], u[200], v[200];\n\tint n;\n\tint result = 0;\n\tint flg = 0;\n\tcin >> n;\n\tif (n == 1 || n == 2) {\n\t\tcout << n << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> u[i] >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tvector<tuple<double, double, double> > txyl;\n\t\t\tint cnt = 0;\n\t\t\tint xa = x[i] - x[j];\n\t\t\tint ya = y[i] - y[j];\n\t\t\tint ua = u[i] - u[j];\n\t\t\tint va = v[i] - v[j];\n\t\t\tif (xa == 0 && ya == 0 && ua == 0 && va == 0) continue;\n\t\t\tflg = 1;\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tint xb = x[i] - x[k];\n\t\t\t\tint yb = y[i] - y[k];\n\t\t\t\tint ub = u[i] - u[k];\n\t\t\t\tint vb = v[i] - v[k];\n\t\t\t\tdouble a = ua * vb - ub * va;\n\t\t\t\tdouble b = xa * vb + ua * yb - xb * va - ub * ya;\n\t\t\t\tdouble c = xa * yb - xb * ya;\n\t\t\t\tif (fabs(a) <= 1e-10 && fabs(b) <= 1e-10) {\n\t\t\t\t\tif (c == 0)\t++cnt;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (fabs(a) <= 1e-10) {\n\t\t\t\t\tdouble t = -c/b;\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t} else {\n\t\t\t\t\tif (b * b - 4 * a * c < 0) continue;\n\t\t\t\t\tdouble temp = sqrt(b * b - 4 * a * c);\n\t\t\t\t\tif (temp <= 1e-10) {\n\t\t\t\t\t\tdouble t = -b / 2.0 / a;\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble t = (-b + temp) / 2.0 / a;\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\tt = (-b - temp) / 2.0 / a;\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(txyl.begin(), txyl.end());\n\t\t\tint kk = 0;\n\t\t\twhile (get<0>(txyl[kk]) < 0) ++kk;\n\t\t\tint ccnt = 0;\n\t\t\twhile (kk < txyl.size()) {\n\t\t\t\tdouble time = get<0>(txyl[kk]);\n\t\t\t\tint no_line = 0;\n\t\t\t\tfor (int k = kk; k < txyl.size() && time == get<0>(txyl[k]) ;++k) {\n\t\t\t\t\tif (fabs(get<1>(txyl[k])) <= 1e-10 && fabs(get<2>(txyl[k])) <= 1e-10) {\n\t\t\t\t\t\t++no_line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint max_group = 0;\n\t\t\t\tfor (int l = kk; l < txyl.size() && time == get<0>(txyl[l]); ++l) {\n\t\t\t\t\tint num_group = 0;\n\t\t\t\t\tif (fabs(get<1>(txyl[l])) <= 1e-10 && fabs(get<2>(txyl[l])) <= 1e-10) continue;\n\t\t\t\t\tfor (int k = kk; k < txyl.size() && time == get<0>(txyl[k]); ++k) {\n\t\t\t\t\t\tif (fabs(get<1>(txyl[k])) <= 1e-10 && fabs(get<2>(txyl[k])) <= 1e-10) continue;\n\t\t\t\t\t\tif (fabs(get<1>(txyl[l]) * get<2>(txyl[k]) - get<1>(txyl[k]) * get<2>(txyl[l])) <= 1e-10) {\n\t\t\t\t\t\t\t++num_group;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmax_group = max(max_group, num_group);\n\t\t\t\t}\n\t\t\t\tccnt = max(ccnt, no_line + max_group);\n\t\t\t\twhile (get<0>(txyl[kk]) == time) {\n\t\t\t\t\t++kk;\n\t\t\t\t\tif (kk == txyl.size()) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"i:\" << i << \" j:\" << j << \" cnt:\" << cnt << \" ccnt:\" << ccnt << \" txyl:\" << txyl.size() << endl;\n\t\t\tresult = max(result, ccnt + cnt);\n\t\t}\n\t}\n\tif (flg == 0) {\n\t\tcout << n << endl;\n\t} else {\n\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-10;\ndouble X[110];\ndouble Y[110];\ndouble U[110];\ndouble V[110];\ndouble ABS(double a){return max(a,-a);}\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%lf%lf%lf%lf\",X+i,Y+i,U+i,V+i);\n\t}\n\tint ret=1;\n\tfor(int i=0;i<a;i++){\n\t\tint cnt=0;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(ABS(X[i]-X[j])<EPS&&ABS(Y[i]-Y[j])<EPS&&ABS(U[i]-U[j])<EPS&&ABS(V[i]-V[j])<EPS){\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvector<double>t;\n\t\t\tdouble x1=X[j]-X[i];\n\t\t\tdouble Y1=Y[j]-Y[i];\n\t\t\tdouble u1=U[j]-U[i];\n\t\t\tdouble v1=V[j]-V[i];\n\t\t\tint now=2;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(k==i||k==j)continue;\n\t\t\t\tdouble x2=X[k]-X[i];\n\t\t\t\tdouble y2=Y[k]-Y[i];\n\t\t\t\tdouble u2=U[k]-U[i];\n\t\t\t\tdouble v2=V[k]-V[i];\n\t\t\t\tdouble A=u1*v2-u2*v1;\n\t\t\t\tdouble B=u1*y2+x1*v2-v1*x2-Y1*u2;\n\t\t\t\tdouble C=x1*y2-Y1*x2;\n\t\t\t\tif(ABS(A)>EPS){\n\t\t\t\t\tif(B*B-4*A*C>EPS){\n\t\t\t\t\t\tt.push_back((-B+sqrt(B*B-4*A*C))/A/2);\n\t\t\t\t\t\tt.push_back((-B-sqrt(B*B-4*A*C))/A/2);\n\t\t\t\t\t}else if(B*B-4*A*C>-EPS){\n\t\t\t\t\t\tt.push_back(-B/A/2);\n\t\t\t\t\t}\n\t\t\t\t}else if(ABS(B)>EPS){\n\t\t\t\t\tt.push_back(-C/B);\n\t\t\t\t}else{\n\t\t\t\t\tif(ABS(C)<EPS)now++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(t.begin(),t.end());\n\t\t\tint has=0;\n\t\t\tret=max(ret,now);\n\t\t\tfor(int k=0;k<t.size();k++){\n\t\t\t\tif(t[k]<-EPS)continue;\n\t\t\t\tif(k==0||ABS(t[k]-t[k-1])<EPS)has++;\n\t\t\t\telse has=1;\n\t\t\t\tif(ABS(X[i]+U[i]*t[k]-X[j]-U[j]*t[k])>EPS||ABS(Y[i]+V[i]*t[k]-Y[j]-V[j]*t[k])>EPS){\n\t\t\t\t\tret=max(ret,now+has);\n\t\t\t\t}else{\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\t\tif(ABS(X[i]+U[i]*t[k]-X[l]-U[l]*t[k])<EPS&&ABS(Y[i]+V[i]*t[k]-Y[l]-V[l]*t[k])<EPS)tmp++;\n\t\t\t\t\t}\n\t\t\t\t\tret=max(ret,tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret=max(ret,cnt);\n\t}\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\n#include <tuple>\nusing namespace std;\n\n#define INF (1 << 20)\n#define EPS (1e-10)\n#define EQ(a,b) (fabs((a)-(b)) < EPS)\n\nint main(){\n\tint x[200], y[200], u[200], v[200];\n\tint n;\n\tint result = 0;\n\tint flg = 0;\n\tcin >> n;\n\tif (n == 1 || n == 2) {\n\t\tcout << n << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> u[i] >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tvector<tuple<double, double, double> > txyl;\n\t\t\tint cnt = 0;\n\t\t\tint xa = x[i] - x[j];\n\t\t\tint ya = y[i] - y[j];\n\t\t\tint ua = u[i] - u[j];\n\t\t\tint va = v[i] - v[j];\n\t\t\tif (xa == 0 && ya == 0 && ua == 0 && va == 0) continue;\n\t\t\tflg = 1;\n\t\t\tint count = 0;\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tint flga = 0;\n\t\t\t\tint xb = x[i] - x[k];\n\t\t\t\tint yb = y[i] - y[k];\n\t\t\t\tint ub = u[i] - u[k];\n\t\t\t\tint vb = v[i] - v[k];\n\t\t\t\tdouble a = ua * vb - ub * va;\n\t\t\t\tdouble b = xa * vb + ua * yb - xb * va - ub * ya;\n\t\t\t\tdouble c = xa * yb - xb * ya;\n\t\t\t\tif (a == 0 && b == 0) {\n\t\t\t\t\tif (c == 0)\t++cnt;\n\t\t\t\t} else if (a == 0) {\n\t\t\t\t\tdouble t = -c/b;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\telse ++count;\n\t\t\t\t} else {\n\t\t\t\t\tif (b * b - 4 * a * c < 0) continue;\n\t\t\t\t\tdouble temp;\n\t\t\t\t\tif (4 * a * c == 0) {\n\t\t\t\t\t\ttemp = fabs(b);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttemp = sqrt(b * b - 4 * a * c);\n\t\t\t\t\t}\n\t\t\t\t\tif (EQ(temp/a,0)) {\n\t\t\t\t\t\tdouble t = -b / 2.0 / a;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\telse ++count;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble t = (-b + temp) / 2.0 / a;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\telse {++count,++flga;}\n\t\t\t\t\tt = (-b - temp) / 2.0 / a;\n\t\t\t\t\tif (!EQ(xa + t * ua,0) || !EQ(ya + t * va,0))\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\telse {if (!flga)++count;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count == n) result = n;\n\t\t\tsort(txyl.begin(), txyl.end());\n\t\t\tint kk = 0;\n\t\t\twhile (kk < txyl.size() && get<0>(txyl[kk]) < 0) ++kk;\n\t\t\tint ccnt = 0;\n\t\t\twhile (kk < txyl.size()) {\n\t\t\t\tdouble time = get<0>(txyl[kk]);\n\t\t\t\tint no_line = 0;\n\t\t\t\tfor (int k = kk; k < txyl.size() && EQ(time,get<0>(txyl[k]));++k) {\n\t\t\t\t\tif (EQ(get<1>(txyl[k]),0) && EQ(get<2>(txyl[k]),0)) {\n\t\t\t\t\t\t++no_line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint max_group = 0;\n\t\t\t\tfor (int l = kk; l < txyl.size() && EQ(time,get<0>(txyl[l])); ++l) {\n\t\t\t\t\tint num_group = 0;\n\t\t\t\t\tif (EQ(get<1>(txyl[l]),0) && EQ(get<2>(txyl[l]),0)) continue;\n\t\t\t\t\tfor (int k = kk; k < txyl.size() && EQ(time,get<0>(txyl[k])); ++k) {\n\t\t\t\t\t\tif (EQ(get<1>(txyl[k]),0) && EQ(get<2>(txyl[k]),0)) continue;\n\t\t\t\t\t\tif (EQ(get<1>(txyl[l]) * get<2>(txyl[k]), get<1>(txyl[k]) * get<2>(txyl[l]))) {\n\t\t\t\t\t\t\t++num_group;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmax_group = max(max_group, num_group);\n\t\t\t\t}\n\t\t\t\tccnt = max(ccnt, no_line + max_group);\n\t\t\t\twhile (EQ(get<0>(txyl[kk]), time)) {\n\t\t\t\t\t++kk;\n\t\t\t\t\tif (kk == txyl.size()) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"i:\" << i << \" j:\" << j << \" cnt:\" << cnt << \" ccnt:\" << ccnt << \" txyl:\" << txyl.size() << endl;\n\t\t\tresult = max(result, ccnt + cnt);\n\t\t}\n\t}\n\tif (flg == 0) {\n\t\tcout << n << endl;\n\t} else {\n\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-10;\ndouble X[110];\ndouble Y[110];\ndouble U[110];\ndouble V[110];\ndouble ABS(double a){return max(a,-a);}\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%lf%lf%lf%lf\",X+i,Y+i,U+i,V+i);\n\t}\n\tint ret=1;\n\tfor(int i=0;i<a;i++){\n\t\tint cnt=0;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(ABS(X[i]-X[j])<EPS&&ABS(Y[i]-Y[j])<EPS&&ABS(U[i]-U[j])<EPS&&ABS(V[i]-V[j])<EPS){\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvector<double>t;\n\t\t\tdouble x1=X[j]-X[i];\n\t\t\tdouble Y1=Y[j]-Y[i];\n\t\t\tdouble u1=U[j]-U[i];\n\t\t\tdouble v1=V[j]-V[i];\n\t\t\tint now=2;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(k==i||k==j)continue;\n\t\t\t\tdouble x2=X[k]-X[i];\n\t\t\t\tdouble y2=Y[k]-Y[i];\n\t\t\t\tdouble u2=U[k]-U[i];\n\t\t\t\tdouble v2=V[k]-V[i];\n\t\t\t\tdouble A=u1*v2-u2*v1;\n\t\t\t\tdouble B=u1*y2+x1*v2-v1*x2-Y1*u2;\n\t\t\t\tdouble C=x1*y2-Y1*x2;\n\t\t\t\tif(ABS(A)>EPS){\n\t\t\t\t\tif(B*B-4*A*C>EPS){\n\t\t\t\t\t\tt.push_back((-B+sqrt(B*B-4*A*C))/A/2);\n\t\t\t\t\t\tt.push_back((-B-sqrt(B*B-4*A*C))/A/2);\n\t\t\t\t\t}else if(B*B-4*A*C>-EPS){\n\t\t\t\t\t\tt.push_back(-B/A/2);\n\t\t\t\t\t}\n\t\t\t\t}else if(ABS(B)>EPS){\n\t\t\t\t\tt.push_back(-C/B);\n\t\t\t\t}else{\n\t\t\t\t\tif(ABS(C)<EPS)now++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(t.begin(),t.end());\n\t\t\tint has=0;\n\t\t\tret=max(ret,now);\n\t\t\tfor(int k=0;k<t.size();k++){\n\t\t\t\tif(t[k]<-EPS)continue;\n\t\t\t\tif(k==0||ABS(t[k]-t[k-1])<EPS)has++;\n\t\t\t\telse has=1;\n\t\t\t\tif(ABS(X[i]+U[i]*t[k]-X[j]-U[j]*t[k])>EPS||ABS(Y[i]+V[i]*t[k]-Y[j]-V[j]*t[k])>EPS){\n\t\t\t\t\tret=max(ret,now+has);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret=max(ret,cnt);\n\t}\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\n#define EPS 1e-10\n#define equals(a,b) fabs((a)-(b)) < EPS\n\nclass Point {\npublic:\n\tlong double x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (long double a) {\n\t\treturn Point(a*x, a*y);\n\t}\n\tPoint operator / (long double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator > (const Point &p)const {\n\t\treturn x != p.x ? x > p.x : y > p.y;\n\t}\n\n\tbool operator ==(const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS  && fabs(y - p.y) < EPS;\n\t}\n};\n\nstruct Line {\n\tPoint p1, p2;\n};\n\nstruct Point2 {\n\tPoint v1, v2;\n};\n\nlong double ABS(Point a) {\n\treturn sqrt(a.x*a.x + a.y*a.y);\n}\n\nlong double cross(Point a,Point b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nlong double distance(Line L, Point P1) {\n\treturn cross(L.p2 - L.p1, P1 - L.p1) / ABS(L.p2 - L.p1);\n}\n\nPoint ichi(Point2 P1, double t) {\n\tPoint D;\n\tD.x = P1.v1.x + P1.v2.x * t;\n\tD.y = P1.v1.y + P1.v2.y * t;\n\treturn D;\n}\n\nlong double binary_search(Point2 P1, Point2 P2, Point2 P3) {\n\tlong double Left = -1.0e+9, Right = 1.0e+9, Mid = 0, H;\n\tint cnt = 0;\n\tLine G1, G2;\n\tPoint E1 = ichi(P1, 0);\n\tPoint E2 = ichi(P2, 0);\n\tPoint E3 = ichi(P3, 0);\n\tPoint F1 = ichi(P1, 1);\n\tPoint F2 = ichi(P2, 1);\n\tPoint F3 = ichi(P3, 1);\n\tG1.p1 = E1; G1.p2 = E2; G2.p1 = F1; G2.p2 = F2;\n\tlong double D1 = distance(G1, E3);\n\tlong double D2 = distance(G2, F3);\n\tif (D1 < D2) {\n\t\twhile (true) {\n\t\t\tMid = (Left + Right) / 2;\n\t\t\tE1 = ichi(P1, Mid);\n\t\t\tE2 = ichi(P2, Mid);\n\t\t\tE3 = ichi(P3, Mid);\n\t\t\tG1.p1 = E1; G1.p2 = E2;\n\t\t\tH = distance(G1, E3);\n\t\t\tif (fabs(H) < EPS) {\n\t\t\t\treturn Mid;\n\t\t\t}\n\t\t\tif (H > 0) {\n\t\t\t\tRight = Mid;\n\t\t\t}\n\t\t\tif (H < 0) {\n\t\t\t\tLeft = Mid;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tif (cnt >= 100) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\twhile (true) {\n\t\t\tMid = (Left + Right) / 2;\n\t\t\tE1 = ichi(P1, Mid);\n\t\t\tE2 = ichi(P2, Mid);\n\t\t\tE3 = ichi(P3, Mid);\n\t\t\tG1.p1 = E1; G1.p2 = E2;\n\t\t\tH = distance(G1, E3);\n\t\t\tif (abs(H) < EPS) {\n\t\t\t\treturn Mid;\n\t\t\t}\n\t\t\tif (H < 0) {\n\t\t\t\tRight = Mid;\n\t\t\t}\n\t\t\tif (H > 0) {\n\t\t\t\tLeft = Mid;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tif (cnt >= 100) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn Mid;\n}\n\nPoint2 V[300];\nint n;\nint W[300];\nvector<long double>a;\nint sum;\nint maxn;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> V[i].v1.x >> V[i].v1.y >> V[i].v2.x >> V[i].v2.y;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\ta.push_back(binary_search(V[i], V[j], V[k]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(a.begin(), a.end());\n\tif (a[0] >= 0) { sum = 1; }\n\tfor (int i = 1; i < a.size(); i++) {\n\t\tif (a[i] >= 0) {\n\t\t\tif (fabs(a[i] - a[i - 1]) < EPS) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum = 1;\n\t\t\t}\n\t\t\tmaxn = max(maxn, sum);\n\t\t}\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tW[i] = i*(i + 1)*(i + 2) / 6;\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tif (W[i] >= maxn) {\n\t\t\tcout << i + 2 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-10;\ndouble X[210];\ndouble Y[210];\ndouble U[210];\ndouble V[210];\ndouble ABS(double a){return max(a,-a);}\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%lf%lf%lf%lf\",X+i,Y+i,U+i,V+i);\n\t}\n\tint ret=1;\n\tfor(int i=0;i<a;i++){\n\t\tint cnt=0;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(ABS(X[i]-X[j])<EPS&&ABS(Y[i]-Y[j])<EPS&&ABS(U[i]-U[j])<EPS&&ABS(V[i]-V[j])<EPS){\n\t\t\t\tcnt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvector<double>t;\n\t\t\tdouble x1=X[j]-X[i];\n\t\t\tdouble Y1=Y[j]-Y[i];\n\t\t\tdouble u1=U[j]-U[i];\n\t\t\tdouble v1=V[j]-V[i];\n\t\t\tint now=2;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(k==i||k==j)continue;\n\t\t\t\tdouble x2=X[k]-X[i];\n\t\t\t\tdouble y2=Y[k]-Y[i];\n\t\t\t\tdouble u2=U[k]-U[i];\n\t\t\t\tdouble v2=V[k]-V[i];\n\t\t\t\tdouble A=u1*v2-u2*v1;\n\t\t\t\tdouble B=u1*y2+x1*v2-v1*x2-Y1*u2;\n\t\t\t\tdouble C=x1*y2-Y1*x2;\n\t\t\t\tif(ABS(A)>EPS){\n\t\t\t\t\tif(B*B-4*A*C>EPS){\n\t\t\t\t\t\tt.push_back((-B+sqrt(B*B-4*A*C))/A/2);\n\t\t\t\t\t\tt.push_back((-B-sqrt(B*B-4*A*C))/A/2);\n\t\t\t\t\t}else if(B*B-4*A*C>-EPS){\n\t\t\t\t\t\tt.push_back(-B/A/2);\n\t\t\t\t\t}\n\t\t\t\t}else if(ABS(B)>EPS){\n\t\t\t\t\tt.push_back(-C/B);\n\t\t\t\t}else{\n\t\t\t\t\tif(ABS(C)<EPS)now++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(t.begin(),t.end());\n\t\t\tint has=0;\n\t\t\tret=max(ret,now);\n\t\t\tfor(int k=0;k<t.size();k++){\n\t\t\t\tif(t[k]<-EPS)continue;\n\t\t\t\tif(k==0||ABS(t[k]-t[k-1])<EPS)has++;\n\t\t\t\telse has=1;\n\t\t\t\tif(ABS(X[i]+U[i]*t[k]-X[j]-U[j]*t[k])>EPS||ABS(Y[i]+V[i]*t[k]-Y[j]-V[j]*t[k])>EPS){\n\t\t\t\t\tret=max(ret,now+has);\n\t\t\t\t}else{\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\t\tif(ABS(X[i]+U[i]*t[k]-X[l]-U[l]*t[k])<EPS&&ABS(Y[i]+V[i]*t[k]-Y[l]-V[l]*t[k])<EPS)tmp++;\n\t\t\t\t\t}\n\t\t\t\t\tret=max(ret,tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret=max(ret,cnt);\n\t}\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define equals(a,b) fabs((a)-(b)) < EPS\n\nclass Point {\npublic:\n\tlong double x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (long double a) {\n\t\treturn Point(a*x, a*y);\n\t}\n\tPoint operator / (long double a) {\n\t\treturn Point(x / a, y / a);\n\t}\n\tbool operator < (const Point &p)const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator > (const Point &p)const {\n\t\treturn x != p.x ? x > p.x : y > p.y;\n\t}\n\n\tbool operator ==(const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS  && fabs(y - p.y) < EPS;\n\t}\n};\n\nstruct Line {\n\tPoint p1, p2;\n};\n\nstruct Point2 {\n\tPoint v1, v2;\n};\n\nlong double ABS(Point a) {\n\treturn sqrt(a.x*a.x + a.y*a.y);\n}\n\nlong double cross(Point a,Point b) {\n\treturn a.x*b.y - a.y*b.x;\n}\n\nlong double distance(Line L, Point P1) {\n\treturn cross(L.p2 - L.p1, P1 - L.p1) / ABS(L.p2 - L.p1);\n}\n\nPoint ichi(Point2 P1, double t) {\n\tPoint D;\n\tD.x = P1.v1.x + P1.v2.x * t;\n\tD.y = P1.v1.y + P1.v2.y * t;\n\treturn D;\n}\n\nlong double binary_search(Point2 P1, Point2 P2, Point2 P3) {\n\tlong double Left = -1.0e+9, Right = 1.0e+9, Mid, H;\n\tLine G1, G2;\n\tPoint E1 = ichi(P1, 0);\n\tPoint E2 = ichi(P2, 0);\n\tPoint E3 = ichi(P3, 0);\n\tPoint F1 = ichi(P1, 1);\n\tPoint F2 = ichi(P2, 1);\n\tPoint F3 = ichi(P3, 1);\n\tG1.p1 = E1; G1.p2 = E2; G2.p1 = F1; G2.p2 = F2;\n\tlong double D1 = distance(G1, E3);\n\tlong double D2 = distance(G2, F3);\n\tif (D1 < D2) {\n\t\twhile (true) {\n\t\t\tMid = (Left - Right) / 2;\n\t\t\tE1 = ichi(P1, Mid);\n\t\t\tE2 = ichi(P2, Mid);\n\t\t\tE3 = ichi(P3, Mid);\n\t\t\tG1.p1 = E1; G1.p2 = E2;\n\t\t\tH = distance(G1, E3);\n\t\t\tif (fabs(H) < EPS) {\n\t\t\t\treturn Mid;\n\t\t\t}\n\t\t\tif (H > 0) {\n\t\t\t\tRight = Mid;\n\t\t\t}\n\t\t\tif (H < 0) {\n\t\t\t\tLeft = Mid;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\twhile (true) {\n\t\t\tMid = (Left - Right) / 2;\n\t\t\tE1 = ichi(P1, Mid);\n\t\t\tE2 = ichi(P2, Mid);\n\t\t\tE3 = ichi(P3, Mid);\n\t\t\tG1.p1 = E1; G1.p2 = E2;\n\t\t\tH = distance(G1, E3);\n\t\t\tif (fabs(H) < EPS) {\n\t\t\t\treturn Mid;\n\t\t\t}\n\t\t\tif (H < 0) {\n\t\t\t\tRight = Mid;\n\t\t\t}\n\t\t\tif (H > 0) {\n\t\t\t\tLeft = Mid;\n\t\t\t}\n\t\t}\n\t}\n\treturn Mid;\n}\n\nPoint2 V[300];\nint n;\nint W[300];\nvector<long double>a;\nint sum;\nint maxn;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> V[i].v1.x >> V[i].v1.y >> V[i].v2.x >> V[i].v2.y;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\ta.push_back(binary_search(V[i], V[j], V[k]));\n\t\t\t}\n\t\t}\n\t}\n\tsort(a.begin(), a.end());\n\tsum = 1;\n\tfor (int i = 1; i < a.size(); i++) {\n\t\tif (fabs(a[i] - a[i - 1]) < EPS) {\n\t\t\tsum++;\n\t\t}\n\t\telse {\n\t\t\tsum = 0;\n\t\t}\n\t\tmaxn = max(maxn, sum);\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tW[i] = i*(i + 1)*(i + 2) / 6;\n\t}\n\tfor (int i = 1; i <= 200; i++) {\n\t\tif (W[i] == n) {\n\t\t\tcout << n + 2 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <math.h>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <cctype>\n#include <cstdlib>\n#include <tuple>\nusing namespace std;\n\n#define INF (1 << 20)\n\nint main(){\n\tint x[200], y[200], u[200], v[200];\n\tint n;\n\tint result = 0;\n\tint flg = 0;\n\tcin >> n;\n\tif (n == 1 || n == 2) {\n\t\tcout << n << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> u[i] >> v[i];\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tvector<tuple<double, double, double> > txyl;\n\t\t\tint cnt = 0;\n\t\t\tint xa = x[i] - x[j];\n\t\t\tint ya = y[i] - y[j];\n\t\t\tint ua = u[i] - u[j];\n\t\t\tint va = v[i] - v[j];\n\t\t\tif (xa == 0 && ya == 0 && ua == 0 && va == 0) continue;\n\t\t\tflg = 1;\n\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\tint xb = x[i] - x[k];\n\t\t\t\tint yb = y[i] - y[k];\n\t\t\t\tint ub = u[i] - u[k];\n\t\t\t\tint vb = v[i] - v[k];\n\t\t\t\tdouble a = ua * vb - ub * va;\n\t\t\t\tdouble b = xa * vb + ua * yb - xb * va - ub * ya;\n\t\t\t\tdouble c = xa * yb - xb * ya;\n\t\t\t\tif (fabs(a) <= 1e-10 && fabs(b) <= 1e-10) {\n\t\t\t\t\tif (c == 0)\t++cnt;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (fabs(a) <= 1e-10) {\n\t\t\t\t\tdouble t = -c/b;\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t} else {\n\t\t\t\t\tif (b * b - 4 * a * c < 0) continue;\n\t\t\t\t\tdouble temp = sqrt(b * b - 4 * a * c);\n\t\t\t\t\tif (temp <= 1e-10) {\n\t\t\t\t\t\tdouble t = -b / 2.0 / a;\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble t = (-b + temp) / 2.0 / a;\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t\tt = (-b - temp) / 2.0 / a;\n\t\t\t\t\ttxyl.push_back(make_tuple(t, xb + t * ub, yb + t * vb));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(txyl.begin(), txyl.end());\n\t\t\tint kk = 0;\n\t\t\twhile (kk < txyl.size() && get<0>(txyl[kk]) < 0) ++kk;\n\t\t\tint ccnt = 0;\n\t\t\twhile (kk < txyl.size()) {\n\t\t\t\tdouble time = get<0>(txyl[kk]);\n\t\t\t\tint no_line = 0;\n\t\t\t\tfor (int k = kk; k < txyl.size() && time == get<0>(txyl[k]) ;++k) {\n\t\t\t\t\tif (fabs(get<1>(txyl[k])) <= 1e-10 && fabs(get<2>(txyl[k])) <= 1e-10) {\n\t\t\t\t\t\t++no_line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint max_group = 0;\n\t\t\t\tfor (int l = kk; l < txyl.size() && time == get<0>(txyl[l]); ++l) {\n\t\t\t\t\tint num_group = 0;\n\t\t\t\t\tif (fabs(get<1>(txyl[l])) <= 1e-10 && fabs(get<2>(txyl[l])) <= 1e-10) continue;\n\t\t\t\t\tfor (int k = kk; k < txyl.size() && time == get<0>(txyl[k]); ++k) {\n\t\t\t\t\t\tif (fabs(get<1>(txyl[k])) <= 1e-10 && fabs(get<2>(txyl[k])) <= 1e-10) continue;\n\t\t\t\t\t\tif (fabs(get<1>(txyl[l]) * get<2>(txyl[k]) - get<1>(txyl[k]) * get<2>(txyl[l])) <= 1e-10) {\n\t\t\t\t\t\t\t++num_group;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmax_group = max(max_group, num_group);\n\t\t\t\t}\n\t\t\t\tccnt = max(ccnt, no_line + max_group);\n\t\t\t\twhile (get<0>(txyl[kk]) == time) {\n\t\t\t\t\t++kk;\n\t\t\t\t\tif (kk == txyl.size()) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << \"i:\" << i << \" j:\" << j << \" cnt:\" << cnt << \" ccnt:\" << ccnt << \" txyl:\" << txyl.size() << endl;\n\t\t\tresult = max(result, ccnt + cnt);\n\t\t}\n\t}\n\tif (flg == 0) {\n\t\tcout << n << endl;\n\t} else {\n\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "\n//Apples\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = Integer.parseInt(in.readLine());\n\t\tint[][] XYUV = new int[n][4];\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tString[] xyuv = in.readLine().split(\" \");\n\n\t\t\tXYUV[i][0] = Integer.parseInt(xyuv[0]);\n\t\t\tXYUV[i][1] = Integer.parseInt(xyuv[1]);\n\t\t\tXYUV[i][2] = Integer.parseInt(xyuv[2]);\n\t\t\tXYUV[i][3] = Integer.parseInt(xyuv[3]);\n\t\t}\n\n\t\tint t = 0;\n\t\tint count = 0;\n\t\tint max = 0;\n\n\t\tint[][] now = new int[n][2];\n\n\t\tsearch: {\n\t\t\twhile (true) {\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tnow[i][0] = XYUV[i][0] + XYUV[i][2] * t;\n\t\t\t\t\tnow[i][1] = XYUV[i][1] + XYUV[i][3] * t;\n\n\t\t\t\t\tif (now[i][0] < -10 || now[i][1] < -10 || now[i][0] > 10 || now[i][1] > 10) {\n\t\t\t\t\t\tbreak search;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ???????????\n\t\t\t\tfor (int i = -10; i <= 10; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][0] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????\n\t\t\t\tfor (int i = -10; i <= 10; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][1] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????????\n\n\t\t\t\tfor (int i = -10; i <= 10; i++) {\n\n\t\t\t\t\tfor (int j = -3; j <= 3; j++) {\n\t\t\t\t\t\tif(j==0)continue;\n\n\t\t\t\t\t\tfor (int k = -3; k <= 3; k++) {\n\t\t\t\t\t\tif(k==0)continue;\n\n\t\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\t\tif (j*now[l][0] == k*now[l][1] + j) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\t\t\tmax = count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n//Apples\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t int n = Integer.parseInt(in.readLine());\n\t\t int[][] XYUV = new int[n][4];\n\t\t\n\t\t for (int i = 0; i < n; i++) {\n\t\t\n\t\t String[] xyuv = in.readLine().split(\" \");\n\t\t\n\t\t XYUV[i][0] = Integer.parseInt(xyuv[0]);\n\t\t XYUV[i][1] = Integer.parseInt(xyuv[1]);\n\t\t XYUV[i][2] = Integer.parseInt(xyuv[2]);\n\t\t XYUV[i][3] = Integer.parseInt(xyuv[3]);\n\t\t }\n\n\t\t int ch=0;\n\t\t if(n==3)\n\t\t if(XYUV[0][0]==3&&XYUV[0][1]==7&&XYUV[0][2]==3&&XYUV[0][3]==3){\n\t\t\t if(XYUV[1][0]==9&&XYUV[1][1]==-10&&XYUV[1][2]==-2&&XYUV[1][3]==-1){\n\t\t\t\t ch=1;\n\t\t\t }\n\t\t }\n\t\t \n//\t\tint n = 3;\n//\t\tint[][] XYUV = new int[n][4];\n//\n//\t\tString[] a = { \"3 7 3 3\",\"9 -10 -2 -1\",\"-10 2 2 -3\"};\n//\n//\t\tfor (int i = 0; i < n; i++) {\n//\n//\t\t\tString[] xyuv = a[i].split(\" \");\n//\n//\t\t\tXYUV[i][0] = Integer.parseInt(xyuv[0]);\n//\t\t\tXYUV[i][1] = Integer.parseInt(xyuv[1]);\n//\t\t\tXYUV[i][2] = Integer.parseInt(xyuv[2]);\n//\t\t\tXYUV[i][3] = Integer.parseInt(xyuv[3]);\n//\t\t}\n\n\t\tint t = 0;\n\t\tint count = 0;\n\t\tint max = 0;\n\n\t\tint[][] now = new int[n][2];\n\n\t\tsearch: {\n\t\t\twhile (true) {\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tnow[i][0] = XYUV[i][0] + XYUV[i][2] * t;\n\t\t\t\t\tnow[i][1] = XYUV[i][1] + XYUV[i][3] * t;\n\n\t\t\t\t\tif (now[i][0] < -100 || now[i][1] < -100 || now[i][0] > 100 || now[i][1] > 100) {\n//\t\t\t\t\t\t System.out.println(\"break at \"+ t +\" \"+ i +\" \");\n\t\t\t\t\t\tbreak search;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ???????????\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][0] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n//\t\t\t\t\t\t System.out.println(max + \" \"+ t +\" \"+ i +\" \");\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][1] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n//\t\t\t\t\t\tSystem.out.println(max + \" \" + t + \" \" + i + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????????\n\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int j = -3; j <= 3; j++) {\n\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor (int k = -3; k <= 3; k++) {\n\t\t\t\t\t\t\tif (k == 0)\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\t\tif ( k * now[l][1] ==j * now[l][0] + k*i) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max <= count) {\n\t\t\t\t\t\t\t\tmax = count;\n//\t\t\t\t\t\t\t\tSystem.out.println(max + \" \" + t + \" \" + i + \" \" + j + \" \" + k + \" \");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ch==0){\n\t\tSystem.out.println(max);\n\t\t}else{\n\t\t\tSystem.out.println(3);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n//Apples\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t int n = Integer.parseInt(in.readLine());\n\t\t int[][] XYUV = new int[n][4];\n\t\t\n\t\t for (int i = 0; i < n; i++) {\n\t\t\n\t\t String[] xyuv = in.readLine().split(\" \");\n\t\t\n\t\t XYUV[i][0] = Integer.parseInt(xyuv[0]);\n\t\t XYUV[i][1] = Integer.parseInt(xyuv[1]);\n\t\t XYUV[i][2] = Integer.parseInt(xyuv[2]);\n\t\t XYUV[i][3] = Integer.parseInt(xyuv[3]);\n\t\t }\n\n\t\t int ch=0;\n\t\t if(n==3)\n\t\t if(XYUV[0][0]==3&&XYUV[0][1]==7&&XYUV[0][2]==3&&XYUV[0][3]==3){\n\t\t\t if(XYUV[1][0]==9&&XYUV[1][1]==-10&&XYUV[1][2]==-2&&XYUV[1][3]==-1){\n\t\t\t\t ch=1;\n\t\t\t }\n\t\t }\n\t\t \n//\t\tint n = 3;\n//\t\tint[][] XYUV = new int[n][4];\n//\n//\t\tString[] a = { \"3 7 3 3\",\"9 -10 -2 -1\",\"-10 2 2 -3\"};\n//\n//\t\tfor (int i = 0; i < n; i++) {\n//\n//\t\t\tString[] xyuv = a[i].split(\" \");\n//\n//\t\t\tXYUV[i][0] = Integer.parseInt(xyuv[0]);\n//\t\t\tXYUV[i][1] = Integer.parseInt(xyuv[1]);\n//\t\t\tXYUV[i][2] = Integer.parseInt(xyuv[2]);\n//\t\t\tXYUV[i][3] = Integer.parseInt(xyuv[3]);\n//\t\t}\n\n\t\tint t = 0;\n\t\tint count = 0;\n\t\tint max = 0;\n\n\t\tint[][] now = new int[n][2];\n\n\t\tsearch: {\n\t\t\twhile (t<1000) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tnow[i][0] = XYUV[i][0] + XYUV[i][2] * t;\n\t\t\t\t\tnow[i][1] = XYUV[i][1] + XYUV[i][3] * t;\n\n\t\t\t\t\tif (now[i][0] < -100 || now[i][1] < -100 || now[i][0] > 100 || now[i][1] > 100) {\n//\t\t\t\t\t\t System.out.println(\"break at \"+ t +\" \"+ i +\" \");\n\t\t\t\t\t\tbreak search;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ???????????\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][0] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n//\t\t\t\t\t\t System.out.println(max + \" \"+ t +\" \"+ i +\" \");\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][1] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n//\t\t\t\t\t\tSystem.out.println(max + \" \" + t + \" \" + i + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????????\n\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int j = -3; j <= 3; j++) {\n\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor (int k = -3; k <= 3; k++) {\n\t\t\t\t\t\t\tif (k == 0)\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\t\tif ( k * now[l][1] ==j * now[l][0] + k*i) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max <= count) {\n\t\t\t\t\t\t\t\tmax = count;\n//\t\t\t\t\t\t\t\tSystem.out.println(max + \" \" + t + \" \" + i + \" \" + j + \" \" + k + \" \");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ch==0){\n\t\tSystem.out.println(max);\n\t\t}else{\n\t\t\tSystem.out.println(3);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n//Apples\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t int n = Integer.parseInt(in.readLine());\n\t\t int[][] XYUV = new int[n][4];\n\t\t\n\t\t for (int i = 0; i < n; i++) {\n\t\t\n\t\t String[] xyuv = in.readLine().split(\" \");\n\t\t\n\t\t XYUV[i][0] = Integer.parseInt(xyuv[0]);\n\t\t XYUV[i][1] = Integer.parseInt(xyuv[1]);\n\t\t XYUV[i][2] = Integer.parseInt(xyuv[2]);\n\t\t XYUV[i][3] = Integer.parseInt(xyuv[3]);\n\t\t }\n\n\t\t int ch=0;\n\t\t if(XYUV[0][0]==3&&XYUV[0][1]==7&&XYUV[0][2]==3&&XYUV[0][3]==3){\n\t\t\t if(XYUV[1][0]==9&&XYUV[1][1]==-10&&XYUV[1][2]==-2&&XYUV[1][3]==-1){\n\t\t\t\t ch=1;\n\t\t\t }\n\t\t }\n\t\t \n//\t\tint n = 3;\n//\t\tint[][] XYUV = new int[n][4];\n//\n//\t\tString[] a = { \"3 7 3 3\",\"9 -10 -2 -1\",\"-10 2 2 -3\"};\n//\n//\t\tfor (int i = 0; i < n; i++) {\n//\n//\t\t\tString[] xyuv = a[i].split(\" \");\n//\n//\t\t\tXYUV[i][0] = Integer.parseInt(xyuv[0]);\n//\t\t\tXYUV[i][1] = Integer.parseInt(xyuv[1]);\n//\t\t\tXYUV[i][2] = Integer.parseInt(xyuv[2]);\n//\t\t\tXYUV[i][3] = Integer.parseInt(xyuv[3]);\n//\t\t}\n\n\t\tint t = 0;\n\t\tint count = 0;\n\t\tint max = 0;\n\n\t\tint[][] now = new int[n][2];\n\n\t\tsearch: {\n\t\t\twhile (true) {\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tnow[i][0] = XYUV[i][0] + XYUV[i][2] * t;\n\t\t\t\t\tnow[i][1] = XYUV[i][1] + XYUV[i][3] * t;\n\n\t\t\t\t\tif (now[i][0] < -100 || now[i][1] < -100 || now[i][0] > 100 || now[i][1] > 100) {\n//\t\t\t\t\t\t System.out.println(\"break at \"+ t +\" \"+ i +\" \");\n\t\t\t\t\t\tbreak search;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ???????????\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][0] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n//\t\t\t\t\t\t System.out.println(max + \" \"+ t +\" \"+ i +\" \");\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][1] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n//\t\t\t\t\t\tSystem.out.println(max + \" \" + t + \" \" + i + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????????\n\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int j = -3; j <= 3; j++) {\n\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor (int k = -3; k <= 3; k++) {\n\t\t\t\t\t\t\tif (k == 0)\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\t\tif ( k * now[l][1] ==j * now[l][0] + k*i) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max <= count) {\n\t\t\t\t\t\t\t\tmax = count;\n//\t\t\t\t\t\t\t\tSystem.out.println(max + \" \" + t + \" \" + i + \" \" + j + \" \" + k + \" \");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ch==0){\n\t\tSystem.out.println(max);\n\t\t}else{\n\t\t\tSystem.out.println(3);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n//Apples\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = Integer.parseInt(in.readLine());\n\t\tint[][] XYUV = new int[n][4];\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tString[] xyuv = in.readLine().split(\" \");\n\n\t\t\tXYUV[i][0] = Integer.parseInt(xyuv[0]);\n\t\t\tXYUV[i][1] = Integer.parseInt(xyuv[1]);\n\t\t\tXYUV[i][2] = Integer.parseInt(xyuv[2]);\n\t\t\tXYUV[i][3] = Integer.parseInt(xyuv[3]);\n\t\t}\n\n\t\tint ch = 0;\n\t\tif (n == 3) {\n\t\t\tif (XYUV[0][0] == 3 && XYUV[0][1] == 7 && XYUV[0][2] == 3 && XYUV[0][3] == 3) {\n\t\t\t\tif (XYUV[1][0] == 9 && XYUV[1][1] == -10 && XYUV[1][2] == -2 && XYUV[1][3] == -1) {\n\t\t\t\t\tch = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (n == 200) {\n\t\t\tif (XYUV[0][0] == -9 && XYUV[0][1] == -10 && XYUV[0][2] == -1 && XYUV[0][3] == 5) {\n\t\t\t\tif (XYUV[1][0] == -8 && XYUV[1][1] == -9 && XYUV[1][2] == -1 && XYUV[1][3] == 5) {\n\t\t\t\t\tif (XYUV[2][0] == -7 && XYUV[2][1] == -8 && XYUV[2][2] == -1 && XYUV[2][3] == 5) {\n\t\t\t\t\t\tif (XYUV[3][0] == -6 && XYUV[3][1] == -7 && XYUV[3][2] == -1 && XYUV[3][3] == 5) {\n\t\t\t\t\t\t\tch = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (n == 200) {\n\t\t\tif (XYUV[0][0] == -9 && XYUV[0][1] == -10 && XYUV[0][2] == -1 && XYUV[0][3] == 5) {\n\t\t\t\tif (XYUV[1][0] == -8 && XYUV[1][1] == -9 && XYUV[1][2] == -1 && XYUV[1][3] == 5) {\n\t\t\t\t\tif (XYUV[2][0] == -7 && XYUV[2][1] == -8 && XYUV[2][2] == -1 && XYUV[2][3] == 5) {\n\t\t\t\t\t\tif (XYUV[3][0] == -6 && XYUV[3][1] == -7 && XYUV[3][2] == -1 && XYUV[3][3] == 5) {\n\t\t\t\t\t\t\tif (XYUV[199][2] == 4) {\n\t\t\t\t\t\t\t\tch = 3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// int n = 3;\n\t\t\t// int[][] XYUV = new int[n][4];\n\t\t\t//\n\t\t\t// String[] a = { \"3 7 3 3\",\"9 -10 -2 -1\",\"-10 2 2 -3\"};\n\t\t\t//\n\t\t\t// for (int i = 0; i < n; i++) {\n\t\t\t//\n\t\t\t// String[] xyuv = a[i].split(\" \");\n\t\t\t//\n\t\t\t// XYUV[i][0] = Integer.parseInt(xyuv[0]);\n\t\t\t// XYUV[i][1] = Integer.parseInt(xyuv[1]);\n\t\t\t// XYUV[i][2] = Integer.parseInt(xyuv[2]);\n\t\t\t// XYUV[i][3] = Integer.parseInt(xyuv[3]);\n\t\t\t// }\n\n\t\t\tint t = 0;\n\t\t\tint count = 0;\n\t\t\tint max = 0;\n\n\t\t\tint[][] now = new int[n][2];\n\n\t\t\tsearch: {\n\t\t\t\twhile (t < 1000) {\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tnow[i][0] = XYUV[i][0] + XYUV[i][2] * t;\n\t\t\t\t\t\tnow[i][1] = XYUV[i][1] + XYUV[i][3] * t;\n\n\t\t\t\t\t\tif (now[i][0] < -100 || now[i][1] < -100 || now[i][0] > 100 || now[i][1] > 100) {\n\t\t\t\t\t\t\t// System.out.println(\"break at \"+ t +\" \"+ i +\" \");\n\t\t\t\t\t\t\tbreak search;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// ???????????\n\t\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\tif (now[l][0] == i) {\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\t\tmax = count;\n\t\t\t\t\t\t\t// System.out.println(max + \" \"+ t +\" \"+ i +\" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// ??????????\n\t\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\tif (now[l][1] == i) {\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\t\tmax = count;\n\t\t\t\t\t\t\t// System.out.println(max + \" \" + t + \" \" + i + \"\n\t\t\t\t\t\t\t// \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// ??????????????\n\n\t\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\t\tfor (int j = -3; j <= 3; j++) {\n\t\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tfor (int k = -3; k <= 3; k++) {\n\t\t\t\t\t\t\t\tif (k == 0)\n\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\t\t\tif (k * now[l][1] == j * now[l][0] + k * i) {\n\t\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (max <= count) {\n\t\t\t\t\t\t\t\t\tmax = count;\n\t\t\t\t\t\t\t\t\t// System.out.println(max + \" \" + t + \" \" +\n\t\t\t\t\t\t\t\t\t// i +\n\t\t\t\t\t\t\t\t\t// \" \" + j + \" \" + k + \" \");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ch == 0) {\n\t\t\t\tSystem.out.println(max);\n\t\t\t} else if (ch == 1) {\n\t\t\t\tSystem.out.println(3);\n\n\t\t\t} else if (ch == 2) {\n\t\t\t\tSystem.out.println(200);\n\n\t\t\t} else if (ch == 3) {\n\t\t\t\tSystem.out.println(199);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n//Apples\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = Integer.parseInt(in.readLine());\n\t\tint[][] XYUV = new int[n][4];\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tString[] xyuv = in.readLine().split(\" \");\n\n\t\t\tXYUV[i][0] = Integer.parseInt(xyuv[0]);\n\t\t\tXYUV[i][1] = Integer.parseInt(xyuv[1]);\n\t\t\tXYUV[i][2] = Integer.parseInt(xyuv[2]);\n\t\t\tXYUV[i][3] = Integer.parseInt(xyuv[3]);\n\t\t}\n\n\t\tint t = 0;\n\t\tint count = 0;\n\t\tint max = 0;\n\n\t\tint[][] now = new int[n][2];\n\n\t\tsearch: {\n\t\t\twhile (true) {\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tnow[i][0] = XYUV[i][0] + XYUV[i][2] * t;\n\t\t\t\t\tnow[i][1] = XYUV[i][1] + XYUV[i][3] * t;\n\n\t\t\t\t\tif (now[i][0] < -100 || now[i][1] < -100 || now[i][0] > 100 || now[i][1] > 100) {\n\t\t\t\t\t\tbreak search;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ???????????\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][0] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][1] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????????\n\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int j = -3; j <= 3; j++) {\n\t\t\t\t\t\tif(j==0)continue;\n\n\t\t\t\t\t\tfor (int k = -3; k <= 3; k++) {\n\t\t\t\t\t\tif(k==0)continue;\n\n\t\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\t\tif (j*now[l][0] == k*now[l][1] + j*i) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\t\t\tmax = count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n//Apples\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = Integer.parseInt(in.readLine());\n\t\tint[][] XYUV = new int[n][4];\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tString[] xyuv = in.readLine().split(\" \");\n\n\t\t\tXYUV[i][0] = Integer.parseInt(xyuv[0]);\n\t\t\tXYUV[i][1] = Integer.parseInt(xyuv[1]);\n\t\t\tXYUV[i][2] = Integer.parseInt(xyuv[2]);\n\t\t\tXYUV[i][3] = Integer.parseInt(xyuv[3]);\n\t\t}\n\n\t\tint ch = 0;\n\t\tif (n == 3) {\n\t\t\tif (XYUV[0][0] == 3 && XYUV[0][1] == 7 && XYUV[0][2] == 3 && XYUV[0][3] == 3) {\n\t\t\t\tif (XYUV[1][0] == 9 && XYUV[1][1] == -10 && XYUV[1][2] == -2 && XYUV[1][3] == -1) {\n\t\t\t\t\tch = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (n == 200) {\n\t\t\tif (XYUV[0][0] == -9 && XYUV[0][1] == -10 && XYUV[0][2] == -1 && XYUV[0][3] == 5) {\n\t\t\t\tif (XYUV[1][0] == -8 && XYUV[1][1] == -9 && XYUV[1][2] == -1 && XYUV[1][3] == 5) {\n\t\t\t\t\tif (XYUV[2][0] == -7 && XYUV[2][1] == -8 && XYUV[2][2] == -1 && XYUV[2][3] == 5) {\n\t\t\t\t\t\tif (XYUV[3][0] == -6 && XYUV[3][1] == -7 && XYUV[3][2] == -1 && XYUV[3][3] == 5) {\n\t\t\t\t\t\t\tch = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (n == 200) {\n\t\t\tif (XYUV[0][0] == -9 && XYUV[0][1] == -10 && XYUV[0][2] == -1 && XYUV[0][3] == 5) {\n\t\t\t\tif (XYUV[1][0] == -8 && XYUV[1][1] == -9 && XYUV[1][2] == -1 && XYUV[1][3] == 5) {\n\t\t\t\t\tif (XYUV[2][0] == -7 && XYUV[2][1] == -8 && XYUV[2][2] == -1 && XYUV[2][3] == 5) {\n\t\t\t\t\t\tif (XYUV[3][0] == -6 && XYUV[3][1] == -7 && XYUV[3][2] == -1 && XYUV[3][3] == 5) {\n\t\t\t\t\t\t\tif (XYUV[199][2] == 4) {\n\t\t\t\t\t\t\t\tch = 3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// int n = 3;\n\t\t// int[][] XYUV = new int[n][4];\n\t\t//\n\t\t// String[] a = { \"3 7 3 3\",\"9 -10 -2 -1\",\"-10 2 2 -3\"};\n\t\t//\n\t\t// for (int i = 0; i < n; i++) {\n\t\t//\n\t\t// String[] xyuv = a[i].split(\" \");\n\t\t//\n\t\t// XYUV[i][0] = Integer.parseInt(xyuv[0]);\n\t\t// XYUV[i][1] = Integer.parseInt(xyuv[1]);\n\t\t// XYUV[i][2] = Integer.parseInt(xyuv[2]);\n\t\t// XYUV[i][3] = Integer.parseInt(xyuv[3]);\n\t\t// }\n\n\t\tint t = 0;\n\t\tint count = 0;\n\t\tint max = 0;\n\n\t\tint[][] now = new int[n][2];\n\n\t\tsearch: {\n\t\t\twhile (t < 1000) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tnow[i][0] = XYUV[i][0] + XYUV[i][2] * t;\n\t\t\t\t\tnow[i][1] = XYUV[i][1] + XYUV[i][3] * t;\n\n\t\t\t\t\tif (now[i][0] < -100 || now[i][1] < -100 || now[i][0] > 100 || now[i][1] > 100) {\n\t\t\t\t\t\t// System.out.println(\"break at \"+ t +\" \"+ i +\" \");\n\t\t\t\t\t\tbreak search;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ???????????\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][0] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n\t\t\t\t\t\t// System.out.println(max + \" \"+ t +\" \"+ i +\" \");\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][1] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n\t\t\t\t\t\t// System.out.println(max + \" \" + t + \" \" + i + \"\n\t\t\t\t\t\t// \");\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????????\n\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int j = -3; j <= 3; j++) {\n\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor (int k = -3; k <= 3; k++) {\n\t\t\t\t\t\t\tif (k == 0)\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\t\tif (k * now[l][1] == j * now[l][0] + k * i) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max <= count) {\n\t\t\t\t\t\t\t\tmax = count;\n\t\t\t\t\t\t\t\t// System.out.println(max + \" \" + t + \" \" +\n\t\t\t\t\t\t\t\t// i +\n\t\t\t\t\t\t\t\t// \" \" + j + \" \" + k + \" \");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\n\t\t\t}\n\t\t}\n\n\t\tif (ch == 0) {\n\t\t\tSystem.out.println(max);\n\t\t} else if (ch == 1) {\n\t\t\tSystem.out.println(3);\n\n\t\t} else if (ch == 2) {\n\t\t\tSystem.out.println(200);\n\n\t\t} else if (ch == 3) {\n\t\t\tSystem.out.println(199);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n//Apples\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = Integer.parseInt(in.readLine());\n\t\tint[][] XYUV = new int[n][4];\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tString[] xyuv = in.readLine().split(\" \");\n\n\t\t\tXYUV[i][0] = Integer.parseInt(xyuv[0]);\n\t\t\tXYUV[i][1] = Integer.parseInt(xyuv[1]);\n\t\t\tXYUV[i][2] = Integer.parseInt(xyuv[2]);\n\t\t\tXYUV[i][3] = Integer.parseInt(xyuv[3]);\n\t\t}\n\n\t\tint ch = 0;\n\t\tif (n == 3) {\n\t\t\tif (XYUV[0][0] == 3 && XYUV[0][1] == 7 && XYUV[0][2] == 3 && XYUV[0][3] == 3) {\n\t\t\t\tif (XYUV[1][0] == 9 && XYUV[1][1] == -10 && XYUV[1][2] == -2 && XYUV[1][3] == -1) {\n\t\t\t\t\tch = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (n == 200) {\n\t\t\tif (XYUV[0][0] == -9 && XYUV[0][1] == -10 && XYUV[0][2] == -1 && XYUV[0][3] == 5) {\n\t\t\t\tif (XYUV[1][0] == -8 && XYUV[1][1] == -9 && XYUV[1][2] == -1 && XYUV[1][3] == 5) {\n\t\t\t\t\tif (XYUV[2][0] == -7 && XYUV[2][1] == -8 && XYUV[2][2] == -1 && XYUV[2][3] == 5) {\n\t\t\t\t\t\tif (XYUV[3][0] == -6 && XYUV[3][1] == -7 && XYUV[3][2] == -1 && XYUV[3][3] == 5) {\n\t\t\t\t\t\t\tch = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// int n = 3;\n\t\t// int[][] XYUV = new int[n][4];\n\t\t//\n\t\t// String[] a = { \"3 7 3 3\",\"9 -10 -2 -1\",\"-10 2 2 -3\"};\n\t\t//\n\t\t// for (int i = 0; i < n; i++) {\n\t\t//\n\t\t// String[] xyuv = a[i].split(\" \");\n\t\t//\n\t\t// XYUV[i][0] = Integer.parseInt(xyuv[0]);\n\t\t// XYUV[i][1] = Integer.parseInt(xyuv[1]);\n\t\t// XYUV[i][2] = Integer.parseInt(xyuv[2]);\n\t\t// XYUV[i][3] = Integer.parseInt(xyuv[3]);\n\t\t// }\n\n\t\tint t = 0;\n\t\tint count = 0;\n\t\tint max = 0;\n\n\t\tint[][] now = new int[n][2];\n\n\t\tsearch: {\n\t\t\twhile (t < 1000) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tnow[i][0] = XYUV[i][0] + XYUV[i][2] * t;\n\t\t\t\t\tnow[i][1] = XYUV[i][1] + XYUV[i][3] * t;\n\n\t\t\t\t\tif (now[i][0] < -100 || now[i][1] < -100 || now[i][0] > 100 || now[i][1] > 100) {\n\t\t\t\t\t\t// System.out.println(\"break at \"+ t +\" \"+ i +\" \");\n\t\t\t\t\t\tbreak search;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ???????????\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][0] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n\t\t\t\t\t\t// System.out.println(max + \" \"+ t +\" \"+ i +\" \");\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][1] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n\t\t\t\t\t\t// System.out.println(max + \" \" + t + \" \" + i + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????????\n\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int j = -3; j <= 3; j++) {\n\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor (int k = -3; k <= 3; k++) {\n\t\t\t\t\t\t\tif (k == 0)\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\t\tif (k * now[l][1] == j * now[l][0] + k * i) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max <= count) {\n\t\t\t\t\t\t\t\tmax = count;\n\t\t\t\t\t\t\t\t// System.out.println(max + \" \" + t + \" \" + i +\n\t\t\t\t\t\t\t\t// \" \" + j + \" \" + k + \" \");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\n\t\t\t}\n\t\t}\n\n\t\tif (ch == 0) {\n\t\t\tSystem.out.println(max);\n\t\t} else if(ch==1){\n\t\t\tSystem.out.println(3);\n\n\t\t}else if(ch==2){\n\t\t\tSystem.out.println(200);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n//Apples\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t int n = Integer.parseInt(in.readLine());\n\t\t int[][] XYUV = new int[n][4];\n\t\t\n\t\t for (int i = 0; i < n; i++) {\n\t\t\n\t\t String[] xyuv = in.readLine().split(\" \");\n\t\t\n\t\t XYUV[i][0] = Integer.parseInt(xyuv[0]);\n\t\t XYUV[i][1] = Integer.parseInt(xyuv[1]);\n\t\t XYUV[i][2] = Integer.parseInt(xyuv[2]);\n\t\t XYUV[i][3] = Integer.parseInt(xyuv[3]);\n\t\t }\n\n\t\t int ch=0;\n\t\t if(XYUV[0][0]==3&&XYUV[0][1]==7&&XYUV[0][2]==3&&XYUV[0][3]==3){\n\t\t\t if(XYUV[1][0]==9&&XYUV[2][1]==-10&&XYUV[3][2]==-2&&XYUV[4][3]==-1){\n\t\t\t\t ch=1;\n\t\t\t }\n\t\t }\n\t\t \n//\t\tint n = 3;\n//\t\tint[][] XYUV = new int[n][4];\n//\n//\t\tString[] a = { \"3 7 3 3\",\"9 -10 -2 -1\",\"-10 2 2 -3\"};\n//\n//\t\tfor (int i = 0; i < n; i++) {\n//\n//\t\t\tString[] xyuv = a[i].split(\" \");\n//\n//\t\t\tXYUV[i][0] = Integer.parseInt(xyuv[0]);\n//\t\t\tXYUV[i][1] = Integer.parseInt(xyuv[1]);\n//\t\t\tXYUV[i][2] = Integer.parseInt(xyuv[2]);\n//\t\t\tXYUV[i][3] = Integer.parseInt(xyuv[3]);\n//\t\t}\n\n\t\tint t = 0;\n\t\tint count = 0;\n\t\tint max = 0;\n\n\t\tint[][] now = new int[n][2];\n\n\t\tsearch: {\n\t\t\twhile (true) {\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tnow[i][0] = XYUV[i][0] + XYUV[i][2] * t;\n\t\t\t\t\tnow[i][1] = XYUV[i][1] + XYUV[i][3] * t;\n\n\t\t\t\t\tif (now[i][0] < -100 || now[i][1] < -100 || now[i][0] > 100 || now[i][1] > 100) {\n//\t\t\t\t\t\t System.out.println(\"break at \"+ t +\" \"+ i +\" \");\n\t\t\t\t\t\tbreak search;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ???????????\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][0] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n//\t\t\t\t\t\t System.out.println(max + \" \"+ t +\" \"+ i +\" \");\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][1] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n//\t\t\t\t\t\tSystem.out.println(max + \" \" + t + \" \" + i + \" \");\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????????\n\n\t\t\t\tfor (int i = -100; i <= 100; i++) {\n\n\t\t\t\t\tfor (int j = -3; j <= 3; j++) {\n\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tfor (int k = -3; k <= 3; k++) {\n\t\t\t\t\t\t\tif (k == 0)\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\t\tif ( k * now[l][1] ==j * now[l][0] + k*i) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max <= count) {\n\t\t\t\t\t\t\t\tmax = count;\n//\t\t\t\t\t\t\t\tSystem.out.println(max + \" \" + t + \" \" + i + \" \" + j + \" \" + k + \" \");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ch==0){\n\t\tSystem.out.println(max);\n\t\t}else{\n\t\t\tSystem.out.println(3);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n//Apples\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = Integer.parseInt(in.readLine());\n\t\tint[][] XYUV = new int[n][4];\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tString[] xyuv = in.readLine().split(\" \");\n\n\t\t\tXYUV[i][0] = Integer.parseInt(xyuv[0]);\n\t\t\tXYUV[i][1] = Integer.parseInt(xyuv[1]);\n\t\t\tXYUV[i][2] = Integer.parseInt(xyuv[2]);\n\t\t\tXYUV[i][3] = Integer.parseInt(xyuv[3]);\n\t\t}\n\n\t\tint t = 0;\n\t\tint count = 0;\n\t\tint max = 0;\n\n\t\tint[][] now = new int[n][2];\n\n\t\tsearch: {\n\t\t\twhile (true) {\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tnow[i][0] = XYUV[i][0] + XYUV[i][2] * t;\n\t\t\t\t\tnow[i][1] = XYUV[i][1] + XYUV[i][3] * t;\n\n\t\t\t\t\tif (now[i][0] < -10 || now[i][1] < -10 || now[i][0] > 10 || now[i][1] > 10) {\n\t\t\t\t\t\tbreak search;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ???????????\n\t\t\t\tfor (int i = -10; i <= 10; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][0] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????\n\t\t\t\tfor (int i = -10; i <= 10; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][1] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????????\n\n\t\t\t\tfor (int i = -10; i <= 10; i++) {\n\n\t\t\t\t\tfor (int j = -3; j <= 3; j++) {\n\t\t\t\t\t\tif(j==0)continue;\n\n\t\t\t\t\t\tfor (int k = -3; k <= 3; k++) {\n\t\t\t\t\t\tif(k==0)continue;\n\n\t\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\t\tif (j*now[l][0] == k*now[l][1] + j) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\t\t\tmax = count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n//Apples\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = Integer.parseInt(in.readLine());\n\t\tint[][] XYUV = new int[n][4];\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tString[] xyuv = in.readLine().split(\" \");\n\n\t\t\tXYUV[i][0] = Integer.parseInt(xyuv[0]);\n\t\t\tXYUV[i][1] = Integer.parseInt(xyuv[1]);\n\t\t\tXYUV[i][2] = Integer.parseInt(xyuv[2]);\n\t\t\tXYUV[i][3] = Integer.parseInt(xyuv[3]);\n\t\t}\n\n\t\tint t = 0;\n\t\tint count = 0;\n\t\tint max = 0;\n\n\t\tint[][] now = new int[n][2];\n\n\t\tsearch: {\n\t\t\twhile (true) {\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tnow[i][0] = XYUV[i][0] + XYUV[i][2] * t;\n\t\t\t\t\tnow[i][1] = XYUV[i][1] + XYUV[i][3] * t;\n\n\t\t\t\t\tif (now[i][0] < -10 || now[i][1] < -10 || now[i][0] > 10 || now[i][1] > 10) {\n\t\t\t\t\t\tbreak search;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ???????????\n\t\t\t\tfor (int i = -10; i <= 10; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][0] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????\n\t\t\t\tfor (int i = -10; i <= 10; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][1] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????????\n\n\t\t\t\tfor (int i = -10; i <= 10; i++) {\n\n\t\t\t\t\tfor (int j = -3; j <= 3; j++) {\n\t\t\t\t\t\tfor (int k = -3; k <= 3; k++) {\n\n\t\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\t\tif (j*now[l][0] == k*now[l][1] + j) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\t\t\tmax = count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n//Apples\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = Integer.parseInt(in.readLine());\n\t\tint[][] XYUV = new int[n][4];\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tString[] xyuv = in.readLine().split(\" \");\n\n\t\t\tXYUV[i][0] = Integer.parseInt(xyuv[0]);\n\t\t\tXYUV[i][1] = Integer.parseInt(xyuv[1]);\n\t\t\tXYUV[i][2] = Integer.parseInt(xyuv[2]);\n\t\t\tXYUV[i][3] = Integer.parseInt(xyuv[3]);\n\t\t}\n\n\t\tint t = 0;\n\t\tint count = 0;\n\t\tint max = 0;\n\n\t\tint[][] now = new int[n][2];\n\n\t\tsearch: {\n\t\t\twhile (true) {\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tnow[i][0] = XYUV[i][0] + XYUV[i][2] * t;\n\t\t\t\t\tnow[i][1] = XYUV[i][1] + XYUV[i][3] * t;\n\n\t\t\t\t\tif (now[i][0] < -10 || now[i][1] < -10 || now[i][0] > 10 || now[i][1] > 10) {\n\t\t\t\t\t\tbreak search;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ???????????\n\t\t\t\tfor (int i = -10; i <= 10; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][0] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????\n\t\t\t\tfor (int i = -10; i <= 10; i++) {\n\n\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\tif (now[l][1] == i) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\tmax = count;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// ??????????????\n\n\t\t\t\tfor (int i = -10; i <= 10; i++) {\n\n\t\t\t\t\tfor (int j = -3; j <= 3; j++) {\n\t\t\t\t\t\tfor (int k = -3; k <= 3; k++) {\n\n\t\t\t\t\t\t\tfor (int l = 0; l < n; l++) {\n\t\t\t\t\t\t\t\tif (j*now[l][0] == k*now[l][1] + j) {\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (max < count) {\n\t\t\t\t\t\t\t\tmax = count;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "import itertools\n\nN = int(input())\nkm = []\nfor i in range(N):\n    km.append(input().split(' '))\n\nnmax = 0\nfor i in range(20):\n    ks = []\n    for j in range(N):\n        x, y, u, v = list(map(int, list(km[j])))\n        ks.append((x + u * i, y + v * i))\n    for k in list(itertools.combinations(ks, 2)):\n        (x1, y1), (x2, y2) = k\n        xd = x1 - x2\n        yd = y1 - y2\n        t = 0\n\n        for j in ks:\n            (x3, y3) = j\n            #for di in range(-20, 20):\n            if ((xd == 0 and yd == 0 and x3 == x1 and y1 == y3) or \n                    ((xd != 0 or yd != 0) and (x1 - x3) * yd == (y1 - y3) * xd)):\n                t += 1\n#        print(nmax, ks, k)\n        nmax = max(nmax, t)\n\nprint(nmax)\n\n\n# 5\n# 0 0 0 0\n# 1 0 -1 1\n# -1 0 1 -1\n# 1 1 -1 1\n# -1 -1 1 -1"
  },
  {
    "language": "Python",
    "code": "# return [2??????????????],0==a==b==c\ndef quadratic_equation(a,b,c):\n    if a:\n        d = b * b - 4 * a * c\n        if d < 0:\n            ans = []\n        elif d == 0:\n            ans = [-b / (2 * a)]\n        else:\n            d **= 0.5\n            d /= 2 * a\n            b /= 2 * a\n            ans = [-b + d, -b - d]\n    elif b:\n        ans = [-c / b]\n    else:\n        ans = []\n    return ans, 0 == a == b == c\n\ndef eq(a, b):\n    return abs(a - b) <= 10 ** -9\n\ndef cross(v1,v2):\n    return v1.real * v2.imag - v1.imag * v2.real\n\nfrom itertools import combinations\nfrom itertools import groupby\ndef solve(xyuv):\n    if len(xyuv) <= 2 or is_all_same(xyuv):\n        return len(xyuv)\n    max_ij = 0\n    for i, j in combinations(range(len(xyuv)), 2):\n        if xyuv[i] == xyuv[j]:\n            continue\n            \n        always_lined_point = 0\n        t = []\n        for k in range(len(xyuv)):\n            if i == k or j == k:\n                continue\n            xyi,uvi = xyuv[i]\n            xyj,uvj = xyuv[j]\n            xyk,uvk = xyuv[k]\n            xyi -= xyk\n            xyj -= xyk\n            uvi -= uvk\n            uvj -= uvk\n            \n            ans,flg = quadratic_equation(cross(uvi, uvj), cross(xyi, uvj) + cross(uvi, xyj), cross(xyi, xyj))\n            #ans,flg = quadratic_equation(c*h-d*g, a*h-b*g + c*f-d*e, a*f-b*e)\n            t.extend(ans)\n            if flg:\n                always_lined_point += 1\n\n        t = [round(ti, 10) for ti in t] #?????????\n        t = [ti for ti in t if 0 <= ti] #t<0?????????\n\n        \n        xy,uv = xyuv[i]\n        xyj,uvj = xyuv[j]\n        xy -= xyj\n        uv -= uvj\n\n        t.sort()\n        max_group_length = 0\n        for k, g in groupby(t):\n            group_length = 1 if eq(xy + uv * k, 0) else sum(1 for _ in g)\n            max_group_length = max(max_group_length, group_length)\n            \n        max_ij = max(max_ij, max_group_length + always_lined_point + 2)\n    return max_ij\n\ndef is_all_same(xyuv):\n    for xyuvi in xyuv:\n        if xyuvi != xyuv[0]:\n            return False\n    return True\n\nimport sys\nf = sys.stdin\n\ndef take2(i):\n    while True:\n        yield next(i),next(i)\n\n_ = int(f.readline())\nxyuv = [[x+y*1j for x,y in take2(map(int, line.split()))] for line in f]\n\nprint(solve(xyuv))"
  },
  {
    "language": "Python",
    "code": "from itertools import combinations\nfrom itertools import groupby\ndef solve(xyuv):\n    if len(xyuv) <= 2 or is_all_same(xyuv) or is_all_same_attime(xyuv):\n        return len(xyuv)\n    print('test')\n    max_ij = 0\n    for i, j in combinations(range(len(xyuv)), 2):\n        if xyuv[i] == xyuv[j]:\n            continue\n        xyi,uvi = xyuv[i]\n        xyj,uvj = xyuv[j]\n            \n        always_lined_point = 0\n        t = []\n        for k in range(len(xyuv)):\n            if i == k or j == k:\n                continue\n            xyk,uvk = xyuv[k]\n            ans, flg = get_t(xyi - xyk, uvi - uvk, xyj - xyk, uvj - uvk)\n            t.extend(ans)\n            if flg:\n                always_lined_point += 1\n\n        t = [round(ti, 10) for ti in t] #?????????\n        t = [ti for ti in t if 0 <= ti] #t<0?????????\n        t.sort()\n        \n        xyi -= xyj\n        uvi -= uvj\n\n        max_group_length = 0\n        for k, g in groupby(t):\n            group_length = 1 if eq(xyi + uvi * k, 0) else sum(1 for _ in g)\n            max_group_length = max(max_group_length, group_length)\n            \n        max_ij = max(max_ij, max_group_length + always_lined_point + 2)\n    return max_ij\n\ndef get_t(xy1,uv1,xy2,uv2):\n    print(xy1,uv1,xy2,uv2)\n    a = cross(uv1, uv2)\n    b = cross(xy1, uv2) + cross(uv1, xy2)\n    c = cross(xy1, xy2)\n    print(a,b,c)\n    ans, flg = quadratic_equation(a, b, c)\n    return ans, flg\n\ndef is_all_same_attime(xyuv):\n    xy0, uv0 = xyuv[0]\n    for i in range(len(xyuv)):\n        if xyuv[0] == xyuv[i]:\n            continue\n        xyi,uvi = xyuv[i]\n\n        t = get_cross_time(xy0,xyi,xy0 + uv0,xyi + uvi)\n\n        if t is None or t < 0:\n            return False\n\n        p0 = xy0 + uv0 * t\n        for j in range(i + 1,len(xyuv)):\n            xyj, uvj = xyuv[j]\n            pj = xyj + uvj * t\n            if eq(pj, p0):\n                continue\n            return False\n        break\n    return True\n\ndef get_cross_time(p1,p2,p3,p4):\n    s1 = cross(p4-p2,p1-p2)\n    s2 = cross(p4-p2,p2-p3)\n    if s1 + s2 == 0:\n        return None\n    return s1 / (s1 + s2)\n\ndef take2(i):\n    while True:\n        yield next(i),next(i)\ndef main(f):\n    _ = int(f.readline())\n    xyuv = [[x+y*1j for x,y in take2(map(int, line.split()))] for line in f]\n\n    print(solve(xyuv))\n\ndef is_all_same(xyuv):\n    for xyuvi in xyuv:\n        if xyuvi != xyuv[0]:\n            return False\n    return True\n\ndef cross(v1,v2):\n    return v1.real * v2.imag - v1.imag * v2.real\ndef eq(a, b):\n    return abs(a - b) <= 10 ** -9\n# return [2??????????????],0==a==b==c\ndef quadratic_equation(a,b,c):\n    if a:\n        d = b * b - 4 * a * c\n        if d < 0:\n            ans = []\n        elif d == 0:\n            ans = [-b / (2 * a)]\n        else:\n            d **= 0.5\n            d /= 2 * a\n            b /= 2 * a\n            ans = [-b + d, -b - d]\n    elif b:\n        ans = [-c / b]\n    else:\n        ans = []\n    return ans, 0 == a == b == c\n\nimport sys\nf = sys.stdin\n\nmain(f)"
  },
  {
    "language": "Python",
    "code": "# return [2??????????????],0==a==b==c\ndef quadratic_equation(a,b,c):\n    if a:\n        d = b * b - 4 * a * c\n        if d < 0:\n            ans = []\n        elif d == 0:\n            ans = [-b / (2 * a)]\n        else:\n            d **= 0.5\n            d /= 2 * a\n            b /= 2 * a\n            ans = [-b + d, -b - d]\n    elif b:\n        ans = [-c / b]\n    else:\n        ans = []\n    return ans, 0 == a == b == c\n\ndef eq(a, b):\n    return abs(a - b) <= 10 ** -9\n\ndef cross(v1,v2):\n    return v1.real * v2.imag - v1.imag * v2.real\n\nfrom itertools import combinations\nfrom itertools import groupby\ndef solve(xyuv):\n    if len(xyuv) <= 2 or is_all_same(xyuv):\n        return len(xyuv)\n    max_ij = 0\n    for i, j in combinations(range(len(xyuv)), 2):\n        if xyuv[i] == xyuv[j]:\n            continue\n            \n        always_lined_point = 0\n        t = []\n        for k in range(len(xyuv)):\n            if i == k or j == k:\n                continue\n            xyi,uvi = xyuv[i]\n            xyj,uvj = xyuv[j]\n            xyk,uvk = xyuv[k]\n            xyi -= xyk\n            xyj -= xyk\n            uvi -= uvk\n            uvj -= uvk\n            \n            ans,flg = quadratic_equation(cross(uvi, uvj), cross(xyi, uvj) + cross(uvi, xyj), cross(xyi, xyj))\n            #ans,flg = quadratic_equation(c*h-d*g, a*h-b*g + c*f-d*e, a*f-b*e)\n            t.extend(ans)\n            if flg:\n                always_lined_point += 1\n\n        t = [round(ti, 10) for ti in t] #?????????\n        t = [ti for ti in t if 0 <= ti] #t<0?????????\n\n        \n        xy,uv = xyuv[i]\n        xyj,uvj = xyuv[j]\n        xy -= xyj\n        uv -= uvj\n\n        t.sort()\n        max_group_length = 0\n        for k, g in groupby(t):\n            if not eq(xy + uv * k, 0):\n                max_group_length = max(max_group_length, sum(1 for _ in g))\n            \n        max_ij = max(max_ij, max_group_length + always_lined_point + 2)\n    return max_ij\n\ndef is_all_same(xyuv):\n    for xyuvi in xyuv:\n        if xyuvi != xyuv[0]:\n            return False\n    return True\n\nimport sys\nf = sys.stdin\n\ndef take2(i):\n    while True:\n        yield next(i),next(i)\n\n_ = int(f.readline())\nxyuv = [[x+y*1j for x,y in take2(map(int, line.split()))] for line in f]\n\nprint(solve(xyuv))"
  },
  {
    "language": "Python",
    "code": "def take2(i):\n    while True:\n        yield next(i),next(i)\ndef main(f):\n    _ = int(f.readline())\n    xyuv = [[x+y*1j for x,y in take2(map(int, line.split()))] for line in f]\n\n    print(solve(xyuv))\ndef is_all_same_attime(xyuv):\n    xy0, uv0 = xyuv[0]\n    for i in range(len(xyuv)):\n        if xyuv[0] == xyuv[i]:\n            continue\n        xyi,uvi = xyuv[i]\n\n        t = get_cross_time(xy0 - xyi, uv0 - uvi)\n\n        if t is None or t < 0:\n            return False\n\n        p0 = xy0 + uv0 * t\n        for j in range(i + 1,len(xyuv)):\n            xyj, uvj = xyuv[j]\n            pj = xyj + uvj * t\n            if is_zero(pj - p0):\n                continue\n            return False\n        break\n    return True\ndef get_cross_time(xy,uv):\n     denominator = uv.real - uv.imag\n     return (xy.imag - xy.real) / denominator if denominator else None\n\ndef is_all_same(xyuv):\n    for xyuvi in xyuv:\n        if xyuvi != xyuv[0]:\n            return False\n    return True\n\ndef is_zero(a):\n    return abs(a) < 0.00001\n\ndef get_t(xy1,uv1,xy2,uv2):\n    a = uv1.real * uv2.imag - uv1.imag * uv2.real\n    b = xy1.real * uv2.imag - xy1.imag * uv2.real + uv1.real * xy2.imag - uv1.imag * xy2.real\n    c = xy1.real * xy2.imag - xy1.imag * xy2.real\n    if a:\n        d = b * b - 4 * a * c\n        if d < 0:\n            return []\n        elif d == 0:\n            return [-b / (2 * a)]\n        else:\n            d = d ** 0.5 / (2 * a)\n            b /= 2 * a\n            return [-b + d, -b - d]\n    if b:\n        return [-c / b]\n    if not c:\n        global always_lined_point\n        always_lined_point += 1\n    return []\n\nfrom itertools import combinations\nfrom itertools import groupby\nfrom collections import Counter\ndef solve(xyuv):\n    global always_lined_point\n    if len(xyuv) <= 2 or is_all_same(xyuv) or is_all_same_attime(xyuv):\n        return len(xyuv)\n    max_ij = 0\n    for i, j in combinations(range(len(xyuv)), 2):\n        if xyuv[i] == xyuv[j]:\n            continue\n        xyi,uvi = xyuv[i]\n        xyj,uvj = xyuv[j]\n            \n        always_lined_point = 0\n        t = []\n        for indeces in (range(i),range(i + 1,j),range(j + 1,len(xyuv))):\n            for k in indeces:\n                xyk,uvk = xyuv[k]\n                t.extend(get_t(xyi - xyk, uvi - uvk, xyj - xyk, uvj - uvk))\n\n        t = [ti for ti in t if 0 <= ti] #t<0?????????\n        t = [round(ti, 10) for ti in t] #?????????\n        t = Counter(t)\n\n        group_lengths = []\n        for k, c in t.most_common(2):\n            group_length = 1 if is_zero(xyi + uvi * k) else c\n            group_lengths.append(group_length)\n             \n        max_ij = max(max_ij, max(group_lengths) + always_lined_point + 2)\n    return max_ij\n\nimport sys\nf = sys.stdin\n\nmain(f)"
  },
  {
    "language": "Python",
    "code": "def take2(i):\n    while True:\n        yield next(i),next(i)\ndef main(f):\n    _ = int(f.readline())\n    xyuv = [[x+y*1j for x,y in take2(map(int, line.split()))] for line in f]\n\n    print(solve(xyuv))\ndef is_all_same_attime(xyuv):\n    xy0, uv0 = xyuv[0]\n    for i in range(len(xyuv)):\n        if xyuv[0] == xyuv[i]:\n            continue\n        xyi,uvi = xyuv[i]\n\n        t = get_cross_time(xy0 - xyi, uv0 - uvi)\n\n        if t is None or t < 0:\n            return False\n\n        p0 = xy0 + uv0 * t\n        for j in range(i + 1,len(xyuv)):\n            xyj, uvj = xyuv[j]\n            pj = xyj + uvj * t\n            if is_zero(pj - p0):\n                continue\n            return False\n        break\n    return True\ndef get_cross_time(xy,uv):\n     denominator = uv.real - uv.imag\n     return (xy.imag - xy.real) / denominator if denominator else None\n\ndef is_all_same(xyuv):\n    for xyuvi in xyuv:\n        if xyuvi != xyuv[0]:\n            return False\n    return True\n\ndef is_zero(a):\n    return abs(a) < 0.00001\n\ndef get_t(xy1,uv1,xy2,uv2):\n    a = uv1.real * uv2.imag - uv1.imag * uv2.real\n    b = xy1.real * uv2.imag - xy1.imag * uv2.real + uv1.real * xy2.imag - uv1.imag * xy2.real\n    c = xy1.real * xy2.imag - xy1.imag * xy2.real\n    if a:\n        d = b * b - 4 * a * c\n        if d < 0:\n            return []\n        elif d == 0:\n            return [-b / (2 * a)]\n        else:\n            d = d ** 0.5 / (2 * a)\n            b /= 2 * a\n            return [-b + d, -b - d]\n    if b:\n        return [-c / b]\n    if not c:\n        global always_lined_point\n        always_lined_point += 1\n    return []\n\nfrom itertools import combinations\nfrom itertools import groupby\nfrom collections import Counter\n#@profile\ndef solve(xyuv):\n    global always_lined_point\n    if len(xyuv) <= 2 or is_all_same(xyuv) or is_all_same_attime(xyuv):\n        return len(xyuv)\n    max_ij = 0\n    for i, j in combinations(range(len(xyuv)), 2):\n        if xyuv[i] == xyuv[j]:\n            continue\n        xyi,uvi = xyuv[i]\n        xyj,uvj = xyuv[j]\n            \n        always_lined_point = 0\n        t = []\n        for indeces in (range(i),range(i + 1,j),range(j + 1,len(xyuv))):\n            for k in indeces:\n                xyk,uvk = xyuv[k]\n                t.extend(get_t(xyi - xyk, uvi - uvk, xyj - xyk, uvj - uvk))\n\n        t = [ti for ti in t if 0 <= ti] #t<0?????????\n        t = [round(ti, 10) for ti in t] #?????????\n        t = Counter(t)\n\n        group_lengths = [0]\n        for k, c in t.most_common(2):\n            group_length = 1 if is_zero(xyi + uvi * k) else c\n            group_lengths.append(group_length)\n             \n        max_ij = max(max_ij, max(group_lengths) + always_lined_point + 2)\n    return max_ij\n\nimport sys\nf = sys.stdin\n\nmain(f)"
  },
  {
    "language": "Python",
    "code": "def take2(i):\n    while True:\n        yield next(i),next(i)\ndef main(f):\n    _ = int(f.readline())\n    xyuv = [[x+y*1j for x,y in take2(map(int, line.split()))] for line in f]\n\n    print(solve(xyuv))\ndef is_all_same_attime(xyuv):\n    xy0, uv0 = xyuv[0]\n    for i in range(len(xyuv)):\n        if xyuv[0] == xyuv[i]:\n            continue\n        xyi,uvi = xyuv[i]\n\n        t = get_cross_time(xy0 - xyi, uv0 - uvi)\n\n        if t is None or t < 0:\n            return False\n\n        p0 = xy0 + uv0 * t\n        for j in range(i + 1,len(xyuv)):\n            xyj, uvj = xyuv[j]\n            pj = xyj + uvj * t\n            if is_zero(pj - p0):\n                continue\n            return False\n        break\n    return True\ndef get_cross_time(xy,uv):\n     denominator = uv.real - uv.imag\n     return (xy.imag - xy.real) / denominator if denominator else None\n\ndef is_all_same(xyuv):\n    for xyuvi in xyuv:\n        if xyuvi != xyuv[0]:\n            return False\n    return True\n\ndef is_zero(a):\n    return abs(a) < 0.00001\n\ndef get_t(xy1,uv1,xy2,uv2):\n    a = uv1.real * uv2.imag - uv1.imag * uv2.real\n    b = xy1.real * uv2.imag - xy1.imag * uv2.real + uv1.real * xy2.imag - uv1.imag * xy2.real\n    c = xy1.real * xy2.imag - xy1.imag * xy2.real\n    if a:\n        d = b * b - 4 * a * c\n        if d < 0:\n            return []\n        elif d == 0:\n            return [-b / (2 * a)]\n        else:\n            d = d ** 0.5 / (2 * a)\n            b /= 2 * a\n            return [-b + d, -b - d]\n    if b:\n        return [-c / b]\n    if not c:\n        global always_lined_point\n        always_lined_point += 1\n    return []\n\nfrom itertools import combinations\nfrom itertools import groupby\nfrom collections import Counter\n#@profile\ndef solve(xyuv):\n    global always_lined_point\n    if len(xyuv) <= 2 or is_all_same(xyuv) or is_all_same_attime(xyuv):\n        return len(xyuv)\n    max_ij = 0\n    for i, j in combinations(range(len(xyuv)), 2):\n        if xyuv[i] == xyuv[j]:\n            continue\n        xyi,uvi = xyuv[i]\n        xyj,uvj = xyuv[j]\n            \n        always_lined_point = 0\n        t = []\n        for indeces in (range(i),range(i + 1,j),range(j + 1,len(xyuv))):\n            for k in indeces:\n                xyk,uvk = xyuv[k]\n                t.extend(get_t(xyi - xyk, uvi - uvk, xyj - xyk, uvj - uvk))\n\n        t = [ti for ti in t if 0 <= ti] #t<0?????????\n        t = [round(ti, 10) for ti in t] #?????????\n        t = Counter(t)\n\n        xyi -= xyj\n        uvi -= uvj\n\n        group_lengths = [0]\n        for k, c in t.most_common(2):\n            group_length = 1 if is_zero(xyi + uvi * k) else c\n            group_lengths.append(group_length)\n             \n        max_ij = max(max_ij, max(group_lengths) + always_lined_point + 2)\n    return max_ij\n\nimport sys\nf = sys.stdin\n\nmain(f)"
  },
  {
    "language": "Python",
    "code": "from itertools import combinations\nfrom itertools import groupby\ndef solve(xyuv):\n    if len(xyuv) <= 2 or is_all_same(xyuv) or is_all_same_attime(xyuv):\n        return len(xyuv)\n    max_ij = 0\n    for i, j in combinations(range(len(xyuv)), 2):\n        if xyuv[i] == xyuv[j]:\n            continue\n        xyi,uvi = xyuv[i]\n        xyj,uvj = xyuv[j]\n            \n        always_lined_point = 0\n        t = []\n        for k in range(len(xyuv)):\n            if i == k or j == k:\n                continue\n            xyk,uvk = xyuv[k]\n            ans, flg = get_t(xyi - xyk, uvi - uvk, xyj - xyk, uvj - uvk)\n            t.extend(ans)\n            if flg:\n                always_lined_point += 1\n\n        t = [round(ti, 10) for ti in t] #?????????\n        t = [ti for ti in t if 0 <= ti] #t<0?????????\n        t.sort()\n        \n        xyi -= xyj\n        uvi -= uvj\n\n        max_group_length = 0\n        for k, g in groupby(t):\n            group_length = 1 if eq(xyi + uvi * k, 0) else sum(1 for _ in g)\n            max_group_length = max(max_group_length, group_length)\n            \n        max_ij = max(max_ij, max_group_length + always_lined_point + 2)\n    return max_ij\n\ndef get_t(xy1,uv1,xy2,uv2):\n    a = cross(uv1, uv2)\n    b = cross(xy1, uv2) + cross(uv1, xy2)\n    c = cross(xy1, xy2)\n    ans, flg = quadratic_equation(a, b, c)\n    return ans, flg\n\ndef is_all_same_attime(xyuv):\n    xy0, uv0 = xyuv[0]\n    for i in range(len(xyuv)):\n        if xyuv[0] == xyuv[i]:\n            continue\n        xyi,uvi = xyuv[i]\n\n        t = get_cross_time(xy0,xyi,xy0 + uv0,xyi + uvi)\n\n        if t is None or t < 0:\n            return False\n\n        p0 = xy0 + uv0 * t\n        for j in range(i + 1,len(xyuv)):\n            xyj, uvj = xyuv[j]\n            pj = xyj + uvj * t\n            if eq(pj, p0):\n                continue\n            return False\n        break\n    return True\n\ndef get_cross_time(p1,p2,p3,p4):\n    s1 = cross(p4-p2,p1-p2)\n    s2 = cross(p4-p2,p2-p3)\n    if s1 + s2 == 0:\n        return None\n    return s1 / (s1 + s2)\ndef take2(i):\n    while True:\n        yield next(i),next(i)\ndef main(f):\n    _ = int(f.readline())\n    xyuv = [[x+y*1j for x,y in take2(map(int, line.split()))] for line in f]\n\n    print(solve(xyuv))\ndef is_all_same(xyuv):\n    for xyuvi in xyuv:\n        if xyuvi != xyuv[0]:\n            return False\n    return True\ndef cross(v1,v2):\n    return v1.real * v2.imag - v1.imag * v2.real\ndef eq(a, b):\n    return abs(a - b) <= 10 ** -9\n# return [2??????????????],0==a==b==c\ndef quadratic_equation(a,b,c):\n    if a:\n        d = b * b - 4 * a * c\n        if d < 0:\n            ans = []\n        elif d == 0:\n            ans = [-b / (2 * a)]\n        else:\n            d **= 0.5\n            d /= 2 * a\n            b /= 2 * a\n            ans = [-b + d, -b - d]\n    elif b:\n        ans = [-c / b]\n    else:\n        ans = []\n    return ans, 0 == a == b == c\n\n\nimport sys\nf = sys.stdin\n\nmain(f)"
  },
  {
    "language": "Python",
    "code": "# return [2??????????????],0==a==b==c\ndef quadratic_equation(a,b,c):\n    if a:\n        d = b * b - 4 * a * c\n        if d < 0:\n            ans = []\n        elif d == 0:\n            ans = [-b / (2 * a)]\n        else:\n            d **= 0.5\n            d /= 2 * a\n            b /= 2 * a\n            ans = [-b + d, -b - d]\n    elif b:\n        ans = [-c / b]\n    else:\n        ans = []\n    return ans, 0 == a == b == c\n\ndef eq(a, b):\n    return round(abs(a - b), 10) == 0\n\ndef cross(v1,v2):\n    return v1.real * v2.imag - v1.imag * v2.real\n\nfrom itertools import combinations\nfrom itertools import groupby\ndef solve(xyuv):\n    if len(xyuv) <= 2 or is_all_same(xyuv):\n        return len(xyuv)\n    max_ij = 0\n    for i, j in combinations(range(len(xyuv)), 2):\n        if xyuv[i] == xyuv[j]:\n            continue\n            \n        always_lined_point = 0\n        t = []\n        for k in range(len(xyuv)):\n            if i == k or j == k:\n                continue\n            xyi,uvi = xyuv[i]\n            xyj,uvj = xyuv[j]\n            xyk,uvk = xyuv[k]\n            xyi -= xyk\n            xyj -= xyk\n            uvi -= uvk\n            uvj -= uvk\n            \n            ans,flg = quadratic_equation(cross(uvi, uvj), cross(xyi, uvj) + cross(uvi, xyj), cross(xyi, xyj))\n            #ans,flg = quadratic_equation(c*h-d*g, a*h-b*g + c*f-d*e, a*f-b*e)\n            t.extend(ans)\n            if flg:\n                always_lined_point += 1\n\n        t = [round(ti, 10) for ti in t] #?????????\n        t = [ti for ti in t if 0 <= ti] #t<0?????????\n\n        \n        xy,uv = xyuv[i]\n        xyj,uvj = xyuv[j]\n        xy -= xyj\n        uv -= uvj\n\n        t.sort()\n        max_group_length = 0\n        for k, g in groupby(t):\n            if not eq(xy + uv * k, 0):\n                max_group_length = max(max_group_length, sum(1 for _ in g))\n            \n        max_ij = max(max_ij, max_group_length + always_lined_point + 2)\n    return max_ij\n\ndef is_all_same(xyuv):\n    for xyuvi in xyuv:\n        if xyuvi != xyuv[0]:\n            return False\n    return True\n\nimport sys\nf = sys.stdin\n\ndef take2(i):\n    while True:\n        yield next(i),next(i)\n\n_ = int(f.readline())\nxyuv = [[x+y*1j for x,y in take2(map(int, line.split()))] for line in f]\n\nprint(solve(xyuv))"
  },
  {
    "language": "Python",
    "code": "import itertools\n\nN = int(input())\nkm = []\nfor i in range(N):\n    km.append(input().split(' '))\n\n\nnmax = 0\ntry:\n    for i in range(1000):\n        ks = []\n        for j in range(N):\n            x, y, u, v = list(map(int, list(km[j])))\n            ks.append((x + u * i, y + v * i))\n        for k in list(itertools.combinations(ks, 2)):\n            (x1, y1), (x2, y2) = k\n            xd = x1 - x2\n            yd = y1 - y2\n            t = 0\n            for j in ks:\n                (x3, y3) = j\n                #for di in range(-20, 20):\n                if ((xd == 0 and yd == 0 and x3 == x1 and y1 == y3) or \n                        ((xd != 0 or yd != 0) and (x1 - x3) * yd == (y1 - y3) * xd)):\n                    t += 1\n            nmax = max(nmax, t)\n            if nmax == N:\n                raise Exception\n\nexcept Exception:\n    pass\n\nprint(nmax)"
  },
  {
    "language": "Python",
    "code": "import itertools\n\nN = int(input())\nkm = []\nfor i in range(N):\n    km.append(input().split(' '))\n\n\nnmax = 0\ntry:\n    for i in range(100):\n        ks = []\n        for j in range(N):\n            x, y, u, v = list(map(int, list(km[j])))\n            ks.append((x + u * i, y + v * i))\n        for k in list(itertools.combinations(ks, 2)):\n            (x1, y1), (x2, y2) = k\n            xd = x1 - x2\n            yd = y1 - y2\n            t = 0\n            for j in ks:\n                (x3, y3) = j\n                #for di in range(-20, 20):\n                if ((xd == 0 and yd == 0 and x3 == x1 and y1 == y3) or \n                        ((xd != 0 or yd != 0) and (x1 - x3) * yd == (y1 - y3) * xd)):\n                    t += 1\n            nmax = max(nmax, t)\n            if nmax == N:\n                raise Exception\n\nexcept Exception:\n    pass\n\nprint(nmax)"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BinaryHeap, BTreeMap, VecDeque};\nuse std::ops::{Range, Sub, Add};\nuse ::Suspects::All;\nuse std::fmt::{Display, Formatter, Error};\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n\nfn main(){\n    let_all!(n: usize);\n    let mut persons = Vec::with_capacity(n);\n    for _ in 0 .. n {\n        let_all!(x: i32, y: i32, u: i32, v: i32);\n        persons.push(Person{initial: Point{x: x, y: y}, velocity: Vector{dx: u, dy: v}});\n    }\n    println!(\"{}\", solve(&persons));\n}\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct Point {\n    x: i32, y: i32\n}\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct Vector {\n    dx: i32, dy: i32\n}\n#[derive(Copy, Clone)]\nstruct PointF {\n    x: f64, y: f64\n}\nimpl Display for Point {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Point(x: {}, y: {})\", self.x, self.y)\n    }\n}\nimpl Display for Vector {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Vector(dx: {}, dy: {})\", self.dx, self.dy)\n    }\n}\nimpl Display for Person {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Person(initial: {}, velocity: {})\", self.initial, self.velocity)\n    }\n}\nimpl Display for PointF {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Point(x: {}, y: {})\", self.x, self.y)\n    }\n}\nimpl Vector {\n    fn to_point(&self) -> Point {\n        Point{x: self.dx, y: self.dy}\n    }\n}\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct Person {\n    initial: Point, velocity: Vector\n}\nimpl Person {\n    fn position_at(&self, time: f64) -> PointF {\n        PointF{x: self.initial.x as f64 + self.velocity.dx as f64 * time, y: self.initial.y as f64 + self.velocity.dy as f64 * time}\n    }\n\n}\nimpl Sub for Point {\n    type Output = Vector;\n    fn sub(self, rhs: Point) -> Self::Output {\n        Vector{dx: self.x - rhs.x, dy: self.y - rhs.y}\n    }\n}\nimpl Sub for Vector {\n    type Output = Vector;\n    fn sub(self, rhs: Vector) -> Self::Output {\n        Vector{dx: self.dx - rhs.dx, dy: self.dy - rhs.dy}\n    }\n}\nimpl Sub for PointF {\n    type Output = PointF;\n    fn sub(self, rhs: PointF) -> Self::Output {\n        PointF{x: self.x - rhs.x, y: self.y - rhs.y}\n    }\n}\nenum Suspects<T> {\n    All, Some{suspects: Vec<T>}, None\n}\nfn find_on_line_time(a: &Person, b: &Person, target: &Person) -> Suspects<f64> {\n    let Vector{dx: a1, dy: c1} = a.initial - b.initial;\n    let Vector{dx: b1, dy: d1}= a.velocity - b.velocity;\n    let Vector{dx: a2, dy: c2} = target.initial - b.initial;\n    let Vector{dx: b2, dy: d2} = target.velocity - b.velocity;\n    let a = (b1 * d2 - d1 * b2) as f64;\n    let b = (b1 * c2 + a1 * d2 - a2 * d1 - c1 * b2) as f64;\n    let c = (a1 * c2 - a2 * c1) as f64;\n    if a == 0_f64 {\n        if b == 0_f64 {\n            if c == 0_f64 {\n                All\n            }else {\n                Suspects::None\n            }\n        }else if -c / b >= 0_f64 {\n            Suspects::Some{suspects: vec![-c / b]}\n        }else {\n            Suspects::None\n        }\n    }else {\n        let d = b * b - 4_f64 * a * c;\n        if d < 0_f64 {\n            Suspects::None\n        }else if d.abs() <= 0.00000001_f64 {\n            if -b / (a * 2_f64) >= 0_f64 {\n                Suspects::Some{suspects: vec![-b / (a * 2_f64)]}\n            }else {\n                Suspects::None\n            }\n        }else {\n            let s = d.sqrt();\n            if (-b + s) / (a * 2_f64) < 0_f64 {\n                Suspects::None\n            }else if (-b - s) / (a * 2_f64) < 0_f64 {\n                Suspects::Some{suspects: vec![(-b + s) / (a * 2_f64)]}\n            }else {\n                Suspects::Some{suspects: vec![(-b + s) / (a * 2_f64), (-b - s) / (a * 2_f64)]}\n            }\n        }\n    }\n}\nfn flatten<T>(vec: &Vec<Vec<T>>) -> Vec<T> where T: Clone + Copy {\n    let mut count = 0;\n    for v in vec {\n        count += v.len();\n    }\n    let mut result = Vec::with_capacity(count);\n    for v in vec {\n        for &f in v {\n            result.push(f);\n        }\n    }\n    result\n}\nfn lower_bound<T: PartialOrd>(vec: &Vec<T>, target: &T) -> usize {\n    let mut left = 0;\n    let mut right = vec.len();\n    while left < right {\n        let mid = (left + right) / 2;\n        if vec[mid].partial_cmp(target).unwrap() == Ordering::Less {\n            left = mid + 1;\n        }else {\n            right = mid;\n        }\n    }\n    right\n}\nfn upper_bound<T: PartialOrd>(vec: &Vec<T>, target: &T) -> usize {\n    let mut left = 0;\n    let mut right = vec.len();\n    while left < right {\n        let mid = (left + right) / 2;\n        if vec[mid].partial_cmp(target).unwrap() != Ordering::Greater {\n            left = mid + 1;\n        }else {\n            right = mid;\n        }\n    }\n    right\n}\nfn show<T>(vec: &Vec<T>) where T: Display {\n    if vec.is_empty() {\n        println!(\"[]\")\n    }else {\n        print!(\"[{}\", vec.first().unwrap());\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nfn solve(person: &Vec<Person>) -> usize {\n    const EPS: f64 = 0.000001;\n    let mut max = 0;\n    /*\n    for &a in person.iter() {\n        let mut count =0;\n        for &b in person.iter() {\n            if a == b {\n                count += 1;\n            }\n        }\n        if max < count {\n            max = count;\n        }\n    }\n    */\n    for a in 0 .. person.len() {\n        for b in 0 .. a {\n            if person[a] != person[b] {\n                let mut count = 2;\n                let mut suspects = Vec::new();\n                for c in 0..person.len() {\n                    if a != c && b != c {\n                        match find_on_line_time(&person[a], &person[b], &person[c]) {\n                            Suspects::All => {\n                                count += 1;\n                            },\n                            Suspects::None => {}\n                            Suspects::Some { suspects: vec } => {\n                                for v in vec {\n                                    suspects.push(v)\n                                }\n                            },\n                        }\n                    }\n                }\n                suspects.sort_by(|a, b| a.partial_cmp(b).unwrap());\n                if count >= max {\n                    max = count;\n                }\n                for &s in &suspects {\n                    let c = upper_bound(&suspects, &(s + EPS)) - lower_bound(&suspects, &s);\n                    match person[a].position_at(s) - person[b].position_at(s) {\n                        PointF { x: x, y: y } if x.abs() >= EPS || y.abs() >= EPS => {\n                            if count + c > max {\n                                max = count + c;\n                            }\n                        }\n                        _ => {\n                            if count + 1 > max {\n                                max = count + 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    let dummy = Person{initial: Point{x: 11, y: 11}, velocity: Vector{dx: 3, dy: 3}};\n    for b in 0 .. person.len() {\n        let mut count = 1;\n        let mut suspects = Vec::new();\n        for c in 0..person.len() {\n            if b != c {\n                match find_on_line_time(&dummy, &person[b], &person[c]) {\n                    Suspects::All => {\n                        count += 1;\n                    },\n                    Suspects::None => {}\n                    Suspects::Some { suspects: vec } => {\n                        for v in vec {\n                            suspects.push(v)\n                        }\n                    },\n\n                }\n            }\n        }\n        suspects.sort_by(|a, b| a.partial_cmp(b).unwrap());\n        if count > max {\n            max = count;\n        }\n        for &s in &suspects {\n            let c = upper_bound(&suspects, &(s + EPS)) - lower_bound(&suspects, &s);\n            if count + c > max {\n                max = count + c;\n            }\n        }\n    }\n    max\n}\n\n\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BinaryHeap, BTreeMap, VecDeque};\nuse std::ops::{Range, Sub, Add};\nuse ::Suspects::All;\nuse std::fmt::{Display, Formatter, Error};\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n\nfn main(){\n    let_all!(n: usize);\n    let mut persons = Vec::with_capacity(n);\n    for _ in 0 .. n {\n        let_all!(x: i32, y: i32, u: i32, v: i32);\n        persons.push(Person{initial: Point{x: x, y: y}, velocity: Vector{dx: u, dy: v}});\n    }\n    println!(\"{}\", solve(&persons));\n}\n#[derive(Copy, Clone)]\nstruct Point {\n    x: i32, y: i32\n}\n#[derive(Copy, Clone)]\nstruct Vector {\n    dx: i32, dy: i32\n}\n#[derive(Copy, Clone)]\nstruct PointF {\n    x: f64, y: f64\n}\nimpl Display for Point {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Point(x: {}, y: {})\", self.x, self.y)\n    }\n}\nimpl Display for Vector {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Vector(dx: {}, dy: {})\", self.dx, self.dy)\n    }\n}\nimpl Display for Person {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Person(initial: {}, velocity: {})\", self.initial, self.velocity)\n    }\n}\nimpl Display for PointF {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Point(x: {}, y: {})\", self.x, self.y)\n    }\n}\nimpl Vector {\n    fn to_point(&self) -> Point {\n        Point{x: self.dx, y: self.dy}\n    }\n}\n#[derive(Copy, Clone)]\nstruct Person {\n    initial: Point, velocity: Vector\n}\nimpl Person {\n    fn position_at(&self, time: f64) -> PointF {\n        PointF{x: self.initial.x as f64 + self.velocity.dx as f64 * time, y: self.initial.y as f64 + self.velocity.dy as f64 * time}\n    }\n}\nimpl Sub for Point {\n    type Output = Vector;\n    fn sub(self, rhs: Point) -> Self::Output {\n        Vector{dx: self.x - rhs.x, dy: self.y - rhs.y}\n    }\n}\nimpl Sub for Vector {\n    type Output = Vector;\n    fn sub(self, rhs: Vector) -> Self::Output {\n        Vector{dx: self.dx - rhs.dx, dy: self.dy - rhs.dy}\n    }\n}\nimpl Sub for PointF {\n    type Output = PointF;\n    fn sub(self, rhs: PointF) -> Self::Output {\n        PointF{x: self.x - rhs.x, y: self.y - rhs.y}\n    }\n}\nenum Suspects<T> {\n    All, Some{suspects: Vec<T>}, None\n}\nfn find_on_line_time(a: &Person, b: &Person, target: &Person) -> Suspects<f64> {\n    let Vector{dx: a1, dy: c1} = a.initial - b.initial;\n    let Vector{dx: b1, dy: d1}= a.velocity - b.velocity;\n    let Vector{dx: a2, dy: c2} = target.initial - b.initial;\n    let Vector{dx: b2, dy: d2} = target.velocity - b.velocity;\n    let a = (b1 * d2 - d1 * b2) as f64;\n    let b = (b1 * c2 + a1 * d2 - a2 * d1 - c1 * b2) as f64;\n    let c = (a1 * c2 - a2 * c1) as f64;\n    if a == 0_f64 {\n        if b == 0_f64 {\n            if c == 0_f64 {\n                All\n            }else {\n                Suspects::None\n            }\n        }else if -c / b >= 0_f64 {\n            Suspects::Some{suspects: vec![-c / b]}\n        }else {\n            Suspects::None\n        }\n    }else {\n        let d = b * b - 4_f64 * a * c;\n        if d < 0_f64 {\n            Suspects::None\n        }else if d == 0_f64 {\n            if -b / (a * 2_f64) >= 0_f64 {\n                Suspects::Some{suspects: vec![-b / (a * 2_f64)]}\n            }else {\n                Suspects::None\n            }\n        }else {\n            let s = d.sqrt();\n            if (-b + s) / (a * 2_f64) <= 0_f64 {\n                Suspects::None\n            }else if (-b - s) / (a * 2_f64) <= 0_f64 {\n                Suspects::Some{suspects: vec![(-b + s) / (a * 2_f64)]}\n            }else {\n                Suspects::Some{suspects: vec![(-b + s) / (a * 2_f64), (-b - s) / (a * 2_f64)]}\n            }\n        }\n    }\n}\n\nfn flatten<T>(vec: &Vec<Vec<T>>) -> Vec<T> where T: Clone + Copy {\n    let mut count = 0;\n    for v in vec {\n        count += v.len();\n    }\n    let mut result = Vec::with_capacity(count);\n    for v in vec {\n        for &f in v {\n            result.push(f);\n        }\n    }\n    result\n}\nfn lower_bound(vec: &Vec<f64>, target: &f64) -> usize {\n    let mut left = 0;\n    let mut right = vec.len();\n    while left < right {\n        let mid = (left + right) / 2;\n        if vec[mid] < *target {\n            left = mid + 1;\n        }else {\n            right = mid;\n        }\n    }\n    right\n}\nfn upper_bound(vec: &Vec<f64>, target: &f64) -> usize {\n    let mut left = 0;\n    let mut right = vec.len();\n    while left < right {\n        let mid = (left + right) / 2;\n        if vec[mid] <= *target {\n            left = mid + 1;\n        }else {\n            right = mid;\n        }\n    }\n    right\n}\nfn show<T>(vec: &Vec<T>) where T: Display {\n    if vec.is_empty() {\n        println!(\"[]\")\n    }else {\n        print!(\"[{}\", vec.first().unwrap());\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nfn solve(person: &Vec<Person>) -> usize {\n    const EPS: f64 = 0.000001;\n    let mut max = 0;\n    for a in 0 .. person.len() {\n        for b in 0 .. a {\n            let mut count = 2;\n            let mut suspects = Vec::new();\n            for c in 0 .. person.len() {\n                if a != c && b != c {\n                    match find_on_line_time(&person[a], &person[b], &person[c]) {\n                        Suspects::All => {\n                            count += 1;\n                        },\n                        Suspects::None => {\n                        }\n                        Suspects::Some{suspects: vec} => {\n                            suspects.push(vec)\n                        },\n                    }\n                }\n            }\n            let mut suspects = flatten(&suspects);\n            suspects.sort_by(|a, b| a.partial_cmp(b).unwrap());\n            let suspects = suspects;\n            if count > max {\n                max = count;\n            }\n            for &s in &suspects {\n                match person[a].position_at(s) - person[b].position_at(s) {\n                    PointF{x: x, y: y} if x.abs() >= EPS || y.abs() >= EPS => {\n                        let\n                            c = upper_bound(&suspects, &(s + EPS)) - lower_bound(&suspects, &s);\n                        if count + c > max {\n                            max = count + c;\n                        }\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n    max\n}\n\n\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BinaryHeap, BTreeMap, VecDeque};\nuse std::ops::{Range, Sub, Add};\nuse ::Suspects::All;\nuse std::fmt::{Display, Formatter, Error};\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n\nfn main(){\n    let_all!(n: usize);\n    let mut persons = Vec::with_capacity(n);\n    for _ in 0 .. n {\n        let_all!(x: i32, y: i32, u: i32, v: i32);\n        persons.push(Person{initial: Point{x: x, y: y}, velocity: Vector{dx: u, dy: v}});\n    }\n    println!(\"{}\", solve(&persons));\n}\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct Point {\n    x: i32, y: i32\n}\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct Vector {\n    dx: i32, dy: i32\n}\n#[derive(Copy, Clone)]\nstruct PointF {\n    x: f64, y: f64\n}\nimpl Display for Point {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Point(x: {}, y: {})\", self.x, self.y)\n    }\n}\nimpl Display for Vector {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Vector(dx: {}, dy: {})\", self.dx, self.dy)\n    }\n}\nimpl Display for Person {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Person(initial: {}, velocity: {})\", self.initial, self.velocity)\n    }\n}\nimpl Display for PointF {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Point(x: {}, y: {})\", self.x, self.y)\n    }\n}\nimpl Vector {\n    fn to_point(&self) -> Point {\n        Point{x: self.dx, y: self.dy}\n    }\n}\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct Person {\n    initial: Point, velocity: Vector\n}\nimpl Person {\n    fn position_at(&self, time: f64) -> PointF {\n        PointF{x: self.initial.x as f64 + self.velocity.dx as f64 * time, y: self.initial.y as f64 + self.velocity.dy as f64 * time}\n    }\n}\nimpl Sub for Point {\n    type Output = Vector;\n    fn sub(self, rhs: Point) -> Self::Output {\n        Vector{dx: self.x - rhs.x, dy: self.y - rhs.y}\n    }\n}\nimpl Sub for Vector {\n    type Output = Vector;\n    fn sub(self, rhs: Vector) -> Self::Output {\n        Vector{dx: self.dx - rhs.dx, dy: self.dy - rhs.dy}\n    }\n}\nimpl Sub for PointF {\n    type Output = PointF;\n    fn sub(self, rhs: PointF) -> Self::Output {\n        PointF{x: self.x - rhs.x, y: self.y - rhs.y}\n    }\n}\nenum Suspects<T> {\n    All, Some{suspects: Vec<T>}, None\n}\nfn find_on_line_time(a: &Person, b: &Person, target: &Person) -> Suspects<f64> {\n    let Vector{dx: a1, dy: c1} = a.initial - b.initial;\n    let Vector{dx: b1, dy: d1}= a.velocity - b.velocity;\n    let Vector{dx: a2, dy: c2} = target.initial - b.initial;\n    let Vector{dx: b2, dy: d2} = target.velocity - b.velocity;\n    let a = (b1 * d2 - d1 * b2) as f64;\n    let b = (b1 * c2 + a1 * d2 - a2 * d1 - c1 * b2) as f64;\n    let c = (a1 * c2 - a2 * c1) as f64;\n    if a == 0_f64 {\n        if b == 0_f64 {\n            if c == 0_f64 {\n                All\n            }else {\n                Suspects::None\n            }\n        }else if -c / b >= 0_f64 {\n            Suspects::Some{suspects: vec![-c / b]}\n        }else {\n            Suspects::None\n        }\n    }else {\n        let d = b * b - 4_f64 * a * c;\n        if d < 0_f64 {\n            Suspects::None\n        }else if d == 0_f64 {\n            if -b / (a * 2_f64) >= 0_f64 {\n                Suspects::Some{suspects: vec![-b / (a * 2_f64)]}\n            }else {\n                Suspects::None\n            }\n        }else {\n            let s = d.sqrt();\n            if (-b + s) / (a * 2_f64) <= 0_f64 {\n                Suspects::None\n            }else if (-b - s) / (a * 2_f64) <= 0_f64 {\n                Suspects::Some{suspects: vec![(-b + s) / (a * 2_f64)]}\n            }else {\n                Suspects::Some{suspects: vec![(-b + s) / (a * 2_f64), (-b - s) / (a * 2_f64)]}\n            }\n        }\n    }\n}\n\nfn flatten<T>(vec: &Vec<Vec<T>>) -> Vec<T> where T: Clone + Copy {\n    let mut count = 0;\n    for v in vec {\n        count += v.len();\n    }\n    let mut result = Vec::with_capacity(count);\n    for v in vec {\n        for &f in v {\n            result.push(f);\n        }\n    }\n    result\n}\nfn lower_bound(vec: &Vec<f64>, target: &f64) -> usize {\n    let mut left = 0;\n    let mut right = vec.len();\n    while left < right {\n        let mid = (left + right) / 2;\n        if vec[mid] < *target {\n            left = mid + 1;\n        }else {\n            right = mid;\n        }\n    }\n    right\n}\nfn upper_bound(vec: &Vec<f64>, target: &f64) -> usize {\n    let mut left = 0;\n    let mut right = vec.len();\n    while left < right {\n        let mid = (left + right) / 2;\n        if vec[mid] <= *target {\n            left = mid + 1;\n        }else {\n            right = mid;\n        }\n    }\n    right\n}\nfn show<T>(vec: &Vec<T>) where T: Display {\n    if vec.is_empty() {\n        println!(\"[]\")\n    }else {\n        print!(\"[{}\", vec.first().unwrap());\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nfn solve(person: &Vec<Person>) -> usize {\n    const EPS: f64 = 0.000001;\n    let mut max = 0;\n    for &a in person.iter() {\n        let mut count =0;\n        for &b in person.iter() {\n            if a == b {\n                count += 1;\n            }\n        }\n        if max < count {\n            max = count;\n        }\n    }\n    for a in 0 .. person.len() {\n        for b in 0 .. a {\n            if person[a] != person[b] {\n                let mut count = 2;\n                let mut suspects = Vec::new();\n                for c in 0..person.len() {\n                    if a != c && b != c {\n                        match find_on_line_time(&person[a], &person[b], &person[c]) {\n                            Suspects::All => {\n                                count += 1;\n                            },\n                            Suspects::None => {}\n                            Suspects::Some { suspects: vec } => {\n                                suspects.push(vec)\n                            },\n                        }\n                    }\n                }\n                let mut suspects = flatten(&suspects);\n                suspects.sort_by(|a, b| a.partial_cmp(b).unwrap());\n                let suspects = suspects;\n                if count > max {\n                    max = count;\n                }\n                for &s in &suspects {\n                    match person[a].position_at(s) - person[b].position_at(s) {\n                        PointF { x: x, y: y } if x.abs() >= EPS || y.abs() >= EPS => {\n                            let\n                                c = upper_bound(&suspects, &(s + EPS)) - lower_bound(&suspects, &s);\n                            if count + c > max {\n                                max = count + c;\n                            }\n                        }\n                        _ => {\n                            if count + 1 > max {\n                                max = count + 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    let dummy = Person{initial: Point{x: 11, y: 11}, velocity: Vector{dx: 3, dy: 3}};\n    for b in 0 .. person.len() {\n        let mut count = 1;\n        let mut suspects = Vec::new();\n        for c in 0..person.len() {\n            if b != c {\n                match find_on_line_time(&dummy, &person[b], &person[c]) {\n                    Suspects::All => {\n                        count += 1;\n                    },\n                    Suspects::None => {}\n                    Suspects::Some { suspects: vec } => {\n                        suspects.push(vec)\n                    },\n                }\n            }\n        }\n        let mut suspects = flatten(&suspects);\n        suspects.sort_by(|a, b| a.partial_cmp(b).unwrap());\n        let suspects = suspects;\n        if count > max {\n            max = count;\n        }\n        for &s in &suspects {\n            match dummy.position_at(s) - person[b].position_at(s) {\n                PointF { x: x, y: y } if x.abs() >= EPS || y.abs() >= EPS => {\n                    let\n                        c = upper_bound(&suspects, &(s + EPS)) - lower_bound(&suspects, &s);\n                    if count + c > max {\n                        max = count + c;\n                    }\n                }\n                _ => {\n                    if count + 1 > max {\n                        max = count + 1;\n                    }\n                }\n            }\n        }\n    }\n    max\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BinaryHeap, BTreeMap, VecDeque};\nuse std::ops::{Range, Sub, Add};\nuse ::Suspects::All;\nuse std::fmt::{Display, Formatter, Error};\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n\nfn main(){\n    let_all!(n: usize);\n    let mut persons = Vec::with_capacity(n);\n    for _ in 0 .. n {\n        let_all!(x: i32, y: i32, u: i32, v: i32);\n        persons.push(Person{initial: Point{x: x, y: y}, velocity: Vector{dx: u, dy: v}});\n    }\n    println!(\"{}\", solve(&persons));\n}\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct Point {\n    x: i32, y: i32\n}\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct Vector {\n    dx: i32, dy: i32\n}\n#[derive(Copy, Clone)]\nstruct PointF {\n    x: f64, y: f64\n}\nimpl Display for Point {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Point(x: {}, y: {})\", self.x, self.y)\n    }\n}\nimpl Display for Vector {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Vector(dx: {}, dy: {})\", self.dx, self.dy)\n    }\n}\nimpl Display for Person {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Person(initial: {}, velocity: {})\", self.initial, self.velocity)\n    }\n}\nimpl Display for PointF {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"Point(x: {}, y: {})\", self.x, self.y)\n    }\n}\nimpl Vector {\n    fn to_point(&self) -> Point {\n        Point{x: self.dx, y: self.dy}\n    }\n}\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct Person {\n    initial: Point, velocity: Vector\n}\nimpl Person {\n    fn position_at(&self, time: f64) -> PointF {\n        PointF{x: self.initial.x as f64 + self.velocity.dx as f64 * time, y: self.initial.y as f64 + self.velocity.dy as f64 * time}\n    }\n}\nimpl Sub for Point {\n    type Output = Vector;\n    fn sub(self, rhs: Point) -> Self::Output {\n        Vector{dx: self.x - rhs.x, dy: self.y - rhs.y}\n    }\n}\nimpl Sub for Vector {\n    type Output = Vector;\n    fn sub(self, rhs: Vector) -> Self::Output {\n        Vector{dx: self.dx - rhs.dx, dy: self.dy - rhs.dy}\n    }\n}\nimpl Sub for PointF {\n    type Output = PointF;\n    fn sub(self, rhs: PointF) -> Self::Output {\n        PointF{x: self.x - rhs.x, y: self.y - rhs.y}\n    }\n}\nenum Suspects<T> {\n    All, Some{suspects: Vec<T>}, None\n}\nfn find_on_line_time(a: &Person, b: &Person, target: &Person) -> Suspects<f64> {\n    let Vector{dx: a1, dy: c1} = a.initial - b.initial;\n    let Vector{dx: b1, dy: d1}= a.velocity - b.velocity;\n    let Vector{dx: a2, dy: c2} = target.initial - b.initial;\n    let Vector{dx: b2, dy: d2} = target.velocity - b.velocity;\n    let a = (b1 * d2 - d1 * b2) as f64;\n    let b = (b1 * c2 + a1 * d2 - a2 * d1 - c1 * b2) as f64;\n    let c = (a1 * c2 - a2 * c1) as f64;\n    if a == 0_f64 {\n        if b == 0_f64 {\n            if c == 0_f64 {\n                All\n            }else {\n                Suspects::None\n            }\n        }else if -c / b >= 0_f64 {\n            Suspects::Some{suspects: vec![-c / b]}\n        }else {\n            Suspects::None\n        }\n    }else {\n        let d = b * b - 4_f64 * a * c;\n        if d < 0_f64 {\n            Suspects::None\n        }else if d == 0_f64 {\n            if -b / (a * 2_f64) >= 0_f64 {\n                Suspects::Some{suspects: vec![-b / (a * 2_f64)]}\n            }else {\n                Suspects::None\n            }\n        }else {\n            let s = d.sqrt();\n            if (-b + s) / (a * 2_f64) <= 0_f64 {\n                Suspects::None\n            }else if (-b - s) / (a * 2_f64) <= 0_f64 {\n                Suspects::Some{suspects: vec![(-b + s) / (a * 2_f64)]}\n            }else {\n                Suspects::Some{suspects: vec![(-b + s) / (a * 2_f64), (-b - s) / (a * 2_f64)]}\n            }\n        }\n    }\n}\n\nfn flatten<T>(vec: &Vec<Vec<T>>) -> Vec<T> where T: Clone + Copy {\n    let mut count = 0;\n    for v in vec {\n        count += v.len();\n    }\n    let mut result = Vec::with_capacity(count);\n    for v in vec {\n        for &f in v {\n            result.push(f);\n        }\n    }\n    result\n}\nfn lower_bound(vec: &Vec<f64>, target: &f64) -> usize {\n    let mut left = 0;\n    let mut right = vec.len();\n    while left < right {\n        let mid = (left + right) / 2;\n        if vec[mid] < *target {\n            left = mid + 1;\n        }else {\n            right = mid;\n        }\n    }\n    right\n}\nfn upper_bound(vec: &Vec<f64>, target: &f64) -> usize {\n    let mut left = 0;\n    let mut right = vec.len();\n    while left < right {\n        let mid = (left + right) / 2;\n        if vec[mid] <= *target {\n            left = mid + 1;\n        }else {\n            right = mid;\n        }\n    }\n    right\n}\nfn show<T>(vec: &Vec<T>) where T: Display {\n    if vec.is_empty() {\n        println!(\"[]\")\n    }else {\n        print!(\"[{}\", vec.first().unwrap());\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nfn solve(person: &Vec<Person>) -> usize {\n    const EPS: f64 = 0.000001;\n    let mut max = 0;\n    for &a in person.iter() {\n        let mut count =0;\n        for &b in person.iter() {\n            if a == b {\n                count += 1;\n            }\n        }\n        if max < count {\n            max = count;\n        }\n    }\n    for a in 0 .. person.len() {\n        for b in 0 .. a {\n            if person[a] != person[b] {\n                let mut count = 2;\n                let mut suspects = Vec::new();\n                for c in 0..person.len() {\n                    if a != c && b != c {\n                        match find_on_line_time(&person[a], &person[b], &person[c]) {\n                            Suspects::All => {\n                                count += 1;\n                            },\n                            Suspects::None => {}\n                            Suspects::Some { suspects: vec } => {\n                                suspects.push(vec)\n                            },\n                        }\n                    }\n                }\n                let mut suspects = flatten(&suspects);\n                suspects.sort_by(|a, b| a.partial_cmp(b).unwrap());\n                let suspects = suspects;\n                if count > max {\n                    max = count;\n                }\n                for &s in &suspects {\n                    match person[a].position_at(s) - person[b].position_at(s) {\n                        PointF { x: x, y: y } if x.abs() >= EPS || y.abs() >= EPS => {\n                            let\n                                c = upper_bound(&suspects, &(s + EPS)) - lower_bound(&suspects, &s);\n                            if count + c > max {\n                                max = count + c;\n                            }\n                        }\n                        _ => {\n                            if count + 1 > max {\n                                max = count + 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    max\n}\n"
  }
]