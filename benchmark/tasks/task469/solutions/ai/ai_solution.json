[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX_N 1000\n#define EPS 1e-9\n\ntypedef struct {\n    double x, y, u, v;\n} Person;\n\nPerson people[MAX_N];\nint n;\n\ndouble cross_product(double x1, double y1, double x2, double y2) {\n    return x1 * y2 - x2 * y1;\n}\n\nint count_apples_on_line(double px, double py, double dx, double dy) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        double x = people[i].x, y = people[i].y;\n        double u = people[i].u, v = people[i].v;\n        \n        double t = -(px * u + py * v - x * u - y * v) / (u * u + v * v);\n        if (t < 0) continue;\n        \n        double intersect_x = x + u * t;\n        double intersect_y = y + v * t;\n        \n        double cross = cross_product(dx, dy, intersect_x - px, intersect_y - py);\n        if (fabs(cross) < EPS) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint solve() {\n    int max_apples = 0;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            double x1 = people[i].x, y1 = people[i].y;\n            double x2 = people[j].x, y2 = people[j].y;\n            double u1 = people[i].u, v1 = people[i].v;\n            double u2 = people[j].u, v2 = people[j].v;\n            \n            double t1 = -(x1 * u2 + y1 * v2 - x2 * u2 - y2 * v2) / (u2 * u2 + v2 * v2);\n            double t2 = -(x2 * u1 + y2 * v1 - x1 * u1 - y1 * v1) / (u1 * u1 + v1 * v1);\n            \n            if (t1 < 0 || t2 < 0) continue;\n            \n            double px1 = x1 + u1 * t1;\n            double py1 = y1 + v1 * t1;\n            double px2 = x2 + u2 * t2;\n            double py2 = y2 + v2 * t2;\n            \n            double dx = px2 - px1;\n            double dy = py2 - py1;\n            \n            int curr_apples = count_apples_on_line(px1, py1, dx, dy);\n            max_apples = fmax(max_apples, curr_apples);\n        }\n    }\n    \n    return max_apples;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf %lf %lf\", &people[i].x, &people[i].y, &people[i].u, &people[i].v);\n    }\n    \n    printf(\"%d\\n\", solve());\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:47:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    long long x, y, u, v;\n} Person;\n\nint compare(const void *a, const void *b) {\n    Person *p1 = (Person *)a;\n    Person *p2 = (Person *)b;\n    long long cross = p1->u * p2->v - p1->v * p2->u;\n    if (cross != 0) return (cross > 0) ? 1 : -1;\n    long long dot = p1->u * p2->u + p1->v * p2->v;\n    if (dot < 0) return (p1->u * p1->u + p1->v * p1->v) > (p2->u * p2->u + p2->v * p2->v) ? 1 : -1;\n    long long det = (p1->x * p2->v - p1->y * p2->u) - (p2->x * p1->v - p2->y * p1->u);\n    if (det != 0) return (det > 0) ? 1 : -1;\n    return 0;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Person *people = (Person *)malloc(N * sizeof(Person));\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%lld %lld %lld %lld\", &people[i].x, &people[i].y, &people[i].u, &people[i].v);\n    }\n\n    int max_count = 1;\n    if (N == 0) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        Person *temp = (Person *)malloc(N * sizeof(Person));\n        int k = 0;\n        for (int j = 0; j < N; ++j) {\n            if (i == j) continue;\n            temp[k].x = people[j].x - people[i].x;\n            temp[k].y = people[j].y - people[i].y;\n            temp[k].u = people[j].u - people[i].u;\n            temp[k].v = people[j].v - people[i].v;\n            k++;\n        }\n\n        qsort(temp, k, sizeof(Person), compare);\n\n        int current = 1;\n        for (int j = 1; j < k; ++j) {\n            long long cross = temp[j-1].u * temp[j].v - temp[j-1].v * temp[j].u;\n            long long det = (temp[j-1].x * temp[j].v - temp[j-1].y * temp[j].u) - (temp[j].x * temp[j-1].v - temp[j].y * temp[j-1].u);\n            if (cross == 0 && det == 0) {\n                current++;\n            } else {\n                if (current + 1 > max_count) {\n                    max_count = current + 1;\n                }\n                current = 1;\n            }\n        }\n        if (current + 1 > max_count) {\n            max_count = current + 1;\n        }\n        free(temp);\n    }\n\n    printf(\"%d\\n\", max_count);\n    free(people);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:48:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    long long x, y;\n    Point(long long x = 0, long long y = 0) : x(x), y(y) {}\n    bool operator<(const Point& other) const {\n        if (x != other.x) return x < other.x;\n        return y < other.y;\n    }\n};\n\nstruct Line {\n    long long a, b, c; // ax + by + c = 0\n    Line(long long a = 0, long long b = 0, long long c = 0) : a(a), b(b), c(c) {}\n    bool operator<(const Line& other) const {\n        if (a != other.a) return a < other.a;\n        if (b != other.b) return b < other.b;\n        return c < other.c;\n    }\n};\n\nlong long gcd(long long a, long long b) {\n    while (b) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\nLine getLine(Point p1, Point p2) {\n    long long a = p1.y - p2.y;\n    long long b = p2.x - p1.x;\n    long long c = p1.x * p2.y - p2.x * p1.y;\n    \n    long long g = gcd(abs(a), gcd(abs(b), abs(c)));\n    a /= g;\n    b /= g;\n    c /= g;\n    \n    if (a < 0 || (a == 0 && b < 0)) {\n        a = -a;\n        b = -b;\n        c = -c;\n    }\n    \n    return Line(a, b, c);\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Point> initial(N);\n    vector<Point> velocity(N);\n    \n    for (int i = 0; i < N; ++i) {\n        cin >> initial[i].x >> initial[i].y >> velocity[i].x >> velocity[i].y;\n    }\n    \n    if (N == 1) {\n        cout << 1 << endl;\n        return 0;\n    }\n    \n    int max_apples = 1;\n    \n    for (int i = 0; i < N; ++i) {\n        map<Line, int> line_counts;\n        for (int j = 0; j < N; ++j) {\n            if (i == j) continue;\n            long long dx = velocity[j].x - velocity[i].x;\n            long long dy = velocity[j].y - velocity[i].y;\n            if (dx == 0 && dy == 0) {\n                if (initial[i].x == initial[j].x && initial[i].y == initial[j].y) {\n                    max_apples = max(max_apples, N);\n                    break;\n                } else {\n                    continue;\n                }\n            }\n            Point p1(initial[i].x - initial[j].x, initial[i].y - initial[j].y);\n            Point p2(dy, -dx);\n            Line line = getLine(p1, p2);\n            line_counts[line]++;\n        }\n        for (auto& entry : line_counts) {\n            max_apples = max(max_apples, entry.second + 1);\n        }\n    }\n    \n    cout << max_apples << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:49:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Apples {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] x = new int[N];\n        int[] y = new int[N];\n        int[] u = new int[N];\n        int[] v = new int[N];\n        \n        for (int i = 0; i < N; i++) {\n            x[i] = scanner.nextInt();\n            y[i] = scanner.nextInt();\n            u[i] = scanner.nextInt();\n            v[i] = scanner.nextInt();\n        }\n        \n        Map<String, Integer> lines = new HashMap<>();\n        int maxCount = 1;\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int a = u[i] - u[j];\n                int b = v[i] - v[j];\n                int c = x[i] - x[j];\n                int d = y[i] - y[j];\n                \n                int g = gcd(gcd(a, b), gcd(c, d));\n                if (g != 0) {\n                    a /= g;\n                    b /= g;\n                    c /= g;\n                    d /= g;\n                }\n                \n                if (a < 0 || (a == 0 && b < 0)) {\n                    a = -a;\n                    b = -b;\n                    c = -c;\n                    d = -d;\n                }\n                \n                String key = a + \",\" + b + \",\" + c + \",\" + d;\n                lines.put(key, lines.getOrDefault(key, 0) + 1);\n                int current = lines.get(key);\n                if (current + 1 > maxCount) {\n                    maxCount = current + 1;\n                }\n            }\n        }\n        \n        System.out.println(maxCount);\n    }\n    \n    private static int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}",
    "timestamp": "2025-08-05 21:49:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class AppleShooting {\n    static class Point {\n        long x, y;\n        Point(long x, long y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static class Person {\n        Point start;\n        long u, v;\n        Person(long x, long y, long u, long v) {\n            this.start = new Point(x, y);\n            this.u = u;\n            this.v = v;\n        }\n    }\n\n    public static int maxApples(Person[] people) {\n        int n = people.length;\n        int maxApples = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                // Try every pair of people as potential bullet line\n                maxApples = Math.max(maxApples, countHits(people, i, j));\n            }\n        }\n\n        return maxApples;\n    }\n\n    static int countHits(Person[] people, int p1, int p2) {\n        List<Double> hitTimes = new ArrayList<>();\n\n        // Compute the line through these two people's trajectories\n        for (int k = 0; k < people.length; k++) {\n            Double t = intersectionTime(people[p1], people[p2], people[k]);\n            if (t != null) {\n                hitTimes.add(t);\n            }\n        }\n\n        // Count unique hit times\n        return new HashSet<>(hitTimes).size();\n    }\n\n    static Double intersectionTime(Person line1, Person line2, Person target) {\n        // Line of bullet passes through two people:\n        // (x1 + t*u1, y1 + t*v1) and (x2 + s*u2, y2 + s*v2)\n        // Target moves as (xt + k*u, yt + k*v)\n        long x1 = line1.start.x, y1 = line1.start.y;\n        long u1 = line1.u, v1 = line1.v;\n        long x2 = line2.start.x, y2 = line2.start.y;\n        long u2 = line2.u, v2 = line2.v;\n        long xt = target.start.x, yt = target.start.y;\n        long ut = target.u, vt = target.v;\n\n        // Solve line equations to find intersection time\n        try {\n            // Compute line parameters\n            long a = u2 * v1 - u1 * v2;\n            if (a == 0) return null; // Parallel lines\n\n            // Detailed time computation\n            double t = ((x2 - x1) * v1 - (y2 - y1) * u1) / a;\n            double k = ((x2 - xt) * v1 - (y2 - yt) * u1) / a;\n\n            // Check if time is valid and point is on the line\n            if (t >= 0 && k >= 0 \n                && Math.abs((x1 + t * u1) - (xt + k * ut)) < 1e-9 \n                && Math.abs((y1 + t * v1) - (yt + k * vt)) < 1e-9) {\n                return t;\n            }\n        } catch (Exception e) {\n            return null;\n        }\n        return null;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        Person[] people = new Person[n];\n\n        for (int i = 0; i < n; i++) {\n            String[] parts = br.readLine().split(\" \");\n            long x = Long.parseLong(parts[0]);\n            long y = Long.parseLong(parts[1]);\n            long u = Long.parseLong(parts[2]);\n            long v = Long.parseLong(parts[3]);\n            people[i] = new Person(x, y, u, v);\n        }\n\n        System.out.println(maxApples(people));\n    }\n}",
    "timestamp": "2025-08-05 21:50:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    \n    Point operator+(const Point& p) const {\n        return Point(x + p.x, y + p.y);\n    }\n    \n    Point operator-(const Point& p) const {\n        return Point(x - p.x, y - p.y);\n    }\n};\n\nstruct Apple {\n    Point start, vel;\n    Apple(double x, double y, double u, double v) : \n        start(x, y), vel(u, v) {}\n    \n    Point posAt(double t) const {\n        return Point(start.x + t * vel.x, start.y + t * vel.y);\n    }\n};\n\ndouble cross(const Point& a, const Point& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool isParallel(const Point& a, const Point& b) {\n    return abs(cross(a, b)) < EPS;\n}\n\nbool lineIntersectsApple(const Point& origin, const Point& dir, const Apple& apple, double& t) {\n    Point p0 = origin;\n    Point p1 = apple.start;\n    Point v = apple.vel;\n    Point d = dir;\n    \n    double denom = cross(d, v);\n    \n    if (abs(denom) < EPS) {\n        Point diff = p1 - p0;\n        return abs(cross(diff, d)) < EPS;\n    }\n    \n    t = cross(p1 - p0, v) / denom;\n    Point intersect = p0 + Point(t * d.x, t * d.y);\n    Point applePos = apple.posAt(t);\n    \n    return abs(intersect.x - applePos.x) < EPS && \n           abs(intersect.y - applePos.y) < EPS && \n           t >= 0;\n}\n\nint maxApplesShot(const vector<Apple>& apples) {\n    int n = apples.size();\n    int maxApples = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            Point dir = apples[j].start - apples[i].start;\n            \n            set<int> hitApples;\n            for (int k = 0; k < n; ++k) {\n                double t;\n                if (lineIntersectsApple(apples[i].start, dir, apples[k], t)) {\n                    hitApples.insert(k);\n                }\n            }\n            \n            maxApples = max(maxApples, (int)hitApples.size());\n        }\n    }\n    \n    return maxApples;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<Apple> apples;\n    for (int i = 0; i < N; ++i) {\n        double x, y, u, v;\n        cin >> x >> y >> u >> v;\n        apples.emplace_back(x, y, u, v);\n    }\n    \n    cout << maxApplesShot(apples) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:50:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\nfrom collections import defaultdict\n\ndef max_apples(N, positions, velocities):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    max_shots = 1\n\n    for i in range(N):\n        x1, y1, u1, v1 = positions[i][0], positions[i][1], velocities[i][0], velocities[i][1]\n        slopes = defaultdict(int)\n\n        for j in range(N):\n            if i == j:\n                continue\n\n            x2, y2, u2, v2 = positions[j][0], positions[j][1], velocities[j][0], velocities[j][1]\n            dx = (x2 - x1)\n            dy = (y2 - y1)\n            dvx = (u2 - u1)\n            dvy = (v2 - v1)\n\n            # To avoid division by zero, handle special cases\n            if dvx == 0 and dvy == 0:\n                slope = (0, 0)\n            elif dvx == 0:\n                slope = (float('inf'), float('inf'))\n            elif dvy == 0:\n                slope = (0, float('inf'))\n            else:\n                gcd_dvx_dvy = gcd(dvx, dvy)\n                slope = (dvx // gcd_dvx_dvy, dvy // gcd_dvx_dvy)\n\n            slopes[slope] += 1\n\n        if slopes:\n            max_shots = max(max_shots, max(slopes.values()) + 1)\n\n    return max_shots\n\n# Example usage:\nN = 4\npositions = [(0, 0), (1, 1), (2, 2), (3, 3)]\nvelocities = [(1, 1), (1, 1), (1, 1), (1, 1)]\nprint(max_apples(N, positions, velocities))",
    "timestamp": "2025-08-13 07:37:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Apples {\n    static class Person {\n        double x, y, u, v;\n        \n        Person(double x, double y, double u, double v) {\n            this.x = x;\n            this.y = y;\n            this.u = u;\n            this.v = v;\n        }\n    }\n    \n    public static int maxApples(int N, Person[] people) {\n        int maxApples = 0;\n        \n        // Compare every pair of people\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                Set<Double> times = new HashSet<>();\n                \n                // Calculate potential times for a line\n                for (int k = 0; k < N; k++) {\n                    if (i == k || j == k) continue;\n                    \n                    double dx1 = people[k].x - people[i].x;\n                    double dy1 = people[k].y - people[i].y;\n                    double dx2 = people[k].x - people[j].x;\n                    double dy2 = people[k].y - people[j].y;\n                    \n                    double vx1 = people.k.u - people[i].u;\n                    double vy1 = people.k.v - people.i.v;\n                    double vx2 = people.k.u - people[j].u;\n                    double vy2 = people.k.v - people.j.v;\n                    \n                    // Avoid division by zero & avoid overlapping situations\n                    double crossProduct1 = vx1 * dy1 - vy1 * dx1;\n                    double crossProduct2 = vx2 * dy2 - vy2 * dx2;\n                    \n                    if (crossProduct1 == 0.0 && crossProduct2 == 0.0) {\n                        if ((dx1 * vx1 < 0 || dx2 * vx2 < 0) || (dy1 * vy1 < 0 || dy2 * vy2 < 0)) {\n                            continue;\n                        }\n                        \n                        double t1 = -1.0;\n                        if (vx1 != 0) t1 = dx1 / vx1;\n                        if (vx2 != 0) t1 = dx2 / vx2;\n                        if (t1 < 0) continue;\n                        \n                        times.add(t1);\n                    }\n                }\n                \n                for (double t : times) {\n                    List<Double> angles = new ArrayList<>();\n                    \n                    for (int k = 0; k < N; k++) {\n                        double cx = people[k].x + t * people[k].u;\n                        double cy = people[k].y + t * people[k].v;\n                        double angle = Math.atan2(cy - people[i].y, cx - people[i].x);\n                        angles.add(angle);\n                    }\n                    \n                    Collections.sort(angles);\n                    \n                    int count = 1, maxCount = 1;\n                    \n                    for (int k = 1; k < angles.size(); k++) {\n                        if (Math.abs(angles.get(k) - angles.get(k - 1)) < 1e-9) {\n                            count++;\n                        } else {\n                            maxCount = Math.max(maxCount, count);\n                            count = 1;\n                        }\n                    }\n                    \n                    maxCount = Math.max(maxCount, count);\n                    \n                    maxApples = Math.max(maxApples, maxCount);\n                }\n            }\n        }\n        \n        return maxApples;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        Person[] people = new Person[N];\n        \n        for (int i = 0; i < N; i++) {\n            double x = scanner.nextDouble();\n            double y = scanner.nextDouble();\n            double u = scanner.nextDouble();\n            double v = scanner.nextDouble();\n            people[i] = new Person(x, y, u, v);\n        }\n        \n        System.out.println(maxApples(N, people));\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 07:37:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    int x, y;\n    int u, v;\n} Person;\n\ndouble calculate_slope(double x1, double y1, double x2, double y2) {\n    return (y2 - y1) / (x2 - x1);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Person people[n];\n    \n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d %d %d %d\", &people[i].x, &people[i].y, &people[i].u, &people[i].v);\n    }\n    \n    int max_apples = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double slope;\n            if (people[i].u == people[j].u && people[i].v == people[j].v) {\n                slope = INFINITY;\n            } else {\n                slope = calculate_slope(\n                    people[i].x, people[i].y, \n                    people[j].x + people[i].u - people[j].u, \n                    people[j].y + people[i].v - people[j].v\n                );\n            }\n            \n            int count = 0;\n            for (int k = 0; k < n; ++k) {\n                double x = people[k].x + people[i].u * slope;\n                double y = people[k].y + people[i].v * slope;\n                \n                if (fabs((people[i].v - people[k].v) * (x - people[i].x) - \n                         (people[i].u - people[k].u) * (y - people[i].y)) < 1e-9) {\n                    ++count;\n                }\n            }\n            \n            if (count > max_apples) {\n                max_apples = count;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", max_apples);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 07:37:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_apples_shot(N, positions, velocities):\n    max_apples = 0\n    for i in range(N):\n        for j in range(N):\n            # Check line through two apple positions\n            x1, y1 = positions[i]\n            x2, y2 = positions[j]\n            \n            # Try shooting at different times\n            for t in range(N):\n                current_hit = 0\n                for k in range(N):\n                    # Calculate apple position at time t\n                    x = positions[k][0] + t * velocities[k][0]\n                    y = positions[k][1] + t * velocities[k][1]\n                    \n                    # Check if apple is on line between first two points\n                    if is_point_on_line((x1, y1), (x2, y2), (x, y)):\n                        current_hit += 1\n                \n                max_apples = max(max_apples, current_hit)\n    \n    return max_apples\n\ndef is_point_on_line(p1, p2, p3):\n    # Check if point is on line using cross product method\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    \n    return abs((x2-x1)*(y3-y1) - (y2-y1)*(x3-x1)) < 1e-9\n\n# Input parsing\nN = int(input())\npositions = []\nvelocities = []\n\nfor _ in range(N):\n    x, y, u, v = map(int, input().split())\n    positions.append((x, y))\n    velocities.append((u, v))\n\n# Output result\nprint(max_apples_shot(N, positions, velocities))",
    "timestamp": "2025-08-13 07:37:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    N = int(sys.stdin.readline())\n    lines = defaultdict(int)\n    \n    for _ in range(N):\n        x, y, u, v = map(int, sys.stdin.readline().split())\n        # Direction vector is (u, v), but we need the reduced form\n        # The line equation is v*(X - x) - u*(Y - y) = 0\n        # Which is vX - uY = vx - uy\n        # To represent the line uniquely, we can use the coefficients (v, -u, vx - uy)\n        # But we need to normalize them to avoid duplicates like (2v, -2u, 2(vx - uy))\n        # Compute the greatest common divisor (gcd) of v, -u, and (vx - uy)\n        a = v\n        b = -u\n        c = v * x - u * y\n        \n        # Compute the gcd of a, b, c\n        def compute_gcd(a, b):\n            while b:\n                a, b = b, a % b\n            return a\n        \n        gcd_ab = compute_gcd(abs(a), abs(b))\n        gcd_abc = compute_gcd(gcd_ab, abs(c))\n        \n        # Normalize the coefficients\n        a //= gcd_abc\n        b //= gcd_abc\n        c //= gcd_abc\n        \n        # Ensure the first non-zero coefficient is positive\n        first_non_zero = 0\n        if a != 0:\n            first_non_zero = a\n        elif b != 0:\n            first_non_zero = b\n        else:\n            first_non_zero = c\n        \n        if first_non_zero < 0:\n            a = -a\n            b = -b\n            c = -c\n        \n        lines[(a, b, c)] += 1\n    \n    if not lines:\n        print(0)\n    else:\n        print(max(lines.values()))\n\nsolve()",
    "timestamp": "2025-08-13 07:39:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Person {\n    double x, y, u, v;\n};\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Person> people(N);\n\n    for (int i = 0; i < N; ++i) {\n        cin >> people[i].x >> people[i].y >> people[i].u >> people[i].v;\n    }\n\n    int max_apples = 1;\n\n    for (int i = 0; i < N; ++i) {\n        map<pair<double, double>, int> slope_count;\n\n        for (int j = 0; j < N; ++j) {\n            if (i != j) {\n                double dx = people[j].x - people[i].x;\n                double dy = people[j].y - people[i].y;\n                double d_u = people[j].u - people[i].u;\n                double d_v = people[j].v - people[i].v;\n\n                double t1_numer = dy * d_u - dx * d_v;\n                double t1_denom = d_v * people[j].u - d_u * people[j].v;\n\n                double alpha, beta;\n                if (t1_denom != 0) {\n                    alpha = t1_numer / t1_denom;\n                } else {\n                    alpha = d_u * t1_numer + dx;\n                    beta = d_v * t1_numer + dy;\n                }\n\n                // Normalize alpha and beta to represent the same direction\n                if (beta < 0 || (beta == 0 && alpha < 0)) {\n                    alpha = -alpha;\n                    beta = -beta;\n                }\n                \n                double gcd_value = abs(__gcd((int)alpha, (int)beta));\n\n                if (gcd_value != 0) {\n                    alpha /= gcd_value;\n                    beta /= gcd_value;\n                }\n\n                slope_count[{alpha, beta}]++;\n            }\n        }\n\n        for (auto& pr : slope_count) {\n            max_apples = max(max_apples, pr.second + 1);\n        }\n    }\n\n    cout << max_apples << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:39:59"
  }
]