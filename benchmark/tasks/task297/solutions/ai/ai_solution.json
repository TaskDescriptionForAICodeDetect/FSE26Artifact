[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint count = 0;\nint max_height;\n\nvoid backtrack(int *documents, int n, int *pile1, int top1, int *pile2, int top2, int index) {\n    if (index == n) {\n        count++;\n        return;\n    }\n    \n    int current = documents[index];\n    \n    if (top1 < max_height && (top1 == -1 || pile1[top1] > current)) {\n        pile1[top1 + 1] = current;\n        backtrack(documents, n, pile1, top1 + 1, pile2, top2, index + 1);\n    }\n    \n    if (top2 < max_height && (top2 == -1 || pile2[top2] > current)) {\n        pile2[top2 + 1] = current;\n        backtrack(documents, n, pile1, top1, pile2, top2 + 1, index + 1);\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d %d\", &n, &max_height);\n    int documents[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &documents[i]);\n    }\n    \n    int pile1[max_height], pile2[max_height];\n    backtrack(documents, n, pile1, -1, pile2, -1, 0);\n    \n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:58:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nint count = 0;\n\nvoid backtrack(int pos, stack<int> mainStack, stack<int> pile1, stack<int> pile2, int maxHeight) {\n    if (pos == 0) {\n        count++;\n        return;\n    }\n\n    if (!pile1.empty() && mainStack.top() < pile1.top() && pile1.size() < maxHeight) {\n        stack<int> newPile1 = pile1;\n        stack<int> newMainStack = mainStack;\n        newPile1.push(newMainStack.top());\n        newMainStack.pop();\n        backtrack(pos - 1, newMainStack, newPile1, pile2, maxHeight);\n    } else if (pile1.empty() && pile1.size() < maxHeight) {\n        stack<int> newPile1 = pile1;\n        stack<int> newMainStack = mainStack;\n        newPile1.push(newMainStack.top());\n        newMainStack.pop();\n        backtrack(pos - 1, newMainStack, newPile1, pile2, maxHeight);\n    }\n\n    if (!pile2.empty() && mainStack.top() < pile2.top() && pile2.size() < maxHeight) {\n        stack<int> newPile2 = pile2;\n        stack<int> newMainStack = mainStack;\n        newPile2.push(newMainStack.top());\n        newMainStack.pop();\n        backtrack(pos - 1, newMainStack, pile1, newPile2, maxHeight);\n    } else if (pile2.empty() && pile2.size() < maxHeight) {\n        stack<int> newPile2 = pile2;\n        stack<int> newMainStack = mainStack;\n        newPile2.push(newMainStack.top());\n        newMainStack.pop();\n        backtrack(pos - 1, newMainStack, pile1, newPile2, maxHeight);\n    }\n}\n\nint main() {\n    int N, H;\n    cin >> N >> H;\n    vector<int> documents(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> documents[i];\n    }\n\n    stack<int> mainStack;\n    for (int i = N - 1; i >= 0; --i) {\n        mainStack.push(documents[i]);\n    }\n\n    stack<int> pile1, pile2;\n    backtrack(N, mainStack, pile1, pile2, H);\n    cout << count << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:58:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DocumentStacking {\n    private static int count = 0;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int H = scanner.nextInt();\n        int[] documents = new int[N];\n        for (int i = 0; i < N; i++) {\n            documents[i] = scanner.nextInt();\n        }\n        count = 0;\n        Stack<Integer> pile1 = new Stack<>();\n        Stack<Integer> pile2 = new Stack<>();\n        backtrack(documents, 0, pile1, pile2, H);\n        System.out.println(count);\n    }\n\n    private static void backtrack(int[] documents, int index, Stack<Integer> pile1, Stack<Integer> pile2, int H) {\n        if (index == documents.length) {\n            count++;\n            return;\n        }\n\n        int doc = documents[index];\n        if (pile1.isEmpty() || doc < pile1.peek()) {\n            if (pile1.size() < H) {\n                pile1.push(doc);\n                backtrack(documents, index + 1, pile1, pile2, H);\n                pile1.pop();\n            }\n        }\n        if (pile2.isEmpty() || doc < pile2.peek()) {\n            if (pile2.size() < H) {\n                pile2.push(doc);\n                backtrack(documents, index + 1, pile1, pile2, H);\n                pile2.pop();\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 20:59:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DocumentStacking {\n    public static int countStackingWays(int[] documents, int maxPileHeight) {\n        int n = documents.length;\n        int[][] dp = new int[n + 1][maxPileHeight + 1];\n        dp[0][0] = 1;\n\n        for (int i = 1; i <= n; i++) {\n            for (int h1 = 0; h1 <= maxPileHeight; h1++) {\n                for (int h2 = 0; h2 <= maxPileHeight; h2++) {\n                    if (h1 + h2 >= i) continue;\n\n                    for (int take = 1; take <= i; take++) {\n                        if (h1 + take > maxPileHeight || h2 + (i - take) > maxPileHeight) continue;\n\n                        boolean validPile1 = isPileValid(documents, 0, take, true);\n                        boolean validPile2 = isPileValid(documents, take, i, false);\n\n                        if (validPile1 && validPile2) {\n                            dp[i][h1 + h2] += dp[i - take][h1];\n                        }\n                    }\n                }\n            }\n        }\n\n        int totalWays = 0;\n        for (int h = 0; h <= maxPileHeight; h++) {\n            totalWays += dp[n][h];\n        }\n\n        return totalWays;\n    }\n\n    private static boolean isPileValid(int[] documents, int start, int length, boolean ascending) {\n        for (int i = start; i < start + length - 1; i++) {\n            if (ascending) {\n                if (documents[i] > documents[i + 1]) return false;\n            } else {\n                if (documents[i] < documents[i + 1]) return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[] documents = {3, 1, 2};\n        int maxPileHeight = 2;\n        System.out.println(countStackingWays(documents, maxPileHeight));\n    }\n}",
    "timestamp": "2025-08-05 20:59:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint countStackingWays(int documents[], int n, int maxHeight) {\n    int dp[2][maxHeight + 1][maxHeight + 1];\n    memset(dp, 0, sizeof(dp));\n    dp[0][0][0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        int curr = i % 2;\n        int prev = (i - 1) % 2;\n        memset(dp[curr], 0, sizeof(dp[curr]));\n\n        for (int p1 = 0; p1 <= maxHeight; p1++) {\n            for (int p2 = 0; p2 <= maxHeight; p2++) {\n                if (dp[prev][p1][p2] == 0) continue;\n\n                // Place in first pile\n                if (p1 < maxHeight && (p1 == 0 || documents[i-1] < documents[p1-1])) {\n                    dp[curr][p1+1][p2] += dp[prev][p1][p2];\n                }\n\n                // Place in second pile\n                if (p2 < maxHeight && (p2 == 0 || documents[i-1] < documents[p2-1])) {\n                    dp[curr][p1][p2+1] += dp[prev][p1][p2];\n                }\n            }\n        }\n    }\n\n    int ways = 0;\n    for (int p1 = 0; p1 <= maxHeight; p1++) {\n        for (int p2 = 0; p2 <= maxHeight; p2++) {\n            ways += dp[n%2][p1][p2];\n        }\n    }\n\n    return ways;\n}\n\nint main() {\n    int n, maxHeight;\n    scanf(\"%d %d\", &n, &maxHeight);\n    \n    int documents[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &documents[i]);\n    }\n\n    printf(\"%d\\n\", countStackingWays(documents, n, maxHeight));\n    return 0;\n}",
    "timestamp": "2025-08-05 20:59:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int countStackingWays(vector<int>& documents, int maxHeight) {\n        int n = documents.size();\n        vector<vector<vector<int>>> dp(n + 1, \n            vector<vector<int>>(maxHeight + 1, \n                vector<int>(maxHeight + 1, 0)));\n        \n        dp[0][0][0] = 1;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int h1 = 0; h1 <= maxHeight; h1++) {\n                for (int h2 = 0; h2 <= maxHeight; h2++) {\n                    // Skip if current configuration impossible\n                    if (dp[i-1][h1][h2] == 0) continue;\n                    \n                    // Place document in first pile\n                    if (h1 < maxHeight) {\n                        dp[i][h1+1][h2] += dp[i-1][h1][h2];\n                    }\n                    \n                    // Place document in second pile\n                    if (h2 < maxHeight) {\n                        dp[i][h1][h2+1] += dp[i-1][h1][h2];\n                    }\n                }\n            }\n        }\n        \n        int totalWays = 0;\n        for (int h1 = 0; h1 <= maxHeight; h1++) {\n            for (int h2 = 0; h2 <= maxHeight; h2++) {\n                totalWays += dp[n][h1][h2];\n            }\n        }\n        \n        return totalWays;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector<int> documents = {3, 1, 2};\n    int maxHeight = 2;\n    cout << sol.countStackingWays(documents, maxHeight) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 20:59:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_reordering_ways(documents, max_height):\n    def backtrack(i, pile1, pile2):\n        if i == len(documents):\n            return 1 if not pile1 or not pile2 or min(pile1) > max(pile2) else 0\n        \n        count = 0\n\n        # Try to add document to pile1\n        if len(pile1) < max_height and (not pile1 or documents[i] <= pile1[-1]):\n            count += backtrack(i + 1, pile1 + [documents[i]], pile2)\n\n        # Try to add document to pile2\n        if len(pile2) < max_height and (not pile2 or documents[i] <= pile2[-1]):\n            count += backtrack(i + 1, pile1, pile2 + [documents[i]])\n        \n        return count\n    \n    return backtrack(0, [], [])\n\n# Example use\ndocuments = [4, 3, 2, 1]\nmax_height = 3\nprint(count_reordering_ways(documents, max_height))",
    "timestamp": "2025-08-13 04:22:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class DocumentReordering {\n    \n    public static int countWaysToReorder(int[] documents, int maxPileHeight) {\n        return countWays(documents, 0, new Stack<>(), new Stack<>(), maxPileHeight);\n    }\n\n    private static int countWays(int[] documents, int index, Stack<Integer> pile1, Stack<Integer> pile2, int maxPileHeight) {\n        if (index == documents.length) {\n            return 1;\n        }\n        \n        int count = 0;\n        \n        if (pile1.isEmpty() || (!pile1.isEmpty() && pile1.peek() > documents[index])) {\n            pile1.push(documents[index]);\n            if (pile1.size() <= maxPileHeight) {\n                count += countWays(documents, index + 1, pile1, pile2, maxPileHeight);\n            }\n            pile1.pop();\n        }\n        \n        if (pile2.isEmpty() || (!pile2.isEmpty() && pile2.peek() > documents[index])) {\n            pile2.push(documents[index]);\n            if (pile2.size() <= maxPileHeight) {\n                count += countWays(documents, index + 1, pile1, pile2, maxPileHeight);\n            }\n            pile2.pop();\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        int[] documents = {4, 3, 2, 1};\n        int maxPileHeight = 2; // Example value; adjust according to requirements\n        int result = countWaysToReorder(documents, maxPileHeight);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 04:22:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint countWays(int* stack, int n, int maxHeight, int pile1Height, int pile2Height, int index, int* memo) {\n    if (index == n) {\n        return 1;\n    }\n    \n    int key = index * (maxHeight + 1) * (maxHeight + 1) + pile1Height * (maxHeight + 1) + pile2Height;\n    if (memo[key] != -1) {\n        return memo[key];\n    }\n    \n    int ways = 0;\n    \n    if (pile1Height < maxHeight) {\n        ways += countWays(stack, n, maxHeight, pile1Height + 1, pile2Height, index + 1, memo);\n    }\n    \n    if (pile2Height < maxHeight) {\n        ways += countWays(stack, n, maxHeight, pile1Height, pile2Height + 1, index + 1, memo);\n    }\n    \n    memo[key] = ways;\n    return ways;\n}\n\nint numberOfWaysToStackDocuments(int* stack, int n, int maxHeight) {\n    int* memo = (int*)malloc((n+1) * (maxHeight+1) * (maxHeight+1) * sizeof(int));\n    for (int i = 0; i < (n+1) * (maxHeight+1) * (maxHeight+1); i++) {\n        memo[i] = -1;\n    }\n    int ways = countWays(stack, n, maxHeight, 0, 0, 0, memo);\n    free(memo);\n    return ways;\n}\n\nint main() {\n    int stack[] = {1, 2, 3}; // Example stack\n    int n = sizeof(stack) / sizeof(stack[0]);\n    int maxHeight = 3; // Example max height\n    int result = numberOfWaysToStackDocuments(stack, n, maxHeight);\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 04:22:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_stacking_ways(documents, max_height):\n    n = len(documents)\n    \n    def is_valid_order(pile):\n        return all(pile[i] < pile[i+1] for i in range(len(pile)-1))\n    \n    def backtrack(index, pile1, pile2):\n        if index == n:\n            return 1 if is_valid_order(pile1) and is_valid_order(pile2) else 0\n        \n        if len(pile1) > max_height or len(pile2) > max_height:\n            return 0\n        \n        ways = 0\n        # Try adding to pile 1\n        ways += backtrack(index + 1, pile1 + [documents[index]], pile2)\n        \n        # Try adding to pile 2\n        ways += backtrack(index + 1, pile1, pile2 + [documents[index]])\n        \n        return ways\n    \n    return backtrack(0, [], [])",
    "timestamp": "2025-08-13 04:22:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_ways(documents, max_height):\n    n = len(documents)\n    if n == 0:\n        return 1\n    if max_height <= 0:\n        return 0\n    \n    memo = {}\n    \n    def dfs(top_idx, pile1, pile2_height):\n        if top_idx == n:\n            return 1\n        key = (top_idx, tuple(pile1), pile2_height)\n        if key in memo:\n            return memo[key]\n        \n        total = 0\n        current_doc = documents[top_idx]\n        \n        # Option 1: Place on pile1 if it's empty or current_doc < pile1[-1]\n        if not pile1 or current_doc < pile1[-1]:\n            if len(pile1) < max_height:\n                new_pile1 = pile1 + [current_doc]\n                total += dfs(top_idx + 1, new_pile1, pile2_height)\n        \n        # Option 2: Place on pile2 if it's empty or current_doc < pile2's top\n        # Since pile2 is in reverse order, the top is the last element\n        if pile2_height == 0 or current_doc < documents[top_idx - pile2_height]:\n            if pile2_height < max_height:\n                total += dfs(top_idx + 1, pile1, pile2_height + 1)\n        \n        memo[key] = total\n        return total\n    \n    return dfs(0, [], 0)\n\n# Example usage:\n# documents = [5, 4, 3, 2, 1]\n# max_height = 3\n# print(count_ways(documents, max_height))",
    "timestamp": "2025-08-13 04:22:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// dp function: number of ways to split [0...i] elements, with tops of piles being <= p1 and <= p2.\nint dp(int i, int p1, int p2, vector<int>& documents, vector<vector<vector<int>>>& memo) {\n    if (i < 0) return 1; // base case: successful split\n\n    if (memo[i][p1][p2] != -1) return memo[i][p1][p2];\n\n    int ways = 0;\n    // Option 1: Place current document on pile 1\n    if (documents[i] <= p1) {\n        ways += dp(i - 1, documents[i], p2, documents, memo);\n    }\n    // Option 2: Place current document on pile 2\n    if (documents[i] <= p2) {\n        ways += dp(i - 1, p1, documents[i], documents, memo);\n    }\n    \n    memo[i][p1][p2] = ways;\n    return ways;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> documents(n);\n    for (int i = 0; i < n; i++) {\n        cin >> documents[i];\n    }\n\n    int max_doc = *max_element(documents.begin(), documents.end());\n\n    // initialize memo table with -1 (uncomputed)\n    vector<vector<vector<int>>> memo(n, vector<vector<int>>(max_doc + 1, vector<int>(max_doc + 1, -1)));\n\n    // The tops of piles initially have no documents (-1 is less than any document)\n    int result = dp(n-1, max_doc, max_doc, documents, memo);\n\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:18:55"
  }
]