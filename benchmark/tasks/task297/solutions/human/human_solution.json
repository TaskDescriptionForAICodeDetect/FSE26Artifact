[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define SIZE 5005\n\nll N,M;\nll table[SIZE],rest_min[SIZE];\nll dp[2][SIZE];\n\nint main(){\n\n\tscanf(\"%lld %lld\",&N,&M);\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%lld\",&table[i]);\n\t}\n\n\trest_min[N] = BIG_NUM;\n\tfor(int i = N-1; i >= 0; i--){\n\n\t\trest_min[i] = min(table[i],rest_min[i+1]);\n\t}\n\n\tint CURRENT = 0,NEXT = 1;\n\tint maximum = -1;\n\n\tdp[CURRENT][0] = 1;\n\n\tfor(int i = 0; i <= N-1; i++){\n\n\t\tfor(int k = 0; k <= i+1; k++){\n\n\t\t\tdp[NEXT][k] = 0;\n\t\t}\n\n\t\tif(table[i] > maximum){\n\n\t\t\tfor(int k = 1; k <= i+1; k++){\n\n\t\t\t\tdp[NEXT][k] = dp[CURRENT][k-1];\n\t\t\t}\n\n\t\t\tif(maximum < rest_min[i+1]){\n\t\t\t\tfor(int k = 0; k <= i+1; k++){\n\n\t\t\t\t\tdp[NEXT][k] += dp[CURRENT][i+1-k];\n\t\t\t\t\tdp[NEXT][k] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmaximum = table[i];\n\n\t\t}else if(table[i] == rest_min[i]){\n\n\t\t\tfor(int k = 0; k <= i+1; k++){\n\n\t\t\t\tdp[NEXT][k] = dp[CURRENT][k];\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tswap(CURRENT,NEXT);\n\t}\n\n\tll ans = 0;\n\n\tfor(int i = N-M; i <= M; i++){\n\n\t\tans += dp[CURRENT][i];\n\t\tans %= MOD;\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<assert.h>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstdlib>\n#include<iostream>\n#include<bitset>\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i,j,k) for(int i=(int)(j);i<=(int)(k);i++)\n#define per(i,j,k) for(int i=(int)(j);i>=(int)(k);i--)\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int N=5005;\nconst int P=1000000007;\nint p[N],n,m,col[N];\nint f[N];\nint cnt[2];\nvoid fail(){puts(\"0\");exit(0);}\nvoid dfs(int x){\n\tcnt[col[x]]++;\n\trep(i,x+1,n)if(p[i]<p[x]){\n\t\tif(col[i]!=-1){\n\t\t\tif(col[i]==col[x]){\n\t\t\t\tfail();\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tcol[i]=col[x]^1;\n\t\t\tdfs(i);\n\t\t}\n\t}\n\trep(i,1,x-1)if(p[i]>p[x]){\n\t\tif(col[i]!=-1){\n\t\t\tif(col[i]==col[x]){\n\t\t\t\tfail();\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tcol[i]=col[x]^1;\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,n)scanf(\"%d\",&p[i]);\n\tmemset(col,-1,sizeof col);\n\tf[0]=1;\n\trep(x,1,n)if(col[x]==-1){\n\t\tcnt[0]=cnt[1]=0;\n\t\tcol[x]=0;\n\t\tdfs(x);\n\t\t//printf(\"__%d %d\\n\",cnt[0],cnt[1]);\n\t\tper(i,n,0){\n\t\t\tint w=0;\n\t\t\tif(i>=cnt[0])w=(w+f[i-cnt[0]])%P;\n\t\t\tif(i>=cnt[1])w=(w+f[i-cnt[1]])%P;\n\t\t\tf[i]=w;\n\t\t}\n\t}\n\tint ans=0;\n\trep(i,n-m,m)ans=(ans+f[i])%P;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long int;\nusing PII = pair<ll,ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\nll MOD = 1000000007;\n\nsigned main() {\n    ll n, m;\n    cin >> n >> m;\n    vector<ll> a(n);\n    REP(i, n) cin >> a[i];\n\n    vector<vector<ll>> g(n);\n    REP(i, n) FOR(j, i+1, n) {\n        if(a[i] > a[j]) {\n            g[i].push_back(j);\n            g[j].push_back(i);\n        }\n    }\n\n    ll cnt0, cnt1;\n    vector<ll> col(n);\n    function<bool(ll,ll)> dfs = [&](ll v, ll c) {\n        if(c == -1) cnt0++;\n        else cnt1++;\n        col[v] = c;\n        for(auto to: g[v]) {\n            if(col[to] == c) return false;\n            if(col[to] == 0 && !dfs(to, -c)) return false;\n        }\n        return true;\n    };\n\n    vector<PII> v;\n    REP(i, n) {\n        if(col[i] == 0) {\n            cnt0 = cnt1 = 0;\n            bool ret = dfs(i, -1);\n            if(!ret) {\n                cout << 0 << endl;\n                return 0;\n            }\n            v.emplace_back(cnt0, cnt1);\n        }\n    }\n\n    const ll sz = v.size();\n    vector<ll> s(sz);\n    REP(i, sz) s[i] = v[i].first + v[i].second;\n    FOR(i, 1, sz) s[i] += s[i-1];\n\n    vector<vector<ll>> dp(sz+1, vector<ll>(m+1));\n    dp[0][0] = 1;\n    REP(i, sz) REP(j, m+1) {\n        if(j+v[i].first<=m && s[i]-j-v[i].first<=m) {\n            (dp[i+1][j+v[i].first] += dp[i][j]) %= MOD;\n        }\n        if(j+v[i].second<=m && s[i]-j-v[i].second<=m) {\n            (dp[i+1][j+v[i].second] += dp[i][j]) %= MOD;\n        }\n    }\n\n    ll ret = 0;\n    REP(i, m+1) (ret += dp[sz][i]) %= MOD;\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m;\nint a[5005];\nvector<int> G[5005];\nint col[5005];\nvector<P> vec;\nint cnt[2];\nll dp[2][5005];\n\nbool dfs(int v,int c){\n\tcnt[c]++;\n\tcol[v]=c;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(col[G[v][i]]==-1){\n\t\t\tif(!dfs(G[v][i],1-c)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}else if(col[v]==col[G[v][i]]){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(a[i]>a[j]){\n\t\t\t\tG[i].push_back(j);\n\t\t\t\tG[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(col,-1,sizeof(col));\n\tfor(int i=0;i<n;i++){\n\t\tif(col[i]==-1){\n\t\t\tcnt[0]=cnt[1]=0;\n\t\t\tif(!dfs(i,0)){\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tvec.push_back(P(cnt[0],cnt[1]));\n\t\t}\n\t}\n\tint cur=0,nxt=1;\n\tdp[0][0]=1;\n\tint sum=0;\n\tfor(int i=0;i<vec.size();i++){\n\t\t//printf(\"%d %d\\n\",vec[i].first,vec[i].second);\n\t\tfor(int j=0;j<=sum;j++){\n\t\t\tdp[nxt][j+vec[i].first]+=dp[cur][j];\n\t\t\tdp[nxt][j+vec[i].first]%=MOD;\n\t\t\tdp[nxt][j+vec[i].second]+=dp[cur][j];\n\t\t\tdp[nxt][j+vec[i].second]%=MOD;\n\t\t}\n\t\tsum+=vec[i].first;\n\t\tsum+=vec[i].second;\n\t\tswap(cur,nxt);\n\t\tmemset(dp[nxt],0,sizeof(dp[nxt]));\n\t}\n\tll ans=0;\n\tfor(int i=0;i<=n;i++){\n\t\tif(i<=m && (n-i)<=m){\n\t\t\tans+=dp[cur][i];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = vector<V<T>>;\n\nconst size_t SIZE = 5010;\nconst ll inf = 5e15;\nconst ll mod = 1e9 + 7;\nll dp[SIZE][SIZE];\n\nll solve() {\n    dp[0][0] = 1;\n    ll N, M;\n    cin >> N >> M;\n    V<ll> books(N);\n    for(auto &&ele : books) cin >> ele;\n    V<ll> back_min(N);\n    back_min.back() = inf;\n    for(ll i = N - 2; 0 <= i; i--) back_min[i] = min(books[i + 1], back_min[i + 1]);\n    ll cur_max = 0;\n    \n    auto check_size = [&](ll sum, ll h) {\n        return 0 <= h && h <= M &&\n               0 <= sum - h && sum - h <= M;\n    };\n\n    for(ll i = 1; i <= N; i++) {\n        ll cur = books[i - 1];\n        if(back_min[i - 1] < cur && cur < cur_max) return 0;\n\n        if(cur_max < cur) {\n            for(ll j = 0; j < SIZE; j++) if(check_size(i, j + 1)) dp[i][j + 1] = dp[i - 1][j] %= mod;\n            if(cur_max && cur_max < back_min[i - 1]) for(ll j = 0; j < SIZE; j++) if(check_size(i, j)) (dp[i][i - j] += dp[i - 1][j]) %= mod;\n            cur_max = cur;\n        } else {\n            for(ll j = 0; j < SIZE; j++) if(check_size(i, j)) dp[i][j] = dp[i - 1][j];\n        }\n    }\n\n    ll ans = 0;\n    for(ll i = 0; i < SIZE; i++) if(check_size(N, i)) (ans += dp[N][i]) %= mod;\n    return ans * 2 % mod;\n}\n\nint main() {\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define REP(i,n) for(int i=0;i<n;++i)\n#define REP1(i,n) for(int i=1;i<=n;++i)\n#define SZ(i) int(i.size())\n#define eb emplace_back\n#define ALL(i) i.begin(),i.end()\n#define X first\n#define Y second\n#ifdef tmd\n#define IOS()\n#define debug(...) fprintf(stderr,\"#%d: %s = \",__LINE__,#__VA_ARGS__),_do(__VA_ARGS__);\ntemplate<typename T> void _do(T &&x){cerr<<x<<endl;}\ntemplate<typename T, typename ...S> void _do(T &&x, S &&...y){cerr<<x<<\", \";_do(y...);}\ntemplate<typename It> ostream& _printRng(ostream &os,It bg,It ed)\n{\n    os<<\"{\";\n    for(It it=bg;it!=ed;it++) {\n        os<<(it==bg?\"\":\",\")<<*it;\n    }\n    os<<\"}\";\n    return os;\n}\ntemplate<typename T> ostream &operator << (ostream &os,vector<T> &v){return _printRng(os,v.begin(), v.end());}\ntemplate<typename T> void pary(T bg, T ed){_printRng(cerr,bg,ed);cerr<<endl;}\n#else\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#define endl '\\n'\n#define debug(...)\n#define pary(...)\n#endif\n\nconst int MAXN = 5003;\nconst ll MOD = 1000000007;\n\nint n, m, a[MAXN], dp[MAXN][MAXN][2], mx;\narray<int,2> tp;\n\nvoid add (int &x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x-= MOD;\n    }\n}\n/*********************GoodLuck***********************/\nint main () {\n    IOS();\n\n    cin >> n >> m;\n\n    dp[0][0][0] = 1;\n    REP1 (i, n) {\n        cin >> a[i];\n        debug(i, mx, tp[0], tp[1]);\n\n        if (mx == i-1) {\n            if (a[i] == mx + 1) {\n                for (int j=0; j<=i; j++) {\n                    if (j > 0) {\n                        add(dp[i][j][0], dp[i-1][j-1][0]);\n                    }\n                    add(dp[i][j][0], dp[i-1][j][0]);\n                }\n            } else {\n                for (int j=0; j<=i; j++) {\n                    if (j > 0) {\n                        add(dp[i][j][0], dp[i-1][j-1][0]);\n                    }\n                    add(dp[i][j][1], dp[i-1][j][0]);\n                }\n            }\n            tp[0] = a[i];\n\n            debug(\"fre\");\n        } else {\n            if (a[i] > mx) {\n                for (int j=0; j<=i; j++) {\n                    if (j > 0) {\n                        add(dp[i][j][0], dp[i-1][j-1][0]);\n                    }\n                    add(dp[i][j][1], dp[i-1][j][1]);\n                }\n\n                tp[0] = a[i];\n                debug(\"inc\");\n            } else {\n                if (a[i] < tp[1]) {\n                    cout << 0 << endl;\n                    return 0;\n                }\n\n                debug(\"dec\");\n                if (mx == i) {\n                    debug(\"unlock\");\n                    for (int j=0; j<=i; j++) {\n                        if (j > 0) {\n                            add(dp[i][j][0], dp[i-1][j-1][1]);\n                        }\n                        add(dp[i][j][0], dp[i-1][j][0]);\n                    }\n                } else {\n                    for (int j=0; j<=i; j++) {\n                        if (j > 0) {\n                            add(dp[i][j][1], dp[i-1][j-1][1]);\n                        }\n                        add(dp[i][j][0], dp[i-1][j][0]);\n                    }\n                }\n\n                tp[1] = a[i];\n\n            }\n        }\n\n        mx = max(mx, a[i]);\n    }\n\n    int ans = 0;\n    for (int i=0; i<=m; i++) {\n        assert(dp[n][i][1] == 0);\n        if (n-i <= m) {\n            add(ans, dp[n][i][0]);\n        }\n    }\n\n    cout << ans << endl;\n\n    #ifdef tmd\n\n    int a, b, c;\n    while (cin >> a >> b >> c) {\n        cout << dp[a][b][c] << endl;\n    }\n\n    #endif // tmd\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct BipartiteGraph {\n\tstruct Edge {\n\t\tconst int from;\n\t\tconst int to;\n\t\tEdge(const int from, const int to) :\n\t\t\tfrom(from),\n\t\t\tto(to)\n\t\t\t{}\n\t};\n\tconst int V;\n\tvector<vector<Edge>> G;\n\tvector<int> color;\n\tBipartiteGraph(const int V) :\n\t\tV(V),\n\t\tG(vector<vector<Edge>>(V, vector<Edge>())),\n\t\tcolor(vector<int>(V, -1))\n\t\t{}\n\tvoid addEdge(const int from, const int to) {\n\t\tG[from].emplace_back(from, to);\n\t\tG[to].emplace_back(to, from);\n\t}\n\tbool dfs(const int from, const int col) {\n\t\tcolor[from] = col;\n\t\tbool ret = true;\n\t\tfor(Edge e : G[from]) {\n\t\t\tif(color[e.to] == -1) {\n\t\t\t\tret &= dfs(e.to, col ^ 1);\n\t\t\t}\n\t\t\tif(color[e.to] == col) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tint bipart() {\n\t\tif(not dfs(0, 0)) throw \"NOT Bipartite Graph\";\n\t\tint ret = 0;\n\t\tfor(int i : color) ret += i;\n\t\treturn ret;\n\t}\n};\n\nstruct UnionFind {\n\tconst int V;\n\t// par[x] := xのroot\n\tvector<int> par;\n\t// sz[x] := xを含む集合のサイズ\n\tvector<int> sz;\n\tUnionFind(const int V) :\n\t\tV(V),\n\t\tpar(vector<int>(V)),\n\t\tsz(vector<int>(V, 1))\n\t\t{\n\t\t\tfor(int i = 0; i < V; ++i) par[i] = i;\n\t\t}\n\tbool unite(int x, int y) {\n\t\tx = root(x), y = root(y);\n\t\tif(same(x, y)) return false;\n\t\tif(y < x) swap(x, y);\n\t\tpar[y] = x;\n\t\tsz[x] += sz[y];\n\t\treturn true;\n\t}\n\tint root(int x) {\n\t\tif(par[x] == x) return x;\n\t\treturn (par[x] = root(par[x]));\n\t}\n\tbool same(int x, int y) {\n\t\treturn (root(x) == root(y));\n\t}\n\tint size(int x) {\n\t\treturn sz[root(x)];\n\t}\n};\n\nint dp[5010][5010];\nint main() {\n\tconst int MOD = 1e9 + 7;\n\tint n, m; cin >> n >> m;\n\tint a[n];\n\tfor(int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\t--a[i];\n\t}\n\tUnionFind uf(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\tif(a[i] > a[j]) uf.unite(i, j);\n\t\t}\n\t}\n\tvector<int> edge[n];\n\tfor(int i = 0; i < n; ++i) {\n\t\tedge[uf.root(i)].push_back(i);\n\t}\n\tvector<int> color[2];\n\tfor(int i = 0; i < n; ++i) {\n\t\tint nn = edge[i].size();\n\t\tif(nn == 0) continue;\n\t\tBipartiteGraph bg(nn);\n\t\tfor(int j = 0; j < nn; ++j) {\n\t\t\tfor(int k = j + 1; k < nn; ++k) {\n\t\t\t\tif(a[edge[i][j]] > a[edge[i][k]]) {\n\t\t\t\t\tbg.addEdge(j, k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tint x = bg.bipart();\n\t\t\tcolor[0].push_back(x);\n\t\t\tcolor[1].push_back(nn - x);\n\t\t}\n\t\tcatch(...) {\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint sz = color[0].size();\n\tdp[0][0] = 1;\n\tfor(int i = 1; i <= sz; ++i) {\n\t\tfor(int j = 0; j <= n; ++j) {\n\t\t\tfor(int k = 0; k < 2; ++k) {\n\t\t\t\tif(j - color[k][i - 1] >= 0) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j - color[k][i - 1]];\n\t\t\t\t}\n\t\t\t\tdp[i][j] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int j = 0; j <= n; ++j) {\n\t\tif(max(j, n - j) > m) continue;\n\t\tans += dp[sz][j];\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nconst int mod = 1000000007;\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> A(N);\n\tfor (int i = 0; i < N; ++i) cin >> A[i];\n\tvector<vector<int> > G(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\tif (A[i] > A[j]) {\n\t\t\t\tG[i].push_back(j);\n\t\t\t\tG[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> va, vb;\n\tvector<int> col(N, -1);\n\tbool ok = true;\n\tfor (int i = 0; i < N && ok; ++i) {\n\t\tif (col[i] != -1) continue;\n\t\tqueue<int> que;\n\t\tque.push(i);\n\t\tcol[i] = 0;\n\t\tint ca = 0, cb = 0;\n\t\twhile (!que.empty()) {\n\t\t\tint u = que.front(); que.pop();\n\t\t\tif (col[u] == 0) ++ca;\n\t\t\telse ++cb;\n\t\t\tfor (int j : G[u]) {\n\t\t\t\tif (col[j] == -1) {\n\t\t\t\t\tcol[j] = col[u] ^ 1;\n\t\t\t\t\tque.push(j);\n\t\t\t\t}\n\t\t\t\telse if (col[j] == col[u]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tva.push_back(ca);\n\t\tvb.push_back(cb);\n\t}\n\tif (!ok) {\n\t\tcout << 0 << endl;\n\t}\n\telse {\n\t\tvector<int> dp(N + 1, 0);\n\t\tdp[0] = 1;\n\t\tfor (int i = 0; i < va.size(); ++i) {\n\t\t\tvector<int> ndp(N + 1, 0);\n\t\t\tfor (int j = 0; j <= N; ++j) {\n\t\t\t\tif (j >= va[i]) ndp[j] += dp[j - va[i]];\n\t\t\t\tif (j >= vb[i]) ndp[j] += dp[j - vb[i]];\n\t\t\t\tif (ndp[j] >= mod) ndp[j] -= mod;\n\t\t\t}\n\t\t\tdp = ndp;\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = N - M; i <= M; ++i) {\n\t\t\tans += dp[i];\n\t\t\tif (ans >= mod) ans -= mod;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\n#include <unordered_map>\n#include <fstream>\n#include <ctime>\n#include <complex>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> pii;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {1,-1,0,0,1,-1,1,-1};\nll dx[8] = {0,0,1,-1,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T> inline void print(T &a){\n    rep(i,a.size()) cout << a[i] << \" \";\n    cout << \"\\n\";\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nll pcount(ll x) {return __builtin_popcountll(x);}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\nint main(){\n\tll n,m; cin >> n >> m;\n\tvector<int> a(n), v(n);\n\trep(i,n){\n\t\tcin >> a[i], a[i]--;\n\t\tv[a[i]] = i;\n\t}\n\tvector<vector<int>> G(n);\n\trep(i,n){\n\t\tREP(j,v[i]+1,n){\n\t\t\tif(a[j] < i){\n\t\t\t\tG[a[j]].push_back(i);\n\t\t\t\tG[i].push_back(a[j]);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> color(n,-1);\n\tvector<pii> sz;\n\trep(i,n){\n\t\tif(color[i] != -1) continue;\n\t\tvector<int> cnt(2,0);\n\t\tqueue<int> q;\n\t\tq.push(i);\n\t\tcnt[0] = 1;\n\t\tcolor[i] = 0;\n\t\twhile(!q.empty()){\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor(auto v : G[u]){\n\t\t\t\tif(color[v] != -1){\n\t\t\t\t\tif(color[v] == color[u]){\n\t\t\t\t\t\tcout << 0 << \"\\n\";\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcolor[v] = 1 - color[u];\n\t\t\t\tcnt[color[v]]++;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t\tsort(all(cnt));\n\t\tsz.emplace_back(cnt[0], cnt[1]);\n\t}\n\tint k = sz.size();\n\tvector<vector<int>> dp(k+1,vector<int>(m+1,0));\n\tdp[0][0] = 1;\n\trep(i,k){\n\t\trep(j,m+1){\n\t\t\tif(j+sz[i].first <= m) (dp[i+1][j+sz[i].first] += dp[i][j]) %= mod;\n\t\t\tif(j+sz[i].second <= m) (dp[i+1][j+sz[i].second] += dp[i][j]) %= mod;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor(int i=n-m; i<=m; i++) (ans += dp[k][i]) %= mod;\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = 0;(i) < (n);i++)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define ALL(v) b.begin(),v.end()\n#define SHOW1d(v, n) {REP(WW,n)cerr<<v[WW]<<\" \";cerr<<endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr<<v[W_][H_]<<\" \";cerr<<endl;}cerr<<endl;}\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nstruct UF\n{\n  vector<int> par;\n  vector<int>sz;\n  vector<int>rank;\n  UF(int n):par(n),sz(n),rank(n){\n    for(int i=0;i<n;i++){\n      par[i] = i;sz[i] = 1;rank[i] = 0;\n    }\n  }\n  int find(int x){\n    if(par[x]==x)return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x = find(x);y = find(y);\n    if(x == y)return;\n    if(rank[x] < rank[y]){\n      par[x] = y;\n      sz[y] += sz[x];\n    }else{\n      par[y] = x;\n      sz[x] += sz[y];\n      if(rank[x] == rank[y])rank[x]++;\n    }\n  }\n  bool same(int x,int y){return find(x) == find(y);}\n  int size(int n){return sz[find(n)];}\n};\n\nvector<vector<int>> g(5555);\nbool used[5555];\nint color[5555];\nint color_a, color_b;\nint dp[5555][5555];\nbool ng_flag;\n\nvoid mod_add(int &a, int b){\n  a += b;\n  a %= MOD;\n}\n\nvoid dfs(int a){\n  //cout << \"dfs in \" << a << endl;\n  used[a] = true;\n  if(color[a] == 1)color_a++;\n  else color_b++;\n\n  REP(i, g[a].size()){\n    //cout << \"dfs \" << a << \" \" << g[a][i] << endl;\n    int aite = g[a][i];\n    if(color[aite] * color[a] == 1){\n      //cout << \"!! \" << aite << \" \" << a << endl;\n      ng_flag = true;\n      continue;\n    }\n    if(used[aite])continue;\n    if(color[aite] == 0){\n      color[aite] = -color[a];\n    }\n    dfs(aite);\n  }\n}\n\nint main() {\n  cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n  ll n, m;cin >> n >> m;\n  vector<ll> v(n);\n  REP(i, n)cin>>v[i];\n\n  for(int i = n-1;i >= 0;i--){\n    for(int j = i-1;j >= 0;j--){\n      if(v[i] < v[j]){\n        //cout << \"! \" << v[i] << \" \" << v[j] << endl;\n        g[i].PB(j);\n        g[j].PB(i);\n      }\n    }\n  }\n  vector<P> seica;\n\n  REP(i, n){\n    //cout << i << endl;\n    if(used[i])continue;\n    color[i] = 1;\n    color_a = 0;\n    color_b = 0;\n    dfs(i);\n    if(ng_flag){\n      cout << 0 << endl;\n      return 0;\n    }\n    seica.EB(color_a, color_b);\n  }\n\n/*\n  SHOW1d(color, n);\n  REP(i, seica.size()){\n    cout << \"(\" << seica[i].FI << \" \" << seica[i].SE << \")\";\n  }cout << endl;\n*/\n  dp[0][0] = 1;\n  int sum = 0;\n  REP(i, seica.size()){\n    REP(j, 5555){\n      if(dp[i][j] == 0)continue;\n      ll a_high = j;\n      ll b_high = sum - j;\n      //cout << i << \" \" << a_high << \" \" << b_high << endl;\n      if(a_high + seica[i].FI <= m && b_high + seica[i].SE <= m){\n        //cout << \"A\" << endl;\n        mod_add(dp[i+1][a_high + seica[i].FI], dp[i][j]);\n      }\n      if(a_high + seica[i].SE <= m && b_high + seica[i].FI <= m){\n        //cout << \"B\" << endl;\n        mod_add(dp[i+1][a_high + seica[i].SE], dp[i][j]);\n      }\n    }\n    sum += seica[i].FI;\n    sum += seica[i].SE;\n  }\n\n  //SHOW2d(dp, seica.size() + 1, 10);\n\n  int ans = 0;\n  REP(i, 5555)mod_add(ans, dp[seica.size()][i]);\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 5055\nconst int MOD = 1e9 + 7;\n\nint n, m;\nint a[N];\nvector <int> E[N];\n\nvoid add(int x, int y) {\n\tE[x].push_back(y);\n\tE[y].push_back(x);\n}\n\nint L, R;\nbool vis[N];\nint col[N];\nbool flag;\nvoid dfs(int x) {\n\tvis[x] = 1;\n\tif (!col[x]) col[x] = 2;\n\tif (col[x] == 2) L++; else R++;\n\tfor (auto &v : E[x]) {\n\t\tif (!vis[v]) col[v] = col[x] ^ 1, dfs(v);\n\t\telse if (col[v] != (col[x] ^ 1)) {\n\t\t\tflag = 0;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvector < pair<int, int> > b;\n\nlong long dp[N];\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\t//while (clock() < n * 0.001 * CLOCKS_PER_SEC);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", a + i);\n\tflag = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (a[j] > a[i]) add(i, j);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[i]) {\n\t\t\tL = R = 0;\n\t\t\tdfs(i);\n\t\t\tif (!flag) break;\n\t\t\tb.push_back({L, R});\n\t\t}\n\t}\n\tif (!flag) return puts(\"0\"), 0;\n\tint sum = 0;\n\tdp[0] = 1;\n\tfor (auto v : b) {\n\t\tsum += max(v.first, v.second);\n\t\tfor (int j = sum; j >= 0; j--) {\n\t\t\tif (v.first == 0 || v.second == 0) {\n\t\t\t\tif (v.first > 0 && j >= v.first) (dp[j] += dp[j - v.first]) %= MOD;\n\t\t\t\tif (v.second > 0 && j >= v.second) (dp[j] += dp[j - v.second]) %= MOD;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j] = 0;\n\t\t\t\tif (j >= v.first) (dp[j] += dp[j - v.first]) %= MOD;\n\t\t\t\tif (j >= v.second) (dp[j] += dp[j - v.second]) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i <= n; i++) {\n\t\tint j = max(i, n - i);\n\t\tif (j <= m) (ans += dp[i]) %= MOD;\n\t}\n\tprintf(\"%d\\n\", int(ans % MOD));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T>\nbool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nstruct UnionFind {\n        vector<int> par, rank, Size;\n        UnionFind(int n = 1) {\n            init(n);\n        }\n\n        void init(int n = 1) {\n            par.resize(n + 1);\n            rank.resize(n + 1);\n            Size.resize(n + 1);\n            for(int i = 0; i <= n; i++) {\n                par[i] = i;\n                rank[i] = 0;\n                Size[i] = 1;\n            }\n        }\n\n    int root(int x) {\n        if(par[x] == x) return x;\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n        bool issame(int x, int y) {\n            x = root(x);\n            y = root(y);\n            return x == y;\n        }\n\n        bool merge(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if(x == y) return false;\n            Size[x] += Size[y];\n            par[y] = x;\n            return true;\n        }\n    };\n\nconst ll mod = 1e9 + 7;\nll N, M;\nll a[5050];\nll Prev[5050], Next[5050];\nint main() {\n    cin.tie(nullptr); ios::sync_with_stdio(false);\n    cin >> N >> M;\n    for(int i = 0; i < N; i++) {\n        cin >> a[i];\n    }\n    UnionFind uni(2 * N);\n    for(int i = 0; i < N; i++) {\n        for(int j = i + 1; j < N; j++) {\n            if(a[i] > a[j]) {\n                uni.merge(i , j + N);\n                uni.merge(i + N, j);\n            }\n        }\n    }\n    for(int i = 0; i < N; i++) {\n        //cerr << i << \" \" << uni.root(i) << \" \" << uni.root(i + N) << endl;\n        if(uni.issame(i, i + N)) {\n            cout << 0 << endl;\n            return 0;\n        }\n    }\n    Prev[0] = 1;\n    for(int i = 0; i < N; i++) {\n        if(uni.root(i) != i and uni.root(i) != i + N) continue;\n        for(int i = 0; i <= N; i++) Next[i] = 0;\n        ll x[2] = {0, 0};\n        for(int j = 0; j < N; j++) {\n            if(uni.issame(i, j)) x[0]++;\n            if(uni.issame(i, j + N)) x[1]++;\n        }\n        //cerr << x[0] << \" \" << x[1] << endl;\n        for(int index = 0; index < 2; index++) {\n            for(int before = 0; before < N; before++) {\n                if(before + x[index] <= N) {\n                    Next[before + x[index]] += Prev[before];\n                    Next[before + x[index]] %= mod;\n                }\n            }\n        }\n        swap(Prev, Next);\n    }\n    ll ans = 0;\n    for(ll i = N - M; i <= M; i++) {\n        ans += Prev[i];\n        ans %= mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nusing ll = long long;\nll modinv(ll a, ll m) {\n\tassert(m > 0);\n\tif (m == 1) return 0;\n\ta %= m;\n\tif (a < 0) a += m;\n\tassert(a != 0);\n\tif (a == 1) return 1;\n\treturn m - modinv(m, a) * m / a;\n}\n\ntemplate <int MOD_> struct modnum {\nprivate:\n\tint v;\npublic:\n\tstatic const int MOD = MOD_;\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int () const { return v; }\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum operator ~ () const {\n\t\tmodnum res;\n\t\tres.v = modinv(v, MOD);\n\t\treturn res;\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= (~o);\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<int(1e9) + 7>;\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> a(n);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\tvector<pair<int,int> > sums;\n\tint cur = -1;\n\tint cmax = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tcmax = max(a[i], cmax);\n\t\tif(cmax == i){\n\t\t\tint y = -1;\n\t\t\tint z = -1;\n\t\t\tint cy = 0;\n\t\t\tint cz = 0;\n\t\t\tfor(int v = cur + 1; v <= i; v++){\n\t\t\t\tif(a[v] >= z){\n\t\t\t\t\tz = a[v];\n\t\t\t\t\tcz++;\n\t\t\t\t} else if(a[v] >= y){\n\t\t\t\t\ty = a[v];\n\t\t\t\t\tcy++;\n\t\t\t\t} else {\n\t\t\t\t\tcout << 0 << '\\n';\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsums.push_back({cy, cz});\n\t\t\tcur = i;\n\t\t}\n\t}\n\tvector<num> dp(n+1, 0);\n\tdp[0] = 1;\n\tfor(pair<int,int> v : sums){\n\t\tvector<num> newdp(n+1, 0);\n\t\tfor(int i = 0; i + v.first <= n; i++) newdp[i+v.first] += dp[i];\n\t\tfor(int i = 0; i + v.second <= n; i++) newdp[i+v.second] += dp[i];\n\t\tdp = newdp;\n\t}\n\tnum ans = 0;\n\tfor(int i = 0; i <= n; i++){\n\t\tif(i <= m && n-i <= m) ans += dp[i];\n\t}\n\tcout << (int)ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define f first\n#define s second\n#define pb push_back\n#define reset(a,b) memset(a,b,sizeof a);\n#define ALL(x) x.begin(),x.end()\n \ntemplate <typename T>\nvoid cetak(T t){cout << t << ')' << endl;}\ntemplate <typename T, typename... V>\nvoid cetak(T t, V... v) {cout << t; if (sizeof...(v)) cerr << \", \"; cetak(v...);}\n \n#define debug(x...) cout<< '(' << #x << \") = (\"; cetak(x) \n#define sz(x) (int)(x.size())\n#define lt(x) (int)(x.length())\n\nconst int MOD = 1e9 + 7;\nconst int mx = 5000 + 10;\n\nint n, m, s[mx];\nint dep[mx][mx];\nbool sudah[mx][mx];\n\nvector<int> g[mx];\n\nint lev[mx];\nvector<vector<int>> ve;\nvector<int> tmp;\nvoid dfs(int now, int a){\n    lev[now] = a;\n    tmp.pb(now);\n    for(int i : g[now]){\n        if(lev[i] == -1) dfs(i, a ^ 1);\n        else if(lev[i] == a){\n            cout << 0 << endl;\n            exit(0);\n        }\n    }\n}\n\nint idx = 0, a[mx], b[mx];\nint pref[mx];\nint dp(int now, int satu){\n    int dua = 0;\n    if(now > 0) dua = pref[now - 1] - satu;\n    if(max(satu, dua) > m) return 0;\n    if(now == idx) return 1;\n    int &ret = dep[now][satu];\n    if(sudah[now][satu]) return ret;\n    ret = 0;\n    sudah[now][satu] = 1;\n    ret = (ret + dp(now + 1, satu + a[now])) % MOD;\n    ret = (ret + dp(now + 1, satu + b[now])) % MOD;\n    return ret;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++) cin >> s[i];\n    for(int i = 1; i <= n; i++){\n        for(int j = i + 1; j <= n; j++){\n            if(s[i] > s[j]){\n                g[i].pb(j);\n                g[j].pb(i);\n            }\n        }\n    }\n    reset(lev, -1);\n    \n    for(int i = 1; i <= n; i++){\n        if(lev[i] == -1){\n            tmp.clear();\n            dfs(i, 0);\n            if(idx > 0) pref[idx] += pref[idx - 1];\n            pref[idx] += sz(tmp);\n            for(int x : tmp){\n                if(lev[x] == 0) a[idx] += 1;\n                else b[idx] += 1;\n            }\n            idx += 1;\n        }\n    }\n    cout << dp(0, 0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<utility>\n#include<cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define MP make_pair\ntypedef long long ll;\n#define mod 1000000007\nll comb[5001][5001];\n\nll dp[5001][2],dp2[5001][2];\nll ss[5002];\n\nint main(){\n    rep(i,5001){\n        comb[i][0] = 1;\n        comb[i][i] = 1;\n    }\n    for(int i=1;i<=5000;i++){\n        for(int j=1;j<i;j++){\n            comb[i][j] = comb[i-1][j] + comb[i-1][j-1];\n            comb[i][j] %= mod;\n        }\n    }\n    int n,m;\n    cin >> n >> m;\n    vector<int>a(n);\n    rep(i,n)cin >> a[i];\n    vector<int>x,y;\n    vector<int>F,G;\n    vector<int>c;\n    for(int i=1;i<n;i++){\n        if(a[i]<a[i-1]){\n            c.push_back(i);\n            F.push_back(a[i-1]);\n            G.push_back(a[i]);\n        }\n    }\n    if(c.size()==0){\n        ll sm = 0;\n        for(int i= n-m;i<=m;i++){\n            sm += comb[n][i];\n            sm %= mod;\n        }\n        cout << sm << endl;\n    }else{\n        int s = 0;\n        bool flag = 0;\n        rep(i,c.size()){\n            int id = c[i];\n            int tar = a[id];\n            int xx = 0;\n            for(int j=s;j<=id-1;j++){\n                if(a[j]>=tar){\n                    xx++;\n                }\n            }\n            x.push_back(xx);\n            int yy = 0;\n            int sss = a[id-1];\n            int ppp = n;\n            if(i!=c.size()-1){\n                ppp = c[i+1];\n            }\n            for(int j=id;j<ppp;j++){\n                if(a[j] < sss){\n                    yy++;\n                }\n            }\n            y.push_back(yy);\n            //cerr << c[i] << \" \" << x[i] << \" \" << y[i] << endl;\n            if(i!=0&&c[i]-c[i-1]<x[i]+y[i-1]){\n                flag = true;\n                // cerr << c[i]-c[i-1] << \" \" << x[i] + y[i-1] << endl;\n                // cerr << c[i-1] << \" \"<< c[i] << endl;\n                // cerr << x[i] << \" \" << y[i-1] << endl;\n            }\n            s = id;\n        }\n        if(flag){\n            cout << 0 << endl;\n            return 0;\n        }\n        ll p = 0;\n        rep(i,c.size()){\n            p += x[i] + y[i];\n            //cerr << x[i] << \" \" << y[i] << endl;\n        }\n        p = n-p;\n        dp[x[0]][0] = 1;\n        dp[y[0]][1] = 1;\n        rep(k,c.size()){\n            if(k==0)continue;\n            rep(i,5001){\n                dp2[i][0] = 0;\n                dp2[i][1] = 0;\n            }\n            for(int i=5000;i>=0;i--){\n                if(i-x[k]>=0){\n                    dp2[i][0] += dp[i-x[k]][0];\n                    dp2[i][0] %= mod;\n                    if(F[k-1]<G[k]){\n                        dp2[i][0] += dp[i-x[k]][1];\n                        dp2[i][0] %= mod;\n                    \n                    }\n                }\n                if(i-y[k]>=0){\n                    dp2[i][1] += dp[i-y[k]][1];\n                    dp2[i][1] %= mod;\n                    if(F[k-1]<G[k]){\n                        \n                        dp2[i][1] += dp[i-y[k]][0];\n                        dp2[i][1] %= mod;\n                    }\n                }\n            }\n            rep(i,5001){\n                dp[i][0] = dp2[i][0];\n                dp[i][1] = dp2[i][1];\n            }\n        }\n        \n        //cerr << p << endl;\n        // rep(i,n+1){\n        //     cerr << dp[i] << \" \";\n        // }\n        // cerr << endl;\n        ll res = 0;\n        rep(i,n+2){\n            if(i!=0){\n                ss[i] = ss[i-1] + comb[p][i-1];\n                ss[i] %= mod;\n            }\n        }\n        rep(i,n+1){\n            if(i>m)continue;\n            int l = max(0,n-m-i);\n            ll r = min(p+1,(ll)m-i+1);\n            res += (dp[i][0]+dp[i][1])%mod*((mod+ss[r]-ss[l])%mod);\n            res %= mod;\n            //cerr << l << \" \" << r << \" \" << dp[i][0] << \" \" << dp[i][1] << \" \" << ss[l] << \" \" << ss[r] << endl;\n        }\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define endl \"\\n\"\n#define MOD 1000000007\n#define INF 1000000010\n#define EPS 1e-9\n#define fst first\n#define scd second\n\n#define repi(i,x,n) for(int i=x;i<n;i++)\n#define rep(i,n) repi(i,0,n)\n#define lp(i,n) rep(i,n)\n#define repn(i,n) for(int i=n;i>=0;i--)\n\n  int dp[8000][6000];\nsigned main(){\n  cin.tie(0);\n  //ios::sync_with_stdio(false);\n  int n,m;\n  cin>>n>>m;\n  int a[n];\n  rep(i,n){\n    cin>>a[i];\n  }\n  int fl[n]={0};\n  vector<pair<int,int> > p;\n  bool flag=false;\n  int fs=1,sc=0;\n  int prev=0,num=0;\n  rep(i,n){\n    //cout<<prev<<\" \"<<num<<endl;\n    if(!flag){\n      if(a[i] == i+1){\n        p.push_back(make_pair(fs,sc));\n        fl[i]=1;\n      }\n      else if(a[i] > i+1){\n        flag=true;\n        prev=a[i]+1;\n        num=i+1;\n        fl[a[i]-1]=1;\n      }\n    }else{\n      if(a[i]>=prev){\n        fl[a[i]-1]=1;\n        fs++;\n\tprev=a[i];\n        while(fl[prev-1]==1) prev++;\n      }else if(a[i]==num){\n        fl[a[i]-1]=1;\n        sc++;\n        while(fl[num-1]==1) num++;\n      }else{cout<<0<<endl;return 0;}\n      if(prev==num){\n        flag=false;\n        p.push_back(make_pair(fs,sc));\n        fs=1;sc=0;\n      }\n    }\n  }\n  if(flag)  p.push_back(make_pair(fs,sc));\n  rep(i,p.size() ){\n    //  cout<<p[i].fst<<\" \"<<p[i].scd<<endl;\n  }\n\n   rep(i,p.size() + 1){\n    rep(j,n+1){\n      dp[i][j]=0;\n    }\n  }\n   dp[0][0]=1;\n\n  rep(i,p.size() ){\n    repn(j,n){\n      if(j+p[i].fst <= n+1){\n        dp[i+1][j+p[i].fst]+=dp[i][j];\n        dp[i+1][j+p[i].fst]%=MOD;\n      }\n       if(j+p[i].scd <= n+1){\n        dp[i+1][j+p[i].scd]+=dp[i][j];\n        dp[i+1][j+p[i].scd]%=MOD;\n      }\n    }\n  }\n  int ans=0;/*\n  rep(i,p.size() + 1){\n    rep(j,n+1){\n      cout<<dp[i][j]<<\" \";\n    }\n    cout<<endl;}*/\n\n  for(int i=n-m;i<m+1;i++){\n    ans+=dp[p.size()][i];\n    ans%=MOD;\n  }\n  cout<<ans<<endl;\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5050;\nint a[N], f[N][N];\n\nconst int MOD = 1e9 + 7;\n\nvoid Add(int& a, int b) {\n    a += b;\n    a -= (a >= MOD ? MOD : 0);\n    a += (a < 0 ? MOD : 0);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    int p = 2;\n    while (p <= n && a[p] > a[p - 1]) {\n        Add(f[p][1], 1);\n        Add(f[p + 1][1], -1);\n        //cerr << p << \" \" << p - 1 << '\\n';\n        ++p;\n    } \n    if (p <= n) {\n        Add(f[p][1], 1);\n        Add(f[p + 1][1], -1);\n    }\n    a[n + 1] = n + 1;\n    int ans = 0;\n    if (p > n && m == n) Add(ans, 1);\n    ++n;\n    for (int i = 2; i <= n; ++i) {\n        int L = i + 1, R = i;\n        while (R < n && a[R + 1] > a[R]) ++R;\n        while (L <= R && a[L] <= a[i - 1]) ++L;\n        if (R != n && a[R + 1] > a[i - 1]) ++R;\n        // cerr << \"At \" << i << ' ' << L << ' ' << R << '\\n';\n        for (int j = 1; j < i; ++j) {\n            Add(f[i][j], f[i - 1][j]);\n            // cerr << \"DP \" << i << ' ' << j << ' ' << f[i][j] << '\\n';\n            if (L > R) continue;\n            // cerr << \"Add \" << L << \"..\" << R << ' ' << i - j + 1 << ' ' << f[i][j] << '\\n';\n            Add(f[L][i - j + 1], f[i][j]);\n            Add(f[R + 1][i - j + 1], -f[i][j]); \n        }\n    }\n    for (int t = 2; t <= m + 1; ++t) {\n        if (n - t <= m) {\n            Add(ans, f[n][t]);\n        }\n    }\n    cout << 1ll * ans * 2 % MOD << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\n#define mkp make_pair\n#define rep(i,n) for(int (i)=0;(i)<(n);++(i))\n\nll dp[5005][5005];\n\nvoid add(ll &a,ll b){\n  a=(a+b)%MOD;\n}\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  vector<int> A(N);\n  rep(i,N) cin>>A[i];\n\n  vector<pair<int,int>> v;\n  int ma=0;\n  int now=0;\n  int sx=0,sy=0;\n  while(now<N){\n    int mi=A[now],mit=now;\n    for(int j=now;j<N;j++){\n      if(mi>A[j]){\n        mi=A[j];\n        mit=j;\n      }\n    }\n\n    bool ok=true;\n    for(int j=now;j+1<mit;j++){\n      if(A[j]>A[j+1]) ok=false;\n    }\n    if(ok==false){\n      cout<<0<<endl;\n      return 0;\n    }\n\n    if(mi<ma){\n      sx++;\n      sy+=mit-now;\n      now=mit+1;\n    }else{\n      if(now>0) v.push_back(mkp(sx,sy));\n      sx=1;\n      sy=mit-now;\n      now=mit+1;\n    }\n\n    for(int j=0;j<=mit;j++) ma=max(ma,A[j]);\n  }\n  v.push_back(mkp(sx,sy));\n\n  dp[0][0]=1;\n  for(int i=0;i<v.size();i++){\n    int x=v[i].first;\n    int y=v[i].second;\n    for(int j=0;j<=N;j++){\n      if(j+x<=N) add(dp[i+1][j+x],dp[i][j]);\n      if(j+y<=N) add(dp[i+1][j+y],dp[i][j]);\n    }\n  }\n\n  ll ans=0;\n  for(int j=0;j<=N;j++){\n    if(j<=M&&N-j<=M) add(ans,dp[v.size()][j]);\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n    return powmod(a, MOD-2);\n}\nll f[10010], invf[10010];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n    invf[n]=inv(f[n]);\n    for(ll i=n-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n}\nll comb(int x, int y){\n    if(!(0<=y && y<=x)) return 0;\n    return f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nint main()\n{\n\tint n, m;\n\tcin>>n>>m;\n\tint p[5050];\n\tfor(int i=0; i<n; i++){\n\t\tcin>>p[i]; p[i]--;\n\t\tif(i-2>=0 && p[i-2]>p[i-1] && p[i-1]>p[i]){\n\t\t\tcout<<0<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tp[n]=n+1, p[n+1]=n;\n\tn+=2;\n\tfac(n);\n\tvector<ll> dp(n+1);\n\tdp[0]=1;\n\tint pr=0;\n\tint cnt=0;\n\tfor(int i=0; i<n-1; i++){\n\t\tif(p[i]<p[i+1]) continue;\n\t\tcnt++;\n\t\tvector<ll> tmp(n+1);\n\t\tint c1=0, c2=0, c=0;\n\t\tbool dame=0;\n\t\tif(pr>0 && (p[pr-2]>p[i] || p[pr-1]>p[i+1])){\n\t\t\tdame=1;\n\t\t}else{\n\t\t\tfor(int j=pr; j<i; j++){\n\t\t\t\tif((pr==0 || p[pr-2]<p[j]) && p[j]<p[i+1]){\n\t\t\t\t\tc++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbool myon1=0, myon2=0;\n\t\t\t\tif(pr>0 && p[pr-1]<p[j] && p[j]<p[pr-2]) myon2=1;\n\t\t\t\tif(p[j]>p[i+1] && p[j]<p[i]) myon1=1;\n\t\t\t\tif(myon1 && myon2){\n\t\t\t\t\tdame=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(myon1) c1++;\n\t\t\t\telse c2++;\n\t\t\t}\n\t\t\tif(c1+c2+c<i-pr) dame=1;\n\t\t}\n\t\tif(!dame){\n\t\t\tfor(int k=0; k<=n; k++){\n\t\t\t\tif(dp[k]==0) continue;\n\t\t\t\tfor(int j=0; j<=c; j++){\n\t\t\t\t\t(tmp[k+c1+j+1]+=dp[k]*comb(c, j))%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdame=0, c1=0, c2=0, c=0;\n\t\tif(pr>0 && p[pr-2]>p[i+1]) dame=1;\n\t\telse{\n\t\t\tfor(int j=pr; j<i; j++){\n\t\t\t\tif((pr==0 || p[pr-2]<p[j]) && p[j]<p[i+1]) c++;\n\t\t\t\telse if(p[j]>p[i] || (pr>0 && p[j]<p[pr-1])){\n\t\t\t\t\tdame=1; break;\n\t\t\t\t}else c2++;\n\t\t\t}\n\t\t\tif(c+c2<i-pr) dame=1;\n\t\t}\n\t\tif(!dame){\n\t\t\tfor(int k=0; k<=n; k++){\n\t\t\t\tif(dp[k]==0) continue;\n\t\t\t\tfor(int j=0; j<=c; j++){\n\t\t\t\t\t(tmp[pr-k+c2+1+j]+=dp[k]*comb(c, j))%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(dp, tmp);\n\t\tpr=i+2;\n\t}\n\tll ans=0;\n\tfor(int i=1; i<=n; i++){\n\t\tif(i-1<=m && n-i-1<=m) (ans+=dp[i])%=MOD;\n\t}\n\t(ans*=((MOD+1)/2))%=MOD;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst long long int mod=1000000007,INF=9999999999999;\n\nlong long int dp[5500][5500]={};\nlong long int LDSmemo=0,dp2[200010],LISs[200005];\n\nlong long int GyakuLIS(long long int n,long long int s[]){\n\tLDSmemo=0;\n\tfor(long long int i=0;i<n;i++){\n\t\tdp2[i]=INF;\n\t\tLISs[i]=s[n-i];\n\t}\n\tfor(long long int i=0;i<n;i++){\n\t\t*lower_bound(dp2,dp2+n,LISs[i])=LISs[i];\n\t}\n    \n\treturn lower_bound(dp2,dp2+n,INF)-dp2;\n}\n\nlong long int kaijyou[200005]={1};\n\n\nlong long int ruijyou(long long int a,long long int b){\n\tif(b==0)return 1;\n\tlong long int res=ruijyou(a*a%mod,b/2);\n\tif(b & 1)res=res*a%mod;\n\treturn res;\n}\nlong long int combination(long long int a,long long int b){\n\tlong long int res=kaijyou[a]*ruijyou(kaijyou[b],mod-2)%mod;\n\tres=res*ruijyou(kaijyou[a-b],mod-2)%mod;\n\treturn res;\n}\n\nint main(){\n\tlong long int n,m,s[200005]={},type,res=0;\n\tcin>>n>>m;\n\tfor(long long int i=1;i<=2*n;i++){\n\t\tkaijyou[i]=i*kaijyou[i-1];\n\t\tkaijyou[i]%=mod;\n\t}\n    \n\tfor(int i=1;i<=n;i++){\n\t\tcin>>s[i];\n\t}\n\ttype=GyakuLIS(n,s);\n    //cout<<\"TYPE>> \"<<type<<endl;\n\tif(type>2){cout<<\"0\"<<endl;return 0;}\n    \n\tif(type==1){\n        //cout<<\"TYPE1\";\n\t\tfor(int i=n-m;i<=m;i++){\n\t\t\tres+=combination(n,i);\n\t\t\tres%=mod;\n\t\t}\t\t\n\t\tcout<<res<<endl;\n\t\t\n\t}else{\n\t\tlong long int mode=0,count1=0,count2=0,memo,mymax=0;\n\t\tvector<pair<long long int,long long int> >vec;\n\t\tvec.push_back({0,0});\n\t\tfor(int i=1;i<=n;i++){\n            mymax=max(mymax,s[i]);\n            //cout<<i<<\" \"<<mymax<<endl;\n\t\t\tif(mode==0){\n\t\t\t\tif(mymax==i){\n\t\t\t\t\tvec.push_back({1LL,0LL});\n\t\t\t\t}else{\n\t\t\t\t\tmode=1;\n\t\t\t\t\tcount1=1;\n\t\t\t\t}\n\t\t\t}else if(mode==1){\n\t\t\t\tif(s[i]>s[i-1]){\n\t\t\t\t\tcount1++;\n\t\t\t\t}else{\n\n                    if(mymax==i){\n                        \n\t\t\t\t\t    vec.push_back({count1,count2+1});\n\t\t\t\t\t\t//vec.push_back({1LL,0LL});\n\t\t\t\t\t\tmode=0;\n                        count1=0;\n                        count2=0;\n\t\t\t\t\t}else{\n\t\t\t\t\tmode=2;\n\t\t\t\t\tcount2++;memo=s[i-1];\n\t\t\t\t\t}\n                    \n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(mymax!=i&&memo>s[i]){\n\t\t\t\t\tcount2++;\n\t\t\t\t}else{\n\t\t\t\t\t//vec.push_back({count1,count2});\n\t\t\t\t\t//count1=0;\n\t\t\t\t\t//count2=0;\n\t\t\t\t\tif(mymax==i){\n                        \n\t\t\t\t\t    vec.push_back({count1,count2+1});\n\t\t\t\t\t\t//vec.push_back({1LL,0LL});\n\t\t\t\t\t\tmode=0;\n                        count1=0;\n                        count2=0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcount1++;\n\t\t\t\t\t\tmode=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n        \n\t\tif(count1>0||count2>0){vec.push_back({count1,count2});}\n\t\tdp[0][0]=1;\n\t\tfor(int i=1;i<vec.size();i++){\n            \n            //cout<<\"DEBUG : \"<<vec[i].first<<\" : \"<<vec[i].second<<endl;\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\tif(j+vec[i].first<=m){dp[i][j+vec[i].first]+=dp[i-1][j];}\n\t\t\t\tif(j+vec[i].second<=m){dp[i][j+vec[i].second]+=dp[i-1][j];}\n\t\t\t\tdp[i][j+vec[i].first]%=mod;\n\t\t\t\tdp[i][j+vec[i].second]%=mod;\n\t\t\t}\n\t\t}\n    //cout<<DEBUG<<endl;\n        res=0;\n\t\tfor(int i=n-m;i<=m;i++){\n\t\t\tres+=dp[vec.size()-1][i];\n\t\t}\n        \n\t\tcout<<res%mod<<endl;\n\t\t\n\t\t//for(int i=1;i<vec.size();i++){\n\t\t\t//cout<<vec[i].first<<\" \"<<vec[i].second<<endl;\n\t\t//}\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \n#define rep(i, n) for(int i=0;i<(n);++i)\n#define per(i, n) for(int i=(n)-1;i>=0;--i)\n#define repa(i, n) for(int i=1;i<(n);++i)\n#define lp(i, n) rep(i, n)\n#define foreach(i, n) for(auto &i:(n))\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll<(x))\n#define MOD ((ll)1e9+7)\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\nint n, m;\nvector<int> line;\nvector<int> maxs;\nvector<int> places;\nvvector<int> dp;\n\nvvector<int> isdp;\n\nbool isok(int l, int r){\n\tif(r<0)return true;\n\tif(isdp[l][r]>=0)return isdp[l][r];\n\tbool res = true;\n\tfor(int i=l;i<r;++i){\n\t\tif(line[i]>line[i+1]){\n\t\t\tres = false;\n\t\t}\n\t}\n\treturn isdp[l][r] = res;\n}\n\nll func(int place, int used, int rightest){\n\tif(place==n){\n\t\tif(n-used<=m&&used<=m)return 1;\n\t\treturn 0;\n\t}\n\tif(places[place]<rightest)return func(place+1, used, rightest);\n\tif(dp[place][used]>=0)return dp[place][used];\n\tif(isok(rightest+1, places[place]-1)==false)return 0;\n\tll res = 0;\n\tif((rightest!=-1)&&(maxs[rightest]<=place)){\n\t\tres += func(place+1, rightest+1-used+1, places[place]);\n\t}\n\tif((rightest==-1)||((places[place]-rightest)==1)||(maxs[rightest]<line[rightest+1])){\n\t\tres += func(place+1, used+1, places[place]);\n\t}\n\treturn dp[place][used] = res % MOD;\n}\n\nint main(){\n\tcin>>n>>m;\n\tline.resize(n);\n\tmaxs.resize(n, 0);\n\tplaces.resize(n);\n\tisdp.resize(n, vector<int>(n, -1));\n\tdp.resize(n, vector<int>(n, -1));\n\trep(i, n){\n\t\tcin >> line[i];\n\t\t--line[i];\n\t\tmaxs[i] = line[i];\n\t\tplaces[line[i]] = i;\n\t}\n\trep(i, n-1){\n\t\tmaxs[i+1] = max(maxs[i+1], maxs[i]);\n\t}\n\tcout << func(0, 0, -1) * 2 % MOD << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define N 100005\n#define MXN 2000005\nint dp[5005];\nint main(){\n    int n,m;\n    scanf(\"%d %d\",&n,&m);\n    int s[5005];\n    for(int i = 1;i<=n;i++)\n        scanf(\"%d\",&s[i]);\n    vector<int> v1,v2;\n    //v1.pb(1);\n    vector<pii> v;\n    int now=1,Max=0;\n    for(int i =1;i<=n;i++){\n        Max=max(Max,s[i]);\n        if(s[i]==now){\n            v2.pb(s[i]);\n        }  \n        else{\n            if(v2.empty()){\n                if(!v1.empty()&&s[i]<v1.back()){\n                    printf(\"0\\n\");\n                    return 0;\n                }\n                v1.pb(s[i]);\n            }\n            else{\n                if(v1.back()<s[i]){\n                    v1.pb(s[i]);\n                }\n                else if(v2.back()<s[i]){\n                    v2.pb(s[i]);\n                }\n                else{\n                    printf(\"0\\n\");\n                    return 0;\n                }\n            }\n        }\n        if((i-now+1)==v1.size()+v2.size()&&v2.size()&&i==Max){\n            v.pb(mp(v1.size(),v2.size()));\n          //  printf(\"%d %d\\n\",v1.size(),v2.size());\n            now=i+1;\n            v1.clear();\n            v2.clear();\n        }\n    }\n    dp[0]=1;\n    const int mod= 1e9+7;\n    for(auto it:v){\n        for(int j=n;j>=0;j--){\n            if(dp[j]){\n                int tmp=dp[j];\n                dp[j]=0;\n                dp[j+it.x]+=tmp;\n                dp[j+it.y]+=tmp;\n                dp[j+it.x]%=mod;\n                dp[j+it.y]%=mod;\n            }\n        }\n       // for(int j =0;j<=n;j++)\n        //    printf(\"%d \",dp[j]);\n        //printf(\"\\n\");\n    }\n    LL ans=0;\n    for(int i = 0;i<=n&&i<=m;i++){\n        if(n-i<=m)ans+=dp[i];\n    }\n    printf(\"%lld\\n\",ans%mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 5010\n\n/* Binary Indexed Tree(0-index) */\n\ntemplate <typename Type = int>\nstruct BIT{\n  int bit_size;\n  vector<Type> data;\n\n  void init(int n){\n    bit_size = n;\n    data.assign(n+2, 0);\n  }\n\n  //add x to kth value\n  void add(int k, Type x){\n    k++;\n    while(k <= bit_size){\n      data[k] += x;\n      if (data[k] >= mod) data[k] -= mod;\n      k += k & (-k);\n    }\n  }\n\n  //sum of [0,k)\n  Type query(int k){\n    ll rec = 0;\n    while(k > 0){\n      rec += data[k];\n      k -= k & (-k);\n    }\n    return rec % mod;\n  }\n\n  //sum of [a, b)\n  Type query(int a, int b){\n    return query(b) - query(a);\n  }\n};\n\nint s[SIZE];\nBIT<int> bit[SIZE];\nvector<pair<int,int>> history[SIZE];\n\nint main(){\n  int N, M;\n\n  cin >> N >> M;\n\n  s[0] = 0;\n  for (int i=0; i<N; i++)\n    cin >> s[i+1];\n\n\n  for (int i=0; i<=N; i++) {\n    bit[i].init(N+1);\n  }\n\n  bit[0].add(0, 1);\n  history[0].push_back({0, 1});\n\n  for (int i=0; i<N; i++) {\n    vector<pair<int,int>> vec;\n\n    for (int j=0; j<=i; j++) {\n      int x = bit[j].query(s[i+1]);\n      vec.push_back({i-j, x});\n\n      if (s[i] > s[i+1]) {\n        for (auto p : history[j]) {\n          bit[j].add(p.first, mod-p.second);\n        }\n        history[j].clear();\n      }\n    }\n\n    for (auto p : vec) {\n      bit[p.first].add(s[i], p.second);\n      history[p.first].push_back({s[i], p.second});\n    }\n  }\n\n  ll ans = 0;\n  for (int i=N-M; i<=M; i++) {\n    ans += bit[i].query(N+1);\n  }\n\n  cout << ans % mod << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<int(1e9)+7>;\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n\tint N, M; cin >> N >> M;\n\tvector<int> S(N);\n\tvector<int> invS(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> S[i]; S[i] --;\n\t\tinvS[S[i]] = i;\n\t}\n\n\tvector<int> badCnt(N);\n\tfor (int i = 0; i+1 < N; i++) {\n\t\tint a = invS[i], b = invS[i+1];\n\t\tif (a > b) {\n\t\t\tbadCnt[a]--;\n\t\t\tbadCnt[b]++;\n\t\t}\n\t}\n\tfor (int i = 0; i+1 < N; i++) {\n\t\tbadCnt[i+1] += badCnt[i];\n\t}\n\tvector<int> cutoffs;\n\tcutoffs.push_back(0);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (badCnt[i] == 0) cutoffs.push_back(i+1);\n\t}\n\n\tvector<num> dp({num(1)});\n\n\tfor (int z = 0; z+1 < int(cutoffs.size()); z++) {\n\t\tint l = cutoffs[z], r = cutoffs[z+1];\n\t\tvector<int> lhs;\n\t\tvector<int> rhs;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tint v = S[i];\n\t\t\tif (rhs.empty() || v > rhs.back()) {\n\t\t\t\trhs.push_back(v);\n\t\t\t} else if (lhs.empty() || v > lhs.back()) {\n\t\t\t\tlhs.push_back(v);\n\t\t\t} else {\n\t\t\t\tcout << 0 << '\\n';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\tvector<num> ndp(r+1);\n\t\tfor (int i = 0; i < int(dp.size()); i++) {\n\t\t\tndp[i+int(lhs.size())] += dp[i];\n\t\t\tndp[i+int(rhs.size())] += dp[i];\n\t\t}\n\t\tdp = std::move(ndp);\n\t}\n\tnum ans = 0;\n\tfor (int i = N-M; i <= M; i++) {\n\t\tans += dp[i];\n\t}\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <set>\n#include <tuple>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cfloat>\n#include <climits>\n#include <cassert>\n#include <random>\n#include <bitset>\n#include <memory>\n\nconstexpr long long int MOD = 1000000007;\nlong long int count(int current, int max_rest, int min_rest, const std::vector<std::pair<int, int>>& vec, std::vector<std::vector<long long int>>& memo) {\n\tif (min_rest < 0) return 0;\n\tif (current == vec.size()) return 1;\n\tif (memo[current][min_rest] >= 0) return memo[current][min_rest];\n\treturn memo[current][min_rest] = (count(current + 1, std::max(max_rest - vec[current].first, min_rest - vec[current].second), std::min(max_rest - vec[current].first, min_rest - vec[current].second), vec, memo) +\n\t\tcount(current + 1, std::max(max_rest - vec[current].second, min_rest - vec[current].first), std::min(max_rest - vec[current].second, min_rest - vec[current].first), vec, memo)) % MOD;\n}\nint main() {\n\tint n, m; std::cin >> n >> m;\n\tstd::vector<int> books(n), which(n, -1); for (auto& b : books) std::cin >> b;\n\tstd::vector<std::vector<int>> edges(n);\n\tfor (auto i = 0; i < n; ++i) {\n\t\tfor (auto j = 0; j < i; ++j) if (books[j] > books[i]) {\n\t\t\tedges[i].push_back(j);\n\t\t\tedges[j].push_back(i);\n\t\t}\n\t}\n\tstd::stack<int> stack;\n\tstd::vector<std::pair<int, int>> sub_groups;\n\tfor (auto i = 0; i < n; ++i) if (which[i] == -1) {\n\t\tstack.push(i);\n\t\tint count0{ 1 }, count1{ 0 };\n\t\twhich[i] = 0;\n\t\twhile (!stack.empty()) {\n\t\t\tconst auto top = stack.top(); stack.pop();\n\t\t\tfor (const auto next : edges[top]) if (which[next] != 1 - which[top]) {\n\t\t\t\tif (which[next] != -1) {\n\t\t\t\t\tstd::cout << 0 << '\\n';\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\twhich[next] = 1 - which[top];\n\t\t\t\tif (which[next] == 0) ++count0;\n\t\t\t\telse ++count1;\n\t\t\t\tstack.push(next);\n\t\t\t}\n\t\t}\n\t\tsub_groups.emplace_back(count0, count1);\n\t}\n\tstd::vector<std::vector<long long int>> memo(sub_groups.size(), std::vector<long long int>(m + 1, -1));\n\tstd::cout << count(0, m, m, sub_groups, memo) << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst long long int mod=1000000007,INF=9999999999999;\n\nlong long int dp[5500][5500]={};\nlong long int LDSmemo=0,dp2[200010],LISs[200005];\n\nlong long int GyakuLIS(long long int n,long long int s[]){\n\tLDSmemo=0;\n\tfor(long long int i=0;i<n;i++){\n\t\tdp2[i]=INF;\n\t\tLISs[i]=s[n-i];\n\t}\n\tfor(long long int i=0;i<n;i++){\n\t\t*lower_bound(dp2,dp2+n,LISs[i])=LISs[i];\n\t}\n    \n\treturn lower_bound(dp2,dp2+n,INF)-dp2;\n}\n\nlong long int kaijyou[200005]={1};\n\n\nlong long int ruijyou(long long int a,long long int b){\n\tif(b==0)return 1;\n\tlong long int res=ruijyou(a*a%mod,b/2);\n\tif(b & 1)res=res*a%mod;\n\treturn res;\n}\nlong long int combination(long long int a,long long int b){\n\tlong long int res=kaijyou[a]*ruijyou(kaijyou[b],mod-2)%mod;\n\tres=res*ruijyou(kaijyou[a-b],mod-2)%mod;\n\treturn res;\n}\n\nint main(){\n\tlong long int n,m,s[200005]={},type,res=0;\n\tcin>>n>>m;\n\tfor(long long int i=1;i<=2*n;i++){\n\t\tkaijyou[i]=i*kaijyou[i-1];\n\t\tkaijyou[i]%=mod;\n\t}\n    \n\tfor(int i=1;i<=n;i++){\n\t\tcin>>s[i];\n\t}\n\ttype=GyakuLIS(n,s);\n    \n\tif(type>2){cout<<\"0\"<<endl;return 0;}\n    \n\tif(type==1){\n\t\tfor(int i=n-m;i<=m;i++){\n\t\t\tres+=combination(n,i);\n\t\t\tres%=mod;\n\t\t}\t\t\n\t\tcout<<res<<endl;\n\t\t\n\t}else{\n\t\tlong long int before=0,mode=0,count1=0,count2=0,memo,mymax=0,used[5500]={};\n\t\tvector<pair<long long int,long long int> >vec;\n\t\tvec.push_back({0,0});\n\t\tfor(int i=1;i<=n;i++){\n            \n            used[s[i]]=1;\n            before=mode;\n            mode=0;\n            for(int j=1;j<=i;j++){\n                if(used[j]==0){\n                    \n                    mode=1;\n                }\n            }\n            \n            if(mode==0){\n                if(mymax>s[i]){count2++;}\n                else{mymax=s[i];count1++;}\n                vec.push_back({count1,count2});\n                \n                count1=0;\n                count2=0;\n            }else{\n                \n                    if(mymax>s[i]){count2++;}\n                    else{mymax=s[i];count1++;}\n                \n                \n            }\n\t\t}\n        \n\t\tif(count1>0||count2>0){vec.push_back({count1,count2});}\n\t\tdp[0][0]=1;\n\t\tfor(int i=1;i<vec.size();i++){\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\tif(j+vec[i].first<=m){dp[i][j+vec[i].first]+=dp[i-1][j];}\n\t\t\t\tif(j+vec[i].second<=m){dp[i][j+vec[i].second]+=dp[i-1][j];}\n\t\t\t\tdp[i][j+vec[i].first]%=mod;\n\t\t\t\tdp[i][j+vec[i].second]%=mod;\n\t\t\t}\n\t\t}\n        res=0;\n\t\tfor(int i=n-m;i<=m;i++){\n\t\t\tres+=dp[vec.size()-1][i];\n\t\t}\n\t\tcout<<res%mod<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<db,db> pdb;\ntypedef tuple<int,int,int> tii;\ntypedef tuple<ll,ll,ll> tll;\ntypedef vector<vector<ll>> mat;\nconst ll mod=1e9+7;\nconst int N=5005;\nint n,m,a[N],mn[N],mx[N];\nll dp[N][N],ans;\nint main(){\n    ios::sync_with_stdio(false); cin.tie(0);\n\tcin>>n>>m;\n    if(!m){\n        cout<<0;\n        return 0;\n    }\n    for(int i=1;i<=n;i++){\n        cin>>a[i];\n        mx[i]=max(mx[i-1],a[i]);\n    }\n    mn[n]=1e9;\n    for(int i=n-1;i;i--) mn[i]=min(mn[i+1],a[i+1]);\n    dp[1][1]=2;\n    for(int i=2;i<=n;i++){\n        if(a[i]!=mx[i]){\n            if(a[i]>=mn[i]) break;\n            for(int j=1;j<=m;j++) if(max(j,i-j)<=m) dp[i][j]=dp[i-1][j];\n        } else{\n            for(int j=1;j<=m;j++) if(max(j,i-j)<=m) dp[i][j]=dp[i-1][j-1];\n            if(mx[i-1]<=mn[i]) for(int j=1;j<=m;j++) if(max(j,i-j)<=m) (dp[i][j]+=dp[i-1][i-j])%=mod;\n        }\n    }\n    for(int i=1;i<=m;i++) (ans+=dp[n][i])%=mod;\n    cout<<ans<<\"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Pi = pair < int, int >;\nusing Pii = pair < int , Pi >;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr int dx[] = {1, 0, -1, 0};\nconstexpr int dy[] = {0, 1, 0, -1};\nconstexpr int mod = 1000000007;\n\nint N, M;\nint S[5005];\nvector < Pi > nums;\nint dp[5005][5005] = {};\n\nint main()\n{\n        cin >> N >> M;\n        \n        S[0] = 0;\n        for ( int i = 1; i <= N; i++ ) {\n                cin >> S[i];\n        }\n\n        int maxv = 0;\n        int pos = 0;\n        for ( int i = 1; i <= N; i++ ) {\n                maxv = max(maxv, S[i]);\n                if ( maxv == i ) {\n                        int p1 = 0, p2 = 0, c1 = 0, c2 = 0;\n                        for ( int j = pos + 1; j <= i; j++ ) {\n                                if ( p1 < S[j] ) {\n                                        p1 = S[j];\n                                        c1++;\n                                } else if ( p2 < S[j] ) {\n                                        p2 = S[j];\n                                        c2++;\n                                } else {\n                                        cout << 0 << endl;\n                                        return ( 0 );\n                                }\n                        }\n                        nums.emplace_back(c1, c2);\n                        pos = i;\n                }\n        }\n\n        dp[0][0] = 1;\n        int wa = 0;\n        for ( int i = 0; i < nums.size(); i++ ) {\n                int num1 = nums[i].first;\n                int num2 = nums[i].second;\n                for ( int j = 0; j <= wa; j++ ) { //左に何個積み上げているのか\n                        (dp[i + 1][j + num2] += dp[i][j]) %= mod;\n                        (dp[i + 1][j + num1] += dp[i][j]) %= mod;\n                }\n                wa += num1 + num2;\n        }\n\n        int sum = 0;\n        for ( int i = N - M; i <= M; i++ ) {\n                (sum += dp[nums.size()][N - i]) %= mod;\n        }\n\n        cout << sum << endl;\n\n        return ( 0 );\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// vvvvvvvvvvvv TEMPLATE vvvvvvvvvvvv\n#include <bits/stdc++.h>\nusing namespace std; using ll = long long; using P = pair<ll, ll>;\nconst ll linf = 1e18; const double eps = 1e-12, pi = acos(-1);\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define each(i,a) for (auto&& i : a)\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) begin(a),end(a)\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n#define min(x,y) (x < y ? x : y)\n#define max(x,y) (x < y ? y : x)\ntemplate<typename Head> void out(Head h) { cout << h << endl; } template<typename Head, typename... Tail>void out(Head h, Tail... t) { cout << h << \" \"; out(t...); }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& v) { each(x,v) is >> x; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) { rep(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<string>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\nstruct yes_no : std::numpunct<char> { string_type do_truename() const { return \"Yes\"; } string_type do_falsename() const { return \"No\"; } };\nvoid solve(); int main() {\n  ios::sync_with_stdio(false); cin.tie(0); locale loc(locale(), new yes_no); cout.imbue(loc); cout << fixed << setprecision(10) << boolalpha;\n  solve();\n}\n// ^^^^^^^^^^^^ TEMPLATE ^^^^^^^^^^^^\n\ntemplate <class Monoid>\nclass SegmentTree {\n  using T = typename Monoid::type;\n  const int size_, n;\n  std::vector<T> data;\n  int expand(int m) const { return m <= 1 ? 1 : expand((m + 1) / 2) * 2; }\npublic:\n  SegmentTree() : SegmentTree(0) {}\n  SegmentTree(const std::vector<T> &vec) :\n    size_(vec.size()), n(expand(size_)), data(n * 2, Monoid::id()) {\n    std::copy(begin(vec), end(vec), begin(data) + n);\n    for (int i = n - 1; i >= 0; --i) {\n      data[i] = Monoid::op(data[i * 2 + 0], data[i * 2 + 1]);\n    }\n  }\n  SegmentTree(const int count, const T &value = Monoid::id()) :\n    SegmentTree(std::vector<T>(count, value)) {}\n  int size() const { return size_; }\n  void update(int pos, const T &value) {\n    assert (0 <= pos && pos < size_); // assertion\n    data[pos += n] = value;\n    while (pos /= 2) {\n      data[pos] = Monoid::op(data[pos * 2], data[pos * 2 + 1]);\n    }\n  }\n  T find(int l, int r) const {\n    assert (0 <= l && l <= r && r <= size_); // assertion\n    l += n; r += n;\n    T res1 = Monoid::id(), res2 = Monoid::id();\n    while (l != r) {\n      if (l % 2) res1 = Monoid::op(res1, data[l++]);\n      if (r % 2) res2 = Monoid::op(data[--r], res2);\n      l /= 2; r /= 2;\n    }\n    return Monoid::op(res1, res2);\n  }\n  T operator[](size_t pos) {\n    return data[n+pos];\n  }\n  using value_type = T;\n  using update_type = T;\n};\n\nstruct Min {\n  using type = ll;\n  static type id() { return linf; }\n  static type op(const type &l, const type &r) { return min(l, r); }\n};\nstruct Max {\n  using type = ll;\n  static type id() { return -linf; }\n  static type op(const type &l, const type &r) { return max(l, r); }\n};\nstruct Sum {\n  using type = ll;\n  static type id() { return 0; }\n  static type op(const type &l, const type &r) { return l + r; }\n};\n\nstruct Node {\n  ll n1, n2;\n};\n\nNode f(const vector<ll>& a, ll l, ll r) {\n  ll cnt = 0, prv = -linf, prv2 = -linf;\n  rep(i, l, r) {\n    if (a[i] > prv) {\n      prv = a[i];\n      ++cnt;\n    }\n    else if (a[i] > prv2) {\n      prv2 = a[i];\n    }\n    else {\n      return {-1, -1};\n    }\n  }\n  return {cnt, r-l-cnt};\n}\n\nconstexpr ll mod = 1e9+7;\nconstexpr ll mul(ll a, ll b) { return a * b % mod; }\nll mul(initializer_list<ll> t) { ll res = 1; each(v, t) res = mul(res, v); return res; }\nll add(ll a, ll b) { return (a + b) % mod; }\nll add(initializer_list<ll> t) { ll res = 0; each(v, t) res = add(res, v); return res; }\nll sub(ll a, ll b) { return (a - b + mod) % mod; }\nll sub(initializer_list<ll> t) { auto it = t.begin(); ll res = *(it++); while (it != t.end()) res = sub(res, *(it++)); return res; }\nll inv(ll n); ll power(ll x, ll n) { if (n < 0) return inv(power(x, -n)); ll res = 1; for (ll i = 1; i <= n; i <<= 1) { if (i & n) res = mul(res, x); x = mul(x, x); } return res; }\nll inv(ll n) { return power(n, mod-2); }\nll divi(ll a, ll b) { return mul(a, inv(b)); }\nll divi(initializer_list<ll> t) { auto it = t.begin(); ll res = *(it++); while (it != t.end()) res = divi(res, *(it++)); return res; }\nvector<ll> fact, rfact;\nvoid init_fact(ll n) { fact.resize(n+1); fact[0] = 1; rep(i, n) fact[i+1] = mul(fact[i], i+1); rfact.resize(n+1); rfact[n] = inv(fact[n]); rrep(i, n) rfact[i] = mul(rfact[i], i+1); }\nll comb(ll n, ll r) { if (r < 0) return 0; if (r > n) return 0; return divi(fact[n], mul(fact[r], fact[n-r])); }\nll perm(ll n, ll r) { if (r < 0) return 0; if (r > n) return 0; return divi(fact[n], fact[n-r]); }\n\nusing Row = vector<ll>;\nusing Matrix = vector<Row>;\nMatrix E(ll n) { Matrix res(n, Row(n, 0)); rep(i, n) res[i][i] = 1; return res; }\nMatrix mul(const Matrix& A, const Matrix& B) { const ll n = A.size(), m = A[0].size(), l = B[0].size(); assert(m == B.size()); Matrix res(n, Row(l, 0)); rep(i, n) rep(j, m) rep(k, l) res[i][k] = add(res[i][k], mul(A[i][j], B[j][k])); return res; }\nRow mul(const Matrix& A, const Row& x) { Matrix tx(x.size()); rep(i, x.size()) tx[i] = Row(1, x[i]); tx = mul(A, tx); Row res(x.size()); rep(i, x.size()) res[i] = tx[i][0]; return res; }\nMatrix power(Matrix A, ll n) { assert(A.size() == A[0].size()); Matrix res = E(A.size()); for (ll i = 1; i <= n; i <<= 1) { if (i & n) res = mul(res, A); A = mul(A, A); } return res; }\n\nvoid solve() {\n  ll n, m; cin >> n >> m;\n  vector<ll> a(n); cin >> a;\n  each(x, a) --x;\n  SegmentTree<Sum> seg(n);\n  vector<Node> v;\n  ll l = 0;\n  rep(i, n) {\n    seg.update(a[i], 1);\n    if (seg.find(0, i+1) == i+1) {\n      auto node = f(a, l, i+1);\n      if (node.n1 < 0) {\n        cout << 0 << endl;\n        return;\n      }\n      v.pb(node);\n      l = i+1;\n    }\n  }\n  n = v.size();\n  vector<vector<ll>> dp(n+1, vector<ll>(m+1, 0));\n  dp[0][0] = 1;\n  ll sum = 0;\n  rep(i, n) {\n    rep(j, m+1) {\n      if (dp[i][j] == 0) continue;\n      ll n1 = j, n2 = sum - j;\n      assert(n2 >= 0);\n      {\n        ll nn1 = n1 + v[i].n1, nn2 = n2 + v[i].n2;\n        if (nn1 <= m && nn2 <= m) {\n          dp[i+1][nn1] = add(dp[i+1][nn1], dp[i][j]);\n        }\n      }\n      {\n        ll nn1 = n1 + v[i].n2, nn2 = n2 + v[i].n1;\n        if (nn1 <= m && nn2 <= m) {\n          dp[i+1][nn1] = add(dp[i+1][nn1], dp[i][j]);\n        }\n      }\n    }\n    sum += v[i].n1 + v[i].n2;\n  }\n  ll ans = 0;\n  rep(j, m+1) {\n    ans = add(ans, dp[n][j]);\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing ull=unsigned long long;\nusing uint=unsigned int;\nusing pcc=pair<char,char>;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing pdd=pair<double,double>;\nusing tuplis=pair<ll,pll>;\nusing tuplis2=pair<pll,ll>;\ntemplate<class T> using pq=priority_queue<T,vector<T>,greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst ll MOD=1000000007;\nconst ll MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.141592653589793238462643383279;\nconst vector<ll>four{0,1,0,-1,0};\n#define _overload4(_1,_2,_3,_4,name,...) name\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep1(n) for(ll i=0;i<n;++i)\n#define _rep2(i,n) for(ll i=0;i<n;++i)\n#define _rep3(i,a,b) for(ll i=a;i<b;++i)\n#define _rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) _overload4(__VA_ARGS__,_rep4,_rep3,_rep2,_rep1)(__VA_ARGS__)\n#define _rrep1(n) for(ll i=(n)-1;i>=0;i--)\n#define _rrep2(i,n) for(ll i=(n)-1;i>=0;i--)\n#define _rrep3(i,a,b) for(ll i=(b)-1;i>=(a);i--)\n#define _rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) _overload4(__VA_ARGS__,_rrep4,_rrep3,_rrep2,_rrep1)(__VA_ARGS__)\n#define each(i,a) for(auto &i:a)\n#define sum(...) accumulate(range(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(range(__VA_ARGS__),double(0))\n#define _range(i) (i).begin(),(i).end()\n#define _range2(i,k) (i).begin(),(i).begin()+k\n#define _range3(i,a,b) (i).begin()+a,(i).begin()+b\n#define range(...) _overload3(__VA_ARGS__,_range3,_range2,_range)(__VA_ARGS__)\n#define _rrange(i) (i).rbegin(),(i).rend()\n#define _rrange2(i,k) (i).rbegin(),(i).rbegin()+k\n#define _rrange3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rrange(...) _overload3(__VA_ARGS__,_rrange3,_rrange2,_rrange)(__VA_ARGS__)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ninline ll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\ninline ll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\ntemplate<class T> inline T min(const vector<T> &v){ return *min_element(range(v)); }\ninline char min(const string &v){ return *min_element(range(v)); }\ntemplate<class T> inline T max(const vector<T> &v){ return *max_element(range(v)); }\ninline char max(const string &v){ return *max_element(range(v)); }\ninline ll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\ntemplate<class T> inline bool chmin(T &a, const T &b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmax(T &a, const T &b){ if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T> unordered_map<T, ll> press(vector<T> &a){ auto b = a; sort(range(b)); b.erase(unique(range(b)), b.end()); unordered_map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T> &a){ auto b = a; sort(range(b)); b.erase(unique(range(b)), b.end()); map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ninline int scan(){ return getchar(); }\ninline void scan(int &a){ scanf(\"%d\", &a); }\ninline void scan(unsigned &a){ scanf(\"%u\", &a); }\ninline void scan(long &a){ scanf(\"%ld\", &a); }\ninline void scan(long long &a){ scanf(\"%lld\", &a); }\ninline void scan(unsigned long long &a){ scanf(\"%llu\", &a); }\ninline void scan(char &a){ cin >> a; }\ninline void scan(float &a){ scanf(\"%f\", &a); }\ninline void scan(double &a){ scanf(\"%lf\", &a); }\ninline void scan(long double &a){ scanf(\"%Lf\", &a); }\ninline void scan(vector<bool> &vec){ for(unsigned i = 0; i < vec.size(); i++) { int a; scan(a); vec[i] = a; } }\ninline void scan(char a[]){ scanf(\"%s\", a); }\ninline void scan(string &a){ cin >> a; }\ntemplate<class T> inline void scan(vector<T> &vec);\ntemplate<class T, size_t size> inline void scan(array<T, size> &vec);\ntemplate<class T, class L> inline void scan(pair<T, L> &p);\ntemplate<class T, size_t size> inline void scan(T (&vec)[size]);\ntemplate<class T> inline void scan(vector<T> &vec){ for(auto &i : vec) scan(i); }\ntemplate<class T> inline void scan(deque<T> &vec){ for(auto &i : vec) scan(i); }\ntemplate<class T, size_t size> inline void scan(array<T, size> &vec){ for(auto &i : vec) scan(i); }\ntemplate<class T, class L> inline void scan(pair<T, L> &p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> inline void scan(T (&vec)[size]){ for(auto &i : vec) scan(i); }\ntemplate<class T> inline void scan(T &a){ cin >> a; }\ninline void in(){}\ntemplate <class Head, class... Tail> inline void in(Head &head, Tail&... tail){ scan(head); in(tail...); }\ninline void print(){ putchar(' '); }\ninline void print(const bool &a){ printf(\"%d\", a); }\ninline void print(const int &a){ printf(\"%d\", a); }\ninline void print(const unsigned &a){ printf(\"%u\", a); }\ninline void print(const long &a){ printf(\"%ld\", a); }\ninline void print(const long long &a){ printf(\"%lld\", a); }\ninline void print(const unsigned long long &a){ printf(\"%llu\", a); }\ninline void print(const char &a){ printf(\"%c\", a); }\ninline void print(const char a[]){ printf(\"%s\", a); }\ninline void print(const float &a){ printf(\"%.15f\", a); }\ninline void print(const double &a){ printf(\"%.15f\", a); }\ninline void print(const long double &a){ printf(\"%.15Lf\", a); }\ninline void print(const string &a){ for(auto&& i : a) print(i); }\ntemplate<class T> inline void print(const vector<T> &vec);\ntemplate<class T, size_t size> inline void print(const array<T, size> &vec);\ntemplate<class T, class L> inline void print(const pair<T, L> &p);\ntemplate<class T, size_t size> inline void print(const T (&vec)[size]);\ntemplate<class T> inline void print(const vector<T> &vec){ if(vec.empty()) return; print(vec[0]); for(auto i = vec.begin(); ++i != vec.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> inline void print(const deque<T> &vec){ if(vec.empty()) return; print(vec[0]); for(auto i = vec.begin(); ++i != vec.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> inline void print(const array<T, size> &vec){ print(vec[0]); for(auto i = vec.begin(); ++i != vec.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> inline void print(const pair<T, L> &p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> inline void print(const T (&vec)[size]){ print(vec[0]); for(auto i = vec; ++i != end(vec); ){ putchar(' '); print(*i); } }\ntemplate<class T> inline void print(const T &a){ cout << a; }\ninline int out(){ putchar('\\n'); return 0; }\ntemplate<class T> inline int out(const T &t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> inline int out(const Head &head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\ninline void err(){ putchar('\\n'); }\ntemplate<class T> inline void err(const T &t){ print(t); putchar('\\n'); }\ntemplate<class Head, class... Tail> inline void err(const Head &head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\ntemplate<class... T> inline void err(const T&... t){}\n#endif\ninline int first(bool i = true){ return out(i?\"first\":\"second\"); }\ninline int yes(bool i = true){ return out(i?\"yes\":\"no\"); }\ninline int Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\ninline int No(){ return out(\"No\"); }\ninline int YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\ninline int NO(){ return out(\"NO\"); }\ninline int Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\ninline int Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\ninline int POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\ninline void Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\nconstexpr uint mod = MOD;\nstruct Modint{\n    uint num = 0;\n    constexpr Modint(){}\n    constexpr Modint(const Modint &x) : num(x.num){}\n    inline constexpr operator ll() const { return num; }\n    inline constexpr Modint& operator+=(Modint x){ num += x.num; if(num >= mod) num -= mod; return *this; }\n    inline constexpr Modint& operator++(){ if(num == mod - 1) num = 0; else num++; return *this; }\n    inline constexpr Modint operator++(int){ Modint ans(*this); operator++(); return ans; }\n    inline constexpr Modint operator- () const { return Modint(0) -= *this; }\n    inline constexpr Modint operator- (Modint x) const { return Modint(*this) -= x; }\n    inline constexpr Modint& operator-=(Modint x){ if(num < x.num) num += mod; num -= x.num; return *this; }\n    inline constexpr Modint& operator--(){ if(num == 0) num = mod - 1; else num--; return *this; }\n    inline constexpr Modint operator--(int){ Modint ans(*this); operator--(); return ans; }\n    inline constexpr Modint& operator*=(Modint x){ num = ull(num) * x.num % mod; return *this; }\n    inline constexpr Modint& operator/=(Modint x){ return operator*=(x.inv()); }\n    template<class T> constexpr Modint(T x){ x %= T(mod); if(x < 0) x += mod; num = uint(x); }\n    template<class T> inline constexpr Modint operator+(T x) const { return Modint(*this) += x; }\n    template<class T> inline constexpr Modint& operator+=(T x){ x %= mod; if(x < 0) x += mod; num += x; if(num >= mod) num -= mod; return *this; }\n    template<class T> inline constexpr Modint operator- (T x) const { return Modint(*this) -= x; }\n    template<class T> inline constexpr Modint& operator-=(T x){ return operator-=(Modint(x)); }\n    template<class T> inline constexpr Modint operator* (T x) const { return Modint(*this) *= x; }\n    template<class T> inline constexpr Modint& operator*=(T x){ return operator*=(Modint(x)); }\n    template<class T> inline constexpr Modint operator/ (T x) const { return Modint(*this) /= x; }\n    template<class T> inline constexpr Modint& operator/=(T x){ return operator/=(Modint(x)); }\n    inline constexpr Modint inv() const { ll x = 0, y = 0; extgcd(num, mod, x, y); return x; }\n    inline constexpr ll extgcd(ll a, ll b, ll &x, ll &y) const { ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\n    inline constexpr Modint pow(ull x) const { Modint ans = 1, cnt = *this; while(x){ if(x & 1) ans *= cnt; cnt *= cnt; x /= 2; } return ans; }\n};\nstd::istream& operator>>(std::istream& is, Modint& x) { ll a; is >> a; x = a; return is; }\ninline constexpr Modint operator\"\"_M(ull x) { return Modint(x); }\nstd::vector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(ll a){\n    if(fac.size() >= a) return;\n    if(a < fac.size() * 2) a = fac.size() * 2;\n    if(a >= mod) a = mod;\n    while(fac.size() < a) fac.push_back(fac.back() * Modint(fac.size()));\n    inv.resize(fac.size());\n    inv.back() = fac.back().inv();\n    for(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint fact(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint perm(ll n, ll r){ if(r < 0 || n < r) return 0; reserve(n + 1); return fac[n] * inv[n - r]; }\ninline Modint comb(ll n, ll r){ if(r < 0 || n < r) return 0; reserve(n + 1); return fac[n] * inv[r] * inv[n - r]; }\ninline Modint Mcomb(ll n, ll r){ return comb(n + r - 1, n - 1); } // r個をn部屋に分ける\ninline Modint catalan(ll n){ reserve(n * 2 + 1); return fac[n * 2] * inv[n] * inv[n + 1]; }\nint main(){\n    LL(n,m);\n    VEC(ll,a,n);\n    each(i,a)i--;\n    vv(Modint,dp,n+2,n+2);\n    dp[0][0]=1;\n    vec(bool,used,n);\n    ll at=0,min=0,large=-1,small=-2;\n    rep(n+1){\n        while(min<n&&used[min])min++;\n        if(min==n)break;\n        ll cnt=0;\n        bool flag=large==min-1;\n        while(a[at]!=min){\n            if(large>=a[at])return out(0);\n            large=a[at];\n            used[a[at]]=1;\n            cnt++;\n            at++;\n        }\n        used[min]=1;\n        at++;\n        if(flag){\n            if(cnt==0){\n                large=min;\n                small=min-1;\n                rep(j,1,n+1)dp[i+1+cnt][j]+=dp[i][j-1];\n                rep(j,0,i+2)dp[i+1+cnt][j]+=dp[i][i+1-j];\n            }\n            else{\n                small=min;\n                rep(j,1,n+1)dp[i+1+cnt][j]+=dp[i][j-1];\n                rep(j,0,i+2)dp[i+1+cnt][j]+=dp[i][i+1-j];\n            }\n        }\n        else{\n            small=min;\n            rep(j,1,n+1)dp[i+1+cnt][j]+=dp[i][j-1];\n        }\n        i+=cnt;\n    }\n    Modint ans=0;\n    rep(i,n-m,m+1)ans+=dp[n][i];\n    out(ans);\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef _MSC_VER\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\ntemplate<class T> inline void ckmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void ckmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,a) for(int i=0;i<(a);++i)\n#define ALL(A) A.begin(),A.end()\nusing VI=vector<int>;\n\ntemplate<typename base_type, base_type _MOD>\nclass IntMod\n{\npublic:\n\tstatic const int INVERSE_CACHE_SIZE = (1 << 20);\n\tstatic base_type MOD;\n\tstatic void set_mod(base_type new_mod) { MOD = new_mod; }\n\n\tbase_type n;\n\n\tIntMod(long long d = 0) { n = (d >= 0 ? d % MOD : (d % MOD + MOD) % MOD); }\n\tvirtual ~IntMod() = default;\n\n\tIntMod operator-() const { return build(n == 0 ? 0 : MOD - n); }\n\tIntMod& operator+=(IntMod a) { n = (n >= MOD - a.n ? n - MOD + a.n : n + a.n); return *this; }\n\tIntMod& operator-=(IntMod a) { n = (n >= a.n) ? n - a.n : n - a.n + MOD; return *this; }\n\tIntMod& operator*=(IntMod a) { *this = *this * a; return *this; }\n\tIntMod& operator/=(IntMod a) { *this = *this / a; return *this; }\n\n\tstatic IntMod build(base_type n) { IntMod r; r.n = n; return r; }\n\n\tstatic base_type inverse_cache[INVERSE_CACHE_SIZE];\n\tstatic bool inverse_cache_ready;\n\tfriend IntMod inverse(IntMod n) { return build(inverse_internal(n.n)); }\n\tstatic base_type inverse_internal(base_type n)\n\t{\n\t\tif (!inverse_cache_ready) \n\t\t{\n\t\t\tinverse_cache_ready=true;\n\t\t\tinverse_cache[0] = 0;\n\t\t\tinverse_cache[1] = 1;\n\t\t\tfor (int n = 2; n < INVERSE_CACHE_SIZE; ++n) inverse_cache[n] = (MOD - (base_type)((long long)inverse_cache[MOD % n] * (MOD / n) % MOD));\n\t\t}\n\t\treturn n < INVERSE_CACHE_SIZE ? inverse_cache[n] : MOD - (base_type)((long long)inverse_internal(MOD % n) * (MOD / n) % MOD);\n\t}\n\n\tfriend bool operator==(IntMod a, IntMod b) { return a.n == b.n; }\n\tfriend bool operator!=(IntMod a, IntMod b) { return a.n != b.n; }\n\tfriend IntMod operator+(IntMod a, IntMod b) { return build(a.n >= MOD - b.n ? a.n - MOD + b.n : a.n + b.n); }\n\tfriend IntMod operator-(IntMod a, IntMod b) { return build(a.n >= b.n ? a.n - b.n : a.n - b.n + MOD); }\n\tfriend IntMod operator*(IntMod a, IntMod b) { return build(static_cast<base_type>(static_cast<long long>(a.n) * b.n % MOD)); }\n\tfriend IntMod operator/(IntMod a, IntMod b) { return a * inverse(b); }\n\tfriend IntMod pow(IntMod p, long long e)\n\t{\n\t\tif (e <= 0) return IntMod(1);\n\t\tIntMod r = IntMod(1);\n\t\twhile (1) { if (e & 1) r *= p; e /= 2; if (e) p = p * p; else break; }\n\t\treturn r;\n\t}\n\n\tfriend istream& operator>>(istream &stream, IntMod &a) { stream >> a.n; return stream; }\n\tfriend ostream& operator<<(ostream &stream, const IntMod &a) { stream << a.n; return stream; }\n};\ntemplate<typename base_type, base_type _MOD> base_type IntMod<base_type, _MOD>::inverse_cache[INVERSE_CACHE_SIZE];\ntemplate<typename base_type, base_type _MOD> bool IntMod<base_type, _MOD>::inverse_cache_ready;\ntemplate<typename base_type, base_type _MOD> base_type IntMod<base_type, _MOD>::MOD = _MOD;\n\n#define MOD (1000000007)\nusing Int = IntMod<int, MOD>;\n\nconst int maxsize=200000;\n\nInt permutation[maxsize];\nInt permutation_inv[maxsize];\n\nInt choose(int n,int m)\n{\n\treturn (m<0 || m>n?0:permutation[n]*permutation_inv[m]*permutation_inv[n-m]);\n}\nvoid prepare()\n{\n\tpermutation[0]=permutation_inv[0]=1;\n\tFOR(i,1,maxsize)\n\t{\n\t\tpermutation[i]=permutation[i-1]*i;\n\t\tpermutation_inv[i]=permutation_inv[i-1]/i;\n\t}\n}\n\nvoid expand(vector<Int>& f,int cnt)\n{\n\tint n=SIZE(f)-1;\n\tfor (;cnt>0;--cnt)\n\t\tfor (int i=n;i>0;i--)\n\t\t\tf[i]+=f[i-1];\n}\n\nint solve(VI a,int m)\n{\n\tint n=SIZE(a);\n\tif (n==1) return 2;\n\tvector<Int> f(n+1);\n\tf[0]=1;\n\tint c1=0,c2=0;\n\tfor (int k=0;k<n;)\n\t{\n\t\tif (c1>a[k]) return 0;\n\t\tint p=k;\n\t\tfor (;p+1<n && a[p]<a[p+1];++p);\n\t\tif (p>=n-1)\n\t\t{\n\t\t\tfor (;k<n && a[k]<c2;k++);\n\t\t\texpand(f,n-k);\n\t\t\tInt ret=0;\n\t\t\tfor (int c1=0;c1<=m;c1++) if (n-c1<=m) ret+=f[c1];\n\t\t\treturn ret.n;\n\t\t}\n\t\tif (c2>a[p]) return 0;\n\t\tfor (;a[k]<c2;k++) c1=a[k];\n\t\tif (c1>a[p+1]) return 0;\n\t\tint key=a[p+1];\n\t\tint cnt=0;\n\t\tfor (;a[k]<key;k++) cnt++;\n\t\texpand(f,cnt);\n\t\tvector<Int> g(n+1);\n\t\tint cnt2=p-k+1;\n\t\tint ep=(c2<a[p+1]);\n\t\tREP(c1,SIZE(f)) if (f[c1].n)\n\t\t{\n\t\t\tif (c1+cnt2<=n) g[c1+cnt2]+=f[c1];\n\t\t\tif (ep)\n\t\t\t{\n\t\t\t\tint c2=k-c1;\n\t\t\t\tif (c2+cnt2<=n) g[c2+cnt2]+=f[c1];\n\t\t\t}\n\t\t}\n\t\tf.swap(g);\n\t\tc2=a[p];\n\t\tc1=a[p+1];\n\t\tk=p+2;\n\t}\n\tInt ret=0;\n\tfor (int c1=0;c1<=m;c1++) if (n-c1<=m) ret+=f[c1];\n\treturn ret.n;\n}\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tstd::ios::sync_with_stdio(false);\n\tprepare();\n\t/*\n\tint ee=solve(VI{3,1,4,2},2);\n\tprintf(\"ee = %d\\n\",ee);\n\tfor (int n=1;n<=8;n++)\n\t{\n\t\tprintf(\"n = %d\\n\",n);\n\t\tVI p(n);\n\t\tREP(i,n) p[i]=i+1;\n\t\tdo{\n\t\t\tfor (int m=(n+1)/2;m<=n;m++)\n\t\t\t{\n\t\t\t\tint r1=solve(p,m);\n\t\t\t\tint r2=0;\n\t\t\t\tREP(set,two(n))\n\t\t\t\t{\n\t\t\t\t\tint p1=0,p2=0,c1=0,c2=0;\n\t\t\t\t\tint ok=1;\n\t\t\t\t\tREP(i,n)\n\t\t\t\t\t\tif (contain(set,i))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (p[i]<p1) ok=0;\n\t\t\t\t\t\t\tp1=p[i];\n\t\t\t\t\t\t\t++c1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (p[i]<p2) ok=0;\n\t\t\t\t\t\t\tp2=p[i];\n\t\t\t\t\t\t\t++c2;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (ok && c1<=m && c2<=m) ++r2;\n\t\t\t\t}\n\t\t\t\tif (r1!=r2)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"ERROR\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} while (next_permutation(ALL(p))!=0);\n\t}\n\t*/\n\tint n,m;\n\twhile (cin>>n>>m && n!=0)\n\t{\n\t\tVI a(n);\n\t\tREP(i,n) cin>>a[i];\n\t\tint ret=solve(a,m);\n\t\tprintf(\"%d\\n\",ret);\n#ifndef _MSC_VER\n\t\tbreak;\n#endif\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <random>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\n#define For(i , a , b) for (int i = a , _b = b ; i <= _b ; ++i)\n#define Ford(i , a  ,b) for (int i = a , _b = b : i >= _b ; --i)\n#define Rep(i , n) for (int i = 0 , _n = n ; i < _n ; ++i)\n#define sz(A) ((int)A.size())\n#define LL(x) (x << 1)\n#define RR(x) ((x << 1) | 1)\n\ntypedef long long ll;\ntypedef pair<int , int> pt;\n\nconst int maxn = 5000 + 123;\nconst int MOD = 1e9 + 7;\nint n, m;\nint a[maxn];\n\n\nstd::vector<int> V[maxn];\nint scc = 0;\nint color[maxn];\nint odd[maxn][2];\n\nll f[maxn];\n\n\nvoid fail() {\n\tcout << 0 << endl;\n\texit(0);\n}\n\nvoid dfs(int u) {\n\todd[scc][color[u] - 1]++;\n\tfor (auto v: V[u]) {\n\t\tif (color[v]) {\n\t\t\tif (color[v] == color[u]) {\n\t\t\t\treturn fail();\n\t\t\t}\n\t\t} else {\n\t\t\tcolor[v] = 3 - color[u];\n\t\t\tdfs(v);\n\t\t}\n\t}\n}\n\n\nint f1[maxn];\nint solve() {\n\tcin >> n >> m;\n\tFor(i,1,n) cin >> a[i];\n\n\tFor(i,1,n) For(j, i + 1, n) if (a[j] < a[i]) {\n\t\tV[i].push_back(j);\n\t\tV[j].push_back(i);\n\t}\n\n\tmemset(color, 0, sizeof(color));\n\tmemset(odd, 0, sizeof(odd));\n\tscc = 0;\n\tFor(u, 1, n) if (!color[u]) {\n\t\tcolor[u] = 1;\n\t\tscc++;\n\t\tdfs(u);\n\t}\n\n    f[0] = 1;\n    for(int i = 1; i <= scc; i++) {\n        for(int j = 0; j <= n; j++) f1[j] = f[j], f[j] = 0;\n        for(int j = n; j >= 0; j--) {\n            for(int k = 0; k <= 1; k++) if (j >= odd[i][k]) \n                f[j] = (f[j] + f1[j - odd[i][k]]) % MOD;\n        }\n    }\n    ll ans = 0;\n    for(int i = n - m; i <= m; i++)\n        ans = (ans + f[i]) % MOD;\n    return ans;\n\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n    cout << solve() << endl;\n\t\n\n\treturn 0;\n\n}\t\t\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T> using vec = vector<T>;\ntemplate<class T> using vvec = vector<vec<T>>;\nusing P = pair<int,int>;\nconst ll mod = 1e9+7;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\n\nint main(){\n    int N,M;\n    cin >> N >> M;\n    vec<int> S(N);\n    for(int i=0;i<N;i++){\n        cin >> S[i];\n        S[i]--;\n    }\n    vvec<int> g(N);\n    for(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n        if(S[i]>S[j]){\n            g[i].push_back(j);\n            g[j].push_back(i);\n        }\n    }\n    vec<int> c(N,-1);\n    vvec<int> cmp;\n    function<bool(int,int,vec<int>&)> dfs = [&](int n,int col,vec<int>& v){\n        c[n] = col;\n        bool ok = true;\n        for(auto& e:g[n]){\n            if(c[e]==-1) ok &= dfs(e,1-col,v);\n            else if(c[e]==col) return false;\n        }\n        v[col]++;\n        return ok;\n    };\n    for(int i=0;i<N;i++) if(c[i]==-1){\n        vec<int> res = vec<int>(2,0);\n        bool ok = dfs(i,1,res);\n        if(!ok){\n            cout << 0 << endl;\n            return 0;\n        }\n        cmp.push_back(res);\n    }\n    int n = cmp.size();\n    vvec<mint> dp(n+1,vec<mint>(N+1,0));\n    dp[0][0] = 1;\n    for(int i=0;i<n;i++) for(int j=0;j<N;j++){\n        for(int k=0;k<2;k++){\n            if(j-cmp[i][k]>=0) dp[i+1][j] += dp[i][j-cmp[i][k]];\n        }\n    }\n    mint ans = 0;\n    for(int i=N-M;i<=M;i++) ans += dp[n][i];\n    cout << ans.x << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[10000100];\n                int inv[10000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\n\n\n\nint vis[5100]={};\nint dp[5010][5010]={};\n\nsigned main(){\n\t\n\t\n   cin.tie(0);\n\tios::sync_with_stdio(false);\nint n,m;\n\tcin>>n>>m;\n\tvector<int> ve(n+1);\n\tfor(int i=1;i<=n;i++)cin>>ve[i];\n\tvector<int> las;\n\tlas.pb(0);\n\tfor(int i=1;i<=n;i++){\n\t\tvis[ve[i]]=1;\n\t\tint cnt=0;\n\t\tfor(int j=1;j<=i;j++)cnt+=vis[j];\n\t\tif(cnt==i)las.pb(i);\n\t}\n\t\n\tint d=las.size();\n\td--;\n\t\n\t\n\tvector<pa> W;\n\tfor(int ii=1;ii<=d;ii++){\n\t\tint mae=las[ii-1]+1,ato=las[ii]+1;\n\t\t//cout<<mae<<\"   \"<<ato<<endl;\n\t\tif(ato-mae==1){\n\t\t\tW.pb(mp(0,1));\n\t\t}\n\t\telse{\n\t\t\tint a=ve[mae];\n\t\t\tint b=-1;\n\t\t\tint cnt=0;\n\t\t\tfor(int i=mae+1;i<ato;i++){\n\t\t\t\tif(b==-1){\n\t\t\t\t\tif(ve[i]>a) a=ve[i];\n\t\t\t\t\telse{\n\t\t\t\t\t\tb=ve[i];\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(ve[i]<b){\n\t\t\t\t\t\tcout<<0<<endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(ve[i]<a){\n\t\t\t\t\t\tb=ve[i];\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\telse a=ve[i];\n\t\t\t\t}\n\t\t\t}\n\t\t//\tcout<<b<<\" \"<<a<<endl;\n\t\t\tW.pb(mp(cnt,ato-mae-cnt));\n\t\t}\n\t}\n\t\n\t//for(auto v:W)cout<<v.first<<\" \"<<v.second<<endl;\n\t\n\tdp[0][0]=1;\n\tfor(int i=0;i<W.size();i++)for(int j=0;j<=n;j++)if(dp[i][j]){\n\t\tdp[i+1][j+W[i].first]+=dp[i][j];\n\t\tdp[i+1][j+W[i].second]+=dp[i][j];\n\t\t\n\t\tdp[i+1][j+W[i].first]%=inf;\n\t\tdp[i+1][j+W[i].second]%=inf;\n\t\n\t}\n\tint ans=0;\n\tfor(int j=0;j<=n;j++)if(max(j,n-j)<=m)ans+=dp[W.size()][j];\n\t\n\tcout<<ans%inf<<endl;\n \t\n }\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <unordered_map> \n#include <unordered_set>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\ntypedef tuple<int, int, int> T;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\nvector<long long int> E[6000];\n\nint s[6000];\nint used[6000];\nint cnt1 = 0, cnt2 = 0;\n\nlong long int DP[5100][5100];\n\nbool func(int pos, bool odd){\n\tif(used[pos] != 0){\n\t\tif(used[pos] == 1 && !odd || used[pos] == -1 && odd){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tif(odd){\n\t\tcnt1 += 1;\n\t\tused[pos] = 1;\n\t}else{\n\t\tcnt2 += 1;\n\t\tused[pos] = -1;\n\t}\n\tfor(int to : E[pos]){\n\t\tbool ret = func(to, !odd);\n\t\tif(!ret){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> s[i];\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = i + 1; j < n; j++){\n\t\t\tif(s[i] > s[j]){\n\t\t\t\tE[i].push_back(j);\n\t\t\t\tE[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tDP[0][0] = 1;\n\tfor(int i = 0; i < n; i++){\n\t\tif(used[i] == 0){\n\t\t\tint preS = cnt1 + cnt2;\n\t\t\tint pre1 = cnt1;\n\t\t\tint pre2 = cnt2;\n\t\t\tbool ret = func(i, true);\n\t\t\tif(!ret){\n\t\t\t\tcout << 0 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint d1 = cnt1 - pre1;\n\t\t\tint d2 = cnt2 - pre2;\n\t\t\tfor(int i = 0; i <= preS; i++){\n\t\t\t\tif(i + d1 < 5100 && preS - i + d2 < 5100){\n\t\t\t\t\tDP[i + d1][preS - i + d2] += DP[i][preS - i];\n\t\t\t\t\tDP[i + d1][preS - i + d2] %= MOD;\n\t\t\t\t}\n\t\t\t\tif(i + d2 < 5100 && preS - i + d1 < 5100){\n\t\t\t\t\tDP[i + d2][preS - i + d1] += DP[i][preS - i];\n\t\t\t\t\tDP[i + d2][preS - i + d1] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ans = 0;\n\tfor(int i = n - m; i <= m; i++){\n\t\tans += DP[i][n - i];\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nvoid add(int &a, const int &b) {\n\ta += b;\n\tif (a >= MOD)a -= MOD;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> A(N);\n\tvector<int> V(N, 0);\n\tint mn = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t\tA[i]--;\n\t}\n\t{\n\t\tint t = -1;\n\t\tint b = -1;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (t < A[i]) {\n\t\t\t\tt = A[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (b > A[i]) {\n\t\t\t\t\tcout << 0 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tb = A[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tint mx = -1;\n\tpair<int, int> cur;\n\tvector<pair<int, int> > X;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (mx < A[i]) {\n\t\t\tif (mx < mn) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tX.push_back(cur);\n\t\t\t\t}\n\t\t\t\tcur.first = 1;\n\t\t\t\tcur.second = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcur.first++;\n\t\t\t}\n\t\t\tmx = A[i];\n\t\t}\n\t\telse {\n\t\t\tcur.second++;\n\t\t}\n\t\tV[A[i]] = 1;\n\t\twhile (mn < N && V[mn] == 1)mn++;\n\t}\n\tX.push_back(cur);\n\n\t/*for (int i = 0; i < X.size(); i++) {\n\t\tcerr << X[i].first << \" \" << X[i].second << endl;\n\t}*/\n\tvector<int> dp(N + 1, 0);\n\tdp[0] = 1;\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tvector<int> ndp(N + 1, 0);\n\t\tfor (int j = 0; j + X[i].first <= N; j++) {\n\t\t\tadd(ndp[j + X[i].first], dp[j]);\n\t\t}\n\t\tfor (int j = 0; j + X[i].second <= N; j++) {\n\t\t\tadd(ndp[j + X[i].second], dp[j]);\n\t\t}\n\t\tswap(dp, ndp);\n\t}\n\n\tint res = 0;\n\tfor (int i = N - M; i <= M; i++) {\n\t\tadd(res, dp[i]);\n\t}\n\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 1000000007\n\nint n, x, ans, dp[5005][5005];\nset<int> s, se;\n\nvoid add(int& a, int b) {\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n}\n\nint main() {\n\ts.insert(0);\n\tscanf(\"%d%d\", &n, &x);\n\tdp[0][1] = 2;\n\tfor (int i = 1; i <= n + 1; i++)\n\t\tse.insert(i);\n\tfor (int i = 0; i < n; i++) {\n\t\tint tmp;\n\t\tscanf(\"%d\", &tmp);\n\t\tif (i) {\n\t\t\tif (tmp > *s.rbegin()) {\n\t\t\t\tfor (int j = 0; j <= i; j++)\n\t\t\t\t\tadd(dp[i][j + 1], dp[i - 1][j]);\n\t\t\t\tif (*s.rbegin() < *se.begin())\n\t\t\t\t\tfor (int j = 0; j <= i; j++)\n\t\t\t\t\t\tadd(dp[i][i - j + 1], dp[i - 1][j]);\n\t\t\t} else if (tmp == *se.begin())\n\t\t\t\tfor (int j = 0; j <= i; j++)\n\t\t\t\t\tadd(dp[i][j], dp[i - 1][j]);\n\t\t}\n\t\ts.insert(tmp);\n\t\tse.erase(tmp);\n\t\t// for (int j = 0; j <= n; j++) for (auto& k : dp[j]) printf(\"dp[%d][%d][%d]=%d\\n\", i, j, k.first + dj[j], k.second);\n\t}\n\tfor (int i = n - x; i <= x; i++)\n\t\tadd(ans, dp[n - 1][i]);\n\tprintf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args){\n\t\n\tScanner stdin = new Scanner(System.in);\n\tint n = stdin.nextInt();\n\tint m = stdin.nextInt();\n\tlong S[] = new long[n];\n\tfinal long mod = 1000000007;\n\n\tfor (int i = 0 ; i < n ; i++ ){\n\t    S[i] = stdin.nextInt();\n\t}\n\n\t//System.out.println(S[0]+S[1]);\n\n\tlong nowmax = 0;\n\tlong X[] = new long[n];\n\n\tfor (int i = 0 ; i < n ; i++){\n\t    X[i] = nowmax;\n\t    nowmax = Math.max(nowmax , S[i]);\n\t}\n\n\tlong nowmin = 10000;\n\tlong Y[] = new long[n];\n\n\tfor (int i = n-1 ; i > -1 ; i-- ){\n\t    Y[i] = nowmin;\n\t    nowmin = Math.min(nowmin , S[i]);\n\t}\n\n\tlong dp[][] = new long[n][m+1];\n\n\tfor (int i = 0 ; i < n ; i++ ){\n\n\t    if (i == 0){\n\t\tdp[i][1] = 2;\n\t\tcontinue;\n\t    }\n\n\t    long s = S[i];\n\t    long x = X[i];\n\t    long y = Y[i];\n\n\t    if (x < y && x < s){\n\t\tfor (int p = 0 ; p < m+1 ; p++){\n\t\t    if (p + 1 <= m){\n\t\t\tdp[i][p+1] += dp[i-1][p];\n\t\t\tdp[i][p+1] %= mod;\n\t\t    }\n\t\t    if (i-p+1 <= m && 0 <= i-p+1){\n\t\t\tdp[i][i-p+1] += dp[i-1][p];\n\t\t\tdp[i][i-p+1] %= mod;\n\t\t    }\t    \n\t\t}\n\t    }else if (x < y && s < x){\n\t\tfor (int p = 0; p < m+1 ; p++){\n\t\t    if (i-p+1 <= m && 0 <= i-p+1){\n\t\t\tdp[i][p] += dp[i-1][p];\n\t\t\tdp[i][p] %= mod;\n\t\t    }\n\t\t}\n\t    }else if (x > y && x < s){\n\t\tfor (int p = 0; p < m+1 ; p++){\n\t\t    if (p+1 <= m){\n\t\t\tdp[i][p+1] += dp[i-1][p];\n\t\t\tdp[i][p+1] %= mod;\n\t\t    }\n\t\t}\n\t    }else if (s > y){\n\t\tSystem.out.println(0);\n\t\treturn;\n\t    }else{\n\t\tfor (int p = 0 ; p < m+1 ; p++){\n\t\t    if (i-p+1 <= m && 0 <= i-p+1){\n\t\t\tdp[i][p] += dp[i-1][p];\n\t\t\tdp[i][p] %= mod;\n\t\t    }\n\t\t}\n\t    }\n   \n\t}\n\n\tlong ans = 0;\n\tfor (int i = 0; i < m+1 ; i++){\n\t    ans += dp[n-1][i];\n\t    ans %= mod;\n\t}\n\n\tSystem.out.println(ans);\n\t\n    }\n\n}\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    mod = 10 ** 9 + 7\n    n, m = map(int, input().split())\n    a = [int(x) for x in input().split()]\n\n    if not m:\n        print(0)\n        return\n    \n    mx = [0] * (n + 1)\n    mn = [mod] * (n + 1)\n    \n    for i in range(n):\n        if mx[i] > a[i]:\n            mx[i + 1] = mx[i]\n        else:\n            mx[i + 1] = a[i]\n    for i in range(n - 1, -1, -1):\n        if mn[i + 1] < a[i]:\n            mn[i] = mn[i + 1]\n        else:\n            mn[i] = a[i]\n    \n    dp = [0] * (n + 1)\n    \n    dp[1] = 2\n\n    for i in range(1, n):\n\n        ndp = [0] * (n + 1)\n\n        check0 = mx[i + 1] == a[i]\n        check1 = mn[i + 1] >= mx[i]\n        check2 = mn[i] == a[i]\n\n        if check0:\n            if check1:\n                for j in range(i + 1):\n                    ndp[j + 1] += dp[j]\n                    ndp[i - j + 1] += dp[j]\n\n            else:\n                for j in range(i + 1):\n                    ndp[j + 1] += dp[j]\n\n\n        else:\n            if check2:\n                for j in range(i + 1):\n                    ndp[j] += dp[j]\n\n        dp = [x % mod for x in ndp]\n        \n    ans = 0\n    for i in range(n - m, m + 1):\n        ans += dp[i]\n        ans %= mod\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n"
  }
]