[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\n#define MAX_POINTS 1000\n\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\ndouble distance(Point p1, Point p2) {\n    return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n}\n\ndouble closest_pair_distance(Point points[], int n) {\n    double min_dist = DBL_MAX;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double curr_dist = distance(points[i], points[j]);\n            if (curr_dist < min_dist) {\n                min_dist = curr_dist;\n            }\n        }\n    }\n    \n    return min_dist;\n}\n\nint main() {\n    int n;\n    Point points[MAX_POINTS];\n    \n    printf(\"Enter number of points: \");\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"Enter point %d (x y): \", i + 1);\n        scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n    }\n    \n    double result = closest_pair_distance(points, n);\n    printf(\"Closest pair distance: %f\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:15:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble dist(Point p1, Point p2) {\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\nint compareX(const void* a, const void* b) {\n    Point *p1 = (Point *)a, *p2 = (Point *)b;\n    return (p1->x > p2->x) - (p1->x < p2->x);\n}\n\nint compareY(const void* a, const void* b) {\n    Point *p1 = (Point *)a, *p2 = (Point *)b;\n    return (p1->y > p2->y) - (p1->y < p2->y);\n}\n\ndouble bruteForce(Point P[], int n) {\n    double min = DBL_MAX;\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j)\n            if (dist(P[i], P[j]) < min)\n                min = dist(P[i], P[j]);\n    return min;\n}\n\ndouble min(double x, double y) {\n    return (x < y) ? x : y;\n}\n\ndouble stripClosest(Point strip[], int size, double d) {\n    double min = d;\n    qsort(strip, size, sizeof(Point), compareY);\n    for (int i = 0; i < size; ++i)\n        for (int j = i + 1; j < size && (strip[j].y - strip[i].y) < min; ++j)\n            if (dist(strip[i], strip[j]) < min)\n                min = dist(strip[i], strip[j]);\n    return min;\n}\n\ndouble closestUtil(Point P[], int n) {\n    if (n <= 3)\n        return bruteForce(P, n);\n    int mid = n / 2;\n    Point midPoint = P[mid];\n    double dl = closestUtil(P, mid);\n    double dr = closestUtil(P + mid, n - mid);\n    double d = min(dl, dr);\n    Point strip[n];\n    int j = 0;\n    for (int i = 0; i < n; i++)\n        if (fabs(P[i].x - midPoint.x) < d)\n            strip[j++] = P[i];\n    return min(d, stripClosest(strip, j, d));\n}\n\ndouble closest(Point P[], int n) {\n    qsort(P, n, sizeof(Point), compareX);\n    return closestUtil(P, n);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Point P[n];\n    for (int i = 0; i < n; i++)\n        scanf(\"%lf %lf\", &P[i].x, &P[i].y);\n    printf(\"%.6lf\\n\", closest(P, n));\n    return 0;\n}",
    "timestamp": "2025-08-05 22:15:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\nbool compareX(const Point &a, const Point &b) {\n    return a.x < b.x;\n}\n\nbool compareY(const Point &a, const Point &b) {\n    return a.y < b.y;\n}\n\ndouble distance(const Point &a, const Point &b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble bruteForce(const vector<Point> &points, int left, int right) {\n    double min_dist = numeric_limits<double>::max();\n    for (int i = left; i <= right; ++i) {\n        for (int j = i + 1; j <= right; ++j) {\n            min_dist = min(min_dist, distance(points[i], points[j]));\n        }\n    }\n    return min_dist;\n}\n\ndouble stripClosest(vector<Point> &strip, double d) {\n    double min_dist = d;\n    sort(strip.begin(), strip.end(), compareY);\n    for (int i = 0; i < strip.size(); ++i) {\n        for (int j = i + 1; j < strip.size() && (strip[j].y - strip[i].y) < min_dist; ++j) {\n            min_dist = min(min_dist, distance(strip[i], strip[j]));\n        }\n    }\n    return min_dist;\n}\n\ndouble closestUtil(vector<Point> &points, int left, int right) {\n    if (right - left <= 3) {\n        return bruteForce(points, left, right);\n    }\n    int mid = (left + right) / 2;\n    Point mid_point = points[mid];\n    double dl = closestUtil(points, left, mid);\n    double dr = closestUtil(points, mid + 1, right);\n    double d = min(dl, dr);\n    vector<Point> strip;\n    for (int i = left; i <= right; ++i) {\n        if (abs(points[i].x - mid_point.x) < d) {\n            strip.push_back(points[i]);\n        }\n    }\n    return min(d, stripClosest(strip, d));\n}\n\ndouble closestPair(vector<Point> &points) {\n    sort(points.begin(), points.end(), compareX);\n    return closestUtil(points, 0, points.size() - 1);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> points(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> points[i].x >> points[i].y;\n    }\n    double min_dist = closestPair(points);\n    cout.precision(10);\n    cout << min_dist << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:16:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class ClosestPair {\n\n    static class Point {\n        double x, y;\n\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static double bruteForce(Point[] points, int start, int end) {\n        double min = Double.MAX_VALUE;\n        for (int i = start; i <= end; i++) {\n            for (int j = i + 1; j <= end; j++) {\n                double dist = distance(points[i], points[j]);\n                if (dist < min) {\n                    min = dist;\n                }\n            }\n        }\n        return min;\n    }\n\n    static double stripClosest(Point[] strip, int size, double d) {\n        double min = d;\n        Arrays.sort(strip, 0, size, new Comparator<Point>() {\n            public int compare(Point p1, Point p2) {\n                return Double.compare(p1.y, p2.y);\n            }\n        });\n\n        for (int i = 0; i < size; i++) {\n            for (int j = i + 1; j < size && (strip[j].y - strip[i].y) < min; j++) {\n                double dist = distance(strip[i], strip[j]);\n                if (dist < min) {\n                    min = dist;\n                }\n            }\n        }\n        return min;\n    }\n\n    static double closestUtil(Point[] pointsX, Point[] pointsY, int start, int end) {\n        if (end - start <= 3) {\n            return bruteForce(pointsX, start, end);\n        }\n\n        int mid = (start + end) / 2;\n        Point midPoint = pointsX[mid];\n\n        Point[] pointsYLeft = new Point[mid - start + 1];\n        Point[] pointsYRight = new Point[end - mid];\n        int leftIdx = 0, rightIdx = 0;\n\n        for (Point point : pointsY) {\n            if (point.x <= midPoint.x) {\n                pointsYLeft[leftIdx++] = point;\n            } else {\n                pointsYRight[rightIdx++] = point;\n            }\n        }\n\n        double dl = closestUtil(pointsX, pointsYLeft, start, mid);\n        double dr = closestUtil(pointsX, pointsYRight, mid + 1, end);\n        double d = Math.min(dl, dr);\n\n        Point[] strip = new Point[end - start + 1];\n        int j = 0;\n        for (int i = 0; i < pointsY.length; i++) {\n            if (Math.abs(pointsY[i].x - midPoint.x) < d) {\n                strip[j++] = pointsY[i];\n            }\n        }\n\n        return Math.min(d, stripClosest(strip, j, d));\n    }\n\n    static double distance(Point p1, Point p2) {\n        return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n    }\n\n    static double closest(Point[] points) {\n        Point[] pointsX = points.clone();\n        Arrays.sort(pointsX, new Comparator<Point>() {\n            public int compare(Point p1, Point p2) {\n                return Double.compare(p1.x, p2.x);\n            }\n        });\n\n        Point[] pointsY = points.clone();\n        Arrays.sort(pointsY, new Comparator<Point>() {\n            public int compare(Point p1, Point p2) {\n                return Double.compare(p1.y, p2.y);\n            }\n        });\n\n        return closestUtil(pointsX, pointsY, 0, points.length - 1);\n    }\n\n    public static void main(String[] args) {\n        Point[] points = {\n            new Point(2, 3),\n            new Point(12, 30),\n            new Point(40, 50),\n            new Point(5, 1),\n            new Point(12, 10),\n            new Point(3, 4)\n        };\n        System.out.println(\"The smallest distance is \" + closest(points));\n    }\n}",
    "timestamp": "2025-08-05 22:17:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ClosestPairDistance {\n    public static double findClosestPairDistance(double[][] points) {\n        int n = points.length;\n        if (n < 2) return Double.MAX_VALUE;\n        \n        double minDistance = Double.MAX_VALUE;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                double distance = calculateDistance(points[i], points[j]);\n                minDistance = Math.min(minDistance, distance);\n            }\n        }\n        \n        return minDistance;\n    }\n    \n    private static double calculateDistance(double[] point1, double[] point2) {\n        double sum = 0;\n        for (int k = 0; k < point1.length; k++) {\n            double diff = point1[k] - point2[k];\n            sum += diff * diff;\n        }\n        return Math.sqrt(sum);\n    }\n    \n    public static void main(String[] args) {\n        double[][] points = {{1, 2}, {3, 4}, {5, 6}, {0, 0}};\n        System.out.printf(\"%.2f\", findClosestPairDistance(points));\n    }\n}",
    "timestamp": "2025-08-05 22:17:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <limits>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\ndouble calculateDistance(const pair<double, double>& p1, const pair<double, double>& p2) {\n    return sqrt(pow(p1.first - p2.first, 2) + pow(p1.second - p2.second, 2));\n}\n\ndouble closestPairDistance(vector<pair<double, double>>& points) {\n    int n = points.size();\n    if (n < 2) return 0;\n    \n    double minDistance = numeric_limits<double>::max();\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double dist = calculateDistance(points[i], points[j]);\n            minDistance = min(minDistance, dist);\n        }\n    }\n    \n    return minDistance;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<pair<double, double>> points(n);\n    \n    for (int i = 0; i < n; i++) {\n        cin >> points[i].first >> points[i].second;\n    }\n    \n    cout << fixed << setprecision(6) << closestPairDistance(points) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:17:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef closest_pair_of_points(points):\n    def distance(point1, point2):\n        return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n    \n    def closest_pair_rec(points_sorted_x, points_sorted_y):\n        n = len(points_sorted_x)\n        if n <= 3:\n            return min(distance(points_sorted_x[i], points_sorted_x[j]) \n                       for i in range(n) for j in range(i + 1, n))\n        \n        mid = n // 2\n        midpoint = points_sorted_x[mid][0]\n        \n        left_sorted_x = points_sorted_x[:mid]\n        right_sorted_x = points_sorted_x[mid:]\n        \n        left_sorted_y = list(filter(lambda x: x[0] <= midpoint, points_sorted_y))\n        right_sorted_y = list(filter(lambda x: x[0] > midpoint, points_sorted_y))\n        \n        dl = closest_pair_rec(left_sorted_x, left_sorted_y)\n        dr = closest_pair_rec(right_sorted_x, right_sorted_y)\n        \n        d = min(dl, dr)\n        \n        # Combine step\n        strip = [p for p in points_sorted_y if abs(p[0] - midpoint) < d]\n        \n        min_d = d\n        strip_len = len(strip)\n        for i in range(strip_len):\n            j = i + 1\n            while j < strip_len and (strip[j][1] - strip[i][1]) < min_d:\n                min_d = min(min_d, distance(strip[i], strip[j]))\n                j += 1\n        \n        return min_d\n    \n    points_sorted_x = sorted(points, key=lambda x: x[0])\n    points_sorted_y = sorted(points, key=lambda x: x[1])\n    \n    return closest_pair_rec(points_sorted_x, points_sorted_y)\n\n# Example usage:\npoints = [(0, 0), (1, 1), (3, 4), (5, 1), (12, 30), (40, 50), (12, 10), (3, 4)]\nprint(closest_pair_of_points(points))",
    "timestamp": "2025-08-13 09:44:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\n\npublic class ClosestPair {\n    \n    static class Point implements Comparable<Point> {\n        double x, y;\n\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public int compareTo(Point o) {\n            return Double.compare(this.x, o.x);\n        }\n    }\n\n    private static double closestPair(Point[] points, int n) {\n        Arrays.sort(points);\n        return closestPairRec(points, 0, n - 1);\n    }\n\n    private static double closestPairRec(Point[] points, int left, int right) {\n        if (right - left < 3) {\n            return bruteForce(points, left, right);\n        }\n\n        int mid = (left + right) / 2;\n        double leftDist = closestPairRec(points, left, mid);\n        double rightDist = closestPairRec(points, mid + 1, right);\n        double d = Math.min(leftDist, rightDist);\n\n        Point[] strip = new Point[right - left + 1];\n        int j = 0;\n        for (int i = left; i <= right; i++) {\n            if (Math.abs(points[i].x - points[mid].x) < d) {\n                strip[j++] = points[i];\n            }\n        }\n\n        Arrays.sort(strip, 0, j, (a, b) -> Double.compare(a.y, b.y));\n        return Math.min(d, stripClosest(strip, j, d));\n    }\n\n    private static double bruteForce(Point[] points, int left, int right) {\n        double minDist = Double.POSITIVE_INFINITY;\n        for (int i = left; i <= right; i++) {\n            for (int j = i + 1; j <= right; j++) {\n                minDist = Math.min(minDist, distance(points[i], points[j]));\n            }\n        }\n        return minDist;\n    }\n\n    private static double stripClosest(Point[] strip, int size, double d) {\n        double minDist = d;\n        for (int i = 0; i < size; ++i) {\n            for (int j = i + 1; j < size && (strip[j].y - strip[i].y) < minDist; ++j) {\n                minDist = Math.min(minDist, distance(strip[i], strip[j]));\n            }\n        }\n        return minDist;\n    }\n\n    private static double distance(Point p1, Point p2) {\n        return Math.hypot(p1.x - p2.x, p1.y - p2.y);\n    }\n\n    public static void main(String[] args) {\n        Point[] points = {\n            new Point(2.1, 3.4),\n            new Point(5.6, 1.9),\n            new Point(1.0, 4.8),\n            new Point(7.3, 6.1),\n            new Point(4.4, 3.8)\n        };\n        System.out.println(\"The smallest distance is: \" + closestPair(points, points.length));\n    }\n}",
    "timestamp": "2025-08-13 09:44:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\nint compareX(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    return (p1->x - p2->x > 0) - (p1->x - p2->x < 0);\n}\n\nint compareY(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    return (p1->y - p2->y > 0) - (p1->y - p2->y < 0);\n}\n\ndouble dist(Point p1, Point p2) {\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\ndouble bruteForce(Point P[], int n) {\n    double min = DBL_MAX;\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j)\n            min = fmin(min, dist(P[i], P[j]));\n    return min;\n}\n\ndouble stripClosest(Point strip[], int size, double d) {\n    double min = d;\n    qsort(strip, size, sizeof(Point), compareY);\n\n    for (int i = 0; i < size; ++i)\n        for (int j = i + 1; j < size && (strip[j].y - strip[i].y) < min; ++j)\n            min = fmin(min, dist(strip[i], strip[j]));\n\n    return min;\n}\n\ndouble closestUtil(Point Px[], Point Py[], int n) {\n    if (n <= 3)\n        return bruteForce(Px, n);\n\n    int mid = n / 2;\n    Point midPoint = Px[mid];\n\n    Point Pyl[mid + 1];\n    Point Pyr[n - mid - 1];\n    int li = 0, ri = 0;\n    for (int i = 0; i < n; i++) {\n        if (Py[i].x <= midPoint.x && li < mid + 1)\n            Pyl[li++] = Py[i];\n        else\n            Pyr[ri++] = Py[i];\n    }\n\n    double dl = closestUtil(Px, Pyl, mid);\n    double dr = closestUtil(Px + mid, Pyr, n - mid);\n\n    double d = fmin(dl, dr);\n\n    Point strip[n];\n    int j = 0;\n    for (int i = 0; i < n; i++)\n        if (fabs(Py[i].x - midPoint.x) < d)\n            strip[j++] = Py[i];\n\n    return fmin(d, stripClosest(strip, j, d));\n}\n\ndouble closest(Point P[], int n) {\n    Point Px[n];\n    Point Py[n];\n    for (int i = 0; i < n; i++) {\n        Px[i] = P[i];\n        Py[i] = P[i];\n    }\n\n    qsort(Px, n, sizeof(Point), compareX);\n    qsort(Py, n, sizeof(Point), compareY);\n\n    return closestUtil(Px, Py, n);\n}\n\nint main() {\n    Point P[] = {{2, 3}, {12, 30}, {40, 50}, {5, 1}, {12, 10}, {3, 4}};\n    int n = sizeof(P) / sizeof(P[0]);\n    printf(\"The smallest distance is %f\\n\", closest(P, n));\n    return 0;\n}",
    "timestamp": "2025-08-13 09:44:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def closest_pair_distance(points):\n    n = len(points)\n    if n < 2:\n        return float('inf')\n    \n    min_distance = float('inf')\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            distance = ((points[i][0] - points[j][0])**2 + \n                        (points[i][1] - points[j][1])**2)**0.5\n            min_distance = min(min_distance, distance)\n    \n    return min_distance\n\n# Example usage\npoints = [(1,2), (4,6), (2,3), (5,7)]\nprint(closest_pair_distance(points))",
    "timestamp": "2025-08-13 09:45:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef closest_pair_distance(points):\n    min_dist = float('inf')\n    n = len(points)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = math.sqrt((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2)\n            if dist < min_dist:\n                min_dist = dist\n    return min_dist",
    "timestamp": "2025-08-13 09:45:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <float.h>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\nint compareX(const void* a, const void* b) {\n    Point *p1 = (Point *)a, *p2 = (Point *)b;\n    return p1->x - p2->x;\n}\n\nint compareY(const void* a, const void* b) {\n    Point *p1 = (Point *)a, *p2 = (Point *)b;\n    return p1->y - p2->y;\n}\n\nfloat distance(Point p1, Point p2) {\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) +\n                (p1.y - p2.y) * (p1.y - p2.y));\n}\n\nfloat bruteForce(Point P[], int n) {\n    float minDist = FLT_MAX;\n    for (int i = 0; i < n; ++i)\n        for (int j = i + 1; j < n; ++j)\n            if (distance(P[i], P[j]) < minDist)\n                minDist = distance(P[i], P[j]);\n    return minDist;\n}\n\nfloat stripClosest(Point strip[], int size, float d) {\n    float minDist = d;\n    qsort(strip, size, sizeof(Point), compareY);\n    for (int i = 0; i < size; ++i)\n        for (int j = i + 1; j < size && (strip[j].y - strip[i].y) < minDist; ++j)\n            if (distance(strip[i], strip[j]) < minDist)\n                minDist = distance(strip[i], strip[j]);\n    return minDist;\n}\n\nfloat closestUtil(Point P[], int n) {\n    if (n <= 3)\n        return bruteForce(P, n);\n    int mid = n / 2;\n    Point midPoint = P[mid];\n    float dl = closestUtil(P, mid);\n    float dr = closestUtil(P + mid, n - mid);\n    float d = min(dl, dr);\n    Point strip[n];\n    int j = 0;\n    for (int i = 0; i < n; i++)\n        if (abs(P[i].x - midPoint.x) < d)\n            strip[j] = P[i], j++;\n    return min(d, stripClosest(strip, j, d));\n}\n\nfloat closest(Point P[], int n) {\n    qsort(P, n, sizeof(Point), compareX);\n    return closestUtil(P, n);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> points(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> points[i].x >> points[i].y;\n    }\n    cout << closest(points.data(), n) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:54:29"
  }
]