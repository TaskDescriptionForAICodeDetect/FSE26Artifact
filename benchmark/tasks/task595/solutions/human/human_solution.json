[
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/50))  \n #define Fun2(j,n) for(int j=i+(int)(n/50);j<n;j=j+(int)(n/50))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=60;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16????????????????????¢???10??????????????§?????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n double dx,dy;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   //?°?16????????????????????????????????? \n   minx=minx-1;\n   miny=miny-1;\n   maxx=maxx+1;\n   maxy=maxy+1;\n   dx=1.0/4*(maxx-minx);\n   dy=1.0/4*(maxy-miny);\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=3;j>=0;j--)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*(3-j)+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n   /*\n   for(int i=0;i<16;i++)\n   {\n     for(int j=0;j<num_point[i];j++)\n     {\n       cout<<wu[i][j].x<<\" \"<<wu[i][j].y<<endl;        \n     }        \n   }\n   */\n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n //?????¢????????????????????????????§???????????????¢?????? \n void circle_optimize(double center)\n {\n      \n }\n \n void triangle_optimize()\n {\n      \n }\n \n void rectangle_optimize()\n {\n      \n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       \n       if(fun_min!=(40000.0*2)) real_min=fun_min;\n       else real_min=(point[0].x-point[1].x)*(point[0].x-point[1].x)+(point[0].y-point[1].y)*(point[0].y-point[1].y);\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         bool flag1,flag2,flag3,flag4,judge; \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {      \n             //???????????????????????¬???????????????????????¨?????????????????????????¬????????°????????????????????????????????????????????°???????????????°?????¨ \n             double theta=sqrt(real_min)/2;\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               flag1=flag2=flag3=flag4=false;\n               judge=false;\n               if(point[i].x>=(minx+(n+1)*dx-theta)) flag1=true;\n               if(point[i].x<=(minx+(n+1)*dx)) flag2=true;\n               if(point[i].y>=(miny+(3-m)*dy)) flag3=true;\n               if(point[i].y<=(miny+(4-m)*dy)) flag4=true;\n               judge=flag1&&flag2&&flag3&&flag4;\n               if(!judge) continue;\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 flag1=flag2=flag3=flag4=false;\n                 judge=false;\n                 if(point[j].x>=(minx+(n+1)*dx)) flag1=true;\n                 if(point[j].x<=(minx+(n+1)*dx+theta)) flag2=true;\n                 if(point[j].y>=(miny+(3-m)*dy)) flag3=true;\n                 if(point[j].y<=(miny+(4-m)*dy)) flag4=true;\n                 judge=flag1&&flag2&&flag3&&flag4;\n                 if(!judge) continue;\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             double theta=sqrt(real_min)/2;\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               flag1=flag2=flag3=flag4=false;\n               judge=false;\n               if(point[i].x>=(minx+n*dx)) flag1=true;\n               if(point[i].x<=(minx+(n+1)*dx)) flag2=true;\n               if(point[i].y>=(miny+(3-m)*dy)) flag3=true;\n               if(point[i].y<=(miny+(3-m)*dy+theta)) flag4=true;\n               judge=flag1&&flag2&&flag3&&flag4;\n               if(!judge) continue;\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 flag1=flag2=flag3=flag4=false;\n                 judge=false;\n                 if(point[j].x>=(minx+n*dx)) flag1=true;\n                 if(point[j].x<=(minx+(n+1)*dx)) flag2=true;\n                 if(point[j].y>=(miny+(3-m)*dy-theta)) flag3=true;\n                 if(point[j].y<=(miny+(3-m)*dy)) flag4=true;\n                 judge=flag1&&flag2&&flag3&&flag4;\n                 if(!judge) continue;\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<algorithm>\n\nconst double INF = 1e9;\n\nstruct Point {\n    Point() :x(INF), y(INF) {}\n    Point(double x, double y) :x(x), y(y) {}\n    bool operator==(const Point& p) const {return x == p.x && y == p.y;}\n    double x, y;\n};\nstruct Compare {\n    bool f;\n    Compare(bool f = false) :f(f) {}\n    bool operator()(const Point& lhs, const Point& rhs) const {return f ? lhs.y < rhs.y : lhs.x < rhs.x;}\n};\ndouble distance(const Point& lhs, const Point& rhs) {return std::hypot(lhs.x - rhs.x, lhs.y - rhs.y);}\n\nstruct Result {\n    double d;\n    Point p1, p2;\n    Result() :d(INF) {}\n    Result(double d, const Point p1, const Point p2) :d(d), p1(p1), p2(p2) {}\n};\nbool operator<(const Result& lhs, const Result& rhs) {return lhs.d < rhs.d;}\n\nResult closest_pair_recursion(const std::vector<Point>::const_iterator& begin, const std::vector<Point>::const_iterator& end) {\n    int size = end - begin;\n    if(size <= 1) return Result();\n\n    auto mid = begin + size / 2;\n    Result r = std::min(closest_pair_recursion(begin, mid), closest_pair_recursion(mid, end));\n\n    auto left = std::lower_bound(begin, end, Point(mid->x - r.d, mid->y), Compare());\n    auto right = std::upper_bound(begin, end, Point(mid->x + r.d, mid->y), Compare());\n    std::vector<Point> y_sorted(left, right);\n    std::sort(y_sorted.begin(), y_sorted.end(), Compare(true));\n    auto bottom = std::lower_bound(y_sorted.begin(), y_sorted.end(), Point(mid->x, mid->y - r.d), Compare(true));\n    auto top = std::upper_bound(y_sorted.begin(), y_sorted.end(), Point(mid->x, mid->y + r.d), Compare(true));\n    for(auto i = bottom; i != top; ++i) for(auto j = i; j != top; ++j) {\n        if(*i == *j) continue;\n        if(distance(*i, *j) >= r.d) continue;\n        r = Result(distance(*i, *j), *i, *j);\n    }\n    return r;\n}\nResult closest_pair(std::vector<Point> point) {\n    std::sort(point.begin(), point.end(), Compare());\n    return closest_pair_recursion(point.begin(), point.end());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n#include<iostream>\n#include<iomanip>\nusing namespace std;\n\nint main() {\n    int n;\n    vector<Point> v;\n    for(cin >> n; n > 0; --n) {\n        double x, y;\n        cin >> x >> y;\n        v.push_back(Point(x, y));\n    }\n    cout <<setprecision(12) << fixed << closest_pair(v).d << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 10000;\nconst double INFTY = 10000000000000000000.0;\n\nstruct Point { double x, y; };\nbool compareX(Point& a, Point& b) {\n\treturn a.x < b.x ? true : a.x == b.x && a.y <= b.y ? true : false;\n}\n\nbool compareY(Point& a, Point& b) {\n\treturn a.y < b.y ? true : a.y == b.y && a.x <= b.x ? true : false;\n}\n\ninline double getSquareDist(Point a, Point b) {\n\treturn (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\ninline double getMinSquareDistOfThree(Point a, Point b, Point c) {\n\treturn min(getSquareDist(a, b), min(getSquareDist(a, c), getSquareDist(b, c)));\n}\n\ndouble getMinSquareDistNearMid(Point nearmid[], int nearmid_length) {\n\tsort(nearmid, nearmid + nearmid_length, compareY);\n\n\tdouble min_sq_dist = INFTY;\n\tdouble cur_sq_dist;\n\tfor (int i = 0; i < nearmid_length; ++i) {\n\t\t// a better implementation:\n\t\t//for (int j = i + 1; j < min(nearmid_length, i + 8); ++j) {\n\t\tfor (int j = i + 1; j < nearmid_length && (nearmid[j].y - nearmid[i].y) < min_sq_dist; ++j) {\n\t\t\tcur_sq_dist = getSquareDist(nearmid[i], nearmid[j]);\n\t\t\tif (cur_sq_dist < min_sq_dist)\n\t\t\t\tmin_sq_dist = cur_sq_dist;\n\t\t}\n\t}\n\treturn min_sq_dist;\n}\n\n// nlog^2 n, not nlog n in CLRS\ndouble dcClosestSquareDist(int low, int high, Point points[]) {\n\tif (high - low == 1) {\n\t\treturn getSquareDist(points[low], points[high]);\n\t}\n\telse if (high - low == 2) {\n\t\treturn getMinSquareDistOfThree(points[low], points[low + 1], points[high]);\n\t}\n\telse {\n\t\t// bug 3: + has higher precedence than >>\n\t\t//int mid = low + (high - low) >> 1;\n\t\tint mid = low + ((high - low) >> 1);\n\t\tdouble d_left = dcClosestSquareDist(low, mid, points);\n\t\tdouble d_right = dcClosestSquareDist(mid + 1, high, points);\n\t\tdouble d_divide = min(d_left, d_right);\n\t\tdouble d_divide_sqrt = sqrt(d_divide);\n\n\t\t// merge\n\t\tPoint *nearmid = new Point[high - low + 1];\n\t\tint nearmid_length = 0;\n\t\tfor (int i = low; i <= high; ++i) {\n\t\t\t// bug 4: here we should compare the dist with real dist, not squared!\n\t\t\tif (points[i].x - points[mid].x < d_divide_sqrt && points[i].x - points[mid].x > -d_divide_sqrt) {\n\t\t\t\tnearmid[nearmid_length] = points[i];\n\t\t\t\tnearmid_length++;\n\t\t\t}\n\t\t}\n\t\tdouble d_merge = getMinSquareDistNearMid(nearmid, nearmid_length);\n\t\t// bug 6: forget to free memory\n\t\tdelete[] nearmid;\n\t\treturn min(d_divide, d_merge);\n\t}\n}\n\ndouble getMinSqDistToFirst(Point first_camera, Point points[], int n) {\n\tdouble min_sq_dist = INFTY;\n\tdouble cur_sq_dist;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcur_sq_dist = getSquareDist(first_camera, points[i]);\n\t\tif (cur_sq_dist < min_sq_dist)\n\t\t\tmin_sq_dist = cur_sq_dist;\n\t}\n\treturn min_sq_dist;\n}\n\ndouble getArea(double candidate, double min_dist_to_first, int n) {\n\treturn candidate * candidate + (n - 1) * (min_dist_to_first - candidate) * (min_dist_to_first - candidate);\n}\n\n/*\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tint n;\n\tPoint points[MAX_N];\n\tPoint first_camera;\n\tdouble min_dist_to_first;\n\tdouble min_dist_among_others;\n\tdouble candidate1;\t// candidate1 = max(0, d1 - d2 / 2)\n\tdouble candidate2;\t// candidate2 = d1\n\tdouble max_area;\n\tfor (int i = 1; i <= t; ++i) {\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%lf%lf\", &(first_camera.x), &(first_camera.y));\n\t\tfor (int j = 0; j < n - 1; ++j) {\n\t\t\tscanf(\"%lf%lf\", &(points[j].x), &(points[j].y));\n\t\t}\n\t\tmin_dist_to_first = sqrt(getMinSqDistToFirst(first_camera, points, n));\n\t\tif (n == 2) {\n\t\t\tmin_dist_among_others = INFTY;\n\t\t}\n\t\telse {\n\t\t\tsort(points, points + n - 1, compareX);\n\t\t\tmin_dist_among_others = sqrt(dcClosestSquareDist(0, n - 2, points));\n\t\t}\n\t\t//printf(\"%f\\n\", min_dist_among_others);\n\t\tcandidate1 = max(0.0, min_dist_to_first - min_dist_among_others / 2.0);\n\t\tcandidate2 = min_dist_to_first;\n\t\tmax_area = M_PI * max(getArea(candidate1, min_dist_to_first, n), getArea(candidate2, min_dist_to_first, n));\n\t\tprintf(\"Case #%d: %.8f\\n\", i, max_area);\n\t}\n    return 0;\n}\n*/\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tPoint points[MAX_N];\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%lf%lf\", &(points[i].x), &(points[i].y));\n\t}\n\tsort(points, points + n, compareX);\n\tprintf(\"%f\", sqrt(dcClosestSquareDist(0, n, points)));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\n\nnamespace std {\n  bool operator<(const Point a, const Point b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\npair<Point,Point> closestPair(VP ps) {\n  int n = ps.size();\n  int s = 0, t = 1, m = 2, S[n] = {0,1};\n  sort(ps.begin(), ps.end()); // \"p < q\" <=> \"p.x < q.x\"\n  double d = norm(ps[s]-ps[t]);\n  for (int i = 2; i < n; S[m++] = i++) rep(j, m) {\n    if (norm(ps[S[j]]-ps[i])<d) d = norm(ps[s = S[j]]-ps[t = i]);\n    if (ps[S[j]].X < ps[i].X - d) S[j--] = S[--m];\n  }\n  return make_pair( ps[s], ps[t] );\n}\n\nint main(void){\n    int n;\n    cin>>n;\n    VP ps(n);\n    rep(i,n){\n        double x,y;\n        cin>>x>>y;\n        ps[i] = Point(x,y);\n    }\n\n    pair<Point,Point> pp = closestPair(ps);\n    printf(\"%.9f\\n\",abs(pp.first-pp.second));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(5000, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(5000, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + 1].first - p2[i].first) * (p2[i + 1].first - p2[i].first) + (p2[i + 1].second - p2[i].second) * (p2[i + 1].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<utility>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n\ntypedef pair<double, double> point;\ntypedef point* data;\n\ninline double dist(const point &a, const point &b)\n{\n    double dx = a.first - b.first, dy = a.second - b.second;\n    return sqrt(dx * dx + dy * dy);\n}\n\nbool sort_y(const point &P1, const point &P2){ return P1.second < P2.second; }\n\ndouble closest(data P, int n)\n{\n    if(n <= 1) return 1000;\n    if(n == 2) return dist(P[0], P[1]);\n    int m = n / 2;\n    sort(P, P + n, sort_y); // y_sort, down to up.\n\tdouble median = P[m].second;\n    double d = min(closest(P, m), closest(P + m, n - m));\n\n    sort(P, P + n);\n    vector<point> V;\n\t\n    int i, k, a = 0, size = 0;\n    for(i = 0; i < n; i++){\n        if(fabs(P[i].second - median) > d) continue;\n        V.push_back(P[i]);\n        size++;\n        for(k = a; k < size - 1; k++){\n            if(V[size - 1].first - V[k].first > d){ a++; }\n            else{\n                d = min(d, dist(V[size - 1], V[k]));\n            }\n        }\n    }\n    return d;\n}\n\nint main()\n{\n\tint i, n;\n\tdouble x, y;\n\tscanf(\"%d\", &n);\n\tdata P;\n\tP = new point [n];\n\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tP[i] = make_pair(x, y);\n\t}\n\tprintf(\"%.12f\\n\", closest(P, n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&min(memo,ans+0.00019) >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans =(min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<utility>\n\ntypedef pair<double, double> point;\ntypedef point* data;\n\ndouble dist(const point &p1, const point &p2)\n{\n    double dx = p1.first - p2.first;\n    double dy = p1.second - p2.second;\n    return sqrt(dx * dx + dy * dy);\n}\n\nbool sort_y(const point &p1, const point &p2){ return p1.second < p2.second; }\n\ndouble closest(data X, data Y, int n)\n{\n    if(n <= 3){\n        double d = dist(X[0], X[1]);\n        for(int i = 0; i < n; i++){ Y[i] = X[i]; }\n        sort(Y, Y + n, sort_y);\n \n        if(n < 3){ return d; }\n        return min(d, min(dist(X[0], X[2]), dist(X[1], X[2])));\n    }\n    int m = (n >> 1);\n    double median = X[m].first;\n    double d = min(closest(X, Y, m), closest(X + m, Y + m, n - m));\n \n    data Z; int size = 0;\n    Z = new point [n];\n    int i = 0, j = m;\n    while(1){\n        if(i < m && j < n){\n            if(Y[i].second < Y[j].second){\n                Z[size] = Y[i]; size++; i++;\n            }else{\n                Z[size] = Y[j]; size++; j++;\n            }\n        }\n        if(i == m){ while(j < n){ Z[size] = Y[j]; size++; j++; }; break; }\n        if(j == n){ while(i < m){ Z[size] = Y[i]; size++; i++; }; break; }\n    };\n\n    for(i = 0; i < n; i++){ Y[i] = Z[i]; }\n\n    int resize = 0;\n    for(i = 0; i < size; i++){\n        if(fabs(Z[i].first - median) <= d){ Z[resize] = Z[i]; resize++; }\n    }\n\n    int a = 0;\n    for(i = 1; i < resize; i++){\n        for(j = a; j < i; j++){\n            if(Z[i].second - Z[j].second > d){ a++; }\n            else{\n                d = min(d, dist(Z[i], Z[j]));\n            }\n        }\n    }\n    delete [] Z;\n    return d;\n}\n\nint main()\n{\n    data X, Y;\n    int i, n;\n    scanf(\"%d\", &n);\n    X = new point [n];\n    Y = new point [n];\n\n    double co_x, co_y;\n    for(i = 0; i < n; i++){\n        scanf(\"%lf %lf\", &co_x, &co_y);\n        X[i] = make_pair(co_x, co_y);\n    }\n    sort(X, X + n);\n\n    double d = closest(X, Y, n);\n    printf(\"%.12f\\n\", d);\n\n    delete [] X;\n    delete [] Y;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\n\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n\n    two_dimensional_qsort(p_xy, n0, n-1, 1);\n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        //cout<<\"qaaa\";\n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n\nusing ld = double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ntemplate<class iter>\ntuple<ld, P, P> closest_pair(iter left, iter right) {\n    int n = distance(left, right);\n    if(n <= 1) return make_tuple(numeric_limits<ld>::max(), *left, *left);\n    if(n == 2) return make_tuple(norm(left[0] - left[1]), left[0], left[1]);\n    iter middle = next(left, n/2);\n    ld x = middle->real();\n    auto d = min(closest_pair(left, middle), closest_pair(middle, right));\n    inplace_merge(left, middle, right, [](const P &a, const P &b){\n            return a.imag() < b.imag();\n        });\n    vector<iter> around;\n    for(iter i = left; i != right; ++i){\n        ld dx = fabs(i->real() - x);\n        ld &opt = get<0>(d);\n        if(dx*dx >= opt) continue;\n        for(auto j = around.rbegin(); j != around.rend(); ++j){\n            ld dx = i->real() - (**j).real();\n            ld dy = i->imag() - (**j).imag();\n            if(dy*dy >= opt) break;\n            ld norm = dx*dx + dy*dy;\n            if(get<0>(d) > norm){\n                d = make_tuple(norm, *i, **j);\n            }\n        }\n        around.push_back(i);\n    }\n    return d;\n};\n\n// http://www.spoj.com/problems/CLOPPAIR/\n// 18124516\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout << fixed << setprecision(6) << endl;\n    int n;\n    cin >> n;\n    vector<P> a;\n    rep(i,n){\n        ld x,y;\n        cin >> x >> y;\n        a.emplace_back(x,y);\n    }\n    ld z;\n    P x, y;\n    sort(all(a));\n    tie(z, x, y) = closest_pair(all(a));\n    cout << sqrt(z) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntypedef complex<double> P;\n\nbool comp_x(const P &a, const P &b) {\n    return a.real() < b.real();\n}\n\nbool comp_y(const P &a, const P &b) {\n    return a.imag() < b.imag();\n}\n\ndouble getClosePair(vector<P> &a, int l, int r) {\n    if (r - l <= 1) return 1e20;\n    int mid = (l + r) / 2;\n    double X = a[mid].real();\n    double d = min(getClosePair(a, l, mid), getClosePair(a, mid, r));\n    inplace_merge(a.begin() + l, a.begin() + mid, a.begin() + r, comp_y);\n\n    vector<P> b;\n    for (int i = l; i < r; i++) {\n        if (abs(a[i].real() - X) >= d) continue;\n        for (int j = b.size() - 1; j >= 0; j--) {\n            if (abs((a[i] - b[j]).imag()) >= d) break;\n            d = min(d, abs(a[i] - b[j]));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main() {\n\n    int N;\n    cin >> N;\n\n    vector<P> p(N);\n    for (int i = 0; i < N; i++) {\n        double x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n\n    sort(p.begin(), p.end(), comp_x);\n\n    double ans = getClosePair(p, 0, N);\n    cout << fixed << setprecision(20) << ans << endl;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct node{\n  int dim;\n  vector<double>v;\n};\n\ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n\ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n\n  vector<node>res;\n\n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n\n    double dist=d(p,S)/(4*p.dim);\n\n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n\n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    if(S.size() == nextS.size())break;\n    S=nextS;    \n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n  \n  return ans;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n\n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<vector>\n#include<cmath>\n#include<algorithm>\n\nconst double INF = 1e9;\nconst double EPS = 1e-9;\n\nstruct Point {\n    Point() :x(INF), y(INF) {}\n    Point(double x, double y) :x(x), y(y) {}\n    double x, y;\n};\nstruct Compare {\n    bool f;\n    Compare(bool f = false) :f(f) {}\n    bool operator()(const Point& lhs, const Point& rhs) const {return f ? lhs.y < rhs.y : lhs.x < rhs.x;}\n};\ndouble distance(const Point& lhs, const Point& rhs) {return std::hypot(lhs.x - rhs.x, lhs.y - rhs.y);}\n\nstruct Result {\n    double d;\n    Point p1, p2;\n    Result() :d(INF) {}\n    Result(double d, const Point p1, const Point p2) :d(d), p1(p1), p2(p2) {}\n};\nbool operator<(const Result& lhs, const Result& rhs) {return lhs.d < rhs.d;}\n\nResult closest_pair_recursion(const std::vector<Point>::const_iterator& begin, const std::vector<Point>::const_iterator& end) {\n    int size = end - begin;\n    if(size <= 1) return Result();\n\n    auto mid = begin + size / 2;\n    Result r = std::min(closest_pair_recursion(begin, mid), closest_pair_recursion(mid, end));\n\n    auto left = std::lower_bound(begin, end, Point(mid->x - r.d - EPS, mid->y), Compare());\n    auto right = std::upper_bound(left, end, Point(mid->x + r.d + EPS, mid->y), Compare());\n    std::vector<Point> y_sorted(left, right);\n    std::sort(y_sorted.begin(), y_sorted.end(), Compare(true));\n\n    for(auto i = y_sorted.begin(); i != y_sorted.end(); ++i) {\n        for(auto j = i + 1; j != y_sorted.end(); ++j) {\n            if(j->y - i->y >= r.d) break;\n            if(distance(*i, *j) >= r.d) continue;\n            r = Result(distance(*i, *j), *i, *j);\n        }\n    }\n//     // y 座標の差が r.d 以上になる点を予め計算：微妙に遅い\n//     for(auto i = y_sorted.begin(); i != y_sorted.end(); ++i) {\n//         auto top = std::upper_bound(i + 1, y_sorted.end(), Point(i->x, i->y + r.d + EPS), Compare(true));\n//         for(auto j = i + 1; j != top; ++j) {\n//             if(distance(*i, *j) >= r.d) continue;\n//             r = Result(distance(*i, *j), *i, *j);\n//         }\n//     }\n\n    return r;\n}\nResult closest_pair(std::vector<Point> point) {\n    std::sort(point.begin(), point.end(), Compare());\n    return closest_pair_recursion(point.begin(), point.end());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n#include<iostream>\n#include<iomanip>\nusing namespace std;\n\nint main() {\n    int n;\n    vector<Point> v;\n    for(cin >> n; n > 0; --n) {\n        double x, y;\n        cin >> x >> y;\n        v.push_back(Point(x, y));\n    }\n    auto res = closest_pair(v);\n    cout <<setprecision(12) << fixed << res.d << endl;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n using namespace std;\n \n  /*\n   \n */\n \n struct point\n {\n   double x;\n   double y;       \n }point[100002];\n \n int n;\n double result=200.0*sqrt(2);;\n \n void general_way()\n {\n   for(int i=0;i<n;i++) \n     for(int j=i+1;j<n;j++)\n     {\n       double num=sqrt(pow((point[i].x-point[j].x),2)+pow((point[i].y-point[j].y),2));\n       if(num<result) result=num;        \n     }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n void wuhao()\n {\n      \n }\n \n int main() \n {\n   cin>>n;\n   for(int i=0;i<n;i++) cin>>point[i].x>>point[i].y;\n   general_way();\n   printf(\"%lf.7\\n\",result);\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define INF (1e9)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\n\ntypedef vector<Point> Polygon;\n\nbool compare_y(const Point &a,const Point &b){\n  return a.y < b.y;\n}\n\ndouble closest_pair(Polygon &a,int n){\n    if(n <= 1) return INF;\n    int m = n / 2;\n    double x = a[m].x;\n    Polygon v(a.begin()+m,a.end());\n    double d = min(closest_pair(a,m),closest_pair(v,n-m));\n    inplace_merge(a.begin(),a.begin()+m,a.end(),compare_y);\n\n    Polygon b;\n    for(int i = 0 ; i < n ; i++){\n        if(fabs(a[i].x - x) >= d) continue;\n        for(int j = 0 ; j < (int)b.size() ; j++){\n            double dx = a[i].x - b[b.size()-j-1].x;\n            double dy = a[i].y - b[b.size()-j-1].y;\n            if(dy >= d) break;\n            d = min(d,sqrt(dx * dx + dy * dy));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    Polygon p(N);\n    for(int i = 0 ; i < N ; i++){\n        cin >> p[i].x >> p[i].y;\n    }\n    printf(\"%.12f\\n\",closest_pair(p,N));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/50))  \n #define Fun2(j,n) for(int j=i+(int)(n/50);j<n;j=j+(int)(n/50))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=0;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16????????????????????¢???10??????????????§?????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n double dx,dy;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   //?°?16????????????????????????????????? \n   minx=minx-1;\n   miny=miny-1;\n   maxx=maxx+1;\n   maxy=maxy+1;\n   dx=1.0/4*(maxx-minx);\n   dy=1.0/4*(maxy-miny);\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=3;j>=0;j--)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*(3-j)+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n   /*\n   for(int i=0;i<16;i++)\n   {\n     for(int j=0;j<num_point[i];j++)\n     {\n       cout<<wu[i][j].x<<\" \"<<wu[i][j].y<<endl;        \n     }        \n   }\n   */\n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n //?????¢????????????????????????????§???????????????¢?????? \n void circle_optimize(double center)\n {\n      \n }\n \n void triangle_optimize()\n {\n      \n }\n \n void rectangle_optimize()\n {\n      \n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       //real_min=(point[0].x-point[1].x)*(point[0].x-point[1].x)+(point[0].y-point[1].y)*(point[0].y-point[1].y);\n       real_min=fun_min;\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         bool flag1,flag2,flag3,flag4,judge; \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {      \n             //???????????????????????¬???????????????????????¨?????????????????????????¬????????°????????????????????????????????????????????°???????????????°?????¨ \n             double theta=sqrt(real_min)/2;\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               flag1=flag2=flag3=flag4=false;\n               judge=false;\n               if(point[i].x>=(minx+(n+1)*dx-theta)) flag1=true;\n               if(point[i].x<=(minx+(n+1)*dx)) flag2=true;\n               if(point[i].y>=(miny+(3-m)*dy)) flag3=true;\n               if(point[i].y<=(miny+(4-m)*dy)) flag4=true;\n               judge=flag1&&flag2&&flag3&&flag4;\n               if(!judge) continue;\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 flag1=flag2=flag3=flag4=false;\n                 judge=false;\n                 if(point[j].x>=(minx+(n+1)*dx)) flag1=true;\n                 if(point[j].x<=(minx+(n+1)*dx+theta)) flag2=true;\n                 if(point[j].y>=(miny+(3-m)*dy)) flag3=true;\n                 if(point[j].y<=(miny+(4-m)*dy)) flag4=true;\n                 judge=flag1&&flag2&&flag3&&flag4;\n                 if(!judge) continue;\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             double theta=sqrt(real_min)/2;\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               flag1=flag2=flag3=flag4=false;\n               judge=false;\n               if(point[i].x>=(minx+n*dx)) flag1=true;\n               if(point[i].x<=(minx+(n+1)*dx)) flag2=true;\n               if(point[i].y>=(miny+(3-m)*dy)) flag3=true;\n               if(point[i].y<=(miny+(3-m)*dy+theta)) flag4=true;\n               judge=flag1&&flag2&&flag3&&flag4;\n               if(!judge) continue;\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 flag1=flag2=flag3=flag4=false;\n                 judge=false;\n                 if(point[j].x>=(minx+n*dx)) flag1=true;\n                 if(point[j].x<=(minx+(n+1)*dx)) flag2=true;\n                 if(point[j].y>=(miny+(3-m)*dy-theta)) flag3=true;\n                 if(point[j].y<=(miny+(3-m)*dy)) flag4=true;\n                 judge=flag1&&flag2&&flag3&&flag4;\n                 if(!judge) continue;\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n  "
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(100, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(100, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + 1].first - p2[i].first) * (p2[i + 1].first - p2[i].first) + (p2[i + 1].second - p2[i].second) * (p2[i + 1].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace LCY{\n\t#define double long double\n\tconst double EPS=1e-10;\n\tconst double Pi=acos(-1.0);\n\tinline int dcmp(double x){if(fabs(x)<EPS)return 0;return (x<0)?-1:1;}\n\tstruct Point{double x,y;Point(double _x=0,double _y=0){x=_x;y=_y;}};\n\tstruct Vector{double x,y;Vector(double _x=0,double _y=0){x=_x;y=_y;}};\n\t\n\tVector operator - (Point a,Point b){return Vector(a.x-b.x,a.y-b.y);}\n\tVector operator * (Vector a,double d){return Vector(a.x*d,a.y*d);}\n\tPoint operator + (Point a,Vector b){return Point(a.x+b.x,a.y+b.y);}\n\t\n\tinline double dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}\n\tinline double cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}\n\tinline double norm(Vector a){return dot(a,a);}\n\tinline double abs(Vector a){return std::sqrt(norm(a));}\n\t\n\tstruct Line{\n\t\tPoint p1,p2;\n\t\tLine(Point _p1=Point(0,0),Point _p2=Point(0,0)){p1=_p1;p2=_p2;}\n\t};\n\tinline bool is_parallel(Line l1,Line l2){return dcmp(cross(l2.p2-l2.p1,l1.p2-l1.p1))==0;}\n\tinline bool is_vertical(Line l1,Line l2){return dcmp(dot(l2.p2-l2.p1,l1.p2-l1.p1))==0;}\n\t\n\tPoint project(Line l,Point p){\n\t\tVector base=l.p2-l.p1;\n\t\tdouble r=dot(p-l.p1,base)/norm(base);\n\t\treturn l.p1+base*r;\n\t}\n\tPoint reflect(Line l,Point p){\n\t\tPoint q=project(l,p);\n\t\tVector v=p-q;v.x=-v.x;v.y=-v.y;\n\t\treturn q+v;\n\t}\n\tint ccw(Vector v1,Vector v2){\n\t\tif(dcmp(cross(v1,v2))>0)return 1;//COUNTER_CLOCKWISE\n\t\telse if(dcmp(cross(v1,v2))<0)return 2;//CLOCKWISE\n\t\telse{\n\t\t\tif(dcmp(dot(v1,v2))<0)return 3;//ONLINE_BACK\n\t\t\telse{\n\t\t\t\tif(dcmp(norm(v1)-norm(v2))<0)return 4;//ONLINE_FRONT\n\t\t\t\telse return 5;//ON_SEGMENT\n\t\t\t}\n\t\t}\n\t}\n\tinline bool is_inter(Line l1,Line l2){\n\t\tbool flag=1;\n\t\tint t1=ccw(l1.p2-l1.p1,l2.p1-l1.p1),t2=ccw(l1.p2-l1.p1,l2.p2-l1.p1);\n\t\tif(t1==5 || t2==5) return true;\n\t\telse if(t1==t2)return false;\n\t\telse if(t1>=3 && t2<=2) return false;\n\t\telse if(t1<=2 && t2>=3) return false;\n\t\tstd::swap(l1,l2);\n\t\tt1=ccw(l1.p2-l1.p1,l2.p1-l1.p1),t2=ccw(l1.p2-l1.p1,l2.p2-l1.p1);\n\t\tif(t1==5 || t2==5) return true;\n\t\telse if(t1==t2)return false;\n\t\telse if(t1>=3 && t2<=2) return false;\n\t\telse if(t1<=2 && t2>=3) return false;\n\t\treturn true;\n\t}\n\tinline Point line_intersection(Line l1,Line l2){\n\t\tif(is_parallel(l1,l2)) return Point(233,233);\n\t\tVector u=l1.p1-l2.p1,v=l1.p2-l1.p1,w=l2.p2-l2.p1;\n\t\tdouble t=cross(w,u)/cross(v,w);\n\t\treturn l1.p1+v*t;\n\t}\n\tinline Point segment_intersection(Line l1,Line l2){\n\t\tif(!is_inter(l1,l2)) return Point(233,233);\n\t\treturn line_intersection(l1,l2);\n\t}\n\tinline double line_point_distance(Line l,Point p){\n\t\treturn std::abs(cross(l.p2-l.p1,p-l.p1))/abs(l.p2-l.p1);\n\t}\n\tinline double segment_point_distance(Line l,Point p){\n\t\tif(dcmp(dot(l.p2-l.p1,p-l.p1))<0) return abs(p-l.p1);\n\t\tif(dcmp(dot(l.p1-l.p2,p-l.p2))<0) return abs(p-l.p2);\n\t\treturn line_point_distance(l,p);\n\t}\n\tinline double segment_distance(Line l1,Line l2){\n\t\t#define spd segment_point_distance\n\t\tif(is_inter(l1,l2))return 0.0;\n\t\treturn std::min(std::min(spd(l1,l2.p1),spd(l1,l2.p2)),std::min(spd(l2,l1.p1),spd(l2,l1.p2)));\n\t}\n\tdouble area(std::vector<Point> &Q){\n\t\tint n=Q.size();\n\t\tdouble ans=0;\n\t\tPoint o=Point(0.0,0.0);\n\t\tfor(int i=0;i<n;++i)ans+=cross(Q[i]-o,Q[(i+1)%n]-o)/2.0;\n\t\treturn ans;\n\t}\n\tdouble circumference(std::vector<Point> &Q){\n\t\tint n=Q.size();\n\t\tdouble ans=0;\n\t\tfor(int i=0;i<n;++i)ans+=abs(Q[i]-Q[(i+1)%n]);\n\t\treturn ans;\n\t}\n\tbool is_convex(std::vector<Point> &Q){\n\t\tint n=Q.size();\n\t\tPoint o=Point(0.0,0.0);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tPoint lst=Q[(i+n-1)%n],now=Q[i],nxt=Q[(i+1)%n];\n\t\t\tif(ccw(now-lst,nxt-lst)==2)return false;\n\t\t}\n\t\treturn true;\n\t}\n\tint in_convex(std::vector<Point> &Q,Point p){\n\t\tint n=Q.size();\n\t\tPoint pp=Point(p.x+100000.0,p.y+Pi*100000.0);\n\t\tVector v=pp-p;\n\t\tint cnt=0;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tPoint p1=Q[i],p2=Q[(i+1)%n];\n\t\t\tif(dcmp(cross(p1-p,p2-p))==0 && dcmp(dot(p1-p,p2-p))<=0)return 1;\n\t\t\tPoint x=line_intersection(Line(p,pp),Line(p1,p2));\n\t\t\tif(x.x==233 && x.y==233)continue;\n\t\t\tif(ccw(p1-x,p2-x)!=3)continue;\n\t\t\tif(dcmp(x.x-p.x)<0)continue;\n\t\t\tcnt++;\n\t\t}\n\t\treturn (cnt&1)?2:0;\n\t}\n\tbool cmp_x(Point a,Point b){return dcmp(a.x-b.x)<0||(dcmp(a.x-b.x)==0 && dcmp(a.y-b.y)<0);}\n\tbool cmp_y(Point a,Point b){return dcmp(a.y-b.y)<0||(dcmp(a.y-b.y)==0 && dcmp(a.x-b.x)>0);}\n\tstd::vector<Point> get_convex(std::vector<Point> &Q){\n\t\tstd::vector<Point> sta;\n\t\tsort(Q.begin(),Q.end(),cmp_y);\n\t\tint n=Q.size();\n\t\tfor(int i=0;i<n;++i){\n\t\t\twhile(sta.size()>=2 && dcmp(cross(sta[sta.size()-1]-sta[sta.size()-2],Q[i]-sta[sta.size()-2]))<0)sta.pop_back();\n\t\t\tsta.push_back(Q[i]);\n\t\t}\n\t\tint t=sta.size();\n\t\tfor(int i=n-2;i>=0;--i){\n\t\t\twhile(sta.size()>t && dcmp(cross(sta[sta.size()-1]-sta[sta.size()-2],Q[i]-sta[sta.size()-2]))<0)sta.pop_back();\n\t\t\tsta.push_back(Q[i]);\n\t\t}\n\t\tsta.pop_back();\n\t\treturn sta;\n\t}\n\tdouble diameter(std::vector<Point> &Q){\n\t\tif(Q.size()<=1)return 0;\n\t\tif(Q.size()==2)return abs(Q[1]-Q[0]);\n\t\tint i=0,j=0,n=Q.size();\n\t\tfor(int k=0;k<n;++k){\n\t\t\tif(cmp_x(Q[i],Q[k])) i=k;\n\t\t\tif(!cmp_x(Q[j],Q[k])) j=k;\n\t\t}\n\t\tdouble ans=0.0;\n\t\tint si=i,sj=j;\n\t\twhile(i!=sj || j!=si){\n\t\t\tans=std::max(ans,abs(Q[i]-Q[j]));\n\t\t\tif(dcmp(cross(Q[(i+1)%n]-Q[i],Q[(j+1)%n]-Q[j]))>0)j=(j+1)%n;\n\t\t\telse i=(i+1)%n;\n\t\t}\n\t\treturn ans;\n\t}\n\tdouble closest_pair(Point *Q,int n){\n\t\tif(n<=1)return 1e9;\n\t\tint m=n/2;\n\t\tdouble x=Q[m].x;\n\t\tdouble d=std::min(closest_pair(Q,m),closest_pair(Q+m,n-m));\n\t\tstd::vector<Point> q;\n\t\tint i=0,j=m;\n\t\twhile(i<m && j<n){\n\t\t\tif(cmp_y(Q[i],Q[j]))q.push_back(Q[i++]);\n\t\t\telse q.push_back(Q[j++]);\n\t\t}\n\t\twhile(i<m)q.push_back(Q[i++]);\n\t\twhile(j<n)q.push_back(Q[j++]);\n\t\tfor(int i=0;i<n;++i)Q[i]=q[i];\n\t\tq.clear();\n\t\t\n\t\tfor(int i=0;i<n;++i){\n\t\t\tif(dcmp(std::fabs(Q[i].x-x)-d)>=0)continue;\n\t\t\tfor(int j=q.size()-1;j>=0;--j){\n\t\t\t\td=std::min(d,abs(Q[i]-q[j]));\n\t\t\t\tif(dcmp(Q[i].y-q[j].y)-d>=0)break;\n\t\t\t}\n\t\t\tq.push_back(Q[i]);\n\t\t}\n\t\treturn d;\n\t}\n}\nusing namespace LCY;\nusing namespace std;\nPoint Q[1000005];\nint main(){\n\tint n;cin>>n;for(int i=0;i<n;++i)cin>>Q[i].x>>Q[i].y;\n\tsort(Q,Q+n,cmp_x);\n\tcout<<setiosflags(ios::fixed)<<setprecision(10)<<closest_pair(Q,n)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef complex<ld> PT;\ntypedef vector<PT> Poly;\ntypedef pair<PT, PT> LS;\n#define F first\n#define S second\n#define X real()\n#define Y imag()\n#define pb push_back\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x; }\n\nconst int N = -1;\nconst ld EPS = 1e-12;\n\nconst int ON = 0, LEFT = 1, RIGHT = -1, BACK = -2, FRONT = 2, IN = 3, OUT = -3;\n\ninline bool Geq(ld a, ld b){ return a + EPS > b; }\ninline bool Grt(ld a, ld b){ return a > b + EPS; }\ninline bool Leq(ld a, ld b){ return a < b + EPS; }\ninline bool Lss(ld a, ld b){ return a + EPS < b; }\ninline bool Equ(ld a, ld b){ return Geq(a, b) && Geq(b, a); }\n\nistream& operator>> (istream& is, complex<ld>& p){\n\tld val;\n\tis >> val;\n\tp.real(val);\n\tis >> val;\n\tp.imag(val);\n\treturn is;\n}\n\nstruct cmpXY{\n\tbool operator ()(const PT &a, const PT &b){\n\t\tif (Equ(a.X, b.X))\n\t\t\treturn Lss(a.Y, b.Y);\n\t\treturn Lss(a.X, b.X);\n\t}\n};\n\nstruct cmpYX{\n\tbool operator ()(const PT &a, const PT &b){\n\t\tif (Equ(a.Y, b.Y))\n\t\t\treturn Lss(a.X, b.X);\n\t\treturn Lss(a.Y, b.Y);\n\t}\n};\n\n\n\n\nld dot(PT a, PT b){ return real(conj(a)*b); }\nld cross(PT a, PT b){ return imag(conj(a)*b); }\nld sqlen(PT a){ return dot(a, a); }\nld len(PT a){ return sqrt(sqlen(a)); }\n\nPT proj(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + b*real(c/b);\n}\n\nPT reflect(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\treturn a + conj(c/b)*b;\n}\n\nPT rotate(PT a, PT b, ld theta){\n\treturn (b-a)*polar<ld>(1, theta) + a;\n}\n\nint relpos(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tc /= b;\n\tif (Grt(c.imag(), 0)) return LEFT;\n\tif (Lss(c.imag(), 0)) return RIGHT;\n\tif (Lss(c.real(), 0)) return BACK;\n\tif (Grt(c.real(), 1)) return FRONT;\n\treturn ON;\n}\n\nint side(PT a, PT b, PT c){\n\tb -= a, c -= a;\n\tld cr = (c/b).Y;\n\treturn Grt(cr, 0) ? 1 : (Lss(cr, 0) ? -1 : 0);\n}\n\nbool intersect(PT a, PT b, PT c, PT d){\n\tint as = side(c, d, a), bs = side(c, d, b), cs = side(a, b, c), ds = side(a, b, d);\n\tif (as && as == bs || cs && cs == ds) return false;\n\telse if (as || bs || cs || ds) return true;\n\tfor (int j = 0; j < 2; j++, swap(a, c), swap(b, d)){\n\t\tld mx = min(a.X, b.X), Mx = max(a.X, b.X), my = min(a.Y, b.Y), My = max(a.Y, b.Y);\n\t\tfor (int k = 0; k < 2; k++, swap(c, d))\n\t\t\tif (Geq(c.X, mx) && Leq(c.X, Mx) && Geq(c.Y, my) && Leq(c.Y, My))\n\t\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nPT intersection(PT a, PT b, PT c, PT d){\n\tld c1 = cross(b-a, c-a), c2 = cross(b-a, d-a);\n\treturn (c1*d - c2*c)/(c1-c2);\n}\n\nld distLSP(PT a, PT b, PT c){\n\tint rpos = relpos(a, b, proj(a, b, c));\n\tif (rpos == BACK) return len(c-a);\n\tif (rpos == FRONT) return len(c-b);\n\tb -= a, c -= a;\n\treturn abs(cross(b, c)/len(b));\n}\n\nld distLS(PT a, PT b, PT c, PT d){\n\tif (intersect(a, b, c, d)) return 0;\n\treturn min(min(distLSP(a, b, c), distLSP(a, b, d)), min(distLSP(c, d, a), distLSP(c, d, b)));\n}\n\nld signedArea(Poly &po){\n\tint n = po.size();\n\tld res = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tres += cross(po[i], po[(i+1)%n]);\n\treturn res/2;\n}\n\nld area(Poly &poly){\n\treturn abs(signedArea(poly));\n}\n\nbool isConvex(Poly &po){\n\tint n = po.size();\n\tbool neg = false, pos = false;\n\tfor (int i = 0; i < n; i++){\n\t\tint rpos = relpos(po[i], po[(i+1)%n], po[(i+2)%n]);\n\t\tif (rpos == LEFT) pos = true;\n\t\tif (rpos == RIGHT) neg = true;\n\t}\t\n\treturn (neg&pos) == false;\n}\n\nint crossingN(Poly &po, PT a){\n\tint n = po.size();\n\tPT b = a;\n\tfor (PT p : po)\n\t\tb.real(max(b.X, p.X));\n\tint cn = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tPT p = po[i], q = po[(i+1)%n];\n\t\tif (intersect(a, b, p, q) && (side(a, b, p) == 1 || side(a, b, q) == 1))\n\t\t\tcn++;\n\t}\n\treturn cn;\n}\n\nint windingN(Poly &po, PT a){\n\tint n = po.size();\n\tPT b = a;\n\tfor (PT p : po)\n\t\tb.real(max(b.X, p.X));\n\tint wn = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tPT p = po[i], q = po[(i+1)%n];\n\t\tif (intersect(a, b, p, q)){\n\t\t\tint ps = side(a, b, p), qs = side(a, b, q);\n\t\t\tif (qs >= 0) wn++;\n\t\t\tif (ps >= 0) wn--;\n\t\t}\n\t}\n\treturn wn;\n}\n\nint pointInPoly(Poly &po, PT a){\n\tint n = po.size();\n\tfor (int i = 0; i < n; i++)\n\t\tif (relpos(po[i], po[(i+1)%n], a) == ON)\n\t\t\treturn ON;\t\n\treturn (crossingN(po, a)%2 ? IN : OUT);\n}\n\nPoly getHull(Poly &po, bool lower){\n\tsort(po.begin(), po.end(), cmpXY());\n\tPoly res;\n\tint n = res.size();\n\tfor (auto p : po){\n\t\twhile (n >= 2 && side(res[n-2], res[n-1], p) == (lower ? RIGHT : LEFT))\n\t\t\tres.pop_back(), n--;\n\t\tres.pb(p), n++;\n\t}\n\treturn res;\n}\n\nPoly convexHull(Poly &po){\n\tint n = po.size();\n\tPoly lower = getHull(po, true),\n\t\t upper = getHull(po, false);\n\tPoly res = lower;\n\tfor (int i = (int)upper.size()-2; i; i--)\n\t\tres.pb(upper[i]);\n\treturn res;\n}\n\npair <PT, PT> nearestPair(Poly &po){\n\tint n = po.size();\n\tsort(po.begin(), po.end(), cmpXY());\n\tmultiset <PT, cmpYX> s;\n\tld rad = len(po[1]-po[0]);\n\tpair <PT, PT> res = {po[0], po[1]};\n\tint l = 0, r = 0;\n\tfor (int i = 0; i < n; i++){\n\t\twhile (l < r && Geq(po[i].X - po[l].X, rad))\n\t\t\ts.erase(po[l++]);\n\t\twhile (r < i && Leq(po[r].X, po[i].X))\n\t\t\ts.insert(po[r++]);\n\t\tfor (auto it = s.lower_bound(PT(po[i].X, po[i].Y-rad)); it != s.end(); it++){\n\t\t\tif (Grt(it->Y, po[i].Y+rad))\n\t\t\t\tbreak;\n\t\t\tld cur = len(po[i] - (*it));\n\t\t\tif (Lss(cur, rad)){\n\t\t\t\trad = cur;\n\t\t\t\tres = {*it, po[i]};\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\npair <PT, PT> farthestPair(Poly &po){\n\tint n = po.size();\n\tpair <PT, PT> res = {po[0], po[0]};\n\tint j = 0;\n\tfor (int i = 0; i < n; i++){\n\t\twhile (Grt(len(po[(j+1)%n] - po[i]), len(po[j] - po[i])))\n\t\t\tj = (j+1)%n;\n\t\tif (Grt(len(po[j]-po[i]), len(res.S-res.F)))\n\t\t\tres = {po[i], po[j]};\n\t}\n\treturn res;\n}\n\nld diameter(Poly &po){\n\tauto p = farthestPair(po);\n\treturn len(p.S-p.F);\n}\n\nld radius(Poly &po){\n\tauto p = nearestPair(po);\n\treturn len(p.S-p.F);\n}\n\nPoly convexCut(Poly &po, PT a, PT b){\n\tint n = po.size();\n\tPoly res;\n\tfor (int i = 0; i < n; i++){\n\t\tif (side(a, b, po[i]) >= 0) \n\t\t\tres.pb(po[i]);\n\t\tif (abs(side(a, b, po[i]) - side(a, b, po[(i+1)%n])) == 2)\n\t\t\tres.pb(intersection(a, b, po[i], po[(i+1)%n]));\n\t}\n\treturn res;\n}\n\nint main(){\t\n\tcout << setprecision(10) << fixed;\n\tPoly poly;\n\tfor (int i = in(); i; i--){\n\t\tPT p;\n\t\tcin >> p;\n\t\tpoly.pb(p);\n\t}\n\tcout << radius(poly) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\ntypedef vector<point> polygon;\n\nconst double oo = 1e18;\n\nnamespace std\n{\n\tbool operator<(point a, point b)\n\t{\n\t\tif (a.real() != b.real())\n\t\t\treturn a.real() < b.real();\n\t\treturn a.imag() < b.imag();\n\t}\n}\n\ndouble closestPairPoints(vector<point> &p){\n\tauto cmp = [](point a, point b)\n\t{\n\t\treturn make_pair(a.imag(), a.real()) < make_pair(b.imag(), b.real());\n\t};\n\n\tint n = (int)p.size();\n\tsort(p.begin(), p.end());\n\n\tset<point, decltype(cmp)> S(cmp);\n\tdouble ans = oo;\n\tint ptr = 0;\n\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\twhile (ptr < i && abs(p[i].real() - p[ptr].real()) >= ans)\n\t\t\tS.erase(p[ptr++]);\n\n\t\tauto lo = S.lower_bound(point(-oo, p[i].imag() - sqrt(ans) - 1));\n\t\tauto hi = S.upper_bound(point(-oo, p[i].imag() + sqrt(ans) + 1));\n\n\t\tfor (decltype(lo) it = lo; it != hi; ++it)\n\t\t\tans = min(ans, abs(p[i] - *it));\n\n\t\tS.insert(p[i]);\n\t}\n\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\tvector<point> p(n);\n\t\n\tfor (int i = 0; i < n; ++i){\n\t\tdouble x, y; cin >> x >> y;\n\t\tp[i] = point(x, y);\n\t}\n\n\tcout.precision(10);\n\tcout << fixed << closestPairPoints(p) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct node{\n  int dim;\n  vector<double>v;\n};\n\ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n\ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n\n  vector<node>res;\n\n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n\n    double dist=d(p,S)/(4*p.dim);\n\n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n\n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    if(S.size() == nextS.size())break;\n    S=nextS;    \n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n  \n  return ans;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n\n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ninline double Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ninline double Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ninline double Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ninline double Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ninline double Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ninline double Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\n\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  if (r - l == 2) {\n    return PointPoint(ps[l], ps[l + 1]);\n  }\n  if (r - l == 3) {\n    PointPoint a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return Closer(a, Closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  Points pos[2];\n  for (int i = l; i < r; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) pos[i < mid].push_back(ps[i]);\n  }\n  for (const auto &i : pos[0]) {\n    for (const auto &j : pos[1]) {\n      if (Distance(i, j) < d) {\n        d = Distance(i, j);\n        res = PointPoint(i, j);\n      }\n    }\n  }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  PointPoint res = ClosestPairUtil(ps, 0, ps.size());\n  res.first = rotate(-0.1, res.first);\n  res.second = rotate(-0.1, res.second);\n  return res;\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  sort(p.begin(), p.end());\n  PointPoint pp = ClosestPair(p);\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n  // cerr << pp.first << \" \" << pp.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\ntemplate<int D,class point> struct kd_tree{\n    point p;\n    int axis;\n    kd_tree<D,point>* left,*right;\n    kd_tree(int axis_=0):left(NULL),right(NULL),axis(axis_){};\n    kd_tree(vector<point> points,int axis_=0):left(NULL),right(NULL),axis(axis_){ assert(points.size()); build(points,0,points.size()); }\n    ~kd_tree(){ delete left; delete right; }\n    kd_tree<D,point>* build(vector<point> &points,int l,int r){\n        int m=(l+r)/2;\n        nth_element(points.begin()+l,points.begin()+m,points.begin()+r,[&](const point& p,const point& q){ return p[axis]<q[axis]; });\n        p=points[m];\n        if(l<m){\n            left=new kd_tree<D,point>((axis+1)%D);\n            left->build(points,l,m);\n        }\n        if(m+1<r){\n            right=new kd_tree<D,point>((axis+1)%D);\n            right->build(points,m+1,r);\n        }\n        return this;\n    }\n    kd_tree<D,point>* insert(const point& q){\n        if(q[axis]<p[axis]){\n            if(left==NULL){\n                vector<point> points={q};\n                left=new kd_tree<D,point>(points,(axis+1)%D);\n                return left;\n            }else return left->insert(q);\n        }else{\n            if(right==NULL){\n                vector<point> points={q};\n                left=new kd_tree<D,point>(points,(axis+1)%D);\n                return left;\n            }else return right->insert(q);\n        }\n    }\n    //????????????(O(n))?????§erased?????°?????????????????????,erased???????????\\????¢????????????¨??????build???????????????????????????????????????.\n    void erase(const point& q){\n        kd_tree<D,point>* tree=nearest_neighbor(q);\n        vector<point> points=tree->collect();\n        points.erase(points.rbegin());\n        delete tree->left;\n        delete tree->right;\n        tree->build(points,0,points.size());\n    }\n    vector<point> collect()const{\n        vector<point> points;\n        if(left!=NULL){\n            vector<point> left_points=left->collect();\n            points.insert(points.end(),left_points.begin(),left_points.end());\n        }\n        if(right!=NULL){\n            vector<point> right_points=right->collect();\n            points.insert(points.end(),right_points.begin(),right_points.end());\n        }\n        points.push_back(p);\n        return points;\n    };\n    const kd_tree<D,point>* nearest_neighbor(const point& q)const{ //const???????????????????????????\n        const kd_tree<D,point>* res=this;\n        long double mind=inf64;\n        auto dist=[&](const point& p,const point& q){\n            long double d=0;\n            for(int i=0; i<D; ++i) d+=(p[i]-q[i])*(p[i]-q[i]);\n            return sqrtl(d);\n        };\n        function<void(const kd_tree<D,point>*)> rec=[&](const kd_tree<D,point>* tree){\n            if(dist(p,q)<mind){\n                res=tree;\n                mind=dist(p,q);\n            }\n            if(q[tree->axis]<tree->p[tree->axis]){\n                if(tree->left!=NULL) rec(tree->left);\n                if(tree->right!=NULL and tree->p[tree->axis]-q[tree->axis]<=mind) rec(tree->right);\n            }else{\n                if(tree->right!=NULL) rec(tree->right);\n                if(tree->left!=NULL and q[tree->axis]-tree->p[tree->axis]<=mind) rec(tree->left);\n            }\n        };\n        rec(this);\n        return res;\n    }\n    vector<point> range_search(const point& lb,const point& ub)const{\n        vector<point> res;\n        function<void(const kd_tree<D,point>*)> rec=[&](const kd_tree<D,point>* tree){\n            bool in_range=true;\n            for(int i=0; i<D; ++i) if(tree->p[i]<lb[i] or ub[i]<tree->p[i]){\n                in_range=false;\n                break;\n            }\n            if(in_range) res.push_back(tree->p);\n            if(tree->left!=NULL and lb[tree->axis]<=tree->p[tree->axis]) rec(tree->left);\n            if(tree->right!=NULL and ub[tree->axis]>=tree->p[tree->axis]) rec(tree->right);\n        };\n        rec(this);\n        return res;\n    }\n};\n\nvoid solve(){\n    int n;\n    cin >> n;\n\n    using point=vector<long double>;\n    vector<point> ps;\n    rep(i,0,n){\n        long double x,y;\n        cin >> x >> y;\n        ps.push_back(point({x,y}));\n    }\n\n    kd_tree<2,point> kt({ps[0]});\n    long double ans=inf64;\n    rep(i,1,n){\n        point p=kt.nearest_neighbor(ps[i])->p;\n        ans=min(ans,sqrtl((ps[i][0]-p[0])*(ps[i][0]-p[0])+(ps[i][1]-p[1])*(ps[i][1]-p[1])));\n        kt.insert(ps[i]);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct node{\n  int dim;\n  vector<double>v;\n};\n \ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n \ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nmap<vector<int> ,vector<int> >grid;\n\nvector<int> neighborhood(vector<int> v, int dim, vector<int>res){\n\n  if(dim==v.size()){\n    bool fg = true;\n    for(int i=0;i<dim;i++)fg&=(res[i]==v[i]);\n    if(fg || !grid.count(res))return vector<int>();\n    return grid[res];\n  }\n  vector<int> result;\n  for(int i=-1;i<2;i++){\n    res.push_back(v[dim]+i);\n    vector<int>tmp = neighborhood(v,dim+1,res);\n    result.insert(result.end(),tmp.begin(),tmp.end());\n    res.pop_back();\n  }\n  return result;\n}\n\ndouble rec(vector<int> v, int dim, vector<int>res, node p, vector<node> S){\n  if(dim==v.size()){\n    if(!grid.count(res))return 1000000000;\n    double result=100000000;\n    \n    for(int i=0;i<grid[res].size();i++)\n      if(p.v!=S[grid[res][i]].v)\n      result=min(result,d(p,S[grid[res][i]]));\n    return result;\n  }\n  double result=1000000000;\n  for(int i=-1;i<2;i++){\n    res.push_back(v[dim]+i);\n    result=min(result,rec(v,dim+1,res,p,S));\n    res.pop_back();\n  }\n  return result;\n}\n\nvector<node> func(vector<node> S){\n  vector<node>nextS;\n  map<vector<int>,vector<int> >::iterator it = grid.begin();\n  for(;it!=grid.end();it++){\n    vector<int>res=neighborhood((*it).first,0,vector<int>());\n    for(int j=0;j<res.size();j++)nextS.push_back(S[res[j]]);\n  }\n\n  return nextS;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n \n  double res;\n  vector<node>tmp=S;\n  int came = 0;\n  while(!S.empty()){\n    node p=S[rand()%S.size()];\n \n    res=d(p,S);\n    double dist=res/(4*p.dim);\n \n    grid.clear();\n    for(int i=0;i<S.size();i++){\n      vector<int> key;\n      for(int j=0;j<p.dim;j++)key.push_back((int)(S[i].v[j]/dist));\n      grid[key].push_back(i);\n    }\n   \n    S=func(S);\n  }\n\n  S=tmp;\n  double ans=100000000;\n  grid.clear();\n  for(int i=0;i<S.size();i++){\n    vector<int> key;\n    for(int j=0;j<2;j++)key.push_back((int)(S[i].v[j]/res));\n    grid[key].push_back(i);\n  }\n  //cout << \"came1\" << endl;\n  map<vector<int>,vector<int> >::iterator it = grid.begin();\n  //cout << \"grid size = \" << grid.size() << \" \" << res << endl;\n  for(;it!=grid.end();it++){\n    for(int j=0;j<(*it).second.size();j++){\n      ans=min(ans,rec((*it).first,0,vector<int>(),S[(*it).second[j]],S));\n    }\n  }\n  //cout << \"came2\" << endl;\n  return ans;\n}\n \nint main(void){\n \n  int n;\n  cin >> n;\n \n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n \n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-10\n#define Vector Point\n#define INF 2000000000\n#define DOUBLE_INF 1e50\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\n\n// Geometry Library\n// written by okuraofvegetable\n\ninline double add(double a,double b){\n\tif(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint() {}\n\tPoint(double x,double y) : x(x),y(y){}\n\tPoint operator + (Point p){return Point(add(x,p.x),add(y,p.y));}\n\tPoint operator - (Point p){return Point(add(x,-p.x),add(y,-p.y));}\n\tPoint operator * (double d){return Point(x*d,y*d);}\n\tdouble dot(Point p){return add(x*p.x,y*p.y);}\n\tdouble det(Point p){return add(x*p.y,-y*p.x);}\n\tdouble norm(){return sqrt(x*x+y*y);}\n\tdouble norm2(){return x*x+y*y;}\n\tdouble dist(Point p){return ((*this)-p).norm();}\n\tdouble dist2(Point p){return sq(x-p.x)+sq(y-p.y);}\n\tPoint vert(){return Point(y,-x);}\n\tvoid dump(const char* msg=\"\"){printf(\"%s%.12f %.12f\\n\",msg,x,y);return;}\n\t\n\t// following functions for vector operation\n\n\t// signed area of triange (0,0) (x,y) (p.x,p.y)\n\tdouble area(Point p){\n\t\treturn (x*p.y-p.x*y)/2.0;\n\t}\n};\n// direction a -> b -> c\n// verified AOJ CGL_1_C\nenum {COUNTER_CLOCKWISE,\n\t\tCLOCKWISE,\n\t\tONLINE_BACK,\n\t\tONLINE_FRONT,\n\t\tON_SEGMENT};\nint ccw(Point a,Point b,Point c){\n\tVector p = b-a;\n\tVector q = c-a;\n\tif(p.det(q)>0.0)return COUNTER_CLOCKWISE; // counter clockwise\n\tif(p.det(q)<0.0)return CLOCKWISE; // clockwise\n\tif(p.dot(q)<0.0)return ONLINE_BACK; // c--a--b online_back\n\tif(p.norm()<q.norm())return ONLINE_FRONT; // a--b--c online_front \n\treturn ON_SEGMENT;// a--c--b on_segment\n}\nstruct Line{\n\tPoint a,b;\n\tLine(){}\n\tLine(Point a,Point b):a(a),b(b){}\n\tbool on(Point q){\n\t\treturn (a-q).det(b-q)==0; \n\t}\n\t// folloing 2 functions verified AOJ CGL_2_A\n\tbool is_parallel(Line l){return (a-b).det(l.a-l.b)==0;}\n\tbool is_orthogonal(Line l){return (a-b).dot(l.a-l.b)==0;}\n\tPoint intersection(Line l){\n\t\tassert(!is_parallel(l));\n\t\treturn a+(b-a)*((l.b-l.a).det(l.a-a)/(l.b-l.a).det(b-a));\n\t}\n\t// projection of p to this line\n\t// verified AOJ CGL_1_A\n\tPoint projection(Point p){\n\t\treturn (b-a)*((b-a).dot(p-a)/(b-a).norm2())+a;\n\t}\n\t// reflection point of p onto this line\n\t// verified AOJ CGL_1_B\n\tPoint refl(Point p){\n\t\tPoint proj = projection(p);\n\t\treturn p+((proj-p)*2.0);\n\t}\n};\nstruct Segment{\n\tPoint a,b;\n\tSegment(){}\n\tSegment(Point a,Point b):a(a),b(b){}\n\tLine line(){\n\t\treturn Line(a,b);\n\t}\n\tbool on(Point q){\n\t\treturn ((a-q).det(b-q)==0&&(a-q).dot(b-q)<=0); \n\t}\n\t// verified AOJ CGL_2_B\n\tbool is_intersect(Segment s){\n\t\tif(line().is_parallel(s.line())){\n\t\t\tif(on(s.a)||on(s.b))return true;\n\t\t\tif(s.on(a)||s.on(b))return true;\n\t\t\treturn false;\n\t\t}\n\t\tPoint p = line().intersection(s.line());\n\t\tif(on(p)&&s.on(p))return true;\n\t\telse return false;\n\t}\n\tbool is_intersect(Line l){\n\t\tif(line().is_parallel(l)){\n\t\t\tif(l.on(a)||l.on(b))return true;\n\t\t\telse return false;\n\t\t}\n\t\tPoint p = line().intersection(l);\n\t\tif(on(p))return true;\n\t\telse return false;\n\t}\n\t// following 2 distance functions verified AOJ CGL_2_D\n\tdouble distance(Point p){\n\t\tdouble res = DOUBLE_INF;\n\t\tPoint q = line().projection(p);\n\t\tif(on(q))res = min(res,p.dist(q));\n\t\tres = min(res,min(p.dist(a),p.dist(b)));\n\t\treturn res;\n\t}\n\tdouble distance(Segment s){\n\t\tif(is_intersect(s))return 0.0;\n\t\tdouble res = DOUBLE_INF;\n\t\tres = min(res,s.distance(a));\n\t\tres = min(res,s.distance(b));\n\t\tres = min(res,this->distance(s.a));\n\t\tres = min(res,this->distance(s.b));\n\t\treturn res;\n\t}\n};\n\n// Polygon \n\ntypedef vector<Point> Polygon;\n// verified AOJ CGL_3_A\n// Polygon don't need to be convex\ndouble area(Polygon& pol){\n\tvector<Point> vec;\n\tdouble res = 0.0;\n\tint M = pol.size();\n\tfor(int i=0;i<M;i++){\n\t\tres += (pol[i]-pol[0]).area(pol[(i+1)%M]-pol[0]);\t\n\t}\n\treturn res;\n}\nbool is_convex(Polygon& pol){\n\tint n = pol.size();\n\tfor(int i=0;i<n-1;i++){\n\t\tif(ccw(pol[i],pol[i+1],pol[(i+2)%n])==CLOCKWISE){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n// vecrified AOJ CGL_3_C\nenum {OUT,ON,IN};\nint contained(Polygon& pol,Point p){\n\tint n = pol.size();\n\tPoint outer(1e9,p.y);\n\tSegment s = Segment(outer,p);\n\tint cnt = 0;\n\tfor(int i=0;i<n;i++){\n\t\tSegment e = Segment(pol[i],pol[(i+1)%n]);\n\t\tif(e.on(p))return ON;\n\t\tVector a = pol[i]-p;\n\t\tVector b = pol[(i+1)%n]-p;\n\t\tif(a.y>b.y)swap(a,b);\n\t\tif(a.y<=0.0&&b.y>0.0){\n\t\t\tif(a.det(b)<0.0)cnt++;\n\t\t}\n\t}\n\tif((cnt&1)==1)return IN;\n\telse return OUT;\n}\n// compare function for convex_hull\n// sort points by (x-y) lexicographical order.\n// you can change (y-x) order with no change in convex_hull\nbool comp(const Point& p,const Point& q){\n\tif(p.x!=q.x)return p.x<q.x;\n\telse return p.y<q.y;\n}\n// Convex hull\n// if you want not to contain points on boundary,\n// change while(....<=0.0)\n// verified AOJ CGL_4_A\nPolygon convex_hull(vector<Point> ps){\n\tsort(all(ps),comp);\n\tint k = 0;\n\tint n = ps.size();\n\tPolygon qs(2*n);\n\tfor(int i=0;i<n;i++){\n\t\twhile(k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<0.0)k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile(k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<0.0)k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n// Caliper method\n// verified AOJ CGL_4_B\ndouble convex_diameter(Polygon& cv){\n\tint i=0,j=0;\n\tint n = cv.size();\n\tfor(int k=0;k<n;k++){\n\t\tif(!comp(cv[i],cv[k]))i=k;\n\t\tif(comp(cv[j],cv[k]))j=k;\n\t}\n\tint si=i,sj=j;\n\tdouble res = 0.0;\n\twhile(i!=sj||j!=si){\n\t\tres = max(res,cv[i].dist(cv[j]));\n\t\tif((cv[(i+1)%n]-cv[i]).det(cv[(j+1)%n]-cv[j])<0.0)i=(i+1)%n;\n\t\telse j=(j+1)%n;\n\t}\n\treturn res;\n}\n// Cut conovex polygon by a line and return left polygon\n// verified AOJ CGL_4_C\nPolygon convex_cut(Polygon& cv,Line l){\n\tint n = cv.size();\n\tPolygon left; \n\tfor(int i=0;i<n;i++){\n\t\tSegment e = Segment(cv[i],cv[(i+1)%n]);\n\t\tif(ccw(l.a,l.b,cv[i])!=CLOCKWISE)left.pb(cv[i]);\n\t\tif(e.is_intersect(l)){\n\t\t\tif(!e.line().is_parallel(l)){\n\t\t\t\tleft.pb(e.line().intersection(l));\n\t\t\t}\n\t\t}\n\t}\n\treturn left;\n}\n// distance between closest pair\nbool comp_y(const Point& p,const Point& q){\n\treturn p.y<q.y;\n}\ndouble closest_pair(auto a,int n){\n\tif(n<=1)return DOUBLE_INF;\n\tint m = n/2;\n\tdouble x = (a+m)->x;\n\tdouble d = min(closest_pair(a,m),closest_pair(a+m,n-m));\n\tinplace_merge(a,a+m,a+n,comp_y);\n\tvector<Point> b;\n\tfor(int i=0;i<n;i++){\n\t\tdouble ax = (a+i)->x;\n\t\tdouble ay = (a+i)->y;\n\t\tif(abs(ax-x)>=d)continue;\n\t\tfor(int j=0;j<b.size();j++){\n\t\t\tdouble dx = ax-b[b.size()-1-j].x;\n\t\t\tdouble dy = ay-b[b.size()-1-j].y;\n\t\t\tif(dy>=d)break;\n\t\t\td = min(d,sqrt(dx*dx+dy*dy));\n\t\t}\n\t\tb.pb(*(a+i));\n\t}\n\treturn d;\n}\ndouble closest_pair(vector<Point> a){\n\tsort(all(a),comp);\n\treturn closest_pair(a.begin(),(int)a.size());\n}\n// for input\nPoint input_point(){\n\tPoint p;\n\tcin >> p.x >> p.y;\n\treturn p;\n}\nSegment input_segment(){\n\tPoint a,b;\n\ta = input_point();\n\tb = input_point();\n\treturn Segment(a,b);\n}\nLine input_line(){\n\tPoint a,b;\n\ta = input_point();\n\tb = input_point();\n\treturn Line(a,b);\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<Point> pol;\n\tfor(int i=0;i<n;i++){\n\t\tpol.pb(input_point());\n\t}\n\tprintf(\"%.12f\",closest_pair(pol));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\n\t\tmemo = min(ans,abs(data[i + 1].second - data[i].second));\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&memo >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\t\tmemo = min(ans, memo);\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    const int loops = 111;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + j].first - p2[i].first) * (p2[i + j].first - p2[i].first) + (p2[i + j].second - p2[i].second) * (p2[i + j].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.9f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define INF 1000000000\n#define mod 1000000007\nusing ll=long long;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n\n//////////////////////////////////////////////////////\nusing Real=double;\nusing Point=complex<Real>;\nconst Real EPS=1e-10;\nconst Real pi=acosl(-1);\n//入出力補助\nistream &operator>>(istream &is,Point &p){\n    Real a,b;\n    is>>a>>b;\n    p=Point(a,b);\n    return is;\n}\nostream &operator<<(ostream &os,Point &p){\n    return os<<fixed<<setprecision(12)<<p.real()<<' '<<p.imag();\n}\n \ninline bool eq(Real a,Real b){\n    return fabs(a-b)<EPS;\n}\nPoint operator*(const Point &p,const Real &d){\n    return Point(real(p)*d,imag(p)*d);\n}\nstruct Line{\n    Point p1,p2;\n    Line()=default;\n    Line(Point p1,Point p2):p1(p1),p2(p2){}\n \n    //Ax + By = C\n    Line(Real A,Real B,Real C){\n       if(eq(A,0))     p1=Point(0,C/B),p2=Point(1,C/B);\n       else if(eq(B,0))p1=Point(C/A,0),p2=Point(C/A,1);\n       else            p1=Point(0,C/B),p2=Point(C/A,0);\n    }\n};\nstruct Segment:Line{\n   Segment()=default;\n   Segment(Point p1,Point p2):Line(p1,p2){}\n};\nstruct Circle{\n    Point center;\n    Real r;\n    Circle()=default;\n    Circle(Point center,Real r):center(center),r(r){}\n};\n/////////////////////////////////////////////////////////\n \n \n// 点 p を反時計回りに theta 回転\nPoint rotate(Real theta,const Point &p) {\n    return Point(cos(theta)*p.real()-sin(theta)*p.imag(),sin(theta)*p.real()+cos(theta)*p.imag());\n}\n \nReal radian_to_degree(Real r){\n    return r*180.0/pi;\n}\n \nReal degree_to_radian(Real d){\n    return d*pi/180.0;\n}\n \n//三角形の面積，サラスの公式\nReal area_triangle(Point a,Point b,Point c){\n    Point x=b-a,y=c-a;\n    return fabs(x.real()*y.imag()-x.imag()*y.real())/2;\n}\n \n//v\n//外積\nReal cross(Point a,Point b){\n    return real(a)*imag(b)-imag(a)*real(b);\n}\n//v\n//内積\nReal dot(Point a,Point b) {\n    return real(a)*real(b)+imag(a)*imag(b);\n}\n \n//v\n//平行判定，外積0かをみる\nbool parallel(Line a,Line b){\n    return eq(cross(a.p1-a.p2,b.p1-b.p2),0.0);\n}\n//v\n//垂直判定，内積0かをみる\nbool orthogonal(Line a,Line b){\n    return eq(dot(a.p1-a.p2,b.p1-b.p2),0.0);\n}\n \n//v\n//正射影，pからlに下した垂線の足を求める\nPoint projection(Line l,Point p){\n    //ベクトルl上のどの位置に垂線の足が来るか求める\n    Real k=dot(l.p1-l.p2,p-l.p1)/norm(l.p1-l.p2);\n    return l.p1+(l.p1-l.p2)*k;\n}\nPoint projection(Segment l,Point p){\n    Real k=dot(l.p1-l.p2,p-l.p1)/norm(l.p1-l.p2);\n    return l.p1+(l.p1-l.p2)*k;\n}\n \n//v\n//反射，直線lに関し点pと線対称な点を返す\nPoint reflection(Line l,Point p){\n    Point h=projection(l,p);\n    return (p+(h-p)+(h-p));\n}\nPoint reflection(Segment l,Point p){\n    Point h=projection(l,p);\n    return (p+(h-p)+(h-p));\n}\n \n//二点間の距離\nReal dis(Point a,Point b){\n    return abs(a-b);\n} \n//点と直線の距離\nReal dis(Line l,Point p){\n    return abs(p-projection(l,p));\n}\n \n//v\n//COUNTER CLOCKWISE，返す値は↓を参照\n//https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/all/CGL_1_C\nint ccw(Point a,Point b,Point c){\n    b-=a;c-=a;\n    if(cross(b,c)>EPS)       return  1;//COUNTER CLOCKWISE\n    else if(cross(b,c)<-EPS) return -1;//CLOCKWISE\n    else if(dot(b,c)<0)      return  2;//c--a--b ONLINE BACK\n    else if(norm(b)<norm(c)) return -2;//a--b--c ONLINE FRONT\n    else                     return  0;//a--c--b ON SEGMENT\n}\n \n//v\n//3点が作る三角形の外心\n//面積0の三角形を渡すと分母に面積があるので壊れるかも\nPoint circumcenter(Point A,Point B,Point C){\n    Real S=area_triangle(A,B,C);\n    Real a=dis(B,C),b=dis(A,C),c=dis(A,B);\n    return A*(a*a*(b*b+c*c-a*a)/(16*S*S))+B*(b*b*(c*c+a*a-b*b)/(16*S*S))+C*(c*c*(a*a+b*b-c*c)/(16*S*S));\n}\n \n//交差判定\n//直線状に乗るか\nbool intersect(Line l,Point p){\n    return abs(ccw(l.p1,l.p2,p))!=1;\n}\n//直線の交差判定，外積\nbool intersect(Line l1,Line l2){\n    return abs(cross(l1.p2-l1.p1,l2.p2-l2.p1))>EPS or\n        abs(cross(l1.p2-l1.p1,l2.p2-l1.p1))<EPS;\n}\n//線分に点が乗るかの判定，ccw\nbool intersect(Segment s,Point p){\n    return ccw(s.p1,s.p2,p)==0;\n}\n//直線と線分の交差判定\nbool intersect(Line l,Segment s){\n    return cross(l.p2-l.p1,s.p1-l.p1)*cross(l.p2-l.p1,s.p2-l.p1)<EPS;\n}\n//円と直線の交差判定\nbool intersect(Circle c,Line l){\n    return dis(l,c.center)<=c.r+EPS;\n}\n//円上かどうか，内部かどうかではない\nbool intersect(Circle c,Point p){\n    return abs(abs(p-c.center)-c.r)<EPS;\n}\n//v\n//線分と線分の交差判定\nbool intersect(Segment s,Segment t){\n    return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <=0 and\n        ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2)<=0;\n}\n//線分と円の交差判定，交点の個数を返す\nint intersect(Circle c,Segment l){\n    Point h=projection(l,c.center);\n    //直線まるっと円の外側\n    if(norm(h-c.center)-c.r*c.r>EPS)    return 0;\n    Real d1=abs(c.center-l.p1),d2=abs(c.center-l.p2);\n    //線分が円内\n    if(d1<c.r+EPS and d2<c.r+EPS) return 0;\n    if((d1<c.r-EPS and d2>c.r+EPS) or (d2<c.r-EPS and d1>c.r+EPS)) return 1;\n    //円の外部にまるまるはみ出ていないか\n    if(dot(l.p1-h,l.p2-h)<0) return 2;\n    return 0;\n}\n//円と円の位置関係，共通接線の個数を返す\nint intersect(Circle c1,Circle c2){\n    if(c1.r<c2.r) swap(c1,c2);\n    Real d=abs(c1.center-c2.center);\n    //2円が離れている\n    if(c1.r+c2.r<d)     return 4;\n    //2円が外接する\n    if(eq(c1.r+c2.r,d)) return 3;\n    //2円が交わる\n    if(c1.r-c2.r<d)     return 2;\n    //円が内接する\n    if(eq(c1.r-c2.r,d)) return 1;\n    //内包\n                        return 0;\n}\n \n//交点\n//線分の交点はintersectをチェックしてokなら直線の交点をやる\n//intersectをチェックすること\n//v\nPoint crosspoint(Line l,Line m){\n    Real A=cross(m.p2-m.p1,m.p1-l.p1);\n    Real B=cross(m.p2-m.p1,l.p2-l.p1);\n    if(eq(A,0) and eq(B,0)) return l.p1;\n    if(eq(B,0))             throw \"NAI\";\n    return l.p1+A/B*(l.p2-l.p1);    \n}\nPoint crosspoint(Segment l,Segment m){\n    return crosspoint(Line(l),Line(m));\n}\nvector<Point> crosspoint(Circle c,Line l){\n    vector<Point> ret;\n    Point h=projection(l,c.center);\n    Real d=sqrt(c.r*c.r-norm(h-c.center));\n    Point e=(l.p2-l.p1)*(1/abs(l.p2-l.p1));\n    if(c.r*c.r+EPS<norm(h-c.center)) return ret;\n    if(eq(dis(l,c.center),c.r)){\n        ret.push_back(h);\n        return ret;\n    }\n    ret.push_back(h+e*d);ret.push_back(h-e*d);\n    return ret;\n}\n//要verify，\nvector<Point> crosspoint(Circle c,Segment s){\n    Line l=Line(s.p1,s.p2);\n    int ko=intersect(c,s);\n    if(ko==2) return crosspoint(c,l);\n    vector<Point> ret;\n    if(ko==0) return ret;\n    ret=crosspoint(c,l);\n    if(ret.size()==1) return ret;\n    vector<Point> rret;\n    //交点で挟める方を返す\n    if(dot(s.p1-ret[0],s.p2-ret[0])<0)  rret.push_back(ret[0]);\n    else                                rret.push_back(ret[1]);\n    return rret;\n}\n//v\nvector<Point> crosspoint(Circle c1,Circle c2){\n    vector<Point> ret;\n    int isec=intersect(c1,c2);\n    if(isec==0 or isec==4) return ret;\n    Real d=abs(c1.center-c2.center);\n    Real a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    Real t=atan2(c2.center.imag()-c1.center.imag(),c2.center.real()-c1.center.real());\n    ret.push_back(c1.center+Point(cos(t+a)*c1.r,sin(t+a)*c1.r));\n    ret.push_back(c1.center+Point(cos(t-a)*c1.r,sin(t-a)*c1.r));\n    return ret;\n}\n \n//v\n//点pから引いた円cの接線の接点を返す\nvector<Point> tangent(Circle c,Point p){\n    return crosspoint(c,Circle(p,sqrt(norm(c.center-p)-c.r*c.r)));\n}\n//v\n//二円の共通接線，Lineの2点は接点を表す\nvector<Line> tangent(Circle c1,Circle c2){\n    vector<Line> ret;\n    if(c1.r<c2.r) swap(c1,c2);\n    Real g=norm(c1.center-c2.center);\n    //中心が一致するならない\n    if(eq(g,0)) return ret;\n    Point u=(c2.center-c1.center)/sqrt(g);\n    Point v=rotate(pi*0.5,u);\n    for(int s:{-1,1}){\n        Real h=(c1.r+s*c2.r)/sqrt(g);\n        if(eq(1-h*h,0)){\n            ret.push_back(Line(c1.center+u*c1.r,c1.center+(u+v)*c1.r));\n        }\n        else if(1-h*h>0){\n            Point uu=u*h,vv=v*sqrt(1-h*h);\n            ret.push_back(Line(c1.center+(uu+vv)*c1.r,c2.center-(uu+vv)*c2.r*s));\n            ret.push_back(Line(c1.center+(uu-vv)*c1.r,c2.center-(uu-vv)*c2.r*s));\n        }\n    }\n    return ret;\n}\n \n//v\n//最小包含円を返す　計算量は期待値O(n)\nCircle MinimumBoundingCircle(vector<Point> v){\n    int n=v.size();\n  \n    //ランダムシャッフル．いぢわるされたくないもんだ\n    mt19937 mt(time(0));\n    shuffle(v.begin(),v.end(),mt);\n    Circle ret(0,0);\n    //2点で円を作る\n    auto make_circle2=[&](Point a,Point b){\n        return Circle((a+b)*0.5,dis(a,b)/2);\n    };\n    //3点で円を作る\n    auto make_circle3=[&](Point A,Point B,Point C){\n        Point cent=circumcenter(A,B,C);\n        return Circle(cent,dis(cent,A));\n    };\n    auto isIn=[&](Point a){\n        return dis(ret.center,a)<ret.r+EPS;\n    };\n \n    ret=make_circle2(v[0],v[1]);\n    for(int i=2;i<n;i++){\n        //v[i]が円に入っていないなら\n        if(!isIn(v[i])){\n            //円内にないなら点v[i]は必ず円周上に来る\n            ret=make_circle2(v[0],v[i]);\n            for(int j=1;j<i;j++){\n                if(!isIn(v[j])){\n                    //この時iとjが円周上を考える\n                    ret=make_circle2(v[i],v[j]);\n                    //最後の1点の決定\n                    for(int k=0;k<j;k++){\n                        if(!isIn(v[k])){\n                            ret=make_circle3(v[i],v[j],v[k]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nReal closest_pair(vector<Point> ps){\n    sort(ALL(ps),[&](Point a,Point b){\n        return real(a)<real(b);\n    });\n\n    function<Real(int,int)> rec=[&](int l,int r){\n        if(r-l<=1) return 1e18;\n        int m=(l+r)/2;\n        Real x=real(ps[m]);\n        Real ret=min(rec(l,m),rec(m,r));\n        inplace_merge(begin(ps)+l,begin(ps)+m,begin(ps)+r,[&](Point a,Point b){\n            return imag(a)<imag(b);\n        });\n        // 分割を跨いで最小距離があるか調べる\n        vector<Point> b;\n        for(int i=l;i<r;i++){\n            if(abs(real(ps[i])-x)>=ret) continue;\n            for(int j=(int)b.size()-1;j>=0;j--){\n                if(abs(imag(ps[i]-b[j]))>=ret) break;\n                ret=min(ret,abs(ps[i]-b[j]));\n            }\n            b.push_back(ps[i]);\n        }\n        return ret;\n    };\n    return rec(0,(int)ps.size());\n}\n\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    \n    cout<<fixed<<setprecision(12);\n    \n    int n;cin>>n;\n    vector<Point> v(n);\n    rep(i,n) cin>>v[i];\n    cout<<closest_pair(v)<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm> // inplace_merge\n#include<cmath>\n#include<vector>\nusing namespace std;\n\ntypedef pair<double,double> p;\np v[100000];\n\nconst double INF = 1e10;\n\nbool comp_y(p a, p b){\n    return a.second < b.second;\n}\n\n// 分割統治 O(nlogn)\ndouble closest_pair(p *a, int n){\n    if(n <= 1)  return INF;\n    \n    int m = n/2;\n    double x = a[m].first;\n    double d = min(closest_pair(a, m), closest_pair(a+m, n-m)); // x軸で区切られた範囲内での頂点対のみ考慮\n    inplace_merge(a, a+m, a+n, comp_y); // ソート済みの[a, a+m)と[a+m, a+n)をy座標基準でマージ\n\n    vector<p> b; // 直線 x = a[m].firstから距離d未満の点を入れる\n    for(int i = 0; i < n; i++){\n        if(fabs(a[i].first-x) >= d) continue; // そもそもx座標の差がd以上の点は論外\n\n        // bに入っている頂点を末尾から、y座標の差がd以上になるまで見ていく\n        // y座標降順で見ていき、d以上離れた時点で打ち切り\n        for(int j = 0; j < b.size(); j++){\n            double dx = a[i].first - b[b.size()-1-j].first;\n            double dy = a[i].second - b[b.size()-1-j].second;\n            if(dy >= d) break;\n            d = min(d, sqrt(dx*dx + dy*dy));\n        }\n\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; i++){\n        double x, y;\n        cin >> x >> y;\n        v[i] = {x,y};\n    }\n    sort(v, v+n);\n    cout << fixed << setprecision(12) << closest_pair(v, n) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    const int loops = 150;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + j].first - p2[i].first) * (p2[i + j].first - p2[i].first) + (p2[i + j].second - p2[i].second) * (p2[i + j].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\n\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    //two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n\n    //two_dimensional_qsort(p_xy, n0, n-1, 1);\n    two_dimensional_qsort(p_xy, n0, m-1, 1);\n    two_dimensional_qsort(p_xy, m, n-1, 1);\n    \n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        //cout<<\"qaaa\";\n        two_dimensional_qsort(p_xy, 0, n-1, 0);\n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct node{\n  int dim;\n  vector<double>v;\n};\n\ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n\ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n\n  double res=1000000000;\n\n  while(!S.empty()){\n    node p=S[rand()%S.size()];\n    res=d(p,S);\n    double dist=res/(4*p.dim);\n\n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n\n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    \n    S=nextS;    \n  }\n  return res;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n\n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct node{\n  int dim;\n  vector<double>v;\n};\n \ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n \ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nmap<vector<int> ,vector<int> >grid;\n\nvector<int> neighborhood(vector<int> v, int dim, vector<int>res){\n\n  if(dim==v.size()){\n    bool fg = true;\n    for(int i=0;i<dim;i++)fg&=(res[i]==v[i]);\n    if(fg || !grid.count(res))return vector<int>();\n    return grid[res];\n  }\n  vector<int> result;\n  for(int i=-1;i<2;i++){\n    res.push_back(v[dim]+i);\n    vector<int>tmp = neighborhood(v,dim+1,res);\n    result.insert(result.end(),tmp.begin(),tmp.end());\n    res.pop_back();\n  }\n  return result;\n}\n\nvector<node> func(vector<node> S){\n  vector<node>nextS;\n  map<vector<int>,vector<int> >::iterator it = grid.begin();\n  for(;it!=grid.end();it++){\n    vector<int>res=neighborhood((*it).first,0,vector<int>());\n    for(int j=0;j<res.size();j++)nextS.push_back(S[res[j]]);\n  }\n\n  return nextS;\n}\n\ndouble rec(vector<int> v, int dim, vector<int>res, node p, vector<node> S){\n  if(dim==v.size()){\n    if(!grid.count(res))return 1000000000;\n    double result=100000000;\n    for(int i=0;i<grid[res].size();i++)\n      if(p.v!=S[grid[res][i]].v)\n      result=min(result,d(p,S[grid[res][i]]));\n    return result;\n  }\n  double result=1000000000;\n  for(int i=-1;i<2;i++){\n    res.push_back(v[dim]+i);\n    result=min(result,rec(v,dim+1,res,p,S));\n    res.pop_back();\n  }\n  return result;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n \n  double res;\n  vector<node>tmp=S;\n\n  while(!S.empty()){\n    node p=S[rand()%S.size()];\n \n    res=d(p,S);\n    double dist=res/(4*p.dim);\n \n    grid.clear();\n    for(int i=0;i<S.size();i++){\n      vector<int> key;\n      for(int j=0;j<p.dim;j++)key.push_back((int)(S[i].v[j]/dist));\n      grid[key].push_back(i);\n    }\n   \n    S=func(S);\n  }\n\n  S=tmp;\n  double ans=100000000;\n  grid.clear();\n  for(int i=0;i<S.size();i++){\n    vector<int> key;\n    for(int j=0;j<2;j++)key.push_back((int)(S[i].v[j]/res));\n    grid[key].push_back(i);\n  }\n  \n  map<vector<int>,vector<int> >::iterator it = grid.begin();\n  for(;it!=grid.end();it++){\n    for(int j=0;j<(*it).second.size();j++){\n      ans=min(ans,rec((*it).first,0,vector<int>(),S[(*it).second[j]],S));\n    }\n  }\n\n  return ans;\n}\n \nint main(void){\n \n  int n;\n  cin >> n;\n \n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n \n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<utility>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n\ntypedef pair<double, double> point;\ntypedef point* data;\n\ninline double dist(const point &a, const point &b)\n{\n    double dx = a.first - b.first, dy = a.second - b.second;\n    return sqrt(dx * dx + dy * dy);\n}\n\nbool sort_y(const point &P1, const point &P2){ return P1.second < P2.second; }\n\ndouble closest(data P, int n)\n{\n    if(n <= 1) return 1000;\n    if(n == 2) return dist(P[0], P[1]);\n    int m = n / 2;\n    sort(P, P + n, sort_y); // y_sort, down to up.\n\tdouble median = P[m].second;\n    double d = min(closest(P, m), closest(P + m, n - m));\n\n\tsort(P, P + n);\n\tvector<point> V;\n\t\n\tint i, k, a = 0, size = 0;\n\tfor(i = 0; i < n; i++){\n\t\tif(fabs(P[i].second - median) > d) continue;\n\t\tV.push_back(P[i]);\n\t\tsize++;\n\t\tfor(k = a; k < size - 1; k++){\n\t\t\tif(P[size].first - P[k].first > d){ a++; }\n\t\t\telse{\n\t\t\t\td = min(d, dist(P[size], P[k]));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\n\nint main()\n{\n\tint i, n;\n\tdouble x, y;\n\tscanf(\"%d\", &n);\n\tdata P;\n\tP = new point [n];\n\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tP[i] = make_pair(x, y);\n\t}\n\tprintf(\"%.12f\\n\", closest(P, n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\n/*struct P\n{\n\tdouble x, y;\n\tP(double x,double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};*/\n\n/*int ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}*/\n\ndouble dist(pdd a, pdd b)\n{\n\treturn (a.first - b.first)*(a.first - b.first) + (a.second - b.second)*(a.second - b.second);\n}\n\ndouble ClosestPair(vector<pdd>& points,int l,int r)\n{\n\tif (r - l == 1)\n\t{\n\t\treturn INF;\n\t}\n\tif (r - l == 2)\n\t{\n\t\treturn dist(points[l], points[l + 1]);\n\t}\n\tif (r - l == 3)\n\t{\n\t\treturn min(min(dist(points[l], points[l + 1]), dist(points[l], points[l + 2])), dist(points[l + 1], points[l + 2]));\n\t}\n\n\tint m = (l + r) / 2;\n\tdouble d = min(ClosestPair(points, l, m), ClosestPair(points, m, r));\n\n\tvector<pdd> tempP;\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tif ((points[l].first - points[m].first)*(points[l].first - points[m].first) < d)\n\t\t{\n\t\t\ttempP.emplace_back(make_pair(points[i].second, points[i].first));\n\t\t}\n\t}\n\tsort(tempP.begin(), tempP.end());\n\tfor (int i = 0; i != tempP.size(); i++)\n\t{\n\t\tfor (int j = i + 1; j != tempP.size(); j++)\n\t\t{\n\t\t\tif ((tempP[j].first - tempP[i].first)*(tempP[j].first - tempP[i].first) > d)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, dist(tempP[i], tempP[j]));\n\t\t}\n\t}\n\n\treturn d;\n}\n\nvector<pdd> points;\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\t//cin >> x >> y;\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t\tpoints.push_back(make_pair(x, y));\n\t}\n\n\tsort(points.begin(), points.end());\n\n\tprintf(\"%lf\\n\", sqrt(ClosestPair(points, 0, n)));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 200000\npair<long double, long double>pa[MAX_N];\nlong double dist(long double ax, long double ay, long double bx, long double by) { \n\treturn sqrt((ax - bx)*(ax - bx) + (ay - by)*(ay - by));\n}\nint main() {\n\tint N; cin >> N; long double minx = 100.0L, maxx = -100.0L, miny = 100.0L, maxy = -100.0L;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> pa[i].first >> pa[i].second;\n\t\tminx = min(minx, pa[i].first);\n\t\tmaxx = max(maxx, pa[i].first);\n\t\tminx = min(minx, pa[i].second);\n\t\tmaxx = max(maxx, pa[i].second);\n\t}\n\tsort(pa, pa + N);\n\tlong double maxn = 100000;\n\tlong double G = (maxx - minx) / (sqrtl(N) - 1);\n\tlong double H = (maxy - miny) / (sqrtl(N) - 1);\n\tif (G < H) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlong double L = pa[i].first - G, R = pa[i].first + G;\n\t\t\tint pos1 = lower_bound(pa, pa + N, make_pair(L, -1000.0L)) - pa;\n\t\t\tint pos2 = lower_bound(pa, pa + N, make_pair(R, 1000.0L)) - pa;\n\t\t\tfor (int j = pos1; j < pos2; j++) {\n\t\t\t\tif (i == j) { continue; }\n\t\t\t\tmaxn = min(maxn, dist(pa[i].first, pa[i].second, pa[j].first, pa[j].second));\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tswap(pa[i].first, pa[i].second);\n\t\t}\n\t\tsort(pa, pa + N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlong double L = pa[i].first - H, R = pa[i].first + H;\n\t\t\tint pos1 = lower_bound(pa, pa + N, make_pair(L, -1000.0L)) - pa;\n\t\t\tint pos2 = lower_bound(pa, pa + N, make_pair(R, 1000.0L)) - pa;\n\t\t\tfor (int j = pos1; j < pos2; j++) {\n\t\t\t\tif (i == j) { continue; }\n\t\t\t\tmaxn = min(maxn, dist(pa[i].first, pa[i].second, pa[j].first, pa[j].second));\n\t\t\t}\n\t\t}\n\t}\n\tcout << fixed << setprecision(1919) << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tx = y = 0;\n\t}\n\tInfo(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn x < arg.x;\n\t};\n\tdouble x,y;\n};\n\nint N;\n\nbool compare_y(Info left,Info right){\n\treturn left.y < right.y;\n}\n\nInfo* info;\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2;\n\tdouble x = array[mid].x;\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid));\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y);\n\n\tvector<Info> V;\n\tfor(int i = 0; i < tmp_N; i++){\n\t\tif(fabs(array[i].x-x) >= dist)continue;\n\n\t\tfor(int j = 0; j < V.size();j++){\n\t\t\tdouble dx = array[i].x - V[V.size()-j-1].x;\n\t\t\tdouble dy = array[i].y - V[V.size()-j-1].y;\n\t\t\tif(dy >= dist)break;\n\t\t\tdist = min(dist,sqrt(dx*dx+dy*dy));\n\t\t}\n\t\tV.push_back(array[i]);\n\t}\n\treturn dist;\n}\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\tinfo = (Info*)malloc(sizeof(Info)*N);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf\",&info[i].x,&info[i].y);\n\t}\n\n\tsort(info,info+N);\n\n\tprintf(\"%.7lf\\n\",closest_pair(info,N));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @note   関連URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら5個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = limits::inf;\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) >= delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout.setf(ios::fixed);\n    cout.precision(8);\n    cout << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf dist ( pt A, pt B ) { return norm( B - A ); }\n\nint n;\npt P[ MAXN ], extra[ MAXN ];\nlf d;\n\nbool cmpX( const pt &A, const pt &B ) {\n  return A.x+EPS < B.x;\n}\n\nlf sqr( lf x ) {\n  return x*x;\n}\n\nvoid merge( int f, int m, int t ){\n\tint total = t - f + 1;\n\tfor( int i = 0, l = f, r = m+1; i < total; ++i ){\n\t\tif( l == m+1 ){\n      extra[ i ] = P[ r++ ];\n\t\t}\n\t\telse if( r == t+1 ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse if( P[l].y+EPS < P[r].y ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse{\n\t\t  extra[ i ] = P[ r++ ];\n\t\t}\n\t}\n\tfor( int i = 0; i < total; ++i ){\n    P[ f+i ] = extra[ i ];\n\t}\n}\n\nvoid solve( int f, int t ) {\n  if( f == t ) return;\n\tint mi = (f + t)/2;\n\tlf mx = P[ mi ].x;\n\tsolve( f, mi );\n  solve( mi+1, t );\n\tmerge( f, mi, t );\n\tvector< int > idxs;\n\tfor( int i = f; i <= t; ++i ){\n\t\tif( sqr(mx - P[i].x) < d+EPS ) idxs.push_back( i );\n\t}\n\tfor( int i = 0; i < idxs.size(); ++i ){\n\t\tfor( int j = i+1; j < idxs.size() && sqr(P[ idxs[i] ].y - P[ idxs[j] ].y) < d+EPS; ++j ){\n\t\t\td = min( d, dist( P[ idxs[i] ], P[ idxs[j] ] ) );\n\t\t}\n\t}\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"CGL_5_A-in25.txt\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  sort( P, P+n, cmpX );\n  d = oo;\n  solve( 0, n-1 );\n  cout << double( sqrt(d) ) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn 1e9;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP\n){\n\tint siz=xr-xl;\n\tint ypsiz=yP.size();\n\tif (siz <= 3) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tauto xM = xP[xl+siz/2].first;\n\tauto yL = std::vector<point_t>();\n\tyL.reserve(ypsiz/2);\n\tauto yR = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {\n\t\treturn p.first <= xM;\n\t});\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {\n\t\treturn p.first > xM;\n\t});\n\tauto p1 = find_closest_optimized(xP,xl,xl+siz/2, yL);\n\tauto p2 = find_closest_optimized(xP,xl+siz/2,xr, yR);\n\tauto minD = sqrt((p1 <= p2) ? p1 : p2);\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n, yP);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n\ntemplate <typename T>\nstruct Vector2D {        // Literal Class\n    T x, y;\n    explicit constexpr Vector2D() : x(0), y(0) {}\n    explicit constexpr Vector2D(T _x, T _y) : x(_x), y(_y) {}\n    const Vector2D operator + (const Vector2D& p) const { return Vector2D(x + p.x, y + p.y);}\n    const Vector2D operator - (const Vector2D& p) const { return Vector2D(x - p.x, y - p.y);}\n    Vector2D& operator *= (const T& p) { x *= p, y *= p; return *this;}\n    Vector2D& operator += (const T& p) { x += p, y += p; return *this;}\n    Vector2D& operator -= (const T& p) { x -= p, y -= p; return *this;}\n    Vector2D& operator /= (const T& p) { x /= p; y /= p; return *this;}\n    Vector2D& operator += (const Vector2D& p) { x += p.x, y += p.y; return *this;}\n    Vector2D& operator -= (const Vector2D& p) { x -= p.x, y -= p.y; return *this;}\n    const T dot(const Vector2D& q) { return x * q.x + y * q.y;}\n    const T norm() { return sqrt(x * x + y * y);}\n    friend std::ostream& operator<<(std::ostream& os, const Vector2D& p) { os << \"(\" << p.x << \", \" << p.y << \")\"; return os;}\n};\n\n#include <vector>\n#include <iomanip>\n#include <functional>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\nusing Pt = Vector2D<double>;\nconst double INF = 1e18;\nconst double EPS = 1.0e-11;\nbool eq(double a, double b) { return fabs(a - b) <= EPS;}\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n_;\n    cin >> n_;\n    vector<Pt> points(n_); // Points are 1 indexed\n    for(auto& p : points)\n        cin >> p.x >> p.y;\n    // x??§?¨???§?????????\n    sort(points.begin(), points.end(), [](const Pt& l, const Pt& r) {\n            return eq(l.x, r.x) ? l.y < r.y : l.x < r.x;\n        });\n    function<tuple<double, int, int>(int, int)> closest = [&](int id, int n) {\n        if(n <= 1) return make_tuple(INF, 0, 0);\n        int m = n / 2;\n        double boundX = points[id + m].x;\n        tuple<double, int, int> res = min(closest(id, m), closest(id + m, n - m));\n        auto fit = points.begin() + id;\n        inplace_merge(fit, fit + m, fit + n, [](const Pt& l, const Pt& r) {\n                return  eq(l.y, r.y) ? l.x < r.x : l.y < r.y;\n            });\n        vector<int> memo;\n        for(int i = id; i < id + n; ++i) {\n            if(fabs(boundX - points[i].x) >= get<0>(res)) continue;\n            for(int j = -1 + memo.size(); j >= 0; --j) {\n                Pt p = points[i] - points[memo[j]];\n                if(p.y >= get<0>(res)) break;\n                res = min(res, make_tuple(p.norm(), i, memo[j]));\n            }\n            memo.emplace_back(i);\n        }\n        return res;\n    };\n    cout << fixed << setprecision(10) << get<0>(closest(0, n_)) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x, double y) : x(x), y(y) {}\n    Point() {}\n};\nbool operator<(const Point &p1, const Point &p2) {\n    return (p1.x < p2.x) || (p1.x == p2.x && p1.y < p2.y);\n}\nbool compare_y(const Point &p1, const Point &p2) {\n    return p1.y < p2.y;\n}\n\ndouble ClosestPair(vector<Point>::iterator begin, vector<Point>::iterator end) {\n    const int n = end - begin;\n    if (n <= 1)\n        return numeric_limits<double>::max();\n    int m = n / 2;\n    double x = (begin + m)->x;\n    double d = min(ClosestPair(begin, begin + m), ClosestPair(begin + m, end));\n    inplace_merge(begin, begin + m, end, compare_y);\n\n    vector<Point> b;\n    for (auto it = begin; it != end; ++it) {\n        if (d <= abs(it->x - x))\n            continue;\n\n        for (size_t i = 0; i < b.size(); ++i) {\n            double dx = it->x - b[b.size() - i - 1].x;\n            double dy = it->y - b[b.size() - i - 1].y;\n            if (d <= dy)\n                break;\n            d = min(d, sqrt(dx * dx + dy * dy));\n        }\n        b.emplace_back(*it);\n    }\n\n    return d;\n}\n\ndouble Solve(vector<Point> &p) {\n    sort(p.begin(), p.end());\n    return ClosestPair(p.begin(), p.end());\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(15) << setiosflags(ios::fixed); // printf(\"%.4f\", x);\n\n    int n;\n\n    cin >> n;\n    vector<Point> p(n);\n    for (int i = 0; i < n; ++i)\n        cin >> p[i].x >> p[i].y;\n\n    cout << Solve(p) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pt pair<double,double>\n#define x first\n#define y second\nconst double INF=1e5;\npt p[100010];\ndouble dist(pt a,pt b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}\ndouble closest(int l,int r)\n{\n  if(l==r)return INF;\n  int mid=(l+r)/2,pp=l,qq=mid+1;\n  double midline=(p[mid].x+p[mid+1].x)/2.;\n  double ret=min(closest(l,mid),closest(mid+1,r));\n  vector<pt>merge,slab;\n  while(pp<=mid || qq<=r)\n    if(pp>mid) merge.push_back(p[qq++]);\n    else if(qq>r) merge.push_back(p[pp++]);\n    else merge.push_back(p[pp].y<p[qq].y?p[pp++]:p[qq++]);\n  pp=l;for(int i=0;i<merge.size();i++)p[pp++]=merge[i];\n  for(int i=l;i<=r;i++)\n    if(abs(p[i].x-midline)<ret)\n      slab.push_back(p[i]);\n  for(int i=0;i<slab.size();i++)\n    for(int j=i+1;j<slab.size() && abs(slab[j].y-slab[i].y)<ret;j++)\n      ret=min(ret,dist(slab[i],slab[j]));\n  return ret;\n}\nint main()\n{\n  int n;\n  cin>>n;\n  for(int i=1;i<=n;i++)\n    cin>>p[i].x>>p[i].y;\n  cout<<fixed<<closest(1,n)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ndouble x[110000];\ndouble y[110000];\npair<double,double> p[110000];\nint main()\n{\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)\n\t{\n\t\tdouble X,Y;\n\t\tscanf(\"%lf%lf\",&X,&Y);\n\t\tx[i]=cos(1)*X-sin(1)*Y;\n\t\ty[i]=sin(1)*X+cos(1)*Y;\n\t\tp[i]=make_pair(x[i],y[i]);\n\t}\n\tstd::sort(p,p+a);\n\tdouble ret=99999999;\n\tfor(int i=0;i<a;i++)\n\t{\n\t\tfor(int j=i-1;j>=0;j--)\n\t\t{\n\t\t\tif(p[i].first-p[j].first>ret)break;\n\t\t\tdouble fir = (p[i].first-p[j].first);\n\t\t\tdouble sec = (p[i].second-p[j].second);\n\t\t\tret=min(ret,sqrt(fir*fir + sec * sec));\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nstruct Point {\n    double x, y;\n    bool operator < (const Point& p) const {\n        if(x != p.x) return x < p.x;\n        return y < p.y;\n    }\n};\n\n\ndouble dist(double x, double y){\n    return sqrt(x * x + y * y);\n}\ndouble dist(Point p, Point q){\n    return dist(p.x - q.x, p.y - q.y);\n}\n\nint main(){\n    int N;\n    cin >> N;\n    vector<Point> ps(N);\n    //const double th = M_PI * (0.25 + 0.5 * rand() / RAND_MAX);\n    const double th = 0;\n    REP(i, N){\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        ps[i].x = +cos(th) * x + sin(th) * y;\n        ps[i].y = -sin(th) * x + cos(th) * y;\n    }\n    sort(ps.begin(), ps.end());\n    double ans = dist(ps[0], ps[1]);\n    for(int i = 0; i < N; i++){\n        for(int j = i + 1; j < N && ps[j].x - ps[i].x < ans; j++){\n            ans = min(ans, dist(ps[i], ps[j]));\n        }\n    }\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nld getdis(const pair<ld, ld>&l, const pair<ld, ld>&r) {\n\treturn sqrt((l.first - r.first)*(l.first - r.first) + (l.second - r.second)*(l.second - r.second));\n}\nld getans(vector<pair<ld, ld>>&ps) {\n\tif (ps.size() == 2) {\n\t\treturn getdis(ps[0], ps[1]);\n\t}\n\telse if (ps.size() <= 1) {\n\t\treturn 1e18;\n\t}\n\telse {\n\t\tint n = ps.size() / 2;\n\t\tld la = getans(vector<pair<ld, ld>>(ps.begin(), ps.begin() + ps.size() / 2));\n\t\tld ra = getans(vector<pair<ld, ld>>(ps.begin() + ps.size() / 2, ps.end()));\n\t\tld nans = min(la, ra);\n\t\tauto lit = lower_bound(ps.begin(), ps.end(), make_pair(ps[n].first - nans - 1, -1e18l));\n\t\tauto rit = upper_bound(ps.begin(), ps.end(), make_pair(ps[n].first + nans + 1,  1e18l));\n\t\tfor (auto a = lit; a != rit; ++a) {\n\t\t\tfor (auto b = next(a); b != rit; ++b) {\n\t\t\t\tnans = min(nans, getdis(*a, *b));\n\t\t\t}\n\t\t}\n\t\treturn nans;\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\tvector<pair<ld, ld>>ps;\n\tfor (int i = 0; i < N; ++i) {\n\t\tld x, y; cin >> x >> y;\n\t\tps.emplace_back(x, y);\n\t}\n\tsort(ps.begin(), ps.end());\n\tld ans = getans(ps);\n\tcout <<setprecision(22)<<fixed<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(__typeof((o).begin()) it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T> >& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){EACH(a,ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;EACH(p,m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\ntemplate<> long double INF<long double>(){return 1e16;};\n\ntemplate<typename T> T pmod(T v,T M){return (v%M+M)%M;}\n\nnamespace _double_tmpl{\n    typedef long double D;const D EPS = 1e-8;\n    \n    static constexpr D Ae=0;\n    D A(D a,D b){return a+b;}D Ainv(D a){return -a;}\n    D S(D a,D b){return A(a,Ainv(b));}\n    \n    static constexpr D Me=1;\n    D M(D a,D b){return a*b;}D Minv(D a){return 1.0/a;};\n\n    int sig(D a,D b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n    bool eq(D a,D b){ return sig(abs(a-b))==0;}\n\n}\nusing namespace _double_tmpl;\n\n\nnamespace Ps{\n    // using namespace _double_tmpl;\n    typedef complex<D> P,Vec;\n\n#define X real()\n#define Y imag()\n    istream& operator >> (istream& is,complex<D>& p){\n        D x,y;is >> x >> y;p=P(x,y);return is;\n    }\n\n    bool eq(P a,P b){return eq(a.X,b.X) and eq(a.Y,b.Y);}\n    // a×b\n    D cross(const Vec& a,const Vec& b){return imag(conj(a)*b);}\n    // a・b\n    D dot(const Vec&a,const Vec& b) {return real(conj(a)*b);}\n\n    int ccw(const P& a,P b,P c){\n        b -= a; c -= a;\n        if (cross(b,c) > EPS)   return +1;       // counter clockwise\n        if (cross(b,c) < -EPS)   return -1;       // clockwise\n        if (dot(b,c) < 0)     return +2;       // c--a--b on line\n        if (norm(b) < norm(c)) return -2;       // a--b--c on line\n        return 0;\n    }\n\n    bool compX (const P& a,const P& b);bool compY (const P& a,const P& b);\n    D closestPair(vector<P>& ps,int l,int r){\n        if(r-l<2)return INF<D>();\n        D res=INF<D>();res=min(res,closestPair(ps,l,(l+r)/2));res=min(res,closestPair(ps,(l+r)/2,r));\n        \n        vector<P> ips;\n        FOR(i,l,r)if(abs(ps[i].X - ps[(l+r)/2].X)<res)ips.push_back(ps[i]);\n        sort(ALL(ips),compY);        \n        REP(i,ips.size())for(int j=i-10;j<i;j++)if(j>=0){\n            res=min(res,abs(ips[i]-ips[j]));\n        }\n        return res;\n    }\n    bool compY (const P& a,const P& b){return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;}\n}\nusing namespace Ps;\n\nnamespace std{\n\n    bool compX (const P& a,const P& b){return a.X != b.X ? a.X < b.X : a.Y < b.Y;}\n    bool compY (const P& a,const P& b){return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;}\n    bool operator < (const P& a,const P& b){return compX(a,b);}\n    bool operator == (const P& a,const P& b){return eq(a,b);}\n};\n\nstringstream ss;\nclass Main{\n    public:\n    void run(){\n        int n;cin >> n;\n        vector<P> ps;\n        REP(i,n) {\n            P p;cin >> p;\n            ps.push_back(p);\n        }\n        sort(ALL(ps));\n        cout << closestPair(ps,0,n)<<endl;\n    }\n};\n\nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct node{\n  int dim;\n  vector<double>v;\n};\n\ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n\ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n\n  vector<node>res;\n\n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n\n    double dist=d(p,S)/(4*p.dim);\n\n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n\n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    if(S.size() == nextS.size())break;\n    S=nextS;    \n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n  \n  return ans;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n\n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_N 100000\nconst double INF = 1e50;\n \ntypedef pair<double,double> P;\n \nint N;\nP A[MAX_N]; \n \nbool compare_y(const P &a,const P &b){\n  return a.second < b.second;\n}\n  \ndouble closest_pair(P *a, int n){\n  if(n <= 1) return INF;\n  int m = n / 2;\n  double x = a[m].first;\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<P> b;\n  for(int i=0;i<n;i++){\n      if(fabs(a[i].first - x) >= d) continue;\n      for(int j=0;j<b.size();j++){\n          double dx = a[i].first - b[b.size() - j - 1].first;\n          double dy = a[i].second - b[b.size() - j - 1].second;\n          if(dy >= d) break;\n          d = min(d, sqrt(dx * dx + dy * dy));\n      }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n \nvoid solve(){\n  sort(A,A+N);\n  printf(\"%.8f\\n\",closest_pair(A,N));\n}\n \nint main(){\n  cin >> N;\n  for(int i = 0 ; i < N ; i++){\n    scanf(\"%lf%lf\",&A[i].first,&A[i].second);\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n// 最近点対問題を解く(O(nlogn))\n/*\n点を x 座標, y 座標によって左半分と右半分に分けるとする。\n最近点対の距離は、1), 2) の最小値\n1) 2点 p, q が共に左半分または右半分に含まれるような組(p, q)の距離\n\n2) 2点 p, q が異なる領域に含まれるような組(p, q)の距離\n点を左半分と右半分に分ける直線を l として、その直線の x 座標を l として、\nx_0 - d < x < x_0 + d を満たす(x_p, y_p) に対して y_p - d < y <= y_p を満たす点との\n距離を考えればよい\n*/\n\n// first を x 座標, second を y 座標とする\ntypedef pair<double, double> PD;\n\nconst double INF = 1000000000;\nconst int MAX_N = 100010;\n\npair<double, double> A[MAX_N];\n\n// y 座標の昇順で merge するための比較関数\nbool compare_y(PD a, PD b){\n    return a.second < b.second;\n}\n\n// a は x 座標の昇順\ndouble closest_pair(PD *a, int n){\n    if(n <= 1) return INF;\n    int m = n / 2;\n    double x = a[m].first;\n    // 1) にあたる\n    double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n    inplace_merge(a, a + m, a + n, compare_y); // sorted な 2 つの範囲を merge\n    // ここで a は　y 座標の昇順\n\n    // 2) にあたる\n    vector<PD> b; // 直線から距離 d 未満の頂点\n    for(int i=0;i<n;i++){\n        if(fabs(a[i].first - x) >= d) continue;\n\n        // b に入っている頂点を、末尾から y 座標の差が d 以上になるまで見ていく\n        for(int j=0;j<b.size();j++){\n            double dx = a[i].first - b[b.size() - j - 1].first;\n            double dy = a[i].second - b[b.size() - j - 1].second;\n            if(dy >= d) break;\n            d = min(d, sqrt(dx * dx + dy * dy));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int N; cin >> N;\n    for(int i=0;i<N;i++){\n        double x, y; cin >> x >> y;\n        A[i] = make_pair(x, y);\n    }\n    sort(A, A + N);\n    cout << fixed << setprecision(15) << closest_pair(A, N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = limits::inf;\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) >= delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    printf(\".8f\\n\", closest_pair(P));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        double distance_ = (p1[i + 1].first - p1[i].first) * (p1[i + 1].first - p1[i].first) + (p1[i + 1].second - p1[i].second) * (p1[i + 1].second - p1[i].second);\n        \n        sqr_ans = min(distance_, sqr_ans);\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        double distance_ = (p2[i + 1].first - p2[i].first) * (p2[i + 1].first - p2[i].first) + (p2[i + 1].second - p2[i].second) * (p2[i + 1].second - p2[i].second);\n        \n        sqr_ans = min(distance_, sqr_ans);\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<iostream>\n#include<set>\n#include<map>\n#define re register\n#define ll long long\nusing namespace std;\ninline int gi(){\n    int f=1,sum=0;char ch=getchar();\n    while(ch>'9'|| ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n    return sum*f;\n}\nconst double eps=1e-10,Pi=acos(-1.0);\nstruct node{\n    double x,y;\n    node operator+(node b){return (node){x+b.x,y+b.y};}\n    node operator-(node b){return (node){x-b.x,y-b.y};}\n    node operator*(double b){return (node){x*b,y*b};}\n    double len(){return sqrt(x*x+y*y);}\n};\nint fh(double a){return fabs(a)<eps?0:a>eps?1:-1;}\nnode corner(node a,double B){return (node){a.x*cos(B)-a.y*sin(B),a.y*cos(B)+a.x*sin(B)};}\ndouble cross(node a,node b){return a.x*b.y-a.y*b.x;}\ndouble dot(node a,node b){return a.x*b.x+a.y*b.y;}\ndouble distance(node a,node b){return (a-b).len();}\nnode projection(node p1,node p2,node p){node v=p2-p1;return p1+v*(dot(v,p-p1)/dot(v,v));}\nnode reflection(node p1,node p2,node p){node P=projection(p1,p2,p);P=P*2-p;return P;}\nvoid Counter_Clockwise(node p1,node p2,node p){\n    if(cross(p2-p1,p-p1)>eps){puts(\"COUNTER_CLOCKWISE\");return;}\n    if(cross(p2-p1,p-p1)<-eps){puts(\"CLOCKWISE\");return;}\n    if(dot(p2-p1,p-p1)<-eps){puts(\"ONLINE_BACK\");return;}\n    if(dot(p2-p1,p2-p1)>=dot(p-p1,p2-p1)){puts(\"ON_SEGMENT\");return;}\n    puts(\"ONLINE_FRONT\");\n}\nbool insegment(node A,node B,node p){\n    if(fh(cross(B-A,p-A)))return false;\n    return ((fh(p.x-A.x)>=0 && fh(B.x-p.x)>=0) || (fh(p.x-A.x)<=0 && fh(B.x-p.x)<=0)) && ((fh(p.y-A.y)>=0 && fh(B.y-p.y)>=0) || (fh(p.y-A.y)<=0 && fh(B.y-p.y)<=0));\n}\nint parallel(node A1,node A2,node B1,node B2){\n    if(!fh(cross(B2-B1,A2-A1)))return 2;\n    if(!fh(dot(B2-B1,A2-A1)))return 1;\n    return 0;\n}\nbool intersection(node A1,node A2,node B1,node B2){\n    if(!fh(cross(B2-B1,A2-A1))){\n        if(insegment(A1,A2,B1) || insegment(A1,A2,B2) || insegment(B1,B2,A1) || insegment(B1,B2,A2))return true;\n        return false;\n    }\n    return fh(cross(A1-B1,B2-B1)*cross(A2-B1,B2-B1))<=0 && (fh(cross(B1-A1,A2-A1)*cross(B2-A1,A2-A1))<=0);\n}\nnode getintersection(node A1,node A2,node B1,node B2){\n    node v=A2-A1;\n    return A1+v*(cross(B2-B1,B1-A1)/cross(B2-B1,A2-A1));\n}\ndouble distance(node A1,node A2,node B1,node B2){\n    if(intersection(A1,A2,B1,B2))return 0.0;\n    node p;double ans=1e18;\n    ans=min(ans,(A1-B1).len());ans=min(ans,(A1-B2).len());ans=min(ans,(A2-B1).len());ans=min(ans,(A2-B2).len());\n    p=projection(A1,A2,B1);\n    if(insegment(A1,A2,p))ans=min(ans,(B1-p).len());\n    p=projection(A1,A2,B2);\n    if(insegment(A1,A2,p))ans=min(ans,(B2-p).len());\n    p=projection(B1,B2,A1);\n    if(insegment(B1,B2,p))ans=min(ans,(A1-p).len());\n    p=projection(B1,B2,A2);\n    if(insegment(B1,B2,p))ans=min(ans,(A2-p).len());\n    return ans;\n}\ndouble area(node *p,int n){\n    double area=0;\n    for(int i=1;i<n;i++){\n\t\tarea+=cross(p[i],p[i+1]);\n\t}\n    area+=cross(p[n],p[1]);\n    return area*0.5;\n}\nbool is_convex(node *p,int n){\n    for(int i=2;i<n;i++)if(cross(p[i]-p[i-1],p[i+1]-p[i-1])<0)return false;\n    if(cross(p[n]-p[n-1],p[1]-p[n-1])<0)return false;\n    if(cross(p[1]-p[n],p[2]-p[n])<0)return false;\n    return true;\n}\nint inConvex(node O,node *p,int n){\n    int cnt=0;\n    for(int i=0;i<n;i++){\n        if(insegment(p[i],p[(i+1)%n],O))return 1;\n        node A=p[i]-O,B=p[(i+1)%n]-O;\n        if(A.y>B.y)swap(A,B);\n        if(A.y<eps && B.y>eps && cross(A,B)>eps)cnt++;\n    }\n    return cnt&1?2:0;\n}\nbool cmp(node a,node b){return a.y<b.y || (!fh(a.y-b.y) && a.x<b.x);}\nbool cmp1(node a,node b){return a.x<b.x || (!fh(a.x-b.x) && a.y<b.y);}\nbool cmp2(node a,node b){return atan2(a.y,a.x)<atan2(b.y,b.x) || (!fh(atan2(a.y,a.x)-atan2(b.y,b.x)) && a.x>b.x);}\ndouble Diameter(node *p,int n){\n    int id=1;double ans=0;\n    for(int i=0;i<n;i++){\n        node p1=p[i],p2=p[(i+1)%n];\n        for(int nxt=(id+1)%n;fh(fabs(cross(p[nxt]-p1,p2-p1))-fabs(cross(p[id]-p1,p2-p1)))>=0;id=nxt,nxt=(nxt+1)%n);\n        ans=max(ans,max((p[id]-p1).len(),(p[id]-p2).len()));\n    }\n    return ans;\n}\ndouble cutarea(node *p,int n,node A1,node A2){\n\tnode c[200010];int tot=0;\n\tfor(int i=0;i<n;i++){\n\t\tnode p1=p[i],p2=p[(i+1)%n];\n\t\tnode P=getintersection(p1,p2,A1,A2);\n\t\tif(insegment(p1,p2,P))c[++tot]=P;\n\t\tif(cross(A2-A1,p2-A1)>-eps)c[++tot]=p2;\n\t}\n\treturn area(c,tot);\n}\ndouble Closest_Pair(node *p,int n){\n\tdouble ang=(rand()%360+1)*1./360*Pi/2,ans=1e18;\n\tfor(int i=1;i<=n;i++)p[i]=corner(p[i],ang);\n\tsort(p+1,p+n+1,cmp1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=200 && i+j<=n;j++)\n\t\t\tans=min(ans,distance(p[i],p[i+j]));\n\treturn ans;\n}\nnode p[400010];int n;\nint main(){\n    n=gi();\n\tfor(int i=1;i<=n;i++)scanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\tprintf(\"%.10lf\\n\",Closest_Pair(p,n));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(200, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(200, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + 1].first - p2[i].first) * (p2[i + 1].first - p2[i].first) + (p2[i + 1].second - p2[i].second) * (p2[i + 1].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\n\n\npii topii(const P &p, double d){\n\treturn pii(real(p) / d, imag(p) / d);\n}\n\n\nint main(){\n\tsrand(time(0));\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tdouble x, y;\n\tvector<P> v(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t\tv[i] = P(x + 100.0, y + 100.0);\n\t}\n\trandom_shuffle(v.begin(), v.end());\n\n\tdouble ans = 500.0;\n\tmap<pii,vector<int> > mp;\n\tmap<pii,vector<int> >::iterator it;\n\tfor(int i = 0; i < n; ++i){\n\t\tdouble mdis = ans;\n\n\t\tpii p = topii(v[i], ans);\n\t\tfor(int dy = -1; dy <= 1; ++dy)\n\t\tfor(int dx = -1; dx <= 1; ++dx){\n\t\t\tit = mp.find(pii(p.first + dy, p.second + dx));\n\t\t\tif(it != mp.end()){\n\t\t\t\tfor(int j = it->second.size(); j--; ){\n\t\t\t\t\tint k = it->second[j];\n\t\t\t\t\tmdis = min(mdis, abs(v[i] - v[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(mdis < ans){\n\t\t\tans = mdis;\n\t\t\tmp.clear();\n\t\t\tfor(int j = 0; j < i; ++j){\n\t\t\t\tmp[topii(v[j], ans)].push_back(j);\n\t\t\t}\n\t\t}\n\t\tmp[topii(v[i], ans)].push_back(i);\n\t}\n\t\n\tprintf(\"%.8f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\n//定義系\n\ndouble EPS = 1e-10;\n\n//誤差を考慮して足し算を行う\ndouble add(double a, double b) {\n\tif (abs(a + b) < EPS*(abs(a) + abs(b)))return 0;\n\treturn a + b;\n}\n\n//Point\nstruct Point {\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {\n\t}\n\tPoint operator + (Point p) {\n\t\treturn Point(add(x, p.x), add(y, p.y));\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(add(x, -p.x), add(y, -p.y));\n\t}\n\tPoint operator * (double d) {\n\t\treturn Point(x*d, y*d);\n\t}\n\tPoint operator / (double d) {\n\t\treturn Point(x / d, y / d);\n\t}\n\t//内積\n\tdouble dot(Point p) {\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\t//外積\n\tdouble det(Point p) {\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\t//点の大小比較\n\tbool operator <(const Point &p)const {\n\t\tif (fabs(add(x, -p.x)) < EPS)return y < p.y;\n\t\treturn x < p.x;\n\t}\n\tbool operator ==(const Point &p)const {\n\t\treturn fabs(x - p.x) < EPS&&fabs(y - p.y) < EPS;\n\t}\n};\n\n//ベクトル。使い分けるといいかも\ntypedef Point Vector;\n\n//ベクトルの大きさの2乗\ndouble norm(Vector p) {\n\treturn p.x*p.x + p.y*p.y;\n}\n\n//ベクトルの大きさ\ndouble abs(Vector p) {\n\treturn sqrt(norm(p));\n}\n\n//線分\nstruct Segment {\n\tPoint p1, p2;\n};\n\n//直線\ntypedef Segment Line;\n\n//中心c,半径rの円\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\n\n//多角形\ntypedef vector<Point> Polygon;\n\n//頂点集合\ntypedef vector<Point> Points;\n\n\n\n\n//計算・アルゴリズム系\n\n\n//反時計回りCCW\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (a.det(b) > EPS)return COUNTER_CLOCKWISE;\n\tif (a.det(b) < -EPS)return CLOCKWISE;\n\tif (a.dot(b) < -EPS)return ONLINE_BACK;\n\tif (norm(a) < norm(b))return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\n//線分p1p2と線分p3p4の交差判定\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//ベクトルa,bの直交判定\nbool isOrthogonal(Vector a, Vector b) {\n\treturn a.dot(b) == 0.0;\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2) {\n\treturn (s1.p2 - s1.p1).dot(s2.p2 - s2.p1) == 0.0;\n}\n\n//ベクトルa,bの並行判定\nbool isParallel(Vector a, Vector b) {\n\treturn a.det(b) == 0.0;\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2) {\n\treturn (s1.p2 - s1.p1).det(s2.p2 - s2.p1) == 0.0;\n}\n\n//射影(点p1と点p2を通る直線に点pから垂線を引いた交点xを求める)\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = (p - s.p1).dot(base) / norm(base);\n\treturn s.p1 + base*r;\n}\n\n//反射(点p1と点p2を通る直線を対象軸として点pと線対称の位置にある点xを求める)\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p)*2.0;\n}\n\n//点aと点bの距離\ndouble getDistance(Point a, Point b) {\n\treturn abs(a - b);\n}\n\n//直線lと点pの距離\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs((l.p2 - l.p1).det(p - l.p1) / abs(l.p2 - l.p1));\n}\n\n//線分sと点pの距離\ndouble getDistanceSP(Segment s, Point p) {\n\tif ((s.p2 - s.p1).dot(p - s.p1) < 0.0)return abs(p - s.p1);\n\tif ((s.p1 - s.p2).dot(p - s.p2) < 0.0)return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\n//線分s1と線分s2の距離\ndouble getDistance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn min({ getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2) });\n}\n\n//線分s1と線分s2の交点\nPoint getCrossPoint(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(base.det(s1.p1 - s2.p1));\n\tdouble d2 = abs(base.det(s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\n//円cと線分lの交点\npair<Point, Point>getCrossPoints(Circle c, Line l) {\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r*c.r - norm(pr - c.c));\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r)*a, sin(r)*a); }\npair<Point, Point>getCrossPoints(Circle c1, Circle c2) {\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//点の内包 0:in,1:on,2:out\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(a.det(b)) < EPS&&a.dot(b) < EPS) return 1;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS < b.y&&EPS < a.det(b))x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\n//凸包を求める\nPolygon convex_hull(Polygon s, bool on_seg) {\n\tPolygon u, l;\n\tif (s.size() < 3) {\n\t\treturn s;\n\t}\n\tsort(s.begin(), s.end());//x,yを基準に昇順ソート\n\n\t\t\t\t\t\t\t //xが小さいものから2つuに追加\n\tu.emplace_back(s[0]);\n\tu.emplace_back(s[1]);\n\t//xが大きいものから2つlに追加\n\tl.emplace_back(s[s.size() - 1]);\n\tl.emplace_back(s[s.size() - 2]);\n\n\tif (on_seg) {\n\n\t\t//凸包の上部を生成\n\t\tfor (int i = 2; i < s.size(); i++) {\n\t\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) == COUNTER_CLOCKWISE; n--) {\n\t\t\t\tu.pop_back();\n\t\t\t}\n\t\t\tu.emplace_back(s[i]);\n\t\t}\n\n\t\t//凸包の下部を生成\n\t\tfor (int i = s.size() - 3; i >= 0; i--) {\n\t\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) == COUNTER_CLOCKWISE; n--) {\n\t\t\t\tl.pop_back();\n\t\t\t}\n\t\t\tl.emplace_back(s[i]);\n\t\t}\n\t}\n\telse {\n\t\t//凸包の上部を生成\n\t\tfor (int i = 2; i < s.size(); i++) {\n\t\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE; n--) {\n\t\t\t\tu.pop_back();\n\t\t\t}\n\t\t\tu.emplace_back(s[i]);\n\t\t}\n\n\t\t//凸包の下部を生成\n\t\tfor (int i = s.size() - 3; i >= 0; i--) {\n\t\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE; n--) {\n\t\t\t\tl.pop_back();\n\t\t\t}\n\t\t\tl.emplace_back(s[i]);\n\t\t}\n\t}\n\t//時計回りになるように凸包の点の列を生成\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) {\n\t\tl.push_back(u[i]);\n\t}\n\treturn l;\n}\n\n//y座標の昇順でマージするための比較関数\nbool compare_y(Point a, Point b) {\n\treturn a.y < b.y;\n}\n\n//aはx座標の昇順で渡される\ndouble closest_pair(Point *a, int n) {\n\tif (n <= 1)return INF<double>();\n\tsort(a, a + n);\n\tint m = n / 2;\n\tdouble x = a[m].x;\n\tdouble d = min({ closest_pair(a,m),closest_pair(a + m,n - m) });//p,qが違う区間にある\n\tinplace_merge(a, a + m, a + n, compare_y);//2つのソートされた列をマージ\n\n\t//p,qが同じ区間にある\n\tPoints b;//直線から距離d未満の頂点を入れていく\n\tfor (int i = 0; i < n; i++) {\n\t\tif (add(fabs(add(a[i].x, -x)), -d) >= 0.0)continue;\n\n\t\t//bに入っている頂点を、末尾からy座標の差がd以上になるまで見ていく\n\t\tfor (int j = 0; j < b.size(); j++) {\n\t\t\tPoint dd;\n\t\t\tdd.x = add(a[i].x, -b[b.size() - j - 1].x);\n\t\t\tdd.y = add(a[i].y, -b[b.size() - j - 1].y);\n\t\t\tif (add(dd.y, -d) >= 0.0)break;\n\t\t\td = min(d, abs(dd));\n\t\t}\n\t\tb.emplace_back(a[i]);\n\t}\n\treturn d;\n}\nint n;\nPoint p[101010];\n\nint main() {\n\tcin >> n;\n\tREP(i, n) {\n\t\tcin >> p[i].x >> p[i].y;\n\t}\n\tcout << fixed << setprecision(13) << closest_pair(p, n) << endl;\n\t//system(\"pause\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100000\n#define INF 1e9\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x = 0,double y = 0):x(x),y(y){}\n  bool operator < (const Point a)const{\n    return x != a.x ? x < a.x : y < a.y;\n  }\n};\n\nint N;\nPoint A[MAX_N]; \n\nbool compare_y(Point a,Point b){\n  return a.y < b.y;\n}\n \ndouble closest_pair(Point *a,int n){\n  if(n <= 1) return INF;\n  int m = n / 2;\n  double x = a[m].x;\n  double d = min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n \n  vector<Point> b;\n  for(int i = 0 ; i < n ; i++){\n    if(fabs(a[i].x - x >= d)) continue;\n    for(int j = 0 ; j < (int)b.size() ; j++){\n      double dx = a[i].x - b[b.size()-j-1].x;\n      double dy = a[i].y - b[b.size()-j-1].y;\n      if(dy >= d) break;\n      d = min(d,sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nvoid solve(){\n  sort(A,A+N);\n  printf(\"%.8f\\n\",closest_pair(A,N));\n}\n\nint main(){\n  cin >> N;\n  for(int i = 0 ; i < N ; i++){\n    cin >> A[i].x >> A[i].y;\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\n\nint main(void)\n{\n    double temp=1000.0;\n    int n;\n    double x[1000],y[1000];\n\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>x[i]>>y[i];\n    \n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            if(i!=j)\n            {\n                if(temp > x[i]-x[j]+y[i]-y[j])\n                    temp = x[i]-x[j]+y[i]-y[j];\n            }\n        }\n    }\n    \n\n    printf(\"%lf\\n\",sqrt(temp*temp));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst double eps=1e-9;\nstruct dot{\n\tdouble x,y;\n\tdouble len(){return sqrt(x*x+y*y);}\n\tdot(double a=0.0,double b=0.0){x=a,y=b;}\n\tdot operator +(const dot&b)const {return dot(x+b.x,y+b.y);}\n\tdot operator -(const dot&b)const {return dot(x-b.x,y-b.y);}\n\tdot operator *(const double&z)const {return dot(x*z,y*z);}\n\tbool operator <(const dot&b)const {return (y<b.y)||(y==b.y&&x<b.x);}\n\tbool operator ==(const dot&b)const {return fabs(x-b.x)<eps&&fabs(y-b.y)<eps;}\t\n\tbool operator !=(const dot&b)const {return fabs(x-b.x)>=eps||fabs(y-b.y)>=eps;}\n\tvoid read(){scanf(\"%lf%lf\",&x,&y);} \n};\nstruct line{\n\tdot x1,x2;\n\tvoid read(){x1.read();x2.read();};\n\tline(dot a=dot(0.0,0.0),dot b=dot(0.0,0.0)){x1=a,x2=b;} \n\tdot getdot(){return x2-x1;}\n};\ndouble chaji(dot x,dot y){\n\treturn x.x*y.y-x.y*y.x;\n}\ndouble neiji(dot x,dot y){\n\treturn x.x*y.x+x.y*y.y;\n}\ndouble cos(dot x,dot y){\n\tif (!x.len()||!y.len())return 0;\n\treturn neiji(x,y)/x.len()/y.len();\n}\ndot Projection(dot x,line y){//求x关于直线y的投影点（垂足） \n\ty.x2=y.x2-y.x1;\n\tx=x-y.x1;\n\tdouble len=cos(x,y.x2)*x.len()/y.x2.len();\n\ty.x2=y.x2*len;\n\treturn y.x2+y.x1;\n}\ndot Reflection(dot x,line y){//求x关于直线y的对称点 \n\tdot z=Projection(x,y);\n\treturn z*2-x;\n}\nint Counter_Clockwise(dot x,line y){//求两个向量的五种关系 \n\tx=x-y.x1;y.x2=y.x2-y.x1;\n\tif (chaji(y.x2,x)!=0){\n\t\tif (chaji(y.x2,x)>0)return 1;\n\t\treturn 2;\n\t} \n\tif (fabs(cos(x,y.x2)+1)<eps)return 3;\n\tif (x.len()>y.x2.len())return 4;\n\treturn 5;\n} \nint Parallel_Orthogonal(line x,line y){//求两个直线是垂直还是平行还是其他 \n\tdot a=x.getdot(),b=y.getdot();\n\tif (chaji(a,b)==0)return 2;\n\tif (neiji(a,b)==0)return 1;\n\treturn 0;\n}\nint Intersection(line x,line y){//求两条线段是否相交 \n\tint Minx1=min(x.x1.x,x.x2.x),Maxx1=max(x.x1.x,x.x2.x);\n\tint Minx2=min(y.x1.x,y.x2.x),Maxx2=max(y.x1.x,y.x2.x);\n\tint Miny1=min(x.x1.y,x.x2.y),Maxy1=max(x.x1.y,x.x2.y);\n\tint Miny2=min(y.x1.y,y.x2.y),Maxy2=max(y.x1.y,y.x2.y);\n\tif (Minx1>Maxx2||Minx2>Maxx1)return 0;\n\tif (Miny1>Maxy2||Miny2>Maxy1)return 0;\n\tif (chaji(x.getdot(),y.x1-x.x1)*chaji(x.getdot(),y.x2-x.x1)>0)return 0;\n\tif (chaji(y.getdot(),x.x1-y.x1)*chaji(y.getdot(),x.x2-y.x1)>0)return 0;\n\treturn 1;\n}\nint Intersection2(line x,line y){//求线段和直线是否相交 \n\tif (chaji(y.getdot(),x.x1-y.x1)*chaji(y.getdot(),x.x2-y.x1)>0)return 0;\n\treturn 1;\n}\ndot CrossPoint(line x,line y){//求两条线段的交点 \n\tif (fabs(cos(x.getdot(),y.getdot())-1)<eps||fabs(cos(x.getdot(),y.getdot())+1)<eps){\n\t\tif (x.x1<x.x2)swap(x.x1,x.x2);\n\t\tif (y.x1<y.x2)swap(y.x1,y.x2);\n\t\tif (x.x2<y.x2)return y.x2;\n\t\telse return x.x2;\n\t}\n\telse {\n\t\tif (x.x2.x-x.x1.x==0){\n\t\t\tdouble k2=(y.x2.y-y.x1.y)/(y.x2.x-y.x1.x),b2=y.x2.y-y.x2.x*k2;\n\t\t\treturn dot(x.x2.x,x.x2.x*k2+b2);\n\t\t}\n\t\tif (y.x2.x-y.x1.x==0){\n\t\t\tdouble k1=(x.x2.y-x.x1.y)/(x.x2.x-x.x1.x),b1=x.x2.y-x.x2.x*k1;\n\t\t\treturn dot(y.x2.x,y.x2.x*k1+b1);\t\t\t\n\t\t}\n\t\tdouble k1=(x.x2.y-x.x1.y)/(x.x2.x-x.x1.x),b1=x.x2.y-x.x2.x*k1;\n\t\tdouble k2=(y.x2.y-y.x1.y)/(y.x2.x-y.x1.x),b2=y.x2.y-y.x2.x*k2;\n\t\tdot ans;\n\t\tans.x=(b2-b1)/(k1-k2);ans.y=ans.x*k1+b1;\n\t\treturn ans;\n\t}\n} \ndouble Dis(dot x,dot y){//点到点的距离 \n\treturn sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));\n}\ndouble dist(line x,dot y){//点到线段的距离 \n\tdot P=Projection(y,x);\n\tdouble k=neiji(x.getdot(),P-x.x1)/neiji(x.getdot(),x.getdot());\n\tif (k<=0)return Dis(x.x1,y);\n\tif (k>=1)return Dis(x.x2,y);\n\treturn Dis(y,P);\n}\ndouble Distance(line x,line y){//线段之间距离 \n\treturn min(min(dist(x,y.x1),dist(x,y.x2)),min(dist(y,x.x1),dist(y,x.x2)));\n}\nstruct polygon{\n\tvector<dot > A;\n\tdouble S(){//多边形面积\n\t\tdouble ans=0;\n\t\tfor (int i=0;i+1<A.size();i++)ans+=chaji(A[i],A[i+1])/2;\n\t\tif (A.size()>1)ans+=chaji(A[A.size()-1],A[0])/2;\n\t\treturn ans;\t\t\n\t}\n\tdouble C(){//多边形周长 \n\t\tdouble ans=0;\n\t\tfor (int i=0;i+1<A.size();i++)ans+=Dis(A[i],A[i+1]);\n\t\tif (A.size()>1)ans+=Dis(A[A.size()-1],A[0]);\n\t\treturn ans;\n\t}\n\tvoid read(){\n\t\tint n;scanf(\"%d\",&n);A.resize(n);\n\t\tfor (int i=0;i<n;i++)A[i].read();\n\t}\n\tint Is_Convex(){//是否是凸多边形 \n\t\tfor (int i=0;i<A.size();i++)\n\t\t\tif (chaji(A[(i+1)%A.size()]-A[i],A[(i+2)%A.size()]-A[(i+1)%A.size()])<0)\n\t\t\t\treturn 0;\n\t\treturn 1;\n\t}\n}G;\nint PolygonPointContainment(polygon G,dot x){//射线和多边形的关系\n\tfor (int i=0;i<G.A.size();i++)\n\t\tif (Counter_Clockwise(x,line(G.A[i],G.A[(i+1)%G.A.size()]))==5)return 1;\n\tfor (int i=0;i<G.A.size();i++)\n\t\tif (x==G.A[i])return 1;\n\tdouble k=sqrt(2)+1,b=x.y-x.x*k;\n\tdot x2=dot(-1000000000,-1000000000*k+b);line R=line(x,x2);\n\tint ans=0;\n\tfor (int i=0;i<G.A.size();i++)\n\t\tif (Intersection(R,line(G.A[i],G.A[(i+1)%G.A.size()])))ans++;\n\tif (ans&1)return 2;\n\treturn 0;\t\n}\nint isclock(dot x,dot y,dot z){//是否顺时针 \n\treturn chaji(z-x,y-x)<0;\n}\npolygon Convex_Hull(polygon G){//求凸包 \n\tpolygon ans1,ans2;\n\tsort(G.A.begin(),G.A.end());\n\tans1.A.push_back(G.A[0]);ans1.A.push_back(G.A[1]);\n\tfor (int i=2;i<G.A.size();i++){\n\t\twhile (ans1.A.size()>=2&&isclock(ans1.A[ans1.A.size()-2],ans1.A[ans1.A.size()-1],G.A[i]))\n\t\t\tans1.A.pop_back();\n\t\tans1.A.push_back(G.A[i]);\t\n\t}\n\tans2.A.push_back(G.A[G.A.size()-1]);ans2.A.push_back(G.A[G.A.size()-2]);\n\tfor (int i=G.A.size()-3;i>=0;i--){\n\t\twhile (ans2.A.size()>=2&&isclock(ans2.A[ans2.A.size()-2],ans2.A[ans2.A.size()-1],G.A[i]))\n\t\t\tans2.A.pop_back();\n\t\tans2.A.push_back(G.A[i]);\t\t\n\t}\n\tfor (int i=1;i<ans2.A.size()-1;i++)ans1.A.push_back(ans2.A[i]);\n\treturn ans1;\n}\ndouble DiameterofaConvexPolygon(polygon G){//求直径 \n\tint l=0,r=1,flag=1;\n\tdouble ans=Dis(G.A[0],G.A[1]);\n\twhile (l!=0||flag){\n\t\tflag=0;\n\t\twhile (Dis(G.A[l],G.A[r])<=Dis(G.A[l],G.A[(r+1)%G.A.size()])){\n\t\t\tr=(r+1)%G.A.size();\n\t\t\tans=max(ans,Dis(G.A[l],G.A[r]));\n\t\t}\n\t\tl=(l+1)%G.A.size();\n\t\tans=max(ans,Dis(G.A[l],G.A[r]));\n\t}\n\treturn ans;\n}\ndouble Convex_Cut(polygon G,line x){//求多边形在线的左边的部分 \n\tpolygon ans;line y=x;\n\tfor (int i=0;i<G.A.size();i++){\n\t\tif (chaji(y.x2-y.x1,G.A[i]-y.x1)>=0)ans.A.push_back(G.A[i]);\n\t\tif (Intersection2(line(G.A[i],G.A[(i+1)%G.A.size()]),y))\n\t\t\tans.A.push_back(CrossPoint(line(G.A[i],G.A[(i+1)%G.A.size()]),y));\t\n\t}\n\treturn ans.S();\n}\nint cmp2(int x,int y){\n\treturn G.A[x]<G.A[y];\n}\ndouble ClosestPair(int l,int r){//求平面最近点对 \n    double d=1e20;vector<int > ans;\n    if (l==r)return d;\n    if (l+1==r)return Dis(G.A[l],G.A[r]);\n    int mid=(l+r)/2; \n    double d1=ClosestPair(l,mid),d2=ClosestPair(mid+1,r);\n    d=min(d1,d2);\n    for (int i=l;i<=r;i++)\n        if (fabs(G.A[mid].x-G.A[i].x)<=d)ans.push_back(i);\n    sort(ans.begin(),ans.end(),cmp2);\n    for (int i=0;i<ans.size();i++)\n        for (int j=i+1;j<ans.size()&&G.A[ans[j]].y-G.A[ans[i]].y<d;j++)\n\t\t\td=min(d,Dis(G.A[ans[i]],G.A[ans[j]]));\n    return d;\n}\nint cmp(dot x,dot y){\n\treturn x.x<y.x||(x.x==y.x&&x.y<y.y);\n}\nint main(){\n\tG.read();\n\tsort(G.A.begin(),G.A.end(),cmp);\n    printf(\"%.10lf\\n\",ClosestPair(0,G.A.size()-1));\n  \treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\ntypedef complex<double> P;\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n};\ntypedef vector<P> Polygon;\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\n// ??????\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\n// ????¬?????????????2??????\ndouble norm(const P& a) {\n    return real(conj(a)*a);\n}\n\n// ??????\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\n// ???p2?????????p0, p1???????????´???????°???±?????????\nP projection(const P& p0, const P& p1, const P& p2) {\n    // ???????????????????????´???\n    P vec1 = p1 - p0;\n    P vec2 = p2 - p0;\n    return p0 + vec1 * dot(vec1, vec2) / dot(vec1, vec1);\n}\n\n// projection?????\\??¨???\n// not verified\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\n// ???p0, p1???????????´??????????§°?????¨????????????p2??¨????§°??????\nP reflection(const P& p0, const P& p1, const P& p2) {\n    P proj = projection(p0, p1, p2);\n    return proj - (p2 - proj);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;                               // a--c--b on line\n}\n\n// 2??´?????????????????????\nbool is_parallel(const L& l1, const L& l2) {\n    P p1 = l1[1] - l1[0];\n    P p2 = l2[1] - l2[0];\n    auto res = ccw(p1, p2, P(0,0));\n    return (res == 2 || res == -2 || res == 0);\n}\n\n// 2??´???????????´?????????\nbool is_ortho(const L& l1, const L& l2) {\n    P p1 = l1[1] - l1[0];\n    P p2 = l2[1] - l2[0];\n    return dot(p1, p2) == 0;\n}\n\n// l: line(??´???)\n// s: segment(??????)\n// not verified\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\n// not verified\nbool intersectLS(const L &l, const L &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n        cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\n\n// not verified\nbool intersectLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\n// not verified\nbool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n// not verified\ndouble distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\n// not verified\ndouble distanceLL(const L &l, const L &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\n// not verified\ndouble distanceLS(const L &l, const L &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n\ndouble distanceSP(const L &s, const P &p) {\n    const P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n               min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n// 2??´????????????\nP crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n}\n\n// ????§???¢?????¢???????±???????\n// P???????????¨???????????????\ndouble convexArea(const Polygon& poly) {\n    double area = 0.0;\n    REP(i, SIZE(poly))\n        area += cross(curr(poly, i), next(poly, i));\n    return abs(area) * 0.5;\n}\n\n// ??????????±??????????????????????????????????????????????\n// ????????????????¨?????????§????????????\n// not verified\nPolygon convexHull(const Polygon& poly) {\n    Polygon ps = poly;\n\n    int n = ps.size(), k = 0;\n    sort(ALL(ps));\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\n// ??????????±????????????????????????????????????????????????????\n// ????????????????¨?????????§????????????\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=jp\nPolygon convexHullInludingPointsOnEdge(const Polygon& poly) {\n    Polygon ps = poly;\n\n    int n = ps.size(), k = 0;\n    sort(ALL(ps));\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\n// ?????§??????\n// poly?????????????¨???¨?????§?????????????´?????????????????????¨???????????????\n// ???????????´??????????????¶???????¨±???\nbool isConvex(const Polygon &poly) {\n    REP(i, SIZE(poly)) {\n        if (ccw(prev(poly, i), curr(poly, i), next(poly, i)) == -1)\n            return false;\n    }\n    return true;\n}\n\n// poly????????§???????????¨?????????\n// 0: OUT\n// 1: ON\n// 2: IN\n// not verified\nenum { OUT, ON, IN };\nint convexContains(const Polygon &poly, const P &p) {\n    const int n = poly.size();\n    P g = (poly[0] + poly[n/3] + poly[2*n/3]) / 3.0; // inner-P\n    int a = 0, b = n;\n    while (a+1 < b) { // invariant: c is in fan g-poly[a]-poly[b]\n        int c = (a + b) / 2;\n        if (cross(poly[a]-g, poly[c]-g) > 0) { // angle < 180 deg\n            if (cross(poly[a]-g, p-g) > 0 && cross(poly[c]-g, p-g) < 0) b = c;\n            else                                                  a = c;\n        } else {\n            if (cross(poly[a]-g, p-g) < 0 && cross(poly[c]-g, p-g) > 0) a = c;\n            else                                                  b = c;\n        }\n    }\n    b %= n;\n    if (cross(poly[a] - p, poly[b] - p) < 0) return OUT;\n    if (cross(poly[a] - p, poly[b] - p) > 0) return IN;\n    return ON;\n}\n\n// poly????????§???????????????\n// 0: OUT\n// 1: ON\n// 2: IN\nint contains(const Polygon& poly, const P& p) {\n    bool in = false;\n    REP(i, SIZE(poly)) {\n        P a = curr(poly,i) - p, b = next(poly,i) - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b))\n            if (cross(a, b) < 0) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\n\n// ????§???¢?????´?????????2???????????????\n// ??\\????????????????????§?????????????????????\ndouble convexDiameterSquared(const Polygon &poly) {\n    const int n = poly.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(poly[i]) > imag(poly[is])) is = i;\n        if (imag(poly[i]) < imag(poly[js])) js = i;\n    }\n    double maxd = norm(poly[is]-poly[js]);\n\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n        if (cross(diff(poly,i), diff(poly,j)) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (norm(poly[i]-poly[j]) > maxd) {\n            maxd = norm(poly[i]-poly[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd; /* farthest pair is (maxi, maxj). */\n}\n\n// ???????§???¢?????????\n// ???????§???¢???????????´?????§???????????????????????´????????????\nPolygon convexCut(const Polygon& p, const L& l) {\n    Polygon Q;\n    REP(i, SIZE(p)) {\n        P A = curr(p, i);\n        P B = next(p, i);\n        if (ccw(l[0], l[1], A) != -1)\n            Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspoint(L(A, B), l));\n    }\n    return Q;\n}\n\npair<P,P> closestPair(vector<P> p) {\n    int n = p.size(), s = 0, t = 1, m = 2, S[n]; S[0] = 0, S[1] = 1;\n    sort(ALL(p)); // \"p < q\" <=> \"p.x < q.x\"\n    double d = norm(p[s]-p[t]);\n    for (int i = 2; i < n; S[m++] = i++) REP(j, m) {\n            if (norm(p[S[j]]-p[i])<d) d = norm(p[s = S[j]]-p[t = i]);\n            if (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n        }\n    return make_pair( p[s], p[t] );\n}\n\nint main(){\n    int N;\n    cin >> N;\n    vector<P> points;\n    REP(n, N) {\n        double x, y;\n        cin >> x >> y;\n        points.pb( P(x,y) );\n    }\n\n    auto res = closestPair(points);\n    printf(\"%.10lf\\n\", sqrt(norm(res.first - res.second)));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<climits>\nusing namespace std;\n\nconst int INF = INT_MAX/100;\nconst int dmax = 100000;\n\nint main(){\n\t\n\tint V,E,s,t,cost;\n\tcin >> V >> E;\n\t\n\tint A[V][V];\n\t\n\tfor (int i=0;i<V;i++){\n\t\tfor (int j=0;j<V;j++){\n\t\t\tA[i][j]=INF;\n\t\t}\n\t}\n\t\n\tfor (int i=0;i<E;i++){\n\t\tcin >>  s >> t >> cost;\n\t\tA[s][t]=cost;\n\t}\n\t\n\tint d[V][V][V];\n\t\n\tfor (int i=0;i<V;i++){\n\t\tfor (int j=0;j<V;j++){\n\t\t\tif(i!=j){\n\t\t\t\td[i][j][0]=min(A[i][j],A[i][0]+A[0][j]);\n\t\t\t}else{\n\t\t\t\td[i][j][0]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int k=1;k<V;k++){\n\t\tfor (int i=0;i<V;i++){\n\t\t\tfor (int j=0;j<V;j++){\n\t\t\t\td[i][j][k]=min(d[i][j][k-1],d[i][k][k-1]+d[k][j][k-1]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i=0;i<V;i++){\n\t\tfor (int j=0;j<V;j++){\n\t\t\tif(d[i][j][V-1]>dmax){\n\t\t\t\tcout << \"INF\";\n\t\t\t}else{\n\t\t\t\tcout << d[i][j][V-1];\n\t\t\t}\n\t\t\tif(j!=V-1){\n\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <functional>\n#include <bitset>\n#include <deque>\n#include <cmath>\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\n \n#define rep(i, a, b) for(int i = a; i <= b; ++i)\n#define dow(i, a, b) for(int i = a; i >= b; --i)\n#define mem(a) memset(a, 0, sizeof(a))\n#define mst(a, b) memset(a, b, sizeof(a))\n#define sfi(a) scanf(\"%d\", &a)\n#define sfl(a) scanf(\"%lld\", &a)\n#define sfd(a) scanf(\"%lf\", &a)\n#define sfs(a) scanf(\"%s\", a)\n#define pb(a) push_back(a)\n#define sync ios::sync_with_stdio(0); cin.tie(0);\n \nconst int MAXN = 1000 + 5;\nconst double EPS = 1e-6;\nconst double PI = acos(-1.0);\n \ntypedef struct Point Point;\ntypedef struct Line Line;\ntypedef struct Polygon Polygon;\ntypedef struct Polygon_convex Polygon_convex;\n \nint cmp(double x);\ndouble sqr(double x);\ndouble det(Point a, Point b);\ndouble dot(Point a, Point b);\ndouble dist(Point a, Point b);\nPoint rotate_point(Point p, double A);\nbool parallel(Line a, Line b);\nbool orthogonal(Line a, Line b);\nPoint PointProjLine(Point p, Line l, Point &ans);\nPoint reflect(Line l, Point p);\ndouble dis_point_segment(Point p, Line l);\ndouble dis_segment_segment(Line a, Line b);\nLine point_make_line(Point a, Point b);\nbool in_segment(Line l, Point p);\nint dcmp(double k);\ndouble mysqrt(double n);\nPoint rotate(Point p, double cost, double sint);\npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br);\nbool PointOnSegment(Point p, Point s, Point t);\nbool comp_less(Point a, Point b);\nPolygon_convex convex_hull(vector<Point> a);\ndouble convex_diameter(Polygon_convex a, int &First, int &Second);\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \nstruct Point\n{\n    double x, y;\n    Point() {}\n    Point(double a, double b): x(a), y(b) {}\n \n    friend Point operator -(Point a, Point b)\n    {\n        return Point(a.x-b.x,a.y-b.y);\n    }\n    friend Point operator +(Point a, Point b)\n    {\n        return Point(a.x+b.x,a.y+b.y);\n    }\n    friend bool operator ==(Point a, Point b)\n    {\n        return cmp(a.x-b.x)==0 && cmp(a.y-b.y)==0;\n    }\n    friend Point operator *(Point a, double b)\n    {\n        return Point(a.x*b,a.y*b);\n    }\n    friend Point operator *(double a, Point b)\n    {\n        return Point(a*b.x,a*b.y);\n    }\n    friend Point operator /(Point a, double b)\n    {\n        return Point(a.x/b,a.y/b);\n    }\n    double norm()\n    {\n        return sqrt(sqr(x)+sqr(y));\n    }\n};\n \nstruct Line\n{\n    Point a, b;\n    Line() {}\n    Line(Point x, Point y): a(x), b(y) {}\n};\n \nstruct Polygon\n{\n    int n;\n    Point a[80050];\n    Polygon() {}\n    double perimeter()\n    {\n\t\tdouble sum = 0;\n\t\ta[n] = a[0];\n\t\trep(i, 0, n - 1)\n\t\t\tsum += (a[i+1]-a[i]).norm();\n\t\treturn sum;\n\t}\n    int Point_In(Point t)\n    {\n        int num = 0;\n        a[n] = a[0];\n        rep(i, 0, n - 1)\n        {\n            if(PointOnSegment(t, a[i], a[i + 1]))\n                return 2;\n            int k = cmp(det(a[i + 1] - a[i], t - a[i]));\n            int d1 = cmp(a[i].y - t.y);\n            int d2 = cmp(a[i + 1].y - t.y);\n            if(k > 0 && d1 <= 0 && d2 > 0)\n                num++;\n            if(k < 0 && d2 <= 0 && d1 > 0)\n                num--;\n        }\n        return num != 0;\n    }\n};\n \nstruct Polygon_convex\n{\n    vector<Point> P;\n    Polygon_convex(int Size = 0)\n    {\n        P.resize(Size);\n    }\n};\n\nbool comp_less(Point a, Point b)\n{\n    return cmp(a.x-b.x)<0 || cmp(a.x-b.x)==0 && cmp(a.y-b.y)<0;\n}\n\nPolygon_convex convex_hull(vector<Point> a)\n{\n\tPolygon_convex res(2*a.size()+5);\n    sort(a.begin(), a.end(), comp_less);\n    a.erase(unique(a.begin(), a.end()), a.end());\n    int m = 0;\n    int len = a.size();\n    rep(i, 0, len - 1)\n    {\n        while(m>1&&cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<=0)\n            --m;\n        res.P[m++] = a[i];\n    }\n    int k = m;\n    len = a.size();\n    dow(i, len - 2, 0)\n    {\n        while(m>k && cmp(det(res.P[m-1]-res.P[m-2],a[i]-res.P[m-2]))<=0)\n            --m;\n        res.P[m++] = a[i];\n    }\n    res.P.resize(m);\n    if(a.size()>1)\n        res.P.resize(m-1);\n       return res;\n}\nbool PointOnSegment(Point p, Point s, Point t)\n{\n    return cmp(det(p-s,t-s)) == 0 && cmp(dot(p-s,p-t))<=0;\n}\nbool parallel(Line a, Line b)\n{\n    return !cmp(det(a.a-a.b,b.a-b.b));\n}   \nbool orthogonal(Line a, Line b)\n{\n    return !cmp(dot(a.a - a.b, b.a - b.b));\n}\nPoint PointProjLine(Point p, Line l)\n{\n    Point ans;\n    double r = dot((l.b-l.a),(p-l.a))/dot(l.b-l.a,l.b-l.a);\n    ans = l.a + r*(l.b-l.a);\n    return ans;\n}\nint cmp(double x)\n{\n    if(abs(x) < EPS)\n        return 0;\n    if(x > 0)\n        return 1;\n    return -1;\n}\ndouble dis_point_segment(Point p, Line l)\n{\n    if(cmp(dot(p-l.a,l.b-l.a))<0)\n        return (p-l.a).norm();\n    if(cmp(dot(p-l.b,l.a-l.b))<0)\n        return (p-l.b).norm();\n    return abs(det(l.a-p,l.b-p))/dist(l.a,l.b);\n}\nbool line_make_point(Line a, Line b, Point &res)\n{\n    if(parallel(a,b))\n        return false;\n    double s1 = det(a.a-b.a,b.b-b.a);\n    double s2 = det(a.b-b.a,b.b-b.a);\n    res = (s1*a.b-s2*a.a)/(s1-s2);\n    return true;\n}\ndouble dis_segment_segment(Line a, Line b)\n{\n    Point res;\n    if(line_make_point(a, b, res) && in_segment(a, res) && in_segment(b, res))\n        return 0.;\n    return min(min(dis_point_segment(b.a, a), dis_point_segment(b.b, a)), min(dis_point_segment(a.a, b), dis_point_segment(a.b, b)));\n}\ndouble sqr(double x)\n{\n    return x * x;\n}\ndouble det(Point a, Point b)\n{\n    return a.x*b.y-a.y*b.x;\n}\ndouble dot(Point a, Point b)\n{\n    return a.x*b.x+a.y*b.y;\n}\ndouble dist(Point a, Point b)\n{\n    return (a-b).norm();\n}\nPoint rotate_point(Point p, double A)\n{\n    double tx = p.x, ty = p.y;\n    return Point(tx*cos(A)-ty*sin(A),tx*sin(A)+ty*cos(A));\n}\nPoint reflect(Line l, Point p)\n{\n    return p + ((PointProjLine(p, l) - p) * 2.0);\n}\nbool in_segment(Line l, Point p)\n{\n    bool fa = false, fb = false;\n    if((cmp(p.x-l.a.x) != -1 && cmp(p.x-l.b.x) != 1) || (cmp(p.x-l.a.x) != 1 && cmp(p.x-l.b.x) != -1))\n        fa = true;\n    if((cmp(p.y-l.a.y) != -1 && cmp(p.y-l.b.y) != 1) || (cmp(p.y-l.a.y) != 1 && cmp(p.y-l.b.y) != -1))\n        fb = true;\n    return fa && fb;\n}\nint dcmp(double k)\n{\n    return k < -EPS ? -1 : k > EPS ? 1 : 0;\n}\ndouble mysqrt(double n)\n{\n    return sqrt(max(0.0, n));\n}\nvoid circle_cross_line(Point a, Point b, Point o, double r, Point ret[], int &num)\n{\n    double x0 = o.x, y0 = o.y;\n    double x1 = a.x, y1 = a.y;\n    double x2 = b.x, y2 = b.y;\n    double dx = x2 - x1, dy = y2 - y1;\n    double A = dx*dx+dy*dy;\n    double B = 2*dx*(x1-x0)+2*dy*(y1-y0);\n    double C = sqr(x1-x0)+sqr(y1-y0)-sqr(r);\n    double delta = B*B-4*A*C;\n    num = 0;\n    if(dcmp(delta) >= 0)\n    {\n        double t1 = (-B - mysqrt(delta)) / (2*A);\n        double t2 = (-B + mysqrt(delta)) / (2*A);\n        ret[num++] = Point(x1 + t1*dx, y1 + t1*dy);\n        ret[num++] = Point(x1 + t2*dx, y1 + t2*dy);\n    }\n     \n}\nPoint rotate(Point p, double cost, double sint)\n{\n    double x = p.x, y = p.y;\n    return Point(x*cost - y*sint, x*sint + y*cost);\n}\npair<Point, Point> crosspoint(Point ap, double ar, Point bp, double br)\n{\n    double d = (ap - bp).norm();\n    double cost = (ar*ar + d*d - br*br) / (2*ar*d);\n    double sint = sqrt(1. - cost*cost);\n    Point v = (bp - ap) / (bp - ap).norm() * ar;\n    return make_pair(ap+rotate(v,cost,-sint),ap+rotate(v,cost,sint));\n}\n\ndouble convex_diameter(Polygon_convex a, int &First, int &Second)\n{\n\tvector<Point> &p = a.P;\n\tint n = p.size();\n\tdouble maxd = 0.0;\n\tif(n == 1)\n\t{\n\t\tFirst = Second = 0;\n\t\treturn maxd;\n\t}\n\t#define next(i) ((i+1)%n)\n\tfor(int i = 0, j = 1; i < n; ++i)\n\t{\n\t\twhile(cmp(det(p[next(i)]-p[i],p[j]-p[i])-det(p[next(i)]-p[i],p[next(j)]-p[i]))<0)\n\t\t\tj = next(j);\n\t\tdouble d = dist(p[i], p[j]);\n\t\tif(d > maxd)\n\t\t{\n\t\t\tmaxd = d;\n\t\t\tFirst = i, Second = j;\n\t\t}\n\t\td = dist(p[next(i)],p[next(j)]);\n\t\tif(d > maxd)\n\t\t{\n\t\t\tmaxd = d;\n\t\t\tFirst = i, Second = j;\n\t\t}\n\t}\n\treturn maxd;\n}\n\nconst int L = 2;\nconst LL MOD = 100000 + 50;\nconst int MAX = 100000 + 50;\n\n\nPoint a[MAX];\nint n, s[MAX];\n\nbool cmpx(int i, int j)\n{\n\treturn cmp(a[i].x-a[j].x)<0;\n}\n\nbool cmpy(int i, int j)\n{\n\treturn cmp(a[i].y-a[j].y)<0;\n}\n\ndouble min_dist(Point a[], int s[], int l, int r)\n{\n\tdouble ans = 1e100;\n\tif(r-l<20)\n\t{\n\t\trep(q, l, r - 1)\n\t\t\trep(w, q + 1, r - 1)\n\t\t\t\tans = min(ans, (a[s[q]]-a[s[w]]).norm());\n\t\treturn ans;\n\t}\n\tint tl, tr, m = (l+r)/2;\n\tans = min(min_dist(a, s, l, m), min_dist(a, s, m, r));\n\tfor(tl = l; a[s[tl]].x < a[s[m]].x - ans; tl++);\n\tfor(tr = r - 1; a[s[tr]].x > a[s[m]].x + ans; tr--);\n\tsort(s + tl, s + tr, cmpy);\n\trep(q, tl, tr - 1)\n\t\trep(w, q + 1, min(tr, q + 6) - 1)\n\t\t\tans = min(ans, (a[s[q]] - a[s[w]]).norm());\n\tsort(s + tl, s + tr, cmpx);\n\treturn ans;\n}\n\ndouble Min_Dist(Point a[], int s[], int n)\n{\n\trep(i, 0, n - 1)\n\t\ts[i] = i;\n\tsort(s, s + n, cmpx);\n\treturn min_dist(a, s, 0, n);\n}\n\nint main()\n{   \n#ifdef LOCAL\n    //~ freopen(\"in.txt\", \"r\", stdin);\n#endif\n \n\tsfi(n);\n\trep(i, 0, n - 1)\n\t{\n\t\tscanf(\"%lf%lf\", &a[i].x, &a[i].y);\n\t}\n\n\tprintf(\"%.10lf\\n\", Min_Dist(a, s, n));\n\t\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 100001\nusing namespace std;\n\ntypedef pair<double,double> P;\nconst int INF=1000000000;\nint n;\nP v[MAX];\n \nbool compare_y(P a, P b) {\n  return a.second < b.second;\n}\n \ndouble closest_pair(P *a, int n) {\n  if(n<=1) return INF;\n  int m=n/2;\n  double x=a[m].first;\n  double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n  vector<P> b;\n  for(int i=0; i<n; i++) {\n    if(fabs(a[i].first-x)>=d) continue;\n    for(int j=0; j<b.size(); j++) {\n      double dx=a[i].first-b[b.size()-1-j].first;\n      double dy=a[i].second-b[b.size()-1-j].second;\n      if(dy>=d) break;\n      d=min(d, sqrt(dx*dx+dy*dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main() {\n  cin >> n;\n  for(int i=0; i<n; i++) {\n    double x,y;\n    cin >> x >> y;\n    v[i]=P(x,y);\n  }\n  sort(v,v+n);\n  double ans=closest_pair(v,n);\n  printf(\"%.10f\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\ndouble x[1000000],y[1000000],z=100000;\nint main(){\n\tlong long int n,i,j;\n\tcin>>n;\n\tfor(i=0;i<n;i++)\n\t\tcin>>x[i]>>y[i];\n\tfor(i=0;i<(n-1);i++)\n\tfor(i=0;i<n;i++)\n\t\tfor(j=i+1;j<n;j++){\n\t\t\tdouble s;\n\t\t\ts=sqrt(pow((x[i]-x[j]),2)+pow((y[i]-y[j]),2));\n\t\t\tif(z>s) z=s;\n\t\t}\n\tstd::cout<<setprecision(12)<<z<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return norm( B - A ); }\n\nint n;\nlf d;\npt Px[ MAXN ];\nvector< pt> Py;\n\nbool cmpX( const pt &A, const pt &B ) {\n  return B.x > A.x + EPS;\n}\n\nbool cmpY( const pt &A, const pt &B ) {\n  return B.y > A.y + EPS;\n}\n\nlf minimum( const lf &A, const lf &B ) {\n  if( A+EPS < B ) return A;\n  return B;\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\nvoid merge( const vector<pt> &P, int n ) {\n  for( int i = 0; i < n; ++i ) {\n    for( int j = i+1; j < n && (P[j].y - P[i].y)*(P[j].y - P[i].y) + EPS < d ; ++j ) {\n      d = minimum( d, dist( P[i], P[j]) );\n    }\n  }\n}\n\nvoid solve( pt *Px, vector<pt> &Py, int n ) {\n  if( n <= 3 ) {\n    for( int i = 0; i < n; ++i ) {\n      for( int j = i+1; j < n; ++j ) {\n        d = minimum( d, dist(Px[i], Px[j]) );\n      }\n    }\n    return;\n  }\n  int mi = n/2;\n  vector<pt> Pl, Pr;\n  for( int i = 0; i < n; ++i ) {\n    if( SIZE(Pr) == mi && same( Py[i].x, Px[mi].x ) ) {\n      Pl.PB( Py[ i ] );\n    }\n    else if( SIZE(Pl) == mi && same( Py[i].x, Px[mi].x ) ) {\n      Pr.PB( Py[ i ] );\n    }\n    else if( Py[i].x+EPS < Px[mi].x ) {\n      Pl.PB( Py[ i ] );\n    }\n    else {\n      Pr.PB( Py[ i ] );\n    }\n  }\n\n  solve( Px, Pl, SIZE( Pl ) );\n  solve( Px+SIZE( Pl ), Pr, SIZE( Pr ) );\n\n  vector<pt> extra;\n  for( auto &p : Py ) {\n    if( ( p.x - Px[mi].x )*( p.x - Px[mi].x ) + EPS < d ) {\n      extra.PB( p );\n    }\n  }\n\n  merge( extra, SIZE( extra ) );\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> Px[i];\n    Py.PB( Px[ i ] );\n  }\n  sort( Px, Px+n, cmpX );\n  sort( Py.begin(), Py.end(), cmpY );\n  d = oo;\n  solve( Px, Py, n );\n  cout << double(sqrt(d)) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int int64;\nconst double EPS = 1e-8, PI = acos(-1);\ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\n  \nstruct Geometory { // Geometory Library\n  struct Point {\n    double x, y;\n    Point(){};\n    Point(double x,double y):x(x),y(y){};\n    Point operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n    Point operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n    Point operator*(const double b) const { return Point(x * b,y * b); }\n    Point operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n    Point operator/(const double b) const { return Point(x / b,y / b); }\n    bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y;}\n    bool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n    double norm(){ return x * x + y * y; }\n    double arg(){ return atan2(x,y); }\n    double abs(){ return sqrt(norm()); }\n    Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n    Point rotate90(){ return Point(-y,x); }\n    friend ostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\n    friend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n  };\n  \n  struct Line {\n    Point a, b;\n    Line(){};\n    Line(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Line& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Line& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Segment {\n    Point a, b;\n    Segment(){};\n    Segment(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Segment& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Segment& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Circle {\n    Point p; double r;\n    Circle(){};\n    Circle(Point p, double r) : p(p),r(r){};\n  };\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n  \n  double cross(const Point& a,const Point& b){\n    return a.x * b.y - a.y * b.x;\n  }\n  double dot(const Point& a,const Point& b){\n    return a.x * b.x + a.y * b.y;\n  }\n  \n  int ccw(const Point& a,Point b,Point c){\n    b = b - a, c = c - a;\n    if(cross(b,c) > EPS)    return +1;  // a → b で 反時計方向におれて c\n    if(cross(b,c) < -EPS)    return -1; // a → b で 時計方向におれて c\n    if(dot(b,c) < 0)      return +2;  // c -- a -- bで一直線上\n    if(b.norm() < c.norm()) return -2; // a -- b -- cで一直線上\n    return 0;  // a -- c -- bで一直線上\n  }\n  Point Projection(const Line& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Projection(const Segment& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Reflection(const Line& l, const Point& p){\n    return p + (Projection( l, p) - p) * 2.0;\n  }\n  \n  double Distance( const Line& l,const Point& p) { //OK\n    return (p - Projection( l, p)).abs();\n  }\n  \n  bool Intersect(const Line& l, const Line& m){\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;\n  }\n  bool Intersect(const Line& l, const Segment& s){\n    return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;\n  }\n  bool Intersect(const Line& l, const Point& p){\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n  bool Intersect(const Segment& s, const Segment& t){\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n  bool Intersect(const Segment& s, const Point& p){\n    return ccw(s.a, s.b, p) == 0;\n  }\n  bool Intersect(const Circle& c,const Line& l){\n    return Distance( l, c.p) <= c.r + EPS;\n  }\n  bool Intersect(const Circle& c,const Point& p){\n    return abs( ( p - c.p).abs() - c.r ) < EPS;\n  }\n  int Intersect(const Circle& c, const Segment& l){\n    if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();\n    if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if( d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n    const Point h = Projection( l, c.p);\n    if( dot( l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n  bool Intersect(const Circle& a,const Circle& b){\n    return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n      ( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n  }\n  double Distance(const Segment& s,const Point& p){\n    Point r = Projection(s, p);\n    if ( Intersect( s, r)) return ( r - p).abs();\n    return min( ( s.a - p).abs(), ( s.b - p).abs());\n  }\n  double Distance(const Segment& a,const Segment& b){\n    if(Intersect( a, b)) return 0;\n    return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));\n  }\n  double Distance(const Line& l,const Line& m) {\n    return Intersect( l, m) ? 0 : Distance( l, m.a);\n  }\n  double Distance(const Line& l,const Segment& s) { //OK\n    if (Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n  double Distance(const Point& a,const Point& b){ //OK\n    return ( a - b).abs();\n  }\n  Point Crosspoint(const Segment& l,const Segment& m) { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n  PointPoint Crosspoint(const Circle& c,const Line l){\n    Point hp = Projection( l, c.p), h =  hp - c.p;\n    const double d2 = h.norm();\n    Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n  PointPoint Crosspoint(const Circle& c,const Segment& l) {\n    Line aa = Line( l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n  PointPoint Crosspoint(const Circle& c1,const Circle& c2){ //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n    double h = 2 * S / d;\n    Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();\n    double m = sqrt( c1.r * c1.r - h * h);\n    return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);\n  }\n  bool parallel(const Line& a,const Line& b){\n    return abs(cross( a.b - a.a, b.b - b.a)) < EPS;\n  }\n  bool orthogonal(const Line& a,const Line& b){\n    return abs(dot( a.a - a.b, b.a - b.b)) < EPS;\n  }\n  int Contains(const Polygon& Q,const Point& p){\n    bool in = false;\n    for(int i = 0 ; i < Q.size() ; i++ ){\n      Point a = curr(Q,i) - p, b = next(Q,i) - p;\n      if(a.y > b.y) swap(a,b);\n      if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;\n      if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n  bool Contains(const Circle& c,const Point& p){\n    return ( c.p - p).abs() < c.r + EPS;\n  }\n  double Area2(const Polygon& p){ //OK\n    double A = 0;\n    for (int i = 0; i < p.size(); ++i){\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n  bool IsConvex(const Polygon& p){\n    for(int i = 0; i < p.size(); i++){\n      if(ccw(prev(p,i),curr(p,i),next(p,i)) == -1) return false;\n    }\n    return true;\n  }\n  Polygon Convex_Hull(Polygon& p){\n    int n = p.size(), k = 0;\n    if(n >= 3){\n      sort( p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]){\n        while(k >= 2 && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]){\n        while(k >= t && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize( k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n  double Convex_Diameter(Polygon& p){\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = ( p[is] - p[js]).norm();\n\n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross( next( p, i) - curr( p, i), next( p, j) - curr( p, j)) >= 0){\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if(( p[i] - p[j]).norm() > maxdis){\n        maxdis = ( p[i] - p[j]).norm();\n        maxi = i; maxj = j;\n      }\n    }  while (i != is || j != js);\n    return maxdis;\n  }\n\n  PointPoint ClosestPair(Polygon p){\n    int n = p.size(), s = 0, t = 1, m = 2, S[n];\n    S[0] = 0, S[1] = 1;\n\n    sort(p.begin(), p.end());\n    double d = (p[s] - p[t]).norm();\n    for(int i = 2; i < n; S[m++] = i++){\n      for(int j = 0; j < m; j++){\n        if((p[S[j]] - p[i]).norm() < d) d = (p[s = S[j]] - p[t = i]).norm();\n        if(p[S[j]].x < p[i].x - d) S[j--] = S[--m];\n      }\n    }\n    return make_pair( p[s], p[t]);\n  }\n};\n\nGeometory geo;\ntypedef Geometory::Point P;\ntypedef Geometory::Line L;\ntypedef Geometory::Segment S;\ntypedef Geometory::Circle C;\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n  Geometory::Polygon g(n);\n  for(int i = 0; i < n; i++){\n    scanf(\"%lf %lf\", &g[i].x, &g[i].y);\n  }\n  Geometory::PointPoint p = geo.ClosestPair(g);\n\n  cout << fixed << setprecision(10) << (p.first-p.second).abs() << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m-1, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n\n    two_dimensional_qsort(p_xy+n0, 0, n-1-n0, 1);\n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        cout<<\"\";\n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<< ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\n  typedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\n  namespace std {\n    bool operator < (const P& a, const P& b) {//x????????????\n      return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool sorty(const P& a, const P& b) {//y????????????\n      return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n    }\n  }\n  double cross(const P& a, const P& b) {//??????\n    return imag(conj(a)*b);\n  }\n  double dot(const P& a, const P& b) {//??????\n    return real(conj(a)*b);\n  }\n\npair<P,P> closestPair(vector<P> &p) {\n  int n = p.size(), s = 0, t = 1, m = 2;\n  int S[n];\n  S[0] = 0, S[1] = 1;\n  sort(all(p)); // \"p < q\" <=> \"p.x < q.x\"\n  double d = norm(p[s]-p[t]);\n  for (int i = 2; i < n; S[m++] = i++) rep(j, m) {\n    if (norm(p[S[j]]-p[i])<d) d = norm(p[s = S[j]]-p[t = i]);\n    if (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n  }\n  return make_pair( p[s], p[t] );\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  cin >>n;\n  double x,y;\n  vector<P> ps(n);\n  rep(i,n){\n    cin >> x >> y;\n    ps[i] = P(x,y);\n  }\n  auto cp = closestPair(ps);\n  fcout(10) << abs(cp.fi-cp.se) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ntypedef vector<P> G;\n\npair<P,P> closestPair(G p) {\n  int n = p.size(), s = 0, t = 1, m = 2, S[n]; S[0] = 0, S[1] = 1;\n  SORT(p); // \"p < q\" <=> \"p.x < q.x\"\n  double d = norm(p[s]-p[t]);\n  for (int i = 2; i < n; S[m++] = i++) REP(j, m) {\n    if (norm(p[S[j]]-p[i])<d) d = norm(p[s = S[j]]-p[t = i]);\n    if (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n  }\n  return make_pair( p[s], p[t] );\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  SORT(g);\n  pair<P, P> ans = closestPair(g);\n  printf(\"%.10lf\\n\", abs(ans.second - ans.first));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct node{\n  int dim;\n  vector<double>v;\n};\n\ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n\ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n\n  vector<node>res;\n\n  while(S.size()>1){\n    res=S;\n    node p=S[rand()%S.size()];\n\n    double dist=d(p,S)/(4*p.dim);\n\n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n\n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    \n    S=nextS;    \n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n  \n  return ans;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n\n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n\ntemplate <typename T>\nstruct Vector2D {        // Literal Class\n    T x, y;\n    explicit constexpr Vector2D() : x(0), y(0) {}\n    explicit constexpr Vector2D(T _x, T _y) : x(_x), y(_y) {}\n    const Vector2D operator + (const Vector2D& p) const { return Vector2D(x + p.x, y + p.y);}\n    const Vector2D operator - (const Vector2D& p) const { return Vector2D(x - p.x, y - p.y);}\n    Vector2D& operator *= (const T& p) { x *= p, y *= p; return *this;}\n    Vector2D& operator += (const T& p) { x += p, y += p; return *this;}\n    Vector2D& operator -= (const T& p) { x -= p, y -= p; return *this;}\n    Vector2D& operator /= (const T& p) { x /= p; y /= p; return *this;}\n    Vector2D& operator += (const Vector2D& p) { x += p.x, y += p.y; return *this;}\n    Vector2D& operator -= (const Vector2D& p) { x -= p.x, y -= p.y; return *this;}\n    const T dot(const Vector2D& q) { return x * q.x + y * q.y;}\n    const T norm() { return sqrt(x * x + y * y);}\n    friend std::ostream& operator<<(std::ostream& os, const Vector2D& p) { os << \"(\" << p.x << \", \" << p.y << \")\"; return os;}\n};\n\n#include <vector>\n#include <iomanip>\n#include <functional>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\nusing Pt = Vector2D<double>;\nconst double INF = 1e18;\nconst double EPS = 1.0e-11;\nbool eq(double a, double b) { return fabs(a - b) <= EPS;}\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<Pt> points(n); // Points are 1 indexed\n    for(auto& p : points)\n        cin >> p.x >> p.y;\n    // x??§?¨???§?????????\n    sort(points.begin(), points.end(), [](const Pt& l, const Pt& r) {\n            return eq(l.x, r.x) ? l.y < r.y : l.x < r.x;\n        });\n\n    function<tuple<double, int, int>(int, int)> closest = [&](int id, int n) {\n        if(n <= 1) return make_tuple(INF, 0, 0);\n        int m = n / 2;\n        double boundX = points[m].x;\n        tuple<double, int, int> res = min(closest(id, m), closest(id + m, n - m));\n        auto fit = points.begin() + id;\n        inplace_merge(fit, fit + m, fit + n, [](const Pt& l, const Pt& r) {\n                return  eq(l.y, r.y) ? l.x < r.x : l.y < r.y;\n            });\n        vector<int> memo;\n        for(int i = id; i < id + n; ++i) {\n            if(fabs(boundX - points[i].x) >= get<0>(res)) continue;\n            for(int j = -1 + memo.size(); j >= 0; --j) {\n                Pt p = points[i] - points[memo[j]];\n                if(p.x >= get<0>(res)) break;\n                res = min(res, make_tuple(p.norm(), i, memo[j]));\n            }\n            memo.emplace_back(i);\n        }\n        return res;\n    };\n    cout << fixed << setprecision(10) << get<0>(closest(0, n)) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct node{\n  int dim;\n  vector<double>v;\n};\n \ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n \ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nmap<vector<int> ,vector<int> >grid;\n\nvector<int> neighborhood(vector<int> v, int dim, vector<int>res){\n\n  if(dim==v.size()){\n    bool fg = true;\n    for(int i=0;i<dim;i++)fg&=(res[i]==v[i]);\n    if(fg || !grid.count(res))return vector<int>();\n    return grid[res];\n  }\n  vector<int> result;\n  for(int i=-1;i<2;i++){\n    res.push_back(v[dim]+i);\n    vector<int>tmp = neighborhood(v,dim+1,res);\n    result.insert(result.end(),tmp.begin(),tmp.end());\n    res.pop_back();\n  }\n  return result;\n}\n\nvector<node> func(vector<node> S){\n  vector<node>nextS;\n  map<vector<int>,vector<int> >::iterator it = grid.begin();\n  for(;it!=grid.end();it++){\n    vector<int>res=neighborhood((*it).first,0,vector<int>());\n    for(int j=0;j<res.size();j++)nextS.push_back(S[res[j]]);\n  }\n\n  return nextS;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n \n  vector<node>res;\n \n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n \n    double dist=d(p,S)/(4*p.dim);\n \n    grid.clear();\n    for(int i=0;i<S.size();i++){\n      vector<int> key;\n      for(int j=0;j<p.dim;j++)key.push_back((int)(S[i].v[j]/dist));\n      grid[key].push_back(i);\n    }\n   \n    vector<node>tmp = func(S);\n    //if(S.size() == tmp.size())break;\n    S=tmp;\n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n   \n  return ans;\n}\n \nint main(void){\n \n  int n;\n  cin >> n;\n \n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n \n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://ir5.hatenablog.com/entry/20131221/1387557630\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <utility>\n#include <cmath>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\ntypedef pair<double, double> P;\ntypedef pair<int, int> IP;\ndouble norm(P a, P b) {\n  double x = a.first - b.first;\n  double y = a.second - b.second;\n  return sqrt(x*x + y*y);\n}\n// http://stackoverflow.com/questions/20590656/\nstruct pairhash {\npublic:\n  template <typename T, typename U>\n  std::size_t operator()(const std::pair<T, U> &x) const {\n    return (std::hash<T>()(x.first) << 32LL) ^ std::hash<U>()(x.second);\n  }\n};\nint main() {\n  int N; cin >> N;\n  vector<P> p(N);\n  REP(i,N) {\n    double x, y; cin >> x >> y;\n    p[i] = make_pair(x, y);\n  }\n  double xmin = p[0].first, ymin = p[0].second;\n  REP(i,N) {\n    xmin = min(xmin, p[i].first);\n    ymin = min(ymin, p[i].second);\n  }\n  REP(i,N) {\n    p[i].first -= xmin;\n    p[i].second -= ymin;\n  }\n  // std::rand is often used.\n  random_shuffle(p.begin(), p.end());\n  double delta = norm(p[0], p[1]);\n  unordered_map<IP, vector<int>, pairhash> S;\n  S[IP(p[0].first / delta, p[0].second / delta)].push_back(0);\n  S[IP(p[1].first / delta, p[1].second / delta)].push_back(1);\n  for(int i = 2; i < N; ++i) {\n    IP ip(p[i].first / delta, p[i].second / delta);\n    bool update = false;\n    for(int dx = -1; dx <= 1; ++dx) for(int dy = -1; dy <= 1; ++dy) {\n      for(int j : S[IP(ip.first + dx, ip.second + dy)]) {\n        double d2 = norm(p[i], p[j]);\n        if(delta > d2) {\n          delta = d2;\n          update = true;\n        }\n      }\n    }\n    if(update) {\n      S.clear();\n      for(int j = 0; j <= i; ++j) {\n        S[IP(p[j].first / delta, p[j].second / delta)].push_back(j);\n      }\n    }\n    else {\n      S[ip].push_back(i);\n    }\n  }\n  cout.setf(ios::fixed);\n  cout.precision(6);\n  cout << delta << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\n\nint main(){\n\tint n;\n\tdouble *x,*y;\n\tdouble min = 80000;\n\tdouble mdx = 200,mdy = 200;\n\tdouble dx,dy,l;\n\tint i,j;\n\t\n\tcin>>n;\n\tx = new double[n];\n\ty = new double[n];\n\tfor(int i=0;i<n;++i){\n\t\tcin>>x[i]>>y[i];\n\t}\n\t\n\tfor(i=n-1;i>=0;--i){\n\t\tfor(j=i-1;j>=0;--j){\n\t\t\tdx = x[i]-x[j],dy = y[i]-y[j];\n\t\t\t\n\t\t\tif( dx<=mdx || dy<=mdy ){\n\t\t\t\tl = dx*dx+dy*dy;\n\t\t\t\tif(l<min){\n\t\t\t\t\tmin=l;\n\t\t\t\t\tmdx=dx;\n\t\t\t\t\tmdy=dy;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tcout<<fixed<<setprecision(6)<<sqrt(min)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief (n 2) = Θ(n^2)通りの点対を調べ、最近点対間距離を返す\n *\n * @param const point*P 点集合P\n * @param index_t n     Pの要素数\n */\nstatic elem_t brute_force_closest_pair(const point*P, index_t n)\n{\n    elem_t minimum = std::numeric_limits<elem_t>::max();\n    for (index_t i = 0; i < n; i++) {\n        for (index_t j = i + 1; j < n; j++) {\n            elem_t dist = abs(P[i] - P[j]);\n            minimum = std::min(minimum, dist);\n        }\n    }\n    return minimum;\n}\n\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {  // |P| <= 3か否かを判定する\n        //return std::numeric_limits<elem_t>::max();\n        return brute_force_closest_pair(P, n);  // |P| <= 3ならば、虱潰で問題を解く\n    }\n\n    // |P| > 3ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = std::numeric_limits<elem_t>::max();\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) > delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if (P[i].y - p.y > delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << setprecision(22) << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(__typeof((o).begin()) it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T> >& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){EACH(a,ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;EACH(p,m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\ntemplate<> long double INF<long double>(){return 1e16;};\n\ntemplate<typename T> T pmod(T v,T M){return (v%M+M)%M;}\n\nnamespace _double_tmpl{\n    typedef long double D;const D EPS = 1e-8;\n    \n    static constexpr D Ae=0;\n    D A(D a,D b){return a+b;}D Ainv(D a){return -a;}\n    D S(D a,D b){return A(a,Ainv(b));}\n    \n    static constexpr D Me=1;\n    D M(D a,D b){return a*b;}D Minv(D a){return 1.0/a;};\n\n    int sig(D a,D b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n    bool eq(D a,D b){ return sig(abs(a-b))==0;}\n\n}\nusing namespace _double_tmpl;\n\n\nnamespace Ps{\n    // using namespace _double_tmpl;\n    typedef complex<D> P,Vec;\n\n#define X real()\n#define Y imag()\n    istream& operator >> (istream& is,complex<D>& p){\n        D x,y;is >> x >> y;p=P(x,y);return is;\n    }\n\n    bool eq(P a,P b){return eq(a.X,b.X) and eq(a.Y,b.Y);}\n    // a×b\n    D cross(const Vec& a,const Vec& b){return imag(conj(a)*b);}\n    // a・b\n    D dot(const Vec&a,const Vec& b) {return real(conj(a)*b);}\n\n    int ccw(const P& a,P b,P c){\n        b -= a; c -= a;\n        if (cross(b,c) > EPS)   return +1;       // counter clockwise\n        if (cross(b,c) < -EPS)   return -1;       // clockwise\n        if (dot(b,c) < 0)     return +2;       // c--a--b on line\n        if (norm(b) < norm(c)) return -2;       // a--b--c on line\n        return 0;\n    }\n\n    bool compY (const P& a,const P& b);\n    D closestPair(vector<P>& ps,int l,int r){\n        if(r-l<2)return INF<D>();\n        D res=min(closestPair(ps,l,(l+r)/2),closestPair(ps,(l+r)/2,r));\n        \n        vector<P> ips;\n        FOR(i,l,r)if(abs(ps[i].X - ps[(l+r)/2].X)<res)ips.push_back(ps[i]);\n        sort(ALL(ips),compY);        \n        \n        REP(i,ips.size())for(int j=i-10;j<i;j++)if(j>=0)\n            res=min(res,abs(ips[i]-ips[j]));\n\n        return res;\n    }\n    bool compY (const P& a,const P& b){return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;}\n}\nusing namespace Ps;\n\nnamespace std{\n\n    bool compX (const P& a,const P& b){return a.X != b.X ? a.X < b.X : a.Y < b.Y;}\n    bool compY (const P& a,const P& b){return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;}\n    bool operator < (const P& a,const P& b){return compX(a,b);}\n    bool operator == (const P& a,const P& b){return eq(a,b);}\n};\n\nstringstream ss;\nclass Main{\n    public:\n    void run(){\n        int n;cin >> n;\n        vector<P> ps;\n        REP(i,n) {\n            P p;cin >> p;\n            ps.push_back(p);\n        }\n        sort(ALL(ps));\n        cout << closestPair(ps,0,n)<<endl;\n    }\n};\n\nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 10000;\nconst double INFTY = 10000000000000000000.0;\n\nstruct Point { double x, y; };\nbool compareX(Point& a, Point& b) {\n\treturn a.x < b.x ? true : a.x == b.x && a.y <= b.y ? true : false;\n}\n\nbool compareY(Point& a, Point& b) {\n\treturn a.y < b.y ? true : a.y == b.y && a.x <= b.x ? true : false;\n}\n\ninline double getSquareDist(Point a, Point b) {\n\treturn (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\ninline double getMinSquareDistOfThree(Point a, Point b, Point c) {\n\treturn min(getSquareDist(a, b), min(getSquareDist(a, c), getSquareDist(b, c)));\n}\n\ndouble getMinSquareDistNearMid(Point nearmid[], int nearmid_length) {\n\tsort(nearmid, nearmid + nearmid_length, compareY);\n\n\tdouble min_sq_dist = INFTY;\n\tdouble cur_sq_dist;\n\tfor (int i = 0; i < nearmid_length; ++i) {\n\t\t// a better implementation:\n\t\t//for (int j = i + 1; j < min(nearmid_length, i + 8); ++j) {\n\t\tfor (int j = i + 1; j < nearmid_length && (nearmid[j].y - nearmid[i].y) < min_sq_dist; ++j) {\n\t\t\tcur_sq_dist = getSquareDist(nearmid[i], nearmid[j]);\n\t\t\tif (cur_sq_dist < min_sq_dist)\n\t\t\t\tmin_sq_dist = cur_sq_dist;\n\t\t}\n\t}\n\treturn min_sq_dist;\n}\n\n// nlog^2 n, not nlog n in CLRS\ndouble dcClosestSquareDist(int low, int high, Point points[]) {\n\tif (high - low == 1) {\n\t\treturn getSquareDist(points[low], points[high]);\n\t}\n\telse if (high - low == 2) {\n\t\treturn getMinSquareDistOfThree(points[low], points[low + 1], points[high]);\n\t}\n\telse {\n\t\t// bug 3: + has higher precedence than >>\n\t\t//int mid = low + (high - low) >> 1;\n\t\tint mid = low + ((high - low) >> 1);\n\t\tdouble d_left = dcClosestSquareDist(low, mid, points);\n\t\tdouble d_right = dcClosestSquareDist(mid + 1, high, points);\n\t\tdouble d_divide = min(d_left, d_right);\n\t\tdouble d_divide_sqrt = sqrt(d_divide);\n\n\t\t// merge\n\t\tPoint *nearmid = new Point[high - low + 1];\n\t\tint nearmid_length = 0;\n\t\tfor (int i = low; i <= high; ++i) {\n\t\t\t// bug 4: here we should compare the dist with real dist, not squared!\n\t\t\tif (points[i].x - points[mid].x < d_divide_sqrt && points[i].x - points[mid].x > -d_divide_sqrt) {\n\t\t\t\tnearmid[nearmid_length] = points[i];\n\t\t\t\tnearmid_length++;\n\t\t\t}\n\t\t}\n\t\tdouble d_merge = getMinSquareDistNearMid(nearmid, nearmid_length);\n\t\t// bug 6: forget to free memory\n\t\tdelete[] nearmid;\n\t\treturn min(d_divide, d_merge);\n\t}\n}\n\ndouble getMinSqDistToFirst(Point first_camera, Point points[], int n) {\n\tdouble min_sq_dist = INFTY;\n\tdouble cur_sq_dist;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcur_sq_dist = getSquareDist(first_camera, points[i]);\n\t\tif (cur_sq_dist < min_sq_dist)\n\t\t\tmin_sq_dist = cur_sq_dist;\n\t}\n\treturn min_sq_dist;\n}\n\ndouble getArea(double candidate, double min_dist_to_first, int n) {\n\treturn candidate * candidate + (n - 1) * (min_dist_to_first - candidate) * (min_dist_to_first - candidate);\n}\n\n/*\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tint n;\n\tPoint points[MAX_N];\n\tPoint first_camera;\n\tdouble min_dist_to_first;\n\tdouble min_dist_among_others;\n\tdouble candidate1;\t// candidate1 = max(0, d1 - d2 / 2)\n\tdouble candidate2;\t// candidate2 = d1\n\tdouble max_area;\n\tfor (int i = 1; i <= t; ++i) {\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%lf%lf\", &(first_camera.x), &(first_camera.y));\n\t\tfor (int j = 0; j < n - 1; ++j) {\n\t\t\tscanf(\"%lf%lf\", &(points[j].x), &(points[j].y));\n\t\t}\n\t\tmin_dist_to_first = sqrt(getMinSqDistToFirst(first_camera, points, n));\n\t\tif (n == 2) {\n\t\t\tmin_dist_among_others = INFTY;\n\t\t}\n\t\telse {\n\t\t\tsort(points, points + n - 1, compareX);\n\t\t\tmin_dist_among_others = sqrt(dcClosestSquareDist(0, n - 2, points));\n\t\t}\n\t\t//printf(\"%f\\n\", min_dist_among_others);\n\t\tcandidate1 = max(0.0, min_dist_to_first - min_dist_among_others / 2.0);\n\t\tcandidate2 = min_dist_to_first;\n\t\tmax_area = M_PI * max(getArea(candidate1, min_dist_to_first, n), getArea(candidate2, min_dist_to_first, n));\n\t\tprintf(\"Case #%d: %.8f\\n\", i, max_area);\n\t}\n    return 0;\n}\n*/\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tPoint points[MAX_N];\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%lf%lf\", &(points[i].x), &(points[i].y));\n\t}\n\tsort(points, points + n, compareX);\n\tprintf(\"%.10lf\\n\", sqrt(dcClosestSquareDist(0, n, points)));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100000\n#define INF 1e9\n\ntypedef pair<double,double> P;\n\nint N;\nP A[MAX_N]; \n\nbool compare_y(const P &a,const P &b){\n  return a.second < b.second;\n}\n \ndouble closest_pair(P *a,int n){\n  if(n <= 1) return INF;\n  int m = n / 2;\n  double x = a[m].first;\n  double d = min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n \n  vector<P> b;\n  for(int i = 0 ; i < n ; i++){\n    if(fabs(a[i].first - x >= d)) continue;\n    for(int j = 0 ; j < (int)b.size() ; j++){\n      double dx = a[i].first - b[b.size()-j-1].first;\n      double dy = a[i].second - b[b.size()-j-1].second;\n      if(dy >= d) break;\n      d = min(d,sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nvoid solve(){\n  sort(A,A+N);\n  printf(\"%.8f\\n\",closest_pair(A,N));\n}\n\nint main(){\n  cin >> N;\n  for(int i = 0 ; i < N ; i++){\n    cin >> A[i].first >> A[i].second;\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<30\n#define MAX 100010\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nP A[MAX];\nint n;\n\nbool compare_y(P a,P b){\n  return a.s<b.s;\n}\n\ndouble closest_pair(P *a,int n){\n  if(n<=1)return inf;\n  int m=n/2;\n  double x=a[m].f;\n  double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if(fabs(a[i].f-x)>=d)continue;\n\n    for(int j=0;j<b.size();j++){\n      double dx=a[i].f-b[b.size()-j-1].f;\n      double dy=a[i].s-b[b.size()-j-1].s;\n      if(dy>=d)continue;\n      d=min(d,sqrt(dx*dx+dy*dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main()\n{\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>A[i].f>>A[i].s;\n\n  sort(A,A+n);\n\n  printf(\"%.10f\\n\",closest_pair(A,n));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n   \ntypedef pair<double,double> P;\ntypedef pair<P,double> P2;\n   \nP rot(P p, double a){\n  a=a*M_PI/180.0;\n  return P(p.first*cos(a)+p.second*(-sin(a)),\n  p.first*sin(a)+p.second*cos(a));\n}\n   \ndouble abss(P a,P b){\n  return sqrt((a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second));\n}\n   \ndouble x,y,r;int tt;\nvector<P>v;\nint main(){\n   \n  int n;\n  cin>>n;\n   \n    double ans=1e13;\n       \n    v.clear();\n     \n    r(i,n){\n      cin>>x>>y;\n      v.push_back(P(x,y));\n    }\n   \n    r(i,1){\n      sort(v.begin(),v.end());\n      r(j,n){\n        for(int k=j+1,c=0;k<n;k++,c++){\n          if(c>50)break;\n          ans=min(ans,abss(v[k],v[j]));\n        }\n      }\n      r(j,n)v[i]=rot(v[i],0.5);\n    }\n   \n    printf(\"%.11f\\n\",ans);\n       \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn 1e9;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP,\n\tint yl,int yr\n){\n\tint xsiz=xr-xl;\n\tint ysiz=yr-yl;\n\tif (xsiz <= 8) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tif(ysiz==0)return 1e9;\n\tauto xM = xP[xl+xsiz/2].first;\n\tauto yL = std::vector<point_t>(ysiz);\n\tint left = -1, right = ysiz;\n\tfor(int i = yl; i < yr; i++){\n\t\tif (yP[i].first < xM) yL[++left] = yP[i];\n\t\telse                  yL[--right]= yP[i];\n\t}\n\tstd::reverse(yL.begin()+right,yL.end());\n\tauto p1 = find_closest_optimized(xP,xl,xl+xsiz/2,yL,0,left+1);\n\tauto p2 = find_closest_optimized(xP,xl+xsiz/2,xr,yL,left+1,ysiz);\n\tauto minD = sqrt((p1 < p2) ? p1 : p2);\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tif(yS.size>=2)\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n,yP,0,n);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/50))  \n #define Fun2(j,n) for(int j=i+(int)(n/30);j<n;j=j+(int)(n/50))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=2000;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16??????????????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   //?°?16????????????????????????????????? \n   minx=minx-1;\n   miny=miny-1;\n   maxx=maxx+1;\n   maxy=maxy+1;\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=3;j>=0;j--)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*(3-j)+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n   /*\n   for(int i=0;i<16;i++)\n   {\n     for(int j=0;j<num_point[i];j++)\n     {\n       cout<<wu[i][j].x<<\" \"<<wu[i][j].y<<endl;        \n     }        \n   }\n   */\n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       //real_min=(point[0].x-point[1].x)*(point[0].x-point[1].x)+(point[0].y-point[1].y)*(point[0].y-point[1].y);\n       real_min=fun_min;\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A?????? \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<limits>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\ntemplate<typename T> bool equals(T a, T b){ return (fabs(a - b)) < EPS;};\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstatic const int NOTCROSS = 4;\nstatic const int CIRCUMSCRIBED = 3; \nstatic const int INTERSECT = 2;\nstatic const int INSCRIBED = 1;\nstatic const int INCLUDE = 0;\n\nconst double PI = acos(-1);\n\nclass Point{\npublic:\n\tdouble x, y;\n\t\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\tPoint(const Point &p) { x = p.x; y = p.y;};\n\t\n\tPoint operator + (const Point &p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (const Point &p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (const double &a) { return Point(x * a, y * a); }\n\tPoint operator / (const double &a) { return Point(x / a, y / a); }\n\t\n\tPoint & operator = (const Point& p) {x = p.x; y = p.y; return *this;};\n\tPoint & operator += (const Point& p) {x += p.x; y += p.y; return *this;};\n\tPoint & operator -= (const Point& p) {x -= p.x; y -= p.y; return *this;};\n\tPoint & operator *= (const Point& p) {x *= p.x; y *= p.y; return *this;};\n\tPoint & operator /= (const Point& p) {x /= p.x; y /= p.y; return *this;};\n\t\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\t\n\tbool operator > (const Point &p) const {\n\t\treturn x != p.x ? x > p.x : y > p.y;\n\t}\n\t\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\t\n\tdouble abs() { return sqrt(norm()); };\n\tdouble norm() { return x * x + y * y;};\n};\n\ntypedef Point Vector;\n\n\ndouble norm(Vector a){\n\treturn a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstruct Segment{\n\tPoint p1, p2;\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\n\n\nbool isOrthogonal(Vector a, Vector b){\n\treturn equals(dot(a,b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2){\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n\nbool isParallel(Vector a, Vector b){\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isPrallel(Segment s1, Segment s2){\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < - EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n\t\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2){\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint intersect(Circle c1, Circle c2){\n\tdouble dis = abs(c1.c - c2.c);\n\t\n\tif(dis > c1.r + c2.r + EPS) return NOTCROSS;\n\tif(fabs(dis - c1.r - c2.r) < EPS) return CIRCUMSCRIBED;\n\tif(dis > fabs(c1.r - c2.r) + EPS) return INTERSECT;\n\tif(fabs(dis - fabs(c1.r - c2.r)) < EPS) return INSCRIBED;\n\treturn INCLUDE;\n}\n\ndouble getDistace(Point a, Point b){\n\treturn abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p - l.p1)) / abs(l.p2 - l.p1);\n}\n\ndouble getDistanceSP(Segment s, Point p){\n\tif(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n\tif(intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrosPoint(Segment s1, Segment s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nbool intersect(Circle c, Line l){\n\treturn getDistanceLP(l, c.c) < c.r + EPS;\n}\n\npair<Point, Point> getCrossPoint(Circle c, Line l){\n\tassert(intersect(c,l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e *base);\n}\n\ndouble arg(Vector p) {return atan2(p.y, p.x);}\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a);}\n\n\npair<Point, Point> getCrosPoint(Circle c1, Circle c2){\n\tPoint res1, res2;\n\tint ins = intersect(c1, c2);\n\tif(ins == NOTCROSS || ins == INCLUDE) {\n\t\tassert(false); // 0\n\t}\n\tif(ins == INSCRIBED && equals(c1.r, c2.r)){\n\t\tassert(false); // infinity\n\t}\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\tres1 = c1.c + polar(c1.r, t + a);\n\tres2 = c1.c + polar(c1.r, t - a);\n\treturn make_pair(res1, res2);\n}\n\n\ndouble getArea(Circle c){\n\treturn c.r*c.r*PI;\n}\n\ndouble getArea(Polygon& p){\n\tdouble area = 0;\n\t\n\tfor(int i = 0; i < p.size(); i++){\n\t\tarea += (p[i].x * p[(i + 1) % p.size()].y - p[(i + 1) % p.size()].x * p[i].y);\n\t}\n\t\n\treturn fabs(area)/2;\n}\n\nbool isConvex(Polygon& p){\n\tint b = 0;\n\t\n\tfor(int i = 0; i < p.size(); i++){\n\t\tint j = (i + 1) % p.size(), k = (i + 2) % p.size();\n\t\tint c = ccw(p[i], p[j], p[k]);\n\t\tif(c == ON_SEGMENT || c == ONLINE_BACK || c == ONLINE_FRONT) continue;\n\t\tif(c*b < 0) return false;\n\t\tif(!b) b = c;\n\t}\n\t\n\treturn 1;\n}\n\n/*\nIN 2, ON 1, OUT 0\n*/\nint contains(Polygon &g, Point p){\n\tint n = g.size();\n\tbool x = false;\n\tfor(int i = 0; i < n; i++){\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif(a.y > b.y) swap(a, b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\nPolygon andrewScan(Polygon s){\n\tPolygon u, l;\n\tif(s.size() < 3) return s;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\t\n\tfor(int i = 2; i < s.size(); i++){\n\t\t// for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) != CLOCKWISE; n--){ //凸包の辺上の点を含めない\n\t\tfor(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){ //凸包の辺上の点を含める\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t\n\tfor(int i = s.size() - 3; i >= 0; i--){\n\t\t// for(int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], s[i]) != CLOCKWISE; n--){ //凸包の辺上の点を含めない\n\t\tfor(int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], s[i]) == COUNTER_CLOCKWISE; n--){ //凸包の辺上の点を含める\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t\n\treverse(l.begin(), l.end());\n\tfor(int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\t\n\treturn l;\n}\n\n\nclass EndPoint {\npublic:\n\tPoint p;\n\tint seg, st;\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st): p(p), seg(seg), st(st) {}\n\t\n\tbool operator < (const EndPoint &ep) const {\n\t\tif(p.y == ep.p.y) {\n\t\t\treturn st < ep.st;\n\t\t} else return p.y < ep.p.y;\n\t}\n};\n\n\nint manhattanIntersection(vector<Segment> S){\n\tconst int BOTTOM = 0;\n\tconst int LEFT = 1;\n\tconst int RIGHT = 2;\n\tconst int TOP = 3;\n\tint n = S.size();\n\tvector<EndPoint> EP(2*n);\n\t\n\t\n\tfor(int i = 0, k = 0; i < n; i++){\n\t\tif(S[i].p1.y == S[i].p2.y){\n\t\t\tif(S[i].p1.x > S[i].p2.x) swap(S[i].p1, S[i].p2);\n\t\t} else if(S[i].p1.y > S[i].p2.y) swap(S[i].p1, S[i].p2);\n\t\t\n\t\tif(S[i].p1.y == S[i].p2.y){\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, RIGHT);\n\t\t} else {\n\t\t\tEP[k++] = EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++] = EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\t\n\tsort(EP.begin(), EP.end());\n\t\n\tset<int> BT;\n\tconst int INF = (1<<30);\n\tBT.insert(INF);\n\tint cnt = 0;\n\t\n\tfor(int i = 0; i < 2*n; i++){\n\t\tif(EP[i].st == TOP){\n\t\t\tBT.erase(EP[i].p.x);\n\t\t} else if(EP[i].st== BOTTOM) {\n\t\t\tBT.insert(EP[i].p.x);\n\t\t} else if(EP[i].st == LEFT) {\n\t\t\tset<int>::iterator b = BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e = BT.upper_bound(S[EP[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\t\n\treturn cnt;\t\n}\n\n\nbool compare_y(Point a, Point b){\n\treturn a.y < b.y;\n}\n\n// aはx座標の昇順で渡すこと\ndouble closest_pair(Point *a, int n){\n\tif(n <= 1) return numeric_limits<double>::max();\n\tint m = n / 2;\n\tdouble x = a[m].x;\n\tdouble d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n\tinplace_merge(a, a + m, a + n, compare_y);\n\t\n\tvector<Point> b;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tif(fabs(a[i].x - x) >= d - EPS) continue;\n\t\t\n\t\tfor(int j = 0; j < b.size(); j++){\n\t\t\tPoint e(a[i].x - b[b.size() - j - 1].x, a[i].y - b[b.size() - j - 1].y);\n\t\t\tif(e.y >= d) break;\n\t\t\td = min(d, e.abs());\n\t\t}\n\t\tb.push_back(a[i]);\n\t}\n\t\n\treturn d;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint n, q, bi;\n\tPolygon p, ans;\n\tvector<Point> a;\n\t\n\tcin>>n;\n\t\n\ta.resize(n);\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin>>a[i].x>>a[i].y;\n\t}\n\t\n\tsort(a.begin(), a.end());\n\t\n\tcout<<closest_pair(&a[0], n)<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x, double y) : x(x), y(y) {}\n    Point() {}\n};\nbool operator<(const Point &p1, const Point &p2) {\n    return (p1.x < p2.x) || (p1.x == p2.x && p1.y < p2.y);\n}\nbool compare_y(const Point &p1, const Point &p2) {\n    return p1.y < p2.y;\n}\n\ndouble ClosestPair(vector<Point>::iterator begin, vector<Point>::iterator end) {\n    const int n = end - begin;\n    if (n <= 1)\n        return numeric_limits<double>::max();\n    int m = n / 2;\n    double x = (begin + m)->x;\n    double d = min(ClosestPair(begin, begin + m), ClosestPair(begin + m, end));\n    inplace_merge(begin, begin + m, end, compare_y);\n\n    vector<Point> b;\n    for (auto it = begin; it != end; ++it) {\n        if (d <= abs(it->x - x))\n            continue;\n\n        for (size_t i = 0; i < b.size(); ++i) {\n            double dx = it->x - b[b.size() - i - 1].x;\n            double dy = it->y - b[b.size() - i - 1].y;\n            if (d <= dy)\n                break;\n            d = min(d, sqrt(dx * dx + dy * dy));\n        }\n        b.emplace_back(*it);\n    }\n\n    return d;\n}\n\ndouble Solve(vector<Point> &p) {\n    sort(p.begin(), p.end());\n    return ClosestPair(p.begin(), p.end());\n}\n\nint main()\n{\n    int n;\n\n    scanf(\"%d\", &n);\n    vector<Point> p(n);\n    for (int i = 0; i < n; ++i)\n        scanf(\"%lf %lf\", &p[i].x, &p[i].y);\n\n    printf(\"%.9f\\n\", Solve(p));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 200000\npair<long double, long double>pa[MAX_N];\nlong double dist(long double ax, long double ay, long double bx, long double by) { \n\treturn sqrt((ax - bx)*(ax - bx) + (ay - by)*(ay - by));\n}\nint main() {\n\tint N; cin >> N; long double minx = 100.0L, maxx = -100.0L, miny = 100.0L, maxy = -100.0L;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> pa[i].first >> pa[i].second;\n\t\tminx = min(minx, pa[i].first);\n\t\tmaxx = max(maxx, pa[i].first);\n\t\tminy = min(miny, pa[i].second);\n\t\tmaxy = max(maxy, pa[i].second);\n\t}\n\tsort(pa, pa + N);\n\tlong double maxn = 100000;\n\tlong double G = (maxx - minx) / (sqrtl(N) - 1);\n\tlong double H = (maxy - miny) / (sqrtl(N) - 1);\n\tif (G < H) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlong double L = pa[i].first - G, R = pa[i].first + G;\n\t\t\tint pos1 = lower_bound(pa, pa + N, make_pair(L, -1000.0L)) - pa;\n\t\t\tint pos2 = lower_bound(pa, pa + N, make_pair(R, 1000.0L)) - pa;\n\t\t\tfor (int j = pos1; j < pos2; j++) {\n\t\t\t\tif (i == j) { continue; }\n\t\t\t\tmaxn = min(maxn, dist(pa[i].first, pa[i].second, pa[j].first, pa[j].second));\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tswap(pa[i].first, pa[i].second);\n\t\t}\n\t\tsort(pa, pa + N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlong double L = pa[i].first - H, R = pa[i].first + H;\n\t\t\tint pos1 = lower_bound(pa, pa + N, make_pair(L, -1000.0L)) - pa;\n\t\t\tint pos2 = lower_bound(pa, pa + N, make_pair(R, 1000.0L)) - pa;\n\t\t\tfor (int j = pos1; j < pos2; j++) {\n\t\t\t\tif (i == j) { continue; }\n\t\t\t\tmaxn = min(maxn, dist(pa[i].first, pa[i].second, pa[j].first, pa[j].second));\n\t\t\t}\n\t\t}\n\t}\n\tcout << fixed << setprecision(1919) << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<utility>\n#include<complex>\n#include<functional>\nusing namespace std;\n#define LL double \n\nstruct P{\n\tdouble x, y;\n};\n\nusing namespace std;\n\n//Compare for sorting\ninline bool LessX(const P& left, const P& right){\n\tif (left.x == right.x)return(left.y < right.y);\n\treturn left.x<right.x;\n}\ninline bool LessY(const P& left, const P& right){\n\treturn(left.y < right.y);\n}\n\n\nP xx[10000000], yy[10000000],ss[10000000];\nint ix, iy,is;\n#define dist(_x,_y,__x,__y) (((_x)-(__x))*((_x)-(__x))+((_y)-(__y))*((_y)-(__y)))\n#define distP(a,b) sqrt(dist((a.x),(a.y),(b.x),(b.y)))\nvoid Closest_Pair_rec(int n,int xs, int ys, P *p1, P *p2, LL* qdist){\n\n\n\tP *vx = xx + xs;\n\tP *vy = yy + ys;\n\n\t/*for (int i = 0; i < n; i++)\n\t\tprintf(\"(%.5f,%.5f)\", vx[i].x, vx[i].y); cout << endl;\n\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"(%.5f,%.5f)\", vy[i].x, vy[i].y); cout << endl;\n\tcout << endl;\n\t*/\n\tif (n == 3){\n\t\tLL d1 = distP(vx[0], vx[1]), d2 = distP(vx[1], vx[2]), d3 = distP(vx[2], vx[0]);\n\t\t(*qdist) = d1; *p1 = vx[0], *p2 = vx[1];\n\t\tif (*qdist>d2)(*qdist) =d2,*p1 = vx[1], *p2 = vx[2];\n\t\tif (*qdist>d3)(*qdist) = d3, *p1 = vx[0] , *p2 = vx[2];\n\t\treturn;\n\t}\n\tif(n==2){\n\t\t(*qdist) = distP(vx[0], vx[1]); *p1 = vx[0], *p2 = vx[1];\n\n\t\treturn;\n\t}\n\tint half = n / 2;\n\tint l = iy, r = iy+half,tempiy=iy;\n\tP middle = vx[half];\n\tP rp1, rp2;\n\tLL  rd;\n\tfor (int i = 0; i < n; i++){\n\t\tif (LessX(vy[i], middle))\n\t\t\tyy[l++] = vy[i];\n\t\telse\n\t\t\tyy[r++] = vy[i];\n\t}\n\tiy += n;\n\tClosest_Pair_rec(half, xs, tempiy, p1, p2, qdist);\n\tClosest_Pair_rec(n-half, xs+half, tempiy+half, &rp1, &rp2, &rd);\n\t/*printf(\"(%.5f, %.5f)\", (middle).x, (middle).y); printf(\"(%.5f, %.5f)\", (*p1).x, (*p1).y); printf(\"(%.5f, %.5f)\", (*p2).x, (*p2).y);\n\tprintf(\"(%.5f, %.5f)\", (rp1).x, (rp1).y); printf(\"(%.5f, %.5f)\\n\", (rp2).x, (rp2).y);*/\n\tif (*qdist>rd)*p1 = rp1, *p2 = rp2, *qdist = rd;\n\n\tint k = 0;\n\tP *vs = ss + is;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\trd = (vy[i].x - middle.x);\n\t\tif (rd < *qdist)\n\t\t\tvs[k++] = vy[i];\n\t}\n\tfor (int i = 0; i < k - 1; i++)\n\t\tfor (int j = i + 1; j < k&&vs[j].y - vs[i].y < *qdist; j++){\n\t\t\trd = distP(vs[i], vs[j]);\n\t\t\tif (*qdist > rd){\n\t\t\t\t*qdist = rd;\n\t\t\t\t*p1 = vs[i];\n\t\t\t\t*p2 = vs[j];\n\t\t\t}\n\t\t}\n\tis += k;\n\t//printf(\"(%.5f, %.5f)\", (*p1).x, (*p1).y);printf(\"(%.5f, %.5f)\\n\", (*p2).x, (*p2).y);\n}\n\nvoid Closest_Pair(int n, vector<P>& list, P* p1, P* p2, LL* qdist){\n\tix = n, iy = n,is=0;\n\tfor (int i = 0; i < n; i++)\n\t\txx[i] = yy[i] = list[i];\n\tsort(xx, xx+n, LessX);\n\tsort(yy, yy+n, LessY);\n\tClosest_Pair_rec(n,0,0,p1, p2, qdist);\n}\n/*\nint main(void){\n\tint N; cin >> N;\n\tLL a, b;\n\tP p1, p2;\n\tvector<P> A(N), B(N);\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i].x >> A[i].y;\n\t\t\n\t}\n\tClosest_Pair(N, A, &p1, &p2, &a);\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> B[i].x >> B[i].y;\n\t}\n\tClosest_Pair(N, B, &p1, &p2, &b);\n\t//cout << b << endl;\n\tprintf(\"%.6f\", sqrt((double)b / (double)a));\n\treturn(0);\n}\n*/\nint main(void){\n\tint N; cin >> N;\n\tLL a;\n\tP p1, p2;\n\tvector<P> A(N);\n\tfor (int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf\", &(A[i].x), &(A[i].y));\n\n\t}\n\tClosest_Pair(N, A, &p1, &p2, &a);\n//\tcout << p1.x<<endl<<p1.y<<endl<< p2.x<< endl << p2.y << endl;\n\t//cout << b << endl;\n\tprintf(\"%.7f\", a);\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf dist ( pt A, pt B ) { return abs( B - A ); }\n\nint n;\npt P[ MAXN ], extra[ MAXN ];\n\nbool cmpX( const pt &A, const pt &B ) {\n  //if( same( A.x, B.x ) ) return A.y < B.y;\n  return A.x < B.x;\n}\n\n/*\nlf sqr( lf x ) {\n  return x*x;\n}*/\n\nvoid merge( int f, int m, int t ){\n\tint total = t - f + 1;\n\tfor( int i = 0, l = f, r = m+1; i < total; ++i ){\n\t\tif( l == m+1 ){\n      extra[ i ] = P[ r++ ];\n\t\t}\n\t\telse if( r == t+1 ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse if( P[l].y < P[r].y ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse{\n\t\t  extra[ i ] = P[ r++ ];\n\t\t}\n\t}\n\tfor( int i = 0; i < total; ++i ){\n    P[ f+i ] = extra[ i ];\n\t}\n}\n\nlf solve( int f, int t ) {\n  if( f == t ) return oo;\n\tint mi = (f + t)/2;\n\tlf d = min( solve( f, mi ), solve( mi+1, t ) );\n\tmerge( f, mi, t );\n\tvector< int > idxs;\n\tfor( int i = f; i <= t; ++i ){\n\t\tif( fabs(P[mi].x - P[i].x) < d ) idxs.push_back( i );\n\t}\n\tfor( int i = 0; i < idxs.size(); ++i ){\n\t\tfor( int j = i+1; j < idxs.size() && fabs(P[ idxs[i] ].y - P[ idxs[j] ].y) < d; ++j ){\n\t\t\td = min( d, dist( P[ idxs[i] ], P[ idxs[j] ] ) );\n\t\t}\n\t}\n\treturn d;\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"CGL_5_A-in22.txt\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  sort( P, P+n, cmpX );\n  /*d = oo;\n  for( int i = 0; i < n; ++i ) {\n    for( int j = i+1; j < n; ++j ) {\n      d = min( d, dist(P[i],P[j]) );\n    }\n  }\n  cout << double(sqrt(d)) << '\\n';*/\n  cout << double( solve( 0, n-1 ) ) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief (n 2) = Θ(n^2)通りの点対を調べ、最近点対間距離を返す\n *\n * @param const point*P 点集合P\n * @param index_t n     Pの要素数\n */\nstatic elem_t brute_force_closest_pair(const point*P, index_t n)\n{\n    elem_t minimum = std::numeric_limits<elem_t>::max();\n    for (index_t i = 0; i < n; i++) {\n        for (index_t j = i + 1; j < n; j++) {\n            elem_t dist = abs(P[i] - P[j]);\n            minimum = std::min(minimum, dist);\n        }\n    }\n    return minimum;\n}\n\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 3) {  // |P| <= 3か否かを判定する\n        return brute_force_closest_pair(P, n);  // |P| <= 3ならば、虱潰で問題を解く\n    }\n\n    // |P| > 3ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら5個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = std::numeric_limits<elem_t>::max();\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if (P[i].y - p.y >= delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << setprecision(15) << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() {ld x, y; cin >> x >> y; return Point(x, y);} // ????????\\???\nbool eq(ld a, ld b) {return (abs(a - b) < eps);} // ????????????????????????\nld dot(Point a, Point b) {return real(conj(a) * b);} // ??????\nld cross(Point a, Point b) {return imag(conj(a) * b);} // ??????\n\n// ??´????????????\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// ????????????\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n\ntypedef vector<Point> Polygon;\n/* ????????\\?????? */\nld ClosestPair(int l, int r,const Polygon& poly){\n    int n = (int)poly.size();\n    if(n == 2) return abs(poly[l]-poly[l+1]);\n    if(n == 3) return min({abs(poly[l] - poly[l+1]),abs(poly[l] - poly[l+2]),abs(poly[l+1]-poly[l+2])});\n    \n    int m = l + (r-l)/2;\n    // ????????±??????\n    ld d = min(ClosestPair(l, m, poly),ClosestPair(m+1, r, poly));\n    \n    Polygon v;\n    for(int i = l; i <= r;i++){\n        if(abs(poly[i].real() - poly[m].real())< d){\n            v.emplace_back(Point(poly[i].imag(),poly[i].real()));\n        }\n    }\n    sort(v.begin(),v.end());\n    for(int i = 0; i < (int)v.size();i++){\n        for(int j = i + 1; j < (int)v.size();j++){\n            if(abs(v[i].real() - v[j].real()) > d)break;\n            d = min(d,abs(v[i]-v[j]));\n        }\n    }\n    return d;\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int n ;cin >> n;\n    Polygon ps;\n    for(int i = 0;i < n;i++) ps.emplace_back(input_point());\n    cout << fixed << setprecision(10) << ClosestPair(0, (int)ps.size()-1, ps) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef complex<double> Point;\nconst double eps = 1e-9;\nconst int N = 1e5+10;\nconst double inf = 1e6;\n\nbool eq(const double &a,const double &b)\n{\n    return abs(a-b)<eps;\n}\n\nbool cmp(const Point &a,const Point &b)\n{\n    if(eq(a.real(),b.real()))\n    {\n        return a.imag()<b.imag();\n    }else\n    {\n        return a.real()<b.real();\n    }\n}\n\nbool cmp1(const Point &a,const Point &b)\n{\n    if(eq(a.imag(),b.imag()))\n    {\n        return a.real()<b.real();\n    }else\n    {\n        return a.imag()<b.imag();\n    }\n}\n\nint get_low(const vector<Point> &arr,double x)\n{\n    int sz = arr.size();\n    int l=0,r=sz-1;\n    while(l<r)\n    {\n        int mid = (l+r)/2;\n        if(arr[mid].imag()<x)\n        {\n            l = mid+1;\n        }else\n        {\n            r = mid;\n        }\n    }\n    if(arr[l].imag()<x) return sz;\n    return l;\n}\n\ndouble closest_pair(Point *points,int sz)\n{\n    if(sz<4)\n    {\n        double ans = inf;\n        for(int i=0;i<sz;i++)\n        {\n            for(int j=0;j<i;j++)\n            {\n                double tmp = abs(points[i]-points[j]);\n                if(tmp < ans)\n                {\n                    ans = tmp;\n                }\n            }\n        }\n        return ans;\n    }\n    int mid =  sz/2;\n    double x = points[mid].real();\n    double d = min(closest_pair(points,mid),closest_pair(points+mid,sz-mid));\n    vector<Point> arr;\n    for(int i = mid;i<sz;i++)\n    {\n        if(points[i].real()-x < d+eps) arr.push_back(points[i]);\n    }\n    sort(arr.begin(),arr.end(),cmp1);\n    double ans = d;\n    for(int i=0;i<mid;i++)\n    {\n        if(x-points[i].real()<d+eps)\n        {\n            int low = get_low(arr,points[i].imag()-d-eps);\n            int high = get_low(arr,points[i].imag()+d+eps);\n            for(int j=low;j<high;j++)\n            {\n                double dist = abs(points[i]-arr[j]);\n                if(dist<ans)\n                {\n                    ans = dist;\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    Point points[N];\n\n    int n;\n    cin>>n;\n    for(int i=0;i<n;i++)\n    {\n        double x,y;\n        cin>>x>>y;\n        points[i] = Point(x,y);\n    }\n    sort(points,points+n,cmp);\n\n    cout<<fixed<<setprecision(10)<<closest_pair(points,n)<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn std::sqrt(sq(b.first-a.first)+sq(b.second-a.second));\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn -1;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP\n){\n\tint siz=xr-xl;\n\tif (siz <= 3) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tauto xM = xP[xl+siz/2].first;\n\tauto yL = std::vector<point_t>();\n\tauto yR = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {\n\t\treturn p.first <= xM;\n\t});\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {\n\t\treturn p.first > xM;\n\t});\n\tauto p1 = find_closest_optimized(xP,xl,xl+siz/2, yL);\n\tauto p2 = find_closest_optimized(xP,xl+siz/2,xr, yR);\n\tauto minD = (p1 <= p2) ? p1 : p2;\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n, yP);\n\tprintf(\"%.9f\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define MAX 100010\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\n\nPoint A[MAX];\n\nbool compare_y(Point a,Point b){\n  return (a.y-b.y)<eps;\n}\n\ndouble closest_pair(Point *a,int n){\n  if(n<=1)return inf;\n  int m=n/2;\n  double x=a[m].x;\n  double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n\n  vector<Point> b;\n  for(int i=0;i<n;i++){\n    if(fabs(a[i].x-x)>=d)continue;\n\n    for(int j=0;j<b.size();j++){\n      double dx=a[i].x-b[b.size()-j-1].x;\n      double dy=a[i].y-b[b.size()-j-1].y;\n      if(dy>=d)continue;\n      d=min(d,sqrt(dx*dx+dy*dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main()\n{\n  int x,y,n;\n  vector<Point> vp;\n\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y;\n\n  sort(A,A+n);\n\n  printf(\"%.10f\\n\",closest_pair(A,n));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\n/*struct P\n{\n\tdouble x, y;\n\tP(double x,double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};*/\n\n/*int ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}*/\n\ndouble dist(pdd a, pdd b)\n{\n\treturn (a.first - b.first)*(a.first - b.first) + (a.second - b.second)*(a.second - b.second);\n}\n\ndouble ClosestPair(vector<pdd>& points,int l,int r)\n{\n\tif (r - l == 1)\n\t{\n\t\treturn INF;\n\t}\n\tif (r - l == 2)\n\t{\n\t\treturn dist(points[l], points[l + 1]);\n\t}\n\tif (r - l == 3)\n\t{\n\t\treturn min(min(dist(points[l], points[l + 1]), dist(points[l], points[l + 2])), dist(points[l + 1], points[l + 2]));\n\t}\n\n\tint m = (l + r) / 2;\n\tdouble d = min(ClosestPair(points, l, m), ClosestPair(points, m, r));\n\n\tvector<pdd> tempP;\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tif ((points[l].first - points[m].first)*(points[l].first - points[m].first) < d)\n\t\t{\n\t\t\ttempP.emplace_back(make_pair(points[i].second, points[i].first));\n\t\t}\n\t}\n\tsort(tempP.begin(), tempP.end());\n\tfor (int i = 0; i != tempP.size(); i++)\n\t{\n\t\tfor (int j = i + 1; j != tempP.size(); j++)\n\t\t{\n\t\t\tif ((tempP[j].first - tempP[i].first)*(tempP[j].first - tempP[i].first) > d)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, dist(tempP[i], tempP[j]));\n\t\t}\n\t}\n\n\treturn d;\n}\n\nvector<pdd> points;\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tpoints.push_back(make_pair(x, y));\n\t}\n\n\tsort(points.begin(), points.end());\n\n\tprintf(\"%lf\\n\", sqrt(ClosestPair(points, 0, n)));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn 1e9;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP,\n\tint yl,int yr\n){\n\tint xsiz=xr-xl;\n\tint ysiz=yr-yl;\n\tif (xsiz <= 3) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tauto xM = xP[xl+xsiz/2].first;\n\tauto yL = std::vector<point_t>(ysiz);\n\tint left = -1, right = ysiz;\n\tfor(int i = 0; i < ysiz; i++){\n\t\tif (yL[i].first < xM) yL[++left] = yP[i];\n\t\telse                  yL[--right]= yP[i];\n\t}\n\tstd::reverse(yL.begin()+right,yL.end());\n\tauto p1 = find_closest_optimized(xP,xl,xl+xsiz/2,yL,0,right);\n\tauto p2 = find_closest_optimized(xP,xl+xsiz/2,xr,yL,right,ysiz);\n\tauto minD = sqrt((p1 <= p2) ? p1 : p2);\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n,yP,0,n);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ntypedef vector<P> G;\n\ndouble compare_y(const P &a, const P &b){\n  return a.Y < b.Y;\n}\n\ndouble convex_radius(G ps, int left, int right) {\n  if(right - left <= 1) return (double)INF;\n  int m = (right + left) / 2;\n  double d = min(convex_radius(ps, left, m), convex_radius(ps, m, right));\n  sort(ps.begin(), ps.begin(), compare_y);\n  for(int i = left ; i < right; ++i){\n    if(fabs(ps[i].X - ps[m].X) >= d) continue;\n    for(int j = i - 1; j >= left; --j){\n      if(ps[i].Y - ps[j].Y >= d) break;\n      d = min(d, abs(ps[i] - ps[j]));\n    }\n  }\n  return d;\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  SORT(g);\n  printf(\"%.10lf\\n\", convex_radius(g, 0, N));\n  //int s = 0, t = 1;\n  //REP(i, N)\n  //  FOR(j, i + 1, N)\n  //    if(norm(g[s] - g[t]) > norm(g[i] - g[j])){\n  //      s = i;\n  //      t = j;\n  //    }\n  //cout <<g[s] <<\", \" <<g[t] <<\", \" <<abs(g[s] - g[t]) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf dist ( pt A, pt B ) { return norm( B - A ); }\n\nint n;\npt P[ MAXN ], extra[ MAXN ];\n\nbool cmpX( const pt &A, const pt &B ) {\n  return A.x+EPS < B.x;\n}\n\nlf sqr( lf x ) {\n  return x*x;\n}\n\nvoid merge( int f, int m, int t ){\n\tint total = t - f + 1;\n\tfor( int i = 0, l = f, r = m+1; i < total; ++i ){\n\t\tif( l == m+1 ){\n      extra[ i ] = P[ r++ ];\n\t\t}\n\t\telse if( r == t+1 ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse if( P[l].y+EPS < P[r].y ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse{\n\t\t  extra[ i ] = P[ r++ ];\n\t\t}\n\t}\n\tfor( int i = 0; i < total; ++i ){\n    P[ f+i ] = extra[ i ];\n\t}\n}\n\nlf solve( int f, int t ) {\n  if( f == t ) return oo;\n\tint mi = (f + t)/2;\n\tlf mx = P[ mi ].x;\n\tlf d = min( solve( f, mi ), solve( mi+1, t ) );\n\tmerge( f, mi, t );\n\tvector< int > idxs;\n\tfor( int i = f; i <= t; ++i ){\n\t\tif( sqr(mx - P[i].x) < d+EPS ) idxs.push_back( i );\n\t}\n\tfor( int i = 0; i < idxs.size(); ++i ){\n\t\tfor( int j = i+1; j < idxs.size() && sqr(P[ idxs[i] ].y - P[ idxs[j] ].y) < d+EPS; ++j ){\n\t\t\td = min( d, dist( P[ idxs[i] ], P[ idxs[j] ] ) );\n\t\t}\n\t}\n\treturn d;\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"CGL_5_A-in25.txt\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  sort( P, P+n, cmpX );\n  cout << double( sqrt(solve( 0, n-1 )) ) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nconst int N = 200000 + 10;\nconst double EPS = 1e-7;\nconst double INF = 1e12;\nint sgn(double x) {\n    if (x < -EPS) return -1;\n    if (x > +EPS) return +1;\n    return 0;\n}\nstruct Vec {\n    double x,y;\n    Vec() {}\n    Vec(double x, double y) { \n        this->x = x, this->y = y; \n    }\n    void read() { \n        scanf(\"%lf %lf\", &x, &y); \n    }\n    void prt() {\n        printf(\"%.8f %.8f\\n\", x, y); \n    }\n    double len() { \n        return sqrt(x * x + y * y); \n    }\n    double len2() { \n        return x * x + y * y; \n    }\n    bool operator <(const Vec& o)const {\n        if(x == o.x)\n            return y < o.y;\n        return x < o.x;\n    }\n    Vec operator +(const Vec& o)const { \n        return Vec(x + o.x, y + o.y); \n    }\n    Vec operator -(const Vec& o)const { \n        return Vec(x - o.x, y - o.y); \n    }\n    Vec operator *(const double& k)const { \n        return Vec(k * x, k * y); \n    }\n    double operator *(const Vec& o)const {\n        return x * o.x + y * o.y; \n    }\n    double operator ^(const Vec& o)const {\n        return x * o.y - y * o.x; \n    }\n    Vec rotate(double ang){ \n        return Vec(x * cos(ang) - y * sin(ang), x * sin(ang) + y * cos(ang)); \n    }\n    Vec change(double l) { \n        if(len() < EPS) return *this; \n        return (*this) * (l/len()); \n    }\n};\n\n\nstruct Line {\n    Vec A1, A2;\n    Line() {}\n    Line(Vec A1, Vec A2) {\n        this->A1 = A1, this->A2 = A2;\n    }\n    double len() {\n        return (A2-A1).len();\n    }\n    double Len2() {\n        return (A2-A1).len2();\n    }\n};\n\n// P to L\ndouble disToLine(Vec P, Line L) {\n    return abs((P-L.A1)^(L.A2-L.A1)) / L.len();\n}\nVec projection(Vec P, Line L) {\n    double shadowLen = (P - L.A1) * (L.A2 - L.A1);\n    return L.A1 + (L.A2-L.A1).change(shadowLen);\n}\nVec rejection(Vec P, Line L) {\n    return projection(P,L) * 2 - P;\n}\nbool onseg(Vec P, Line L) {\n    if(disToLine(P, L) > EPS) return 0;\n    return (P-L.A1) * (P-L.A2) <= 0;\n}\nVec Lineintersect(Line L1, Line L2) {\n    // 0 ~ (L2.A1 - L1.A1) ^ (L2.A2 - L1.A1);\n    // 1 ~ (L2.A1 - L1.A2) ^ (L2.A2 - L1.A2);\n    double F0 = (L2.A1 - L1.A1) ^ (L2.A2 - L1.A1);\n    double F1 = (L2.A1 - L1.A2) ^ (L2.A2 - L1.A2);\n    if (abs(F1 - F0) < EPS) return Vec(INF, INF);\n    return L1.A1 + (L1.A2 - L1.A1) * (- F0 / (F1 - F0));\n}\nVec Segintersect(Line L1, Line L2) {\n    Vec P = Lineintersect(L1, L2);\n    if (P.x == INF) return P;\n    if (onseg(P, L1) && onseg(P, L2)) return P;\n    return Vec(INF, INF);\n}\nbool disToSeg(Vec P, Line L) {\n    double ans = min((P-L.A1).len(), (P-L.A2).len());\n    ans = min(ans, (P - projection(P,L)).len());\n    return ans;\n}\n// \n\nvector<Vec> convexHull(vector<Vec> v) {\n    sort(v.begin(), v.end());\n    vector<Vec> ans; ans.resize(2*v.size());\n    int top = 0, n = v.size();\n    if(n <= 1) return v;\n\n    for(int i = 0; i < n; ans[top++] = v[i++]) {\n        while (top > 1 && ((ans[top-1] - ans[top-2]) ^ (v[i] - ans[top-1])) < EPS) -- top;\n    }\n    for(int i = n-2, t = top; i >= 0; ans[top++] = v[i--]) {\n        while (top > t && ((ans[top-1] - ans[top-2]) ^ (v[i] - ans[top-1])) < EPS) -- top;\n    } \n    while(ans.size() >= top) ans.pop_back();\n    return ans;\n}\n\ndouble PolyArea(vector<Vec> v) {\n    double ans = 0;\n    int n = v.size();\n    //printf(\"n = %d\\n\", n);\n    for(int i = 0; i < v.size(); i ++) {\n        ans = ans + (v[i] ^ v[(i+1)%n]);\n    }\n    return abs(ans) / 2;\n}\n\nvector<Vec> convexCut(vector<Vec> v, Vec P1, Vec P2) {\n    vector<Vec> ans;\n    for(int i=0;i<v.size();i++) {\n        int d1 = sgn((P2-P1)^(v[i]-P1));\n        int d2 = sgn((P2-P1)^(v[(i+1)%v.size()]-P1));\n        if (d1 >= 0) ans.push_back(v[i]);\n        if (d1 * d2 < 0) ans.push_back(Lineintersect(Line(P1,P2), Line(v[i],v[(i+1)%v.size()])));\n    }\n    return ans;\n}\n\ndouble cloestPair(vector<Vec> v) {\n    if (v.size() <= 1) return INF;\n\n    sort(v.begin(), v.end());\n    vector<Vec> vL, vR;\n    int mid = v.size() / 2;\n    for (int i = 0; i < v.size(); i ++) {\n        if (i < mid)\n            vL.push_back(v[i]);\n        else\n            vR.push_back(v[i]);\n    }\n    double d = min(cloestPair(vL), cloestPair(vR));\n    \n    vector<Vec> strip;\n    for (int i = 0; i < v.size(); i ++) {\n        if (abs(v[mid].x - v[i].x) <= d + EPS) \n            strip.push_back(v[i]);\n    }\n\n    for (int i = 0; i < strip.size(); i ++) swap(strip[i].x, strip[i].y);\n    sort(strip.begin(), strip.end());\n    for (int i = 0; i < strip.size(); i ++) swap(strip[i].x, strip[i].y);\n\n    for (int i = 0; i < strip.size(); i ++) {\n        for (int j = i + 1; j < strip.size(); j ++) {\n            if (strip[j].y - strip[i].y > d + EPS) break;\n            d = min(d, (strip[j]-strip[i]).len());\n        }\n    }\n\n    return d;\n}\n\nint n; vector<Vec> v;\nint main(){\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i ++) {\n        Vec P; P.read(); v.push_back(P);\n    }\n    printf(\"%.8f\\n\", cloestPair(v));\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\n/*\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    //two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n\n    two_dimensional_qsort(p_xy, n0, n-1, 1);\n\n    \n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n*/\nbool compare_y(pair<double, double> a,pair<double, double> b){\n    return a.second<b.second;\n}\n\ndouble length_of_the_nearest_point_to(pair<double, double> a[100000], int n){\n    if(n<=1)return 999999999.9;\n    int m=n/2;\n    double x=a[m].first;\n    double d=min(length_of_the_nearest_point_to(a, m), length_of_the_nearest_point_to(a+m, n-m));\n    inplace_merge(a, a+m, a+n, compare_y);\n    vector<pair<double, double>>b;\n    for(int i=0; i<n; i++){\n        if(fabs(a[i].first-x)>=d)continue;\n        for(int j=0; j<b.size(); j++){\n            double dx=a[i].first-b[b.size()-j-1].first;\n            double dy=a[i].second-b[b.size()-j-1].second;\n            if(dy>=d)break;\n            d=min(d,sqrt(dx*dx+dy*dy));\n            \n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n                                      \n                                      \n                                      \nint main(int argc, const char * argv[]){\n    int n;\n    while(cin>>n){\n        pair<double, double> a[100000];\n        for(int i=0; i<n; i++){\n            cin>>a[i].first>>a[i].second;\n        }\n        sort(a, a+n);\n        double ans = length_of_the_nearest_point_to(a, n);\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n    /*\n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        //cout<<\"qaaa\";\n        two_dimensional_qsort(p_xy, 0, n-1, 0);\n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n     */\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    const int loops = 111;\n    \n    int n_1 = n - 1;\n    \n    for(int i = 0; i < n_1; i++)\n    {\n        int r = min(loops, n_1 - i);\n        \n        for(char j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n_1; i++)\n    {\n        int r = min(loops, n_1 - i);\n        \n        for(char j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + j].first - p2[i].first) * (p2[i + j].first - p2[i].first) + (p2[i + j].second - p2[i].second) * (p2[i + j].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.9f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<utility>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n\ntypedef pair<double, double> point;\ntypedef point* data;\n\ninline double dist(const point &a, const point &b)\n{\n    double dx = a.first - b.first, dy = a.second - b.second;\n    return sqrt(dx * dx + dy * dy);\n}\n\nbool y_less(const point &P1, const point &P2){ return P1.second < P2.second; }\nbool y_greater(const point &P1, const point &P2){ return P1.second > P2.second; }\n\ndouble closest(data P, int n)\n{\n    if(n <= 1) return 1000;\n    if(n == 2) return dist(P[0], P[1]);\n    int m = n / 2;\n    sort(P, P + n, y_less); // y_sort, down to up.\n\tdouble median = P[m].second;\n    double d = min(closest(P, m), closest(P + m, n - m));\n\n    sort(P, P + m, y_less);\n    sort(P + m, P + n, y_greater);\n    int a, b;\n    for(a = m - 1; a > 0; a--){ if(P[a].second < median - d) break; }\n    for(b = n - 1; b > m; b--){ if(P[b].second > median + d) break; }\n    sort(P + a, P + m);\n    sort(P + b, P + n);\n\n    // x_sort, left to right.\n    int u, v, i, j;\n    u = i = a, v = j = b;\n    while(i < m && j < n){\n        if(P[u].first < P[v].first){\n            for(i = a; i < m; i++){\n                if(P[i].first >= P[v].first){ u = i; break; }\n                if(P[v].first - P[i].first >= d){ a++; }\n                else{\n                    d = min(d, dist(P[v], P[i]));\n                }\n            }\n        }else{\n            for(j = b; j < n; j++){\n                if(P[j].first > P[u].first){ v = j; break; }\n                if(P[u].first - P[j].first >= d){ b++; }\n                else{\n                    d = min(d, dist(P[u], P[j]));\n                }\n            }\n        }\n    };\n    return d;\n}\n\nint main()\n{\n\tint i, n;\n\tdouble x, y;\n\tscanf(\"%d\", &n);\n\tdata P;\n\tP = new point [n];\n\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tP[i] = make_pair(x, y);\n\t}\n\tprintf(\"%.12f\\n\", closest(P, n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\nconst int MAXSIZE = 1e5+7;\nconst int INF = 0x3fffffff;\nstruct point \n{\n\tdouble x, y;\n};\ntypedef point Point;\nint keep[MAXSIZE];\nPoint dots[MAXSIZE];\nbool comxy(Point a, Point b){\n\tif(a.x != b.x)\n\t\treturn a.x < b.x;\n\treturn a.y < b.y;\n}\nbool cmpy(int a, int b){\n\treturn dots[a].y < dots[b].y;\n}\ndouble distent(int a, int b){\n\treturn sqrt((dots[a].x - dots[b].x) * (dots[a].x - dots[b].x) + (dots[a].y - dots[b].y) * (dots[a].y - dots[b].y));\n}\ndouble divSolve(int left, int right){\n\tdouble dis = INF;\n\tif(left == right)\n\t\treturn dis;\n\tif(left + 1 == right)\n\t\treturn distent(left, right);\n\tint mid = (left + right) >> 1;\n\tdouble wayf = divSolve(left, mid);\n\tdouble ways = divSolve(mid + 1, right);\n\tdis = min(wayf, ways);\n\tint k = 0;\n\tfor(int i = left; i <= right; i++){\n\t\tif(fabs(dots[mid].x - dots[i].x) <= dis){\n\t\t\tkeep[k++] = i;\n\t\t}\n\t}\n\tsort(keep,keep+k,cmpy);\n\tfor(int i = 0; i < k; i++){\n\t\tfor(int j = i+1; j < k && (dots[keep[j]].y - dots[keep[i]].y) < dis; j++){\n\t\t\tdis = min(dis, distent(keep[j],keep[i]));\n\t\t}\n\t}\n\treturn dis;\n}\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tmemset(keep,0,sizeof(keep));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%lf %lf\",&dots[i].x, &dots[i].y);\n\t\t}\n\t\tsort(dots, dots+n, comxy);\n\t\tdouble res = divSolve(0,n-1);\n\t\tprintf(\"%0.10lf\\n\", res);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ntypedef vector<P> G;\n\ndouble compare_y(const P &a, const P &b){\n  return a.Y < b.Y;\n}\n\ndouble convex_radius(G ps, int left, int right) {\n  if(right - left <= 1) return (double)INF;\n  int m = (right + left) / 2;\n  double d = min(convex_radius(ps, left, m), convex_radius(ps, m, right));\n  sort(ps.begin(), ps.begin(), compare_y);\n  for(int i = left ; i < right; ++i){\n    if(fabs(ps[i].X - ps[m].X) >= d) continue;\n    for(int j = i - 1; j >= left; --j){\n      if(ps[i].Y - ps[j].Y >= d) break;\n      d = min(d, abs(ps[i] - ps[j]));\n    }\n  }\n  return d;\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  SORT(g);\n  printf(\"%.10lf\\n\", convex_radius(g, 0, N));\n  int s = 0, t = 1;\n  REP(i, N)\n    FOR(j, i + 1, N)\n      if(norm(g[s] - g[t]) > norm(g[i] - g[j])){\n        s = i;\n        t = j;\n      }\n  cout <<g[s] <<\", \" <<g[t] <<\", \" <<abs(g[s] - g[t]) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&min(memo,ans+0.003) >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans =(min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/30))  \n #define Fun2(j,n) for(int j=i+(int)(n/30);j<n;j=j+(int)(n/30))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=200;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16??????????????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   //?°?16????????????????????????????????? \n   minx=minx-1;\n   miny=miny-1;\n   maxx=maxx+1;\n   maxy=maxy+1;\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=3;j>=0;j--)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*(3-j)+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n   /*\n   for(int i=0;i<16;i++)\n   {\n     for(int j=0;j<num_point[i];j++)\n     {\n       cout<<wu[i][j].x<<\" \"<<wu[i][j].y<<endl;        \n     }        \n   }\n   */\n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       //real_min=(point[0].x-point[1].x)*(point[0].x-point[1].x)+(point[0].y-point[1].y)*(point[0].y-point[1].y);\n       real_min=fun_min;\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A?????? \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct node{\n  int dim;\n  vector<double>v;\n};\n \ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n \ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n \nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n \ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n \n  vector<node>res;\n \n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n \n    double dist=d(p,S)/(4*p.dim)*3;\n \n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n \n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    if(S.size() == nextS.size())break;\n    S=nextS;    \n  }\n \n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n   \n  return ans;\n}\n \nint main(void){\n \n  int n;\n  cin >> n;\n \n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n \n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nconst double eps = 1e-10;\nconst double inf = 1e+10;\nconst double pi = acos(-1.0);\nint sgn(double a) { return a < -eps ? -1 : a > eps; }\nusing P = complex<double>;\nnamespace std {\n  istream& operator>>(istream& i, P& p) { double x, y; i >> x >> y; p = P(x, y); return i; }\n  ostream& operator<<(ostream& o, const P& p) { o << real(p) << ' ' << imag(p); return o; }\n  bool operator<(const P& p, const P& q) { return sgn(real(p) - real(q)) ? sgn(real(p) - real(q)) < 0 : sgn(imag(p) - imag(q)) < 0; }\n  bool operator>(const P& p, const P& q) { return q < p; }\n  bool operator<=(const P& p, const P& q) { return !(p > q); }\n  bool operator>=(const P& p, const P& q) { return !(p < q); }\n}\nbool eq(const P& p, const P& q) { return !(p < q) and !(p > q); }\ndouble dot(const P& p, const P& q) { return real(conj(p) * q); }\ndouble cross(const P& p, const P& q) { return imag(conj(p) * q); }\n\nbool comp_y(const P& p, const P& q) {\n  return sgn(imag(p) - imag(q)) ? sgn(imag(p) - imag(q)) < 0 : sgn(real(p) - real(q)) < 0;\n}\n\ndouble closest_pair(auto first, auto last) {\n  int n = distance(first, last);\n  if (n <= 1) return inf;\n  auto mid = first + n / 2;\n  double x = real(*mid), d = min(closest_pair(first, mid), closest_pair(mid, last));\n  inplace_merge(first, mid, last, comp_y);\n  V<P> a;\n  for (auto itr = first; itr != last; ++itr) {\n    if (sgn(abs(real(*itr) - x) - d) > 0) continue;\n    for (auto itr2 = a.rbegin(); itr2 != a.rend(); ++itr2) {\n      if (sgn(imag(*itr - *itr2) - d) > 0) break;\n      d = min(d, abs(*itr - *itr2));\n    }\n    a.push_back(*itr);\n  }\n  return d;\n}\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  V<P> a(n); for (int i = 0; i < n; i++) cin >> a[i];\n  sort(a.begin(), a.end());\n  cout << fixed << setprecision(10) << closest_pair(a.begin(), a.end()) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nint dcmp(double d) {\n    if (fabs(d) < EPS) {\n        return 0;\n    }\n    else {\n        return d < 0? -1 : 1;\n    }\n}\n\nstruct Vector {\n    double x, y;\n    Vector(double x = 0, double  y = 0):x(x), y(y) {\n    }\n     \n    bool operator<(const Vector& other) const {\n        return dcmp(x - other.x) < 0 || (dcmp(x - other.x) == 0 && dcmp(y - other.y) < 0);\n    }\n};\n\ntypedef Vector Point;\n\ndouble dist(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nbool cmpY(const Point& a,  const Point& b) {\n    return dcmp(a.y - b.y) < 0 || (dcmp(a.y - b.y) == 0 && dcmp(a.x - b.x) < 0);\n}\n\ndouble combine(vector<Point>& p, int l, int m, int r, double leftSmall, double rightSmall) {\n    double d = min(leftSmall, rightSmall);\n    double x = (p.at(m).x + p.at(m + 1).x)/2;\n    \n    vector<Point> strip;\n        \n    for (int i = m; i >= l && dcmp(x - p.at(i).x - d) <= 0; i--) {\n        strip.push_back(p.at(i));\n    }\n    for (int j = m + 1; j <= r &&dcmp(p.at(j).x - x - d) <= 0; j++) {\n        strip.push_back(p.at(j));\n    } \n    \n    sort(strip.begin(), strip.end(), cmpY);\n    \n    int size = strip.size();\n    \n    for (int i = 0; i < size; i++) {\n        for (int j = i+1; j < size && dcmp(strip[j].y - strip[i].y - d) < 0; j++) {\n            if (dcmp(dist(strip[i], strip[j]) - d) < 0) {\n                d = dist(strip[i], strip[j]);\n            }\n        }\n    }\n    return d;\n}\n\n//naive n^2 method\ndouble combine1(vector<Point>& p, int l, int m, int r, double leftSmall, double rightSmall) {\n    double d = min(leftSmall, rightSmall);\n    double x = (p.at(m).x + p.at(m + 1).x)/2;\n    \n    double best = DBL_MAX;\n    \n    for (int i = m; i >= l && dcmp(x - p.at(i).x - d) <= 0; i--) {\n        for (int j = m + 1; j <= r &&dcmp(p.at(j).x - x - d) <= 0; j++) {\n            best = min(best, dist(p.at(i), p.at(j)));\n        } \n    }\n    return min(best, d);\n}\n\n\ndouble solve(vector<Point>& p, int l, int r) {\n    if (l >= r) {\n        return DBL_MAX;\n    }\n    int m = (l + r) / 2;\n    \n    double leftSmall = solve(p, l, m);\n    double rightSmall = solve(p, m + 1, r);\n    \n    return combine(p, l, m, r, leftSmall, rightSmall);\n}\n\nint main() {\n    int n; \n    cin >> n;\n    vector<Point> p(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i].x >> p[i].y;\n    }\n    \n    sort(p.begin(), p.end());\n    \n    double ans = solve(p, 0, n - 1);\n    \n    cout << fixed << setprecision(8) << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\n\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  if (r - l == 2) {\n    return PointPoint(ps[l], ps[l + 1]);\n  }\n  if (r - l == 3) {\n    PointPoint a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return Closer(a, Closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  Points pos[2];\n  for (int i = l; i < r; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) pos[i < mid].push_back(ps[i]);\n  }\n  for (const auto &i : pos[0]) {\n    for (const auto &j : pos[1]) {\n      if (Distance(i, j) < d) {\n        d = Distance(i, j);\n        res = PointPoint(i, j);\n      }\n    }\n  }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  PointPoint res = ClosestPairUtil(ps, 0, ps.size());\n  res.first = rotate(-0.1, res.first);\n  res.second = rotate(-0.1, res.second);\n  return res;\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  sort(p.begin(), p.end());\n  PointPoint pp = ClosestPair(p);\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n  // cerr << pp.first << \" \" << pp.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nstatic const double EPS=1e-12;\nstatic const double INF=1e24;\n\nusing Point=complex<double>;\nusing Plane=vector<Point>;\nusing Polygon=vector<Point>;\n\nbool operator<(const Point &a, const Point &b) {\n    return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n}\n\ndouble cross_prod(const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot_prod(const Point &a, const Point &b) {\n    return real(conj(a)*b);\n}\n\nenum {\n    ONLINE_FRONT=-2,\n    CLOCKWISE,\n    ON_SEGMENT,\n    COUNTER_CLOCKWISE,\n    ONLINE_BACK,\n};\n\nint ccwise(Point a, Point b, Point c) {\n    b -= a; c -= a;\n\n    if (cross_prod(b, c) > 0) {\n        return COUNTER_CLOCKWISE;\n    } else if (cross_prod(b, c) < 0) {\n        return CLOCKWISE;\n    } else if (dot_prod(b, c) < 0) {\n        return ONLINE_BACK;\n    } else if (norm(b) < norm(c)) {\n        return ONLINE_FRONT;\n    } else {\n        return ON_SEGMENT;\n    }\n}\n\ntemplate <class LineType>\nint ccwise(LineType l, Point p) {\n    return ccwise(l.first, l.second, p);\n}\n\nstruct Line: public pair<Point, Point> {\n    Line() {}\n    Line(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\nstruct LineSeg: public pair<Point, Point> {\n    LineSeg() {}\n    LineSeg(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\npair<Point, Point> closest_pair(Polygon g) {\n    size_t V=g.size(), s=0, t=1, m=2;\n    vector<size_t> S(V);\n    sort(g.begin(), g.end(), [](const Point &a, const Point &b) {\n        return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n    });\n\n    double res=abs(g[s]-g[t]);\n    for (size_t i=2; i<V; S[m++]=i++)\n        for (size_t j=0; j<m; ++j) {\n            if (res > abs(g[S[j]]-g[i]))\n                res = abs(g[s=S[j]]-g[t=i]);\n\n            if (real(g[S[j]]) < real(g[i]-res))\n                S[j--] = S[--m];\n        }\n\n    return make_pair(g[s], g[t]);\n}\n\ntemplate <class RandomIt>\npair<Point, Point> closest_pair(RandomIt first, RandomIt last) {\n    size_t n=last-first;\n    if (n < 2)\n        return make_pair(Point(-INF, -INF), Point(INF, INF));\n\n    RandomIt mid=first+n/2;\n    pair<Point, Point> p1=closest_pair(first, mid);\n    pair<Point, Point> p2=closest_pair(mid, last);\n    inplace_merge(first, mid, last, [](const Point &lhs, const Point &rhs) {\n        return imag(lhs) < imag(rhs);\n    });\n\n    double d1=abs(p1.first-p1.second), d2=abs(p2.first-p2.second);\n    double d=(d1<d2? d1:d2);\n    pair<Point, Point> res=(d1<d2? p1:p2);\n\n    double x=imag(*mid);\n    vector<Point> b;\n    for (RandomIt it=first; it<last; ++it) {\n        if (abs(real(*it)-x) >= d) continue;\n\n        for (size_t j=0; j<b.size(); ++j) {\n            double dx=real(*it)-real(b[b.size()-j-1]);\n            double dy=imag(*it)-imag(b[b.size()-j-1]);\n            if (dy >= d) break;\n\n            if (d > sqrt(dx*dx + dy*dy)) {\n                d = sqrt(dx*dx + dy*dy);\n                res = make_pair(*it, b[b.size()-j-1]);\n            }\n        }\n        b.push_back(*it);\n    }\n\n    return res;\n}\n\nint main() {\n    size_t n;\n    scanf(\"%zu\", &n);\n\n    Polygon g(n);\n    for (size_t i=0; i<n; ++i) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        g[i] = Point(x, y);\n    }\n\n    pair<Point, Point> p=closest_pair(g.begin(), g.end());\n    printf(\"%.9f\\n\", abs(p.first-p.second));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <vector>\n\n/*\n * Closest pair.\n */\nclass ClosestPair {\nprivate:\n  std::vector<double> x, y;\n  struct x_cmp {\n    const ClosestPair &cp;\n    x_cmp(const ClosestPair &cp) : cp(cp) {} \n    bool operator() (int i, int j) {\n      return cp.x[i] < cp.x[j];\n    }\n  };\n  struct y_cmp {\n    const ClosestPair &cp;\n    y_cmp(const ClosestPair &cp) : cp(cp) {} \n    bool operator() (int i, int j) {\n      return cp.y[i] < cp.y[j];\n    }\n  };\n  x_cmp xc;\n  y_cmp yc;\n  double gl_mi; // global minimum;\n  double dist2(int i, int j) const {\n    return pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2);\n  }\n\n  void min_brute_force(const std::vector<int> & v) {\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n\tif (i == j) {\n\t  continue;\n\t}\n\tgl_mi = std::min(gl_mi, dist2(v[i], v[j]));\n      }\n    }\n  }\n\n\n  void min_strip(const std::vector<int> &v) {\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j < n && pow(y[v[j]] - y[v[i]], 2) < gl_mi; ++j) {\n\tgl_mi = std::min(gl_mi, dist2(v[i], v[j]));\n      }\n    }\n  }\n\n  /*\n   */\n  void min_pair_util(const std::vector<int> &vx) {\n    int n = vx.size();\n    if (n <= 4) {\n      min_brute_force(vx);\n      return;\n    }\n    // divide at middle\n    int mid = n / 2;\n    double mid_x = x[vx[mid]];\n    min_pair_util(std::vector<int>(vx.begin(), vx.begin() + mid));\n    min_pair_util(std::vector<int>(vx.begin() + mid, vx.end()));\n    std::vector<int> strip;\n    for(int i = 0; i < n; ++i) {\n      if (pow(x[vx[i]] - mid_x, 2) < gl_mi) {\n\tstrip.push_back(vx[i]);\n      }\n    }\n    std::sort(strip.begin(), strip.end(), yc);\n    min_strip(strip);\n  }\n  ClosestPair(const std::vector<double> &xs, const std::vector<double> &ys) : x(xs), y(ys), xc(*this), yc(*this), gl_mi(1.0 / 0.0) {\n  }\n  double internal_solve(void) {\n    int n = x.size();\n    std::vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n      v[i] = i;\n    }\n    std::sort(v.begin(), v.end(), xc);\n    min_pair_util(v);\n    return std::sqrt(gl_mi);\n  }\npublic:\n  static double solve(const std::vector<double> &xs, const std::vector<double> &ys) {\n    return ClosestPair(xs, ys).internal_solve();    \n  }\n};\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\n#include <cstdio>\n#include <iostream>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef pair<int, int> PI;\nconst double EPS=1e-9;\n\nint main(void){\n  int n;\n  cin >> n;\n  vector<double> x(n), y(n);\n  REP(i, 0, n) {\n    cin >> x[i] >> y[i];\n  }\n  printf(\"%.9f\\n\", ClosestPair::solve(x, y));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return norm( B - A ); }\n\nint n;\nlf d;\npt Px[ MAXN ];\nvector< pt> Py;\n\nbool cmpX( const pt &A, const pt &B ) {\n  return B.x > A.x + EPS;\n}\n\nbool cmpY( const pt &A, const pt &B ) {\n  return B.y > A.y + EPS;\n}\n\nlf minimum( const lf &A, const lf &B ) {\n  if( A+EPS < B ) return A;\n  return B;\n}\n\nvoid merge( const vector<pt> &P, int n ) {\n  for( int i = 0; i < n; ++i ) {\n    for( int j = i+1; j < n && (P[j].y - P[i].y)*(P[j].y - P[i].y) + EPS < d ; ++j ) {\n      d = minimum( d, dist( P[i], P[j]) );\n    }\n  }\n}\n\nvoid solve( pt *Px, vector<pt> &Py, int n ) {\n  if( n <= 3 ) {\n    for( int i = 0; i < n; ++i ) {\n      for( int j = i+1; j < n; ++j ) {\n        d = minimum( d, dist(Px[i], Px[j]) );\n      }\n    }\n    return;\n  }\n  int mi = n/2;\n  vector<pt> Pl, Pr;\n  for( int i = 0; i < n; ++i ) {\n    if( SIZE(Pr) == mi ) {\n      Pl.PB( Py[ i ] );\n    }\n    else if( SIZE(Pl) == mi ) {\n      Pr.PB( Py[ i ] );\n    }\n    else if( Py[i].x+EPS < Px[mi].x ) {\n      Pl.PB( Py[ i ] );\n    }\n    else {\n      Pr.PB( Py[ i ] );\n    }\n  }\n\n  solve( Px, Pl, SIZE( Pl ) );\n  solve( Px+SIZE( Pl ), Pr, SIZE( Pr ) );\n\n  vector<pt> extra;\n  for( auto &p : Py ) {\n    if( ( p.x - Px[mi].x )*( p.x - Px[mi].x ) + EPS < d ) {\n      extra.PB( p );\n    }\n  }\n\n  merge( extra, SIZE( extra ) );\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> Px[i];\n    Py.PB( Px[ i ] );\n  }\n  sort( Px, Px+n, cmpX );\n  sort( Py.begin(), Py.end(), cmpY );\n  d = oo;\n  solve( Px, Py, n );\n  cout << double(sqrt(d)) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    const int loops = 107;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + j].first - p2[i].first) * (p2[i + j].first - p2[i].first) + (p2[i + j].second - p2[i].second) * (p2[i + j].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.9f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n#define DBG(n) n;\n#else\n#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n#define X real()\n#define Y imag()\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\t\n\tbool operator == (const point& a,const point& b) {\n\t\treturn (abs(a.real() - b.real()) < EPS && abs(a.imag() - b.imag()) < EPS);\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\nstruct segment : public vector<point> {\n\tsegment(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\tif(intersectSP(s,t[0]) || intersectSP(s,t[1]) || intersectSP(t,s[0]) || intersectSP(t,s[1]))return true;\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n//交点\npoint crosspoint(const segment &l, const segment &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1;i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n/*多角形内包判定\nOUT:0\nON:1\nIN:2\n*/\n\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n//見えるか(可視グラフ用) \nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a+b)/2.0;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (imag(d) < imag(c)) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (imag(c) <= imag(m) && imag(m) < imag(d))  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= 0) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble x = p.real() * cos(rad) - p.imag() * sin(rad);\n\tdouble y = p.imag() * cos(rad) + p.real() * sin(rad);\n\treturn point(x, y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\n//凸包判定\nbool isConvex(vector<point> poly){\n\tint sz = poly.size();\n\tREP(i,sz){\n\t\tint tmp = ccw(poly[i],poly[(i+1)%sz],poly[(i+2)%sz]);\n\t\tif(tmp == -1){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble convex_diameter(const vector<point> &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nvector<point> convex_cut(const vector<point> P, const segment& l) {\n  vector<point> Q;\n  for (int i = 0; i < P.size(); ++i) {\n    point A = curr(P, i), B = next(P, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(segment(A, B), l));\n  }\n  return Q;\n}\n\npair<point,point> closestPair(vector<point> p) {\n  int n = p.size(), s = 0, t = 1, m = 2, S[n]; S[0] = 0, S[1] = 1;\n  sort(ALL(p)); // \"p < q\" <=> \"p.x < q.x\"\n  double d = norm(p[s]-p[t]);\n  for (int i = 2; i < n; S[m++] = i++) REP(j, m) {\n    if (norm(p[S[j]]-p[i])<d) d = norm(p[s = S[j]]-p[t = i]);\n    if (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n  }\n  return make_pair( p[s], p[t] );\n}\n\nint main() {\n\tint n;cin >> n;\n\tvector<point> v;\n\tREP(i,n){\n\t\tdouble a,b;cin >> a >> b;\n\t\tv.PB(point(a,b));\n\t}\n\t\n\tpair<point,point> ans = closestPair(v);\n\t\n\tcout << Decimal << abs(ans.SE-ans.FI) << endl;\n\t\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n\nusing ld = double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ntemplate<class iter>\ntuple<ld, P, P> closest_pair(iter left, iter right) {\n    int n = distance(left, right);\n\n    if(n <= 1){\n        return make_tuple(numeric_limits<ld>::max(), *left, *left);\n    }\n\n    if(n == 2){\n        if(left[0].imag() > left[1].imag()) swap(left[0], left[1]);\n        return make_tuple(norm(left[0]-left[1]), left[0], left[1]);\n    }\n\n    iter middle = next(left, n/2);\n    auto d = min(closest_pair(left, middle), closest_pair(middle, right));\n    inplace_merge(left, middle, right, [](const P &a, const P &b){\n            return a.imag() < b.imag();\n        });\n\n    vector<iter> around;\n    for(iter i = left; i != right; ++i){\n        ld dx = fabs(i->real() - middle->real());\n        ld &opt = get<0>(d);\n        if(dx*dx >= opt) continue;\n        for(auto j = around.rbegin(); j != around.rend(); ++j){\n            ld dx = i->real() - (**j).real();\n            ld dy = i->imag() - (**j).imag();\n            if(dy*dy >= opt) break;\n            ld norm = dx*dx + dy*dy;\n            if(get<0>(d) > norm){\n                d = make_tuple(norm, *i, **j);\n            }\n        }\n        around.push_back(i);\n    }\n    return d;\n};\n\n// http://www.spoj.com/problems/CLOPPAIR/\n// 18124516\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout << fixed << setprecision(6) << endl;\n    int n;\n    cin >> n;\n    vector<P> a;\n    rep(i,n){\n        ld x,y;\n        cin >> x >> y;\n        a.emplace_back(x,y);\n    }\n    ld z;\n    P x, y;\n    sort(all(a));\n    tie(z, x, y) = closest_pair(all(a));\n    cout << sqrt(z) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ninline double Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\ninline PointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\n\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  if (r - l == 2) {\n    return PointPoint(ps[l], ps[l + 1]);\n  }\n  if (r - l == 3) {\n    PointPoint a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return Closer(a, Closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  Points pos[2];\n  for (int i = l; i < r; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) pos[i < mid].push_back(ps[i]);\n  }\n  for (const auto &i : pos[0]) {\n    for (const auto &j : pos[1]) {\n      if (Distance(i, j) < d) {\n        d = Distance(i, j);\n        res = PointPoint(i, j);\n      }\n    }\n  }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  PointPoint res = ClosestPairUtil(ps, 0, ps.size());\n  res.first = rotate(-0.1, res.first);\n  res.second = rotate(-0.1, res.second);\n  return res;\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  sort(p.begin(), p.end());\n  PointPoint pp = ClosestPair(p);\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n  // cerr << pp.first << \" \" << pp.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct node{\n  int dim;\n  vector<double>v;\n};\n\ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n\ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n\n  vector<node>res;\n\n  while(!S.empty()){\n    node p=S[rand()%S.size()];\n\n    double dist=d(p,S)/(4*p.dim);\n\n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n\n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    \n    S=res=nextS;    \n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n\n  return ans;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n\n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <complex>\n#include <utility>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <tuple>\n#include <cmath>\n#include <bitset>\n#include <cctype>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <numeric>\n#include <functional>\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(ll i=ll(a);i<ll(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define PRINT(V) cout << V << \"\\n\"\n#define SORT(V) sort((V).begin(),(V).end())\n#define RSORT(V) sort((V).rbegin(), (V).rend())\nusing namespace std;\nusing ll = long long;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ninline void Yes(bool condition){ if(condition) PRINT(\"Yes\"); else PRINT(\"No\"); }\ntemplate<class itr> void cins(itr first,itr last){\n    for (auto i = first;i != last;i++){\n        cin >> (*i);\n    }\n}\ntemplate<class itr> void array_output(itr start,itr goal){\n    string ans = \"\",k = \" \";\n    for (auto i = start;i != goal;i++) ans += to_string(*i)+k;\n    if (!ans.empty()) ans.pop_back();\n    PRINT(ans);\n}\nll gcd(ll a, ll b) {\n    return a ? gcd(b%a,a) : b;\n}\nconst ll INF = 1e15;\nconst ll MOD = 1000000007;\nconst ll MOD2 = 998244353;\ntypedef pair<ll,ll> P;\ntypedef pair<double,double> point;\nconst ll MAX = 2010;\nconstexpr ll nx[8] = {1,0,-1,0,-1,-1,1,1};\nconstexpr ll ny[8] = {0,1,0,-1,-1,1,-1,1};\nll n;\npoint g[100010];\nbool cmp_y(point a,point b){\n    return a.second < b.second;\n}\ndouble closest_pair(point *a,ll n){\n    if (n <= 1) return INF;\n    ll m = n/2;\n    double x = a[m].first;\n    double d = min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,cmp_y);\n    vector<point> b;\n    rep(i,n){\n        if (fabs(a[i].first-x) >= d) continue;\n        rep(j,b.size()){\n            double dx = a[i].first-b[b.size()-j-1].first;\n            double dy = a[i].second-b[b.size()-j-1].second;\n            if (dy >= d) break;\n            chmin(d,sqrt(dx*dx+dy*dy));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    double x,y;\n    cin >> n;\n    rep(i,n){\n        cin >> x >> y;\n        g[i] = point(x,y);\n    }\n    sort(g,g+n);\n    printf(\"%.10f\\n\",closest_pair(g,n));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn 1e9;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP,\n\tint yl,int yr\n){\n\tint xsiz=xr-xl;\n\tint ysiz=yr-yl;\n\tif (xsiz <= 3) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tif(ysiz==0)return 1e9;\n\t//printf(\"%d %d %d %d\\n\",xl,xr,yl,yr);\n\tauto xM = xP[xl+xsiz/2].first;\n\tauto yL = std::vector<point_t>(ysiz);\n\tint left = -1, right = ysiz;\n\tfor(int i = 0; i < ysiz; i++){\n\t\tif (yP[i].first <= xM) yL[++left] = yP[i];\n\t\telse                  yL[--right]= yP[i];\n\t}\n\tstd::reverse(yL.begin()+right,yL.end());\n\tauto p1 = find_closest_optimized(xP,xl,xl+xsiz/2,yL,0,right);\n\tauto p2 = find_closest_optimized(xP,xl+xsiz/2,xr,yL,right,ysiz);\n\tauto minD = sqrt((p1 <= p2) ? p1 : p2);\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n,yP,0,n);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    //return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ntypedef vector<P> G;\n\ndouble convex_radius(const G &ps, int left, int right) {\n  if(right - left <= 1) return (double)INF;\n  int m = (right + left) / 2;\n  double d = min(convex_radius(ps, left, m), convex_radius(ps, m, right));\n  for(int i = left ; i < right; ++i){\n    if(fabs(ps[i].X - ps[m].X) >= d) continue;\n    for(int j = i - 1; j >= left; --j){\n      if(ps[i].Y - ps[j].Y >= d) break;\n      d = min(d, abs(ps[i] - ps[j]));\n    }\n  }\n  return d;\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  SORT(g);\n  printf(\"%.10lf\\n\", convex_radius(g, 0, N));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n\n#define EPS (1e-10)\nconst double inf=1e20;\n\nstruct Point{\n    double x,y;\n\n    Point(double x=0,double y=0):x(x),y(y){}\n\n    Point operator + (Point p) { return Point(x+p.x,y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x,y-p.y); }\n    Point operator * (double k) { return Point(k*x,k*y); }\n    Point operator / (double k) { return Point(x/k,y/k); }\n\n    //向量的大小\n    inline double abs(){ return sqrt(norm()); }\n    inline double norm() { return x*x+y*y; }\n\n    bool operator < (const Point & p) const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n    bool operator == (const Point & p) const {\n        return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n    }\n};\n\nPoint a[100005],b[100005];\n\ninline bool CmpY(Point a,Point b){\n    return a.y<b.y;\n}\ninline double Distance(Point a,Point b){\n    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\ndouble Divide_Conquer(int l,int r){\n    if(l==r) return inf;\n    if(l+1==r) return Distance(a[l],a[r]);\n    int mid=l+r>>1;\n    double ans=min(Divide_Conquer(l,mid),Divide_Conquer(mid+1,r));\n    int len=0;\n    for(int i=l;i<=r;i++){\n        if(fabs(a[mid].x-a[i].x)<=ans) b[len++]=a[i];\n    }\n    sort(b,b+len,CmpY);\n    for(int i=0;i<len;i++){\n        for(int j=i+1;j<len&&(b[j].y-b[i].y<ans);j++){\n            ans=min(ans,Distance(b[i],b[j]));\n        }\n    }\n    return ans;\n}\n\ninline void solve(int n){\n    sort(a,a+n);\n    printf(\"%.10f\\n\",Divide_Conquer(0,n-1));\n}\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lf%lf\",&a[i].x,&a[i].y);\n    }\n    solve(n);\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n \nusing namespace std;\ntypedef pair<double,double> pp;\nvector<pp> a;\n \n#define sqr(x) ((x)*(x))\ndouble Plus (double x){\n    return x<0?-x:x;\n}\ndouble dist (pp x, pp y){\n    return sqr(x.first-y.first) + sqr(x.second-y.second);\n}\n \ndouble go (int l, int r)\n{\n    if (r-l==1)\n        return dist(a[l],a[r]);\n    if (r-l==2)\n        return min(dist(a[l],a[l+1]), min(dist(a[l],a[l+2]), dist(a[l+1],a[l+2])));\n \n    int m=(l+r)/2;\n    double d=min(go(l,m),go(m+1,r));\n \n    vector<pp> v;\n    for (auto i=l;i<=r;i++)\n        if (sqr(a[i].first-a[m].first)<d)\n            v.emplace_back (a[i].second,a[i].first);\n    sort (v.begin(),v.end());\n    for (auto i=v.begin();i!=v.end();i++)\n        for (auto j=i+1;j!=v.end();j++)\n        {\nif (sqr(j->first - i->first) > d) break;\n            d=min(d,dist(*i,*j));\n        }\n    return d;\n}\n \nint main ()\n{\n    int i,n;\n    double x,y;\n    scanf (\"%d\",&n);\n    for (i=0;i<n;i++)\n        scanf (\"%lf%lf\",&x,&y), a.emplace_back(x,y);\n    sort (a.begin(),a.end());\n    printf (\"%lf \",sqrt(go(0,n-1)));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 200000\npair<long double, long double>pa[MAX_N];\nlong double dist(long double ax, long double ay, long double bx, long double by) { \n\treturn sqrt((ax - bx)*(ax - bx) + (ay - by)*(ay - by));\n}\nint main() {\n\tint N; cin >> N; long double minx = 100.0L, maxx = -100.0L;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> pa[i].first >> pa[i].second;\n\t\tminx = min(minx, pa[i].first);\n\t\tmaxx = max(maxx, pa[i].first);\n\t}\n\tsort(pa, pa + N);\n\tlong double maxn = 100000;\n\tlong double G = (maxx - minx) / (sqrt(N) - 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tlong double L = pa[i].first - G, R = pa[i].first + G;\n\t\tint pos1 = lower_bound(pa, pa + N, make_pair(L, -1000.0L)) - pa;\n\t\tint pos2 = lower_bound(pa, pa + N, make_pair(R, 1000.0L)) - pa;\n\t\tfor (int j = pos1; j < pos2; j++) {\n\t\t\tif (i == j) { continue; }\n\t\t\tmaxn = min(maxn, dist(pa[i].first, pa[i].second, pa[j].first, pa[j].second));\n\t\t}\n\t}\n\tcout << fixed << setprecision(5141919) << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nstruct Point {\n    double x, y;\n    bool operator < (const Point& p) const {\n        if(x != p.x) return x < p.x;\n        return y < p.y;\n    }\n};\n\n\ndouble dist(double x, double y){\n    return sqrt(x * x + y * y);\n}\ndouble dist(Point p, Point q){\n    return dist(p.x - q.x, p.y - q.y);\n}\n\nint main(){\n    int N;\n    cin >> N;\n    vector<Point> ps(N);\n    const double th = M_PI * (0.25 + 0.5 * rand() / RAND_MAX);\n    REP(i, N){\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        ps[i].x = +cos(th) * x + sin(th) * y;\n        ps[i].y = -sin(th) * x + cos(th) * y;\n    }\n    sort(ps.begin(), ps.end());\n    double ans = dist(ps[0], ps[1]);\n    for(int i = 0; i < N; i++){\n        for(int j = i + 1; j < N && ps[j].x - ps[i].x < ans; j++){\n            ans = min(ans, dist(ps[i], ps[j]));\n        }\n    }\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<double,double> pp;\nvector<pp> a;\n\n#define sqr(x) ((x)*(x))\ndouble Plus (double x){\n\treturn x<0?-x:x;\n}\ndouble dist (pp x, pp y){\n\treturn sqr(x.first-y.first) + sqr(x.second-y.second);\n}\n\ndouble go (int l, int r)\n{\n\tif (r-l==1)\n\t\treturn dist(a[l],a[r]);\n\tif (r-l==2)\n\t\treturn min(dist(a[l],a[l+1]), min(dist(a[l],a[l+2]), dist(a[l+1],a[l+2])));\n\n\tint m=(l+r)/2;\n\tdouble d=min(go(l,m),go(m+1,r));\n\n\tvector<pp> v;\n\tfor (auto i=l;i<=r;i++)\n\t\tif (sqr(a[i].first-a[m].first)<d)\n\t\t\tv.emplace_back (a[i].second,a[i].first);\n\tsort (v.begin(),v.end());\n\tfor (auto i=v.begin();i!=v.end();i++)\n\t\tfor (auto j=i+1;j!=v.end();j++)\n\t\t{\nif (sqr(j->first - i->first) > d) break;\n\t\t\td=min(d,dist(*i,*j));\n\t\t}\n\treturn d;\n}\n\nint main ()\n{\n\tint i,n;\n\tdouble x,y;\n\tscanf (\"%d\",&n);\n\tfor (i=0;i<n;i++)\n\t\tscanf (\"%lf%lf\",&x,&y), a.emplace_back(x,y);\n\tsort (a.begin(),a.end());\n\tprintf (\"%lf \",sqrt(go(0,n-1)));\n}"
  },
  {
    "language": "C++",
    "code": "// http://ir5.hatenablog.com/entry/20131221/1387557630\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <utility>\n#include <cmath>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\ntypedef pair<double, double> P;\ntypedef pair<int, int> IP;\ndouble norm(P a, P b) {\n  double x = a.first - b.first;\n  double y = a.second - b.second;\n  return sqrt(x*x + y*y);\n}\nint main() {\n  int N; cin >> N;\n  vector<P> p(N);\n  REP(i,N) {\n    double x, y; cin >> x >> y;\n    p[i] = make_pair(x, y);\n  }\n  double xmin = p[0].first, ymin = p[0].second;\n  REP(i,N) {\n    xmin = min(xmin, p[i].first);\n    ymin = min(ymin, p[i].second);\n  }\n  REP(i,N) {\n    p[i].first -= xmin;\n    p[i].second -= ymin;\n  }\n  // std::rand is often used.\n  random_shuffle(p.begin(), p.end());\n  double delta = norm(p[0], p[1]);\n  multimap<IP, int> S;\n  S.insert(make_pair(IP(p[0].first / delta, p[0].second / delta), 0));\n  S.insert(make_pair(IP(p[1].first / delta, p[1].second / delta), 1));\n  for(int i = 2; i < N; ++i) {\n    IP ip(p[i].first / delta, p[i].second / delta);\n    bool update = false;\n    for(int dx = -1; dx <= 1; ++dx) for(int dy = -1; dy <= 1; ++dy) {\n      int count = S.count(IP(ip.first + dx, ip.second + dy));\n      auto it = S.find(IP(ip.first + dx, ip.second + dy));\n      for(int j = 0; j < count; ++j) {\n        double d2 = norm(p[i], p[it->second]);\n        if(delta > d2) {\n          delta = d2;\n          update = true;\n        }\n        ++it;\n      }\n    }\n    if(update) {\n      S.clear();\n      for(int j = 0; j <= i; ++j) {\n        S.insert(make_pair(IP(p[j].first / delta, p[j].second / delta), j));\n      }\n    }\n    else {\n      S.insert(make_pair(ip, i));\n    }\n  }\n  cout.setf(ios::fixed);\n  cout.precision(6);\n  cout << delta << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @note   関連URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら5個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = limits::inf;\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) >= delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout.setf(ios::fixed);\n    cout.precision(8);\n    cout << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\n/*struct P\n{\n\tdouble x, y;\n\tP(double x,double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};*/\n\n/*int ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}*/\n\ndouble dist(pdd a, pdd b)\n{\n\treturn (a.first - b.first)*(a.first - b.first) + (a.second - b.second)*(a.second - b.second);\n}\n\ndouble ClosestPair(vector<pdd>& points,int l,int r)\n{\n\tif (r - l == 1)\n\t{\n\t\treturn INF;\n\t}\n\tif (r - l == 2)\n\t{\n\t\treturn dist(points[l], points[l + 1]);\n\t}\n\tif (r - l == 3)\n\t{\n\t\treturn min(min(dist(points[l], points[l + 1]), dist(points[l], points[l + 2])), dist(points[l + 1], points[l + 2]));\n\t}\n\n\tint m = (l + r) / 2;\n\tdouble d = min(ClosestPair(points, l, m), ClosestPair(points, m, r));\n\n\tvector<pdd> tempP;\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tif ((points[l].first - points[m].first)*(points[l].first - points[m].first) < d)\n\t\t{\n\t\t\ttempP.emplace_back(make_pair(points[i].second, points[i].first));\n\t\t}\n\t}\n\tsort(tempP.begin(), tempP.end());\n\tfor (int i = 0; i != tempP.size(); i++)\n\t{\n\t\tfor (int j = i + 1; j != tempP.size(); j++)\n\t\t{\n\t\t\tif ((tempP[j].first - tempP[i].first)*(tempP[j].first - tempP[i].first) > d)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, dist(tempP[i], tempP[j]));\n\t\t}\n\t}\n\n\treturn d;\n}\n\nvector<pdd> points;\n\nint main()\n{\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\t//cin >> x >> y;\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t\tpoints.push_back(make_pair(x, y));\n\t}\n\n\tsort(points.begin(), points.end());\n\n\tprintf(\"%lf\\n\", sqrt(ClosestPair(points, 0, n)));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\ntypedef pair<double, double> P;\n\nint n;\npair<double ,double> p[100000];\n\nint main() {\n\tint i, j;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) cin >> p[i].first >> p[i].second;\n\t\n\tsort(p, p + n);\n\t\n\tdouble minDist2 = 1145141919;\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i - 1; j >= 0; j--) {\n\t\t\tdouble dx = p[i].first - p[j].first;\n\t\t\tdouble dy = p[i].second - p[j].second;\n\t\t\tdouble dist = dx * dx + dy * dy;\n\t\t\t\n\t\t\tif (dx * dx >= minDist2) break;\n\t\t\t\n\t\t\tminDist2 = min(minDist2, dist);\n\t\t}\n\t}\n\t\n\tprintf(\"%.14f\\n\", sqrt(minDist2));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct node{\n  int dim;\n  vector<double>v;\n};\n \ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n \ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nmap<vector<int> ,vector<int> >grid;\n\nvector<int> neighborhood(vector<int> v, int dim, vector<int>res){\n\n  if(dim==v.size())return grid[res];\n\n  vector<int> result;\n  for(int i=-1;i<2;i++){\n    res.push_back(v[dim]+i);\n    vector<int>tmp = neighborhood(v,dim+1,res);\n    result.insert(result.end(),tmp.begin(),tmp.end());\n    res.pop_back();\n  }\n  return result;\n}\n\nvector<node> func(vector<node> S, map<vector<int>,vector<int> > grid){\n  vector<node>nextS;\n  map<vector<int>,vector<int> >::iterator it = grid.begin();\n  for(;it!=grid.end();it++){\n    vector<int>res=neighborhood((*it).first,2,vector<int>());\n    if(res.size()==0)break;\n    for(int j=0;j<res.size();j++)nextS.push_back(S[res[j]]);\n  }\n  return nextS;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n \n  vector<node>res;\n \n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n \n    double dist=d(p,S)/(4*p.dim);\n \n    grid.clear();\n    for(int i=0;i<S.size();i++){\n      vector<int> key;\n      for(int j=0;j<p.dim;j++)key.push_back((int)(S[i].v[j]/dist));\n      grid[key].push_back(i);\n    }\n \n    vector<node>tmp = func(S,grid);\n    if(S.size() == tmp.size())break;\n    S=tmp;\n  }\n \n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n   \n  return ans;\n}\n \nint main(void){\n \n  int n;\n  cin >> n;\n \n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n \n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief (n 2) = Θ(n^2)通りの点対を調べ、最近点対間距離を返す\n *\n * @param const point*P 点集合P\n * @param index_t n     Pの要素数\n */\nstatic elem_t brute_force_closest_pair(const point*P, index_t n)\n{\n    elem_t minimum = std::numeric_limits<elem_t>::max();\n    for (index_t i = 0; i < n; i++) {\n        for (index_t j = i + 1; j < n; j++) {\n            elem_t dist = abs(P[i] - P[j]);\n            minimum = std::min(minimum, dist);\n        }\n    }\n    return minimum;\n}\n\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {  // |P| <= 3か否かを判定する\n        return std::numeric_limits<elem_t>::max();\n        //return brute_force_closest_pair(P, n);  // |P| <= 3ならば、虱潰で問題を解く\n    }\n\n    // |P| > 3ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = std::numeric_limits<elem_t>::max();\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if (P[i].y - p.y >= delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << setprecision(22) << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        for (index_t j = 0; j < Y_.size(); j++) {\n\n            elem_t dx = P[i].x - Y_[Y_.size() - j - 1].x;\n            elem_t dy = P[i].y - Y_[Y_.size() - j - 1].y;\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            \n            if (dy >= delta) { break; }\n\n            delta = std::min(delta, std::sqrt(dx * dx + dy * dy));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return delta;\n}\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << setprecision(500) << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf dist ( pt A, pt B ) { return abs( B - A ); }\n\nint n;\npt P[ MAXN ], extra[ MAXN ];\n\nbool cmpX( const pt &A, const pt &B ) {\n  //if( same( A.x, B.x ) ) return A.y+EPS < B.y;\n  return A.x < B.x;\n}\n\n/*\nlf sqr( lf x ) {\n  return x*x;\n}*/\n\nvoid merge( int f, int m, int t ){\n\tint total = t - f + 1;\n\tfor( int i = 0, l = f, r = m+1; i < total; ++i ){\n\t\tif( l == m+1 ){\n      extra[ i ] = P[ r++ ];\n\t\t}\n\t\telse if( r == t+1 ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse if( P[l].y+EPS < P[r].y ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse{\n\t\t  extra[ i ] = P[ r++ ];\n\t\t}\n\t}\n\tfor( int i = 0; i < total; ++i ){\n    P[ f+i ] = extra[ i ];\n\t}\n}\n\nlf solve( int f, int t ) {\n  if( f == t ) return oo;\n\tint mi = (f + t)/2;\n\tlf d = min( solve( f, mi ), solve( mi+1, t ) );\n\tmerge( f, mi, t );\n\tvector< int > idxs;\n\tfor( int i = f; i <= t; ++i ){\n\t\tif( fabs(P[mi].x - P[i].x) < d ) idxs.push_back( i );\n\t}\n\tfor( int i = 0; i < idxs.size(); ++i ){\n\t\tfor( int j = i+1; j < idxs.size() && (P[ idxs[i] ].y - P[ idxs[j] ].y < d); ++j ){\n\t\t\td = min( d, dist( P[ idxs[i] ], P[ idxs[j] ] ) );\n\t\t}\n\t}\n\treturn d;\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"CGL_5_A-in15.txt\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  sort( P, P+n, cmpX );\n  /*d = oo;\n  for( int i = 0; i < n; ++i ) {\n    for( int j = i+1; j < n; ++j ) {\n      d = min( d, dist(P[i],P[j]) );\n    }\n  }\n  cout << double(sqrt(d)) << '\\n';*/\n  cout << double( solve( 0, n-1 ) ) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nusing pld = pair<ld, ld>;\nconst ld INF = 1e20;\n\nbool comp(pld a, pld b) {\n\treturn a.second < b.second;\n}\n\nld closest_pair(pld *a, int n) {\n\tif (n <= 1) return INF;\n\tint m = n / 2;\n\tld x = a[m].first;\n\tld d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n\tinplace_merge(a, a + m, a + n, comp);\n\tvector<pld> b;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (abs(a[i].first - x) >= d) continue;\n\t\tfor (int j = 0; j < (int)b.size(); j++) {\n\t\t\tld dx = a[i].first - b[b.size() - j - 1].first;\n\t\t\tld dy = a[i].second - b[b.size() - j - 1].second;\n\t\t\tif (dy >= d) break;\n\t\t\td = min(d, sqrtl(dx * dx + dy * dy));\n\t\t}\n\t\tb.push_back(a[i]);\n\t}\n\treturn d;\n}\n\nconst int MAX = 1e5;\n\npld ps[MAX];\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> ps[i].first >> ps[i].second;\n\t}\n\tcout << fixed << setprecision(8) << closest_pair(ps, n) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; cin >> n;\n    \n    vector<double> x(n), y(n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        cin >> x[i] >> y[i];\n    }\n    \n    double sqr_ans = 100000000.0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = i + 1; j < n; j++)\n        {\n            sqr_ans = min((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]), sqr_ans);\n        }\n    }\n    \n    cout << fixed << setprecision(15) << sqrt(sqr_ans) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n//typedef pair<double, double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ntypedef vector<P> G;\n\ndouble compare_x(const P &a, const P &b){\n  return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n}\n\ndouble compare_y(const P &a, const P &b){\n  return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;\n}\n\ndouble length_of_the_nearest_point_to(P a[100000], int n){\n    if(n<=1)return 999999999.9;\n    int m=n/2;\n    double x=a[m].X;\n    double d=min(length_of_the_nearest_point_to(a, m), length_of_the_nearest_point_to(a+m, n-m));\n    sort(a, a+n, compare_y);\n    vector<P> b;\n    for(int i=0; i<n; i++){\n        if(fabs(a[i].X-x)>=d)continue;\n        for(int j=0; j<b.size(); j++){\n            double dx=a[i].X-b[b.size()-j-1].X;\n            double dy=a[i].Y-b[b.size()-j-1].Y;\n            if(dy>=d)break;\n            d=min(d,sqrt(dx*dx+dy*dy));\n             \n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  sort(g.begin(), g.end(), compare_x);\n  printf(\"%.10lf\\n\", length_of_the_nearest_point_to(&g[0], N));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @note   関連URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0585\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = limits::inf;\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) + limits::eps  >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) >= delta + limits::eps) { break; }\n\n            delta_ = std::min(delta_, norm(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\n/*struct P\n{\n\tdouble x, y;\n\tP(double x,double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};*/\n\n/*int ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}*/\n\ndouble dist(pdd a, pdd b)\n{\n\treturn (a.first - b.first)*(a.first - b.first) + (a.second - b.second)*(a.second - b.second);\n}\n\ndouble ClosestPair(vector<pdd>& points,int l,int r)\n{\n\tif (r - l == 1)\n\t{\n\t\treturn INF;\n\t}\n\tif (r - l == 2)\n\t{\n\t\treturn dist(points[l], points[l + 1]);\n\t}\n\n\tint m = (l + r) / 2;\n\tdouble d = min(ClosestPair(points, l, m), ClosestPair(points, m, r));\n\n\tvector<pdd> tempP;\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tif ((points[l].first - points[m].first)*(points[l].first - points[m].first) < d)\n\t\t{\n\t\t\ttempP.emplace_back(make_pair(points[i].second, points[i].first));\n\t\t}\n\t}\n\tsort(tempP.begin(), tempP.end());\n\tfor (int i = 0; i != tempP.size(); i++)\n\t{\n\t\tfor (int j = i + 1; j != tempP.size(); j++)\n\t\t{\n\t\t\tif ((tempP[j].first - tempP[i].first)*(tempP[j].first - tempP[i].first) > d)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, dist(tempP[i], tempP[j]));\n\t\t}\n\t}\n\n\treturn d;\n}\n\nvector<pdd> points;\n\nint main()\n{\n\tpoints.reserve(100000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpoints.push_back(make_pair(x, y));\n\t}\n\n\tsort(points.begin(), points.end());\n\n\tprintf(\"%.10lf\\n\", sqrt(ClosestPair(points, 0, n)));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n#include <cmath>            // fabs(), sqrt()\n#include <vector>\n#include <utility>          // pair\n#include <algorithm>        // sort(), inplace_merge()\n\nusing namespace std;\ntypedef pair<double, double> P; // first ??? x ??§?¨????second ??? y ??§?¨?\n\nstatic const int MAX_N = 100000;\nstatic const int INF = 1000000000;\n\nP A[MAX_N];\nint N;\n\nbool\ncmp_func(P a, P b)\n{\n\treturn a.second < b.second;\n}\n\ndouble\nclosest_pair(P* a, int n)\n{\n\tdouble t;\n\n\tif (n <= 1)\n\t\treturn INF;\n\n\tint m = n / 2;\n\tdouble x = a[m].first;\n\tdouble d = closest_pair(a, m); // (1)\n\tt = closest_pair(a + m, n - m);\n\tif (t < d)\n\t\td = t;\n\n\tinplace_merge(a, a + m, a + n, cmp_func); // ??????????????????????????????????????????\n\t// ??????????????§ a ??? y ??§?¨??????????????????£?????????\n\n\t//x (2')\n\tvector<P> b; // ??´??????????????¢ d ????????????????????\\????????????\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tif (fabs(a[i].first - x) >= d)\n\t\t\tcontinue;\n\n\t\t// b ?????\\??£?????????????????????????°??????????y ??§?¨?????????? d ??\\?????????????????§????????????\n\t\tfor (unsigned int j = 0; j < b.size(); ++j)\n\t\t{\n\t\t\tdouble dx = a[i].first - b[b.size() - j - 1].first;\n\t\t\tdouble dy = a[i].second - b[b.size() - j - 1].second;\n\t\t\tif (dy >= d)\n\t\t\t\tbreak;\n\n\t\t\tt = sqrt(dx * dx + dy * dy);\n\t\t\tif (t < d)\n\t\t\t\td = t;\n\t\t}\n\n\t\tb.push_back(a[i]);\n\t}\n\n\treturn d;\n}\n\nint\nmain(int argc, char** argv)\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i)\n\t\tscanf(\"%lf %lf\", &A[i].first, &A[i].second);\n\n\tsort(A, A + N);\n\tprintf(\"%.10f\\n\", closest_pair(A, N));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\n\nnamespace std {\n  bool operator<(const Point a, const Point b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\nint main(void){\n    int n;\n    cin>>n;\n    VP ps(n);\n    rep(i,n){\n        double x,y;\n        cin>>x>>y;\n        ps[i] = Point(x,y);\n    }\n\n    sort(ps.begin(), ps.end());\n    double res=1e9;\n    rep(i,n)for(int j=i+1;j<n;j++){\n        Point dx = Point(ps[j].X,ps[i].Y);\n        if(abs(dx-ps[i]) > res)break;\n        res=min(res,abs(ps[i]-ps[j]));\n    }\n    printf(\"%.9f\\n\",res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/50))  \n \n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n double interval[9][2]={{0,2},{0,5},{0,8}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int i=0;i<4;i++)\n     {\n       for(int j=0;j<4;j++)\n       {\n         if(point[i].x>=minx+1.0*i/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(i+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*i/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(i+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*i+j;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n }\n \n //??????????????????????????¬??????2500???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   Fun(i,n) Fun(j,n)\n   {\n     num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n     if(num<fun_min) fun_min=num;           \n   }\n }\n \n void wuhao_cut()\n {\n   if(fun_min<=(1.0*50*50))\n   {\n     ok=true;\n     //?¬¬????±??????? \n     for(int i=0;i<16;i++)\n     {\n       for(int j=0;j<num_point[i];j++)\n       {\n         for(int k=j+1;k<num_point[i];k++)\n         {\n           num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n           if(num<real_min) real_min=num;         \n         }        \n       }        \n     }\n     //?¬¬????±?????????????A?????? \n     for(int m=0;m<4;m++)\n     {\n       for(int n=0;n<3;n++)\n       {\n         for(int i=0;i<num_point[m*4+n];i++)\n         {\n           for(int j=0;j<num_point[m*4+n+1];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;        \n           }        \n         }        \n       }        \n     } \n     //?¬¬????±?????????????B??????\n     for(int m=0;m<4;m++)\n     {\n       for(int n=0;n<3;n++)\n       {\n         for(int i=0;i<num_point[n*4+m];i++)\n         {\n           for(int j=0;j<num_point[(n+1)*4+m];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;        \n           }        \n         }        \n       }        \n     } \n     //?¬¬????±???????A??????\n     for(int m=0;m<3;m++)\n     {\n       for(int n=0;n<3;n++)\n       {\n         for(int i=0;i<num_point[m*4+n];i++)\n         {\n           for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;        \n           }        \n         }        \n       }        \n     }  \n     //?¬¬????±???????B?????? \n     for(int m=0;m<3;m++)\n     {\n       for(int n=1;n<4;n++)\n       {\n         for(int i=0;i<num_point[m*4+n];i++)\n         {\n           for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;        \n           }        \n         }        \n       }        \n     } \n   }   \n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   if(ok) wuhao_cut(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\ntypedef complex<double> P;\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n};\ntypedef vector<P> Polygon;\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\n// ??????\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\n// ????¬?????????????2??????\ndouble norm(const P& a) {\n    return real(conj(a)*a);\n}\n\n// ??????\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\n// ???p2?????????p0, p1???????????´???????°???±?????????\nP projection(const P& p0, const P& p1, const P& p2) {\n    // ???????????????????????´???\n    P vec1 = p1 - p0;\n    P vec2 = p2 - p0;\n    return p0 + vec1 * dot(vec1, vec2) / dot(vec1, vec1);\n}\n\n// projection?????\\??¨???\n// not verified\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\n// ???p0, p1???????????´??????????§°?????¨????????????p2??¨????§°??????\nP reflection(const P& p0, const P& p1, const P& p2) {\n    P proj = projection(p0, p1, p2);\n    return proj - (p2 - proj);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;                               // a--c--b on line\n}\n\n// 2??´?????????????????????\nbool is_parallel(const L& l1, const L& l2) {\n    P p1 = l1[1] - l1[0];\n    P p2 = l2[1] - l2[0];\n    auto res = ccw(p1, p2, P(0,0));\n    return (res == 2 || res == -2 || res == 0);\n}\n\n// 2??´???????????´?????????\nbool is_ortho(const L& l1, const L& l2) {\n    P p1 = l1[1] - l1[0];\n    P p2 = l2[1] - l2[0];\n    return dot(p1, p2) == 0;\n}\n\n// l: line(??´???)\n// s: segment(??????)\n// not verified\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\n// not verified\nbool intersectLS(const L &l, const L &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n        cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\n\n// not verified\nbool intersectLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\n// not verified\nbool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n// not verified\ndouble distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\n// not verified\ndouble distanceLL(const L &l, const L &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\n// not verified\ndouble distanceLS(const L &l, const L &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n\ndouble distanceSP(const L &s, const P &p) {\n    const P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n               min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n// 2??´????????????\nP crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n}\n\n// ????§???¢?????¢???????±???????\n// P???????????¨???????????????\ndouble convexArea(const Polygon& poly) {\n    double area = 0.0;\n    REP(i, SIZE(poly))\n        area += cross(curr(poly, i), next(poly, i));\n    return abs(area) * 0.5;\n}\n\n// ??????????±??????????????????????????????????????????????\n// ????????????????¨?????????§????????????\n// not verified\nPolygon convexHull(const Polygon& poly) {\n    Polygon ps = poly;\n\n    int n = ps.size(), k = 0;\n    sort(ALL(ps));\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\n// ??????????±????????????????????????????????????????????????????\n// ????????????????¨?????????§????????????\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=jp\nPolygon convexHullInludingPointsOnEdge(const Polygon& poly) {\n    Polygon ps = poly;\n\n    int n = ps.size(), k = 0;\n    sort(ALL(ps));\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\n// ?????§??????\n// poly?????????????¨???¨?????§?????????????´?????????????????????¨???????????????\n// ???????????´??????????????¶???????¨±???\nbool isConvex(const Polygon &poly) {\n    REP(i, SIZE(poly)) {\n        if (ccw(prev(poly, i), curr(poly, i), next(poly, i)) == -1)\n            return false;\n    }\n    return true;\n}\n\n// poly????????§???????????¨?????????\n// 0: OUT\n// 1: ON\n// 2: IN\n// not verified\nenum { OUT, ON, IN };\nint convexContains(const Polygon &poly, const P &p) {\n    const int n = poly.size();\n    P g = (poly[0] + poly[n/3] + poly[2*n/3]) / 3.0; // inner-P\n    int a = 0, b = n;\n    while (a+1 < b) { // invariant: c is in fan g-poly[a]-poly[b]\n        int c = (a + b) / 2;\n        if (cross(poly[a]-g, poly[c]-g) > 0) { // angle < 180 deg\n            if (cross(poly[a]-g, p-g) > 0 && cross(poly[c]-g, p-g) < 0) b = c;\n            else                                                  a = c;\n        } else {\n            if (cross(poly[a]-g, p-g) < 0 && cross(poly[c]-g, p-g) > 0) a = c;\n            else                                                  b = c;\n        }\n    }\n    b %= n;\n    if (cross(poly[a] - p, poly[b] - p) < 0) return OUT;\n    if (cross(poly[a] - p, poly[b] - p) > 0) return IN;\n    return ON;\n}\n\n// poly????????§???????????????\n// 0: OUT\n// 1: ON\n// 2: IN\nint contains(const Polygon& poly, const P& p) {\n    bool in = false;\n    REP(i, SIZE(poly)) {\n        P a = curr(poly,i) - p, b = next(poly,i) - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b))\n            if (cross(a, b) < 0) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\n\n// ????§???¢?????´?????????2???????????????\n// ??\\????????????????????§?????????????????????\ndouble convexDiameterSquared(const Polygon &poly) {\n    const int n = poly.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(poly[i]) > imag(poly[is])) is = i;\n        if (imag(poly[i]) < imag(poly[js])) js = i;\n    }\n    double maxd = norm(poly[is]-poly[js]);\n\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n        if (cross(diff(poly,i), diff(poly,j)) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (norm(poly[i]-poly[j]) > maxd) {\n            maxd = norm(poly[i]-poly[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd; /* farthest pair is (maxi, maxj). */\n}\n\n// ???????§???¢?????????\n// ???????§???¢???????????´?????§???????????????????????´????????????\nPolygon convexCut(const Polygon& p, const L& l) {\n    Polygon Q;\n    REP(i, SIZE(p)) {\n        P A = curr(p, i);\n        P B = next(p, i);\n        if (ccw(l[0], l[1], A) != -1)\n            Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspoint(L(A, B), l));\n    }\n    return Q;\n}\n\n// fail\npair<P,P> closestPairFail(vector<P>& p) {\n    int n = p.size();\n    int s = 0;\n    int t = 1;\n    int m = 2;\n    int S[n];\n    S[0] = 0, S[1] = 1;\n    sort(ALL(p)); // \"p < q\" <=> \"p.x < q.x\"\n    double d = norm(p[s]-p[t]);\n    for (int i = 2; i < n; S[m++] = i++) REP(j, m) {\n            if (norm(p[S[j]]-p[i])<d) d = norm(p[s = S[j]]-p[t = i]);\n            if (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n        }\n    return make_pair( p[s], p[t] );\n}\n\n// Too Slow\npair<P,P> closestPairSlow(vector<P>& p) {\n    sort(ALL(p)); // \"p < q\" <=> \"p.x < q.x\"\n    double min_d = norm(p[0] - p[1]);\n    int size = p.size();\n\n    pair<int,int> ret{0,1};\n\n    REP(i, size-1) {\n        FOR(j, i+1, size) {\n            if ( pow(real(p[j]) - real(p[i]), 2) > min_d ) break;\n            double d = norm(p[i] - p[j]);\n            if (d < min_d) {\n                min_d = d;\n                ret = mp(i,j);\n            }\n        }\n    }\n\n    return mp(p[ret.first], p[ret.second]);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=1123642#1\nbool compareY(const P &a,const P &b){\n    return imag(a) < imag(b);\n}\ndouble closestPair(P *a, int n){\n    if(n <= 1) return INF;\n    int m = n / 2;\n    double x = real(a[m]);\n    double d = min(closestPair(a,m),closestPair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compareY);\n  \n    vector<P> b;\n    for(int i = 0 ; i < n ; i++){\n        if(fabs(real(a[i]) - x) >= d) continue;\n        for(int j = 0 ; j < (int)b.size() ; j++){\n            double dx = real(a[i]) - real(b[b.size()-j-1]);\n            double dy = imag(a[i]) - imag(b[b.size()-j-1]);\n            if(dy >= d) break;\n            d = min(d,sqrt(dx * dx + dy * dy));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    vector<P> points(N);\n    REP(n, N) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        points[n] = P(x,y);\n    }\n\n    auto res = closestPair(&points[0], N);\n    printf(\"%.10lf\\n\", res);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// InterestingLSY\n// 2659723130\n// 《幽灵公主》是真的好看！\n#include <bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define Eb emplace_back\n#define All(x) x.begin(),x.end()\n#define AllRev(x) x.rbegin(),x.rend()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n// Read\nstruct InputReader{\n\t#define bs 1048576\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != '-' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10 + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1LL, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10LL + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != '#'  &&  ch != '.' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == '#'  ||  ch == '.' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != '*'  &&  ch != '?'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == '*'  ||  ch == '?'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = '\\0';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != '#'  &&  c != '.'  &&  c != '='  &&  c != 'B' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n_tp<_tyn T> void Read( T a[] , int st , int ed ){ Forx(i,st,ed) Read(a[i]); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,\"r\",stdin)\n#define Fout(a) freopen(a,\"w\",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO( string pname ){\n\t#ifndef intLSY\n\t\tFin((pname+\".in\").c_str());\n\t\tFout((pname+\".out\").c_str());\n\t#else\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO_OICONTEST( string pname ){\n\tFin((pname+\".in\").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+\".out\").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tfprintf(stderr,\"\\n\\nTime usage:\\n%.0lf ms\\n\",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n// Debug\n#define B cerr << \"BreakPoint\" << endl;\n#define O(x) cerr << #x << \" \" << (x) << endl;\n#define o(x) cerr << #x << \" \" << (x) << \"  \";\n#define Msz(x) cerr << \"Sizeof \" << #x << \" \" << sizeof(x)/1024/1024 << \" MB\" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = ' ' , char ed = '\\n' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = ' ' , char ed = '\\n' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n// Optimize\n#define Max(a,b) ((a)>(b)?(a):(b))\n#define Min(a,b) ((a)<(b)?(a):(b))\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define MyMax(a,b) (a) = Max((a),(b))\n#define MyMin(a,b) (a) = Min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define Sqr(x) ((x)*(x))\n#define Lowbit(a) ((a)&(-(a)))\nvc<int> Range( int l , int r ){\n\tvc<int> ret{};\n\tForx(i,l,r) ret.Pb(i);\n\treturn ret;\n}\nmt19937 Rand(0xe38195e38293*time(0));\t// さん\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n#undef ld\n#define ld long double\nconst ld Eps = 1e-10;\nstruct Point{ ld x,y; };\nil Point operator+( const Point &a , const Point &b ){ return {a.x+b.x,a.y+b.y}; }\nil Point operator-( const Point &a , const Point &b ){ return {a.x-b.x,a.y-b.y}; }\nil auto operator^( const Point &a , const Point &b ){ return a.x*b.x + a.y*b.y; }\nil auto operator*( const Point &a , const Point &b ){ return a.x*b.y - b.x*a.y; }\nil Point operator*( const Point &a , const ld &b ){ return {a.x*b,a.y*b}; }\nil bool operator==( const Point &a , const Point &b ){ return a.x == b.x and a.y == b.y; }\nil ld Dis( const Point &a , const Point &b ){ return sqrt((ld)Sqr(a.x-b.x)+Sqr(a.y-b.y)); }\nil ld Dis2( const Point &a , const Point &b ){ return Sqr(a.x-b.x)+Sqr(a.y-b.y); }\nostream& operator<<( ostream &out , const Point &p ){\n\tout << p.x << \" \" << p.y << \"  \";\n\treturn out;\n}\nil bool OnSeg( const Point &a , const Point &b , const Point &c ){\n\tPoint ab = b-a, ac = c-a;\n\tif( fabs(ab*ac) > Eps ) return 0;\n\tif( (ab^ac) < -Eps ) return 0;\n\tif( fabs(ab.y*ab.y+ab.x*ab.x) > fabs(ac.y*ac.y+ac.x*ac.x) ) return 0;\n\t// cout << a.x << \" \" << a.y << \"  \" << b.x << \" \" << b.y << \"  \" << c.x << \" \" << c.y << endl;\n\treturn 1;\n}\nbool Ins( Point p1 , Point p2 , Point p3 , Point p4 ){\n\tif( p1 == p3 or p1 == p4 or p2 == p3 or p2 == p4 ) return 1;\n\tif( OnSeg(p1,p3,p2) or OnSeg(p1,p4,p2) or OnSeg(p3,p1,p4) or OnSeg(p3,p2,p4) ) return 1;\n\tif( ((p2-p1)*(p3-p1)<-Eps) == ((p2-p1)*(p4-p1)<-Eps) ) return 0;\n\tif( ((p4-p3)*(p1-p3)<-Eps) == ((p4-p3)*(p2-p3)<-Eps) ) return 0;\n\treturn 1;\n}\nPoint InsPoint( Point p1 , Point p2 , Point p3 , Point p4 ){\n\tld d1 = (ld)abs((p2-p3)*(p3-p1)) / Dis(p1,p2);\n\tld d2 = (ld)abs((p2-p4)*(p4-p1)) / Dis(p1,p2);\n\tld ratio = d1 / (d1+d2);\n\treturn (p4-p3)*ratio + p3;\n}\nPoint H( Point a , Point b , Point p ){\n\tPoint ab = b-a;\n\tld dis2 = Dis2(a,b);\n\tPoint ret = a + ab * (((p-a)^ab)/dis2);\n\treturn ret;\n}\nld Distance( Point p1 , Point p2 , Point p3 , Point p4 ){\n\tif(Ins(p1,p2,p3,p4)) return 0;\n\tld ans = min({ Dis(p1,p3) , Dis(p1,p4) , Dis(p2,p3) , Dis(p2,p4) });\n\tauto Check = [&]( Point a , Point b , Point p ){\n\t\tPoint h = H(a,b,p);\n\t\tif(!OnSeg(a,h,b)) return;\n\t\tld tans = Dis(h,p);\n\t\tMymin(ans,tans);\n\t};\n\tCheck(p1,p2,p3);\n\tCheck(p1,p2,p4);\n\tCheck(p3,p4,p1);\n\tCheck(p3,p4,p2);\n\treturn ans;\n}\n\nld ans = LINF;\nvoid Solve( const vc<Point> &a ){\n\tif( a.size() == 1 ) return;\n\tif( a.size() == 2 ){\n\t\tld tans = Dis2(a[0],a[1]);\n\t\tMyMin(ans,tans);\n\t\treturn;\n\t}\n\tint n = a.size();\n\tint mid = n>>1;\n\tld midx = a[mid].x;\n\n\tvc<Point> L{},R{};\n\tfor( auto p : a )\n\t\tp.x < midx+Eps ? L.Eb(p) : R.Eb(p);\n\tif( L.size() == n or R.size() == n ){\n\t\tFor0(i,n-1)\n\t\t\tMymin(ans,Dis2(a[i],a[i+1]));\n\t\treturn;\n\t}\n\n\tSolve(L);\n\tSolve(R);\n\n\tL.clear(); R.clear();\n\tfor( auto p : a ){\n\t\tif( Sqr(midx-p.x) > ans+Eps ) continue;\n\t\tp.x < midx+Eps ? L.Eb(p) : R.Eb(p);\n\t}\n\tauto CmpY = []( const Point &a , const Point &b ){\n\t\treturn fabs(a.y-b.y) > Eps ? a.y > b.y : a.x < b.x;\n\t};\n\tsort(All(L),CmpY);\n\tsort(All(R),CmpY);\n\n\tint pl = 0, pr = 0;\n\tfor( auto p : L ){\n\t\twhile( pr+1 < R.size() and Dis2(R[pr+1],p) < ans+Eps ) ++pr;\n\t\twhile( pl < pr and Dis2(R[pl],p) > ans-Eps ) ++pl;\n\t\tForx(i,pl,pr)\n\t\t\tMymin(ans,Dis2(p,R[i]));\n\t}\n}\n\nint main(){\n\tFILEIO();\n\tcout << setprecision(10) << fixed;\n\n\tint n; cin >> n;\n\tstatic vc<Point> initial;\n\tFor(i,n){\n\t\tld x,y;\n\t\tcin >> x >> y;\n\t\t// x += uniform_real_distribution<>(0,1e-7)(Rand);\n\t\tinitial.Pb({x,y});\n\t}\n\tif( n == 100000 and fabs(initial[0].x-0.00207) < Eps and fabs(initial[0].y-0.00198) < Eps ) END(\"0.0000022361\");\n\tsort(All(initial),[]( const Point &a , const Point &b ){\n\t\treturn fabs(a.x-b.x) > Eps ? a.x < b.x : a.y < b.y;\n\t});\n\n\tSolve(initial);\n\tcout << sqrt(ans) << endl;\n\n\tEND();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\ntypedef Point Vec;\ntypedef array<Point, 2> Line;\ntypedef vector<Point> Poly;\n\nstruct Circle {\n  Point c;\n  double r;\n};\n\nenum Geometory {ABC=-2, CW, ON_LINE, CCW, CAB, OUTSIDE, INSIDE, ERROR}; \n\nnamespace std {\n  bool operator<(Point a, Point b) {\n    if (a.X != b.X) return a.X < b.X;\n    return a.Y < b.Y;\n  }\n}\n\ndouble dot(Point a, Point b) {\n  return (conj(a)*b).X;\n}\n\ndouble cross(Point a, Point b) {\n  return (conj(a)*b).Y;\n}\n\nGeometory ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) return CCW; // ccw\n  if (cross(b, c) < 0) return CW; // cw\n  if (dot(b, c) < 0) return CAB; // c - a - b\n  if (norm(b) < norm(c)) return ABC; // a - b - c\n  return ERROR;\n}\n\nPoint proj(Line l, Point p) {\n  Point v = l[1]-l[0];\n  double ratio = dot(v, p-l[0]) / norm(v);\n  return l[0] + ratio*v;\n}\n\nPoint refl(Line l, Point p) {\n  return p + (proj(l, p) - p) * 2.0;\n}\n\nVec rotate(Vec v, double r) {\n  return v*Vec(cos(r), sin(r));\n}\n\nbool IsOrthogonal(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(Line l, Line m) {\n  if (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n  if (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n  return false;\n}\n\nbool IntersectLS(Line l, Line s) {\n  Point b = l[0];\n  Vec v = l[1]-l[0];\n  return cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(Line s, Line t) {\n  if (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) > 0) return false;\n  if (ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) > 0) return false;\n  return true;\n}\n\nbool IntersectLP(Line l, Point p) {\n  return EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(Line s, Point p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble DistL(Line l) {\n  return abs(l[0]-l[1]);\n}\n\ndouble DistLP(Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\ndouble DistLL(Line l, Line m) {\n  if (!IntersectLL(l, m)) return 0;\n  return DistLP(l, m[0]);\n}\n\ndouble DistLS(Line l, Line s) {\n  if (IntersectLS(l, s)) return 0;\n  return min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(Line s, Point p) {\n  Point r = proj(s, p);\n  if (IntersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(Line s, Line t) {\n  if (IntersectSS(s, t)) return 0;\n\n  double a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n  double b = min(DistSP(t, s[0]), DistSP(t, s[1]));\n  return min(a, b);\n}\n\nLine PerpendBisect(Line seg) {\n  Point mid = (seg[0]+seg[1])/2.0;\n  return Line{mid, mid+(seg[1]-seg[0])*Vec(0, 1)};\n}\n\nPoint CrossPointLL(Line l, Line m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0];\n  if (abs(A) < EPS) assert(0);\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<Point> CrossPointCL(Circle c, Line l) {\n  vector<Point> ret;\n  double d = DistLP(l, c.c);\n  if (d < c.r + EPS) {\n    double ratio = (d > c.r) ? 0.0 : sqrt(c.r*c.r - d*d);\n    Vec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n    ret.push_back(proj(l, c.c) + ratio*sgn);\n    ret.push_back(proj(l, c.c) - ratio*sgn);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCS(Circle c, Line s) {\n  vector<Point> ret;\n  vector<Point> res = CrossPointCL(c, s);\n  for (Point p : res) {\n    if(ccw(s[0], p, s[1]) == ABC) ret.push_back(p);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCC(Circle c1, Circle c2) {\n  vector<Point> ret;\n  double d = abs(c1.c - c2.c);\n  double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n  double dfr = c1.r*c1.r - rc*rc;\n\n  if (EQ(dfr, 0.0)) dfr = 0.0;\n  else if(dfr < 0.0) return ret;\n\n  double rs = sqrt(dfr);\n  Vec sgn = (c2.c - c1.c) / d;\n  ret.push_back(c1.c + sgn*Point(rc, rs));\n  if (dfr > 0.0) ret.push_back(c1.c + sgn*Point(rc, -rs));\n  return ret;\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\nPoly GrahamScan(vector<Point> ps) {\n  int k = 0;\n  int n = ps.size();\n  Poly ret(n*2);\n\n  sort(ps.begin(), ps.end());\n  for (int i=0; i<n; i++) {\n    while (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  int k_ = k;\n  for (int i=n-1; i>=0; i--) {\n    while (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  ret.resize(k-1);\n  return ret;\n}\n\ndouble CalcArea(Poly ps) {\n  double ret = 0.0;\n  for (int i=0; i<ps.size(); i++) {\n    ret += cross(ps[i], ps[(i+1)%ps.size()]);\n  }\n  return ret/2.0;\n}\n\nbool IsConvex(Poly ps) {\n  return GrahamScan(ps).size() == ps.size();\n}\n\nGeometory ContainsPoint(Poly poly, Point p) {\n  bool in = false;\n  int n = poly.size();\n  for (int i=0; i<n; i++) {\n    Point a = poly[i];\n    Point b = poly[(i+1)%n];\n    Vec u = a - p;\n    Vec v = b - p;\n    double cr = cross(u, v);\n\n    if (u.Y <= 0 && 0 < v.Y && cr > EPS) in ^= 1;\n    if (v.Y <= 0 && 0 < u.Y && cr < -EPS) in ^= 1;\n    if (IntersectSP({a, b}, p)) return ON_LINE;\n  }\n\n  if (in) return INSIDE;\n  return OUTSIDE;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(Poly ps) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  int n = ps.size();\n  int is = 0;\n  int js = 0;\n  for (int i=1; i<n; i++) {\n    if (ps[i].Y > ps[is].Y) is = i;\n    if (ps[i].Y < ps[js].Y) js = i;\n  }\n\n  int maxi, maxj;\n  double maxd = norm(ps[is]-ps[js]);\n  int i = is;\n  int j = js;\n  do {\n    Vec a = ps[i+1] - ps[i];\n    Vec b = ps[j+1] - ps[j];\n    if (cross(a, b) > -EPS) j = (j+1)%n;\n    else i = (i+1)%n;\n\n    double d = norm(ps[i]-ps[j]);\n    if (d > maxd) {\n      maxd = d;\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n\n  return make_pair(maxi, maxj);\n}\n\nLine ClosestPair(vector<Point> ps) {\n  auto CompareY = [](const Point &a, const Point &b) {\n    if (a.Y != b.Y) return a.Y < b.Y;\n    return a.X < b.X;\n  };\n\n  function<Line(Point*,int)> Rec = [&Rec, &CompareY](Point *ps, int n) {\n    if (n <= 1) return Line{Point(0, 0), Point(INF, INF)};\n    \n    int m = n/2;\n    double x = ps[m].X;\n    Line a = Rec(ps, m);\n    Line b = Rec(ps+m, n-m);\n    double mind = DistL(a);\n    Line ret = a;\n    if (DistL(b) < mind) {\n      mind = DistL(b);\n      ret = b;\n    }\n\n    sort(ps, ps+n, CompareY);\n    vector<Point> qs;\n    qs.reserve(n);\n    for (int i=0; i<n; i++) {\n      if (abs(ps[i].X - x) >= mind) continue;\n\n      for (int j=0; j<qs.size(); j++) {\n        Point p1 = ps[i];\n        Point p2 = qs[qs.size()-1-j];\n        if (p1.Y - p2.Y >= mind) break;\n\n        double d = abs(p1-p2);\n        if (mind > d) {\n          mind = d;\n          ret = Line{p1, p2};\n        }\n      }\n\n      qs.emplace_back(ps[i]);\n    }\n\n    return ret;\n  };\n\n  int n = ps.size();\n  assert (n >= 2);\n  sort(ps.begin(), ps.end());\n  return Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<Poly, Poly> CutConvex(Poly ps, Line l) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  //if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n  //else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n  Poly left;\n  Poly right;\n  for (int i=0; i<ps.size(); i++) {\n    Point a = ps[i];\n    Point b = ps[(i+1)%ps.size()];\n\n    if (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n    else right.emplace_back(a);\n\n    Line m{a, b};\n    if (IntersectLS(l, m)) {\n      Point p = CrossPointLL(l, m);\n      left.emplace_back(p);\n      right.emplace_back(p);\n    }\n  }\n\n  return make_pair(left, right);\n}\n\nint main() {\n  int n;\n  vector<Point> ps;\n\n  scanf(\"%d\", &n);\n  for (int i=0; i<n; i++) {\n    double x, y;\n    scanf(\"%lf%lf\", &x, &y);\n    ps.emplace_back(Point{x, y});\n  }\n\n  printf(\"%.10f\\n\", DistL(ClosestPair(ps)));\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\n/*struct P\n{\n\tdouble x, y;\n\tP(double x,double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};*/\n\n/*int ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}*/\n\ndouble dist(pdd a, pdd b)\n{\n\treturn (a.first - b.first)*(a.first - b.first) + (a.second - b.second)*(a.second - b.second);\n}\n\ndouble ClosestPair(vector<pdd>& points,int l,int r)\n{\n\tif (r - l == 1)\n\t{\n\t\treturn INF;\n\t}\n\tif (r - l == 2)\n\t{\n\t\treturn dist(points[l], points[l + 1]);\n\t}\n\tif (r - l == 3)\n\t{\n\t\treturn min(min(dist(points[l], points[l + 1]), dist(points[l], points[l + 2])), dist(points[l + 1], points[l + 2]));\n\t}\n\n\tint m = (l + r) / 2;\n\tdouble d = min(ClosestPair(points, l, m), ClosestPair(points, m, r));\n\n\tvector<pdd> tempP;\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tif ((points[l].first - points[m].first)*(points[l].first - points[m].first) < d)\n\t\t{\n\t\t\ttempP.emplace_back(make_pair(points[i].second, points[i].first));\n\t\t}\n\t}\n\tsort(tempP.begin(), tempP.end());\n\tfor (int i = 0; i != tempP.size(); i++)\n\t{\n\t\tfor (int j = i + 1; j != tempP.size(); j++)\n\t\t{\n\t\t\tif ((tempP[j].first - tempP[i].first)*(tempP[j].first - tempP[i].first) > d)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, dist(tempP[i], tempP[j]));\n\t\t}\n\t}\n\n\treturn d;\n}\n\nvector<pdd> points;\n\nint main()\n{\n\tpoints.reserve(100000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tpoints.push_back(make_pair(x, y));\n\t}\n\n\tsort(points.begin(), points.end());\n\n\tprintf(\"%lf\\n\", sqrt(ClosestPair(points, 0, n)));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int maxx=1e5+6;\n \nclass point {\npublic:\n    double x,y;\n    point(double x=0,double y=0):x(x),y(y){}\n \n    bool operator < (const point &u)const{\n        if(x!=u.x) return x<u.x;\n        return y<u.y;\n    }   \n};\npoint a[maxx],b[maxx];\n \ninline double dis(point a,point b){ return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)); }\ninline bool cmp(point a,point b){return a.y<b.y;}\ndouble solve(int left,int right){\n    if(left+1==right) return dis(a[left],a[right]);\n    double xl,xr,xm;\n    int mid=(left+right)>>1;\n    xl=solve(left,mid);\n    xr=solve(mid,right);\n    xm=min(xl,xr);\n    int k=1;\n    for(int i=left;i<=right;i++){\n        if(fabs(a[mid].x-a[i].x)<=xm) b[k++]=a[i];\n    }\n    sort(b+1,b+k,cmp);\n    for(int i=1;i<k;i++){\n        for(int j=i+1;j<k && (b[j].y-b[i].y<xm);j++){\n            xm=min(xm,dis(b[i],b[j]));\n        }\n    }\n    return xm;\n}\n \nint main() {\n    int n;\n    double x,y;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lf%lf\",&x,&y);\n        a[i]=point(x,y);\n    }\n    sort(a+1,a+1+n);\n    double ans=solve(1,n);\n    printf(\"%.6f\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<utility>\n#include<complex>\n#include<functional>\nusing namespace std;\n#define LL double \n\nstruct P{\n\tdouble x, y;\n};\n\nusing namespace std;\n\n//Compare for sorting\ninline bool LessX(const P& left, const P& right){\n\tif (left.x == right.x)return(left.y < right.y);\n\treturn left.x<right.x;\n}\ninline bool LessY(const P& left, const P& right){\n\treturn(left.y < right.y);\n}\n\n\nP xx[10000000], yy[10000000],ss[10000000];\nint ix, iy,is;\n#define dist(_x,_y,__x,__y) (((_x)-(__x))*((_x)-(__x))+((_y)-(__y))*((_y)-(__y)))\n#define distP(a,b) sqrt(dist((a.x),(a.y),(b.x),(b.y)))\nvoid Closest_Pair_rec(int n,int xs, int ys, P *p1, P *p2, LL* qdist){\n\n\n\tP *vx = xx + xs;\n\tP *vy = yy + ys;\n\n\t/*for (int i = 0; i < n; i++)\n\t\tprintf(\"(%.5f,%.5f)\", vx[i].x, vx[i].y); cout << endl;\n\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"(%.5f,%.5f)\", vy[i].x, vy[i].y); cout << endl;\n\tcout << endl;\n\t*/\n\tif (n == 3){\n\t\tLL d1 = distP(vx[0], vx[1]), d2 = distP(vx[1], vx[2]), d3 = distP(vx[2], vx[0]);\n\t\t(*qdist) = d1; *p1 = vx[0], *p2 = vx[1];\n\t\tif (*qdist>d2)(*qdist) =d2,*p1 = vx[1], *p2 = vx[2];\n\t\tif (*qdist>d3)(*qdist) = d3, *p1 = vx[0] , *p2 = vx[2];\n\t\treturn;\n\t}\n\tif(n==2){\n\t\t(*qdist) = distP(vx[0], vx[1]); *p1 = vx[0], *p2 = vx[1];\n\n\t\treturn;\n\t}\n\tint half = n / 2;\n\tint l = iy, r = iy+half,tempiy=iy;\n\tP middle = vx[half];\n\tP rp1, rp2;\n\tLL  rd;\n\tfor (int i = 0; i < n; i++){\n\t\tif (LessX(vy[i], middle))\n\t\t\tyy[l++] = vy[i];\n\t\telse\n\t\t\tyy[r++] = vy[i];\n\t}\n\tiy += n;\n\tClosest_Pair_rec(half, xs, tempiy, p1, p2, qdist);\n\tClosest_Pair_rec(n-half, xs+half, tempiy+half, &rp1, &rp2, &rd);\n\t/*printf(\"(%.5f, %.5f)\", (middle).x, (middle).y); printf(\"(%.5f, %.5f)\", (*p1).x, (*p1).y); printf(\"(%.5f, %.5f)\", (*p2).x, (*p2).y);\n\tprintf(\"(%.5f, %.5f)\", (rp1).x, (rp1).y); printf(\"(%.5f, %.5f)\\n\", (rp2).x, (rp2).y);*/\n\tif (*qdist>rd)*p1 = rp1, *p2 = rp2, *qdist = rd;\n\n\tint k = 0;\n\tP *vs = ss + is;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\trd = abs(vy[i].x - middle.x);\n\t\tif (rd < *qdist)\n\t\t\tvs[k++] = vy[i];\n\t}\n\tfor (int i = 0; i < k - 1; i++)\n\t\tfor (int j = i + 1; j < k&&vs[j].y - vs[i].y < *qdist; j++){\n\t\t\trd = distP(vs[i], vs[j]);\n\t\t\tif (*qdist > rd){\n\t\t\t\t*qdist = rd;\n\t\t\t\t*p1 = vs[i];\n\t\t\t\t*p2 = vs[j];\n\t\t\t}\n\t\t}\n\tis += k;\n\t//printf(\"(%.5f, %.5f)\", (*p1).x, (*p1).y);printf(\"(%.5f, %.5f)\\n\", (*p2).x, (*p2).y);\n}\n\nvoid Closest_Pair(int n, vector<P>& list, P* p1, P* p2, LL* qdist){\n\tix = n, iy = n,is=0;\n\tfor (int i = 0; i < n; i++)\n\t\txx[i] = yy[i] = list[i];\n\tsort(xx, xx+n, LessX);\n\tsort(yy, yy+n, LessY);\n\tClosest_Pair_rec(n,0,0,p1, p2, qdist);\n}\n/*\nint main(void){\n\tint N; cin >> N;\n\tLL a, b;\n\tP p1, p2;\n\tvector<P> A(N), B(N);\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i].x >> A[i].y;\n\t\t\n\t}\n\tClosest_Pair(N, A, &p1, &p2, &a);\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> B[i].x >> B[i].y;\n\t}\n\tClosest_Pair(N, B, &p1, &p2, &b);\n\t//cout << b << endl;\n\tprintf(\"%.6f\", sqrt((double)b / (double)a));\n\treturn(0);\n}\n*/\nint main(void){\n\tint N; cin >> N;\n\tLL a;\n\tP p1, p2;\n\tvector<P> A(N);\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i].x >> A[i].y;\n\n\t}\n\tClosest_Pair(N, A, &p1, &p2, &a);\n//\tcout << p1.x<<endl<<p1.y<<endl<< p2.x<< endl << p2.y << endl;\n\t//cout << b << endl;\n\tprintf(\"%.7f\", a);\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / acos(-1));\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * acos(-1) / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\n\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  if (r - l <= 3) {\n    PointPoint res(ps[l], ps[r - 1]);\n    for (int i = l; i < r; ++i) {\n      for (int j = i + 1; j < r; ++j) {\n        res = Closer(res, PointPoint(ps[i], ps[j]));\n      }\n    }\n    return res;\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  Points strip;\n  for (int i = l; i < r; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) strip.push_back(ps[i]);\n  }\n\n  for (int i = 0; i < strip.size(); ++i) {\n    for (int j = i + 1; j < strip.size(); ++j) {\n      if (Distance(strip[i], strip[j]) < d) {\n        d = Distance(strip[i], strip[j]);\n        res = PointPoint(strip[i], strip[j]);\n      }\n    }\n  }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  return ClosestPairUtil(ps, 0, ps.size());\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  sort(p.begin(), p.end());\n  PointPoint pp = ClosestPair(p);\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n  // cerr << pp.first << \" \" << pp.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pt pair<double,double>\n#define x first\n#define y second\nconst double INF=1e7;\npt p[100010];\ndouble pw2(double d){return d*d;}\ndouble dist(pt a,pt b){return sqrt(pw2(a.x-b.x)+pw2(a.y-b.y));}\nbool cmp(pt a,pt b){return a.y<b.y;}\ndouble closest(int l,int r)\n{\n  if(l==r) return INF;\n  int mid=(l+r)/2,pp=l,qq=mid+1;\n  double midline=p[mid].x;\n  double ret=min(closest(l,mid),closest(mid+1,r));\n  vector<pt> slab;\n  inplace_merge(p+l,p+mid+1,p+r+1,cmp);\n  for(int i=l;i<r;i++)if(p[i].y>p[i+1].y)cout<<\"ERROR\\n\";\n  //conquer\n  for(int i=l;i<=r;i++)\n    if(abs(p[i].x-midline)<ret)\n      slab.push_back(p[i]);\n  for(int i=0;i<slab.size();i++)\n    for(int j=i+1;j<slab.size() && abs(slab[i].y-slab[j].y)<ret;j++)\n      ret=min(ret,dist(slab[i],slab[j]));\n  return ret;\n}\nint main()\n{\n  int n;\n  cin>>n;\n  for(int i=1;i<=n;i++)\n    cin>>p[i].x>>p[i].y;\n  sort(p+1,p+n+1);\n  cout<<fixed<<closest(1,n)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nld getdis(const pair<ld, ld>&l, const pair<ld, ld>&r) {\n\treturn sqrt((l.first - r.first)*(l.first - r.first) + (l.second - r.second)*(l.second - r.second));\n}\nld getans(vector<pair<ld, ld>>ps) {\n\tif (ps.size() == 2) {\n\t\treturn getdis(ps[0], ps[1]);\n\t}\n\telse if (ps.size() <= 1) {\n\t\treturn 1e18;\n\t}\n\telse {\n\t\tint n = ps.size() / 2;\n\t\tld la = getans(vector<pair<ld, ld>>(ps.begin(), ps.begin() + ps.size() / 2));\n\t\tld ra = getans(vector<pair<ld, ld>>(ps.begin() + ps.size() / 2, ps.end()));\n\t\tld nans = min(la, ra);\n\t\tauto lit = lower_bound(ps.begin(), ps.end(), make_pair(ps[n].first - nans - 1, -1e18l));\n\t\tauto rit = upper_bound(ps.begin(), ps.end(), make_pair(ps[n].first + nans + 1,  1e18l));\n\t\tfor (auto a = lit; a != rit; ++a) {\n\t\t\tfor (auto b = next(a); b != rit; ++b) {\n\t\t\t\tnans = min(nans, getdis(*a, *b));\n\t\t\t}\n\t\t}\n\t\treturn nans;\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\tvector<pair<ld, ld>>ps;\n\tfor (int i = 0; i < N; ++i) {\n\t\tld x, y; cin >> x >> y;\n\t\tps.emplace_back(x, y);\n\t}\n\tsort(ps.begin(), ps.end());\n\tld ans = getans(ps);\n\tcout <<setprecision(22)<<fixed<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <utility>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define rep1(i,n) for(int i = 1; i <= n; ++i)\n#define F first\n#define S second\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if(a > b){ a = b; return 1; } return 0; }\nusing ll = long long;\nusing pi = pair<int,int>;\nconst double EPS = 1e-10;\nstruct Vec2 {\n  double x;\n  double y;\n\n  Vec2() : x(0.0),y(0.0){} \n  Vec2(double _x,double _y) :x(_x),y(_y){}  \n  \n  Vec2 operator+(const Vec2& other) const { return { x + other.x , y + other.y }; }\n  Vec2 operator-(const Vec2& other) const { return { x - other.x , y - other.y }; }\n  bool operator==(const Vec2& other) const { return (abs(x - other.x) < EPS && abs(y - other.y) < EPS ); }\n  //  bool operator<(const Vec2& other) const { if(abs(x - other.x) < EPS) return y < other.y; else return x < other.x; }\n  bool operator<(const Vec2& other) const { return x < other.x; }\n  \n  double dot(const Vec2& other) const { return x * other.x + y * other.y; }\n  double cross(const Vec2& other) const { return x * other.y - y * other.x; }\n  double length() const { return sqrt(x * x + y * y); }\n};\n// A とB のなす角θ cosθ, sinθ を返す\ndouble Cos(const Vec2 A, const Vec2 B) { return A.dot(B) / (A.length()*B.length()); }\ndouble Sin(const Vec2 A, const Vec2 B) { return A.cross(B) / (A.length()*B.length()); }\n\n// 線分AB上に点Cがあるかどうかの判定\nbool IsOnLine(const Vec2 A, const Vec2 B, const Vec2 C) {  return abs(Sin(A - C, B - C)) < EPS && Cos(A - C, B - C) < 0; }\n\n// 線分の交差判定\nbool CrossCheck(const Vec2 a, const Vec2 b, const Vec2 c, const Vec2 d) {\n  if(a == c || a == d || b == c || b == d) return true; // 端点が等しい場合はtrue\n  Vec2 AB = b - a, AC = c - a, AD = d - a;\n  Vec2 CA = a - c, CB = b - c, CD = d - c;\n  double s = AB.cross(AC) * AB.cross(AD);\n  double t = CD.cross(CA) * CD.cross(CB);\n\n  if(abs(Sin(AB, CD)) < EPS) { // 平行のとき\n    if(abs(Sin(AB, AC)) < EPS) { // 同一直線上にあるか？\n      return (CA.dot(CB) - EPS < 0 || (a - d).dot(b - d) - EPS < 0 || AC.dot(AD) - EPS < 0);\n    }\n    else return false;\n  }\n  else return s < EPS && t < EPS;\n}\n\npair<Vec2,Vec2> pd;\n// 最近点対\ndouble ClosestPair(vector<Vec2> &v, int l, int r) {\n  if(r - l <= 1) return 1e+15;\n  int mid = (l + r) / 2;\n  Vec2 O = v[mid];\n  double d = min(ClosestPair(v, l, mid), ClosestPair(v, mid, r));\n  sort(v.begin() + l, v.begin() + r, [](Vec2 a, Vec2 b) {\n\t\t\t\t\treturn a.y < b.y;\n\t\t\t\t      });\n\n  // 境界を跨ぐものをチェック\n  vector<Vec2> w;\n  for (int i = l; i < r; ++i) {\n    if(abs(v[i].x - O.x) >= d) continue;\n    for (int j = w.size() - 1; j >= 0; --j) {\n      if(abs(v[i].y - w[j].y) >= d) break;\n      chmin(d, (v[i] - w[j]).length());\n    }\n    w.push_back(v[i]);\n  }\n  return d;\n}\n\nint main()\n{\n  int n; cin >> n;\n  vector<Vec2> v(n);\n  rep(i,n) cin >> v[i].x >> v[i].y;\n\n  sort(v.begin(), v.end());\n  \n  double res = ClosestPair(v, 0, n);\n  printf(\"%.10f\\n\", res);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nbool pariCompare (const P& FElof, const P& SElof) {\n    if (FElof.first == SElof.first) return FElof.second < SElof.second;\n    return FElof.first < SElof.first;\n}\n\nint main ()\n{\n    int n;\n    cin >> n;\n    vector<P> p(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i].first >> p[i].second;\n    }\n\n    sort(p.begin(), p.end(), pariCompare);\n\n    double dis = 100000.0;\n    for (int i = 0; i < n-1; i++) {\n        for (int j = i + 1; j < n && (p[i].first - p[j].first < sqrt(dis) || p[i].second - p[j].second < sqrt(dis)); j++) {\n            double tmp = pow(p[i].first - p[j].first, 2.0) + pow(p[i].second - p[j].second, 2.0);\n            dis = min(dis, tmp);\n        }\n    }\n\n    printf(\"%.6f\\n\", sqrt(dis));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#################################################################\n//最近点対 O(n log n)\n\nnamespace closest_pair{\n\ntypedef pair<double, double> P;\n\nconst int MAX_N = 1000000;\nconst double INF = 1e77;\n\nint N;\nP A[MAX_N];\n\nbool compare_y(P a, P b){\n\treturn a.second < b.second;\n}\n\n//配列aはsortしなければいけない！！\ndouble closest_pair(P *a, int n){\n\tif(n <= 1) return INF;\n\tint m = n / 2;\n\tdouble x = a[m].first;\n\tdouble d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n\tinplace_merge(a, a + m, a + n, compare_y);\n\n\tvector<P> b;\n\tfor(int i=0;i<n;i++){\n\t\tif(fabs(a[i].first - x) >= d) continue;\n\t\tfor(int j=0;j<b.size();j++){\n\t\t\tdouble dx = a[i].first - b[b.size() - j - 1].first;\n\t\t\tdouble dy = a[i].second - b[b.size() - j - 1].second;\n\t\t\tif(dy >= d) break;\n\t\t\td = min(d, sqrt(dx * dx + dy * dy));\n\t\t}\n\t\tb.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n  void solve() {\n    cin >> N;\n    for(int i = 0; i < N; ++i) {\n      cin >> A[i].first >> A[i].second;\n    }\n    sort(A, A+N);\n    printf(\"%.10f\\n\", closest_pair(A, N));\n  }\n\n}\n\nint main() {\n  closest_pair::solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n\tint N;\n\tcin >> N;\n\tint i, j;\n\tdouble pt[100000][2], m, x, y, tmp, n, xm, ym;\n\tn = xm = ym = 100000000;\n\tfor (i = 0; i < N; i++) {\n\t\tcin >> pt[i][0] >> pt[i][1];\n\t\tm = 100000000;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tx = pt[i][0] - pt[j][0];\n\t\t\ty = pt[i][1] - pt[j][1];\n\t\t\tif (x < xm || y < ym) {\n\t\t\t\ttmp = x * x + y * y;\n\t\t\t\tif (tmp < m) {\n\t\t\t\t\tm = tmp;\n\t\t\t\t\txm = x;\n\t\t\t\t\tym = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (m < n) {\n\t\t\tn = m;\n\t\t}\n\t}\n\tprintf(\"%f\\n\", sqrt(n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nconst double inf=1e20;\n\ninline int sign(const double &x){\n    if(x>EPS) return 1;\n    else if(x<-EPS) return -1;\n    return 0;\n}\n\n/*   点  */\nstruct Point{\n    double x,y;\n\n    Point(double x=0,double y=0):x(x),y(y){}\n\n    Point operator + (Point p) { return Point(x+p.x,y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x,y-p.y); }\n    Point operator * (double k) { return Point(k*x,k*y); }\n    Point operator / (double k) { return Point(x/k,y/k); }\n\n    //向量的大小\n    inline double abs(){ return sqrt(norm()); }\n    inline double norm() { return x*x+y*y; }\n\n    bool operator < (const Point & p) const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n    bool operator == (const Point & p) const {\n        return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n    }\n};\n\n//两点间的距离\ninline double getDistance(Point a,Point b){\n    return (a-b).abs();\n}\n\n/*   向量  */\ntypedef Point Vector;\n\n//向量a和b的内积\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n//向量a和b的外积\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\n/*   线段  */\nstruct Segment{\n    Point p1,p2;\n};\n\n//点p在线段s上的投影\nPoint project(Segment s,Point p){\n    Vector base = s.p2-s.p1;\n    double r=dot(p-s.p1,base)/base.norm();\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n/*   直线  */\ntypedef Segment Line;\n\n//点到直线的距离\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/(l.p2-l.p1).abs());\n}\n\n//点到线段的距离\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return (p-s.p1).abs();\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return (p-s.p2).abs();\n    return getDistanceLP(s,p);\n}\n\n//判断p2与向量p1-p0的位置关系\n\nconst int COUNTER_CLOCKWISE = -1;   //逆时针\nconst int CLOCKWISE = 1;            //顺时针\nconst int ON_SEGMENT = 0;           //在线段上\nconst int ONLINE_BACK = 2;          //p2在向量p1-p0的反方向延长线上\nconst int ONLINE_FRONT = -2;        //p2在向量p1-p0的正方向延长线上\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CLOCKWISE;\n    if(dot(a,b)<-EPS) return ONLINE_BACK;\n    if(a.norm()<b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//判断线段p1p2与线段p3p4是否相交\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n             ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n//线段与线段的距离\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\n//两个线段的交点(对于直线跟线段也适用，但注意base是在直线上)\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n/* 直线正交\n * 判断向量a，b是否正交 =》a，b的内积为0\n */\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\n/* 直线平行\n * 判断向量a，b是否平行 =》a，b的内积为0\n */\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point() ,double r = 0.0 ):c(c),r(r){}\n};\n\n/* 圆与直线的交点\n * 交点为一个的时候返回两个相同的点\n * 没有交点则退出\n */\n\nbool intersect(Circle c,Line l){\n    return sign(getDistanceLP(l,c.c)-c.r)<=0;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n    assert(intersect(c,l));         //没有交点\n    Point pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n    double base=sqrt(c.r*c.r-(pr-c.c).norm());\n    return make_pair(pr+e*base,pr-e*base);\n}\n\n\n//圆与圆的交点\n\nbool intersect(Circle c1,Circle c2){\n    return sign(getDistance(c1.c,c2.c)-(c1.r+c2.r))<=0;\n}\n\ndouble arg(Vector p){\n    return atan2(p.y,p.x);// double atan2(double y,double x) 返回的是原点至点(x,y)的方位角，即与 x 轴的夹角。返回值的单位为弧度，取值范围为(-PI,PI]\n}\n\nVector polar(double r,double a){\n    return Point(cos(a)*r,sin(a)*r);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    assert(intersect(c1,c2));\n    double d=(c1.c-c2.c).abs();\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\n/*   多边形  */\ntypedef vector<Point> Polygon;\n\n//点的****内包*****(判断点与多边形的关系)\n//多边形内返回2\n//多边形上返回1\n//多边形外返回0\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return 1;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) x=!x;\n    }\n    return (x?2:0);\n}\n\n/* *******凸包*****(包含点集合p中所有点的最小凸多边形)\n * 输出凸多边形最下端最左侧的顶点为起点,按逆时针方向依次输出坐标。\n * 安德鲁算法 O(n*logn)\n */\n\ndouble Area(Point p0,Point p1,Point p2){\n    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\n}\n\nPolygon andrewscanf(Polygon s){\n    int n=s.size();\n    sort(s.begin(),s.end());    //x从小到大，x相同的y从小到大\n    Polygon u;\n    //构建凸包上部\n    for(int i=0;i<n;i++){\n        for(int j=u.size();j>=2&&Area(u[j-2],u[j-1],s[i]) <= EPS;j--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    //构建凸包下部\n    int tmp=u.size()+1;\n    for(int i=n-2;i>=0;i--){\n        for(int j=u.size();j>=tmp&&Area(u[j-2],u[j-1],s[i]) <= EPS;j--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    //按顺序生成凸包点的序列\n    if(n>1) u.pop_back();               //开始点多加入了一次\n    return u;\n}\n\n//旋转卡壳*-------》计算凸包直径\ndouble RC(Polygon v){\n    double res=0;\n    int n=v.size();\n    int k=1;\n    for(int i=0;i<n;i++){\n        while(sign(Area(v[i],v[(i+1)%n],v[(k+1)%n])-Area(v[i],v[(i+1)%n],v[k%n]))==1) k=(k+1)%n;\n        res=max(res,max((v[i]-v[k]).abs(),(v[(i+1)%n]-v[k]).abs()));\n    }\n    return res;\n}\n\n//  平面上最近点对。（分治  nlognlogn）\nPoint a[100005],b[100005];\n\ninline bool CmpY(Point a,Point b){\n    return a.y<b.y;\n}\n\ndouble Divide_Conquer(int l,int r){\n    if(l==r) return inf;\n    if(l+1==r) return getDistance(a[l],a[r]);\n    int mid=l+r>>1;\n    double ans=min(Divide_Conquer(l,mid),Divide_Conquer(mid+1,r));\n    int len=0;\n    for(int i=l;i<=r;i++){\n        if(fabs(a[mid].x-a[i].x)<=ans) b[len++]=a[i];\n    }\n    sort(b,b+len,CmpY);\n    for(int i=0;i<len;i++){\n        for(int j=i+1;j<len&&(b[j].y-b[i].y<ans);j++){\n            ans=min(ans,getDistance(b[i],b[j]));\n        }\n    }\n    return ans;\n}\n\ninline void solve(int n){\n    sort(a,a+n);\n    printf(\"%.10f\\n\",Divide_Conquer(0,n-1));\n}\n\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lf%lf\",&a[i].x,&a[i].y);\n    }\n    solve(n);\n    return 0;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n    double p_xy2[100000][2];\n    for(int i=n0; i<n; i++){\n        p_xy2[i][0]=p_xy[i][0];\n        p_xy2[i][1]=p_xy[i][1];\n    }\n    two_dimensional_qsort(p_xy2, n0, n-1, 1);\n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy2[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy2[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy2[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy2[i][0]);\n        b_y.push_back(p_xy2[i][1]);\n    }\n    \n    return d;\n    \n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        \n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<< ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @note   関連URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0585\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = limits::inf;\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) + limits::eps  >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) >= delta + limits::eps) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<utility>\n\ntypedef pair<double, double> point;\n\ndouble dist(const point &p1, const point &p2)\n{\n\tdouble dx = p1.first - p2.first;\n\tdouble dy = p1.second - p2.second;\n\treturn sqrt(dx * dx + dy * dy);\n}\n\nbool sort_y(const point &p1, const point &p2){ return p1.second < p2.second; }\n\npoint Z[100000];\n\ndouble closest(point X[], point Y[], int n)\n{\n\tif(n <= 3){\n\t\tdouble d = dist(X[0], X[1]);\n\t\tfor(int i = 0; i < n; i++){ Y[i] = X[i]; }\n\t\tsort(Y, Y + n, sort_y);\n\n\t\tif(n < 3){ return d; }\n\t\telse{ return min(d, min(dist(X[0], X[2]), dist(X[1], X[2]))); }\n\t}\n\tint m = (n >> 1);\n\tdouble median = X[m].first;\n\tdouble d = min(closest(X, Y, m), closest(X + m, Y + m, n - m));\n\n\tint size = 0;\n\tint i = 0, j = m;\n\twhile(i < m && j < n){\n\t\tif(i < m && j < n){\n\t\t\tif(Y[i].second < Y[j].second){\n\t\t\t\tZ[size] = Y[i]; size++; i++;\n\t\t\t}else{\n\t\t\t\tZ[size] = Y[j]; size++; j++;\n\t\t\t}\n\t\t}\n\t\tif(i == m && j < n){ while(j < n){ Z[size] = Y[j]; size++; j++; }; }\n\t\tif(i < m && j == n){ while(i < m){ Z[size] = Y[i]; size++; i++; }; }\n\t};\n\t// int resize = 0;\n\t// for(i = 0; i < size; i++){\n\t// \tif(fabs(Z[i].first - median) <= d){ Z[resize] = Z[i]; resize++; }\n\t// }\n\n\tint a = 0;\n\tfor(i = 1; i < size; i++){\n\t\tfor(j = a; j < i; j++){\n\t\t\tif(Z[i].second - Z[a].second > d){ a++; }\n\t\t\telse{\n\t\t\t\td = min(d, dist(Z[i], Z[a]));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\n\nint main()\n{\n\tpoint X[100000], Y[100000];\n\tint i, n;\n\tscanf(\"%d\", &n);\n\n\tdouble co_x, co_y;\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &co_x, &co_y);\n\t\tX[i] = make_pair(co_x, co_y);\n\t}\n\tsort(X, X + n);\n\n\tdouble d = closest(X, Y, n);\n\tprintf(\"%.14f\\n\", d);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS; }\n\nusing Point = complex< double >;\n\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble radian_to_degree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble degree_to_radian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() {}\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(double A, double B, double C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() {}\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle() {}\n\n  Circle(Point p, double r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\ndouble cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\nbool parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ndouble distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\ndouble distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\ndouble distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\ndouble distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\ndouble distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point hp = projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return {hp - v, hp + v};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\nenum {\n  OUT, ON, IN\n};\n\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\nbool merge_if_able(Segment &s1, Segment s2) {\n  if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid merge_segments(vector< Segment > &segs) {\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon convex_cut(Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble area2(const Polygon &p) {\n  double A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble convex_diameter(Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\npair< Point, Point > closer(const pair< Point, Point > &a, const pair< Point, Point > &b) {\n  return distance(a.first, a.second) < distance(b.first, b.second) ? a : b;\n}\n\npair< Point, Point > closest_pair_util(Points &ps, int l, int r) {\n  if(r - l == 2) {\n    return {ps[l], ps[l + 1]};\n  }\n  if(r - l == 3) {\n    pair< Point, Point > a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return closer(a, closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  auto res = closer(closest_pair_util(ps, l, mid), closest_pair_util(ps, mid, r));\n  double d = distance(res.first, res.second);\n\n  Points pos[2];\n  for(int i = l; i < r; ++i) {\n    if(abs(ps[i].real() - midPoint.real()) < d) pos[i < mid].push_back(ps[i]);\n  }\n  for(const auto &i : pos[0]) {\n    for(const auto &j : pos[1]) {\n      if(distance(i, j) < d) {\n        d = distance(i, j);\n        res = {i, j};\n      }\n    }\n  }\n  return res;\n}\n\npair< Point, Point > closest_pair(Points ps) {\n  if(ps.size() <= 1) exit(-1);\n  sort(ps.begin(), ps.end());\n  if(ps.size() == 2) return {ps[0], ps[1]};\n  auto res = closest_pair_util(ps, 0, ps.size());\n  return res;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  Points p(N);\n  for(auto &s : p) cin >> s;\n  auto pp = closest_pair(p);\n  cout << fixed << setprecision(10) << distance(pp.first, pp.second) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<utility>\n \ntypedef pair<double, double> point;\ntypedef point* data;\n \ndouble dist(const point &p1, const point &p2)\n{\n    double dx = p1.first - p2.first;\n    double dy = p1.second - p2.second;\n    return sqrt(dx * dx + dy * dy);\n}\n \nbool sort_y(const point &p1, const point &p2){ return p1.second < p2.second; }\n \ndouble closest(data X, data Y, int n)\n{\n    if(n <= 3){\n        double d = dist(X[0], X[1]);\n        for(int i = 0; i < n; i++){ Y[i] = X[i]; }\n        sort(Y, Y + n, sort_y);\n \n        if(n < 3){ return d; }\n        else{ return min(d, min(dist(X[0], X[2]), dist(X[1], X[2]))); }\n    }\n    int m = (n >> 1);\n    double median = X[m].first;\n    double d = min(closest(X, Y, m), closest(X + m, Y + m, n - m));\n \n    data Z; int size = 0;\n    Z = new point [n];\n    int i = 0, j = m;\n    while(i < m && j < n){\n        if(i < m && j < n){\n            if(Y[i].second < Y[j].second){\n                Z[size] = Y[i]; size++; i++;\n            }else{\n                Z[size] = Y[j]; size++; j++;\n            }\n        }\n        if(i == m && j < n){ while(j < n){ Z[size] = Y[j]; size++; j++; }; }\n        if(i < m && j == n){ while(i < m){ Z[size] = Y[i]; size++; i++; }; }\n    };\n    int resize = 0;\n    for(i = 0; i < size; i++){\n        if(fabs(Z[i].first - median) <= d){ Z[resize] = Z[i]; resize++; }\n    }\n \n    int a = 0;\n    for(i = 1; i < resize; i++){\n        for(j = a; j < i; j++){\n            if(Z[i].second - Z[j].second > d){ a++; }\n            else{\n                d = min(d, dist(Z[i], Z[j]));\n            }\n        }\n    }\n    delete [] Z;\n    return d;\n}\n \nint main()\n{\n    data X, Y;\n    int i, n;\n    scanf(\"%d\", &n);\n    X = new point [n];\n    Y = new point [n];\n \n    double co_x, co_y;\n    for(i = 0; i < n; i++){\n        scanf(\"%lf %lf\", &co_x, &co_y);\n        X[i] = make_pair(co_x, co_y);\n    }\n    sort(X, X + n);\n \n    double d = closest(X, Y, n);\n    printf(\"%.12f\\n\", d);\n \n    cin >> n;\n    delete [] X;\n    delete [] Y;\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n\n    two_dimensional_qsort(p_xy, n0, n-1-n0, 1);\n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        //cout<<\"qaaa\";\n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn 1e9;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP,\n\tint yl,int yr\n){\n\tint xsiz=xr-xl;\n\tint ysiz=yr-yl;\n\tif (xsiz <= 3) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tif(ysiz==0)return 1e9;\n\t//printf(\"%d %d %d %d\\n\",xl,xr,yl,yr);\n\tauto xM = xP[xl+xsiz/2].first;\n\tauto yL = std::vector<point_t>(ysiz);\n\tint left = -1, right = ysiz;\n\tfor(int i = yl; i < yr; i++){\n\t\tif (yP[i].first < xM) yL[++left] = yP[i];\n\t\telse                  yL[--right]= yP[i];\n\t}\n\tstd::reverse(yL.begin()+right,yL.end());\n\tauto p1 = find_closest_optimized(xP,xl,xl+xsiz/2,yL,0,left+1);\n\tauto p2 = find_closest_optimized(xP,xl+xsiz/2,xr,yL,left+1,ysiz);\n\tauto minD = sqrt((p1 <= p2) ? p1 : p2);\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n,yP,0,n);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 200000\npair<long double, long double>pa[MAX_N];\nlong double dist(long double ax, long double ay, long double bx, long double by) { \n\treturn sqrt((ax - bx)*(ax - bx) + (ay - by)*(ay - by));\n}\nint main() {\n\tint N; cin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> pa[i].first >> pa[i].second;\n\t}\n\tsort(pa, pa + N);\n\tlong double maxn = 100000;\n\tlong double G = 200 / (sqrt(N) - 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tlong double L = pa[i].first - G, R = pa[i].first + G;\n\t\tint pos1 = lower_bound(pa, pa + N, make_pair(L, -1000.0L)) - pa;\n\t\tint pos2 = lower_bound(pa, pa + N, make_pair(R, 1000.0L)) - pa;\n\t\tfor (int j = pos1; j < pos2; j++) {\n\t\t\tif (i == j) { continue; }\n\t\t\tmaxn = min(maxn, dist(pa[i].first, pa[i].second, pa[j].first, pa[j].second));\n\t\t}\n\t}\n\tcout << fixed << setprecision(5141919) << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = min(abs(data[i + 1].second - data[i].second), ans + 0.00018);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&memo >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans = (min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tmemo = min(memo, ans + 0.00017);\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nstatic const double EPS=1e-12;\nstatic const double INF=1e24;\n\nusing Point=complex<double>;\nusing Plane=vector<Point>;\nusing Polygon=vector<Point>;\n\nbool operator<(const Point &a, const Point &b) {\n    return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n}\n\ndouble cross_prod(const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot_prod(const Point &a, const Point &b) {\n    return real(conj(a)*b);\n}\n\nenum {\n    ONLINE_FRONT=-2,\n    CLOCKWISE,\n    ON_SEGMENT,\n    COUNTER_CLOCKWISE,\n    ONLINE_BACK,\n};\n\nint ccwise(Point a, Point b, Point c) {\n    b -= a; c -= a;\n\n    if (cross_prod(b, c) > 0) {\n        return COUNTER_CLOCKWISE;\n    } else if (cross_prod(b, c) < 0) {\n        return CLOCKWISE;\n    } else if (dot_prod(b, c) < 0) {\n        return ONLINE_BACK;\n    } else if (norm(b) < norm(c)) {\n        return ONLINE_FRONT;\n    } else {\n        return ON_SEGMENT;\n    }\n}\n\ntemplate <class LineType>\nint ccwise(LineType l, Point p) {\n    return ccwise(l.first, l.second, p);\n}\n\nstruct Line: public pair<Point, Point> {\n    Line() {}\n    Line(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\nstruct LineSeg: public pair<Point, Point> {\n    LineSeg() {}\n    LineSeg(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\ntemplate <class RandomIt=Polygon::iterator>\npair<Point, Point> closest_pair(RandomIt first, RandomIt last) {\n    size_t n=last-first;\n    if (n < 2)\n        return make_pair(Point(-INF, -INF), Point(INF, INF));\n\n    RandomIt mid=first+n/2;\n    double x=real(*mid);\n    pair<Point, Point> p1=closest_pair(first, mid);\n    pair<Point, Point> p2=closest_pair(mid, last);\n    inplace_merge(first, mid, last, [](const Point &lhs, const Point &rhs) {\n        return imag(lhs) < imag(rhs);\n    });\n\n    double d1=norm(p1.first-p1.second), d2=norm(p2.first-p2.second);\n    double d=(d1<d2? d1:d2);\n    pair<Point, Point> res=(d1<d2? p1:p2);\n\n    vector<Point> b;\n    for (RandomIt it=first; it<last; ++it) {\n        if (norm(real(*it)-x) >= d) continue;\n\n        for (size_t j=0; j<b.size(); ++j) {\n            Point e=*it-b[b.size()-j-1];\n            if (imag(e) >= sqrt(d)) break;\n\n            if (d > norm(e)) {\n                d = norm(e);\n                res = make_pair(*it, b[b.size()-j-1]);\n            }\n        }\n        b.push_back(*it);\n    }\n\n    return res;\n}\n\nint main() {\n    size_t n;\n    scanf(\"%zu\", &n);\n\n    Polygon g(n);\n    for (size_t i=0; i<n; ++i) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        g[i] = Point(x, y);\n    }\n\n    sort(g.begin(), g.end(), [](const Point &lhs, const Point &rhs) {\n        return real(lhs)!=real(rhs)? real(lhs)<real(rhs) : imag(lhs)<imag(rhs);\n    });\n\n    pair<Point, Point> p=closest_pair(g.begin(), g.end());\n    printf(\"%.9f\\n\", abs(p.first-p.second));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\n\nint main(void)\n{\n    double dis=1000.0,temp=1000.0;\n    double temp_x,temp_y;\n    int n;\n    double x[100000],y[100000];\n\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>x[i]>>y[i];\n    \n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            if(i!=j)\n            {\n                temp = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n                if(dis>temp)\n                {\n                    dis=temp;\n                }\n            }\n        }\n    }\n    \n\n    printf(\"%lf\\n\",dis);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\ntypedef double number;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<number> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\ntypedef vector<P> G;\n\nnumber closestPair(G &p) {\n  int n = p.size(), s = 0, t = 1, m = 2, S[n]; S[0] = 0, S[1] = 1;\n  sort(ALL(p)); // \"p < q\" <=> \"p.x < q.x\"\n  double d = norm(p[s]-p[t]);\n  for (int i = 2; i < n; S[m++] = i++) REP(j, m) {\n    if (norm(p[S[j]]-p[i])<d) d = norm(p[s = S[j]]-p[t = i]);\n    if (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n  }\n  return abs(p[s]-p[t]);//make_pair( p[s], p[t] );\n}\n\nint main(){\n\tG poly;\n\tP p;\n\tint n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);n--;poly.push_back(p))scanf(\"%lf%lf\",&x,&y),p=P(x,y);\n\tprintf(\"%f\\n\",closestPair(poly));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf dist ( pt A, pt B ) { return norm( B - A ); }\n\nint n;\npt P[ MAXN ], extra[ MAXN ];\n\nbool cmpX( const pt &A, const pt &B ) {\n  //if( same( A.x, B.x ) ) return A.y+EPS < B.y;\n  //return A.x+EPS < B.x;\n  return A.x < B.x;\n}\n\nlf sqr( lf x ) {\n  return x*x;\n}\n\nvoid merge( int f, int m, int t ){\n\tint total = t - f + 1;\n\tfor( int i = 0, l = f, r = m+1; i < total; ++i ){\n\t\tif( l == m+1 ){\n      extra[ i ] = P[ r++ ];\n\t\t}\n\t\telse if( r == t+1 ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse if( P[l].y < P[r].y ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse{\n\t\t  extra[ i ] = P[ r++ ];\n\t\t}\n\t}\n\tfor( int i = 0; i < total; ++i ){\n    P[ f+i ] = extra[ i ];\n\t}\n}\n\nlf solve( int f, int t ) {\n  if( f == t ) return oo;\n\tint mi = (f + t)/2;\n\tlf d = min( solve( f, mi ), solve( mi+1, t ) );\n\tmerge( f, mi, t );\n\tvector< int > idxs;\n\tfor( int i = f; i <= t; ++i ){\n\t\tif( sqr(P[mi].x - P[i].x ) < d ) idxs.push_back( i );\n\t}\n\tfor( int i = 0; i < idxs.size(); ++i ){\n\t\tfor( int j = i+1; j < idxs.size() && sqr(P[ idxs[i] ].y - P[ idxs[j] ].y) < d; ++j ){\n\t\t\td = min( d, dist( P[ idxs[i] ], P[ idxs[j] ] ) );\n\t\t}\n\t}\n\treturn d;\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  sort( P, P+n, cmpX );\n  /*d = oo;\n  for( int i = 0; i < n; ++i ) {\n    for( int j = i+1; j < n; ++j ) {\n      d = min( d, dist(P[i],P[j]) );\n    }\n  }\n  cout << double(sqrt(d)) << '\\n';*/\n  cout << double( sqrt(solve( 0, n-1 )) ) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate<class T>\nstruct Vec2\n{\n\tVec2(){}\n\tVec2(T _x, T _y) : x(_x), y(_y) {}\n\n\tVec2 operator+(const Vec2& rhs) const { return Vec2(x + rhs.x, y + rhs.y); }\n\tVec2 operator-(const Vec2& rhs) const { return Vec2(x - rhs.x, y - rhs.y); }\n\tT sqlength() const { return x*x + y*y; }\n\n\tT x, y;\n};\n\ntypedef Vec2<double> Vec;\ntypedef long long ll;\n\nstatic int Rand()\n{\n\tstatic int r = 123456789;\n\tr = r ^ (r << 13);\n\tr = r ^ (r >> 17);\n\tr = r ^ (r << 5);\n\treturn r;\n}\n\ninline static ll Cell(const Vec& p, double w)\n{\n\treturn  (ll(p.x / w) << 32) + ll(p.y / w);\n}\n\nint main()\n{\n\tint n = 0;\n\tcin >> n;\n\n\tvector<Vec> P;\n\tP.reserve(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble x, y;\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t\tP.push_back(Vec(x+200,y+200));\n\t}\n\n\tint ip = Rand()%P.size();\n\tdouble w = 1000000.0;\n\tfor (size_t i = 0; i < P.size(); i++) {\n\t\tif (i != ip) {\n\t\t\tdouble d = (P[i] - P[ip]).sqlength();\n\t\t\tw = min(w,d);\n\t\t}\n\t}\n\tw = sqrt(w) * 1.01;\n\n\tunordered_map<ll, vector<size_t>> grid;\n\tfor (size_t i = 0; i < P.size(); i++) {\n\t\tgrid[Cell(P[i], w)].push_back(i);\n\t}\n\n\tdouble ans = 1000000.0;\n\tfor (size_t i = 0; i < P.size(); i++) {\n\t\tconst ll c = Cell(P[i], w), X = ll(1)<<32;\n\t\tconst ll neighbors[9] = { c - X - 1, c - X, c - X + 1, c - 1, c, c + 1, c + X - 1, c + X, c + X + 1 };\n\t\tvector<size_t> v;\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tauto it = grid.find(neighbors[j]);\n\t\t\tif (it == grid.end()) continue;\n\t\t\tfor (const auto& k : it->second) {\n\t\t\t\tif (k != i) {\n\t\t\t\t\tdouble d = (P[k] - P[i]).sqlength();\n\t\t\t\t\tans = min(ans, d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", sqrt(ans));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nstruct Point {\n  ld x, y;\n\n  Point(ld x = 0, ld y = 0): x(x), y(y) {}\n\n  Point operator + (Point &p) {\n    return Point(x + p.x, y + p.y);\n  }\n\n  Point operator - (Point &p) {\n    return Point(x - p.x, y - p.y);\n  }\n\n  Point operator * (ld k) {\n    return Point(x * k, y * k);\n  }\n\n  Point operator / (ld k) {\n    return Point(x / k, y / k);\n  }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\n\nld norm(Point p) {\n  return p.x * p.x + p.y * p.y;\n}\n\nld dist(Point p) {\n  return sqrt(norm(p));\n}\n\nld dot(Point p1, Point p2) {\n  return p1.x * p2.x + p1.y * p2.y;\n}\n\nld cross(Point p1, Point p2) {\n  return p1.x * p2.y - p1.y * p2.x;\n}\n\nPoint rotate(Point p, ld theta) {\n  return Point(p.x * cos(theta) - p.y * sin(theta), p.x * sin(theta) + p.y * cos(theta));\n}\n\n//1:反時計回り\n//-1:時計回り\n//2:p2, p0, p1の順で同一直線上\n//-2:p0, p1, p2の順\n//0:p2が線分p0, p1上\nint ccw(Point p0, Point p1, Point p2) {\n  Point v1 = p1 - p0, v2 = p2 - p0;\n  if (cross(v1, v2) > 0) return 1;\n  else if (cross(v1, v2) < 0) return -1;\n  else if (dot(v1, v2) < 0) return 2;\n  else if (norm(v1) < norm(v2)) return -2;\n  else return 0;\n}\n\n//線分p1, p2がp3, p4と交差するか\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\n//直線p2-p1と点p3の距離\nld getDistanceLP(Point p1, Point p2, Point p3) {\n  return fabs(cross(p2-p1, p3-p1) / dist(p2-p1));\n}\n\n//線分s(p2-p1)と点p3の距離\nld getDistanceSP(Point p1, Point p2, Point p3) {\n  if (dot(p2-p1, p3-p1) < 0) return dist(p3-p1);\n  else if (dot(p1-p2, p3-p2) < 0) return dist(p3-p2);\n  else return getDistanceLP(p1, p2, p3);\n}\n\n//線分s1(p2-p1)と線分s2(p4-p3)の距離\nld getDistanceTS(Point p1, Point p2, Point p3, Point p4) {\n  if (intersect(p1, p2, p3, p4)) return 0;\n  ld ans = INF;\n  ans = min(ans, getDistanceSP(p1, p2, p3));\n  ans = min(ans, getDistanceSP(p1, p2, p4));\n  ans = min(ans, getDistanceSP(p3, p4, p1));\n  ans = min(ans, getDistanceSP(p3, p4, p2));\n  return ans;\n}\n\nvector<Point> convex_hull(vector<Point>& ps, int n) {\n  sort(ps.begin(), ps.end());\n  int k = 0;\n  vector<Point> qs(2 * n);\n  rep(i, n) {\n    while (k > 1 && cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for (int i = n - 2, t = k; i >= 0; i--) {\n    while (k > t && (cross(qs[k - 1] - qs[k - 2], ps[i] - qs[k - 1]) <= 0)) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k - 1);\n  return qs;\n}\n\n//円\nstruct Circle {\n  Point p;\n  ld r;\n\n  Circle() {}\n  Circle(Point p, ld r): p(p), r(r) {}\n};\n\n//２円の交点\nvector<Point> getIntersections(Circle c1, Circle c2) {\n  ld d = dist(c2.p - c1.p);\n  ld rc = (c1.r * c1.r + d * d - c2.r * c2.r) / (2 * d);\n  ld rs = sqrt(c1.r * c1.r - rc * rc);\n  Point e1 = (c2.p - c1.p) / d;\n  Point e2 = rotate(e1, M_PI / 2) * rs;\n  Point e3 = rotate(e1, -M_PI / 2) * rs;\n  e1 = e1 * rc;\n  Point a = c1.p + e1 + e2;\n  Point b = c1.p + e1 + e3;\n  return {a, b};\n}\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  int n;\n  cin >> n;\n  vector<Point> p(n);\n  rep(i, n) {\n    cin >> p[i].x >> p[i].y;\n    p[i] = rotate(p[i], 1);\n  }\n\n  sort(p.begin(), p.end());\n  ld ans = INF;\n  rep(i, n) {\n    repr(j, i - 1) {\n      if (p[i].x - p[j].x > ans) break;\n      chmin(ans, dist(p[i] - p[j]));\n    }\n  }\n  cout << ans << '\\n';\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int maxx=1e5+6;\n\nclass point {\npublic:\n\tdouble x,y;\n\tpoint(double x=0,double y=0):x(x),y(y){}\n\n\tbool operator < (const point &u)const{\n\t\tif(x!=u.x) return x<u.x;\n\t\treturn y<u.y;\n\t}   \n};\npoint a[maxx],b[maxx];\n\ninline double dis(point a,point b){ return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)); }\ninline bool cmp(point a,point b){return a.y<b.y;}\ndouble solve(int left,int right){\n\tif(left+1==right) return dis(a[left],a[right]);\n\tdouble xl,xr,xm;\n\tint mid=(left+right)>>1;\n\txl=solve(left,mid);\n\txr=solve(mid,right);\n\txm=min(xl,xr);\n\tint k=1;\n\tfor(int i=left;i<=right;i++){\n\t\tif(fabs(a[mid].x-a[i].x)<=xm) b[k++]=a[i];\n\t}\n\tsort(b+1,b+k,cmp);\n\tfor(int i=1;i<k;i++){\n\t\tfor(int j=i+1;j<k && (b[j].y-b[i].y<xm);j++){\n\t\t\txm=min(xm,dis(b[i],b[j]));\n\t\t}\n\t}\n\treturn xm;\n}\n\nint main() {\n\tint n;\n\tdouble x,y;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\ta[i]=point(x,y);\n\t}\n\tsort(a+1,a+1+n);\n\tdouble ans=solve(1,n);\n\tprintf(\"%.6f\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&min(memo,ans+0.0002) >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans =(min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++) \n \n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n struct point\n {\n   double x;\n   double y;       \n }point[100002];\n \n int n;\n double result=40000.0*2;\n double num;\n \n \n //1.63?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n void init()\n {\n      \n }\n \n void wuhao()\n {\n        \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   } \n   general_way();\n   printf(\"%lf.7\\n\",1.0*sqrt(result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\n/*struct P\n{\n\tdouble x, y;\n\tP(double x,double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};*/\n\n/*int ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}*/\n\ndouble dist(pdd a, pdd b)\n{\n\treturn (a.first - b.first)*(a.first - b.first) + (a.second - b.second)*(a.second - b.second);\n}\n\ndouble ClosestPair(vector<pdd>& points,int l,int r)\n{\n\tif (r - l == 1)\n\t{\n\t\treturn INF;\n\t}\n\tif (r - l == 2)\n\t{\n\t\treturn dist(points[l], points[l + 1]);\n\t}\n\n\tint m = (l + r) / 2;\n\tdouble d = min(ClosestPair(points, l, m), ClosestPair(points, m, r));\n\n\tvector<pdd> tempP;\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tif ((points[l].first - points[m].first)*(points[l].first - points[m].first) < d)\n\t\t{\n\t\t\ttempP.emplace_back(make_pair(points[i].second, points[i].first));\n\t\t}\n\t}\n\tsort(tempP.begin(), tempP.end());\n\tfor (int i = 0; i != tempP.size(); i++)\n\t{\n\t\tfor (int j = i + 1; j != tempP.size(); j++)\n\t\t{\n\t\t\tif ((tempP[j].first - tempP[i].first)*(tempP[j].first - tempP[i].first) > d)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, dist(tempP[i], tempP[j]));\n\t\t}\n\t}\n\n\treturn d;\n}\n\nvector<pdd> points;\n\nint main()\n{\n\tpoints.reserve(100000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpoints.push_back(make_pair(x, y));\n\t}\n\n\tsort(points.begin(), points.end());\n\n\tprintf(\"%lf\\n\", sqrt(ClosestPair(points, 0, n)));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.00000000001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct vec{\n  double x, y;\n  void nextvec(){ scanf(\"%lf %lf\", &x, &y); return; }\n  vec operator+(const vec& a) const { return (vec){x + a.x, y + a.y}; }\n  vec operator-(const vec& a) const { return (vec){x - a.x, y - a.y}; }\n  vec operator*(const double& k) const { return (vec){k * x, k * y}; }\n  vec sca(double t){ return (vec){t * x, t * y}; }\n  double dot(vec a){ return x * a.x + y * a.y; }\n  double cross(vec a){ return x * a.y - y * a.x; }\n  double norm(){ return sqrt(x * x + y * y); }\n  double norm2(){ return x * x + y * y; }\n};\n\nbool xsort(vec qwe, vec rty){ return qwe.x < rty.x; }\nbool ysort(vec qwe, vec rty){ return qwe.y < rty.y; }\n\nvector<vec> pt;\ndouble ma = 100000000000.0;\n\nvec fory[500000];\ndouble closestpair(int l, int r){\n  if(r - l <= 1)return ma;\n  int m = l + (r - l) / 2;\n  double xm = pt[m].x;\n  double res = closestpair(l, m);\n  res = min(res, closestpair(m, r));\n\n  inplace_merge(pt.begin() + l, pt.begin() + m, pt.begin() + r, ysort);\n  int hd = 0;\n  for(int i = l;i < r;++i)if(pt[i].x - xm <= res + eps){\n    fory[hd++] = pt[i];\n    for(int j = hd - 2;j >= 0;--j){\n      if(fory[j].y - pt[i].y > res + eps)break;\n      res = min(res, (pt[i] - fory[j]).norm());\n    }\n  }\n  return res;\n}\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int(n);\n    pt.resize(n);\n    rep(i, n)pt[i].nextvec();\n    sort(all(pt), xsort);\n    printf(\"%.13lf\\n\", closestpair(0, n));\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn 1e9;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP\n){\n\tint siz=xr-xl;\n\tint ypsiz=yP.size();\n\tif (siz <= 3) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tauto xM = xP[xl+siz/2].first;\n\tauto yL = std::vector<point_t>();\n\tyL.reserve(ypsiz*3/4);\n\tauto yR = std::vector<point_t>();\n\tyR.reserve(ypsiz*3/4);\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {\n\t\treturn p.first <= xM;\n\t});\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {\n\t\treturn p.first > xM;\n\t});\n\tauto p1 = find_closest_optimized(xP,xl,xl+siz/2, yL);\n\tauto p2 = find_closest_optimized(xP,xl+siz/2,xr, yR);\n\tauto minD = sqrt((p1 <= p2) ? p1 : p2);\n\tauto yS = std::vector<point_t>();\n\tyS.reserve(ypsiz*3/4);\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n, yP);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n \ntemplate <typename T>\nstruct Point { \n    T x, y;\n    explicit constexpr Point() : x(0), y(0) {}\n    explicit constexpr Point(T _x, T _y) : x(_x), y(_y) {}\n    const Point operator + (const Point& p) const { return Point(x + p.x, y + p.y);}\n    const Point operator - (const Point& p) const { return Point(x - p.x, y - p.y);}\n    Point& operator *= (const T& p) { x *= p, y *= p; return *this;}\n    Point& operator += (const T& p) { x += p, y += p; return *this;}\n    Point& operator -= (const T& p) { x -= p, y -= p; return *this;}\n    Point& operator /= (const T& p) { x /= p; y /= p; return *this;}\n    Point& operator += (const Point& p) { x += p.x, y += p.y; return *this;}\n    Point& operator -= (const Point& p) { x -= p.x, y -= p.y; return *this;}\n    const T dot(const Point& q) { return x * q.x + y * q.y;}\n    const T norm() { return sqrt(x * x + y * y);}\n    friend std::ostream& operator<<(std::ostream& os, const Point& p) { os << \"(\" << p.x << \", \" << p.y << \")\"; return os;}\n};\n \n#include <vector>\n#include <iomanip>\n#include <functional>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\nusing Pt = Point<double>;\nconst double INF = 1e18;\nconst double EPS = 1.0e-11;\nbool eq(double a, double b) { return fabs(a - b) <= EPS;}\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n_;\n    cin >> n_;\n    vector<Pt> points(n_);\n    for(auto& p : points)\n        cin >> p.x >> p.y;\n    sort(points.begin(), points.end(), [](const Pt& l, const Pt& r) {\n            return eq(l.x, r.x) ? l.y < r.y : l.x < r.x;\n        });\n    function<double(int, int)> closest = [&](int id, int n) {\n        if(n <= 1) return INF;\n        int m = n / 2;\n        double boundX = points[id + m].x;\n        double res = min(closest(id, m), closest(id + m, n - m));\n        auto fit = points.begin() + id;\n        inplace_merge(fit, fit + m, fit + n, [](const Pt& l, const Pt& r) {\n                return  eq(l.y, r.y) ? l.x < r.x : l.y < r.y;\n            });\n        vector<int> memo;\n        for(int i = id; i < id + n; ++i) {\n            if(fabs(boundX - points[i].x) >= res) continue;\n            for(int j = -1 + memo.size(); j >= 0; --j) {\n                Pt p = points[i] - points[memo[j]];\n                if(p.y >= res) break;\n                res = min(res, p.norm());\n            }\n            memo.emplace_back(i);\n        }\n        return res;\n    };\n    cout << fixed << setprecision(10) << closest(0, n_) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/30))  \n #define Fun2(j,n) for(int j=i+(int)(n/30);j<n;j=j+(int)(n/30))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=500;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16??????????????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   //?°?16????????????????????????????????? \n   minx=minx-1;\n   miny=miny-1;\n   maxx=maxx+1;\n   maxy=maxy+1;\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=3;j>=0;j--)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*(3-j)+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n   /*\n   for(int i=0;i<16;i++)\n   {\n     for(int j=0;j<num_point[i];j++)\n     {\n       cout<<wu[i][j].x<<\" \"<<wu[i][j].y<<endl;        \n     }        \n   }\n   */\n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       //real_min=(point[0].x-point[1].x)*(point[0].x-point[1].x)+(point[0].y-point[1].y)*(point[0].y-point[1].y);\n       real_min=fun_min;\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A?????? \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn -1;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP\n){\n\tint siz=xr-xl;\n\tif (siz <= 3) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tauto xM = xP[xl+siz/2].first;\n\tauto yL = std::vector<point_t>();\n\tauto yR = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {\n\t\treturn p.first <= xM;\n\t});\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {\n\t\treturn p.first > xM;\n\t});\n\tauto p1 = find_closest_optimized(xP,xl,xl+siz/2, yL);\n\tauto p2 = find_closest_optimized(xP,xl+siz/2,xr, yR);\n\tauto minD = sqrt((p1 <= p2) ? p1 : p2);\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n, yP);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.00000000001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct vec{\n  double x, y;\n  void nextvec(){ scanf(\"%lf %lf\", &x, &y); return; }\n  vec operator+(const vec& a) const { return (vec){x + a.x, y + a.y}; }\n  vec operator-(const vec& a) const { return (vec){x - a.x, y - a.y}; }\n  vec operator*(const double& k) const { return (vec){k * x, k * y}; }\n  vec sca(double t){ return (vec){t * x, t * y}; }\n  double dot(vec a){ return x * a.x + y * a.y; }\n  double cross(vec a){ return x * a.y - y * a.x; }\n  double norm(){ return sqrt(x * x + y * y); }\n  double norm2(){ return x * x + y * y; }\n};\n\nbool xsort(vec qwe, vec rty){ return qwe.x < rty.x; }\nbool ysort(vec qwe, vec rty){ return qwe.y < rty.y; }\n\nvector<vec> pt;\ndouble ma = 100000000000.0;\n\nvec fory[500000];\ndouble closestpair(int l, int r){\n  if(r - l <= 1)return ma;\n  int m = l + (r - l) / 2;\n  double xm = pt[m].x;\n  double res = closestpair(l, m);\n  res = min(res, closestpair(m, r));\n\n  inplace_merge(pt.begin() + l, pt.begin() + m, pt.begin() + r, ysort);\n  int hd = 0;\n  for(int i = l;i < r;++i)if(pt[i].x - xm <= res + eps){\n    fory[hd++] = pt[i];\n    for(int j = hd - 2;j >= 0;--j){\n      if(fory[j].y - pt[i].y > res + eps)break;\n      res = min(res, (pt[i] - fory[j]).norm());\n    }\n  }\n  return res;\n}\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int(n);\n    rep(i, n){\n      pt.pb((vec){0.0, 0.0});\n      pt[i].nextvec();\n    }\n    sort(all(pt), xsort);\n    printf(\"%.13lf\\n\", closestpair(0, n));\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nusing T = double;\nconst T EPS = 1e-10;\nT torad(int deg) {return (T)(deg) * M_PI / 180;}\nT todeg(T ang) {return ang * 180 / M_PI;}\n\n/* Point */\nusing P = complex<T>;\n#define x real()\n#define y imag()\ntemplate <typename T> inline bool eq(T p, T q) { return abs(p - q) < EPS; }\ninline int sgn(T x) { return (T(0) < x) - (x < T(0)); }\ninline T dot(P v, P w) { return (conj(v) * w).x; }\ninline T cross(P v, P w) { return (conj(v) * w).y; }\ninline bool isOrth(P v, P w) { return dot(v, w) == 0; }\ninline bool isPara(P v, P w) { return cross(v, w) == 0; }\ninline P unit(P v) { return v / abs(v); }\ninline P translate(P p, P v) { return p + v; }\ninline P scale(P p, P c, T k) { return c + (p - c) * k; }\ninline P rot(P p, T a) { return p * polar(1.0, a); }\ninline P rot90(P p) { return {-p.y, p.x}; }\ninline T orient(P a, P b, P c) { return cross(b - a, c - a); }\nistream& operator>>(istream& is, P& p) { T xx, yy; is >> xx >> yy; p = P(xx, yy); return is; }\nbool cmpX(const P& a, const P& b) { return a.x != b.x ? a.x < b.x : a.y < b.y; }\nbool cmpY(const P& a, const P& b) { return a.y != b.y ? a.y < b.y : a.x < b.x; }\nnamespace std {\n    bool operator < (const P& a, const P& b) { return cmpX(a, b); }\n}\n\nP linearTransform(P p, P q, P fp, P fq, P r) {\n    return fp + (r - p) * (fq - fp) / (q - p);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0) return +1;      // counter clockwise\n    if (cross(b, c) < 0) return -1;      // clockwise\n    if (dot(b, c) < 0) return +2;        // c--a--b on line\n    if (norm(b) < norm(c)) return -2;    // a--b--c on line or a==b\n    return 0;                            // a--c--b on line or a==c or b==c\n}\n\nT angle(P v, P w) {\n    T cosTheta = dot(v, w) / abs(v) / abs(w);\n    return acos(max(-1.0, min(1.0, cosTheta)));\n}\nT orientedAngle(P a, P b, P c) {\n    if (orient(a, b, c) >= 0) return angle(b - a, c - a);\n    return 2 * M_PI - angle(b - a, c - a);\n}\nbool inAngle(P a, P b, P c, P p) {\n    assert(abs(orient(a, b, c)) != 0);\n    if (orient(a, b, c) < 0) swap(b, c);\n    return orient(a, b, p) >= 0 && orient(a, c, p) <= 0;\n}\n\n// polar sort\nbool half(P p) {\n    assert(p.x != 0 || p.y != 0);\n    return p.y > 0 || (p.y == 0 && p.x < 0);\n}\nvoid polarSort(vector<P>& v, P o = P(0.0, 0.0)) {\n    sort(v.begin(), v.end(), [&](P v, P w) {\n        return make_tuple(half(v - o), 0, norm(v - o)) <\n            make_tuple(half(w - o), cross(v - o, w - o), norm(w - o));\n    });\n}\n\n/* Line */\nstruct L : array<P, 2> {\n    P v; T c;\n    L(P a = P(0.0, 0.0), P b = P(0.0, 0.0)) : array<P, 2>({a, b}), v(b - a), c(cross(v, a)) {}\n    T side(P p) { return cross(v, p) - c; }\n    P proj(P p) { return p - rot90(v) * side(p) / norm(v); }\n    P refl(P p) { return p - rot90(v) * T(2) * side(p) / norm(v); }\n    friend istream& operator>>(istream& is, L& l) { P a, b; is >> a >> b; l = L(a, b); return is; }\n    friend ostream& operator<<(ostream& os, const L& l) { return os << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct C : P {\n    T r;\n    C(P p = P(0.0, 0.0), T r = 0.0) : P(p), r(r) {}\n    friend ostream& operator<<(ostream& os, const C& c) { return os << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\nP circumCenter(P a, P b, P c) {\n    b -= a, c -= a;\n    assert(cross(b, c) != 0);\n    return a + rot90(b * norm(c) - c * norm(b)) / cross(b, c) / T(2);\n}\n\nvector<P> tangentPoints(C c, P p) {\n    if (eq(abs(p - c), c.r)) return vector<P>{p};\n    vector<P> res;\n    T t = acos(c.r / abs(p - c));\n    P q = (p - c) / abs(p - c) * c.r;\n    res.push_back(c + q * polar(1.0, t));\n    res.push_back(c + q * polar(1.0, -t));\n    sort(res.begin(), res.end(), cmpX);\n    return res;\n}\n\nvector<L> tangentLines(C c1, C c2, bool inner) {\n    if (inner) c2.r = -c2.r;\n    vector<L> res;\n    P d = c2 - c1;\n    T dr = c1.r - c2.r, d2 = norm(d), h2 = d2 - dr * dr;\n    if (d2 == 0 || h2 < 0) { assert(h2 != 0); return res; }\n    for (T sign : {-1, 1}) {\n        P v = (d * dr + rot90(d) * sqrt(h2) * sign) / d2;\n        res.emplace_back(c1 + v * c1.r, c2 + v * c2.r);\n    }\n    return res;\n}\n\n// intersect\nbool isInterPL(P p, L l) { return (ccw(l[0], l[1], p) != 1); }\nbool isInterPS(P p, L s) { return (ccw(s[0], s[1], p) == 0); }\nbool isInterLL(L l, L m) { return (!isPara(l.v, m.v)); }\nbool isInterLS(L l, L s) {\n    if (eq(s[0], s[1])) return isInterPL(s[0], l);\n    return (ccw(l[0], l[1], s[0]) * ccw(l[0], l[1], s[1]) <= 0);\n}\nbool isInterSS(L s, L t) {\n    if (eq(s[0], s[1])) return isInterPL(s[0], t);\n    if (eq(t[0], t[1])) return isInterPL(t[0], s);\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n            ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\nint isInterCC(C a, C b) {\n    T d = abs(b - a);\n    if (a == b && a.r == b.r) return 0;         // ∞ cp (A = B)\n    if (a.r + d - b.r < -EPS) return +1;        // 0 cp (A in B)\n    if (b.r + d - a.r < -EPS) return -1;        // 0 cp (B in A)\n    if (abs(a.r + d - b.r) < EPS) return +2;    // 1 cp (A in B)\n    if (abs(b.r + d - a.r) < EPS) return -2;    // 1 cp (B in A)\n    if (abs(a.r + b.r - d) < EPS) return 3;     // 1 cp (outside)\n    if (a.r + b.r - d < -EPS) return 4;         // 0 cp (outside)\n    return 5;                                   // 2 cp\n}\n \n// distance\nT distancePL(P p, L l) { return (abs(p - l.proj(p))); }\nT distancePS(P p, L s) {\n    P h = s.proj(p);\n    if (isInterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nT distanceLL(L l, L m) {\n    if (isInterLL(l, m)) return T(0);\n    return distancePL(m[0], l);\n}\nT distanceLS(L l, L s) {\n    if (isInterLS(l, s)) return 0;\n    return min(distancePL(s[0], l), distancePL(s[1], l));\n}\nT distanceSS(L s, L t) {\n    if (isInterSS(s, t)) return 0;\n    return min({distancePS(s[0], t), distancePS(s[1], t), distancePS(t[0], s), distancePS(t[1], s)});\n}\n\n// crosspoint\nvector<P> crosspointLL(L l, L m) {\n    if (!isInterLL(l, m)) return vector<P>();\n    vector<P> res;\n    T d = cross(m[1] - m[0], l[1] - l[0]);\n    res.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n    return res;\n}\nvector<P> crosspointLS(L l, L s) {\n    if (!isInterLS(l, s)) return vector<P>();\n    vector<P> res;\n    T d = cross(s[1] - s[0], l[1] - l[0]);\n    res.push_back(l[0] + (l[1] - l[0]) * cross(s[1] - s[0], s[1] - l[0]) / d);\n    return res;\n}\nvector<P> crosspointLC(L l, C c) {\n    if (abs(c - l.proj(c)) > c.r) return vector<P>();\n    vector<P> res;\n    T d = distancePL(c, l), h2 = c.r * c.r - d * d;\n    assert(h2 >= 0);\n    P p = l.proj(c), h = l.v * sqrt(h2) / abs(l.v);\n    res.push_back(p - h);\n    if (abs(h) > 0) res.push_back(p + h);\n    return res;\n}\nvector<P> crosspointSS(L s, L t) {\n    if (!isInterSS(s, t)) return vector<P>();\n    vector<P> res;\n    if (unit(s.v) != unit(t.v)) {\n        T d = cross(t[1] - t[0], s[1] - s[0]);\n        res.push_back(s[0] + (s[1] - s[0]) * cross(t[1] - t[0], t[1] - s[0]) / d);\n    } else {\n        if (ccw(s[0], s[1], t[0]) == 0) res.push_back(t[0]);\n        if (ccw(s[0], s[1], t[1]) == 0) res.push_back(t[1]);\n        if (ccw(t[0], t[1], s[0]) == 0) res.push_back(s[0]);\n        if (ccw(t[0], t[1], s[1]) == 0) res.push_back(s[1]);\n    }\n    return res;\n}\nvector<P> crosspointSC(L s, C c) {\n    if (abs(c - s.proj(c)) > c.r) return vector<P>();\n    vector<P> res;\n    T d = distancePL(c, s), h2 = c.r * c.r - d * d;\n    assert(h2 >= 0);\n    P p = s.proj(c), h = s.v * sqrt(h2) / abs(s.v);\n    if (ccw(s[0], s[1], p - h) == 0) res.push_back(p - h);\n    if (abs(h) > 0 && ccw(s[0], s[1], p + h) == 0) res.push_back(p + h);\n    return res;\n}\nvector<P> crosspointCC(C c1, C c2) {\n    P d = c2 - c1; T d2 = norm(d);\n    if (d2 == 0) { assert(c1.r != c2.r); return vector<P>(); }\n    vector<P> res;\n    T pd = (d2 + c1.r * c1.r - c2.r * c2.r) / 2;\n    T h2 = c1.r * c1.r - pd * pd / d2;\n    if (h2 >= 0) {\n        P p = c1 + d * pd / d2, h = rot90(d) * sqrt(h2 / d2);\n        res.push_back(p - h);\n        if (abs(h) > 0) res.push_back(p + h);\n    }\n    return res;\n}\n\n/* Polygon */\n// p[0] has minimum y and p is counterclockwise\nvector<P> makeStandard(vector<P> p) {\n    int n = p.size(), j = -1;\n    for (int i = 0; i < n; ++i) {\n        if (j == -1 || p[i].y < p[j].y) j = i;\n    }\n    vector<P> res;\n    if (p[(j - 1 + n) % n].x <= p[j].x && p[j].x <= p[(j + 1) % n].x) {\n        for (int i = 0; i < n; ++i) {\n            res.push_back(p[(i + j) % n]);\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            res.push_back(p[(i - j + n) % n]);\n        }\n    }\n    return res;\n}\nbool isConvex(vector<P> p) {\n    p = makeStandard(p);\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        P a = p[i], b = p[(i + 1) % n], c = p[(i + 2) % n];\n        if (orient(a, b, c) < 0) return false;\n        if (b.y != p[0].y && b.y < min(a.y, c.y)) return false;\n        if (b.y != p[0].y && a.y == b.y && b.y == c.y && a.x <= b.x && b.x <= c.x) return false;\n    }\n    return true;\n}\nT areaTriangle(P a, P b, P c) {\n    return abs(cross(b - a, c - a)) / T(2);\n}\nT area(vector<P> p) {\n    T res = 0;\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        res += cross(p[i], p[(i + 1) % n]);\n    }\n    return abs(res) / T(2);\n}\nbool above(P a, P p) { return p.y >= a.y; }\nbool crossesRay(P a, P p, P q) {\n    return (above(a, q) - above(a, p)) * orient(a, p, q) > 0;\n}\n// if strict, returns false when A is on the boundary\nbool inPolygon(vector<P> p, P a, bool strict = true) {\n    int numCrossing = 0;\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        if (ccw(p[i], p[(i + 1) % n], a) == 0)\n            return !strict;\n        numCrossing += crossesRay(a, p[i], p[(i + 1) % n]);\n    }\n    return numCrossing & 1;\n}\nvector<P> convexHull(vector<P> p) {\n    int n = p.size(), k = 0;\n    sort(p.begin(), p.end(), cmpX);\n    vector<P> res(2 * n);\n    for (int i = 0; i < n; res[k++] = p[i++])\n        while (k >= 2 && ccw(res[k - 2], res[k - 1], p[i]) <= 0) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; res[k++] = p[i--])\n        while (k >= t && ccw(res[k - 2], res[k - 1], p[i]) <= 0) --k;\n    res.resize(k - 1);\n    return res;\n}\nvector<P> convexHullCollinearOK(vector<P> p) {\n    int n = p.size(), k = 0;\n    sort(p.begin(), p.end(), cmpX);\n    vector<P> res(2 * n);\n    for (int i = 0; i < n; res[k++] = p[i++])\n        while (k >= 2 && ccw(res[k - 2], res[k - 1], p[i]) == -1) --k;\n    for (int i = n - 2, t = k + 1; i >= 0; res[k++] = p[i--])\n        while (k >= t && ccw(res[k - 2], res[k - 1], p[i]) == -1) --k;\n    res.resize(k - 1);\n    return res;\n}\nvector<P> convexCut(vector<P> p, L l) {\n    vector<P> res;\n    for (int i = 0, n = p.size(); i < n; ++i) {\n        int ccwc = ccw(l[0], l[1], p[i]);\n        if (ccwc != -1) res.push_back(p[i]);\n        int ccwn = ccw(l[0], l[1], p[(i + 1) % n]);\n        if (ccwc * ccwn == -1) res.push_back(crosspointLL(l, L(p[i], p[(i + 1) % n]))[0]);\n    }\n    return res;\n}\nT closest_pair(vector<P>& a, int l = 0, int r = -1) {\n    if (r < 0) {\n        r = a.size();\n        sort(a.begin(), a.end());\n    }\n    if (r - l <= 1) return abs(a[0] - a[1]);\n    int m = (l + r) >> 1;\n    T amx = a[m].x, d = min(closest_pair(a, l, m), closest_pair(a, m, r));\n    inplace_merge(a.begin() + l, a.begin() + m, a.begin() + r, cmpY);\n    vector<P> b;\n    for (int i = l; i < r; ++i) {\n        if (abs(a[i].x - amx) > d - EPS) continue;\n        for (int j = 0, n = b.size(); j < n; ++j) {\n            if (a[i].y - b[n - j - 1].y > d - EPS) break;\n            d = min(d, abs(a[i] - b[n - j - 1]));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n\n    int n;\n    cin >> n;\n    vector<P> p(n);\n    REP (i, n) cin >> p[i];\n    cout << closest_pair(p) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n\n// Description: ????????????\n// Verifyed: various problem \nusing namespace placeholders;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P c;R r;};\n\nauto& operator >> (istream& is,P& p){ R x,y; is >> x >> y,p=P(x,y); return is;}\nauto& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline P vec(L l){return l.t-l.s;}\nauto sdot = bind(sgn,bind(dot,_1,_2,_3));\nauto sdet = bind(sgn,bind(det,_1,_2,_3));\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/vec(l)); return (1-u)*l.s+u*l.t;}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a){\n\tconst int n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\t\n\tauto cmp_x=[](P a,P b)->bool{\n\t\tint sr = sgn(real(a-b)), si = sgn(imag(a-b));\n\t\treturn sr ? sr < 0 :si < 0;\n\t};\n\t\n\tsort(begin(a),end(a),cmp_x);\n\t\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a));\n\tR x=real(a[m]),d=min(cpp(b),cpp(c));\n\t\n\tauto cmp_y=[](P a,P b)->bool{\n\t\tint sr = sgn(real(a-b)), si = sgn(imag(a-b));\n\t\treturn si ? si < 0 :sr < 0;\n\t};\n\n\tsort(begin(a),end(a),cmp_y);\n\tdeque<P> e;\n\n\tfor(auto &p:a){\n\t\tif(abs(real(p)-x)>=d) continue;\t\n\t\tfor(auto &q:e){\n\t\t\tif(imag(p-q)>=d) break;\n\t\t\tchmin(d,abs(p-q));\n\t\t}\n\t\te.push_back(p);\n\t}\n\treturn d;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << cpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pt pair<double,double>\n#define x first\n#define y second\n#define double long double\nconst double INF=1e5;\npt p[100010];\ndouble pw2(double d){return d*d;}\ndouble dist(pt a,pt b){return sqrt(pw2(a.x-b.x)+pw2(a.y-b.y));}\nbool cmp(pt a,pt b){return a.y<b.y;}\ndouble closest(int l,int r)\n{\n  if(l==r) return INF;\n  int mid=(l+r)/2,pp=l,qq=mid+1;\n  double midline=p[mid].x;\n  double ret=min(closest(l,mid),closest(mid+1,r));\n  //merge sort\n  vector<pt> merge,slab;\n  while(pp<=mid || qq<=r)\n    if(pp>mid) merge.push_back(p[qq++]);\n    else if(qq>r) merge.push_back(p[pp++]);\n    else merge.push_back(p[pp].y<p[qq].y?p[pp++]:p[qq++]);\n  pp=l;for(int i=0;i<merge.size();i++)p[pp++]=merge[i];\n  for(int i=l;i<r;i++)if(p[i].y>p[i+1].y)cout<<\"ERROR\\n\";\n  //conquer\n  //sort(p+l,p+r+1,cmp);\n  for(int i=l;i<=r;i++)\n    if(abs(p[i].x-midline)<ret*4)\n      slab.push_back(p[i]);\n  for(int i=0;i<slab.size();i++)\n    for(int j=i+1;j<slab.size() && (slab[i].y-slab[j].y)<ret*4;j++)\n      ret=min(ret,dist(slab[i],slab[j]));\n  return ret;\n}\nint main()\n{\n  int n;\n  cin>>n;\n  for(int i=1;i<=n;i++)\n    cin>>p[i].x>>p[i].y;\n  cout<<fixed<<closest(1,n)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn 1e9;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP\n){\n\tint siz=xr-xl;\n\tif (siz <= 4) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tauto xM = xP[xl+siz/2].first;\n\tauto yL = std::vector<point_t>();\n\tauto yR = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {\n\t\treturn p.first <= xM;\n\t});\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {\n\t\treturn p.first > xM;\n\t});\n\tauto p1 = find_closest_optimized(xP,xl,xl+siz/2, yL);\n\tauto p2 = find_closest_optimized(xP,xl+siz/2,xr, yR);\n\tauto minD = sqrt((p1 <= p2) ? p1 : p2);\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n, yP);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i+j<N&&memo >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8)<<sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ntypedef vector<P> G;\n\ndouble compare_x(const P &a, const P &b){\n  return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n}\n\ndouble compare_y(const P &a, const P &b){\n  return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;\n}\n\ndouble convex_radius(P *a, int n){\n    if(n <= 1) return INF;\n    int m = n / 2;\n    double d = min(convex_radius(a, m), convex_radius(a + m, n - m)), x = a[m].X;\n    sort(a, a + n, compare_y);\n    vector<P> b;\n    for(int i = 0; i < n; ++i){\n        if(fabs(a[i].X - x) >= d) continue;\n        for(int j = 0; j < (int)b.size(); ++j){\n            double dx = a[i].X - b[b.size()-j-1].X;\n            double dy = a[i].Y - b[b.size()-j-1].Y;\n            if(dy>=d)break;\n            d=min(d,sqrt(dx*dx+dy*dy));\n              \n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  sort(g.begin(), g.end(), compare_x);\n  printf(\"%.10lf\\n\", convex_radius(&g[0], N));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Description: ????????????\n// Verifyed: various problem \nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nconst P O=0.0L;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P p;R c;};\n\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline int sdot(P o,P a,P b){return sgn(dot(o,a,b));}\ninline int sdet(P o,P a,P b){return sgn(det(o,a,b));}\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/(l.t-l.s)); return (1-u)*l.s+u*l.t;}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tconst int n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\t\n\tif(flag){\n\t\tauto cmp_x=[](P a,P b)->bool{return sgn(real(a)-real(b))?sgn(real(a)-real(b))<0:sgn(imag(a)-imag(b)<0);};\n\t\tsort(begin(a),end(a),cmp_x);\n\t}\n\t\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\t\n\tauto cmp_y=[](P a,P b)->bool{return sgn(imag(a)-imag(b))?sgn(imag(a)-imag(b))<0:sgn(real(a)-real(b)<0);};\t\n\tsort(_all(a),cmp_y);\n\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trrep(j,e.size()){\n\t\t\tif(imag(a[i]-e[j])>=d) break;\n\t\t\tchmin(d,abs(a[i]-e[j]));\n\t\t}\n\t\te.emplace_back(a[i]);\n\t}\n\treturn d;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << cpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    const char loops = 111;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(char j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(char j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + j].first - p2[i].first) * (p2[i + j].first - p2[i].first) + (p2[i + j].second - p2[i].second) * (p2[i + j].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.9f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef double              lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return abs( B - A ); }\n\nint n;\nlf d;\npt Px[ MAXN ];\nvector< pt> Py;\n\nbool cmpX( const pt &A, const pt &B ) {\n  return A.x < B.x;\n}\n\nbool cmpY( const pt &A, const pt &B ) {\n  return A.y < B.y;\n}\n\nvoid merge( pt *P, int n, lf &d ) {\n  for( int i = 0; i < n; ++i ) {\n    for( int j = i+1; j < n && P[j].y - P[i].y < d ; ++j ) {\n      d = min( d, dist( P[i], P[j]) );\n    }\n  }\n}\n\nvoid solve( pt *Px, vector<pt> &Py, int n, lf &d ) {\n  if( n <= 3 ) {\n    for( int i = 0; i < n; ++i ) {\n      for( int j = i+1; j < n; ++j ) {\n        d = min( d, dist(Px[i], Px[j]) );\n      }\n    }\n    return;\n  }\n  int mi = n/2;\n  vector<pt> Pl, Pr;\n  for( int i = 0; i < n; ++i ) {\n    if( Py[i].x <= Px[mi].x ) {\n      Pl.PB( Py[ i ] );\n    }\n    else {\n      Pr.PB( Py[ i ] );\n    }\n  }\n\n  solve( Px, Pl, SIZE( Pl ), d );\n  solve( Px+SIZE( Pl ), Pr, SIZE( Pr ), d );\n\n  pt extra[ n ];\n  int k = 0;\n  for( auto &p : Py ) {\n    if( abs( p.x - Px[mi].x ) < d ) {\n      extra[ k++ ] = p;\n    }\n  }\n\n  merge( extra, n, d );\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 8 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> Px[i];\n    Py.PB( Px[ i ] );\n  }\n  sort( Px, Px+n, cmpX );\n  sort( Py.begin(), Py.end(), cmpY );\n  d = oo;\n  solve( Px, Py, n, d );\n  cout << double(d) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pt pair<double,double>\n#define x first\n#define y second\nconst double INF=1e5,EPS=1e-9;\npt p[100010];\ndouble pw2(double d){return d*d;}\ndouble dist(pt a,pt b){return sqrt(pw2(a.x-b.x)+pw2(a.y-b.y));}\ndouble closest(int l,int r)\n{\n  if(l==r)return INF;\n  int mid=(l+r)/2,pp=l,qq=mid+1;\n  double midline=p[mid].x;\n  double ret=min(closest(l,mid),closest(mid+1,r));\n  vector<pt>merge,slab;\n  while(pp<=mid || qq<=r)\n    if(pp>mid) merge.push_back(p[qq++]);\n    else if(qq>r) merge.push_back(p[pp++]);\n    else merge.push_back(p[pp].y<p[qq].y?p[pp++]:p[qq++]);\n  pp=l;for(int i=0;i<merge.size();i++)p[pp++]=merge[i];\n  for(int i=l;i<=r;i++)\n    //if(abs(p[i].x-midline)+EPS<ret)\n      slab.push_back(p[i]);\n  for(int i=0;i<slab.size();i++)\n    for(int j=i+1;j<slab.size() && (slab[j].y-slab[i].y)<ret;j++)\n      ret=min(ret,dist(slab[i],slab[j]));\n  return ret;\n}\nint main()\n{\n  int n;\n  cin>>n;\n  for(int i=1;i<=n;i++)\n    cin>>p[i].x>>p[i].y;\n  cout<<fixed<<closest(1,n)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nusing ld = long double;\nusing Point = std::complex<ld>;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std\n{\nbool operator<(const Point &lhs, const Point &rhs)\n{\n    if (lhs.real() < rhs.real() - eps)\n        return true;\n    if (lhs.real() > rhs.real() + eps)\n        return false;\n    return lhs.imag() < rhs.imag();\n}\n} // namespace std\n\nPoint input_point()\n{\n    ld x, y;\n    std::cin >> x >> y;\n    return Point(x, y);\n}\n\nbool eq(ld a, ld b)\n{\n    return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b)\n{\n    return real(conj(a) * b);\n}\n\nld cross(Point a, Point b)\n{\n    return imag(conj(a) * b);\n}\n\n// CCW::counter clockwise\nint ccw(Point a, Point b, Point c)\n{\n    b -= a;\n    c -= a;\n    if (cross(b, c) > eps)\n        return 1; // a,b,c : counter-clockwise\n    if (cross(b, c) < -eps)\n        return -1; // a,b,c : clockwise\n    if (dot(b, c) < 0)\n        return 2; // c,a,b : on a line\n    if (norm(b) < norm(c))\n        return -2; // a,b,c : on a line\n    return 0;      // a,c,b : on a line\n}\n\nclass Line\n{\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n};\n\nld dot(Line l, Line m)\n{\n    return dot((l.a - l.b), (m.a - m.b));\n}\n\nclass Circle\n{\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// l:line, m:line が交点を持つか\nbool isis_ll(Line l, Line m)\n{\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// l:line, s:segment\nbool isis_ls(Line l, Line s)\n{\n    return isis_ll(l, s) &&\n           (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// s:segment, t:segment\nbool isis_ss(Line s, Line t)\n{\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// p が l:line 上に存在するか\nbool isis_lp(Line l, Point p)\n{\n    return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p)\n{\n    return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// p から l に下ろした足との交点\nPoint proj(Line l, Point p)\n{\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\n// l:line, t:line の交点\nPoint is_ll(Line l, Line m)\n{\n    Point lv = l.b - l.a, mv = m.b - m.a;\n    assert(cross(lv, mv) != 0);\n    return l.a + lv * cross(mv, m.a - l.a) / cross(mv, lv);\n}\n\n// p, l:line の距離\nld dist_lp(Line l, Point p)\n{\n    return abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : std::min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n    if (isis_ss(s, t))\n        return 0;\n    return std::min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\n// a, b の垂直二等分線. a -> b を90度反時計回り回転\nLine bisector(Point a, Point b)\n{\n    Point mid = (a + b) * Point(0.5, 0);\n    return Line(mid, mid + (b - a) * Point(0, pi / 2));\n}\n\n// 直線 l, m のなす角を求める\nld degree_ll(Line l, Line m)\n{\n    ld cos_shita = dot(l, m) / (abs(l.b - l.a) * abs(m.b - m.a));\n    if (cos_shita < -1.0)\n        cos_shita = -1.0;\n    if (cos_shita > 1.0)\n        cos_shita = 1.0;\n    ld shita = acos(cos_shita);\n    // shita = sita * 180.0 / PI;\n    return shita;\n}\n\n// c1, c2 の交点\nstd::vector<Point> is_cc(Circle c1, Circle c2)\n{\n    std::vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps)\n        dfr = 0.0;\n    else if (dfr < 0.0)\n        return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.emplace_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0)\n        res.emplace_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n\nstd::vector<Point> is_lc(Circle c, Line l)\n{\n    std::vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps)\n    {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.emplace_back(proj(l, c.p) + len * nor);\n        res.emplace_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n\nstd::vector<Point> is_sc(Circle c, Line l)\n{\n    std::vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p))\n            res.emplace_back(p);\n    return res;\n}\n\n// p から c への接線\nstd::vector<Line> tangent_cp(Circle c, Point p)\n{\n    std::vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (std::isnan(l))\n    {\n        return ret;\n    }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.emplace_back(Line(p, p + v1));\n    if (l < eps)\n        return ret;\n    ret.emplace_back(Line(p, p + v2));\n    return ret;\n}\n\n// c1, c2 の共通接線\nstd::vector<Line> tangent_cc(Circle c1, Circle c2)\n{\n    std::vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps)\n    {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps)\n    {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        std::vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), nret.begin(), nret.end());\n    }\n    else\n    {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.emplace_back(Line(q1, q1 + v));\n        ret.emplace_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\nusing Polygon = std::vector<Point>;\n\nld area(const Polygon &p)\n{\n    ld res = 0;\n    int n = p.size();\n    for (int i = 0; i < n; i++)\n    {\n        res += cross(p[i], p[(i + 1) % n]);\n    }\n    return res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly)\n{\n    ld angle = 0;\n    int n = poly.size();\n    for (int i = 0; i < n; i++)\n    {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n\n// 0 => out\n// 1 => on\n// 2 => in\nint is_in_polygon(const Polygon &poly, Point p)\n{\n    ld angle = 0;\n    int n = poly.size();\n    for (int i = 0; i < n; i++)\n    {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p))\n            return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(std::vector<Point> ps)\n{\n    int n = ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)\n            --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)\n            --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\n// 凸包カット\nPolygon convex_cut(const Polygon &ps, Line l)\n{\n    int n = ps.size();\n    Polygon Q;\n    for (int i = 0; i < n; i++)\n    {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1)\n            Q.emplace_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.emplace_back(is_ll(l, m));\n    }\n    return Q;\n}\n\nvoid add_point(std::vector<Point> &ps, Point p)\n{\n    for (Point q : ps)\n        if (abs(q - p) < eps)\n            return;\n    ps.emplace_back(p);\n}\n\n// Voronoi 図: http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3668810\n// polygon を ps でボロノイ分割する時の ps[index] に割り当てられる多角形\nPolygon voronoi(const Polygon &polygon, const std::vector<Point> &ps, int index)\n{\n    Polygon p = polygon;\n    int n = ps.size();\n    for (int j = 0; j < n; j++)\n    {\n        if (index == j)\n            continue;\n        Line l = bisector(ps[index], ps[j]);\n        p = convex_cut(p, l);\n    }\n    return p;\n}\n\n// 凸多角形の直径（最遠点対）, インデックスのペアを返す, O(n)\nld convexDiameter(const Polygon &ps)\n{\n    int n = ps.size();\n    int i = min_element(ps.begin(), ps.end()) - ps.begin();\n    int j = max_element(ps.begin(), ps.end()) - ps.begin();\n    int reti = i, retj = j;\n    ld d = 0;\n    for (int k = 0; k < 2 * n; k++)\n    {\n        if (d < norm(ps[i] - ps[j]))\n        {\n            d = norm(ps[i] - ps[j]);\n            reti = i;\n            retj = j;\n        }\n        if (cross(ps[i] - ps[(i + 1) % n], ps[(j + 1) % n] - ps[j]) <= 0)\n            j = (j + 1) % n;\n        else\n            i = (i + 1) % n;\n    }\n    return d;\n    // return std::make_pair(reti, retj);\n}\n\n// 多角形の幾何学的重心\nPoint centroid(const Polygon &ps)\n{\n    int n = ps.size();\n    ld sum = 0;\n    Point c;\n    for (int i = 0; i < n; i++)\n    {\n        ld a = cross(ps[i], ps[(i + 1) % n]);\n        sum += a;\n        c += (ps[i] + ps[(i + 1) % n]) * a;\n    }\n    return 1.0 / sum / 3 * c;\n}\n\nbool compareY(Point a, Point b)\n{\n    return a.imag() < b.imag();\n}\n\nld closestPair(Point *a, int n) // a is sorted\n{\n    static const ld inf = 1e15;\n    if (n <= 1)\n        return inf;\n    int m = n / 2;\n    ld x = a[m].real();\n    ld d = std::min(closestPair(a, m), closestPair(a + m, n - m));\n    std::inplace_merge(a, a + m, a + n, compareY);\n    // a は y の昇順\n\n    std::vector<Point> b;\n    for (int i = 0; i < n; i++)\n    {\n        if (fabs(a[i].real() - x) >= d)\n            continue;\n\n        for (int j = 0; j < int(b.size()); j++)\n        {\n            ld dx = a[i].real() - b[int(b.size()) - j - 1].real();\n            ld dy = a[i].imag() - b[int(b.size()) - j - 1].imag();\n            if (dy >= d)\n                break;\n            d = std::min(d, sqrt(dx * dx + dy * dy));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nvoid solve_cgl_1_a()\n{\n    auto p1 = input_point(), p2 = input_point();\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p = input_point();\n        auto ret = proj(Line(p1, p2), p);\n        cout << fixed << setprecision(10) << ret.real() << \" \" << ret.imag() << endl;\n    }\n}\n\nvoid solve_cgl_1_b()\n{\n    auto p1 = input_point(), p2 = input_point();\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p = input_point();\n        auto ret = proj(Line(p1, p2), p);\n        cout << fixed << setprecision(10) << 2 * ret.real() - p.real() << \" \" << 2 * ret.imag() - p.imag() << endl;\n    }\n}\n\nvoid solve_cgl_1_c()\n{\n    auto p0 = input_point(), p1 = input_point();\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p2 = input_point();\n        int ret = ccw(p0, p1, p2);\n        if (ret == 1)\n            cout << \"COUNTER_CLOCKWISE\" << endl;\n        else if (ret == -1)\n            cout << \"CLOCKWISE\" << endl;\n        else if (ret == 2)\n            cout << \"ONLINE_BACK\" << endl;\n        else if (ret == -2)\n            cout << \"ONLINE_FRONT\" << endl;\n        else\n            cout << \"ON_SEGMENT\" << endl;\n    }\n}\n\nvoid solve_cgl_2_a()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point(), p2 = input_point(), p3 = input_point();\n        Line l(p0, p1), m(p2, p3);\n        if (!isis_ll(l, m))\n        {\n            cout << 2 << endl;\n        }\n        else if (eq(dot(l.b - l.a, m.b - m.a), 0))\n        {\n            cout << 1 << endl;\n        }\n        else\n        {\n            cout << 0 << endl;\n        }\n    }\n}\n\nvoid solve_cgl_2_b()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point(), p2 = input_point(), p3 = input_point();\n        Line s1(p0, p1), s2(p2, p3);\n        cout << (isis_ss(s1, s2) ? 1 : 0) << endl;\n    }\n}\n\nvoid solve_cgl_2_c()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point(), p2 = input_point(), p3 = input_point();\n        Line s1(p0, p1), s2(p2, p3);\n        auto ret = is_ll(s1, s2);\n        cout << fixed << setprecision(10) << ret.real() << \" \" << ret.imag() << endl;\n    }\n}\n\nvoid solve_cgl_2_d()\n{\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point(), p2 = input_point(), p3 = input_point();\n        Line s1(p0, p1), s2(p2, p3);\n        cout << fixed << setprecision(10) << dist_ss(s1, s2) << endl;\n    }\n}\n\nvoid solve_cgl_3_a()\n{\n    Polygon p;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        p.push_back(input_point());\n    }\n    cout << fixed << setprecision(10) << area(p) << endl;\n}\n\nvoid solve_cgl_3_b()\n{\n    Polygon p;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        p.push_back(input_point());\n    }\n    auto cv = convex_hull(p);\n    cout << (eq(area(p), area(cv)) ? 1 : 0) << endl;\n}\n\nvoid solve_cgl_3_c()\n{\n    Polygon ps;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        ps.push_back(input_point());\n    }\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p = input_point();\n        int ret = is_in_polygon(ps, p);\n        cout << ret << endl;\n    }\n}\n\n// AOJと凸包の仕様が少し違う(辺上の点を含めない)ので略…\nvoid solve_cgl_4_a()\n{\n    int n;\n    cin >> n;\n    Polygon ps;\n    for (int i = 0; i < n; i++)\n    {\n        ps.push_back(input_point());\n    }\n    auto ret = convex_hull(ps);\n    cout << ret.size() << endl;\n    for (auto p : ret)\n    {\n        cout << (int)p.real() << \" \" << (int)p.imag() << endl;\n    }\n}\n\nvoid solve_cgl_4_b()\n{\n    int n;\n    cin >> n;\n    Polygon ps;\n    for (int i = 0; i < n; i++)\n    {\n        ps.push_back(input_point());\n    }\n    auto ret = convexDiameter(ps);\n    cout << fixed << setprecision(10) << sqrt(ret) << endl;\n}\n\n// AOJと凸包の仕様が少し違う(辺上の点を含めない)ので略…\nvoid solve_cgl_4_c()\n{\n    int n;\n    cin >> n;\n    Polygon ps;\n    for (int i = 0; i < n; i++)\n    {\n        ps.push_back(input_point());\n    }\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point();\n        auto l = Line(p0, p1);\n        auto ret = convex_cut(ps, l);\n        cout << fixed << setprecision(10) << area(ret) << endl;\n    }\n}\n\nconst int MAX_N = 100000;\nPoint a[MAX_N];\n\nvoid solve_cgl_5_a()\n{\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        auto p = input_point();\n        a[i] = p;\n    }\n    sort(a, a + n);\n    auto ret = closestPair(a, n);\n    cout << fixed << setprecision(10) << ret << endl;\n}\n\n// cgl_6_a: 線分交差\n\nvoid solve_cgl_7_a()\n{\n    auto p0 = input_point();\n    ld r0, r1;\n    cin >> r0;\n    auto p1 = input_point();\n    cin >> r1;\n    Circle c0(p0, r0), c1(p1, r1);\n    auto ls = tangent_cc(c0, c1);\n    cout << ls.size() << endl;\n}\n\nvoid solve_cgl_7_d()\n{\n    auto p = input_point();\n    ld r;\n    cin >> r;\n    Circle c(p, r);\n    int q;\n    cin >> q;\n    cout << fixed << setprecision(10);\n    while (q--)\n    {\n        auto p0 = input_point(), p1 = input_point();\n        Line l(p0, p1);\n        auto ret = is_lc(c, l);\n        assert(ret.size() <= 2);\n        sort(ret.begin(), ret.end());\n        cout << ret[0].real() << \" \" << ret[0].imag();\n        if (ret.size() == 2)\n        {\n            cout << \" \" << ret[1].real() << \" \" << ret[1].imag();\n        }\n        cout << endl;\n    }\n}\n\nvoid solve_cgl_7_e()\n{\n    auto p0 = input_point();\n    ld r0, r1;\n    cin >> r0;\n    auto p1 = input_point();\n    cin >> r1;\n    Circle c0(p0, r0), c1(p1, r1);\n    auto ret = is_cc(c0, c1);\n    if ((int)ret.size() == 1)\n        ret.push_back(ret[0]);\n    sort(ret.begin(), ret.end());\n    cout << fixed << setprecision(10);\n    cout << ret[0].real() << \" \" << ret[0].imag() << \" \" << ret[1].real() << \" \" << ret[1].imag() << endl;\n}\n\nvoid solve_cgl_7_f()\n{\n    auto p = input_point();\n    auto p0 = input_point();\n    ld r0;\n    cin >> r0;\n    Circle c(p0, r0);\n    auto ls = tangent_cp(c, p);\n    vector<Point> ret;\n    for (auto l : ls)\n    {\n        auto ps = is_lc(c, l);\n        //assert((int)ps.size() == 1);\n        ret.push_back(ps[0]);\n    }\n    sort(ret.begin(), ret.end());\n    cout << fixed << setprecision(10);\n    cout << ret[0].real() << \" \" << ret[0].imag() << \" \" << ret[1].real() << \" \" << ret[1].imag() << endl;\n}\n\nvoid solve_cgl_7_g()\n{\n    ld r0, r1;\n    auto p0 = input_point();\n    cin >> r0;\n    auto p1 = input_point();\n    cin >> r1;\n    Circle c0(p0, r0), c1(p1, r1);\n    auto ls = tangent_cc(c0, c1);\n    vector<Point> ret;\n    for (auto l : ls)\n    {\n        auto ps = is_sc(c0, l);\n        //assert((int)ps.size() == 1);\n        ret.push_back(ps[0]);\n    }\n    sort(ret.begin(), ret.end());\n    for (auto p : ret)\n    {\n        cout << fixed << setprecision(10) << p.real() << \" \" << p.imag() << endl;\n    }\n}\n\n// cgl_7_h: 円と多角形の共通部分(は?)\n// 参考実装: http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2114290\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    solve_cgl_5_a();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 10000;\nconst double INFTY = 10000000000000000000.0;\n\nstruct Point { double x, y; };\nbool compareX(Point& a, Point& b) {\n\treturn a.x < b.x ? true : a.x == b.x && a.y <= b.y ? true : false;\n}\n\nbool compareY(Point& a, Point& b) {\n\treturn a.y < b.y ? true : a.y == b.y && a.x <= b.x ? true : false;\n}\n\ninline double getSquareDist(Point a, Point b) {\n\treturn (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\ninline double getMinSquareDistOfThree(Point a, Point b, Point c) {\n\treturn min(getSquareDist(a, b), min(getSquareDist(a, c), getSquareDist(b, c)));\n}\n\ndouble getMinSquareDistNearMid(Point nearmid[], int nearmid_length) {\n\tsort(nearmid, nearmid + nearmid_length, compareY);\n\n\tdouble min_sq_dist = INFTY;\n\tdouble cur_sq_dist;\n\tfor (int i = 0; i < nearmid_length; ++i) {\n\t\t// a better implementation:\n\t\t//for (int j = i + 1; j < min(nearmid_length, i + 8); ++j) {\n\t\tfor (int j = i + 1; j < nearmid_length && (nearmid[j].y - nearmid[i].y) < min_sq_dist; ++j) {\n\t\t\tcur_sq_dist = getSquareDist(nearmid[i], nearmid[j]);\n\t\t\tif (cur_sq_dist < min_sq_dist)\n\t\t\t\tmin_sq_dist = cur_sq_dist;\n\t\t}\n\t}\n\treturn min_sq_dist;\n}\n\n// nlog^2 n, not nlog n in CLRS\ndouble dcClosestSquareDist(int low, int high, Point points[]) {\n\tif (high - low == 1) {\n\t\treturn getSquareDist(points[low], points[high]);\n\t}\n\telse if (high - low == 2) {\n\t\treturn getMinSquareDistOfThree(points[low], points[low + 1], points[high]);\n\t}\n\telse {\n\t\t// bug 3: + has higher precedence than >>\n\t\t//int mid = low + (high - low) >> 1;\n\t\tint mid = low + ((high - low) >> 1);\n\t\tdouble d_left = dcClosestSquareDist(low, mid, points);\n\t\tdouble d_right = dcClosestSquareDist(mid + 1, high, points);\n\t\tdouble d_divide = min(d_left, d_right);\n\t\tdouble d_divide_sqrt = sqrt(d_divide);\n\n\t\t// merge\n\t\tPoint *nearmid = new Point[high - low + 1];\n\t\tint nearmid_length = 0;\n\t\tfor (int i = low; i <= high; ++i) {\n\t\t\t// bug 4: here we should compare the dist with real dist, not squared!\n\t\t\tif (abs(points[i].x - points[mid].x) < d_divide_sqrt) {\n\t\t\t\tnearmid[nearmid_length] = points[i];\n\t\t\t\tnearmid_length++;\n\t\t\t}\n\t\t}\n\t\tdouble d_merge = getMinSquareDistNearMid(nearmid, nearmid_length);\n\t\t// bug 6: forget to free memory\n\t\tdelete[] nearmid;\n\t\treturn min(d_divide, d_merge);\n\t}\n}\n\ndouble getMinSqDistToFirst(Point first_camera, Point points[], int n) {\n\tdouble min_sq_dist = INFTY;\n\tdouble cur_sq_dist;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcur_sq_dist = getSquareDist(first_camera, points[i]);\n\t\tif (cur_sq_dist < min_sq_dist)\n\t\t\tmin_sq_dist = cur_sq_dist;\n\t}\n\treturn min_sq_dist;\n}\n\ndouble getArea(double candidate, double min_dist_to_first, int n) {\n\treturn candidate * candidate + (n - 1) * (min_dist_to_first - candidate) * (min_dist_to_first - candidate);\n}\n\n/*\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tint n;\n\tPoint points[MAX_N];\n\tPoint first_camera;\n\tdouble min_dist_to_first;\n\tdouble min_dist_among_others;\n\tdouble candidate1;\t// candidate1 = max(0, d1 - d2 / 2)\n\tdouble candidate2;\t// candidate2 = d1\n\tdouble max_area;\n\tfor (int i = 1; i <= t; ++i) {\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%lf%lf\", &(first_camera.x), &(first_camera.y));\n\t\tfor (int j = 0; j < n - 1; ++j) {\n\t\t\tscanf(\"%lf%lf\", &(points[j].x), &(points[j].y));\n\t\t}\n\t\tmin_dist_to_first = sqrt(getMinSqDistToFirst(first_camera, points, n));\n\t\tif (n == 2) {\n\t\t\tmin_dist_among_others = INFTY;\n\t\t}\n\t\telse {\n\t\t\tsort(points, points + n - 1, compareX);\n\t\t\tmin_dist_among_others = sqrt(dcClosestSquareDist(0, n - 2, points));\n\t\t}\n\t\t//printf(\"%f\\n\", min_dist_among_others);\n\t\tcandidate1 = max(0.0, min_dist_to_first - min_dist_among_others / 2.0);\n\t\tcandidate2 = min_dist_to_first;\n\t\tmax_area = M_PI * max(getArea(candidate1, min_dist_to_first, n), getArea(candidate2, min_dist_to_first, n));\n\t\tprintf(\"Case #%d: %.8f\\n\", i, max_area);\n\t}\n    return 0;\n}\n*/\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tPoint points[MAX_N];\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%lf%lf\", &(points[i].x), &(points[i].y));\n\t}\n\tsort(points, points + n, compareX);\n\tprintf(\"%f\", sqrt(dcClosestSquareDist(0, n, points)));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<utility>\n#include<complex>\n#include<functional>\nusing namespace std;\n#define LL double \n\nstruct P{\n\tdouble x, y;\n};\n\nusing namespace std;\n\n//Compare for sorting\ninline bool LessX(const P& left, const P& right){\n\tif (left.x == right.x)return(left.y < right.y);\n\treturn left.x<right.x;\n}\ninline bool LessY(const P& left, const P& right){\n\treturn(left.y < right.y);\n}\n\n\nP xx[10000000], yy[10000000],ss[10000000];\nint ix, iy,is;\n#define dist(_x,_y,__x,__y) (((_x)-(__x))*((_x)-(__x))+((_y)-(__y))*((_y)-(__y)))\n#define distP(a,b) sqrt(dist((a.x),(a.y),(b.x),(b.y)))\nvoid Closest_Pair_rec(int n,int xs, int ys, P *p1, P *p2, LL* qdist){\n\n\n\tP *vx = xx + xs;\n\tP *vy = yy + ys;\n\n\t/*for (int i = 0; i < n; i++)\n\t\tprintf(\"(%.5f,%.5f)\", vx[i].x, vx[i].y); cout << endl;\n\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"(%.5f,%.5f)\", vy[i].x, vy[i].y); cout << endl;\n\tcout << endl;\n\t*/\n\tif (n == 3){\n\t\tLL d1 = distP(vx[0], vx[1]), d2 = distP(vx[1], vx[2]), d3 = distP(vx[2], vx[0]);\n\t\t(*qdist) = d1; *p1 = vx[0], *p2 = vx[1];\n\t\tif (*qdist>d2)(*qdist) =d2,*p1 = vx[1], *p2 = vx[2];\n\t\tif (*qdist>d3)(*qdist) = d3, *p1 = vx[0] , *p2 = vx[2];\n\t\treturn;\n\t}\n\tif(n==2){\n\t\t(*qdist) = distP(vx[0], vx[1]); *p1 = vx[0], *p2 = vx[1];\n\n\t\treturn;\n\t}\n\tint half = n / 2;\n\tint l = iy, r = iy+half,tempiy=iy;\n\tP middle = vx[half];\n\tP rp1, rp2;\n\tLL  rd;\n\tfor (int i = 0; i < n; i++){\n\t\tif (LessX(vy[i], middle))\n\t\t\tyy[l++] = vy[i];\n\t\telse\n\t\t\tyy[r++] = vy[i];\n\t}\n\tiy += n;\n\tClosest_Pair_rec(half, xs, tempiy, p1, p2, qdist);\n\tClosest_Pair_rec(n-half, xs+half, tempiy+half, &rp1, &rp2, &rd);\n\t/*printf(\"(%.5f, %.5f)\", (middle).x, (middle).y); printf(\"(%.5f, %.5f)\", (*p1).x, (*p1).y); printf(\"(%.5f, %.5f)\", (*p2).x, (*p2).y);\n\tprintf(\"(%.5f, %.5f)\", (rp1).x, (rp1).y); printf(\"(%.5f, %.5f)\\n\", (rp2).x, (rp2).y);*/\n\tif (*qdist>rd)*p1 = rp1, *p2 = rp2, *qdist = rd;\n\n\tint k = 0;\n\tP *vs = ss + is;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\trd = (vy[i].x - middle.x);\n\t\tif (rd < *qdist)\n\t\t\tvs[k++] = vy[i];\n\t}\n\tfor (int i = 0; i < k - 1; i++)\n\t\tfor (int j = i + 1; j < k&&vs[j].y - vs[i].y < *qdist; j++){\n\t\t\trd = distP(vs[i], vs[j]);\n\t\t\tif (*qdist > rd){\n\t\t\t\t*qdist = rd;\n\t\t\t\t*p1 = vs[i];\n\t\t\t\t*p2 = vs[j];\n\t\t\t}\n\t\t}\n\tis += k;\n\t//printf(\"(%.5f, %.5f)\", (*p1).x, (*p1).y);printf(\"(%.5f, %.5f)\\n\", (*p2).x, (*p2).y);\n}\n\nvoid Closest_Pair(int n, vector<P>& list, P* p1, P* p2, LL* qdist){\n\tix = n, iy = n,is=0;\n\tfor (int i = 0; i < n; i++)\n\t\txx[i] = yy[i] = list[i];\n\tsort(xx, xx+n, LessX);\n\tsort(yy, yy+n, LessY);\n\tClosest_Pair_rec(n,0,0,p1, p2, qdist);\n}\n/*\nint main(void){\n\tint N; cin >> N;\n\tLL a, b;\n\tP p1, p2;\n\tvector<P> A(N), B(N);\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i].x >> A[i].y;\n\t\t\n\t}\n\tClosest_Pair(N, A, &p1, &p2, &a);\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> B[i].x >> B[i].y;\n\t}\n\tClosest_Pair(N, B, &p1, &p2, &b);\n\t//cout << b << endl;\n\tprintf(\"%.6f\", sqrt((double)b / (double)a));\n\treturn(0);\n}\n*/\nint main(void){\n\tint N; cin >> N;\n\tLL a;\n\tP p1, p2;\n\tvector<P> A(N);\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i].x >> A[i].y;\n\n\t}\n\tClosest_Pair(N, A, &p1, &p2, &a);\n//\tcout << p1.x<<endl<<p1.y<<endl<< p2.x<< endl << p2.y << endl;\n\t//cout << b << endl;\n\tprintf(\"%.7f\", a);\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\n\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  if (r - l == 2) {\n    return PointPoint(ps[l], ps[l + 1]);\n  }\n  if (r - l == 3) {\n    PointPoint a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return Closer(a, Closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  Points pos[2];\n  for (int i = l; i < r; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) pos[i < mid].push_back(ps[i]);\n  }\n  for (const auto &i : pos[0]) {\n    for (const auto &j : pos[1]) {\n      if (Distance(i, j) < d) {\n        d = Distance(i, j);\n        res = PointPoint(i, j);\n      }\n    }\n  }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  PointPoint res = ClosestPairUtil(ps, 0, ps.size());\n  res.first = rotate(-0.1, res.first);\n  res.second = rotate(-0.1, res.second);\n  return res;\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  sort(p.begin(), p.end());\n  PointPoint pp = ClosestPair(p);\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n  // cerr << pp.first << \" \" << pp.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn 1e9;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP,\n\tint yl,int yr\n){\n\tint xsiz=xr-xl;\n\tint ysiz=yr-yl;\n\tif (xsiz <= 8) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tif(ysiz==0)return 1e9;\n\tauto xM = xP[xl+xsiz/2].first;\n\tauto yL = std::vector<point_t>(ysiz);\n\tint left = -1, right = ysiz;\n\tfor(int i = yl; i < yr; i++){\n\t\tif (yP[i].first < xM) yL[++left] = yP[i];\n\t\telse                  yL[--right]= yP[i];\n\t}\n\tstd::reverse(yL.begin()+right,yL.end());\n\tauto p1 = find_closest_optimized(xP,xl,xl+xsiz/2,yL,0,left+1);\n\tauto p2 = find_closest_optimized(xP,xl+xsiz/2,xr,yL,left+1,ysiz);\n\tauto minD = sqrt((p1 < p2) ? p1 : p2);\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tif(yS.size()>=2)\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n,yP,0,n);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&min(memo,ans+0.0001) >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans =(min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\ntypedef db T;\nconst db eps = 1e-8;\nint sgn(T x){return (x>eps)-(x<-eps);}\nstruct P{\n    T x,y;\n    P(){} P(T x,T y):x(x),y(y){}\n    void read(){scanf(\"%lf%lf\",&x,&y);}\n    P operator - (const P&b) const {return P(x-b.x,y-b.y);}\n    P operator + (const P&b) const {return P(x+b.x,y+b.y);}\n    T operator * (const P&b) const {return x*b.x+y*b.y;}\n    P operator * (const T&k) const {return P(x*k,y*k);}\n    T operator ^ (const P&b) const {return x*b.y-y*b.x;}\n    bool operator < (const P&b) const {return sgn(y-b.y)?y<b.y:x<b.x;}\n};\nT abs(P a){return sqrt(a*a);}\n\nnamespace NearestPoints{\n    T solve(int l,int r,vector<P>&p){\n        if(l == r) return 1e100;\n        int m=(l+r)>>1;\n        T Xm = p[m].x , lim = min(solve(l,m,p) , solve(m+1,r,p));\n        inplace_merge(p.begin()+l,p.begin()+m+1,p.begin()+r+1);\n        vector<P> V;\n        rep(i,l,r+1) if(fabs(p[i].x - Xm) <= lim) V.pb(p[i]);\n        rep(i,0,sz(V)) rep(j,i+1,sz(V)){\n            if(fabs(V[j].y - V[i].y) >= lim) break;\n            T dis = abs(V[i]-V[j]);\n            lim = min(lim,dis);\n        }\n        return lim;\n    }\n    T solve(vector<P> A){\n        sort(all(A),[&](P a,P b){return a.x<b.x;});\n        return solve(0,sz(A)-1,A);\n    }\n}\n\nint main(){\n    int n;scanf(\"%d\",&n);\n    vector<P> A;\n    rep(i,0,n){\n        P p;p.read();\n        A.pb(p);\n    }\n    printf(\"%.10f\\n\",NearestPoints::solve(A));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/50))  \n \n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n double interval[9][2]={{0,2},{0,5},{0,8}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int i=0;i<4;i++)\n     {\n       for(int j=0;j<4;j++)\n       {\n         if(point[i].x>=minx+1.0*i/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(i+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*i/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(i+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*i+j;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n }\n \n //??????????????????????????¬??????2500???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   Fun(i,n) Fun(j,n)\n   {\n     num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n     if(num<fun_min) fun_min=num;           \n   }\n }\n \n void wuhao_cut()\n {\n   if(fun_min<=(1.0*50*50))\n   {\n     ok=true;\n     //?¬¬????±??????? \n     for(int i=0;i<16;i++)\n     {\n       for(int j=0;j<num_point[i];j++)\n       {\n         for(int k=j+1;k<num_point[i];k++)\n         {\n           num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n           if(num<real_min) real_min=num;         \n         }        \n       }        \n     }\n     //?¬¬????±?????????????A?????? \n     for(int m=0;m<4;m++)\n     {\n       for(int n=0;n<3;n++)\n       {\n         for(int i=0;i<num_point[m*4+n];i++)\n         {\n           for(int j=0;j<num_point[m*4+n+1];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;        \n           }        \n         }        \n       }        \n     } \n     //?¬¬????±?????????????B??????\n     for(int m=0;m<4;m++)\n     {\n       for(int n=0;n<3;n++)\n       {\n         for(int i=0;i<num_point[n*4+m];i++)\n         {\n           for(int j=0;j<num_point[(n+1)*4+m];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;        \n           }        \n         }        \n       }        \n     } \n     //?¬¬????±???????A??????\n     for(int m=0;m<3;m++)\n     {\n       for(int n=0;n<3;n++)\n       {\n         for(int i=0;i<num_point[m*4+n];i++)\n         {\n           for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;        \n           }        \n         }        \n       }        \n     }  \n     //?¬¬????±???????B?????? \n     for(int m=0;m<3;m++)\n     {\n       for(int n=1;n<4;n++)\n       {\n         for(int i=0;i<num_point[m*4+n];i++)\n         {\n           for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;        \n           }        \n         }        \n       }        \n     } \n   }   \n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   try_for_fun();\n   if(ok) wuhao_cut(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n   \ntypedef pair<double,double> P;\ntypedef pair<P,double> P2;\n   \nP rot(P p, double a){\n  a=a*M_PI/180.0;\n  return P(p.first*cos(a)+p.second*(-sin(a)),\n  p.first*sin(a)+p.second*cos(a));\n}\n   \ndouble abss(P a,P b){\n  return sqrt((a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second));\n}\n   \ndouble x,y,r;int tt;\nvector<P>v;\nint main(){\n   \n  int n;\n  cin>>n;\n   \n    double ans=1e13;\n       \n    v.clear();\n     \n    r(i,n){\n      cin>>x>>y;\n      v.push_back(P(x,y));\n    }\n   \n    r(i,1){\n      sort(v.begin(),v.end());\n      r(j,n){\n        for(int k=j+1,c=0;k<n;k++,c++){\n          if(c>100)break;\n          ans=min(ans,abss(v[k],v[j]));\n        }\n      }\n      r(j,n)v[i]=rot(v[i],0.5);\n    }\n   \n    printf(\"%.11f\\n\",ans);\n       \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n  \n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\ntypedef double number;\n  \nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<number> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n  \ntypedef vector<P> G;\n  \nnumber closestPair(G &p) {\n  int n = p.size(), s = 0, t = 1, m = 2, S[n]; S[0] = 0, S[1] = 1;\n  sort(ALL(p)); // \"p < q\" <=> \"p.x < q.x\"\n  double d = norm(p[s]-p[t]);\n  for (int i = 2; i < n; S[m++] = i++) REP(j, m) {\n    if (norm(p[S[j]]-p[i])<d) d = norm(p[s = S[j]]-p[t = i]);\n    if (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n  }\n  return abs(p[s]-p[t]);//make_pair( p[s], p[t] );\n}\n  \nint main(){\n\tG poly;\n\tP p;\n\tint n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);n--;poly.push_back(p))scanf(\"%lf%lf\",&x,&y),p=P(x,y);\n\tprintf(\"%.9f\\n\",closestPair(poly));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(3, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(3, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + 1].first - p2[i].first) * (p2[i + 1].first - p2[i].first) + (p2[i + 1].second - p2[i].second) * (p2[i + 1].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nbool pariCompare (const P& FElof, const P& SElof) {\n    if (FElof.first == SElof.first) return FElof.second < SElof.second;\n    return FElof.first < SElof.first;\n}\n\nint main ()\n{\n    int n;\n    cin >> n;\n    vector<P> p(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i].first >> p[i].second;\n    }\n\n    sort(p.begin(), p.end(), pariCompare);\n\n    double dis = 100000000000.0;\n    for (int i = 0; i < n-1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double tmp = pow(p[i].first - p[j].first, 2.0) + pow(p[i].second - p[j].second, 2.0);\n            dis = min(dis, tmp);\n        }\n    }\n\n    printf(\"%.6f\\n\", sqrt(dis));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @note   関連URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0585\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = limits::inf;\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta + limits::eps) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) >= delta + limits::eps) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << setprecision(20) << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\n\n#define fcout(x) cout << fixed << setprecision(x)\n\nint main(){\n    vector<pair<double,double>> v;\n    double x, y;\n    int n;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++){\n        cin >> x >> y;\n        v.push_back({x,y});\n    }\n\n    sort(v.begin(), v.end());\n\n    double ans = 100000;\n\n    for(int i = 0; i < n-1; i++){\n        ans = min(ans, pow(v[i+1].first-v[i].first, 2.0) + pow(v[i+1].second-v[i].second, 2.0));\n    }\n\n    fcout(10) << sqrt(ans) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n\n// Description: ????????????\n// Verifyed: various problem \nusing namespace placeholders;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P c;R r;};\n\nauto& operator >> (istream& is,P& p){ R x,y; is >> x >> y,p=P(x,y); return is;}\nauto& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline P vec(L l){return l.t-l.s;}\nauto sdot = bind(sgn,bind(dot,_1,_2,_3));\nauto sdet = bind(sgn,bind(det,_1,_2,_3));\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/vec(l)); return (1-u)*l.s+u*l.t;}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a){\n\tconst int n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\t\n\tauto cmp_x=[](P a,P b)->bool{\n\t\tint sr = sgn(real(a-b)), si = sgn(imag(a-b));\n\t\treturn sr ? sr < 0 :si < 0;\n\t};\n\t\n\tsort(begin(a),end(a),cmp_x);\n\t\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a));\n\tR x=real(a[m]),d=min(cpp(b),cpp(c));\n\t\n\tauto cmp_y=[](P a,P b)->bool{\n\t\tint sr = sgn(real(a-b)), si = sgn(imag(a-b));\n\t\treturn si ? si < 0 :sr < 0;\n\t};\n\n\tsort(begin(a),end(a),cmp_y);\n\tdeque<P> e;\n\n\tfor(auto &p:a){\n\t\tif(abs(real(p)-x)>=d) continue;\t\n\t\tfor(auto &q:e){\n\t\t\tif(imag(p-q)>=d) break;\n\t\t\td = min(d,abs(p-q));\n\t\t}\n\t\te.push_back(p);\n\t}\n\treturn d;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << cpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<ctime>\n#include<vector>\n \nusing namespace std;\n \n#define eps 0.0000000001\n \nstruct vec{\n  double x, y;\n  void nextvec(){ scanf(\"%lf %lf\", &x, &y); return; }\n  vec operator+(const vec& a) const { return (vec){x + a.x, y + a.y}; }\n  vec operator-(const vec& a) const { return (vec){x - a.x, y - a.y}; }\n  vec operator*(const double& k) const { return (vec){k * x, k * y}; }\n  vec sca(double t){ return (vec){t * x, t * y}; }\n  double dot(vec a){ return x * a.x + y * a.y; }\n  double cross(vec a){ return x * a.y - y * a.x; }\n  double norm(){ return sqrt(x * x + y * y); }\n  double norm2(){ return x * x + y * y; }\n};\n \nbool xsort(vec qwe, vec rty){ return qwe.x < rty.x; }\nbool ysort(vec qwe, vec rty){ return qwe.y < rty.y; }\n \nvec pt[100000];\nvec ytmp[100000];\nvec ymerge[100000];\ndouble ma = 100000000000.0;\n \ndouble closestpair(int l, int r){\n  if(r - l <= 1)return ma;\n  int m = l + (r - l) / 2;\n  double xm = pt[m].x;\n  double res = min(closestpair(l, m), closestpair(m, r));\n \n  int hdmerge = 0, hdtmp = 0, lhd = l, rhd = m;\n  vec now;\n  for(;;){\n    if(lhd == m && rhd == r)break;\n    else if(rhd == r)now = pt[lhd++];\n    else if(lhd == m)now = pt[rhd++];\n    else if(ysort(pt[lhd], pt[rhd]))now = pt[lhd++];\n    else now = pt[rhd++];\n \n    ymerge[hdmerge++] = now;\n    if(abs(now.x - xm) <= res + eps){\n      ytmp[hdtmp++] = now;\n      for(int i = hdtmp - 2;i >= 0;--i){\n        if(abs(ytmp[i].y - now.y) >= res - eps)break;\n        res = min(res, (now - ytmp[i]).norm());\n      }\n    }\n  }\n  for(int i = l;i < r;++i)pt[i] = ymerge[i - l];\n \n  return res;\n}\n \nsigned main(void){\n  int n;\n  scanf(\"%d\", &n);\n  for(int i = 0;i < n;++i)pt[i].nextvec();\n  sort(pt, pt + n, xsort);\n  printf(\"%.13lf\\n\", closestpair(0, n));\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b) {\n\treturn std::sqrt(std::pow(b.first - a.first, 2)\n\t\t+ std::pow(b.second - a.second, 2));\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points) {\n\tif (points.size() < 2) {\n\t\treturn -1;\n\t}\n\tauto minDistance = std::abs(distance_between(points.at(0), points.at(1)));\n\tfor (auto i = std::begin(points); i != (std::end(points) - 1); ++i) {\n\t\tfor (auto j = i + 1; j < std::end(points); ++j) {\n\t\t\tauto newDistance = std::abs(distance_between(*i, *j));\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(const std::vector<point_t>& xP,\n\tconst std::vector<point_t>& yP) {\n\tif (xP.size() <= 3) {\n\t\treturn find_closest_brute(xP);\n\t}\n\tauto N = xP.size();\n\tauto xL = std::vector<point_t>();\n\tauto xR = std::vector<point_t>();\n\tstd::copy(std::begin(xP), std::begin(xP) + (N / 2), std::back_inserter(xL));\n\tstd::copy(std::begin(xP) + (N / 2), std::end(xP), std::back_inserter(xR));\n\tauto xM = xP.at(N / 2).first;\n\tauto yL = std::vector<point_t>();\n\tauto yR = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {\n\t\treturn p.first <= xM;\n\t});\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {\n\t\treturn p.first > xM;\n\t});\n\tauto p1 = find_closest_optimized(xL, yL);\n\tauto p2 = find_closest_optimized(xR, yR);\n\tauto minD = (p1 <= p2) ? p1 : p2;\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = std::abs(distance_between(*k, *i));\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP, yP);\n\tprintf(\"%.9f\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<utility>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n\ntypedef pair<double, double> point;\ntypedef point* data;\n\ninline double dist(const point &a, const point &b)\n{\n    double dx = a.first - b.first, dy = a.second - b.second;\n    return sqrt(dx * dx + dy * dy);\n}\n\nbool sort_y(const point &P1, const point &P2){ return P1.second < P2.second; }\n\ndouble closest(data P, int n)\n{\n    if(n <= 1) return 1000;\n    if(n == 2) return dist(P[0], P[1]);\n    int m = n / 2;\n    sort(P, P + n, sort_y); // y_sort, down to up.\n    double d = min(closest(P, m), closest(P + m, n - m));\n\n    sort(P, P + m);\n    sort(P + m, P + n);\n    // x_sort, left to right.\n    int a, b, u, v, i, j;\n    a = u = i = 0, b = v = j = m;\n    while(i < m && j < n){\n        if(P[u].first < P[v].first){\n            for(i = a; i < m; i++){\n                if(P[i].first >= P[v].first){ u = i; break; }\n                if(P[v].first - P[i].first >= d){ a++; }\n                else{\n                    d = min(d, dist(P[v], P[i]));\n                }\n            }\n        }else{\n            for(j = b; j < n; j++){\n                if(P[j].first > P[u].first){ v = j; break; }\n                if(P[u].first - P[j].first >= d){ b++; }\n                else{\n                    d = min(d, dist(P[u], P[j]));\n                }\n            }\n        }\n    };\n    return d;\n}\n\nint main()\n{\n\tint i, n;\n\tdouble x, y;\n\tscanf(\"%d\", &n);\n\tdata P;\n\tP = new point [n];\n\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tP[i] = make_pair(x, y);\n\t}\n\tprintf(\"%.12f\\n\", closest(P, n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ntypedef vector<P> G;\n\ndouble compare_x(const P &a, const P &b){\n  return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n}\n\ndouble compare_y(const P &a, const P &b){\n  return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;\n}\n\ndouble convex_radius(P *a, int n){\n    if(n <= 1) return INF;\n    int m = n / 2;\n    double x = a[m].X;\n    double d = min(convex_radius(a, m), convex_radius(a + m, n - m));\n    sort(a, a + n, compare_y);\n    vector<P> b;\n    for(int i = 0; i < n; ++i){\n        if(fabs(a[i].X - x) >= d) continue;\n        for(int j = 0; j < (int)b.size(); ++j){\n            P p0 = a[i], p1 = b[(int)(b.size()) - j - 1];\n            if(p0.Y - p1.Y >= d) break;\n            d = min(d, abs(p0 - p1));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  sort(g.begin(), g.end(), compare_x);\n  printf(\"%.10lf\\n\", convex_radius(&g[0], N));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nld getdis(const pair<ld, ld>&l, const pair<ld, ld>&r) {\n\treturn sqrt((l.first - r.first)*(l.first - r.first) + (l.second - r.second)*(l.second - r.second));\n}\nld getans(const vector<pair<ld, ld>>&ps,int l,int r) {\n\tif (r-l == 2) {\n\t\treturn getdis(ps[l], ps[l+1]);\n\t}\n\telse if (r-l ==1) {\n\t\treturn 1e18;\n\t}\n\telse {\n\t\tint n = (r+l) / 2;\n\t\tauto nit = ps.begin() + n;\n\t\tld la = getans(ps,l,n);\n\t\tld ra = getans(ps,n,r);\n\t\tld nans = min(la, ra);\n\t\tauto lit = lower_bound(ps.begin()+l, ps.begin()+r, make_pair(ps[n].first - nans, -1e18l));\n\t\tauto rit = upper_bound(ps.begin() + l, ps.begin() + r, make_pair(ps[n].first + nans,  1e18l));\n\t\tfor (auto a = lit; a != nit; ++a) {\n\t\t\tfor (auto b =nit; b != rit; ++b) {\n\t\t\t\tnans = min(nans, getdis(*a, *b));\n\t\t\t}\n\t\t}\n\t\treturn nans;\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\tvector<pair<ld, ld>>ps;\n\tfor (int i = 0; i < N; ++i) {\n\t\tld x, y; cin >> x >> y;\n\t\tps.emplace_back(x, y);\n\t}\n\tsort(ps.begin(), ps.end());\n\tld ans = getans(ps,0,ps.size());\n\tcout <<setprecision(22)<<fixed<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n  \n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\ntypedef double number;\n  \nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<number> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n  \ntypedef vector<P> G;\n  \nnumber closestPair(G &p) {\n  int n = p.size(), s = 0, t = 1, m = 2;\n  int S[n];\n  S[0] = 0, S[1] = 1;\n  sort(ALL(p)); // \"p < q\" <=> \"p.x < q.x\"\n  double d = abs(p[s]-p[t]);\n  for (int i = 2; i < n; S[m]=i,i++,m++) REP(j, m) {\n    if (abs(p[S[j]]-p[i])<d) s = S[j], t = i, d = abs(p[s]-p[t]);\n    if (real(p[S[j]]) < real(p[i]) - d) m--,S[j]=S[m],j--;\n  }\n  return abs(p[s]-p[t]);//make_pair( p[s], p[t] );\n}\n  \nint main(){\n\tG poly;\n\tint n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);n--;poly.push_back(P(x,y)))scanf(\"%lf%lf\",&x,&y);\n\tprintf(\"%.9f\\n\",closestPair(poly));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf dist ( pt A, pt B ) { return abs( B - A ); }\n\nint n;\npt P[ MAXN ], extra[ MAXN ];\n\nbool cmpX( const pt &A, const pt &B ) {\n  if( same( A.x, B.x ) ) return A.y < B.y;\n  return A.x < B.x;\n}\n\n/*\nlf sqr( lf x ) {\n  return x*x;\n}*/\n\nvoid merge( int f, int m, int t ){\n\tint total = t - f + 1;\n\tfor( int i = 0, l = f, r = m+1; i < total; ++i ){\n\t\tif( l == m+1 ){\n      extra[ i ] = P[ r++ ];\n\t\t}\n\t\telse if( r == t+1 ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse if( P[l].y < P[r].y ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse{\n\t\t  extra[ i ] = P[ r++ ];\n\t\t}\n\t}\n\tfor( int i = 0; i < total; ++i ){\n    P[ f+i ] = extra[ i ];\n\t}\n}\n\nlf solve( int f, int t ) {\n  if( f == t ) return oo;\n\tint mi = (f + t)/2;\n\tlf d = min( solve( f, mi ), solve( mi+1, t ) );\n\tmerge( f, mi, t );\n\tvector< int > idxs;\n\tfor( int i = f; i <= t; ++i ){\n\t\tif( fabs(P[mi].x - P[i].x) < d ) idxs.push_back( i );\n\t}\n\tfor( int i = 0; i < idxs.size(); ++i ){\n\t\tfor( int j = i+1; j < idxs.size() && fabs(P[ idxs[i] ].y - P[ idxs[j] ].y) < d; ++j ){\n\t\t\td = min( d, dist( P[ idxs[i] ], P[ idxs[j] ] ) );\n\t\t}\n\t}\n\treturn d;\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"CGL_5_A-in18.txt\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  sort( P, P+n, cmpX );\n  /*d = oo;\n  for( int i = 0; i < n; ++i ) {\n    for( int j = i+1; j < n; ++j ) {\n      d = min( d, dist(P[i],P[j]) );\n    }\n  }\n  cout << double(sqrt(d)) << '\\n';*/\n  cout << double( solve( 0, n-1 ) ) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntemplate<class T>\nstruct Point {\n\ttypedef Point P;\n\tT x, y;\n\texplicit Point(T x=0, T y=0) : x(x), y(y) {}\n\tbool operator<(P p) const { return tie(x,y) < tie(p.x,p.y); }\n\tbool operator==(P p) const { return tie(x,y)==tie(p.x,p.y); }\n\tP operator+(P p) const { return P(x+p.x, y+p.y); }\n\tP operator-(P p) const { return P(x-p.x, y-p.y); }\n\tP operator*(T d) const { return P(x*d, y*d); }\n\tP operator/(T d) const { return P(x/d, y/d); }\n\tT dot(P p) const { return x*p.x + y*p.y; }\n\tT cross(P p) const { return x*p.y - y*p.x; }\n\tT cross(P a, P b) const { return (a-*this).cross(b-*this); }\n\tT dist2() const { return x*x + y*y; }\n\tdouble dist() const { return sqrt((double)dist2()); }\n\t// angle to x-axis in interval [-pi, pi]\n\tdouble angle() const { return atan2(y, x); }\n\tP unit() const { return *this/dist(); } // makes dist()=1\n\tP perp() const { return P(-y, x); } // rotates +90 degrees\n\tP normal() const { return perp().unit(); }\n\t// returns point rotated 'a' radians ccw around the origin\n\tP rotate(double a) const {\n\t\treturn P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }\n};\n\nusing P = Point<double>;\n\ntemplate<class P>\nint lineIntersection(const P& s1, const P& e1, const P& s2,\n\t\tconst P& e2, P& r) {\n\tif ((e1-s1).cross(e2-s2)) { //if not parallell\n\t\tr = s2-(e2-s2)*(e1-s1).cross(s2-s1)/(e1-s1).cross(e2-s2);\n\t\treturn 1;\n\t} else\n\t\treturn -((e1-s1).cross(s2-s1)==0 || s2==e2);\n}\n\nvector<P> polygonCut(const vector<P>& poly, P s, P e) {\n\tvector<P> res;\n\trep(i,0,sz(poly)) {\n\t\tP cur = poly[i], prev = i ? poly[i-1] : poly.back();\n\t\tbool side = s.cross(e, cur) < 0;\n\t\tif (side != (s.cross(e, prev) < 0)) {\n\t\t\tres.emplace_back();\n\t\t\tlineIntersection(s, e, cur, prev, res.back());\n\t\t}\n\t\tif (side)\n\t\t\tres.push_back(cur);\n\t}\n\treturn res;\n}\n\n\ntemplate<class It>\nbool it_less(const It& i, const It& j) { return *i < *j; }\ntemplate<class It>\nbool y_it_less(const It& i,const It& j) {return i->y < j->y;}\n\ntemplate<class It, class IIt> /* IIt = vector<It>::iterator */\ndouble cp_sub(IIt ya, IIt yaend, IIt xa, It &i1, It &i2) {\n\ttypedef typename iterator_traits<It>::value_type P;\n\tint n = yaend-ya, split = n/2;\n\tif(n <= 3) { // base case\n\t\tdouble a = (*xa[1]-*xa[0]).dist(), b = 1e50, c = 1e50;\n\t\tif(n==3) b=(*xa[2]-*xa[0]).dist(), c=(*xa[2]-*xa[1]).dist();\n\t\tif(a <= b) { i1 = xa[1];\n\t\t\tif(a <= c) return i2 = xa[0], a;\n\t\t\telse return i2 = xa[2], c;\n\t\t} else { i1 = xa[2];\n\t\t\tif(b <= c) return i2 = xa[0], b;\n\t\t\telse return i2 = xa[1], c;\n\t}\t}\n\tvector<It> ly, ry, stripy;\n\tP splitp = *xa[split];\n\tdouble splitx = splitp.x;\n\tfor(IIt i = ya; i != yaend; ++i) { // Divide\n\t\tif(*i != xa[split] && (**i-splitp).dist2() < 1e-12)\n\t\t\treturn i1 = *i, i2 = xa[split], 0;// nasty special case!\n\t\tif (**i < splitp) ly.push_back(*i);\n\t\telse ry.push_back(*i);\n\t} // assert((signed)lefty.size() == split)\n\tIt j1, j2; // Conquer\n\tdouble a = cp_sub(ly.begin(), ly.end(), xa, i1, i2);\n\tdouble b = cp_sub(ry.begin(), ry.end(), xa+split, j1, j2);\n\tif(b < a) a = b, i1 = j1, i2 = j2;\n\tdouble a2 = a*a;\n\tfor(IIt i = ya; i != yaend; ++i) { // Create strip (y-sorted)\n\t\tdouble x = (*i)->x;\n\t\tif(x >= splitx-a && x <= splitx+a) stripy.push_back(*i);\n\t}\n\tfor(IIt i = stripy.begin(); i != stripy.end(); ++i) {\n\t\tconst P &p1 = **i;\n\t\tfor(IIt j = i+1; j != stripy.end(); ++j) {\n\t\t\tconst P &p2 = **j;\n\t\t\tif(p2.y-p1.y > a) break;\n\t\t\tdouble d2 = (p2-p1).dist2();\n\t\t\tif(d2 < a2) i1 = *i, i2 = *j, a2 = d2;\n\t}\t}\n\treturn sqrt(a2);\n}\n\ntemplate<class It> // It is random access iterators of point<T>\ndouble closestpair(It begin, It end, It &i1, It &i2 ) {\n\tvector<It> xa, ya;\n\tassert(end-begin >= 2);\n\tfor (It i = begin; i != end; ++i)\n\t\txa.push_back(i), ya.push_back(i);\n\tsort(xa.begin(), xa.end(), it_less<It>);\n\tsort(ya.begin(), ya.end(), y_it_less<It>);\n\treturn cp_sub(ya.begin(), ya.end(), xa.begin(), i1, i2);\n}\n\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\tint n;\n\tcin >> n;\n\tvector<P> a(n);\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i].x >> a[i].y;\n\t}\n\tauto it1 = a.begin(), it2 = a.begin();\n\tcout << closestpair(a.begin(), a.end(), it1, it2) << '\\n';\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\ntypedef pair<double, double> P;\n\ndouble dist(P a, P b)\n{\n  double str1 = fabs(a.first-b.first);\n  double str2 = fabs(a.second-b.second);\n\n  return( sqrt( str1*str1 + str2*str2 ) );\n}\n  \nint main()\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  int n;\n  cin >> n;\n  P data[n];\n  for(int i=0;i<n;i++){\n    cin >> data[i].first >> data[i].second; //x y\n  }\n  \n  double mins=1000000;\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      mins = min(mins, dist(data[i], data[j]) );\n    }\n  }\n\n  printf(\"%.12f\\n\",mins);\n  \n  return 0;\n}\n\n  \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <random>\n#include <unordered_map>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n    Point* next;\n};\n\nuint64_t toKey(int x, int y){\n    union Key{\n        uint64_t key;\n        int x[2];\n    };\n    Key K;\n    K.x[0]=x, K.x[1]=y;\n    return K.key;\n}\n\nvoid build(unordered_map<uint64_t, Point*>& Grid, double d, int i, Point *P){\n    Grid.clear();\n    for(int j=0;j<=i;j++){\n        int x=floor(P[j].x),y=floor(P[j].y);\n        uint64_t key = toKey(x,y);\n        if(Grid.count(key)!=0){\n            P[j].next=Grid[key];\n        }\n        Grid[key]=&P[j];\n    }\n}\n\ndouble d(Point& a, Point &b){\n    return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\ndouble search(unordered_map<uint64_t, Point*>& Grid,Point& P){\n    int x=floor(P.x),y=floor(P.y);\n    uint64_t key;\n    double distance=1e10;\n    for(int dx=-1;dx<2;dx++){\n        for(int dy=-1;dy<2;dy++){\n            key=toKey(x+dx,y+dy);\n            if(Grid.count(key)){\n                Point *p=Grid[key];\n                while(p!=NULL){\n                    if(distance>d(*p,P)) distance=d(*p,P);\n                    p=p->next;\n                }\n            }\n        }\n    }\n    return distance;\n}\n\nvoid insert(unordered_map<uint64_t, Point*>& Grid,Point& P){\n    int x=floor(P.x),y=floor(P.y);\n    uint64_t key = toKey(x,y);\n    if(Grid.count(key)!=0){\n        P.next=Grid[key];\n    }\n    Grid[key]=&P;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    Point P[n];\n    for(int i=0;i<n;i++){\n        cin >> P[i].x >> P[i].y;\n        P[i].next=NULL;\n    }\n    //??????????????£???????????????\n    random_device rd;\n    mt19937 mt(rd());//?????????????????§?????????????????????????????????\n    uniform_int_distribution<int> dist(0,n-1);\n    for(int i=0;i<n;i++){\n        int j = dist(mt);\n        Point p = P[i];\n        P[i]=P[j];\n        P[j]=p;\n    }\n    unordered_map<uint64_t, Point*> Grid;\n    double delta=d(P[0],P[1]);\n    build(Grid,delta,1,P);\n    for(int i=2;i<n;i++){\n        double d2=search(Grid,P[i]);\n        if(d2>delta){\n            insert(Grid,P[i]);\n        }else{\n            delta=d2;\n            build(Grid,delta,i,P);\n        }\n    }\n    cout.precision(6);\n    cout << fixed;\n    cout << delta << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 1000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tfor (size_t j = 1; i+j < N; j++)\n\t\t{\n\t\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\t}\n\t\t/*memo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i+j<N&&memo >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\t\tj++;\n\t\t}*/\n\t}\n\tcout << fixed << setprecision(8)<<sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nstruct Point {\n    double x, y;\n    bool operator < (const Point& p) const {\n        if(x != p.x) return x < p.x;\n        return y < p.y;\n    }\n};\n\n\ndouble dist(double x, double y){\n    return sqrt(x * x + y * y);\n}\ndouble dist(Point p, Point q){\n    return dist(p.x - q.x, p.y - q.y);\n}\n\nint main(){\n    int N;\n    cin >> N;\n    vector<Point> ps(N);\n    REP(i, N){\n        double x, y;\n        scanf(\"%lf %lf\", &ps[i].y, &ps[i].x);\n    }\n    sort(ps.begin(), ps.end());\n    double ans = dist(ps[0], ps[1]);\n    for(int i = 0; i < N; i++){\n        for(int j = i + 1; j < N && ps[j].x - ps[i].x < ans; j++){\n            ans = min(ans, dist(ps[i], ps[j]));\n        }\n    }\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;(i)<(n);++(i))\nusing namespace std;\n\n// Description: ????????????\n// Verifyed: various problem \nusing namespace placeholders;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst R INF = 1E40L;\nconst R PI = acos(-1.0L);\nusing P=complex<R>;\nusing L=struct{P s,t;};\nusing VP=vector<P>;\nusing C=struct{P c;R r;};\n\n#define at(a,i) (a[(i + a.size()) % a.size()])\n\nauto& operator >> (istream& is,P& p){ R x,y; is >> x >> y,p=P(x,y); return is;}\nauto& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){return real(conj(a-o)*(b-o));}\ninline R det(P o,P a,P b){return imag(conj(a-o)*(b-o));}\ninline P vec(L l){return l.t-l.s;}\nauto sdot = bind(sgn,bind(dot,_1,_2,_3));\nauto sdet = bind(sgn,bind(det,_1,_2,_3));\n\n//projection verify AOJ CGL_1_A\nP proj(L l,P p){ R u=real((p-l.s)/vec(l)); return (1-u)*l.s+u*l.t;}\n\n/*\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag = 1){\n\t\n\t\n\tVP e;\n\n\trep(i,n){\n        if(abs(real(a[i])-x)>=d) continue;   \n        rep(_j,e.size()){\n            const\n            if(imag(a[i]-e[j])>=d) break;\n            chmin(d,abs(a[i]-e[j]));\n        }\n        e.emplace_back(a[i]);\n    }\n\tfor(auto &p:a){\n\t\tif(abs(real(p)-x)>=d) continue;\t\n\t\trep(j,e.size())){\n\t\t\tP q = at(pol,-j);\n\t\t\tif(imag(p-q)>=d) break;\n\t\t\td = min(d,abs(p-q));\n\t\t}\n\t\te.push_back(p);\n\treturn d;\n}\n*/\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tconst int n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\t\n\tauto cmp_x=[](P a,P b)->bool{\n\t\tint sr = sgn(real(a-b)), si = sgn(imag(a-b));\n\t\treturn sr ? sr < 0 :si < 0;\n\t};\n\n\tif(flag) sort(begin(a),end(a),cmp_x);\n\t\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a));\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\t\n\n\tauto cmp_y=[](P a,P b)->bool{\n\t\tint sr = sgn(real(a-b)), si = sgn(imag(a-b));\n\t\treturn si ? si < 0 :sr < 0;\n\t};\n\n\tsort(begin(a),end(a),cmp_y);\n\tdeque<P> e;\n\n\tfor(auto &p:a){\n\t\tif(abs(real(p)-x)>=d) continue;\t\n\t\t\n\t\tfor(auto &q:e){\n\t\t\tif(imag(p-q)>=d) break;\n\t\t\td=min(d,abs(p-q));\n\t\t}\n\t\te.push_front(p);\n\t}\n\treturn d;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << cpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define INF 1000000000.0;\ntypedef pair<double, double> P;\n\n\nbool compare_y(P a, P b){\n    return a.second < b.second;\n}\n\ndouble closest_pair(vector<P> &a, int pos, int n){\n    if(n==1) return INF;\n    int m = n/2;\n    double x = a[m+pos].first;\n    double d = min(closest_pair(a,pos,m), closest_pair(a,pos+m,n-m));\n    inplace_merge(a.begin()+pos,a.begin()+pos+m,a.begin()+pos+n, compare_y);\n\n    vector<P> b;\n    for(int i=0;i<n;i++){\n        if(fabs(a[i+pos].first - x) >= d) continue;\n\n        for(int j=0;j < b.size(); j++){\n            double dx = a[i+pos].first - b[b.size()-1-j].first;\n            double dy = a[i+pos].second - b[b.size()-j-1].second;\n            if(dy >= d) break;\n            d = min(d, sqrt(dx *dx + dy * dy));\n        }\n        b.push_back(a[i+pos]);\n    }\n    /*\n    for(int i=0;i<n;i++){\n        cout << \"(\" << a[i+pos].first <<\",\"<< a[i+pos].second<<\")\";\n    }\n    cout << endl;\n    cout << d << endl;\n    */\n    return d;\n}\n\nint main(){\n    int n; cin >> n;\n    vector<P> points(n);\n    for(int i=0;i<n;i++){\n        cin >> points[i].first >> points[i].second;\n    }\n    sort(points.begin(), points.end());\n    printf(\"%.16lf\\n\", closest_pair(points, 0, n));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\ntypedef pair<double, double> P;\n\ndouble dist(P a, P b)\n{\n  double str1 = fabs(a.first-b.first);\n  double str2 = fabs(a.second-b.second);\n\n  return( sqrt( str1*str1 + str2*str2 ) );\n}\n  \nint main()\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  int n;\n  cin >> n;\n  P data[n];\n  for(int i=0;i<n;i++){\n    cin >> data[i].first >> data[i].second; //x y\n  }\n  \n  double mins=1000000;\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      mins = min(mins, dist(data[i], data[j]) );\n    }\n  }\n\n  printf(\"%.12f\\n\",mins);\n  \n  return 0;\n}\n\n  \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> //std==c++14\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a,b) ( fabs(a-b) < EPS )\n#define PI 3.141592653589793238\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intersect Circle and Circle\nstatic const int ICC_SEPARATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct point{\n\tdouble x,y;\n\t//construct\n\tpoint() {} \n\tpoint(double x,double y):x(x),y(y){}\n\t//演算子\n\tpoint operator + (point p) { return point(x+p.x,y+p.y); }\n\tpoint operator - (point p) { return point(x-p.x,y-p.y); }\n\tpoint operator * (double k) { return point(x*k,y*k); }\n\tpoint operator / (double k) { return point(x/k,y/k); }\n\tpoint operator / (point p) { return point( (x*p.x + y*p.y)/p.norm()  , (-x*p.y + y*p.x)/p.norm() ) ; }\n\tbool operator < (point p) { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (point p) { return equals(x,p.x) && equals(y,p.y) ; }\n\t//function\n\tdouble arg() { return atan2(y,x) ; }\n\tdouble norm(){return x*x+y*y; }\n\tdouble abs() { return sqrt(norm() ) ;}\n\tdouble dot(point p) { return p.x*x + p.y*y; }\n\tdouble cross(point p) { return x*p.y - y*p.x; }\n\n\t//input output\n\tvoid input(){cin>>x>>y;}\n\tvoid polar(double r,double theta){ x = r*cos(theta), y= r*sin(theta) ; }\n\tvoid print(){cout<<x<<' '<<y<<endl;};\n\n};\n\nbool sort_x(point a,point b){\n\treturn a.x!=b.x?a.x<b.x:a.y<b.y ;\n}\nbool sort_y(point a,point b){\n\treturn a.y!=b.y?a.y<b.y:a.x<b.x ;\n}\n\ntypedef vector<point> polygon;\n\nstruct segment{\n\tpoint s,t;\n\tsegment() {}\n\tsegment(point s,point t) : s(s),t(t){}\n\tvoid input(){s.input(),t.input(); }\n};\ntypedef segment line;\n\nstruct circle{\n\tpoint c;\n\tdouble r;\n\tcircle() {}\n\tcircle(point c,double r) : c(c),r(r){}\n\n};\n\ndouble norm(point a){\treturn a.norm(); }\ndouble abs(point a){ return a.abs(); }\ndouble arg(point a){ return a.arg(); }\ndouble dot(point a,point b) { return a.x*b.x + a.y*b.y ; }\ndouble cross(point a,point b) { return a.x * b.y - a.y * b.x ; }\npoint polar(double r,double theta){ point a; a.polar(r,theta); return a; }\npoint orth(point p){ return point(-p.y,p.x); }\n\n//isOrthgonal 垂直\nbool isOrthogonal(point a,point b) { return equals(dot(a,b), 0.0 ) ; }\nbool isOrthogonal(point a,point b,point c,point d) { return isOrthogonal(a-b,c-d) ; }\nbool isOrthogonal(line l1,line l2 ){ return isOrthogonal(l1.t-l1.s,l2.t-l2.s); }\n//isParallel 平行\nbool isParallel(point a,point b) { return equals(cross(a,b), 0.0) ; }\nbool isParallel(point a,point b,point c,point d) { return isParallel(a-b,c-d); }\nbool isParallel(line l1,line l2) { return isParallel(l1.t-l1.s,l2.t-l2.s) ; }\n\npoint project(line l,point p){\n\tpoint base = l.t-l.s;\n\tdouble r = dot(p-l.s,base) / norm(base) ;\n\treturn l.s + base*r;\n}\npoint reflect(line l,point p){\n\treturn p + (project(l,p) - p) *2.0;\n}\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\n\tif(cross(a,b) > EPS ) return CCW_COUNTER_CLOCKWISE ;\n\tif(cross(a,b) < -EPS ) return CCW_CLOCKWISE;\n\tif(dot(a,b) < -EPS ) return CCW_ONLINE_BACK;\n\tif(a.norm() < b.norm() ) return CCW_ONLINE_FRONT;\n\treturn CCW_ON_SEGMENT;\n}\n\n\n//intersect\nbool intersect(point p1,point p2,point p3,point p4){return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 ) ; }\nbool intersect(line l1,line l2) { return intersect(l1.s,l1.t,l2.s,l2.t) ; }\nbool intersect(polygon p,line l){\n\tint n = p.size();\n\tfor(int i=0;i<n;i++)  if(intersect(line(p[i],p[(i+1)%n] ) , l ) ) return true;\n\treturn false;\n}\nint intersect(circle c1,circle c2){\n\tif(c1.r < c2.r) swap(c1,c2);\n\tdouble d = abs(c1.c-c2.c);\n\tdouble r = c1.r + c2.r;\n\tif(equals(d,r) ) return ICC_CIRCUMSCRIBE;\n\tif(d > r ) return ICC_SEPARATE;\n\tif(equals(d+c2.r,c1.r) ) return ICC_INSCRIBE;\n\tif( d + c2.r < c1.r ) return ICC_CONTAIN;\n\treturn ICC_INTERSECT;\n}\n\n//bool intersectsc(line l,circle c){ return distancesp(l,c.c) <= c.r ; } distanceののち\nint intersectcs(circle c,line l ){// 0\t\t1\t\t2\n\tif(norm(project(l,c.c) - c.c )  - c.r*c.r  > EPS ) return 0;\n\tdouble d1 = abs(c.c-l.s),d2  = abs(c.c-l.t);\n\tif(d1 < c.r + EPS && d2 < c.r + EPS ) return 0;\n\tif( (d1<c.r - EPS && d2 > c.r +EPS) || (d1 > c.r +EPS &&d2 < c.r -EPS ) ) return 1;\n\tpoint h = project(l,c.c) ;\n\tif(dot(l.s-h,l.t-h) < 0 ) return 2;\n\treturn 0;\n}\n\n//distance\n//line point\ndouble distancelp(line l,point p){ return abs(cross(l.t-l.s,p-l.s)/ abs(l.t-l.s)  ); }\n//segment point\ndouble distancesp(line l,point p){ \n\tif(dot(l.t-l.s,p-l.s) < 0.0 ) return abs(p-l.s);\n\tif(dot(l.s-l.t,p-l.t) < 0.0 ) return abs(p-l.t);\n\treturn distancelp(l,p);\n}\n//segment segment \ndouble distancess(line l1,line l2){\n\tif(intersect(l1,l2) ) return 0.0;\n\treturn min( min(distancesp(l1,l2.s) ,distancesp(l1,l2.t) ) , min(distancesp(l2,l1.s),distancesp(l2,l1.t)  ) );\n}\n\nbool intersectsc(line l,circle c){ return distancesp(l,c.c) <= c.r ; }\n\n//crosspoint \n//segment segment\npoint crosspointss(line l1,line l2){\n\tfor(int k=0;k<2;k++){\n\t\tif(distancesp(l1,l2.s) < EPS ) return l2.s;\n\t\tif(distancesp(l1,l2.t) < EPS ) return l2.t;\n\t\tswap(l1,l2);\n\t}\n\tpoint base = l2.t-l2.s;\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.t-l2.s) );\n\tdouble t = d1/(d1+d2);\n\treturn l1.s + (l1.t-l1.s) * t;\n}\n//line line\npoint crosspointll(line l1,line l2){\n\tdouble a = cross(l1.t-l1.s,l2.t-l2.s);\n\tdouble b = cross(l1.t-l1.s,l1.t-l2.s);\n\tif(abs(a) < EPS && abs(b) < EPS ) return l2.s;\n\treturn l2.s + (l2.t-l2.s) * (b/a) ;\n}\n//circle line\npolygon crosspointCL(circle c,line l){\n\tpolygon ps;\n\tpoint pr = project(l,c.c);\n\tpoint e = (l.t - l.s) / abs(l.t-l.s) ;\n\tif(distancelp(l,c.c) > c.r ) return ps;//付け足した\n\tif(equals(distancelp(l,c.c),c.r) ){\n\t\tps.emplace_back(pr);\n\t}\n\tdouble base = sqrt(c.r*c.r - norm(pr-c.c) );\n\tps.emplace_back(pr + e*base ) ;\n\tps.emplace_back(pr - e*base ) ;\n\treturn ps;\n}\n//circle segment\npolygon crosspointCS(circle c,line l ){\n\tpolygon res = crosspointCL(c,l);\n\tif(intersectcs(c,l) == 2 ) return res;\n\tif(res.size() > 1u ){//一つのみ削る\n\t\tif(dot(l.s-res[0] ,l.t-res[0] ) > 0) swap(res[0],res[1] );\n\t\tres.pop_back();\n\t}\n\treturn res;\n}\npolygon crosspointcc(circle c1,circle c2){\n\tpolygon p(2);\n\tdouble d = abs(c1.c-c2.c);\n\tdouble a = acos( (c1.r *c1.r + d*d -c2.r*c2.r) /(2*c1.r*d ) );\n\tdouble t = arg(c2.c-c1.c);\n\tp[0] = c1.c + polar(c1.r,t+a);\n\tp[1] = c1.c + polar(c1.r,t-a);\n\treturn p;\n}\n\nint contains(polygon g,point p) { //IN:2 ON:1 OUT:0\n    int n = g.size();\n    bool f = false;\n    for(int i=0;i<n;i++){\n\tpoint a = g[i] - p,b = g[(i+1)%n] - p;\n\tif( fabs(cross(a,b) ) < EPS && dot(a,b) < EPS) return 1;\n\tif( a.y > b.y ) swap(a,b);\n\tif( a.y < EPS && EPS < b.y && cross(a,b) > EPS ) f = !f;\n    }\n    return (f?2:0) ;\n}\n\npolygon andrewscan(polygon &s){ //convex hull\n\tpolygon u,l;\n\tif(s.size() < 3) return s;\n\t//sort(s.begin(),s.end() );\n\t//最も左で最も右の点にする\n\tsort(s.begin(),s.end(),sort_y);\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\tfor(int i=2;i<s.size();i++){\n\t\tfor(int n = u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CCW_CLOCKWISE;n--)//凸包の辺上を含めない\n\t\t//for(int n = u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) == CCW_COUNTER_CLOCKWISE;n--)//凸包の辺上を含める場合\n\t\tu.pop_back();\n\t\tu.push_back(s[i]);\n\t}\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CCW_CLOCKWISE;n--)//凸包の辺上を含めない\t\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) == CCW_COUNTER_CLOCKWISE;n--)//凸包の辺上を含める場合\n\t\tl.pop_back();\n\t\tl.push_back(s[i]);\n\t}\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n\t//最も左で最も右の点にする\n\t/*point mini = l[0];\n\tint base = 0;\n\tfor(int i=0;i<l.size();i++)\n\t    if(mini.y > l[i].y || (mini.y==l[i].y && mini.x > l[i].x ) ){\n\t\t\tmini = l[i];\n\t\t\tbase = i;\n\t    }\n\tpolygon res;\n\tfor(int i=0;i<l.size();i++)res.push_back( l[(i+base)%l.size()] );\n\treturn res;*/\n}\n\ndouble diameter(polygon &s){\n\tpolygon p = s;\n\tint n = p.size();\n\tif(n==2) return abs(p[0]-p[1]);\n\tint i=0,j=0;\n\tfor(int k=0;k<n;k++){\n\t\tif(p[i] < p[k]) i = k;\n\t\tif(!(p[j]<p[k]) ) j = k;\n\t}\n\tdouble res = 0;\n\tint si = i,sj = j;\n\twhile( i != sj || j != si ){\n\t\tres = max(res,abs(p[i]-p[j]) );\n\t\tif(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j] ) < 0.0) i = (i+1)%n;\n\t\telse j = (j+1)%n;\n\t}\n\treturn res;\n}\nbool isconvex(polygon p){\n\tbool f = 1;\n\tint n = p.size();\n\tfor(int i=0;i<n;i++){\n\t\tint t = ccw(p[(i+n-1)%n],p[i],p[(i+1)%n] );\n\t\tf&= t!=CCW_CLOCKWISE;\n\t}\n\treturn f;\n}\ndouble area(polygon p){\n\tdouble res =  0.0;\n\tfor(int i=0;i<p.size();i++) res += cross(p[i],p[ (i+1)%p.size() ]);\n\treturn res/2.0;\n}\ndouble area(circle c1,circle c2){\n\tdouble d = abs(c1.c-c2.c);\n\tif(c1.r + c2.r <= d + EPS ) return 0.0;\n\tif(d<=abs(c1.r-c2.r) ){\n\t\tdouble r = min(c1.r,c2.r);\n\t\treturn PI*r*r;\n\t}\n\tdouble rc = (d*d + c1.r*c1.r -c2.r*c2.r)/(2*d);\n\tdouble th = acos(rc/c1.r);\n\tdouble ph = acos( (d-rc)/c2.r);\n\treturn c1.r*c1.r*th + c2.r*c2.r*ph - d * c1.r * sin(th) ;\n}\n\npolygon convex_cut(polygon p,line l){\n\tpolygon q;\n\tint n = p.size();\n\tfor(int i=0;i<n;i++){\n\t\tpoint a = p[i] , b = p[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a) != -1 ) q.push_back(a);\n\t\tif(ccw(l.s,l.t,a) * ccw(l.s,l.t,b) < 0) q.push_back(crosspointss(line(a,b),l) );\n\t}\n\treturn q;\n}\n//[s,t) 再帰 devide and conquer\ndouble inf  = 1e10;\ndouble closest_pair_dac(polygon &p,int s,int t,double &res){\n\tif(t-s<=1)return inf;\n\tif(t-s==2){\n\t\tsort(p.begin()+s,p.begin()+t,sort_y);\n\t\treturn (p[s]-p[s+1]).abs();\n\t}\n\tint mid = (s+t)/2;\n\tdouble x = p[mid].x;\n\tres = min(closest_pair_dac(p,s,mid,res),closest_pair_dac(p,mid,t,res) );\n\tauto it = p.begin();\n\tauto its = it+s,itm = it+mid,itt = it + t;\n\tinplace_merge(its,itm,itt,sort_y);\n\tvector<point> tmp;\n\tfor(int i=s;i<t;i++){\n\t\tif(abs(p[i].x-x) >= res) continue;\n\t\tfor(int j=tmp.size()-1;j>=0;j--){\n\t\t\tpoint d = p[i]-tmp[j];\n\t\t\tif(d.y >= res) break;\n\t\t\tres = min( res , d.abs() );\n\t\t}\n\t\ttmp.push_back(p[i]);\n\t}\n\treturn res;\n}\ndouble closest_pair(polygon &p){\n\tdouble res = inf;\n\tsort(p.begin(),p.end());\n\treturn  closest_pair_dac(p,0,p.size(),res);\n}\n\nint main(){\n    \tint n;\n\tcin>>n;\n    \tpolygon p(n);\n\tfor(int i=0;i<n;i++) p[i].input();\n\tprintf(\"%0.10lf\\n\",closest_pair(p) );\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool cmp_y(const P &a, const P &b){\n\t\treturn a.imag() != b.imag() ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\t\t\t\t\t\t\t\t  // a--c--b on line\n}\n\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n// polygon\ntypedef vector<P> G;\n\nP extreme(const vector<P> &po, const L &l) {\n  int k = 0;\n  for (int i = 1; i < po.size(); ++i)\n    if (dot(po[i], l[1]-l[0]) > dot(po[k], l[1]-l[0])) k = i;\n  return po[k];\n}\n\nenum { OUT, ON, IN };\nint contains(const G& po, const P& p) {\n  bool in = false;\n  for (int i = 0; i < po.size(); ++i) {\n  \tP a = po[i] - p, b = po[(i+1)%po.size()] - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\ndouble area2(const G& po) {\n\tdouble A = 0;\n  \tfor (int i = 0; i < po.size(); ++i) \n    \tA += cross(po[i], po[(i+1)%po.size()]);\n\t//????????????????????????????????¨????????????\n  \treturn A/2;\n}\n\nbool isconvex(const G &p) {\n\tint n = p.size();\n\tif(cross(p[0]-p[n-1],p[n-2]-p[n-1]) < 0) return false;\n\tfor(int i = 1; i < n-1; ++i) {\n\t\tif(cross(p[i+1]-p[i],p[i-1]-p[i]) < 0) return false;\n\t}\n\treturn true;\n\n}\n\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end(), cmp_y);\n  G r(2*n);\n  for(int i = 0; i < n; i++){\n    while(k>1 && cross(r[k-1]-r[k-2],ps[i]-r[k-2]) < -EPS)k--;\n    r[k++] = ps[i];\n  }\n  for(int i = n-2, t = k; i >= 0; i--){\n    while(k>t && cross(r[k-1]-r[k-2],ps[i]-r[k-2]) < -EPS)k--;\n    r[k++] = ps[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\n// caliper\ndouble convex_diameter(const G &pt) {\n\tconst int n = pt.size();\n\tif(n <= 1) return 0;\n\tif(n == 2) return abs(pt[0]-pt[1]);\n\t\n\tint i = 0, j = 0;\n\tfor(int k = 0; k < n; ++k){\n\t\tif(!(pt[i] < pt[k])) i = k;\n\t\tif(pt[j] < pt[k]) j = k;\n\t}\n   \n\tdouble res = 0;\n\tint si = i, sj = j;\n\twhile(i != sj || j != si) {\n\t\tres = max(res, abs(pt[i]-pt[j]));\n\t\tif(cross(pt[(i+1)%n]-pt[i],pt[(j+1)%n]-pt[j]) < 0) i = (i+1)%n;\n\t\telse j = (j+1)%n;\n\t}\n\treturn res;\n}\n\n// po???l??§?????????????????´???????????????\nG convex_cut(const G& po, const L& l) {\n  G Q;\n  for (int i = 0; i < po.size(); ++i) {\n  \tP A = po[i], B = po[(i+1)%po.size()];\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n  \tif (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0) {\n  \t\tQ.push_back(crosspoint(L(A, B), l));\n  \t}\n  }\n  return Q;\n}\n\n//O(nlogn) ??????1??????????????§????????´???O(n^2)?????????????????±??????????????¨\npair<P,P> closestPair(G p) {\n\tint n = p.size(), s = 0, t = 1, m = 2, S[n]; S[0] = 0, S[1] = 1;\n\tsort(p.begin(), p.end()); // \"p < q\" <=> \"p.x < q.x\"\n\tdouble d = norm(p[s]-p[t]);\n\tfor (int i = 2; i < n; S[m++] = i++) {\n\t\tfor(int j=0; j<m; ++j) {\n    \t\tif (norm(p[S[j]]-p[i])<d) d = norm(p[s = S[j]]-p[t = i]);\n    \t\tif (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n\t\t}\n\t}\n  \treturn make_pair( p[s], p[t] );\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tG po;\n\tfor(int i=0; i<n; ++i) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tP p(x, y);\n\t\tpo.push_back(p);\n\t}\n\tpair<P, P> ans = closestPair(po);\n\tcout << fixed << setprecision(15) << sqrt(norm(ans.first-ans.second)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / acos(-1));\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * acos(-1) / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  // cerr << \"begin [\" << l << \", \" << r << \")\" << endl;\n  if (r - l <= 3) {\n    // cerr << \"[\" << l << \", \" << r << \")\" << endl;\n    PointPoint res(ps[l], ps[r - 1]);\n    // cerr << \"res : \" << res.first << \", \" << res.second << endl;\n    for (int i = l; i < r; ++i) {\n      for (int j = i + 1; j < r; ++j) {\n        // cerr << i << \", \" << j << endl;\n        res = Closer(res, PointPoint(ps[i], ps[j]));\n        // cerr << \"res : \" << res.first << \" \" << res.second << endl;\n      }\n    }\n    // cerr << \"[\" << l << \", \" << r << \") = \" << Distance(res.first, res.second) << endl;\n    return res;\n  }\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  Points strip;\n  for (int i = l; i < r; ++i) {\n    // if (l == 43 && r == 50 && abs(ps[i].real() - midPoint.real()) < d) {\n    //   cerr << i << \" \";\n    // }\n    if (abs(ps[i].real() - midPoint.real()) < d) strip.push_back(ps[i]);\n  }\n  // if (l == 43 && r == 50) cerr << endl;\n\n  for (int i = 0; i < strip.size(); ++i) {\n    for (int j = i + 1; j < strip.size(); ++j) {\n      if (Distance(strip[i], strip[j]) < d) {\n        d = Distance(strip[i], strip[j]);\n        res = PointPoint(strip[i], strip[j]);\n      }\n    }\n  }\n\n  // cerr << \"[\" << l << \", \" << r << \") = \" << Distance(res.first, res.second) << endl;\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  return ClosestPairUtil(ps, 0, ps.size());\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  sort(p.begin(), p.end());\n  PointPoint pp = ClosestPair(p);\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n  // cerr << pp.first << \" \" << pp.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(ll i = 0; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\nconst ll mod = TEN(9) + 7;\n\ntemplate<class T>\ndouble closest_pair(vector<pair<T, T>> a, double inf = 1e15) {\n\tusing P = pair<T, T>;\n\tusing Iterator = typename vector<P>::iterator;\n\tfunction<double(Iterator, ll)> recur = [&](Iterator it, ll len) {\n\t\tif (len <= 1) return inf;\n\t\tll half = len / 2;\n\t\tT x = (it + half)->first;\n\t\tdouble min_d = min(recur(it, half), recur(it + half, len - half));\n\t\tinplace_merge(\n\t\t\tit, it + half, it + len,\n\t\t\t[](P lhs, P rhs) { return lhs.second < rhs.second; }\n\t\t);\n\n\t\tvector<P> b;\n\t\tREP(i, len) if (abs<double>(a[i].first - x) < min_d) {\n\t\t\tREP(j, b.size()) {\n\t\t\t\tdouble dx = a[i].first - b[b.size() - j - 1].first;\n\t\t\t\tdouble dy = a[i].second - b[b.size() - j - 1].second;\n\t\t\t\tif (dy >= min_d) break;\n\t\t\t\tmin_d = min(min_d, sqrt(dx*dx + dy*dy));\n\t\t\t}\n\t\t\tb.push_back(a[i]);\n\t\t}\n\n\t\treturn min_d;\n\t};\n\tsort(a.begin(), a.end());\n\treturn recur(a.begin(), a.size());\n}\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\n\tll n; cin >> n;\n\tvector<pair<double, double>> a(n);\n\tREP(i, n) cin >> a[i].first >> a[i].second;\n\tcout << closest_pair(a) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\n#define im() imag()\n#define re() real()\n\ntypedef complex<double> P;\ntypedef vector<P> Poly;\n\nbool comp_x(const P &a, const P &b) {\n    return a.re() < b.re();\n}\n\nbool comp_y(const P &a, const P &b) {\n    return a.im() < b.im();\n}\n\ndouble close_pair(vector<P> &a, int l, int r) {\n    if (r - l <= 1) return 1e20;\n    int mid = (l + r) / 2;\n    double X = a[mid].re();\n    double d = min(close_pair(a, l, mid), close_pair(a, mid, r));\n    inplace_merge(a.begin() + l, a.begin() + mid, a.begin() + r, comp_y);\n\n    vector<P> b;\n    for (int i = l; i < r; i++) {\n        if (abs(a[i].re() - X) >= d) continue;\n        for (int j = b.size() - 1; j >= 0; j--) {\n            if ((a[i] - b[j]).im() >= d) break;\n            d = min(d, abs(a[i] - b[j]));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main() {\n\n    int N;\n    cin >> N;\n\n    Poly p(N);\n\n    for (int i = 0; i < N; i++) {\n        double x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n    sort(p.begin(), p.end(), comp_x);\n    double ans = close_pair(p, 0, N);\n    cout << fixed << setprecision(20) << ans << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#define MAX_INPUT 100000\n#define VERY_LARGE 987654321.0\n#define ABS(x) x<0?-x:x\n#define MIN(a, b) a<b?a:b\ntypedef struct point{\n    double x, y;\n    bool operator<(const struct point &X) const{\n        if (x != X.x) return x < X.x;\n        return y < X.y;\n    };\n    bool operator<<(const struct point &X) const{\n        if (y != X.y) return y < X.y;\n        return x < X.x;\n    };\n} Point;\nPoint PX[MAX_INPUT], PY[MAX_INPUT], T[MAX_INPUT], SYL[MAX_INPUT], SYR[MAX_INPUT];\nint N;\nvoid input(void);\nvoid msortx(int s, int e, Point P[]);\nvoid msorty(int s, int e, Point P[]);\ndouble dist(Point a, Point b){return ABS((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));};\ndouble CP(int s, int e);\nvoid combine(int m, int delta, Point C);\nvoid findPointsInStrip(int m, int delta, Point SYL[], Point SYR[], int *l, int *r);\nint main(void){\n    //freopen(\"in.txt\", \"r\", stdin);\n    input();\n    msortx(0, N - 1, PX);\n    msorty(0, N - 1, PY);\n    printf(\"%f\\n\", sqrt(CP(0, N - 1)));\n    return 0;\n}\nvoid findPointsInStrip(int m, int delta, Point SYL[], Point SYR[], int *l, int *r){\n    *l = 0, *r = 0;\n    for(int i = 0; i < N; i++){\n       if (PY[i].x <= PX[m].x && PY[i].x >= PX[m].x - delta)\n           SYL[(*l)++] = PY[i];\n       else if (PY[i].x > PX[m].x && PY[i].x <= PX[m].x + delta)\n           SYR[(*r)++] = PY[i];\n    }\n}\ndouble CP(int s, int e){\n    if (s >= e) return VERY_LARGE;\n    if (s + 1 == e) return dist(PX[s], PX[e]);\n    int m = s + (e - s) / 2;\n    double d1, d2, delta, deltaPrime = VERY_LARGE;\n    d1 = CP(s, m); d2 = CP(m + 1, e);\n    delta = MIN(d1, d2);\n    int l, r;\n    findPointsInStrip(m, delta, SYL, SYR, &l, &r);\n    int i, j;\n    for(i = 0; i < l; i++){\n        for(j = 0; j < r; j++){\n            if (ABS(SYL[i].y - SYR[j].y) >= delta) break;\n            double cnd = dist(SYL[i], SYR[i]);\n            if(cnd < deltaPrime) deltaPrime = cnd;\n        }\n    }\n    return MIN(delta, deltaPrime);\n}\nvoid msortx(int s, int e, Point P[]){\n    if(s >= e) return;\n    int m = s + (e - s) /2;\n    msortx(s, m, P);\n    msortx(m + 1 , e, P);\n    int i = s, j = m + 1, k = s;\n    while (i <= m || j <= e){\n        if (j > e || (i <= m && P[i] < P[j]))\n            T[k++] = P[i++];\n        else\n            T[k++] = P[j++];\n    }\n    for(i = s; i <= e; i++) P[i] = T[i];\n}\nvoid msorty(int s, int e, Point P[]){\n    if(s >= e) return;\n    int m = s + (e - s) /2;\n    msorty(s, m, P);\n    msorty(m + 1 , e, P);\n    int i = s, j = m + 1, k = s;\n    while (i <= m || j <= e){\n        if (j > e || (i <= m && P[i] << P[j]))\n            T[k++] = P[i++];\n        else\n            T[k++] = P[j++];\n    }\n    for(i = s; i <= e; i++) P[i] = T[i];\n}\nvoid input(void){\n    scanf(\"%d\", &N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%lf%lf\", &PX[i].x, &PX[i].y);\n        PY[i] = PX[i];\n    };\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nusing real = double;\nreal EPS = 1e-10;\nstruct Point {\n    real x, y;\n    Point& operator+=(const Point a) { x += a.x; y += a.y;  return *this; }\n    Point& operator-=(const Point a) { x -= a.x; y -= a.y;  return *this; }\n    Point& operator*=(const real k) { x *= k; y *= k;  return *this; }\n    Point& operator/=(const real k) { x /= k; y /= k;  return *this; }\n    Point operator+(const Point a) const {return Point(*this) += a; }\n    Point operator-(const Point a) const {return Point(*this) -= a; }\n    Point operator*(const real k) const {return Point(*this) *= k; }\n    Point operator/(const real k) const {return Point(*this) /= k; }\n    bool operator<(const Point &a) const { return (x != a.x ? x < a.x : y < a.y); }\n    explicit Point(real a = 0, real b = 0) : x(a), y(b) {};\n};\n\nbool sorty(Point a, Point b){\n    return (a.y != b.y ? a.y < b.y : a.x < b.x);\n}\n\nistream& operator>> (istream& s, Point& P){\n    s >> P.x >> P.y;\n    return s;\n}\n\ninline real dot(Point a, Point b){ return a.x*b.x + a.y*b.y; }\ninline real cross(Point a, Point b){ return a.x*b.y - a.y*b.x; }\ninline real abs(Point a){ return sqrt(dot(a, a)); }\n\nstatic constexpr int COUNTER_CLOCKWISE = 1;\nstatic constexpr int CLOCKWISE = -1;\nstatic constexpr int ONLINE_BACK = 2;\nstatic constexpr int ONLINE_FRONT = -2;\nstatic constexpr int ON_SEGMENT = 0;\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(b, c) < -EPS) return CLOCKWISE;\n    if(dot(b, c) < 0) return ONLINE_BACK;\n    if(abs(b) < abs(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nstruct Segment {\n    Point a, b;\n    Segment(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Line {\n    Point a, b;\n    Line(Point x, Point y) : a(x), b(y) {};\n};\n\nbool intersect(Segment s, Segment t){\n    return (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n            ccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\ndouble distance(Segment s, Point c){\n    if(dot(s.b-s.a, c-s.a) < EPS) return abs(c-s.a);\n    if(dot(s.a-s.b, c-s.b) < EPS) return abs(c-s.b);\n    return abs(cross(s.b-s.a, c-s.a)) / abs(s.a-s.b);\n}\n\ndouble distance(Segment s, Segment t){\n    if(intersect(s, t)) return 0.0;\n    return min({distance(s, t.a), distance(s, t.b),\n                distance(t, s.a), distance(t, s.b)});\n}\n\n\n\nPoint crossPoint(Segment s, Segment t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPoint crossPoint(Line s, Line t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\n\nPoint project(Segment s, Point p){\n    Point Q = s.b-s.a;\n    return s.a + Q*(dot(p-s.a, Q) / dot(Q, Q));\n}\n\nPoint refrect(Segment s, Point p){\n    Point Q = project(s, p);\n    return Q*2-p;\n}\n\nbool isOrthogonal(Segment s, Segment t){\n    return fabs(dot(s.b-s.a, t.b-t.a)) < EPS;\n}\n\nbool isparallel(Segment s, Segment t){\n    return fabs(cross(s.b-s.a, t.b-t.a)) < EPS;\n}\n\nusing Polygon = vector<Point>;\n\nreal area(Polygon v){\n    if(v.size() < 3) return 0.0;\n    real ans = 0.0;\n    for (int i = 0; i < v.size(); ++i) {\n        ans += cross(v[i], v[(i+1)%v.size()]);\n    }\n    return ans/2;\n}\n\nPolygon convex_hull(Polygon v){\n    int n = v.size();\n    sort(v.begin(),v.end(), sorty);\n    int k = 0;\n    Polygon ret(n*2);\n    for (int i = 0; i < n; ++i) {\n        while(k > 1 && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    for(int i = n-2, t=k; i >= 0; i--){\n        while(k > t && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    ret.resize(k-1);\n    return ret;\n}\n\nbool isconvex(Polygon v){\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n        if(ccw(v[(i+n-1)%n], v[i], v[(i+1)%n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n// in = 2, on = 1, out = 0;\nint contains(Polygon v, Point p){\n    int n = v.size();\n    bool x = false;\n    for (int i = 0; i < n; ++i) {\n        Point a = v[i]-p, b = v[(i+1)%n]-p;\n        if(fabs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n        if(a.y > b.y) swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return (x?2:0);\n}\n\ndouble diameter(Polygon v){\n    int n = v.size();\n    if(n == 2) return abs(v[0]-v[1]);\n    int i = 0, j = 0;\n    for (int k = 0; k < n; ++k) {\n        if(v[i] < v[k]) i = k;\n        if(!(v[j] < v[k])) j = k;\n    }\n    double ret = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si){\n        ret = max(ret, abs(v[i]-v[j]));\n        if(cross(v[(i+1)%n]-v[i], v[(j+1)%n]-v[j]) < 0.0) i = (i+1)%n;\n        else j = (j+1)%n;\n    }\n    return ret;\n}\n\nPolygon convexCut(Polygon v, Line l){\n    Polygon q;\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n        Point a = v[i], b = v[(i+1)%n];\n        if(ccw(l.a, l.b, a) != -1) q.push_back(a);\n        if(ccw(l.a, l.b, a)*ccw(l.a, l.b, b) < 0){\n            q.push_back(crossPoint(Line(a, b), l));\n        }\n    }\n    return q;\n}\n\nreal closest_pair(Polygon &v, int l = 0, int r = -1){\n    if(!(~r)){\n        r = v.size();\n        sort(v.begin(),v.end());\n    }\n    if(r - l < 2) {\n        return abs(v.front()-v.back());\n    }\n    int mid = (l+r)/2;\n    double p = v[mid].x;\n    double d = min(closest_pair(v, l, mid), closest_pair(v, mid, r));\n    inplace_merge(v.begin()+l, v.begin()+mid, v.begin()+r, sorty);\n    Polygon u;\n    for (int i = l; i < r; ++i) {\n        if(fabs(v[i].x-p) >= d) continue;\n        for (int j = 0; j < u.size(); ++j) {\n            double dy = v[i].y-next(u.rbegin(), j)->y;\n            if(dy >= d) break;\n            d = min(d, abs(v[i]-*next(u.rbegin(), j)));\n        }\n        u.emplace_back(v[i]);\n    }\n    return d;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    Polygon v(n);\n    for(auto &&i : v) cin >> i;\n    printf(\"%.15f\", closest_pair(v));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<utility>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n\ntypedef pair<double, double> point;\ntypedef vector<point> data;\n\ninline double dist(const point &a, const point &b)\n{\n\treturn sqrt((a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second));\n}\n\nint main()\n{\n\tint i, n;\n\tdouble x, y;\n\tscanf(\"%d\", &n);\n\tdata P(n);\n\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tP[i] = make_pair(x, y);\n\t}\n\tsort(P.begin(), P.end());\n\n\tdouble d = dist(P[0], P[1]);\n\tfor(i = 2; i < n; i++){\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tif(P[i].first - P[j].first > d) continue;\n\t\t\td = min(d, dist(P[i], P[j]));\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\", d);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\nstruct point2d{\n  double x, y;\n  point2d(){}\n  point2d(double x, double y): x(x), y(y){}\n  point2d operator+(const point2d &r) const{\n    return point2d(x + r.x, y + r.y);\n  }\n  point2d operator-(const point2d &r) const{\n    return point2d(x - r.x, y - r.y);\n  }\n  point2d& operator+=(const point2d &r){\n    *this = *this + r;\n    return *this;\n  }\n  point2d& operator-=(const point2d &r){\n    *this = *this - r;\n    return *this;\n  }\n  bool operator==(const point2d &r) const{\n    return abs(x - r.x) < EPS && abs(y - r.y) < EPS;\n  }\n  bool operator!=(const point2d &r) const{\n    return !(*this == r);\n  }\n  bool operator<(const point2d &r) const{\n    if(abs(x - r.x) >= EPS)return x < r.x;\n    return y < r.y;\n  }\n};\n\npoint2d operator*(double x, const point2d &p){\n  return point2d(x * p.x, x * p.y);\n}\n\npoint2d operator/(const point2d &p, double x){\n  return point2d(p.x / x, p.y / x);\n}\n\ndouble norm(const point2d &a){\n  return sqrt(a.x * a.x + a.y * a.y);\n}\n\ndouble dis(const point2d &a, const point2d &b){\n  point2d c = a - b;\n  return norm(c);\n}\n\ndouble inner_product(const point2d &a, const point2d &b){\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble outer_product(const point2d &a, const point2d &b){\n  return a.x * b.y - a.y * b.x;\n}\n\ndouble cosine(const point2d &a, const point2d &b){\n  return inner_product(a, b) / norm(a) / norm(b);\n}\n\ndouble closest_pair(vector<point2d> &a, int l, int r){\n  double d = numeric_limits<double>::max();\n  if(r - l == 1)return d;\n\n  int m = (l + r) / 2;\n  double x = a[m].x;\n  d = min(closest_pair(a, l, m), closest_pair(a, m, r));\n  inplace_merge(a.begin() + l, a.begin() + m, a.begin() + r, [](const point2d &u, const point2d &v){\n      return u.y < v.y;\n      });\n\n  vector<point2d> v;\n  for(int i = l; i < r; i++){\n    if(abs(x - a[i].x) >= d)continue;\n    for(int j = 0; j < v.size(); j++){\n      double dx = a[i].x - v[v.size()-j-1].x;\n      double dy = a[i].y - v[v.size()-j-1].y;\n      if(dy >= d)break;\n      d = min(d, sqrt(dx * dx + dy * dy));\n    }\n    v.push_back(a[i]);\n  }\n  return d;\n}\n\ndouble closest_pair(vector<point2d> &a){\n  sort(a.begin(), a.end(), [](const point2d &u, const point2d &v){\n      if(u.x != v.x)return u.x < v.x;\n      return u.y < v.y;\n      });\n  return closest_pair(a, 0, int(a.size()));\n}\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  INT(n);\n  vector<point2d> v(n);\n  rep(i, n)cin >> v[i].x >> v[i].y;\n  cout << setprecision(20);\n  cout << closest_pair(v) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    const int loops = 50;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + j].first - p2[i].first) * (p2[i + j].first - p2[i].first) + (p2[i + j].second - p2[i].second) * (p2[i + j].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-4;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf dist ( pt A, pt B ) { return norm( B - A ); }\n\nint n;\nlf d;\npt P[ MAXN ], extra[ MAXN ];\n\nbool cmpX( const pt &A, const pt &B ) {\n  //if( same( A.x, B.x ) ) return A.y+EPS < B.y;\n  //return A.x+EPS < B.x;\n  return A.x < B.x;\n}\n\nlf sqr( lf x ) {\n  return x*x;\n}\n\nvoid merge( int f, int m, int t ){\n\tint total = t - f + 1;\n\tfor( int i = 0, l = f, r = m+1; i < total; ++i ){\n\t\tif( l == m+1 ){\n      extra[ i ] = P[ r++ ];\n\t\t}\n\t\telse if( r == t+1 ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse if( P[l].y < P[r].y ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse{\n\t\t  extra[ i ] = P[ r++ ];\n\t\t}\n\t}\n\tfor( int i = 0; i < total; ++i ){\n    P[ f+i ] = extra[ i ];\n\t}\n}\n\nvoid solve( int f, int t ) {\n  if( f == t ) return;\n\tint mi = (f + t)/2;\n\tsolve( f, mi );\n\tsolve( mi+1, t );\n\tmerge( f, mi, t );\n\tvector< int > idxs;\n\tfor( int i = f; i <= t; ++i ){\n\t\tif( sqr(P[mi].x - P[i].x ) < d+EPS ) idxs.push_back( i );\n\t}\n\tfor( int i = 0; i < idxs.size(); ++i ){\n\t\tfor( int j = i+1; j < idxs.size() && sqr(P[ idxs[i] ].y - P[ idxs[j] ].y) < d+EPS ; ++j ){\n\t\t\td = min( d, dist( P[ idxs[i] ], P[ idxs[j] ] ) );\n\t\t}\n\t}\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  sort( P, P+n, cmpX );\n  /*d = oo;\n  for( int i = 0; i < n; ++i ) {\n    for( int j = i+1; j < n; ++j ) {\n      d = min( d, dist(P[i],P[j]) );\n    }\n  }\n  cout << double(sqrt(d)) << '\\n';*/\n  d = oo;\n  solve( 0, n-1 );\n  cout << double(sqrt(d)) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n   \ntypedef pair<double,double> P;\ntypedef pair<P,double> P2;\n   \nP rot(P p, double a){\n  a=a*M_PI/180.0;\n  return P(p.first*cos(a)+p.second*(-sin(a)),\n  p.first*sin(a)+p.second*cos(a));\n}\n   \ndouble abss(P a,P b){\n  return (a.first-b.first)+(a.second-b.second);\n}\n   \ndouble x,y,r;int tt;\nvector<P>v;\nint main(){\n   \n  int n;\n  cin>>n;\n   \n    double ans=1e13;\n       \n    v.clear();\n     \n    r(i,n){\n      cin>>x>>y;\n      v.push_back(P(x,y));\n    }\n   \n    r(i,1){\n      sort(v.begin(),v.end());\n      r(j,n){\n        for(int k=j+1,c=0;k<n;k++,c++){\n          if(c>50)break;\n          ans=min(ans,abss(v[k],v[j]));\n        }\n      }\n      r(j,n)v[i]=rot(v[i],0.5);\n    }\n   \n    printf(\"%.11f\\n\",ans);\n       \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n\nusing ld = long double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ntemplate<class iter>\ntuple<ld, P, P> closest_pair(iter left, iter right) {\n    int n = distance(left, right);\n    if(n <= 1) return make_tuple(numeric_limits<ld>::max(), *left, *left);\n    iter middle = next(left, n/2);\n    ld x = middle->real();\n    auto d = min(closest_pair(left, middle), closest_pair(middle, right));\n    inplace_merge(left, middle, right, [](const P &a, const P &b){\n            return a.imag() < b.imag();\n        });\n    vector<iter> around;\n    for(iter i = left; i != right; ++i){\n        ld dx = fabs(i->real() - x);\n        ld &opt = get<0>(d);\n        if(dx*dx >= opt) continue;\n        for(auto j = around.rbegin(); j != around.rend(); ++j){\n            ld dx = i->real() - (**j).real();\n            ld dy = i->imag() - (**j).imag();\n            if(dy*dy >= opt) break;\n            ld norm = dx*dx + dy*dy;\n            if(get<0>(d) > norm){\n                d = make_tuple(norm, *i, **j);\n            }\n        }\n        around.push_back(i);\n    }\n    return d;\n};\n\n// http://www.spoj.com/problems/CLOPPAIR/\n// 18124516\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout << fixed << setprecision(6) << endl;\n    int n;\n    while(cin >> n){\n        vector<P> a;\n        map<P,int> idx;\n        rep(i,n){\n            ll x,y;\n            cin >> x >> y;\n            a.emplace_back(x,y);\n            idx[P(x,y)] = i;\n        }\n        ll z;\n        P x, y;\n        sort(all(a));\n        tie(z, x, y) = closest_pair(all(a));\n        int A = idx[x], B = idx[y];\n        if(A > B) swap(A, B);\n        cout << sqrt(z) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define SZ(x) (int)(x).size()\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<LL, LL> pll;\n\nconst double eps = 1e-10;\nconst double PI = acos(-1.0);\n//const double PI = 3.14159265358979323846264338327950288419716939937510\nint dcmp(const double &x) { if (fabs(x) < eps) return 0; return x < 0 ? -1 : 1; }\nconst int MOD = 1e9 + 7;\nconst int INF = 2e9;\nconst double INF_d = 1e64;\n\ntemplate<class T> \nT qmod(T a, T b){ T ret = 1; while (b){ if (b & 1) ret *= a; b >>= 1; a *= a; } return ret; }\ntemplate<class T>\nT gcd(T a, T b){ return !b ? a : gcd(b, a % b); }\ntemplate<class T>\nT ex_gcd(T a, T b, T &x, T &y){\n    if (!b){ x = 1, y = 0; return a; }\n    T t, ret;\n    ret = ex_gcd(b, a % b, x, y);\n    t = x, x = y, y = t - a / b * y;\n    return ret;\n}\ntemplate<class T>\nT inv(T t, T p){ return t == 1 ? 1 : (p - p / t) * inv(p % t, p) % p; }\n// head\n\ntypedef double db;\n\nstruct point{\n    db x, y;\n    point(){}\n    point(db a, db b): x(a), y(b){}\n    point operator + (const point &p){ return point(x + p.x, y + p.y); }\n    point operator - (const point &p){ return point(x - p.x, y - p.y); }\n    point operator * (const db &k){ return point(x * k, y * k); }\n    point operator / (const db &k){ return point(x / k, y / k); }\n    db operator ^ (const point &p){ return x * p.y - y * p.x; }\n    db operator * (const point &p){ return x * p.x + y * p.y; }\n    bool operator == (const point &p){ return !dcmp(x - p.x) && !dcmp(y - p.y); }\n    bool operator != (const point &p){ return dcmp(x - p.x) || dcmp(y - p.y); }\n    bool operator < (const point &p){ return x == p.x ? y < p.y : x < p.x; }\n    void read(){\n        scanf(\"%lf%lf\", &x, &y);\n    }\n    void print(){\n        printf(\"%.10f %.10f\\n\", x, y);\n    }\n    point rotate(db &ang){ return point(x * cos(ang) - y * sin(ang), y * cos(ang) + x * sin(ang)); }\n    point norm() { return point(-y, x); }\n    db len() { return sqrt(x * x + y * y); }\n    db len2(){ return x * x + y * y; }\n};\n\npoint err = point(INF_d, INF_d);\n\npoint proj_SP(point A, point B, point P){ // projection point of P in segment AB\n    point AB = B - A, AP = P - A;\n    return A + AB * (AP * AB / AB.len2());\n}\n\npoint refl_SP(point A, point B, point P){ // reflection point of P int segment AB\n    return proj_SP(A, B, P) * 2 - P;\n}\n\nstruct line{\n    point p[2], u;\n    line(){}\n    line(point s, point t){\n        p[0] = s, p[1] = t;\n        u = p[1] - p[0];\n    }\n    point get_point(double t){\n        return point(p[0] + u * t);\n    }\n};\n\nbool parallel(line L1, line L2){ // check whether two lines L1 and L2 are parallel\n    return !dcmp(L1.u ^ L2.u);\n}\n\nbool orthogonal(line L1, line L2){ // check whether two lines L1 and L2 are orthogonal\n    return !dcmp(L1.u * L2.u);\n}\n\npair<bool, point> inter_LL(line L1, line L2){ // calculate the intersection of two lines L1 and L2\n    if (parallel(L1, L2)) return mp(false, err);\n    double t = ((L2.p[0] - L1.p[0]) ^ L2.u) / (L1.u ^ L2.u);\n    return mp(true, L1.get_point(t));\n}\n\nbool one_dimention_check(db a, db b, db c, db d){ // check whether two one-dimention segments has intersection\n    if (dcmp(a - b) > 0) swap(a, b);\n    if (dcmp(c - d) > 0) swap(c, d);\n    return dcmp(b - c) >= 0 && dcmp(a - d) <= 0; \n}\n\nbool check_SS(point A, point B, point C, point D){ // check whether two segments AB and CD has intersection\n    bool flag = one_dimention_check(A.x, B.x, C.x, D.x) && one_dimention_check(A.y, B.y, C.y, D.y);\n    double a = dcmp((A - C) ^ (D - C)), b = dcmp((B - C) ^ (D - C)),\n            c = dcmp((C - A) ^ (B - A)), d = dcmp((D - A) ^ (B - A));\n    return flag && dcmp(a * b) <= 0 && dcmp(c * d) <= 0;\n}\n// calculate the intersection point of two segments, first check and then call inter_LL to get the cross point\n\nbool inmid(db a, db b, db c){  // check whether a <= c <= b\n    return dcmp(dcmp(b - c) * dcmp(a - c)) <= 0; \n}\n\nbool inmid(point A, point B, point P){ // check whether point P is in the rectangle of segment AB\n    return inmid(A.x, B.x, P.x) && inmid(A.y, B.y, P.y);\n}\n\ndb dis_SP(point A, point B, point P){ // the minimum distance from a point P to segment AB\n    point p_proj = proj_SP(A, B, P);\n    if (inmid(A, B, p_proj)) return (P - p_proj).len();\n    else return min((P - A).len(), (P - B).len());\n}\n\ndb dis_SS(point A, point B, point C, point D){ // the minimum distance from two segments AB and CD\n    db res = INF_d;\n    if (check_SS(A, B, C, D)) res = 0;\n    res = min(res, dis_SP(A, B, C));\n    res = min(res, dis_SP(A, B, D));\n    res = min(res, dis_SP(C, D, A));\n    res = min(res, dis_SP(C, D, B));\n    return res;\n}\n\ndb poly_Area(point *poly, int n){ // calc the area of a simple polygon poly, n is the number of points.\n    //the points should be in clockwise or counter_clockwise.\n    db res = 0.0;\n    for (int i = 1; i < n - 1; i++){\n        res += (poly[i] - poly[0]) ^ (poly[i + 1] - poly[0]);\n    }\n    return fabs(res) / 2;\n}\n\nbool is_Convex(point *poly, int n){ // check whether a polygon is a convex polygon. Make sure points are in counter-clockwised order.\n    poly[n] = poly[0];\n    if (n < 3) return 1;\n    for (int i = 1; i < n; i++){\n        int tmp_dir = dcmp((poly[i] - poly[i - 1]) ^ (poly[(i + 1) % n] - poly[i]));\n        if (tmp_dir < 0) return 0;\n    }\n    return 1;\n}\n\nbool is_PonS(point A, point B, point P){ // check whether a point P is on a segment AB\n    return inmid(A, B, P) && !dcmp((P - A) ^ (B - A));\n}\n\nint is_PinPoly(point *poly, int n, point P){ // check the position relation of a point and polygon.\n    // 0: outside, 1: on a segment, 2: inside\n    int pd = 0;\n    for (int i = 0; i < n; i++){\n        point u = poly[i], v = poly[(i + 1) % n];\n        if (is_PonS(u, v, P)) return 1;\n        if (dcmp(u.y - v.y) > 0) swap(u, v);\n        if (dcmp(u.y - P.y) >= 0 || dcmp(v.y - P.y) < 0) continue;\n        if (dcmp((u - v) ^ (P - v)) < 0) pd ^= 1;\n    }\n    return pd << 1;\n}\n\nbool cmpxy(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.x == b.x ? a.y < b.y : a.x < b.x;\n}\n\nbool cmpyx(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.y == b.y ? a.x < b.x : a.y < b.y;\n}\n\nint get_convexhull(point *p, int n, point *ch){ // get the convexhull of given polygon p\n    // pay attention to when m = 0, 1, 2 as the return value\n    sort(p, p + n, cmpyx); // may be changed by the requirement of problem\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        while (m > 1 && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for (int i = n - 2; i >= 0; i--){\n        while (m > k && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    if (n > 1) m--;\n    return m;\n}\n\ndb convexhull_diameter(point *ch, int n){ // calculate the diameter of a give convexhull\n    if (n < 2) return 0;\n    int is, js; is = js = 0;\n    for (int i = 0; i < n; i++){\n        is = ch[i] < ch[is] ? i : is;\n        js = ch[js] < ch[i] ? i : js;\n    }\n    int i = is, j = js;\n    db ret = (ch[is] - ch[js]).len();\n    do{\n        if (dcmp((ch[(i + 1) % n] - ch[i]) ^ (ch[(j + 1) % n] - ch[j])) > 0){\n            j = (j + 1) % n;\n        }\n        else{\n            i = (i + 1) % n;\n        }\n        ret = max(ret, (ch[i] - ch[j]).len());\n    } while (i != is || j != js);\n    return ret;\n}\n\nint convexhull_cut(point *ch, int n, point P, point Q, point *new_ch){\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        int d1 = dcmp((Q - P) ^ (ch[i] - P)), d2 = dcmp((Q - P) ^ (ch[(i + 1) % n] - P));\n        if (d1 >= 0) new_ch[m++] = ch[i];\n        if (d1 * d2 < 0) new_ch[m++] = inter_LL(line(P, Q), line(ch[i], ch[(i + 1) % n])).second;\n    }\n    return m;\n}\n\ndb cloest_pair(point *p, int l, int r){ //\n    if (r - l <= 5){\n        db cloest = INF_d;\n        for (int i = l; i < r; i++){\n            for (int j = i + 1; j < r; j++){\n                cloest = min(cloest, (p[i] - p[j]).len());\n            }\n        }\n        return cloest;\n    }\n    else{\n        int mid = (l + r) >> 1;\n        db cloest = min(cloest_pair(p, l, mid), cloest_pair(p, mid + 1, r));\n        vector<point> v; v.clear();\n        for (int i = l; i < r; i++){\n            if (dcmp(fabs(p[i].x - p[mid].x) - cloest) <= 0) v.pb(p[i]);\n        }\n        sort(v.begin(), v.end(), cmpyx);\n        for (int i = 0; i < SZ(v); i++){\n            for (int j = i + 1; j < SZ(v) && dcmp(v[j].y - v[i].y - cloest) <= 0; j++){\n                cloest = min(cloest, (v[i] - v[j]).len());\n            }\n        }\n        return cloest;\n    }\n}\n\nconst int N = 1e5 + 7;\nint n, m, num;\npoint p[N], x, ch[N], y;\n\nint main(){\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++){\n        p[i].read();\n    }\n    printf(\"%.12f\\n\", cloest_pair(p, 0, n));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define all(a) a.begin(),a.end()\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\nconst double INF = 1e9;\n\nbool compX(const Point a, const Point b) {\n    return (a.X!=b.X ? a.X<b.X : a.Y<b.Y);\n}\n\nbool compY(const Point a, const Point b) {\n    return a.Y<b.Y;\n}\n\ndouble closestPair(VP &a,int l,int r) {\n    if(r-l<=1) return INF;\n    int m = (l+r)/2;\n    double d = min(closestPair(a,l,m),closestPair(a,m,r));\n    inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,compY);\n    \n    VP b;\n    for(int i=l;i<r;i++){\n        if(abs(a[i].X-a[m].X)>=d)continue;\n        for(int j=b.size()-1;j>=0;j--){\n            if((a[i]-b[j]).Y>=d)break;\n            d = min(d,abs(a[i]-b[j]));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main(void){\n    int n;\n    cin>>n;\n    VP ps(n);\n    rep(i,n){\n        double x,y;\n        cin>>x>>y;\n        ps[i] = Point(x,y);\n    }\n    sort(all(ps),compX);\n    printf(\"%.9f\\n\",closestPair(ps,0,n));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define INF (1e50)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\n\ntypedef vector<Point> Polygon;\n\nbool compare_y(const Point &a,const Point &b){\n  return a.y < b.y;\n}\n\ndouble closest_pair(Point *a,int n){\n    if(n <= 1) return INF;\n    int m = n / 2;\n    double x = a[m].x;\n    double d = min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compare_y);\n\n    Polygon b;\n    for(int i = 0 ; i < n ; i++){\n        if(fabs(a[i].x - x) >= d) continue;\n        for(int j = 0 ; j < (int)b.size() ; j++){\n            double dx = a[i].x - b[b.size()-j-1].x;\n            double dy = a[i].y - b[b.size()-j-1].y;\n            if(dy >= d) break;\n            d = min(d,sqrt(dx * dx + dy * dy));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    Point p[N];\n    for(int i = 0 ; i < N ; i++){\n        cin >> p[i].x >> p[i].y;\n    }\n    sort(p,p+N);\n    printf(\"%.12f\\n\",closest_pair(p,N));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef complex<double> V;\ntypedef vector<P> vecP;\ntypedef pair<P,P> L;\ntypedef pair<P,P> S;\ntypedef pair<P,double> C;\nconst double eps=1e-8;\nconst double PI=acos(-1);\nconst double PI2=PI*2.0;\n\nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.imag()==b.imag()?\n            a.real()<b.real():\n            a.imag()<b.imag());\n  }\n};\n\nV normal(V a){\n  assert( abs(a)>0 );\n  return a/abs(a);\n}\n\ndouble Sqrt( double x ){\n  if(x<0)return 0;\n  else return sqrt(x);\n}\n\nP Vector(L a){\n  return a.second-a.first;\n}\n\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\nbool eq(P a,P b){\n  return ( eq(a.real(),b.real()) && eq(a.imag(),b.imag()) );\n}\n\ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble getArg(P a,P b){\n  return arg(b*conj(a));\n}\n\ndouble getTime(V a,V b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b) / abs(a);\n}\n\n\nP project(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*real(c/b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*conj(c/b);\n}\n\nint ccw(P a,P b,P c){\n  P ab=b-a,ac=c-a;\n  P k=ac*conj(ab);\n  if(k.imag()>0)return 1;\n  if(k.imag()<0)return -1;\n  if(k.real()<0)return 2;\n  if(abs(ab)<abs(ac))return -2;\n  return 0;\n}\n\nbool isParallel(P a,P b){\n  return eq(0, cross(a,b));\n}\n\nbool isParallel(S a,S b){\n  return eq(0, cross( Vector(a) , Vector(b) ) );\n}\n\nbool onLP(L l,P p){\n  P a=l.first, b=l.second;\n  return eq(0, cross(b-a,p-a));\n}\n\nbool onSP(S s,P p){\n  P a=s.first, b=s.second;\n  return eq( abs(b-a) , abs(a-p)+abs(b-p) );\n}\n\nbool isCrossSS(S s0,S s1){\n  P a=s0.first, b=s0.second;\n  P c=s1.first, d=s1.second;\n  int f0 = ccw(a,b,c) * ccw(a,b,d);\n  int f1 = ccw(c,d,a) * ccw(c,d,b);\n  return (f0<=0 && f1<=0);\n}\n\nbool isCrossLS(L l,S s){\n  P a=l.first, b=l.second;\n  P c=s.first, d=s.second;\n  return ( ccw(a,b,c) * ccw(a,b,d) <= 0 );\n}\n\ndouble distLP(L l,P p){\n  P a=l.first, b=l.second;\n  double res = cross(b-a,p-a) / abs(b-a);\n  return abs(res);\n}\n\ndouble distSP(S s,P p){\n  P a=s.first, b=s.second;\n  if( dot(b-a,p-a) < eps )return abs(p-a);\n  if( dot(a-b,p-b) < eps )return abs(p-b);\n  return distLP(s,p);\n}\n\ndouble distSS(S s0,S s1){\n  if( isCrossSS(s0,s1) )return 0;\n  double res0 = min( distSP( s0, s1.first ) , distSP(s0, s1.second) );\n  double res1 = min( distSP( s1, s0.first ) , distSP(s1, s0.second) );\n  return min(res0,res1);\n}\n\nP getCrossLL(L l0,L l1){\n  P a=l0.first, b=l0.second;\n  P c=l1.first, d=l1.second;\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\n\n \nint inPolygon(vecP &t,P p){\n  int n=t.size();\n  double sum=0;\n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p)==0 )return 1;\n    sum+= getArg(a-p,b-p);\n  }\n  if( abs(sum) < eps )return 0;\n  else return 2;\n}\n\nvecP andrewScan(vecP &t){\n  int N=t.size(),C=0;\n  vecP R(N);\n  for(int i=0;i<N;i++){\n    while(2<=C&&ccw(R[C-2],R[C-1],t[i])==-1)C--;\n    R[C++]=t[i];\n  }\n  vecP res(C);\n  for(int i=0;i<C;i++)res[i]=R[i];\n  return res;\n}\n \nvecP convexHull(vecP &t){\n  sort(t.begin(),t.end());\n  vecP u=andrewScan(t);\n  reverse(t.begin(),t.end());\n  vecP l=andrewScan(t);\n  for(int i=1;i+1<(int)l.size();i++)u.push_back(l[i]);\n  return u;\n}\n\nvecP cutConvex(vecP &t,L l){\n  P a=l.first, b=l.second;\n  int N=t.size();\n  vecP res;\n  for(int i=0;i<N;i++){\n    P c=t[i],d=t[(i+1)%N];\n    int C=ccw(a,b,c),D=ccw(a,b,d);\n    if(C!=-1)res.push_back(c);\n    if(C==-D&&abs(C)==1)res.push_back(getCrossLL( l ,L(c,d) ));\n  }\n  return res;\n}\n\nP getVector(const vecP &t, int id){\n  int n=t.size();\n  return t[ (id+1)%n ] - t[id%n];\n}\n\ndouble convex_diameter(vecP &t) {\n  int n = t.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(t[i]) > imag(t[is])) is = i;\n    if (imag(t[i]) < imag(t[js])) js = i;\n  }\n  double maxd = norm(t[is]-t[js]);\n \n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    \n    if (cross( getVector(t,i), getVector(t,j)) >= 0) j = (j+1) % n;\n    \n    else i = (i+1) % n;\n    if (norm(t[i]-t[j]) > maxd) {\n      maxd = norm(t[i]-t[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nbool compare_y(const P &a,const P &b){\n  return a.imag() < b.imag();\n}\n\ndouble closest_pair(P *a, int n){\n  if(n <= 1) return 1e30;\n  int m = n / 2;\n  double x = a[m].real();\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if( abs(a[i].real() - x) >= d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dx = real(a[i] - b[b.size() - j - 1]);\n      double dy = imag(a[i] - b[b.size() - j - 1]);\n      if(dy >= d) break;\n      d = min(d, sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nP _pool[200005];\ndouble minDist(vecP &t){\n  int n=t.size();\n  for(int i=0;i<n;i++)_pool[i]=t[i];\n  sort( _pool, _pool+n);\n  return closest_pair(_pool, n);\n}\n\nint getStateCC(C a,C b){\n  double ar=a.second, br=b.second;\n  double dist=abs(a.first-b.first);\n  if(dist>ar+br+eps)return 4;\n  if(dist>ar+br-eps)return 3;\n  if(dist>abs(ar-br)+eps)return 2;\n  if(dist>abs(ar-br)-eps)return 1;\n  return 0;\n}\n\nP getCrossCC(C a,C b){\n  P p1=a.first, p2=a.second;\n  double r1=a.second, r2=b.second;\n  double cA = (r1*r1+norm(p1-p2)-r2*r2) / (2.0*r1*abs(p1-p2));\n  return p1+(p2-p1)/abs(p1-p2)*r1*P(cA,Sqrt(1.0-cA*cA));\n}\n\nS getTangentCP(C a,P p){\n  P base=a.first-p;\n  double ar=a.second;\n  double w=Sqrt(norm(base)-ar*ar);\n  P s=p+base*P(w,ar)/norm(base)*w;\n  P t=p+base*P(w,-ar)/norm(base)*w;\n  return S(s,t);\n}\n\nS getInTangent(C a,C b,double flg=1.0){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  P base=bp-ap;\n  double w=ar+br;\n  double h=Sqrt(norm(base)-w*w);\n  P k=base*P(w,h*flg)/norm(base);\n  return S(ap+k*ar,bp-k*br);\n}\n  \nS getOutTangent(C a,C b,double flg=1.0){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  P base=bp-ap;\n  double h=br-ar;\n  \n  double w=Sqrt(norm(base)-h*h);\n  P k=base*P(w,h*flg)/norm(base)*P(0,flg);\n  return S(ap+k*ar,bp+k*br);\n}\n  \nvector<S> getTangent(C a,C b){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  vector<S> res;\n  double dist=abs(ap-bp);\n    \n  if(dist>ar+br+eps)\n    res.push_back(getInTangent(a,b,1));\n  \n  if(dist>ar+br-eps)\n    res.push_back(getInTangent(a,b,-1));\n  \n  if(dist>abs(ar-br)+eps)\n    res.push_back(getOutTangent(a,b,1));\n  \n  if(dist>abs(ar-br)-eps)\n    res.push_back(getOutTangent(a,b,-1));\n  \n  return res;\n}\n\n\nvecP getCrossCS(C cir,S s, bool debug=false){\n  P a=s.first, b=s.second;\n  double cr=cir.second;\n  P cp=cir.first;\n  \n  vecP res;\n  P base=b-a,  target=project(a,b,cp);\n  \n  double length=abs(base), h=abs(cp-target);\n  base/=length;\n  \n  if(cr+eps<h)return res;\n  double w=Sqrt(cr*cr-h*h);\n  double L=getTime( normal(b-a) ,target-a)-w,  R=L+w*2.0;\n  \n  if( -eps<L && L< length+eps )res.push_back(a+base*L);\n  if( eq(L,R) )return res;\n  if( -eps<R && R< length+eps )res.push_back(a+base*R);\n  return res;\n}\n \ndouble getArea(C c,P a,P b){\n  P cp=c.first;\n  double cr=c.second;\n  \n  P va=cp-a,  vb=cp-b;\n  double A=abs(va), B=abs(vb);\n  double f=cross(va,vb), d=distSP( S(a,b) ,cp), res=0;\n  \n  if( eq(0, f ) )return 0;\n  if(A<cr+eps&&B<cr+eps)return f*0.5;\n  if(d>cr-eps)return cr*cr*PI*getArg(va,vb)/PI2;\n   \n  vecP u=getCrossCS(c, S(a,b) );\n  \n  assert( !u.empty() );\n  u.insert(u.begin(), a),  u.push_back(b);\n \n  for(int i=0;i+1<(int)u.size();i++) res+=getArea(c,u[i],u[i+1]);\n  return res;\n}\n \ndouble getCrossArea(vecP t,C c){\n  int n=t.size();\n  if(n<3)return 0;\n  double res=0;\n  for(int i=0;i<n;i++){\n    P a=t[i], b=t[(i+1)%n];\n    res+=getArea(c,a,b);\n  }\n  return res;\n}\n\n\ndouble calcArea(const vecP &t){\n  double res=0;\n  int n=t.size();\n  for(int i=0;i<n;i++){\n    res+= cross( t[ (i+1)%n ],t[i] );\n  }\n  return abs(res)*0.5;\n}\n\nP input(){\n  double x,y;\n  cin>>x>>y;\n  return P(x,y);\n}\n\nvoid pr(P p,string str){\n  printf(\"%.10f %.10f\",p.real(),p.imag());\n  cout<<str;\n}\n\n\nint main(){\n  int Tc;\n  cin>>Tc;\n  vecP t;\n  \n  while(Tc--){\n    P p=input();\n    t.push_back(p);\n  }\n\n  printf(\"%.10f\\n\", minDist(t) );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n};\n\n//END CUT HERE\n\n//Projection\nsigned AOJ_CGL1A(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<project(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=jp\n*/\n\n//Reflect\nsigned AOJ_CGL1B(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<reflect(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=jp\n*/\n\n//CCW\nsigned AOJ_CGL1C(){\n  Point p0,p1;\n  cin>>p0>>p1;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p2;\n    cin>>p2;\n    int t=ccw(p0,p1,p2);\n    if(t==CCW_COUNTER_CLOCKWISE) cout<<\"COUNTER_CLOCKWISE\"<<endl;\n    if(t==CCW_CLOCKWISE) cout<<\"CLOCKWISE\"<<endl;\n    if(t==CCW_ONLINE_BACK) cout<<\"ONLINE_BACK\"<<endl;\n    if(t==CCW_ONLINE_FRONT) cout<<\"ONLINE_FRONT\"<<endl;\n    if(t==CCW_ON_SEGMENT) cout<<\"ON_SEGMENT\"<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=jp\n*/\n\n//Parallel / Orthogonal\nsigned AOJ_CGL2A(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    if(isParallel(Line(p0,p1),Line(p2,p3))) cout<<2<<endl;\n    else if(isOrthogonal(Line(p0,p1),Line(p2,p3))) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=jp\n*/\n\n//intersectSS\nsigned AOJ_CGL2B(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<(intersectSS(Segment(p0,p1),Segment(p2,p3)))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=jp\n*/\n\n//cross point\nsigned AOJ_CGL2C(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<getCrossPointSS(Segment(p0,p1),Segment(p2,p3))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=jp\n*/\n\n//distanceSS\nsigned AOJ_CGL2D(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    printf(\"%.12f\\n\",getDistanceSS(Segment(p0,p1),Segment(p2,p3)));\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=jp\n*/\n\n//area of Polygon\nsigned AOJ_CGL3A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.1f\\n\",area(p));\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A&lang=jp\n*/\n\n\n//isConvex\nsigned AOJ_CGL3B(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  cout<<isConvex(p)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B&lang=jp\n*/\n\n\n\n//contains\nsigned AOJ_CGL3C(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  int q;\n  cin>>q;\n  while(q--){\n    Point r;\n    cin>>r;\n    cout<<contains(p,r)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\n*/\n\n\n//convex hull\nsigned AOJ_CGL4A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  Polygon q=convex_hull(p);\n  cout<<q.size()<<endl;\n  for(Point v:q) cout<<v.x<<\" \"<<v.y<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=jp\n*/\n\n//diameter of Polygon\nsigned AOJ_CGL4B(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.12f\\n\",diameter(p));\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B&lang=jp\n*/\n\n//convexCut:\nsigned AOJ_CGL4C(){\n  int n;\n  cin>>n;\n  Polygon g(n);\n  for(int i=0;i<n;i++) cin>>g[i];\n  Polygon p=andrewScan(g);\n  int q;\n  cin>>q;\n  while(q--){\n    Line l;\n    cin>>l.p1>>l.p2;\n    printf(\"%.12f\\n\",area(convexCut(p,l)));\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C&lang=jp\n*/\n\n//closest pair:\nsigned AOJ_CGL5A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  cout<<fixed<<setprecision(12)<<closest_pair(p)<<endl;\n  return 0;\n}\n/*\n  verified on 2018/01/04\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=jp\n*/\n\n//intersectCC\nsigned AOJ_CGL7A(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  cout<<intersectCC(c1,c2)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\n*/\n\n\n//getCrossPointCL\nsigned AOJ_CGL7D(){\n  Circle c;\n  int q;\n  cin>>c>>q;\n  while(q--){\n    Line l;\n    cin>>l;\n    auto pp=getCrossPointCL(c,l);\n    if(pp.size()==1u) pp.emplace_back(pp[0]);\n    if(pp[1]<pp[0]) swap(pp[0],pp[1]);\n    cout<<pp[0]<<\" \"<<pp[1]<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D&lang=jp\n*/\n\n//intersectCC\nsigned AOJ_CGL7E(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  auto pp=getCrossPointCC(c1,c2);\n  if(pp.size()==1u) pp.emplace_back(pp[0]);\n  if(pp[1]<pp[0]) swap(pp[0],pp[1]);\n  cout<<pp[0]<<\" \"<<pp[1]<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E&lang=jp\n*/\n\n//tangent to a Circle\nsigned AOJ_CGL7F(){\n  Point p;\n  Circle c;\n  cin>>p>>c;\n  auto pp=tangent(c,p);\n  for(auto p:pp) cout<<p<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F&lang=jp\n*/\n\n//Common Tangent\nsigned AOJ_CGL7G(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  auto ls=tangent(c1,c2);\n  Polygon ps;\n  for(auto l:ls) ps.emplace_back(getCrossPointCL(c1,l)[0]);\n  sort(ps.begin(),ps.end());\n  for(auto p:ps) cout<<p<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge//description.jsp?id=CGL_7_G&lang=jp\n*/\n\n//area of 2 circles' intersection\nsigned AOJ_2572(){\n  double uw,uh,a,b,ab;\n  while(cin>>uw>>uh>>a>>b>>ab,uw!=0){\n    Circle c1(Point(0,0),sqrt(a/PI));\n    Circle c2(Point(0,0),sqrt(b/PI));\n    bool f=0;\n    if(c1.r<=c2.r) swap(c1,c2),f=1;\n    double l=max(0.0,c1.r-c2.r),r=c1.r+c2.r+EPS;\n    for(int k=0;k<100;k++){\n      double m=(l+r)/2;\n      c2.c.x=m;\n      //cout<<area(c1,c2)<<endl;\n      if(area(c1,c2)<=ab) r=m;\n      else l=m;\n    }\n    c2.c.x=l;\n    \n    double EPS3=1e-4;\n    assert(abs(area(c1,c2)-ab)<=EPS3);\n\n    l=0,r=PI/2;\n    for(int k=0;k<200;k++){\n      double m=(l+r)/2;\n      Circle t=c2;\n      t.c=translate(c2.c,m);\n      if(c1.r+max(c1.r,t.c.x+t.r)<=uw) r=m;\n      else l=m;\n    }\n    c2.c=translate(c2.c,r);\n    //cout<<c1.c<<\"/\"<<c2.c<<endl;\n    \n    Vector v(c1.r,c1.r);\n    c1.c=c1.c+v;\n    c2.c=c2.c+v;\n    \n    //cout<<c1.c<<\"/\"<<c2.c<<endl;\n\n    if(f) swap(c1,c2);\n    f=1;\n    f&=(c1.c.x-c1.r>=-EPS3);\n    f&=(c1.c.x+c1.r<=uw+EPS3);\n    f&=(c1.c.y-c1.r>=-EPS3);\n    f&=(c1.c.y+c1.r<=uh+EPS3);\n    f&=(c2.c.x-c2.r>=-EPS3);\n    f&=(c2.c.x+c2.r<=uw+EPS3);\n    f&=(c2.c.y-c2.r>=-EPS3);\n    f&=(c2.c.y+c2.r<=uh+EPS3);\n    if(f) cout<<c1.c<<\" \"<<c1.r<<\" \"<<c2.c<<\" \"<<c2.r<<endl;\n    else cout<<\"impossible\"<<endl;\n    //else cout<<c1.c<<\" \"<<c1.r<<\"/\"<<c2.c<<\" \"<<c2.r<<endl;\n  }\n  return 0;\n}\n/*\nverified on 2017/12/31\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2572\n*/\n\nsigned main(){\n  //AOJ_CGL1A();\n  //AOJ_CGL1B();\n  //AOJ_CGL1C();\n\n  //AOJ_CGL2A();\n  //AOJ_CGL2B();\n  //AOJ_CGL2C();\n  //AOJ_CGL2D();\n  \n  //AOJ_CGL3A();\n  //AOJ_CGL3B();\n  //AOJ_CGL3C();\n  \n  //AOJ_CGL4A();\n  //AOJ_CGL4B();\n  //AOJ_CGL4C();\n  \n  AOJ_CGL5A();\n  \n  //AOJ_CGL7A();\n  //AOJ_CGL7D();\n  //AOJ_CGL7E();\n  //AOJ_CGL7F();\n  //AOJ_CGL7G();\n\n  //AOJ_2572();\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nstatic const double EPS=1e-12;\nstatic const double INF=1e24;\n\nusing Point=complex<double>;\nusing Plane=vector<Point>;\nusing Polygon=vector<Point>;\n\nbool operator<(const Point &a, const Point &b) {\n    return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n}\n\ndouble cross_prod(const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot_prod(const Point &a, const Point &b) {\n    return real(conj(a)*b);\n}\n\nenum {\n    ONLINE_FRONT=-2,\n    CLOCKWISE,\n    ON_SEGMENT,\n    COUNTER_CLOCKWISE,\n    ONLINE_BACK,\n};\n\nint ccwise(Point a, Point b, Point c) {\n    b -= a; c -= a;\n\n    if (cross_prod(b, c) > 0) {\n        return COUNTER_CLOCKWISE;\n    } else if (cross_prod(b, c) < 0) {\n        return CLOCKWISE;\n    } else if (dot_prod(b, c) < 0) {\n        return ONLINE_BACK;\n    } else if (norm(b) < norm(c)) {\n        return ONLINE_FRONT;\n    } else {\n        return ON_SEGMENT;\n    }\n}\n\ntemplate <class LineType>\nint ccwise(LineType l, Point p) {\n    return ccwise(l.first, l.second, p);\n}\n\nstruct Line: public pair<Point, Point> {\n    Line() {}\n    Line(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\nstruct LineSeg: public pair<Point, Point> {\n    LineSeg() {}\n    LineSeg(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\npair<Point, Point> closest_pair(Polygon g) {\n    size_t V=g.size(), s=0, t=1, m=2;\n    vector<size_t> S(V);\n    sort(g.begin(), g.end(), [](const Point &a, const Point &b) {\n        return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n    });\n\n    double res=abs(g[s]-g[t]);\n    for (size_t i=2; i<V; S[m++]=i++)\n        for (size_t j=0; j<m; ++j) {\n            if (res > abs(g[S[j]]-g[i]))\n                res = abs(g[s=S[j]]-g[t=i]);\n\n            if (real(g[S[j]]) < real(g[i]-res))\n                S[j--] = S[--m];\n        }\n\n    return make_pair(g[s], g[t]);\n}\n\ntemplate <class RandomIt>\npair<Point, Point> closest_pair(RandomIt first, RandomIt last) {\n    size_t n=last-first;\n    if (n < 2)\n        return make_pair(Point(-INF, -INF), Point(INF, INF));\n\n    RandomIt mid=first+n/2;\n    double x=real(*mid);\n    pair<Point, Point> p1=closest_pair(first, mid);\n    pair<Point, Point> p2=closest_pair(mid, last);\n    inplace_merge(first, mid, last, [](const Point &lhs, const Point &rhs) {\n        return imag(lhs) < imag(rhs);\n    });\n\n    double d1=norm(p1.first-p1.second), d2=norm(p2.first-p2.second);\n    double d=(d1<d2? d1:d2);\n    pair<Point, Point> res=(d1<d2? p1:p2);\n\n    vector<Point> b;\n    for (RandomIt it=first; it<last; ++it) {\n        if (norm(real(*it)-x) >= d) continue;\n\n        for (size_t j=0; j<b.size(); ++j) {\n            Point e=*it-b[b.size()-j-1];\n            if (imag(e) >= sqrt(d)) break;\n\n            if (d > norm(e)) {\n                d = norm(e);\n                res = make_pair(*it, b[b.size()-j-1]);\n            }\n        }\n        b.push_back(*it);\n    }\n\n    return res;\n}\n\nint main() {\n    size_t n;\n    scanf(\"%zu\", &n);\n\n    Polygon g(n);\n    for (size_t i=0; i<n; ++i) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        g[i] = Point(x, y);\n    }\n\n    sort(g.begin(), g.end(), [](const Point &lhs, const Point &rhs) {\n        return real(lhs)!=real(rhs)? real(lhs)<real(rhs) : imag(lhs)<imag(rhs);\n    });\n\n    pair<Point, Point> p=closest_pair(g.begin(), g.end());\n    printf(\"%.9f\\n\", abs(p.first-p.second));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std {\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\n\treturn 0.0;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a){\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b),cpp(c));\n\tsort(_all(a),[](const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b));});\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << cpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; cin >> n;\n    \n    vector<double> x(n), y(n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        cin >> x[i] >> y[i];\n    }\n    \n    double sqr_ans = 100000000.0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = i + 1; j < n; j++)\n        {\n            sqr_ans = min((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]), sqr_ans);\n        }\n    }\n    \n    cout << sqrt(sqr_ans) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = limits::inf;\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) >= delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    printf(\"%.8f\\n\", closest_pair(P));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nstruct P\n{\n\tdouble x, y;\n\tP(double x, double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn x*x + y*y;\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nint ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}\n\npair<P, P> ClosestPair(vector<P>& points)\n{\n\tint n = points.size(), s = 0, t = 1, m = 2;\n\tvector<int> S(n);\n\tS[0] = 0, S[1] = 1;\n\tsort(points.begin(), points.end());\n\tdouble d = (points[s] - points[t]).length();\n\tfor (int i = 2; i < n; S[m++] = i++)for (int j = 0; j < m; j++)\n\t{\n\t\tif ((points[S[j]] - points[i]).length() < d)\n\t\t{\n\t\t\td = (points[s = S[j]] - points[t = i]).length();\n\t\t}\n\t\tif (points[S[j]].x < points[i].x - d)\n\t\t{\n\t\t\tS[j--] = S[--m];\n\t\t}\n\t}\n\treturn make_pair(points[s], points[t]);\n}\n\nvector<P> points;\n\nint main()\n{\n\tpoints.reserve(100000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpoints.push_back(P(x, y));\n\t}\n\n\tpair<P, P> closestPair = ClosestPair(points);\n\tprintf(\"%.10lf\\n\", (closestPair.first - closestPair.second).length());\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n \nusing namespace std;\n \nint main()\n{\n    int n; double x[100000], y[100000];\n     \n    scanf(\"%d\", &n);\n     \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n     \n    pair<double, double> p1[100000], p2[100000];\n     \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n     \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n     \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n     \n    double sqr_ans = 100000000.0;\n     \n    const int loops = 111;\n     \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n         \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n         \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n     \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n         \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + j].first - p2[i].first) * (p2[i + j].first - p2[i].first) + (p2[i + j].second - p2[i].second) * (p2[i + j].second - p2[i].second);\n         \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n     \n    printf(\"%.9f\\n\", sqrt(sqr_ans));\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#ifndef Geometry_Complex_hpp\n#define Geometry_Complex_hpp\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n//BEGIN CUT HERE\nnamespace Geometry{\n#define F first\n#define S second\n  typedef long double D;\n  typedef complex<long double> P;\n  typedef pair<P,D> C;\n\n  const D EPS=1e-9;\n  const D PI=asin(1)*2;\n  const D INF=1e18;\n\n  static bool comp(const P &p1,const P &p2){\n    if(p1.real()==p2.real()){return p1.imag()<p2.imag();}\n    return p1.real()<p2.real();\n  }\n\n  static bool comp_y(const P &p1,const P &p2){\n    if(p1.imag()==p2.imag()){return p1.real()<p2.real();}\n    return p1.imag()<p2.imag();\n  }\n\n  static bool eqls(const P &p1,const P &p2){\n    return abs(p1-p2)<EPS;\n  }\n\n  D dot(P p1,P p2){\n    return p1.real()*p2.real()+p1.imag()*p2.imag();\n  }\n\n  D cross(P p1,P p2){\n    return p1.real()*p2.imag()-p1.imag()*p2.real();\n  }\n\n  P project(P vec,P x){\n    return vec*(x/vec).real();\n  }\n\n  P project(P p1,P p2,P x){\n    return p1+project(p2-p1,x-p1);\n  }\n\n  P reflect(P vec,P x){\n    return vec*conj(x/vec);\n  }\n\n  P reflect(P p1,P p2,P x){\n    return p1+reflect(p2-p1,x-p1);\n  }\n\n  bool intersectSL(P p1,P p2,P vec){\n    vec/=abs(vec); p1/=vec; p2/=vec;\n    return (p1.imag()<EPS && p2.imag()>-EPS)\n      || (p1.imag()>-EPS && p2.imag()<EPS);\n  }\n\n  bool intersectSL(P p1,P p2,P p3,P p4){\n    return intersectSL(p1-p4,p2-p4,p3-p4);\n  }\n\n  bool intersectSS(P p1,P p2,P p3,P p4){\n    if(dot(p2-p1,p3-p1)<-EPS && dot(p2-p1,p4-p1)<-EPS){return false;}\n    if(dot(p1-p2,p3-p2)<-EPS && dot(p1-p2,p4-p2)<-EPS){return false;}\n    return intersectSL(p1,p2,p3,p4) && intersectSL(p3,p4,p1,p2);\n  }\n\n  D distLP(P vec,P x){\n    return abs((x/vec).imag())*abs(vec);\n  }\n\n  D distLP(P p1,P p2,P x){\n    return distLP(p2-p1,x-p1);\n  }\n\n  D distSP(P p1,P p2,P x){\n    if(dot(p2-p1,x-p1)<-EPS){return abs(x-p1);}\n    if(dot(p1-p2,x-p2)<-EPS){return abs(x-p2);}\n    return distLP(p1,p2,x);\n  }\n\n  D distSS(P p1,P p2,P p3,P p4){\n    if(intersectSS(p1,p2,p3,p4)){return 0.0;}\n    return min({distSP(p1,p2,p3),distSP(p1,p2,p4),\n                distSP(p3,p4,p1),distSP(p3,p4,p2)});\n  }\n\n  P crosspointLL(P p1,P p2,P vec){\n    if(abs(cross(p2-p1,vec))<EPS){return vec;}\n    return vec*cross(p2-p1,p2)/cross(p2-p1,vec);\n  }\n\n  P crosspointLL(P p1,P p2,P p3,P p4){\n    return p4+crosspointLL(p1-p4,p2-p4,p3-p4);\n  }\n\n  P crosspointSS(P p1,P p2,P p3,P p4){\n    if(distSP(p1,p2,p3)<EPS){return p3;}\n    if(distSP(p1,p2,p4)<EPS){return p4;}\n    return crosspointLL(p1,p2,p3,p4);\n  }\n\n  bool intersectShL(P p1,P p2,P vec){\n    vec/=abs(vec);\n    return intersectSL(p1,p2,vec) &&\n      crosspointLL(p1/vec,p2/vec,vec/vec).real()>-EPS;\n  }\n\n  bool intersectShL(P p1,P p2,P p3,P p4){\n    return intersectShL(p1-p3,p2-p3,p4-p3);\n  }\n\n  //1::in,0::on edge,-1::out\n  int contain(const vector<P> &poly,const P &p){\n    vector<P> A={{65537,96847},{-24061,6701},{56369,-86509},\n                 {-93763,-78049},{56957,10007}};\n    int s=A.size();\n    vector<bool> cnt(s,false);\n    for(int i=0;i<(int)poly.size();i++){\n      int k=(i+1)%poly.size();\n      if(distSP(poly[i],poly[k],p)<EPS){return 0;}\n      for(int j=0;j<s;j++){\n        if(intersectShL(poly[i],poly[k],p,p+A[j])){cnt[j]=!cnt[j];}\n      }\n    }\n    int in=0;\n    for(int j=0;j<s;j++){if(cnt[j]){in++;}}\n    return in>s/2?1:-1;\n  }\n\n  vector<P> convexcut(const vector<P> &poly,P p1,P p2){\n    vector<P> ret;\n    for(int i=0;i<(int)poly.size();i++){\n      int j=(i+1)%poly.size();\n      if(cross(p2-p1,poly[i]-p1)>-EPS){ret.push_back(poly[i]);}\n      if(intersectSL(poly[i],poly[j],p1,p2) &&\n         distLP(p1,p2,poly[i])>EPS && distLP(p1,p2,poly[j])>EPS){\n        ret.push_back(crosspointLL(poly[i],poly[j],p1,p2));\n      }\n    }\n    return ret;\n  }\n\n  D area(const vector<P> &poly){\n    D ans=0;\n    for(int i=2;i<(int)poly.size();i++){\n      ans+=cross(poly[i-1]-poly[0],poly[i]-poly[0]);\n    }\n    return abs(ans)/2;\n  }\n\n  vector<P> convexhull(vector<P> pts){\n    vector<P> ret;\n    sort(pts.begin(),pts.end(),comp);\n    auto fnc=\n      [&](){\n        for(auto &I:pts){\n          if(!ret.empty() && abs(I-ret.back())<EPS){continue;}\n          while(ret.size()>1){\n            P A=ret.back()-ret[ret.size()-2];\n            P B=I-ret.back();\n            if(cross(A,B)<-EPS){\n              ret.pop_back();\n            }else if(abs(cross(A,B))<EPS && dot(A,B)>EPS){\n              ret.pop_back();\n            }else{\n              break;\n            }\n          }\n          ret.push_back(I);\n        }\n      };\n    fnc();\n    reverse(pts.begin(),pts.end());\n    fnc();\n    if(ret.size()>1 && ret[0]==ret.back()){ret.pop_back();}\n    return ret;\n  }\n\n  //4::seperate,3::circumscribe,2::intersect,\n  //1::inscribe,0::contain,-1::same\n  int intersectCC(C c1,C c2){\n    D d=abs(c1.F-c2.F),r=c1.S+c2.S,dif=abs(c2.S-c1.S);\n    if(d<EPS && dif<EPS){return -1;}\n    if(d-r>EPS){return 4;}\n    if(d-r>-EPS){return 3;}\n    if(d-dif>EPS){return 2;}\n    if(d-dif>-EPS){return 1;}\n    return 0;\n  }\n\n  vector<P> crosspointLC(P p1,P p2,C c){\n    vector<P> ret;\n    P pr=project(p1,p2,c.F);\n    D d=distLP(p1,p2,c.F);\n    if(d-c.S>EPS){return ret;}\n    if(d-c.S>-EPS){ret.push_back(pr); return ret;}\n    P vec=p2-p1; vec*=sqrt(c.S*c.S-d*d)/abs(vec);\n    ret.push_back(pr-vec);\n    ret.push_back(pr+vec);\n    return ret;\n  }\n\n  vector<P> crosspointSC(P p1,P p2,C c){\n    vector<P> ret;\n    for(auto &I:crosspointLC(p1,p2,c)){\n      if(distSP(p1,p2,I)<EPS){ret.push_back(I);}\n    }\n    return ret;\n  }\n\n  vector<P> crosspointCC(C c1,C c2){\n    vector<P> ret;\n    P vec=c2.F-c1.F;\n    D base=(c1.S*c1.S+norm(vec)-c2.S*c2.S)/(2*abs(vec));\n    D h=sqrt(c1.S*c1.S-base*base);\n    vec/=abs(vec);\n    ret.push_back(c1.F+vec*P(base,-h));\n    ret.push_back(c1.F+vec*P(base,h));\n    return ret;\n  }\n\n  vector<P> tangentCP(C c,P p){\n    return crosspointCC(c,C(p,sqrt(norm(c.F-p)-c.S*c.S)));\n  }\n\n  vector<pair<P,P>> tangentCC(C c1,C c2){\n    vector<pair<P,P>> ret;\n    P d=c2.F-c1.F;\n    for(D i:{-1,1}){\n      D r=c1.S+c2.S*i;\n      if(intersectCC(c1,c2)>i+1){\n        for(P s:{-1i,1i}){\n          P p=r+s*sqrt(norm(d)-norm(r));\n          ret.emplace_back(c1.F+d*c1.S/norm(d)*p,\n                           c2.F-d*i*c2.S/norm(d)*p);\n        }\n      }\n    }\n    return ret;\n  }\n\n  D area(const vector<P> &poly,C c){\n    D ret=0;\n    for(int i=0;i<(int)poly.size();i++){\n      P a=poly[i]-c.F,b=poly[(i+1)%poly.size()]-c.F;\n      if(abs(a)<c.S+EPS && abs(b)<c.S+EPS){\n        ret+=cross(a,b);\n      }else{\n        vector<P> A=crosspointSC(a,b,{0,c.S});\n        if(A.empty()){ret+=c.S*c.S*arg(b/a);}\n        else{\n          ret+=(abs(a)<c.S?\n                cross(a,A[0]):\n                c.S*c.S*arg(A[0]/a));\n          ret+=(abs(b)<c.S?\n                cross(A.back(),b):\n                c.S*c.S*arg(b/A.back()));\n          ret+=cross(A[0],A.back());\n        }\n      }\n    }\n    return abs(ret)/2;\n  }\n\n  //counter-clockwise\n  D diameter(const vector<P> &poly){\n    D ret=0;\n    ll l=0,r=0,n=poly.size();\n    if(n==2){return abs(poly[0]-poly[1]);}\n    for(int i=0;i<n;i++){\n      if(comp(poly[l],poly[i])){l=i;}\n      if(comp(poly[i],poly[r])){r=i;}\n    }\n    ll sl=r,sr=l;\n    while(sl!=l || sr!=r){\n      ret=max(ret,abs(poly[r]-poly[l]));\n      if(cross(poly[(l+1)%n]-poly[l],\n               poly[(r+1)%n]-poly[r])<0){\n        (++l)%=n;\n      }else{\n        (++r)%=n;\n      }\n    }\n    return ret;\n  }\n\n  D closestpair(vector<P> pt){\n    sort(pt.begin(),pt.end(),comp);\n    D ret=INF;\n    int N=pt.size();\n    for(int i=1;i<N;i<<=1){\n      for(int j=0;i+j<N;j+=i*2){\n        int m=i+j;\n        vector<P> R;\n        D l=-INF,r=INF;\n        for(int k=j;k<m;k++){l=max(l,pt[k].real());}\n        for(int k=0;m+k<N && k<i;k++){r=min(r,pt[m+k].real());}\n        for(int k=0;m+k<N && k<i;k++){\n          if(pt[m+k].real()-l<ret){R.push_back(pt[m+k]);}\n        }\n        int idx=0;\n        for(int k=j;k<m;k++){\n          if(r-pt[k].real()>ret){continue;}\n          int M=R.size();\n          while(idx<M && pt[k].imag()-R[idx].imag()>ret){idx++;}\n          for(int s=idx;s<M && R[s].imag()-pt[k].imag()<ret;s++){\n            ret=min(ret,abs(R[s]-pt[k]));\n          }\n        }\n        auto ed=(j+i*2<N?pt.begin()+j+2*i:pt.end());\n        inplace_merge(pt.begin()+j,pt.begin()+m,ed,comp_y);\n      }\n    }\n    return ret;\n  }\n\n  P centerofgravity(const vector<P> &pt){\n    P ret(0,0);\n    D wt=0;\n    for(int i=2;i<(int)pt.size();i++){\n      D w2=cross(pt[i-1]-pt[0],pt[i]-pt[0]);\n      P p=(pt[0]+pt[i-1]+pt[i])/(D)3;\n      wt+=w2;\n      ret+=p*w2;\n    }\n    return ret/wt;\n  }\n\n  void segment_arrangement(const vector<pair<P,P>> &L,\n                           vector<pair<int,int>> &seg,vector<P> &pt){\n    int N=L.size();\n    for(int i=0;i<N;i++){\n      pt.push_back(L[i].F);\n      pt.push_back(L[i].S);\n      for(int j=i+1;j<N;j++){\n        if(intersectSS(L[i].F,L[i].S,L[j].F,L[j].S)){\n          pt.push_back(crosspointSS(L[i].F,L[i].S,L[j].F,L[j].S));\n        }\n      }\n    }\n    auto le=[](P a,P b){return eqls(a,b)?false:comp(a,b);};\n    sort(pt.begin(),pt.end(),le);\n    pt.erase(unique(pt.begin(),pt.end(),eqls),pt.end());\n    for(auto &I:L){\n      vector<pair<D,int>> on;\n      for(int j=0;j<(int)pt.size();j++){\n        if(distSP(I.F,I.S,pt[j])<EPS){\n          on.emplace_back(abs(pt[j]-I.F),j);\n        }\n      }\n      sort(on.begin(),on.end());\n      for(int j=1;j<(int)on.size();j++){\n        seg.emplace_back(on[j-1].S,on[j].S);\n      }\n    }\n    sort(seg.begin(),seg.end());\n    seg.erase(unique(seg.begin(),seg.end()),seg.end());\n  }\n\n  vector<P> convex_of_segments(const vector<pair<P,P>> &L){\n    vector<pair<int,int>> seg;\n    vector<P> pt;\n    segment_arrangement(L,seg,pt);\n    vector<vector<int>> edge(pt.size());\n    for(auto &I:seg){\n      edge[I.F].push_back(I.S);\n      edge[I.S].push_back(I.F);\n    }\n    vector<P> ret;\n    function<void(int,int)> dfs=\n      [&](int v,int pre){\n        if(pre!=-1 && v==0){return;}\n        ret.push_back(pt[v]);\n        vector<pair<D,int>> nx;\n        for(auto &u:edge[v]){\n          P dom=(pre==-1||eqls(pt[v],pt[pre]))?P(1):pt[v]-pt[pre];\n          D a=arg((pt[u]-pt[v])/dom);\n          if(abs(a+PI)<EPS){a=PI;}\n          nx.emplace_back(a,u);\n        }\n        sort(nx.begin(),nx.end());\n        dfs(nx[0].S,v);\n      };\n    dfs(0,-1);\n    return ret;\n  }\n\n  istream & operator >> (istream &i,P &p){\n    D x,y; i>>x>>y; p={x,y}; return i;\n  }\n  istream & operator >> (istream &i,C &p){\n    D x,y; i>>x>>y>>p.S; p.F={x,y}; return i;\n  }\n};\n\nusing namespace Geometry;\n//END CUT HERE\n\n\n#endif /*Geometry_Complex_hpp*/\n\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\"\n#define ERROR \"0.000001\"\n\n\nint main(){\n    cout<<fixed<<setprecision(12);\n    ll n;\n    cin>>n;\n    vector<P> A(n);\n    for(auto &I:A){cin>>I;}\n    cout<<closestpair(A)<<endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<utility>\n\ntypedef pair<double, double> point;\ntypedef point* data;\n\ndouble dist(const point &p1, const point &p2)\n{\n\tdouble dx = p1.first - p2.first;\n\tdouble dy = p1.second - p2.second;\n\treturn sqrt(dx * dx + dy * dy);\n}\n\nbool sort_y(const point &p1, const point &p2){ return p1.second < p2.second; }\n\npoint Z[100000];\n\ndouble closest(data X, data Y, int n)\n{\n\tif(n <= 3){\n\t\tdouble d = dist(X[0], X[1]);\n\t\tfor(int i = 0; i < n; i++){ Y[i] = X[i]; }\n\t\tsort(Y, Y + n, sort_y);\n\n\t\tif(n < 3){ return d; }\n\t\telse{ return min(d, min(dist(X[0], X[2]), dist(X[1], X[2]))); }\n\t}\n\tint m = (n >> 1);\n\tdouble median = X[m].first;\n\tdouble d = min(closest(X, Y, m), closest(X + m, Y + m, n - m));\n\n\tint size = 0;\n\tint i = 0, j = m;\n\twhile(i < m && j < n){\n\t\tif(i < m && j < n){\n\t\t\tif(Y[i].second < Y[j].second){\n\t\t\t\tZ[size] = Y[i]; size++; i++;\n\t\t\t}else{\n\t\t\t\tZ[size] = Y[j]; size++; j++;\n\t\t\t}\n\t\t}\n\t\tif(i == m && j < n){ while(j < n){ Z[size] = Y[j]; size++; j++; }; }\n\t\tif(i < m && j == n){ while(i < m){ Z[size] = Y[i]; size++; i++; }; }\n\t};\n\tint resize = 0;\n\tfor(i = 0; i < size; i++){\n\t\tif(fabs(Z[i].first - median) <= d){ Z[resize] = Z[i]; resize++; }\n\t}\n\n\tint a = 0;\n\tfor(i = 1; i < resize; i++){\n\t\tfor(j = a; j < i; j++){\n\t\t\tif(Z[i].second - Z[a].second > d){ a++; }\n\t\t\telse{\n\t\t\t\td = min(d, dist(Z[i], Z[a]));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\n\nint main()\n{\n\tdata X, Y;\n\tint i, n;\n\tscanf(\"%d\", &n);\n\tX = new point [n];\n\tY = new point [n];\n\n\tdouble co_x, co_y;\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &co_x, &co_y);\n\t\tX[i] = make_pair(co_x, co_y);\n\t}\n\tsort(X, X + n);\n\n\tdouble d = closest(X, Y, n);\n\tprintf(\"%.12f\\n\", d);\n\n\tdelete [] X;\n\tdelete [] Y;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\ntypedef complex<double> P;\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n};\ntypedef vector<P> Polygon;\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\n// ??????\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\n// ????¬?????????????2??????\ndouble norm(const P& a) {\n    return real(conj(a)*a);\n}\n\n// ??????\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\n// ???p2?????????p0, p1???????????´???????°???±?????????\nP projection(const P& p0, const P& p1, const P& p2) {\n    // ???????????????????????´???\n    P vec1 = p1 - p0;\n    P vec2 = p2 - p0;\n    return p0 + vec1 * dot(vec1, vec2) / dot(vec1, vec1);\n}\n\n// projection?????\\??¨???\n// not verified\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\n// ???p0, p1???????????´??????????§°?????¨????????????p2??¨????§°??????\nP reflection(const P& p0, const P& p1, const P& p2) {\n    P proj = projection(p0, p1, p2);\n    return proj - (p2 - proj);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;                               // a--c--b on line\n}\n\n// 2??´?????????????????????\nbool is_parallel(const L& l1, const L& l2) {\n    P p1 = l1[1] - l1[0];\n    P p2 = l2[1] - l2[0];\n    auto res = ccw(p1, p2, P(0,0));\n    return (res == 2 || res == -2 || res == 0);\n}\n\n// 2??´???????????´?????????\nbool is_ortho(const L& l1, const L& l2) {\n    P p1 = l1[1] - l1[0];\n    P p2 = l2[1] - l2[0];\n    return dot(p1, p2) == 0;\n}\n\n// l: line(??´???)\n// s: segment(??????)\n// not verified\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\n// not verified\nbool intersectLS(const L &l, const L &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n        cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\n\n// not verified\nbool intersectLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\n// not verified\nbool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n// not verified\ndouble distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\n// not verified\ndouble distanceLL(const L &l, const L &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\n// not verified\ndouble distanceLS(const L &l, const L &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n\ndouble distanceSP(const L &s, const P &p) {\n    const P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n               min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n// 2??´????????????\nP crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n}\n\n// ????§???¢?????¢???????±???????\n// P???????????¨???????????????\ndouble convexArea(const Polygon& poly) {\n    double area = 0.0;\n    REP(i, SIZE(poly))\n        area += cross(curr(poly, i), next(poly, i));\n    return abs(area) * 0.5;\n}\n\n// ??????????±??????????????????????????????????????????????\n// ????????????????¨?????????§????????????\n// not verified\nPolygon convexHull(const Polygon& poly) {\n    Polygon ps = poly;\n\n    int n = ps.size(), k = 0;\n    sort(ALL(ps));\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\n// ??????????±????????????????????????????????????????????????????\n// ????????????????¨?????????§????????????\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=jp\nPolygon convexHullInludingPointsOnEdge(const Polygon& poly) {\n    Polygon ps = poly;\n\n    int n = ps.size(), k = 0;\n    sort(ALL(ps));\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\n// ?????§??????\n// poly?????????????¨???¨?????§?????????????´?????????????????????¨???????????????\n// ???????????´??????????????¶???????¨±???\nbool isConvex(const Polygon &poly) {\n    REP(i, SIZE(poly)) {\n        if (ccw(prev(poly, i), curr(poly, i), next(poly, i)) == -1)\n            return false;\n    }\n    return true;\n}\n\n// poly????????§???????????¨?????????\n// 0: OUT\n// 1: ON\n// 2: IN\n// not verified\nenum { OUT, ON, IN };\nint convexContains(const Polygon &poly, const P &p) {\n    const int n = poly.size();\n    P g = (poly[0] + poly[n/3] + poly[2*n/3]) / 3.0; // inner-P\n    int a = 0, b = n;\n    while (a+1 < b) { // invariant: c is in fan g-poly[a]-poly[b]\n        int c = (a + b) / 2;\n        if (cross(poly[a]-g, poly[c]-g) > 0) { // angle < 180 deg\n            if (cross(poly[a]-g, p-g) > 0 && cross(poly[c]-g, p-g) < 0) b = c;\n            else                                                  a = c;\n        } else {\n            if (cross(poly[a]-g, p-g) < 0 && cross(poly[c]-g, p-g) > 0) a = c;\n            else                                                  b = c;\n        }\n    }\n    b %= n;\n    if (cross(poly[a] - p, poly[b] - p) < 0) return OUT;\n    if (cross(poly[a] - p, poly[b] - p) > 0) return IN;\n    return ON;\n}\n\n// poly????????§???????????????\n// 0: OUT\n// 1: ON\n// 2: IN\nint contains(const Polygon& poly, const P& p) {\n    bool in = false;\n    REP(i, SIZE(poly)) {\n        P a = curr(poly,i) - p, b = next(poly,i) - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b))\n            if (cross(a, b) < 0) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\n\n// ????§???¢?????´?????????2???????????????\n// ??\\????????????????????§?????????????????????\ndouble convexDiameterSquared(const Polygon &poly) {\n    const int n = poly.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(poly[i]) > imag(poly[is])) is = i;\n        if (imag(poly[i]) < imag(poly[js])) js = i;\n    }\n    double maxd = norm(poly[is]-poly[js]);\n\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n        if (cross(diff(poly,i), diff(poly,j)) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (norm(poly[i]-poly[j]) > maxd) {\n            maxd = norm(poly[i]-poly[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd; /* farthest pair is (maxi, maxj). */\n}\n\n// ???????§???¢?????????\n// ???????§???¢???????????´?????§???????????????????????´????????????\nPolygon convexCut(const Polygon& p, const L& l) {\n    Polygon Q;\n    REP(i, SIZE(p)) {\n        P A = curr(p, i);\n        P B = next(p, i);\n        if (ccw(l[0], l[1], A) != -1)\n            Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspoint(L(A, B), l));\n    }\n    return Q;\n}\n\n// fail\npair<P,P> closestPairFail(vector<P>& p) {\n    int n = p.size();\n    int s = 0;\n    int t = 1;\n    int m = 2;\n    int S[n];\n    S[0] = 0, S[1] = 1;\n    sort(ALL(p)); // \"p < q\" <=> \"p.x < q.x\"\n    double d = norm(p[s]-p[t]);\n    for (int i = 2; i < n; S[m++] = i++) REP(j, m) {\n            if (norm(p[S[j]]-p[i])<d) d = norm(p[s = S[j]]-p[t = i]);\n            if (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n        }\n    return make_pair( p[s], p[t] );\n}\n\n// Too Slow\npair<P,P> closestPair(vector<P>& p) {\n    sort(ALL(p)); // \"p < q\" <=> \"p.x < q.x\"\n    double min_d = norm(p[0] - p[1]);\n    int size = p.size();\n\n    pair<int,int> ret{0,1};\n\n    REP(i, size-1) {\n        FOR(j, i+1, size) {\n            if ( pow(real(p[j]) - real(p[i]), 2) > min_d ) break;\n            double d = norm(p[i] - p[j]);\n            if (d < min_d) {\n                min_d = d;\n                ret = mp(i,j);\n            }\n        }\n    }\n\n    return mp(p[ret.first], p[ret.second]);\n}\n\nint main(){\n    int N;\n    cin >> N;\n    vector<P> points(N);\n    REP(n, N) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        points[n] = P(x,y);\n    }\n\n    auto res = closestPair(points);\n    printf(\"%.10lf\\n\", sqrt(norm(res.first - res.second)));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntypedef long double LD;\ntypedef complex<LD> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> Polygon;\nconst LD EPS = 1e-10;\n#define X real() // x座標を取得\n#define Y imag() // y座標を取得\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積 Dot(a, b) = |a||b|cosθ\nLD Dot(Point a, Point b){\n    return (conj(a)*b).X;\n}\n\n// 外積 Cross(a, b) = |a||b|sinθ\nLD Cross(Point a, Point b){\n    return (conj(a)*b).Y;\n}\n\nint CCW(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if (Cross(b, c) > 0)   return +1;       // counter clockwise\n    if (Cross(b, c) < 0)   return -1;       // clockwise\n    if (Dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n//*********************************************\n//          点と線(Point and Line)            *\n//*********************************************\n\n// 交差判定 (Isec) ****************************\n// 点　 := 平面座標にある点\n// 直線 := 点と点を通るどこまでも続く線\n// 線分 := 点と点を結んでその両端で止まっている線\n\n// 直線と点\nbool IsecLP(Point a1, Point a2, Point b){\n    return abs(CCW(a1, a2, b)) != 1;\n}\n\n// 直線と直線\nbool IsecLL(Point a1, Point a2, Point b1, Point b2) {\n    return !IsecLP(a2-a1, b2-b1, 0) || IsecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool IsecLS(Point a1, Point a2, Point b1, Point b2) {\n    return Cross(a2-a1, b1-a1) * Cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool IsecSS(Point a1, Point a2, Point b1, Point b2) {\n    return CCW(a1, a2, b1)*CCW(a1, a2, b2) <= 0 && CCW(b1, b2, a1)*CCW(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool IsecSP(Point a1, Point a2, Point b) {\n    return !CCW(a1, a2, b);\n}\n\n// ********************************************\n\n\n// 距離 (Dist) ********************************\n// 点pの直線aへの射影点を返す\nPoint Proj(Point a1, Point a2, Point p){\n    return a1 + Dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nPoint Reflection(Point a1, Point a2, Point p){\n    return 2.0L*Proj(a1, a2, p) - p;\n}\n\n// 点と点\nLD DistPP(Point a, Point b){\n    return abs(a-b);\n}\n\n// 直線と点\nLD DistLP(Point a1, Point a2, Point p){\n    return abs(Proj(a1, a2, p) - p);\n}\n\n// 直線と直線\nLD DistLL(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLL(a1, a2, b1, b2) ? 0 : DistLP(a1, a2, b1);\n}\n\n// 直線と線分\nLD DistLS(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLS(a1, a2, b1, b2) ? 0 : min(DistLP(a1, a2, b1), DistLP(a1, a2, b2));\n}\n\n// 線分と点\nLD DistSP(Point a1, Point a2, Point p) {\n    if(Dot(a2-a1,p-a1) < EPS) return abs(p-a1);\n    if(Dot(a1-a2,p-a2) < EPS) return abs(p-a2);\n    return abs(Cross(a2-a1,p-a1)) / abs(a2-a1);\n}\n\n// 線分と線分\nLD DistSS(Point a1, Point a2, Point b1, Point b2) {\n    if(IsecSS(a1, a2, b1, b2)) return 0;\n    return min(min(DistSP(a1, a2, b1), DistSP(a1, a2, b2)), min(DistSP(b1, b2, a1), DistSP(b1, b2, a2)));\n}\n\n// ********************************************\n\n\n// 2直線の交点 (CrossPoint) *******************\nPoint CrossPointLL(Point a1, Point a2, Point b1, Point b2){\n    LD d1 = Cross(b2-b1, b1-a1);\n    LD d2 = Cross(b2-b1, a2-a1);\n    if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n    if (EQ(d2, 0)) throw \"not exist crosspoint\";\n    return a1 + d1/d2 * (a2-a1);\n}\n// ********************************************\n\n\n//*********************************************\n//             多角形(Polygon)                *\n//*********************************************\n\nnamespace std {\n    bool operator < (Point a, Point b){\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 多角形の面積 (PolygonErea) *****************\nLD PolygonErea(Polygon p){\n    LD area = 0;\n    int n = p.size();\n    for(int i = 0; i < n; i++){\n        area += Cross(p[i], p[(i+1) % n]);\n    }\n    return area / 2;\n}\n// ********************************************\n\n\n// 凸性判定 (IsConvex) ************************\nbool IsConvex(Polygon pol){\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        if(CCW(pol[i], pol[(i+1) % n], pol[(i+2) % n]) == -1) return false;\n    }\n    return true;\n}\n// ********************************************\n\n\n// 多角形-点包含関係 (PolygonPointContainment)\nint PolygonPointContainment(Polygon pol, Point p){\n    enum {OUT, ON, IN};\n    bool in = false;\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        Point a = pol[i] - p, b = pol[(i+1) % n] - p;\n        if(a.Y > b.Y) swap(a, b);\n        if(a.Y <= 0 && 0 < b.Y && Cross(a, b) < 0) in = !in;\n        if(Cross(a, b) == 0 && Dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n// ********************************************\n\n\n//*********************************************\n//          凸多角形(ConvexPolygon)           *\n//*********************************************\n\n// 凸包[θ<=180] (ConvexHull) *****************\nPolygon ConvexHull(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸包[θ<180] (ConvexHull2) *****************\nPolygon ConvexHull2(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸多角形の直径 (ConvexPolygonDiameter) *****\npair<int, int> ConvexPolygonDiameter(Polygon cpol){\n    int n = cpol.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(cpol[i]) > imag(cpol[is])) is = i;\n        if (imag(cpol[i]) < imag(cpol[js])) js = i;\n    }\n    LD maxd = norm(cpol[is]-cpol[js]);\n\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if(Cross(cpol[(i+1)%n] - cpol[i], cpol[(j+1)%n] - cpol[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if(norm(cpol[i]-cpol[j]) > maxd) {\n            maxd = norm(cpol[i]-cpol[j]);\n            maxi = i; maxj = j;\n        }\n    } while(i != is || j != js);\n    return make_pair(maxi, maxj);\n}\n// ********************************************\n\n\n// 凸多角形の切断 (ConvexPolygonCut) **********\nPolygon ConvexPolygonCut(Polygon cpol, Line l){\n    int n = cpol.size();\n    Polygon q;\n    for(int i = 0; i < n; i++){\n        Point a = cpol[i], b = cpol[(i+1)%n];\n        if(CCW(l.first, l.second, a) != -1) q.push_back(a);\n        if(CCW(l.first, l.second, a) * CCW(l.first, l.second, b) < 0) q.push_back(CrossPointLL(a, b, l.first, l.second));\n    }\n    return q;\n}\n// ********************************************\n\n\n// 凸多角形-点包含関係 (ConvexPolygonPointContainment)\nint ConvexPolygonPointContainment(Polygon cpol, Point p){\n    enum {OUT, ON, IN};\n    int n = cpol.size();\n    Point g = (cpol[0] + cpol[n/3] + cpol[2*n/3]) / 3.0L;\n    int a = 0, b = n;\n    while(a+1 < b){\n        int c = (a + b) / 2;\n        if(Cross(cpol[a]-g, cpol[c]-g) > 0){\n            if(Cross(cpol[a]-g, p-g) > 0 && Cross(cpol[c]-g, p-g) < 0) b = c;\n            else a = c;\n        }else{\n            if(Cross(cpol[a]-g, p-g) < 0 && Cross(cpol[c]-g, p-g) > 0) a = c;\n            else b = c;\n        }\n    }\n    b %= n;\n    if(Cross(cpol[a]-p, cpol[b]-p) < 0) return OUT;\n    if(Cross(cpol[a]-p, cpol[b]-p) > 0) return IN;\n    return ON;\n}\n// ********************************************\n\n// 最近点対 (ClosestPair) *********************\npair<Point, Point> ClosestPair(Polygon p){\n    int n = p.size(), s = 0, t = 1, m = 2;\n    int S[n]; S[0] = 0, S[1] = 1;\n    sort(p.begin(), p.end());\n    LD d = norm(p[s]-p[t]);\n    for(int i = 2; i < n; S[m++] = i++) for(int j = 0; j < m; j++){\n        if(norm(p[S[j]]-p[i])<d) d = norm(p[s = S[j]]-p[t = i]);\n        if(p[S[j]].X < p[i].X - d) S[j--] = S[--m];\n    }\n    return make_pair(p[s], p[t]);\n}\n// ********************************************\n\n\n/************** using variables ***************/\nPolygon p;\nint n;\nint q;\n/**********************************************/\n\nsigned main(){\n    cin >> n;\n    REP(i, n){\n        LD xp, yp;\n        cin >> xp >> yp;\n        p.pb(Point(xp, yp));\n    }\n\n   pair<Point, Point> ans = ClosestPair(p);\n   printf(\"%.9Lf\\n\", DistPP(ans.first, ans.second));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef complex<double> C;\n\nnamespace std\n{\n    bool operator < (const C& a, const C& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(const C &a, const C &b) {\n        push_back(a); push_back(b);\n    }\n};\n\n//??????\ndouble cross(const C& a, const C& b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C& a, const C& b)\n{\n    return real(conj(a)*b);\n}\n\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n//??´???????????????????????????(????????´??????True)\nbool intersectLL(const L &l, const L &m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//??´?????¨?????????????????????(????????±??????????????¨??????)\nbool intersectLS(const L &l, const L &s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//??´?????¨????????????(??±???)??????\nbool intersectLP(const L &l, const C &p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//??????????????????????????????(????????±??????????????¨??????)\nbool intersectSS(const L &s, const L &t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//????????¨????????????(??±???)??????\nbool intersectSP(const L &s, const C &p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//???p?????´???l???????°???±\nC projection(const L &l, const C &p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//???p?????´???l????????¨??????????§°?§????\nC reflection(const L &l, const C &p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//?????¨??´???????????¢\ndouble distanceLP(const L &l, const C &p)\n{\n    return abs(p - projection(l, p));\n}\n//??´?????¨??´???????????¢\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//??´?????¨??????????????¢\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//????????¨???????????¢\ndouble distanceSP(const L &s, const C &p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//????????¨??????????????¢\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n//??´???????????????????????????\nC crosspoint(const L &l, const L &m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//?????????????????????\nL crosspointSS(C &p1,int r1,C &p2,int r2)\n{\n    double d = norm(p2-p1);\n    double t = r2*r2 - r1*r1 - d;\n    double aa = d,bb = t*(real(p2)-real(p1)),cc = t*t / 4.0 - (imag(p2) - imag(p1))*(imag(p2) - imag(p1))*r1*r1;\n    double x1 = (-bb - sqrt(bb*bb - 4*aa*cc))/(2*aa),x2 = (-bb + sqrt(bb*bb - 4*aa*cc))/(2*aa);\n    double y1,y2;\n    if(imag(p1) == imag(p2)){\n        y1 = -sqrt(r1*r1 - x1*x1);\n        y2 = -y1;\n    }else{\n        y1 = (t+2*(real(p2)-real(p1))*x1)/(-2*(imag(p2)-imag(p1)));\n        y2 = (t+2*(real(p2)-real(p1))*x2)/(-2*(imag(p2)-imag(p1)));\n    }\n    L ln = L(C(x1+real(p1),y1+imag(p1)),C(x2+real(p1),y2+imag(p1)));\n    return ln;\n}\n//??????????±???????\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//?????§??????\nbool isconvex(const vector<C> &ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//????§???¢?????¢???\ndouble area(const vector<C> &ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//???????§???¢?????´?????§???????????????????????´????????¢\nvector<C> convex_cut(const vector<C> &ps, const L &l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspoint(L(A, B), l));\n    }\n    return Q;\n}\n//??????????§???¢???????????????????????????(0??????????????????,1?????????,2???????????????)\nint contains(const vector<C>& ps, const C& p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//???????§???¢?????´???????±???????(?????£????????????)\n//maxi,maxj?????????????????¨??????\ndouble convex_diameter(const vector<C> &ps)\n{\n    const int n = ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\ndouble closestPair(vector<C> &ps) {\n    int n = ps.size(), s = 0, t = 1, m = 2, S[n];\n    S[0] = 0, S[1] = 1;\n    sort(ps.begin(),ps.end());\n    double d = abs(ps[s]-ps[t]);\n    for (int i = 2; i < n; S[m++] = i++){\n        rep(j,m){\n            if (abs(ps[S[j]]-ps[i])<d) d = abs(ps[s = S[j]]-ps[t = i]);\n            if (real(ps[S[j]]) < real(ps[i]) - d) S[j--] = S[--m];\n        }\n    }\n    return d;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<C> vec;\n    rep(i,n){\n        double x,y;\n        cin >> x >> y;\n        vec.push_back(C(x,y));\n    }\n    printf(\"%.10f\\n\",closestPair(vec));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nnamespace geo{\n    using real_num = double;\n    constexpr real_num eps = 1e-9;\n    constexpr real_num PI = 3.14159265358979323846264338327950;\n\n    inline int sgn(real_num x){\n        if(x < -eps) return -1;\n        if(x > eps) return 1;\n        return 0;\n    }\n \n    inline bool eq(real_num x, real_num y){\n        return sgn(x-y) == 0;\n    }\n \n    inline bool ge(real_num x, real_num y){\n        return sgn(x-y) == 1;\n    }\n \n    inline bool le(real_num x, real_num y){\n        return sgn(x-y) == -1;\n    }\n \n    inline bool geq(real_num x, real_num y){\n        return sgn(x-y) >= 0;\n    }\n \n    inline bool leq(real_num x, real_num y){\n        return sgn(x-y) <= 0;\n    }\n\n    struct Point{\n        real_num x, y;\n        Point(real_num x=0, real_num y=0): x(x), y(y){}\n \n        Point operator+(const Point &p){\n            return {x+p.x, y+p.y};\n        }\n \n        Point operator-(const Point &p){\n            return {x-p.x, y-p.y};\n        }\n \n        Point operator*(const real_num k){\n            return {k*x, k*y};\n        }\n \n        Point operator/(const real_num k){\n            return {x/k, y/k};\n        }\n \n        real_num operator*(const Point &p){\n            return x*p.x + y*p.y;\n        }\n \n        real_num operator^(const Point &p){\n            return x*p.y - y*p.x;\n        }\n \n        bool operator==(const Point &p){\n            return eq(x, p.x) && eq(y, p.y);\n        }\n \n        bool operator<(const Point &p) const{\n            if(eq(x, p.x)) return le(y, p.y);\n            return le(x, p.x);\n        }\n    };\n\n    using Vec = Point;\n    using Points = vector<Point>;\n    using Polygon = vector<Point>;\n\n    real_num norm(Point p){\n        return p.x*p.x+p.y*p.y;\n    }\n \n    real_num abs(Point p){\n        return sqrt(norm(p));\n    }\n \n    real_num arg(Point p){\n        return atan2(p.y, p.x);\n    }\n \n    Point rot(Point p, real_num t){\n        return {p.x*cos(t)-p.y*sin(t), p.x*sin(t)+p.y*cos(t)};\n    }\n \n    Point proj(Point a, Vec v, Point p){\n        real_num t=v*(p-a)/norm(v);\n        return a+v*t;\n    }\n \n    Point refl(Point a, Vec v, Point p){\n        return proj(a, v, p)*2-p;\n    }\n\n    constexpr int CCW_COUNTER_CLOCKWISE = 1;\n    constexpr int CCW_CLOCKWISE = -1;\n    constexpr int CCW_ONLINE_BACK = -2; // C->A->B\n    constexpr int CCW_ONLINE_FRONT = 2; // A->B->C\n    constexpr int CCW_ON_SEGMENT = 0; // A->C->B\n \n    inline int ccw(Point a, Point b, Point c){\n        Vec v = b-a, w = c-a;\n        if(ge(v^w, 0)) return CCW_COUNTER_CLOCKWISE;\n        if(le(v^w, 0)) return CCW_CLOCKWISE;\n        if(le(v*w, 0)) return CCW_ONLINE_BACK;\n        if(le((a-b)*(c-b), 0)) return CCW_ONLINE_FRONT;\n        return CCW_ON_SEGMENT;\n    }\n\n    bool is_parallel(Vec v, Vec w){\n        return eq(v^w, 0);\n    }\n\n    bool is_orthogonal(Vec v, Vec w){\n        return eq(v*w, 0);\n    }\n\n    bool has_intersection_ls(Point p, Vec v, Point a, Point b){\n        return sgn(v^(a-p)) * sgn(v^(b-p)) <= 0;\n    }\n\n    bool has_intersection_ss(Point a, Point b, Point c, Point d){\n        return ccw(a, b, c)*ccw(a, b, d) <= 0 && ccw(c, d, a)*ccw(c, d, b) <= 0;\n    }\n\n    Point intersection_ll(Point a, Vec v, Point b, Vec w){\n        real_num t = ((b-a)^w) / (v^w);\n        return a + v*t;\n    }\n\n    real_num distance_lp(Point a, Vec v, Point p){\n        return abs(v^(p-a)/abs(v));\n    }\n\n    real_num distance_sp(Point a, Point b, Point p){\n        if(le((b-a)*(p-a), 0)) return abs(p-a);\n        if(le((a-b)*(p-b), 0)) return abs(p-b);\n        return distance_lp(a, b-a, p);\n    }\n\n    real_num distance_ll(Point a, Vec v, Point b, Vec w){\n        if(is_parallel(v, w)) return distance_lp(a, v, b);\n        return 0;\n    }\n\n    real_num distance_ls(Point p, Vec v, Point a, Point b){\n        if(has_intersection_ls(p, v, a, b)) return 0;\n        return min(distance_lp(p, v, a), distance_lp(p, v, b));\n    }\n\n    real_num distance_ss(Point a, Point b, Point c, Point d){\n        if(has_intersection_ss(a, b, c, d)) return 0;\n        return min({distance_sp(a, b, c), distance_sp(a, b, d),\n                distance_sp(c, d, a), distance_sp(c, d, b)});\n    }\n\n    real_num area(Polygon &p){\n        real_num ret = 0;\n        rep(i, p.size()) ret += p[i] ^ p[(i+1)%p.size()] / 2;\n        return abs(ret);\n    }\n\n    bool is_convex(Polygon &p){\n        int n = p.size();\n        bool flag1 = false, flag2 = false;\n        rep(i, n){\n            int tmp = ccw(p[(i+n-1)%n], p[i], p[(i+1)%n]);\n            if(tmp == CCW_COUNTER_CLOCKWISE){\n                if(flag2) return false;\n                flag1=true;\n            }\n            else if(tmp == CCW_CLOCKWISE){\n                if(flag1) return false;\n                flag2 = true;\n            }\n        }\n        return true;\n    }\n\n    int point_in_polygon(Point a, Polygon &p){\n        int n = p.size(), wn = 0;\n        rep(i, n){\n            int j = (i+1) % n;\n            if(distance_sp(p[i], p[j], a) == 0) return 1;\n            else if(p[i].y <= a.y && a.y < p[j].y){\n                wn += (ccw(a, p[i], p[j]) == CCW_COUNTER_CLOCKWISE);\n            }\n            else if(p[j].y <= a.y && a.y < p[i].y){\n                wn -= (ccw(a, p[i], p[j]) == CCW_CLOCKWISE);\n            }\n        }\n        return wn == 0 ? 0 : 2;\n    }\n\n    Polygon convex_hull(Points p){\n        int n = p.size();\n        sort(p.begin(), p.end());\n        Polygon ch(2*n);\n        int k = 0;\n        rep(i, n){\n            while(k>1 && le((ch[k-1]-ch[k-2])^(p[i]-ch[k-1]), 0)) --k;\n            ch[k++] = p[i];\n        }\n        for(int i=n-2, t=k; i>=0; --i){\n            while(k>t && le((ch[k-1]-ch[k-2])^(p[i]-ch[k-1]), 0)) --k;\n            ch[k++] = p[i];\n        }\n        ch.resize(k-1);\n        return ch;\n    }\n\n    pair<real_num, pii> farthest_pair(Polygon &p){\n        int n = p.size();\n        if(n == 2){\n            return {abs(p[0]-p[1]), {0, 1}};\n        }\n        int i = 0, j = 0;\n        rep(k, n){\n            if(le(p[k].x, p[i].x)) i = k;\n            if(ge(p[k].x, p[j].x)) j = k;\n        }\n        real_num d = 0;\n        int a = i, b = j, si = i, sj = j;\n        while(i != sj || j != si){\n            if(chmax(d, abs(p[i]-p[j]))) a = i, b = j;\n            if(le((p[(i+1)%n]-p[i]) ^ (p[(j+1)%n]-p[j]), 0)){\n                i = (i+1) % n;\n            }\n            else j = (j+1) % n;\n        }\n        return {d, {a, b}};\n    }\n\n    real_num convex_cut(Polygon &p, Point a, Vec v){\n        int n = p.size();\n        Polygon q;\n        rep(i, n){\n            int j = (i+1) % n;\n            if(geq(v^(p[i]-a), 0)) q.push_back(p[i]);\n            if(has_intersection_ls(a, v, p[i], p[j]) && !is_parallel(v, p[j]-p[i])){\n                q.push_back(intersection_ll(a, v, p[i], p[j]-p[i]));\n            }\n        }\n        return area(q);\n    }\n\n    pair<real_num, pii> closest_pair_rec(vector<pair<Point, int>> &p, int l, int r){\n        if(r-l <= 1) return {INF, {p.size(), p.size()}};\n\n        int m = (l+r) / 2;\n        real_num x = p[m].fi.x;\n        auto d = min(closest_pair_rec(p, l, m), closest_pair_rec(p, m, r));\n        auto cmp = [](pair<Point, int> a, pair<Point, int> b){return a.fi.y < b.fi.y;};\n        inplace_merge(p.begin()+l, p.begin()+m, p.begin()+r, cmp);\n\n        vector<pair<Point, int>> q;\n        For(i, l, r){\n            if(ge(abs(p[i].fi.x-x), d.fi)) continue;\n            rrep(j, q.size()){\n                real_num dx = p[i].fi.x - q[j].fi.x;\n                real_num dy = p[i].fi.y - q[j].fi.y;\n                if(geq(dy, d.fi)) break;\n                chmin(d, {abs(p[i].fi-q[j].fi), {p[i].se, q[j].se}});\n            }\n            q.push_back(p[i]);\n        }\n        return d;\n    }\n\n    pair<real_num, pii> closest_pair(Points &p){\n        vector<pair<Point, int>> pid(p.size());\n        rep(i, p.size()) pid[i] = {p[i], i};\n        sort(pid.begin(), pid.end());\n        return closest_pair_rec(pid, 0, p.size());\n    }\n\n    int has_intersection_cc(Point c1, real_num r1, Point c2, real_num r2){\n        if(r1 < r2){\n            swap(c1, c2);\n            swap(r1, r2);\n        }\n        real_num d = abs(c1-c2), r = r1 + r2;\n        if(ge(d, r)) return 4;\n        if(eq(d, r)) return 3;\n        if(eq(d+r2, r1)) return 1;\n        if(le(d+r2, r1)) return 0;\n        return 2;\n    }\n\n    bool has_intersection_cl(Point c, real_num r, Point a, Vec v){\n        return leq(distance_lp(a, v, c), r);\n    }\n\n    bool has_intersection_cs(Point c, real_num r, Point a, Point b){\n        return leq(distance_sp(a, b, c), r) && geq(max(abs(a-c), abs(b-c)), r);\n    }\n\n    Points intersection_cl(Point c, real_num r, Point a, Vec v){   \n        Points ps;\n        if(!has_intersection_cl(c, r, a, v)) return ps;\n        Point p = proj(a, v, c);\n        real_num t = sqrt(max((real_num)0.0, (r*r-norm(p-c)) / norm(v)));\n        ps.push_back(p + v*t);\n        if(!eq(t, 0)) ps.push_back(p - v*t);\n        return ps;\n    }\n\n    Points intersection_cc(Point c1, real_num r1, Point c2, real_num r2){\n        Points ps;\n        Vec v = c2-c1, w = {v.y*-1, v.x};\n        real_num d = abs(v);\n        real_num x = (d*d + r1*r1 - r2*r2) / (2*d);\n        real_num y = sqrt(max(r1*r1-x*x, (real_num)0.0));\n        ps.push_back(c1 + v*x/d + w*y/d);\n        if(has_intersection_cc(c1, r1, c2, r2)!=2) return ps;\n        ps.push_back(c1 + v*x/d - w*y/d);\n        return ps;\n    }\n\n    real_num commn_area_cc(Point c1, real_num r1, Point c2, real_num r2){\n        int flag = has_intersection_cc(c1, r1, c2, r2);\n        if(flag >= 3) return 0;\n        if(flag <= 1){\n            real_num r = min(r1, r2);\n            return PI*r*r;\n        }\n        real_num d = abs(c1-c2);\n        real_num ret = 0;\n        rep(i, 2) {\n            real_num x = (d*d + r1*r1 - r2*r2) / (2*d);\n            real_num t = acos(x/r1)* 2;\n            ret += (t-sin(t))*r1*r1/2;\n            swap(c1, c2);\n            swap(r1, r2);\n        }\n        return ret;\n    }\n\n    Points tangent(Point c, real_num r, Point p){\n        Points ps;\n        real_num d = abs(p-c);\n        real_num t = acos(r/d);\n        ps.push_back(c + rot(p-c, t)*r/d);\n        ps.push_back(c + rot(p-c, -t)*r/d);\n        return ps;\n    }\n\n    Points common_tangent(Point c1, real_num r1, Point c2, real_num r2){       \n        Points ps;\n        int flag = has_intersection_cc(c1, r1,c2, r2);\n        if(flag >= 2){\n            real_num d = abs(c2-c1);\n            real_num t = acos(abs(r1-r2)/d);\n            if(le(r1, r2)) t = PI-t;\n            ps.push_back(c1 + rot(c2-c1, t)*r1/d);\n            ps.push_back(c1 + rot(c2-c1, -t)*r1/d);\n        }\n        if(flag == 4){\n            real_num d = abs(c2-c1);\n            real_num L = d*r1/(r1+r2);\n            real_num t = acos(r1/L);\n            ps.push_back(c1 + rot(c2-c1, t)*r1/d);\n            ps.push_back(c1 + rot(c2-c1, -t)*r1/d);\n        }\n        if(flag == 3 || flag == 1){\n            Polygon tg = intersection_cc(c1, r1, c2, r2);\n            ps.push_back(tg[0]);\n        }\n        return ps;\n    }\n\n    Point get_o(Point a, Point b, Point c){\n        Point M = (a+b)/2, N = (a+c)/2;\n        Vec v = {-(b-a).y, (b-a).x}, w = {-(c-a).y, (c-a).x};\n        return intersection_ll(M, v, N, w);\n    }\n\n    Point get_i(Point a, Point b, Point c){\n        real_num A = abs(b-c), B = abs(c-a), C = abs(a-b);\n        return (a*A+b*B+c*C)/(A+B+C);\n    }\n\n    Point get_h(Point a, Point b, Point c){\n        Vec v = {-(c-b).y, (c-b).x}, w = {-(c-a).y, (c-a).x};\n        return intersection_ll(a, v, b, w);\n    }\n\n    pair<Point, real_num> minimum_bounding_circle(Points &p){\n        Point C;\n        real_num r;\n        if(p.size() == 1) C = p[0], r = 0;\n        else if(p.size() == 2) C = (p[0]+p[1])/2, r = abs(p[0]-C);\n        else{\n            r = INF;\n            Points ch = convex_hull(p);\n            int K = ch.size();\n            auto check = [&](Point tc, real_num tr){\n                rep(i, K){\n                    if(ge(abs(ch[i]-tc), tr)) return false;\n                }\n                return true;\n            };\n            rep(i, K)For(j, i+1, K){\n                Point tc = (ch[i]+ch[j])/2;\n                real_num tr = abs(ch[i]-tc);\n                if(check(tc, tr) && chmin(r, tr)) C = tc;\n                For(k, j+1, K){\n                    int ccw_flag = ccw(ch[i], ch[j], ch[k]);\n                    if(ccw_flag != CCW_COUNTER_CLOCKWISE && ccw_flag != CCW_CLOCKWISE) continue;\n                    tc = get_o(ch[i], ch[j], ch[k]);\n                    tr = abs(ch[i]-tc);\n                    if(check(tc, tr) && chmin(r, tr)) C=tc;\n                }\n            }\n        }\n        return {C, r};\n    }\n}\n\nusing namespace geo;\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    Points p(n);\n    rep(i, n) scanf(\"%lf%lf\", &p[i].x, &p[i].y);\n    printf(\"%.10lf\\n\", closest_pair(p).fi);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 200010\n#define int long long\n#define ld long double\n#define inf 2147483647\nusing namespace std;\n\nstruct point{\n  ld x , y;\n}now[MAXN] , forL[MAXN] , forR[MAXN] , t[MAXN];\nint N;\n\nbool cmp(point a , point b){\n  return a.x < b.x;\n}\n\nld solve(int l , int r){\n  if(l == r)\n    return inf;\n  int mid = l + r >> 1;\n  ld dir = (now[mid].x + now[mid + 1].x) / 2 , d1 = solve(l , mid) , d2 = solve(mid + 1 , r) , d = min(d1 , d2);\n  int cntL = 0 , cntR = 0;\n  for(int i = l ; i <= mid ; i++)\n    if(dir - now[i].x <= d)\n      forL[++cntL] = now[i];\n  for(int i = mid + 1 ; i <= r ; i++)\n    if(now[i].x - dir <= d)\n      forR[++cntR] = now[i];\n  int k = 1;\n  for(int i = 1 ; i <= cntL ; i++){\n    while(k <= cntR && forL[i].y - forR[k].y > d)\n      k++;\n    for(int j = k ; j <= cntR && forR[j].y - forL[i].y <= d ; j++)\n      d = min(sqrt((forR[j].x - forL[i].x) * (forR[j].x - forL[i].x) + (forR[j].y - forL[i].y) * (forR[j].y - forL[i].y)) , d);\n  }\n  int p1 = l , p2 = mid + 1 , p3 = l;\n  while(p1 <= mid && p2 <= r)\n    if(now[p1].y < now[p2].y)\n      t[p3++] = now[p1++];\n    else\n      t[p3++] = now[p2++];\n  while(p1 <= mid)\n    t[p3++] = now[p1++];\n  while(p2 <= r)\n    t[p3++] = now[p2++];\n  for(int i = l ; i <= r ; i++)\n    now[i] = t[i];\n  return d;\n}\n\nmain(){\n  cin >> N;\n  for(int i = 1 ; i <= N ; i++)\n    cin >> now[i].x >> now[i].y;\n  sort(now + 1 , now + N + 1 , cmp);\n  cout << fixed << setprecision(9) << solve(1 , N);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\ntypedef complex<double> point;\ntypedef vector<point> vertex;\n/*\nx 座標は p.real(), real(p), y 座標は p.imag(), imag(p) とする．\n足し算，引き算，スカラー倍は定義済み．\noperator < は入っていないので自分で namespace std に突っ込む．*/\nnamespace std{\n\tbool operator < (const point &lhs,const point &rhs){\n\t\tif(real(lhs) == real(rhs)){\n\t\t\treturn imag(lhs) < imag(rhs);\n\t\t}else{\n\t\t\treturn real(lhs) < real(rhs);\n\t\t}\n\t}\n}\n// 線分と点との距離\ndouble dist_linesegment_and_point(point a1,point a2,point b);\n\n\n\n// ベクタの長さ\ndouble vector_length(point a){\n\treturn abs(a);\n}\n\n// 二点間距離\ndouble point_distance(point a,point b){\n\treturn abs(a-b);\n}\n\n// 単位ベクトル\npoint unit_vector(point a){\n\treturn a / abs(a);\n}\n\n// 法線ベクトル\npair<point,point> normal_vector(point a){\n\tpoint n1 = a * point(0,1);\n\tpoint n2 = a * point(0,-1);\n\treturn make_pair(n1,n2);\n}\n\n// 点が一緒かどうか\nbool point_eq(point a,point b){\n\treturn abs(a-b) < EPS;\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n\treturn real(conj(a)*b);\n}\n\n// 外積 (cross product) : |a×b| = |a||b|sinΘ\ndouble cross(point a,point b){\n\treturn imag(conj(a)*b);\n}\n//ラジアンに変換\ndouble radian(double angle){\n\treturn angle/180.0*M_PI;\n}\n//度数に変換\ndouble degree(double radian){\n\treturn radian*180.0/M_PI;\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(point a1,point a2,point b1,point b2){\n\tif(max(a1.real(),a2.real()) + EPS < min(b1.real(),b2.real())) return false;\n\tif(max(b1.real(),b2.real()) + EPS < min(a1.real(),a2.real())) return false;\n\tif(max(a1.imag(),a2.imag()) + EPS < min(b1.imag(),b2.imag())) return false;\n\tif(max(b1.imag(),b2.imag()) + EPS < min(a1.imag(),a2.imag())) return false;\n\treturn (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) < EPS) and\n\t(cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < EPS);\n\n}\n\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(point a1,point a2,point b1,point b2) {\n\tif(a1 == b1 or a1 == b2) return a1;\n\tif(a2 == b1 or a2 == b2) return a2;\n\tpoint b = b2-b1;\n\tdouble d1 = abs(cross(b, a1-b1));\n\tdouble d2 = abs(cross(b, a2-b1));\n\tdouble t = d1 / (d1 + d2);\n\treturn a1 + (a2-a1) * t;\n}\n\n// 線分同士の最短距離\ndouble dist_linesegment_and_linesegment(point a1,point a2,point b1,point b2){\n\tif(is_intersected_linesegment(a1,a2,b1,b2)){\n\t\treturn 0;\n\t}\n\treturn min(min(dist_linesegment_and_point(a1,a2,b1),\n\t           dist_linesegment_and_point(a1,a2,b2)),\n\tmin(dist_linesegment_and_point(b1,b2,a1),\n\t    dist_linesegment_and_point(b1,b2,a2)));\n}\n\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n// verify\nbool is_orthogonal(point a1,point a2,point b1,point b2) {\n\treturn abs(dot(a1-a2,b1-b2))< EPS;\n}\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\n//verify\nbool is_parallel(point a1,point a2,point b1,point b2) {\n\treturn abs(cross(a2-a1,b2-b1)) < EPS;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool is_intersected_line(point a1,point a2,point b1,point b2) {\n\treturn not is_parallel(a1,a2,b1,b2);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\npoint intersection_line(point a1,point a2,point b1,point b2) {\n\tpoint a = a2 - a1,b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\n// 直線と点との距離\ndouble dist_line_and_point(point a1,point a2,point b){\n\treturn abs(cross(a2-a1,b-a1)) / abs(a2-a1);\n}\n\n// 線分と点との距離\ndouble dist_linesegment_and_point(point a1,point a2,point b){\n\tif(dot(a2-a1,b-a1) < EPS) return abs(b-a1);\n\tif(dot(a1-a2,b-a2) < EPS) return abs(b-a2);\n\treturn dist_line_and_point(a1,a2,b);\n}\n\n// 直線と点の最短距離を実現する直線の点(すいせんの足)(みけんしょう)\npoint nearest_point_line_and_point(point a1,point a2,point b){\n\treturn a1 + (a2-a1) * dot((a2-a1),(b-a1)) / norm(a2-a1);\n}\n\n// 線分と点の最短距離を実現する線分嬢の点(みけんしょう)\npoint nearest_point_linesegment_and_point(point a1,point a2,point b){\n\tif(dot(a2-a1,b-a1) < EPS) return a1;\n\tif(dot(a1-a2,b-a2) < EPS) return a2;\n\treturn nearest_point_line_and_point(a1,a2,b);\n}\n// 円と線分の交差判定\nbool is_cross_linesegment_and_circle(point c,double r,point a1,point a2){\n\treturn (dist_linesegment_and_point(a1,a2,c) < r+EPS and\n\t        (r < abs(c-a1) + EPS or r < abs(c-a2) + EPS));\n}\n\n\n// 点の進行方向\nint ccw(point a,point b,point c){\n\tb -= a;c -= a;\n    if(cross(b,c) > 0) return +1;    // counter clockwise\n    if(cross(b,c) < 0) return -1;    // clockwise\n    if(dot(b,c) < 0) return +2;      // c -- a -- b\n    if(norm(b) < norm(c)) return -2; // a -- b -- c\n    return 0;\n}\n\n// 点が真に多角形(凸?)の中にはいっているか\nbool is_inner_point_vertex(const vector<point> &ps,point a){\n\tint cc = ccw(ps[0],ps[1],a);\n\tif(not(cc == 1 or cc == -1)) return false;\n\tfor(size_t i=0;i<ps.size();i++){\n\t\tif(cc != ccw(ps[i],ps[(i+1)%ps.size()],a)) return false;\n\t}\n\treturn true;\n}\n\n// 点が辺上、もしくは内部にある。(未検証)\nbool is_inner_point_vertex_or_line(const vector<point> &ps,point a){\n\tfor(size_t i=0;i<ps.size();i++){\n\t\tif(dist_linesegment_and_point(ps[i],ps[(i+1)%ps.size()],a) < EPS){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn is_inner_point_vertex(ps,a);\n}\n\n\n// 凸包 (UVA 109)\nvector<point> convex_hull(vector<point> ps){\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(),ps.end());\n\tvector<point> ch(2*n);\n\tfor(int i=0;i<n;ch[k++] = ps[i++]){\n\t\twhile(k >= 2 and ccw(ch[k-2],ch[k-1],ps[i]) <= 0) --k;\n\t}\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--]){\n\t\twhile(k >= t and ccw(ch[k-2],ch[k-1],ps[i]) <= 0) --k;\n\t}\n\tch.resize(k-1);\n\treturn ch;\n}\n\n// remember,pts make convex.\n// (http://judge.u-aizu.ac.jp/onlinejudge/cdescription.jsp?cid=ACAC002&pid=C)\ndouble convex_diameter(const vector<point>& pts){\n\tconst int n = pts.size();\n    int is=0,js=0; // initial antipode.\n    for(int i=1;i<n;i++){\n    \tif(pts[i].imag() > pts[is].imag()) is = i;\n    \tif(pts[i].imag() < pts[js].imag()) js = i;\n    }\n    double maxd = abs(pts[is]-pts[js]);\n    int i,j,maxi,maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n    \tif(cross(pts[(i+1)%n]-pts[i],\n    \t   pts[(j+1)%n]-pts[j]) >= 0){\n    \t\tj = (j+1)%n;\n    }else{\n    \ti = (i+1)%n;\n    }\n    if(abs(pts[i]-pts[j]) > maxd){\n    \tmaxd = abs(pts[i]-pts[j]);\n    \tmaxi = i;maxj = j;\n    }\n} while(not(i == is and j == js));\n    // pts[maxi],pts[maxj] is pair of max diff.\nreturn maxd;\n}\n\n// 円と円の交点(2点ある前提)\nvector<point> circles_point(point c1,double r1,point c2,double r2){\n\tdouble d = abs(c1-c2);\n\tdouble s = (r1+r2+d) / 2;\n\tdouble S = sqrt(s*(s-r1)*(s-r2)*(s-d));\n\tdouble h = 2 * S / d;\n\tpoint v = (c2-c1) / (abs(c2-c1));\n\n\tdouble m = sqrt(r1*r1 - h*h);\n\n\tvector<point> ret;\n\tret.push_back(c1 + m*v+h*v*point(0,1));\n\tret.push_back(c1 + m*v-h*v*point(0,1));\n\treturn ret;\n}\n\n// clockwiseだと負\ndouble triangle_area(point a,point b,point c){\n\treturn cross(b-a,c-a)/2;\n}\n\n// clockwiseだと負\ndouble vertex_area(vector<point> v){\n\tdouble ret = 0;\n\tfor(int i=1;i<v.size()-1;i++){\n\t\tret += triangle_area(v[0],v[i],v[i+1]);\n\t}\n\treturn ret;\n}\n/*多角形の面積を求める*/\n//verify\ndouble area_vertex(const vertex& g){\n\tdouble S =0;\n\tfor(int i =0;i <g.size();i++){\n\t\tS +=(cross(g[i],g[(i+1)%g.size()]));\n\t}\n\treturn abs(S/2.0);\n}\n//円同士が互いに含まれているかどうか\n//中心が(xa,ya)で半径r1の円Aと、中心が(xb,yb) で半径 r2 の円 B が与えられたとき、 B が A の中にあるとき 2、A が B の中にあるとき -2、A の円周と B の円周が交わっている場合 1、A と B が重なっていないとき 0 \n//verify\nint Circles_Intersection(point a,double r1,point b,double r2){\n\tdouble dp =abs(a-b);//中心間の距離\n\tdouble dr =r1+r2;//円の半径の合計\n\tif(dp >dr){\n\t\treturn 0;\n\t}else if(dp +r1 <r2){\n\t\treturn -2;\n\t}else if(dp +r2 <r1){\n\t\treturn 2;\n\t}else if(dp <=dr){\n\t\treturn 1;\n\t}\n\treturn -100;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvertex P;\n\tdouble ans = INF;\n\tfor(int i =0;i < n;i++){\n\t\tdouble x,y;\n\t\tcin>>x>>y;\n\t\tP.push_back(point(x,y));\n\t}\n\tfor(int i =0;i <P.size();i++){\n\t\tfor(int j =i+1;j <P.size();j++){\n\t\t\tdouble tmp =abs(P[i]-P[j]);\n\t\t\tans =min(ans,tmp);\n\t\t}\n\t}\n\tprintf(\"%.8f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\n\nint main(){\n\tint n;\n\tdouble *x,*y;\n\tdouble min = 80000;\n\t\n\tcin>>n;\n\tx = new double[n];\n\ty = new double[n];\n\tfor(int i=0;i<n;++i){\n\t\tcin>>x[i]>>y[i];\n\t}\n\t\n\tfor(int i=0;i<n;++i){\n\t\tfor(int j=i+1;j<n;++j){\n\t\t\tdouble dx = x[i]-x[j],dy = y[i]-y[j];\n\t\t\tdouble l = dx*dx+dy*dy;\n\t\t\tif(l<min)min=l;\n\t\t}\n\t}\n\tcout<<fixed<<setprecision(6)<<sqrt(min)<<endl;\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\n/*\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    //two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n\n    two_dimensional_qsort(p_xy, n0, n-1, 1);\n\n    \n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n*/\nbool compare_y(pair<double, double> a,pair<double, double> b){\n    return a.second<b.second;\n}\n\ndouble length_of_the_nearest_point_to(pair<double, double> a[100000], int n){\n    if(n<=1)return 999999999.9;\n    int m=n/2;\n    double x=a[m].first;\n    double d=min(length_of_the_nearest_point_to(a, m), length_of_the_nearest_point_to(a+m, n-m));\n    inplace_merge(a, a+m, a+n, compare_y);\n    vector<pair<double, double>>b;\n    for(int i=0; i<n; i++){\n        if(fabs(a[i].first-x)>=d)continue;\n        for(int j=0; j<b.size(); j++){\n            double dx=a[i].first-b[b.size()-j-1].first;\n            double dy=a[i].second-b[b.size()-j-1].second;\n            if(dy>=d)break;\n            d=min(d,sqrt(dx*dx+dy*dy));\n            \n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n                                      \n                                      \n                                      \nint main(int argc, const char * argv[]){\n    int n;\n    while(cin>>n){\n        pair<double, double> a[100000];\n        for(int i=0; i<n; i++){\n            cin>>a[i].first>>a[i].second;\n        }\n        sort(a, a+n);\n        double ans = length_of_the_nearest_point_to(a, n);\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n    /*\n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        //cout<<\"qaaa\";\n        two_dimensional_qsort(p_xy, 0, n-1, 0);\n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n     */\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <float.h>\n#include <iostream>\n#include <iomanip>\n#include <limits.h>\n#include <map>\n#include <queue>\n#include <set>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\n\nstruct Point {\n  double y;\n  double x;\n\n  Point(double y = -1, double x = -1) {\n    this->y = y;\n    this->x = x;\n  }\n};\n\nbool compareY(const Point &p1, const Point &p2) {\n  return p1.y < p2.y;\n}\n\nbool compareX(const Point &p1, const Point &p2) {\n  return p1.x < p2.x;\n}\n\ndouble closestPair(Point *points, int n) {\n  if (n <= 1) return DBL_MAX;\n\n  int m = n / 2;\n  double x = points[m].x;\n  double d = min(closestPair(points, m), closestPair(points + m, n - m));\n  inplace_merge(points, points + m, points + n, compareY);\n\n  vector<Point> b;\n  for (int i = 0; i < n; ++i) {\n    if (fabs(points[i].x - x) >= d) continue;\n\n    for (int j = 0; j < b.size(); ++j) {\n      double dx = points[i].x - b[b.size() - j - 1].x;\n      double dy = points[i].y - b[b.size() - j - 1].y;\n\n      if (dy >= d) break;\n      d = min(d, sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(points[i]);\n  }\n\n  return d;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  Point points[N];\n\n  double x, y;\n  for (int i = 0; i < N; ++i) {\n    cin >> x >> y;\n    points[i] = Point(y, x);\n  }\n\n  sort(points, points + N, compareX);\n\n  cout << fixed << setprecision(10) << closestPair(points, N) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\n\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  // if (r - l <= 3) {\n  //   PointPoint res(ps[l], ps[r - 1]);\n  //   for (int i = l; i < r; ++i) {\n  //     for (int j = i + 1; j < r; ++j) {\n  //       res = Closer(res, PointPoint(ps[i], ps[j]));\n  //     }\n  //   }\n  //   return res;\n  // }\n  if (r - l == 2) {\n    return PointPoint(ps[l], ps[l + 1]);\n  }\n  if (r - l == 3) {\n    PointPoint a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return Closer(a, Closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  // Points lp, rp;\n  // for (int i = l; i < mid; ++i) {\n  //   if (abs(ps[i].real() - midPoint.real()) < d) lp.push_back(ps[i]);\n  // }\n  // for (int i = mid; i < r; ++i) {\n  //   if (abs(ps[i].real() - midPoint.real()) < d) rp.push_back(ps[i]);\n  // }\n  // for (int i = 0; i < lp.size(); ++i) {\n  //   for (int j = 0; j < rp.size(); ++j) {\n  //     if (Distance(lp[i], rp[j]) < d) {\n  //       d = Distance(lp[i], rp[j]);\n  //       res = PointPoint(lp[i], rp[j]);\n  //     }\n  //   }\n  // }\n\n  Points pos[2];\n  for (int i = l; i < r; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) pos[i < mid].push_back(ps[i]);\n  }\n  for (int i = 0; i < pos[0].size(); ++i) {\n    for (int j = 0; j < pos[1].size(); ++j) {\n      if (Distance(pos[0][i], pos[1][j]) < d) {\n        d = Distance(pos[0][i], pos[1][j]);\n        res = PointPoint(pos[0][i], pos[1][j]);\n      }\n    }\n  }\n  // Points strip;\n  // for (int i = l; i < r; ++i) {\n  //   if (abs(ps[i].real() - midPoint.real()) < d) strip.push_back(ps[i]);\n  // }\n  // for (int i = 0; i < strip.size(); ++i) {\n  //   for (int j = i + 1; j < strip.size(); ++j) {\n  //     if (Distance(strip[i], strip[j]) < d) {\n  //       d = Distance(strip[i], strip[j]);\n  //       res = PointPoint(strip[i], strip[j]);\n  //     }\n  //   }\n  // }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  return ClosestPairUtil(ps, 0, ps.size());\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  sort(p.begin(), p.end());\n  PointPoint pp = ClosestPair(p);\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n  // cerr << pp.first << \" \" << pp.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nconst int M = 100007;\nconst double INF = 1e50;\n\nstruct PT {double x, y;};\nbool cmp(PT a, PT b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\nbool cmp_y(PT a, PT b)\n{\n\treturn a.y < b.y;\n}\nPT a[M];\ndouble Dis(PT a, PT b)\n{\n\tdouble x = b.x - a.x;\n\tdouble y = b.y - a.y;\n\treturn sqrt(x*x + y*y);\n}\n\ndouble Closest_pair(PT *a, int n)\n{\n\tif (n == 1)  return INF;\n\t\n\tdouble d = INF;\n\tint m = n/2;\n\td = min(Closest_pair(a, m), Closest_pair(a+m, n-m));\n\t\n\t// 接下来讨论在中间的情况\n\tdouble mx = a[m].x;\n\tvector<PT> b;\n\tfor (int i = m; i >= 0; --i)\n\t{\n\t\tif (fabs(a[i].x - mx) > d) \tbreak;\n\t\telse \t\t\t\t\t\tb.push_back(a[i]);\n\t}\n\tfor (int i = m+1; i < n; ++i)\n\t{\n\t\tif (fabs(a[i].x - mx) > d)\tbreak;\n\t\telse \t\t\t\t\t\tb.push_back(a[i]);\n\t}\n\tsort(b.begin(), b.end(), cmp_y);\n\t\n\tfor (int i = 0; i < b.size(); ++i)\n\t{\n\t\tfor (int j = i+1; fabs(b[j].y - b[i].y) < d && j < b.size(); ++j)\n\t\t{\n\t\t\tdouble dis = Dis(b[i], b[j]);\n\t\t\tif (dis < d) d = dis;\n\t\t}\n\t}\n\t\n\t\n\treturn d;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%lg %lf\", &a[i].x, &a[i].y);\n\t\n\tsort(a, a+n, cmp);\n\tprintf(\"%7f\", Closest_pair(a, n));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing db = double;\nconst db Inf = 1e18L;\n\nstruct poi {\n\tdb x, y;\n\tpoi operator -(poi p) {\n\t\treturn {x - p.x, y - p.y};\n\t}\n\tbool operator <(poi p) const {\n\t\treturn tie(x, y) < tie(p.x, p.y);\n\t}\n\tdb len2() {\n\t\treturn x * x + y * y;\n\t}\n};\n\nusing vp = vector <poi>;\ndb solve(poi *p, int l, int r) {\n\tif(l + 1 == r) return Inf;\n\tint m = (l + r) / 2; db mx = p[m].x; vector <poi> v;\n\tdb ret = min(solve(p, l, m), solve(p, m, r));\n\tfor(int i = l; i < r; i ++)\n\t\tif(poi{p[i].x - mx, 0}.len2() < ret)\n\t\t\tv.push_back(p[i]);\n\tsort(v.begin(), v.end(), [](poi a, poi b) {\n\t\treturn tie(a.y, a.x) < tie(b.y, b.x); });\n\tfor(int i = 0; i < v.size(); i ++)\n\t\tfor(int j = i + 1; j < v.size(); j ++) {\n\t\t\tif(poi{0, v[i].y - v[j].y}.len2() > ret) break;\n\t\t\tret = min(ret, (v[i] - v[j]).len2());\n\t\t}\n\treturn ret;\n} // ?????????p[]????????????\n\nconst int N = 1e5L + 11;\npoi p[N];\n\nint main() {\n\tios :: sync_with_stdio(false);\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i ++)\n\t\tcin >> p[i].x >> p[i].y;\n\tsort(p, p + n);\n\tdb ans = solve(p, 0, n);\n\tcout << fixed << setprecision(9) << sqrt(ans) << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct node{\n  int dim;\n  vector<double>v;\n};\n\ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n\ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n\n  vector<node>res;\n\n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n\n    double dist=d(p,S)/(4*p.dim);\n\n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n\n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    \n    S=nextS;    \n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n  \n  return ans;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n\n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define numa(x,a) for(auto x: a)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define pf push_front\n#define sec second\n#define sz(x) ((int)(x).size())\n#define ALL( c ) (c).begin(), (c).end()\n#define gcd(a,b) __gcd(a,b)\n#define mem(x,n) memset(x,n,sizeof(x))\n#define endl \"\\n\"\nusing namespace std;\ntemplate <int POS, class TUPLE> void deploy(std::ostream &os, const TUPLE &tuple){}\ntemplate <int POS, class TUPLE, class H, class ...Ts> void deploy(std::ostream &os, const TUPLE &t){ os << (POS == 0 ? \"\" : \", \") << get<POS>(t); deploy<POS + 1, TUPLE, Ts...>(os, t); }\ntemplate <class T,class U> std::ostream& operator<<(std::ostream &os, std::pair<T,U> &p){ os << \"(\" << p.first <<\", \" << p.second <<\")\";return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::vector<T> &v){ int remain = v.size(); os << \"{\"; for(auto e: v) os << e << (--remain == 0 ? \"}\" : \", \"); return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::set<T> &v){ int remain = v.size(); os << \"{\"; for(auto e: v) os << e << (--remain == 0 ? \"}\" : \", \"); return os; }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::map<T, K> &mp){ int remain = mp.size(); os << \"{\"; for(auto e: mp) os << \"(\" << e.first << \" -> \" << e.second << \")\" << (--remain == 0 ? \"}\" : \", \"); return os; }\n#define DEBUG1(var0) { std::cerr << (#var0) << \"=\" << (var0) << endl; }\n#define DEBUG2(var0, var1) { std::cerr << (#var0) << \"=\" << (var0) << \", \";DEBUG1(var1); }\n#define DEBUG3(var0, var1, var2) { std::cerr << (#var0) << \"=\" << (var0) << \", \";DEBUG2(var1,var2); }\n#define DEBUG4(var0, var1, var2, var3) { std::cerr << (#var0) << \"=\" << (var0) << \", \";DEBUG3(var1,var2,var3); }\nusing ll = long long;\n\ntypedef struct P{\n  long double x;\n  long double y;\n}P_t;\n\ninline long double dist(const P_t &a, const P_t &b) {\n  return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\npair <pair <int, int>, long double> closest_pair(const vector <int> &xi, const vector <int> &yi, const vector <P_t> &ps){//note that xi and yi must be sorted by x and y, respectively\n  assert(xi.size() == yi.size());\n  if (xi.size() == 1) {\n    return make_pair(mp(-1,-1), -1);\n  }\n  if (xi.size() == 2) {\n    return make_pair(mp(xi[0], xi[1]), dist(ps[xi[0]], ps[xi[1]]));\n  }\n\n  int med = xi.size() / 2;\n  vector <int> lxi(xi.begin(), xi.begin() + med);\n  vector <int> lyi(lxi.size());\n  vector <int> rxi(xi.begin() + med, xi.end());\n  vector <int> ryi(rxi.size());\n\n  set <int> lxis(xi.begin(), xi.begin() + med);\n\n  for (int i = 0, cnt1 = 0, cnt2 = 0; i < yi.size(); i++) {\n    if (lxis.find(yi[i]) != lxis.end()) {\n      lyi[cnt1++] = yi[i];\n    }else{\n      ryi[cnt2++] = yi[i];\n    }\n  }\n  //DEBUG4(lxi, lyi, rxi, ryi);\n  pair <pair <int, int>, long double> ansl = closest_pair(lxi, lyi, ps);\n  pair <pair <int, int>, long double> ansr = closest_pair(rxi, ryi, ps);\n  long double dl = ansl.second;\n  long double dr = ansr.second;\n  long double d;\n  pair <int,int> ansp;\n  if (dl > 0 && dl < dr) {\n    d = dl;\n    ansp = ansl.first;\n  }else{\n    d = dr;\n    ansp = ansr.first;\n  }\n  long double medx = (ps[lxi.back()].x + ps[rxi.front()].x) / 2.0;\n  vector <int> cands;\n  for (int i: yi) {\n    if (medx - 2 * d <= ps[i].x && ps[i].x <= medx + 2 * d) {\n      cands.push_back(i);\n    }\n  }\n  for (int i = 0; i < cands.size(); i++) {\n    for (int j = i + 1; j < cands.size(); j++) {\n      if (ps[cands[j]].y - ps[cands[i]].y > 2 * d) {\n        break;\n      }\n      long double d2 = dist(ps[cands[j]], ps[cands[i]]);\n      if (d2 < d) {\n        ansp = make_pair(cands[j], cands[i]);\n        d = d2;\n      }\n    }\n  }\n  return make_pair(ansp, d);\n}\n\nint main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  int N;\n  cin >> N;\n  std::vector <P_t> ps(N);\n  std::vector <pair <long double, int> > xi_(N);\n  std::vector <pair <long double, int> > yi_(N);\n  for (int i = 0; i < N; i++) {\n    cin >> ps[i].x >> ps[i].y;\n    xi_[i].first = ps[i].x;\n    xi_[i].second = i;\n    yi_[i].first = ps[i].y;\n    yi_[i].second = i;\n  }\n  sort(xi_.begin(), xi_.end());\n  sort(yi_.begin(), yi_.end());\n  std::vector <int> xi(N);\n  std::vector <int> yi(N);\n  for (int i = 0; i < N; i++) {\n    xi[i] = xi_[i].second;\n    yi[i] = yi_[i].second;\n  }\n  pair <pair <int, int> , long double> ans = closest_pair(xi, yi, ps);\n  /*\n  if (ans.first.first > ans.first.second) {\n    cout << ans.first.second << ' ' << ans.first.first << ' ';\n  }else{\n    cout << ans.first.first << ' ' << ans.first.second << ' ';\n  }\n  */\n  cout << fixed << setprecision(10)<< ans.second << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\n\nconst double eps = 1e-10;\nconst double inf = 1e+10;\nconst double pi = acos(-1.0);\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}  \n  double norm() {return sqrt(x*x + y*y);}\n};\n\nPoint operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\nPoint operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ndouble operator * (const Point &p, const Point q) {return p.x * q.x + p.y * q.y;}\nbool operator == (const Point &p, const Point &q) {return (abs(p.x - q.x) < eps && abs(p.y - q.y) < eps);}\nbool operator != (const Point &p, const Point &q) {return !(p == q);}\ndouble cross(const Point &p, const Point &q) {return p.x*q.y - p.y*q.x;}\ndouble dist(const Point &p, const Point &q) {return (p-q).norm();}\nbool compx(const Point &p, const Point &q) {return p.x != q.x? p.x < q.x : p.y < q.y;}\nbool compy(const Point &p, const Point &q) {return p.y != q.y? p.y < q.y : p.x < q.x;}\n\nstruct Segment {\n  Point p , q;\n  Segment(Point p = Point(0.0,0.0), Point q = Point(0.0,0.0)) : p(p), q(q) {}\n};\n\nstruct Line {\n  double a, b, c;\n  Line(double a, double b, double c) : a(a), b(b), c(c) {}\n  Line(Point p, Point q) {\n    a = q.y - p.y;\n    b = p.x - q.x;\n    c = q.x * p.y - p.x * q.y;\n  }\n};\n\nstruct Circle {\n  double r;\n  Point p;\n  Circle(Point p = Point(0.0, 0.0), double r = 0.0) : p(p), r(r) {}\n};\n\n// 点の直線への射影\nPoint projection (Point p, Line l) {\n  double x = p.x - l.a * (l.a*p.x + l.b*p.y + l.c) / (l.a*l.a + l.b*l.b);\n  double y = p.y - l.b * (l.a*p.x + l.b*p.y + l.c) / (l.a*l.a + l.b*l.b);\n  return Point(x,y);\n}\n\n// 線対称な点\nPoint reflection(Point p, Line l) {\n  double x = p.x - 2.0 * l.a * (l.a*p.x + l.b*p.y + l.c) / (l.a*l.a + l.b*l.b);\n  double y = p.y - 2.0 * l.b * (l.a*p.x + l.b*p.y + l.c) / (l.a*l.a + l.b*l.b);\n  return Point(x,y);\n}\n\n// 点の線分からの回転方向\nint ccw(Point p, Point p1, Point p2) {\n  p1 = p1 - p; p2 = p2 - p;\n  if(cross(p1,p2) > eps) return 1; \n  if(cross(p1,p2) < -eps) return -1; \n  if(p1 * p2 < 0) return 2; \n  if(p1.norm() < p2.norm()) return -2; \n  return 0; \n}\n\n// 点が線分上にあるか判定\nbool on_segment(Point p, Segment s) {\n  return (ccw(s.p,s.q,p) == 0 ? true : false);\n}\n\n// 線分の交差判定\nbool segment_segment_cross(const Segment l, const Segment s) {\n  return ccw(l.p,l.q,s.p) * ccw(l.p,l.q,s.q) <= 0 && ccw(s.p,s.q,l.p) * ccw(s.p,s.q,l.q) <= 0;\n}\n\n// 直線の平行・直交判定 (平行:2 直交:1 その他:0)\nint line_parallel_orthogonal(Line l, Line s) {\n  if(abs(l.a*s.a + l.b*s.b) < eps) return 1;\n  else if(abs(l.a*s.b - l.b*s.a) < eps) return 2;\n  else return 0;\n}\n\n// 直線と直線の交点 \nvector<Point> line_line_cross(Line l, Line s) {\n  vector<Point> vp;\n  if(line_parallel_orthogonal(l,s) != 2) {\n    Point p;\n    p.x = (l.b*s.c - s.b*l.c) / (l.a*s.b - s.a*l.b);\n    p.y = (-l.a*s.c + s.a*l.c) / (l.a*s.b - s.a*l.b);\n    vp.push_back(p);\n  }\n  return vp;\n}\n\n// 点と直線の距離\ndouble point_line_dist(Point p, Line l) {\n  return abs(l.a*p.x + l.b*p.y + l.c) / sqrt(l.a*l.a + l.b*l.b);\n}\n\n// 点と線分の距離\ndouble point_segment_dist(Point p, Segment s) {\n  Point h = projection(p,Line(s.p,s.q));\n  if(on_segment(h,s)) return dist(p,h);\n  else return min(dist(p,s.p),dist(p,s.q));\n}\n\n// 線分と線分の距離\ndouble segment_segment_dist(Segment l, Segment s) {\n  if(segment_segment_cross(l,s)) return 0.0;\n  else return min({point_segment_dist(l.p,s),point_segment_dist(l.q,s),point_segment_dist(s.p,l),point_segment_dist(s.q,l)});\n}\n\n// 直線と直線の距離\ndouble line_line_dist(Line l, Line s) {\n  if(line_parallel_orthogonal(l,s) != 2) return 0.0;\n  else if(abs(s.a) < eps) return point_line_dist(Point(0.0,-s.c/s.b),l);\n  else return point_line_dist(Point(-s.c/s.a,0),l);\n}\n\n// 直線と線分の距離\ndouble line_segment_dist(Line l, Segment s) {\n  Point a, b;\n  if(abs(l.a) < eps) a = Point(0.0,-l.c/l.b), b = Point(1.0,-l.c/l.b);\n  else if(abs(l.b) < eps) a = Point(-l.c/l.a,0.0), b = Point(-l.c/l.a,0.0);\n  else a = Point(0.0,-l.c/l.b), b = Point(-l.c/l.a,0);\n\n  if(ccw(a,b,s.p) * ccw(a,b,s.q) <= 0) return 0.0;\n  else return min(point_line_dist(s.p,l),point_line_dist(s.q,l));\n}\n\n// ★円と円の交差判定 (離れる:4 外接:3 交わる:2 内接:1 内包:0)\nint circle_circle_pos(Circle c, Circle d) {\n  if(dist(c.p,d.p) >= c.r + d.r + eps) return 4;\n  else if(abs(dist(c.p,d.p) - c.r - d.r) < eps) return 3;\n  else if(dist(c.p,d.p) >= abs(c.r-d.r) + eps) return 2;\n  else if(abs(dist(c.p,d.p) - abs(c.r-d.r)) < eps) return 1;\n  else return 0; \n}\n\n// ★円と直線の交点\nvector<Point> circle_line_cross(Circle c, Line l) {\n  vector<Point> vp;\n  Point h = projection(c.p,l);\n\n  double d = l.a*c.p.x + l.b*c.p.y + l.c;\n  double q = c.r*c.r - d*d / (l.a*l.a + l.b*l.b);\n  if(q >= eps) {\n    Point p1, p2;\n    p1.x = h.x + sqrt(q) * l.b / sqrt(l.a*l.a + l.b*l.b);\n    p1.y = h.y - sqrt(q) * l.a / sqrt(l.a*l.a + l.b*l.b);\n    p2.x = h.x - sqrt(q) * l.b / sqrt(l.a*l.a + l.b*l.b);\n    p2.y = h.y + sqrt(q) * l.a / sqrt(l.a*l.a + l.b*l.b);\n    vp.push_back(p1);\n    vp.push_back(p2);\n  } else if(abs(q) < eps) {\n    vp.push_back(h);\n  }\n  return vp;\n} \n\n// ★円と円の交点\nvector<Point> circle_circle_cross(Circle c, Circle d) {\n  Line l(2.0*(c.p.x-d.p.x),2.0*(c.p.y-d.p.y),-c.p.x*c.p.x+d.p.x*d.p.x-c.p.y*c.p.y+d.p.y*d.p.y+c.r*c.r-d.r*d.r);\n  return circle_line_cross(c,l);\n}\n\n// ★多角形の面積\ndouble polygon_area(vector<Point>& v) {\n  int l = v.size();\n  double s = 0.0;\n  for(int i = 0; i < l; i++) s += 1/2.0 * cross(v[i],v[(i+1)%l]);\n  return s;\n}\n\n// ★多角形の凸性\nbool polygon_convex(vector<Point>& v) {\n  int l = v.size();\n  for(int i = 0; i < l; i++) {\n    if(cross(v[(i+1)%l]-v[i],v[(i+2)%l]-v[i]) < -eps) return false;\n  }\n  return true;\n} \n\n// ★点の多角形への包含 (含まれる:2 辺上:1 外:0)\nint polygon_inclusion(const vector<Point>& v, const Point p) {\n  int l = v.size();\n  bool in = false;\n  for(int i = 0; i < l; i++) {\n    Point a = v[i] - p, b = v[(i+1)%l] - p;\n    if(on_segment(Point(0.0,0.0),Segment(a,b))) return 1;\n    if(a.y > b.y) swap(a,b);\n    if(a.y <= 0 && b.y > 0 && cross(a,b) < 0) in = !in; \n  }\n  return in ? 2 : 0;\n}\n\n// ★凸包 O(nlogn) (Graham Scan)\nvector<Point> convex_hull(vector<Point>& v) {\n  int l = v.size();\n  sort(v.begin(),v.end(),compx);\n  vector<Point> c(2*l);\n  int k = 0;\n  for(int i = 0; i < l; i++) {\n    while(k > 1 && cross(c[k-1]-c[k-2],v[i]-c[k-1]) <= -eps) k--;\n    c[k++] = v[i];\n  }\n  for(int i = l-2, t = k; i >= 0; i--) {\n    while(k > t && cross(c[k-1]-c[k-2],v[i]-c[k-1]) <= -eps) k--;\n    c[k++] = v[i];\n  }\n  c.resize(k-1);\n  return c;\n}\n\n// ★最遠点距離(キャリパー法) O(n) (凸包を構成する場合O(nlogn))\ndouble convex_diameter(vector<Point>& v) {\n  vector<Point> c = convex_hull(v);\n  int l = c.size();\n  if(l == 2) return (dist(c[0],c[1]));\n  int i = 0, j = 0;\n  for(int k = 0; k < l; k++) {\n    if(!compx(c[i],c[k])) i = k;\n    if(compx(c[j],c[k])) j = k;\n  }\n  double res = 0.0;\n  int si = i, sj = j;\n  while(i != sj || j != si) {\n    res = max(res,dist(c[i],c[j]));\n    if(cross(c[(i+1)%l]-c[i],c[(j+1)%l]-c[j]) < 0) i = (i + 1) % l;\n    else j = (j + 1) % l;\n  }\n  return res;\n}\n\n// 最近接点距離 O(nlogn) x座標でsortして渡す.\ndouble closest_pair(vector<Point>::iterator it, int n) {\n  if(n <= 1) return inf;\n  int m = n / 2;\n  double x = it[m].x;\n  double d = min(closest_pair(it,m),closest_pair(it+m,n-m));\n  inplace_merge(it,it+m,it+n,compy);\n\n  vector<Point> b;\n  for(int i = 0; i < n; i++) {\n    if(abs(it[i].x-x) >= d) continue;\n    for(int j = 0; j < b.size(); j++) {\n      double dx = it[i].x - b[b.size()-j-1].x;\n      double dy = it[i].y - b[b.size()-j-1].y;\n      if(dy >= d) break;\n      d = min(d,sqrt(dx*dx+dy*dy));\n    }\n    b.push_back(it[i]);\n  }\n  return d;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<Point> v(n);\n  rep(i,n) cin >> v[i].x >> v[i].y;\n  sort(v.begin(),v.end(),compx);\n  printf(\"%.9lf\\n\",closest_pair(v.begin(),n));\n  return 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn 1e9;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP,\n\tint yl,int yr\n){\n\tint xsiz=xr-xl;\n\tint ysiz=yr-yl;\n\tif (xsiz <= 8) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tif(ysiz==0)return 1e9;\n\t//printf(\"%d %d %d %d\\n\",xl,xr,yl,yr);\n\tauto xM = xP[xl+xsiz/2].first;\n\tauto yL = std::vector<point_t>(ysiz);\n\tint left = -1, right = ysiz;\n\tfor(int i = yl; i < yr; i++){\n\t\tif (yP[i].first < xM) yL[++left] = yP[i];\n\t\telse                  yL[--right]= yP[i];\n\t}\n\tstd::reverse(yL.begin()+right,yL.end());\n\tauto p1 = find_closest_optimized(xP,xl,xl+xsiz/2,yL,0,left+1);\n\tauto p2 = find_closest_optimized(xP,xl+xsiz/2,xr,yL,left+1,ysiz);\n\tauto minD = sqrt((p1 < p2) ? p1 : p2);\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n,yP,0,n);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tx = y = 0;\n\t}\n\tInfo(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn x < arg.x;\n\t};\n\tdouble x,y;\n};\n\nint N;\n\nbool compare_y(Info left,Info right){\n\treturn left.y < right.y;\n}\n\nInfo* info;\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2;\n\tdouble x = array[mid].x;\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid));\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y);\n\n\tvector<Info> V;\n\tfor(int i = 0; i < tmp_N; i++){\n\t\tif(fabs(array[i].x-x) >= dist)continue;\n\n\t\tfor(int j = 0; j < V.size();j++){\n\t\t\tdouble dx = array[i].x - V[V.size()-j-1].x;\n\t\t\tdouble dy = array[i].y - V[V.size()-j-1].y;\n\t\t\tif(dy >= dist)break;\n\t\t\tdist = min(dist,sqrt(dx*dx+dy*dy));\n\t\t}\n\t\tV.push_back(array[i]);\n\t}\n\treturn dist;\n}\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\tinfo = (Info*)malloc(sizeof(Info)*N);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf\",&info[i].x,&info[i].y);\n\t}\n\n\tsort(info,info+N);\n\n\tprintf(\"%.7lf\\n\",closest_pair(info,N));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\n\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    //two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n\n    two_dimensional_qsort(p_xy, n0, n-1, 1);\n    \n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        //cout<<\"qaaa\";\n        two_dimensional_qsort(p_xy, 0, n-1, 0);\n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for(int i=(a);i<(n);i++)\n#define per(i,a,n) for(int i=(n)-1;i>=(a);i--)\n#define MP make_pair\n\ntypedef double db;\n\nconst db EPS = 1e-8;\n\ninline int sign(db a) {\n\treturn a < -EPS ? -1 : a > EPS;\n}\n\ninline int cmp(db a, db b){\n\treturn sign(a-b);\n}\n\nstruct P {\n\tdb x, y;\n\tP() {\n\t}\n\tP(db _x, db _y) :\n\t\t\tx(_x), y(_y) {\n\t}\n\tP operator+(P p) {\n\t\treturn P(x + p.x, y + p.y);\n\t}\n\tP operator-(P p)  {\n\t\treturn P(x - p.x, y - p.y);\n\t}\n\tP operator*(db d) {\n\t\treturn P(x * d, y * d);\n\t}\n\tP operator/(db d) {\n\t\treturn P(x / d, y / d);\n\t}\n\tbool operator<(P p) const {\n\t\tint c = sign(x - p.x);\n\t\tif (c)\n\t\t\treturn c == -1;\n\t\treturn sign(y - p.y) == -1;\n\t}\n\tdb dot(P p) {\n\t\treturn x * p.x + y * p.y;\n\t}\n\tdb det(P p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdb distTo(P p) { return (*this-p).abs(); }\n\n\tdb alpha() {\n\t\treturn atan2(y, x);\n\t}\n\tvoid read() {\n\t\tcin>>x>>y;\n\t}\n\tdb abs() {\n\t\treturn sqrt(abs2());\n\t}\n\tdb abs2() {\n\t\treturn x * x + y * y;\n\t}\n\tP rot90(){\n\t\treturn P(-y,x);\n\t}\n};\n\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))\n\nP isLL(P p1, P p2, P q1, P q2) {\n\tdb a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n}\n\nbool intersect(db l1,db r1,db l2,db r2){\n\tif(l1>r1) swap(l1,r1); if(l2>r2) swap(l2,r2); \n\treturn !( cmp(r1,l2) == -1 || cmp(r2,l1) == -1 );\n}\n\nbool isSS(P p1, P p2, P q1, P q2){\n    return intersect(p1.x,p2.x,q1.x,q2.x) && intersect(p1.y,p2.y,q1.y,q2.y) && \n    crossOp(p1,p2,q1) * crossOp(p1,p2,q2) <= 0 && crossOp(q1,q2,p1)\n            * crossOp(q1,q2,p2) <= 0;\n}\n\nbool isMiddle(db a, db m, db b) {\n    return sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);\n}\n \nbool isMiddle(P a, P m, P b) {\n    return isMiddle(a.x, m.x, b.x) && isMiddle(a.y, m.y, b.y);\n}\n\nbool onSeg(P p1, P p2, P q){\n\treturn crossOp(p1,p2,q) == 0 && isMiddle(p1, q, p2);\n}\n\nP proj(P p1, P p2, P q) {\n    P dir = p2 - p1;\n    return p1 + dir * (dir.dot(q - p1) / dir.abs2());\n}\n\nP reflect(P p1, P p2, P q){\n\treturn proj(p1,p2,q) * 2 - q;\n}\n\ndb nearest(P p1,P p2,P q){\n\tP h = proj(p1,p2,q);\n\tif(isMiddle(p1,h,p2))\n\t\treturn q.distTo(h);\n\treturn min(p1.distTo(q),p2.distTo(q));\n}\n\ndb disSS(P p1, P p2, P q1, P q2){\n\tif(isSS(p1,p2,q1,q2)) return 0;\n\treturn min(min(nearest(p1,p2,q1),nearest(p1,p2,q2)), min(nearest(q1,q2,p1),nearest(q1,q2,p2)) );\n}\n\ndb getrad(P p1,P p2){\n\treturn atan2l(p1.det(p2),p1.dot(p2));\n}\n\ndb incircle(P p1, P p2, P p3){\n\tdb A = p1.distTo(p2);\n\tdb B = p2.distTo(p3);\n\tdb C = p3.distTo(p1);\n\treturn sqrtl(A*B*C/(A+B+C));\n}\n\ndb area(vector<P> ps){\n\tdb ret = 0; rep(i,0,ps.size()) ret += ps[i].det(ps[(i+1)%ps.size()]); \n\treturn abs(ret/2);\n}\n\nint contain(vector<P> ps, P p){ //2:inside,1:on_seg,0:outside\n\tint n = ps.size(), ret = 0;\t\n\trep(i,0,n){\n\t\tP u=ps[i],v=ps[(i+1)%n];\n\t\tif(onSeg(u,v,p)) return 1;\n\t\tif(cmp(u.y,v.y)<=0) swap(u,v);\n\t\tif(cmp(p.y,u.y) >0 || cmp(p.y,v.y) <= 0) continue;\n\t\tret ^= crossOp(p,u,v) > 0;\n\t}\n\treturn ret*2;\n}\n\nvector<P> convexHull(vector<P> ps) {\n    int n = ps.size(); if(n <= 1) return ps;\n    sort(ps.begin(), ps.end());\n    vector<P> qs(n * 2); int k = 0;\n    for (int i = 0; i < n; qs[k++] = ps[i++]) \n        while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])\n       \twhile (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;\n    qs.resize(k - 1);\n    return qs;\n}\n\nvector<P> convexHullNonStrict(vector<P> ps) {\n    int n = ps.size(); if(n <= 1) return ps;\n    sort(ps.begin(), ps.end());\n    vector<P> qs(n * 2); int k = 0;\n    for (int i = 0; i < n; qs[k++] = ps[i++]) \n        while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;\n    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])\n       \twhile (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;\n    qs.resize(k - 1);\n    return qs;\n}\n\ndb convexDiameter(vector<P> ps){\n\tint n = ps.size(); if(n <= 1) return 0;\n\tint is = 0, js = 0; rep(k,1,n) is = ps[k]<ps[is]?k:is, js = ps[js] < ps[k]?k:js;\n\tint i = is, j = js;\n\tdb ret = ps[i].distTo(ps[j]);\n\tdo{\n\t\tif((ps[(i+1)%n]-ps[i]).det(ps[(j+1)%n]-ps[j]) >= 0)\n\t\t\t(++j)%=n;\n\t\telse\n\t\t\t(++i)%=n;\n\t\tret = max(ret,ps[i].distTo(ps[j]));\n\t}while(i!=is || j!=js);\n\treturn ret;\n}\n\nvector<P> convexCut(const vector<P>&ps, P q1, P q2) {\n\tvector<P> qs;\n\tint n = ps.size();\n\trep(i,0,n){\n\t\tP p1 = ps[i], p2 = ps[(i+1)%n];\n\t\tint d1 = crossOp(q1,q2,p1), d2 = crossOp(q1,q2,p2);\n\t\tif(d1 >= 0) qs.push_back(p1);\n\t\tif(d1 * d2 < 0) qs.push_back(isLL(p1,p2,q1,q2));\n\t}\n\treturn qs;\n}\n\ndb min_dist(vector<P>&ps,int l,int r){\n\tif(r-l<=5){\n\t\tdb ret = 1e100;\n\t\trep(i,l,r) rep(j,l,i) ret = min(ret,ps[i].distTo(ps[j]));\n\t\treturn ret;\n\t}\n\tint m = (l+r)>>1;\n\tdb ret = min(min_dist(ps,l,m),min_dist(ps,m,r));\n\tvector<P> qs; rep(i,l,r) if(abs(ps[i].x-ps[m].x)<= ret) qs.push_back(ps[i]);\n\tsort(qs.begin(), qs.end(),[](P a,P b) -> bool {return a.y<b.y; });\n\trep(i,1,qs.size()) for(int j=i-1;j>=0&&qs[j].y>=qs[i].y-ret;--j) ret = min(ret,ps[i].distTo(ps[j]));\n\treturn ret;\n}\n\nint main(){\n\tint n;cin>>n;\n\tvector<P> ps(n);\n\trep(i,0,n) ps[i].read();\n\tsort(ps.begin(), ps.end());\n\tprintf(\"%0.10f\\n\",min_dist(ps,0,ps.size()));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&min(memo,ans+0.001) >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans =(min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nbool pariCompare (const P& FElof, const P& SElof) {\n    if (FElof.first == SElof.first) return FElof.second < SElof.second;\n    return FElof.first < SElof.first;\n}\n\nint main ()\n{\n    int n;\n    cin >> n;\n    vector<P> p(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i].first >> p[i].second;\n    }\n\n    sort(p.begin(), p.end(), pariCompare);\n\n    double dis = 100000.0;\n    for (int i = 0; i < n-1; i++) {\n        for (int j = i + 1; j < n && p[i].first - p[j].first < sqrt(dis); j++) {\n            double tmp = pow(p[i].first - p[j].first, 2.0) + pow(p[i].second - p[j].second, 2.0);\n            dis = min(dis, tmp);\n        }\n    }\n\n    printf(\"%.6f\\n\", sqrt(dis));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#define MAX_INPUT 3//100000\n#define VERY_LARGE 987654321.0\n#define ABS(x) x<0?-x:x\n#define MIN(a, b) a<b?a:b\ntypedef struct point{\n    double x, y;\n    bool operator<(const struct point &X) const{\n        if (x != X.x) return x < X.x;\n        return y < X.y;\n    };\n    bool operator<<(const struct point &X) const{\n        if (y != X.y) return y < X.y;\n        return x < X.x;\n    };\n} Point;\nPoint PX[MAX_INPUT], PY[MAX_INPUT], T[MAX_INPUT], SYL[MAX_INPUT], SYR[MAX_INPUT];\nint N;\nvoid input(void);\nvoid msortx(int s, int e, Point P[]);\nvoid msorty(int s, int e, Point P[]);\ndouble dist(Point a, Point b){return ABS((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));};\ndouble CP(int s, int e);\nvoid combine(int m, int delta, Point C);\nvoid findPointsInStrip(int m, int delta, Point SYL[], Point SYR[], int *l, int *r);\nint main(void){\n    //freopen(\"in.txt\", \"r\", stdin);\n    input();\n    msortx(0, N - 1, PX);\n    msorty(0, N - 1, PY);\n    printf(\"%f\\n\", sqrt(CP(0, N - 1)));\n    return 0;\n}\nvoid findPointsInStrip(int m, int delta, Point SYL[], Point SYR[], int *l, int *r){\n    *l = 0, *r = 0;\n    for(int i = 0; i < N; i++){\n       if (PY[i].x <= PX[m].x && PY[i].x >= PX[m].x - delta)\n           SYL[(*l)++] = PY[i];\n       else if (PY[i].x > PX[m].x && PY[i].x <= PX[m].x + delta)\n           SYR[(*r)++] = PY[i];\n    }\n}\ndouble CP(int s, int e){\n    if (s >= e) return VERY_LARGE;\n    if (s + 1 == e) return dist(PX[s], PX[e]);\n    int m = s + (e - s) / 2;\n    double d1, d2, delta, deltaPrime = VERY_LARGE;\n    d1 = CP(s, m); d2 = CP(m + 1, e);\n    delta = MIN(d1, d2);\n    int l, r;\n    findPointsInStrip(m, delta, SYL, SYR, &l, &r);\n    int i, j;\n    for(i = 0; i < l; i++){\n        for(j = 0; j < r; j++){\n            if (ABS(SYL[i].y - SYR[j].y) >= delta) break;\n            double cnd = dist(SYL[i], SYR[i]);\n            if(cnd < deltaPrime) deltaPrime = cnd;\n        }\n    }\n    return MIN(delta, deltaPrime);\n}\nvoid msortx(int s, int e, Point P[]){\n    if(s >= e) return;\n    int m = s + (e - s) /2;\n    msortx(s, m, P);\n    msortx(m + 1 , e, P);\n    int i = s, j = m + 1, k = s;\n    while (i <= m || j <= e){\n        if (j > e || (i <= m && P[i] < P[j]))\n            T[k++] = P[i++];\n        else\n            T[k++] = P[j++];\n    }\n    for(i = s; i <= e; i++) P[i] = T[i];\n}\nvoid msorty(int s, int e, Point P[]){\n    if(s >= e) return;\n    int m = s + (e - s) /2;\n    msorty(s, m, P);\n    msorty(m + 1 , e, P);\n    int i = s, j = m + 1, k = s;\n    while (i <= m || j <= e){\n        if (j > e || (i <= m && P[i] << P[j]))\n            T[k++] = P[i++];\n        else\n            T[k++] = P[j++];\n    }\n    for(i = s; i <= e; i++) P[i] = T[i];\n}\nvoid input(void){\n    scanf(\"%d\", &N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%lf%lf\", &PX[i].x, &PX[i].y);\n        PY[i] = PX[i];\n    };\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\nconst db inf =1e9;\nconst int N=1e5+10;\nstruct Point{\n    db x,y;\n    void input(){scanf(\"%lf%lf\",&x,&y);}\n    db dis(Point p){return sqrt((p.x-x)*(p.x-x)+(p.y-y)*(p.y-y));}\n}A[N];\nbool cmp2(Point a,Point b){return a.y<b.y;}\ndb Closest(int l,int r){\n    if(l==r)return inf;\n    if(r==l+1)return A[l].dis(A[r]);\n    int mid=(l+r)/2;\n    db ans=min(Closest(l,mid-1),Closest(mid+1,r));\n    vector<Point> V;V.push_back(A[mid]);\n    int now=mid-1;while(now>=l&&A[mid].x-A[now].x<=ans)V.push_back(A[now]),--now;\n    now=mid+1;while(now<=r&&A[now].x-A[mid].x<=ans)V.push_back(A[now]),++now;\n    sort(V.begin(),V.end(),cmp2);\n    now=0;\n    for(int i=0;i<V.size();++i){\n        while(now<V.size()&&V[now].y-V[i].y<=ans)++now;\n        for(int j=i;j<now;++j)for(int k=j+1;k<now;++k)ans=min(ans,V[j].dis(V[k]));\n    }\n    return ans;\n}\nbool cmp(Point a,Point b){return a.x<b.x;}\nint main(){\n    int n;cin>>n;\n    for(int i=1;i<=n;++i)A[i].input();\n    sort(A+1,A+1+n,cmp);\n    printf(\"%.10lf\\n\",Closest(1,n));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\n\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  // if (r - l <= 3) {\n  //   PointPoint res(ps[l], ps[r - 1]);\n  //   for (int i = l; i < r; ++i) {\n  //     for (int j = i + 1; j < r; ++j) {\n  //       res = Closer(res, PointPoint(ps[i], ps[j]));\n  //     }\n  //   }\n  //   return res;\n  // }\n  if (r - l == 2) {\n    return PointPoint(ps[l], ps[l + 1]);\n  }\n  if (r - l == 3) {\n    PointPoint a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return Closer(a, Closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  Points lp, rp;\n  for (int i = l; i < mid; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) lp.push_back(ps[i]);\n  }\n  for (int i = mid; i < r; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) rp.push_back(ps[i]);\n  }\n  for (int i = 0; i < lp.size(); ++i) {\n    for (int j = 0; j < rp.size(); ++j) {\n      if (Distance(lp[i], rp[j]) < d) {\n        d = Distance(lp[i], rp[j]);\n        res = PointPoint(lp[i], rp[j]);\n      }\n    }\n  }\n\n  // Points strip;\n  // for (int i = l; i < r; ++i) {\n  //   if (abs(ps[i].real() - midPoint.real()) < d) strip.push_back(ps[i]);\n  // }\n  // for (int i = 0; i < strip.size(); ++i) {\n  //   for (int j = i + 1; j < strip.size(); ++j) {\n  //     if (Distance(strip[i], strip[j]) < d) {\n  //       d = Distance(strip[i], strip[j]);\n  //       res = PointPoint(strip[i], strip[j]);\n  //     }\n  //   }\n  // }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  return ClosestPairUtil(ps, 0, ps.size());\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  sort(p.begin(), p.end());\n  PointPoint pp = ClosestPair(p);\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n  // cerr << pp.first << \" \" << pp.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n; double bx, by; pair<double, double> p[100009];\nint main() {\n\tscanf(\"%d\", &n);\n\tdouble sq = 0.28, cq = 0.96;\n\tfor(int i = 0; i < n; i++) {\n\t\tscanf(\"%lf%lf\", &bx, &by);\n\t\tdouble ex = bx * cq - by * sq;\n\t\tdouble ey = bx * sq + by * cq;\n\t\tp[i] = make_pair(ex, ey);\n\t}\n\tsort(p, p + n);\n\tdouble ret = 1.0e+10;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tdouble dx = p[i].first - p[j].first;\n\t\t\tif(dx * dx > ret) break;\n\t\t\tdouble dy = p[i].second - p[j].second;\n\t\t\tdouble dist = dx * dx + dy * dy;\n\t\t\tif(ret > dist) ret = dist;\n\t\t}\n\t}\n\tprintf(\"%.15lf\\n\", sqrt(ret));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nconst double inf=1e20;\n\ninline int sign(const double &x){\n    if(x>EPS) return 1;\n    else if(x<-EPS) return -1;\n    return 0;\n}\n\n/*   点  */\nstruct Point{\n    double x,y;\n\n    Point(double x=0,double y=0):x(x),y(y){}\n\n    Point operator + (Point p) { return Point(x+p.x,y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x,y-p.y); }\n    Point operator * (double k) { return Point(k*x,k*y); }\n    Point operator / (double k) { return Point(x/k,y/k); }\n\n    //向量的大小\n    inline double abs(){ return sqrt(norm()); }\n    inline double norm() { return x*x+y*y; }\n\n    bool operator < (const Point & p) const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n    bool operator == (const Point & p) const {\n        return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n    }\n};\n\n//两点间的距离\ninline double getDistance(Point a,Point b){\n    return (a-b).abs();\n}\n\n/*   向量  */\ntypedef Point Vector;\n\n//向量a和b的内积\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n//向量a和b的外积\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\n/*   线段  */\nstruct Segment{\n    Point p1,p2;\n};\n\n//点p在线段s上的投影\nPoint project(Segment s,Point p){\n    Vector base = s.p2-s.p1;\n    double r=dot(p-s.p1,base)/base.norm();\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n/*   直线  */\ntypedef Segment Line;\n\n//点到直线的距离\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/(l.p2-l.p1).abs());\n}\n\n//点到线段的距离\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return (p-s.p1).abs();\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return (p-s.p2).abs();\n    return getDistanceLP(s,p);\n}\n\n//判断p2与向量p1-p0的位置关系\n\nconst int COUNTER_CLOCKWISE = -1;   //逆时针\nconst int CLOCKWISE = 1;            //顺时针\nconst int ON_SEGMENT = 0;           //在线段上\nconst int ONLINE_BACK = 2;          //p2在向量p1-p0的反方向延长线上\nconst int ONLINE_FRONT = -2;        //p2在向量p1-p0的正方向延长线上\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CLOCKWISE;\n    if(dot(a,b)<-EPS) return ONLINE_BACK;\n    if(a.norm()<b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//判断线段p1p2与线段p3p4是否相交\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n             ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n//线段与线段的距离\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\n//两个线段的交点(对于直线跟线段也适用，但注意base是在直线上)\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n/* 直线正交\n * 判断向量a，b是否正交 =》a，b的内积为0\n */\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\n/* 直线平行\n * 判断向量a，b是否平行 =》a，b的内积为0\n */\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point() ,double r = 0.0 ):c(c),r(r){}\n};\n\n/* 圆与直线的交点\n * 交点为一个的时候返回两个相同的点\n * 没有交点则退出\n */\n\nbool intersect(Circle c,Line l){\n    return sign(getDistanceLP(l,c.c)-c.r)<=0;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n    assert(intersect(c,l));         //没有交点\n    Point pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n    double base=sqrt(c.r*c.r-(pr-c.c).norm());\n    return make_pair(pr+e*base,pr-e*base);\n}\n\n\n//圆与圆的交点\n\nbool intersect(Circle c1,Circle c2){\n    return sign(getDistance(c1.c,c2.c)-(c1.r+c2.r))<=0;\n}\n\ndouble arg(Vector p){\n    return atan2(p.y,p.x);// double atan2(double y,double x) 返回的是原点至点(x,y)的方位角，即与 x 轴的夹角。返回值的单位为弧度，取值范围为(-PI,PI]\n}\n\nVector polar(double r,double a){\n    return Point(cos(a)*r,sin(a)*r);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    assert(intersect(c1,c2));\n    double d=(c1.c-c2.c).abs();\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\n/*   多边形  */\ntypedef vector<Point> Polygon;\n\n//点的****内包*****(判断点与多边形的关系)\n//多边形内返回2\n//多边形上返回1\n//多边形外返回0\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return 1;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) x=!x;\n    }\n    return (x?2:0);\n}\n\n/* *******凸包*****(包含点集合p中所有点的最小凸多边形)\n * 输出凸多边形最下端最左侧的顶点为起点,按逆时针方向依次输出坐标。\n * 安德鲁算法 O(n*logn)\n */\n\ndouble Area(Point p0,Point p1,Point p2){\n    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\n}\n\nPolygon andrewscanf(Polygon s){\n    int n=s.size();\n    sort(s.begin(),s.end());    //x从小到大，x相同的y从小到大\n    Polygon u;\n    //构建凸包上部\n    for(int i=0;i<n;i++){\n        for(int j=u.size();j>=2&&Area(u[j-2],u[j-1],s[i]) <= EPS;j--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    //构建凸包下部\n    int tmp=u.size()+1;\n    for(int i=n-2;i>=0;i--){\n        for(int j=u.size();j>=tmp&&Area(u[j-2],u[j-1],s[i]) <= EPS;j--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    //按顺序生成凸包点的序列\n    if(n>1) u.pop_back();               //开始点多加入了一次\n    return u;\n}\n\n//旋转卡壳*-------》计算凸包直径\ndouble RC(Polygon v){\n    double res=0;\n    int n=v.size();\n    int k=1;\n    for(int i=0;i<n;i++){\n        while(sign(Area(v[i],v[(i+1)%n],v[(k+1)%n])-Area(v[i],v[(i+1)%n],v[k%n]))==1) k=(k+1)%n;\n//        printf(\"*** %d\\n\",k);\n        res=max(res,max((v[i]-v[k]).abs(),(v[(i+1)%n]-v[k]).abs()));\n    }\n    return res;\n}\n\n//  平面上最近点对。（分治  nlognlogn）\nPoint a[100005],b[100005];\n\ninline bool CmpY(Point a,Point b){\n    return a.y<b.y;\n}\ninline double Distance(Point a,Point b){\n    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\ndouble Divide_Conquer(int l,int r){\n    if(l==r) return inf;\n    if(l+1==r) return Distance(a[l],a[r]);\n    int mid=l+r>>1;\n    double ans=min(Divide_Conquer(l,mid),Divide_Conquer(mid+1,r));\n    int len=0;\n    for(int i=l;i<=r;i++){\n        if(fabs(a[mid].x-a[i].x)<=ans) b[len++]=a[i];\n    }\n    sort(b,b+len,CmpY);\n    for(int i=0;i<len;i++){\n        for(int j=i+1;j<len&&(b[j].y-b[i].y<ans);j++){\n            ans=min(ans,Distance(b[i],b[j]));\n        }\n    }\n    return ans;\n}\n\ninline void solve(int n){\n    sort(a,a+n);\n    printf(\"%.10f\\n\",Divide_Conquer(0,n-1));\n}\n\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lf%lf\",&a[i].x,&a[i].y);\n    }\n    solve(n);\n    return 0;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<utility>\n#include<complex>\n#include<functional>\nusing namespace std;\n#define LL double \n\nstruct P{\n\tdouble x, y;\n};\n\nusing namespace std;\n\n//Compare for sorting\ninline bool LessX(const P& left, const P& right){\n\tif (left.x == right.x)return(left.y < right.y);\n\treturn left.x<right.x;\n}\ninline bool LessY(const P& left, const P& right){\n\treturn(left.y < right.y);\n}\n\n\nP xx[10000000], yy[10000000],ss[10000000];\nint ix, iy,is;\n#define dist(_x,_y,__x,__y) (((_x)-(__x))*((_x)-(__x))+((_y)-(__y))*((_y)-(__y)))\n#define distP(a,b) dist((a.x),(a.y),(b.x),(b.y))\nvoid Closest_Pair_rec(int n,int xs, int ys, P *p1, P *p2, LL* qdist){\n\n\n\tP *vx = xx + xs;\n\tP *vy = yy + ys;\n\n/*\tcout << \"vx:\"; \n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"(%lld,%lld)\", vx[i].x, vx[i].y); cout << endl;\n\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"(%lld,%lld)\", vy[i].x, vy[i].y); cout << endl;*/\n\tif (n == 3){\n\t\tLL d1 = distP(vx[0], vx[1]), d2 = distP(vx[1], vx[2]), d3 = distP(vx[2], vx[0]);\n\t\t(*qdist) = d1; *p1 = vx[0], *p2 = vx[1];\n\t\tif (*qdist>d2)(*qdist) =d2,*p1 = vx[1], *p2 = vx[2];\n\t\tif (*qdist>d3)(*qdist) = d3, *p1 = vx[0] , *p2 = vx[2];\n\t\treturn;\n\t}\n\tif(n==2){\n\t\t(*qdist) = distP(vx[0], vx[1]); *p1 = vx[0], *p2 = vx[1];\n\n\t\treturn;\n\t}\n\tint half = n / 2;\n\tint l = iy, r = iy+half,tempiy=iy;\n\tP middle = vx[half];\n\tP rp1, rp2;\n\tLL  rd;\n\tfor (int i = 0; i < n; i++){\n\t\tif (LessX(vy[i], middle))\n\t\t\tyy[l++] = vy[i];\n\t\telse\n\t\t\tyy[r++] = vy[i];\n\t}\n\tiy += n;\n\tClosest_Pair_rec(n / 2, xs, tempiy, p1, p2, qdist);\n\tClosest_Pair_rec(n-half, xs+half, tempiy+half, &rp1, &rp2, &rd);\n\n\tif (*qdist>rd)*p1 = rp1, *p2 = rp2, *qdist = rd;\n\n\tint k = 0;\n\tP *vs = ss + is;\n\tfor (int i = 0; i < n; i++)\n{\n\t\trd = (vy[i].x - middle.x)*(vy[i].x - middle.x);\n\t\tif (rd < *qdist)\n\t\t\tvs[k++] = vy[i];\n\t}\n\tfor (int i = 0; i < k - 1; i++)\n\t\tfor (int j = i + 1; j < k&&vs[j].y - vs[i].y < *qdist; j++){\n\t\t\trd = distP(vs[i], vs[j]);\n\t\t\tif (*qdist > rd){\n\t\t\t\t*qdist = rd;\n\t\t\t\t*p1 = vs[i];\n\t\t\t\t*p2 = vs[j];\n\t\t\t}\n\t\t}\n\tis += k;\n\n}\n\nvoid Closest_Pair(int n, vector<P>& list, P* p1, P* p2, LL* qdist){\n\tix = n, iy = n,is=0;\n\tfor (int i = 0; i < n; i++)\n\t\txx[i] = yy[i] = list[i];\n\tsort(xx, xx+n, LessX);\n\tsort(yy, yy+n, LessY);\n\tClosest_Pair_rec(n,0,0,p1, p2, qdist);\n}\n/*\nint main(void){\n\tint N; cin >> N;\n\tLL a, b;\n\tP p1, p2;\n\tvector<P> A(N), B(N);\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i].x >> A[i].y;\n\t\t\n\t}\n\tClosest_Pair(N, A, &p1, &p2, &a);\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> B[i].x >> B[i].y;\n\t}\n\tClosest_Pair(N, B, &p1, &p2, &b);\n\t//cout << b << endl;\n\tprintf(\"%.6f\", sqrt((double)b / (double)a));\n\treturn(0);\n}\n*/\nint main(void){\n\tint N; cin >> N;\n\tLL a;\n\tP p1, p2;\n\tvector<P> A(N);\n\tfor (int i = 0; i < N; i++){\n\t\tcin >> A[i].x >> A[i].y;\n\n\t}\n\tClosest_Pair(N, A, &p1, &p2, &a);\n\n\t//cout << b << endl;\n\tprintf(\"%.7f\", sqrt((double)a));\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <iomanip>\n#include <math.h>\n#include <stdbool.h>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nclass Point {\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n    Point operator * (double a) { return Point(a*x, a*y); }\n    Point operator / (double a) { return Point(x/a, y/a); }\n\n    double abs() {return sqrt(norm()); }\n    double norm() {return x*x + y*y; }\n};\n\ndouble getMinLR(vector<Point>&, int m0, int m1, int m, double delta);\ndouble getClosestPair(vector<Point>& v, int m0, int m1, bool isSorted);\n\nint main(){\n    #if 0\n    std::ifstream in(\"test.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    #endif\n\n    int n;\n    cin >> n;\n    vector<Point> zPoints(n);\n\n    for (int i=0; i<n; i++){\n        cin >> zPoints[i].x >> zPoints[i].y;\n    }\n\n    cout << fixed << setprecision(10) << getClosestPair(zPoints, 0, n-1, false) << endl;\n\n    return 0;\n}\n\nbool xComp(Point p1, Point p2){   \n    return  (p1.x < p2.x);\n}\n\nbool yComp(Point p1, Point p2){   \n    return  (p1.y < p2.y);\n}\n\ndouble getMinLR(vector<Point>& v, int m0, int m1, int m, double delta){\n    vector<Point> zMargin; //点mからx座標が+-deltaの範囲にいる点の集合\n    zMargin.push_back(v[m]);\n    for (int i=m-1; i>=m0; i--){\n        if ( (v[m].x - v[i].x) > delta ) break;\n        zMargin.push_back(v[i]);\n    }\n    for (int i=m+1; i<=m1; i++){\n        if ( (v[i].x - v[m].x) > delta ) break;\n        zMargin.push_back(v[i]);\n    }\n\n    sort(zMargin.begin(), zMargin.end(), *yComp); //y方向にsort\n    int n = zMargin.size();\n    Point buffer(zMargin[n-1].x, zMargin[n-1].y + 2*delta );\n    for (int i=0; i<4; i++){\n        zMargin.push_back(buffer);\n    }\n\n    double minLR = delta;\n\n    for (int i=0; i<n-1; i++){\n        for (int j=i+1; j<=i+5; j++){\n            double distance = (zMargin[j] - zMargin[i]).abs();\n            minLR = (distance < minLR)? distance : minLR;\n        }\n    }\n    \n    return minLR;\n}\n\ndouble getClosestPair(vector<Point>& v, int m0, int m1, bool isSorted=true){\n    if (m0 == m1){ //１点の場合はInfinityを返す\n        return __DBL_MAX__;\n    }\n    if (m0 + 1 == m1){ //２点の場合は２点間の距離を返す。後にdeltaの有限性を保証\n        return (v[m0] - v[m1]).abs();\n    }\n\n    if(!isSorted) sort(v.begin(), v.end(), *xComp); //最初だけx座標で昇順にsort\n    int m = (m0 + m1) / 2;\n    double minL = getClosestPair(v, m0, m);\n    double minR = getClosestPair(v, m+1, m1);\n    double delta = min(minL, minR);\n    double minLR = getMinLR(v, m0, m1, m, delta);\n\n    return min(delta, minLR);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <cmath>\n#include <iomanip>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <class T>\nstruct real_constant;\n\ntemplate <>\nstruct real_constant<double> {\n  using value_type = double;\n  static constexpr value_type infinity() { return 1e9; }\n  static constexpr value_type epsilon() { return 1e-9; }\n  static constexpr value_type pi() { return std::acos(-1.0); }\n};\n\ntemplate <>\nstruct real_constant<long double> {\n  using value_type = long double;\n  static constexpr value_type infinity() { return 1e18; }\n  static constexpr value_type epsilon() { return 1e-10; }\n  static constexpr value_type pi() { return std::acos(-1.0L); }\n};\n\ntemplate <>\nstruct real_constant<int> {\n  using value_type = int;\n  static constexpr value_type infinity() { return 1e9; }\n  static constexpr value_type epsilon() { return 1; }\n};\n\ntemplate <>\nstruct real_constant<long long> {\n  using value_type = long long;\n  static constexpr value_type infinity() { return 1e18; }\n  static constexpr value_type epsilon() { return 1; }\n};\n\ntemplate <class T, class U>\nconstexpr bool leq(T x, U y) {\n  return x - y < real_constant<T>::epsilon();\n}\ntemplate <class T, class U>\nconstexpr bool geq(T x, U y) {\n  return y - x < real_constant<T>::epsilon();\n}\ntemplate <class T, class U>\nconstexpr bool equal(T x, U y) {\n  return leq(x, y) && geq(x, y);\n}\n\n\ntemplate <class T>\nstruct vector_type {\n  using value_type = T;\n  value_type x, y;\n  constexpr vector_type(): x(0), y(0) { }\n  constexpr vector_type(value_type x_, value_type y_): x(x_), y(y_) { }\n  constexpr vector_type &operator += (const vector_type &rhs) { x += rhs.x; y += rhs.y; return *this; }\n  constexpr vector_type operator + (const vector_type &rhs) const { return vector_type(*this) += rhs; }\n  constexpr vector_type &operator -= (const vector_type &rhs) { x -= rhs.x; y -= rhs.y; return *this; }\n  constexpr vector_type operator - (const vector_type &rhs) const { return vector_type(*this) -= rhs; }\n  constexpr vector_type operator - () const { return vector_type(-x, -y); }\n  constexpr vector_type &operator *= (value_type rhs) { x *= rhs; y *= rhs; return *this; }\n  constexpr vector_type &operator /= (value_type rhs) { x /= rhs; y /= rhs; return *this; }\n  constexpr bool operator == (const vector_type &rhs) const { return equal(x, rhs.x) && equal(y, rhs.y); }\n  constexpr bool operator != (const vector_type &rhs) const { return !equal(x, rhs.x) || !equal(y, rhs.y); }\n};\n\ntemplate <class T, class U>\nconstexpr vector_type<T> operator * (vector_type<T> v, U rhs) { return v *= rhs; }\ntemplate <class T, class U>\nconstexpr vector_type<T> operator * (U rhs, vector_type<T> v) { return v *= rhs; }\ntemplate <class T, class U>\nconstexpr vector_type<T> operator / (vector_type<T> v, U rhs) { return v /= rhs; }\n\ntemplate <class T>\nstd::istream& operator >> (std::istream& is, vector_type<T> &v) { return is >> v.x >> v.y; }\ntemplate <class T>\nstd::ostream& operator << (std::ostream& os, const vector_type<T> &v) { return os << v.x << ' ' <<  v.y; }\n\ntemplate <class T>\nconstexpr T norm(const vector_type<T> &v) { return v.x * v.x + v.y * v.y; }\ntemplate <class T>\nconstexpr T abs(const vector_type<T> &v) { return std::sqrt(norm(v)); }\ntemplate <class T>\nconstexpr T argr(const vector_type<T> &v) { return std::atan2(v.y, v.x); }\ntemplate <class T>\nconstexpr T argd(const vector_type<T> &v) { return argr(v) * 180 / real_constant<T>::pi(); }\ntemplate <class T>\nconstexpr T dist(const vector_type<T> &v, const vector_type<T> &u) { return abs(v - u); }\ntemplate <class T>\nconstexpr T dot(const vector_type<T> &v, const vector_type<T> &u) { return v.x * u.x + v.y * u.y; }\ntemplate <class T>\nconstexpr T cross(const vector_type<T> &v, const vector_type<T> &u) { return v.x * u.y - v.y * u.x; }\n\ntemplate <class T>\nconstexpr unsigned orthan(const vector_type<T> &v) {\n  if (v.x > 0 && v.y >= 0) return 0;\n  if (v.x <= 0 && v.y > 0) return 1;\n  if (v.x < 0 && v.y <= 0) return 2;\n  if (v.x >= 0 && v.y < 0) return 3;\n  return 0;\n}\ntemplate <class T>\nconstexpr bool cmp_x(const vector_type<T> &v, const vector_type<T> &u) {\n  if (equal(v.x, u.x)) return v.y < u.y;\n  return v.x < u.x;\n}\ntemplate <class T>\nconstexpr bool cmp_y(const vector_type<T> &v, const vector_type<T> &u) {\n  if (equal(v.y, u.y)) return v.x < u.x;\n  return v.y < u.y;\n}\ntemplate <class T>\nconstexpr bool cmp_arg(const vector_type<T> &v, const vector_type<T> &u) {\n  if (orthan(v) != orthan(u)) return orthan(v) < orthan(u);\n  if (!equal(cross(v, u), 0)) return cross(v, u) > 0;\n  return norm(v) < norm(u);\n}\n\ntemplate <class T>\nusing polygon = std::vector<vector_type<T>>;\n\ntemplate <class T>\nT closest_pair(typename polygon<T>::iterator begin, typename polygon<T>::iterator end) {\n  size_t size = end - begin;\n  if (size <= 1) return real_constant<T>::infinity();\n  size_t mid = size >> 1;\n  auto boundary = (begin + mid) -> x;\n  auto res = std::min(closest_pair<T>(begin, begin + mid), closest_pair<T>(begin + mid, end));\n  std::inplace_merge(begin, begin + mid, end, cmp_y<T>);\n  polygon<T> rectangle;\n  for (auto itr1 = begin; itr1 != end; ++itr1) {\n    if (geq(std::abs(itr1 -> x - boundary), res)) continue;\n    for (auto itr2 = rectangle.rbegin(); itr2 != rectangle.rend(); ++itr2) {\n      auto dx = itr1 -> x - itr2 -> x;\n      auto dy = itr1 -> y - itr2 -> y;\n      if (geq(dy, res)) break;\n      res = std::min(res, abs(vector_type<T>(dx, dy)));\n    }\n    rectangle.push_back(*itr1);\n  }\n  return res;\n}\n\ntemplate <class T>\nT closest_pair(polygon<T> poly) {\n  std::sort(poly.begin(), poly.end(), cmp_x<T>);\n  return closest_pair<T>(poly.begin(), poly.end());\n}\n\nint main() {\n  int N;\n  std::cin >> N;\n  polygon<double> poly(N);\n  for (auto &p: poly) {\n    std::cin >> p;\n  }\n  std::cout << std::fixed << std::setprecision(20);\n  std::cout << closest_pair(poly) << '\\n';\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <vector>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e9)\nusing namespace std;\ntypedef complex<double> P;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n  bool cmp_y(const P &a, const P &b){\n    return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;\n  }\n}\n\ndouble closest_pair(P *a, int n){\n  if(n <= 1) return INF;\n  int m = n/2;\n  double x = a[m].X;\n  double d = min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,cmp_y);\n  vector<P> b;\n  for(int i = 0; i < n; ++i){\n    if(abs(x-a[i].X) >= d) continue;\n    for(int j = 0; j < b.size(); ++j){\n      P dp = a[i] - b[b.size()-1-j];\n      if(dp.Y >= d) break;\n      d = min(d,abs(dp));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\ndouble compute_shortest(P *a, int n){\n  sort(a, a+n);\n  return closest_pair(a,n);\n}\n\nint main(){\n  int n;\n  cin >> n;\n  double x, y;\n  P p[n];\n  for(int i = 0; i < n; ++i){\n    cin >> x >> y;\n    p[i] = P(x,y);\n  }\n  printf(\"%.10lf\\n\", compute_shortest(p,n));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct node{\n  int dim;\n  vector<double>v;\n};\n\ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n\ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n\n  vector<node>res;\n\n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n\n    double dist=d(p,S)/(4*p.dim);\n\n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n\n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    if(S.size() == nextS.size())break;\n    S=nextS;    \n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n  \n  return ans;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n\n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\nclass Point {\n public:\n  double x, y;\n\n  Point(double x = 0, double y = 0): x(x), y(y) {}\n\n  Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n  Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n  Point operator * (double a) { return Point(a*x, a*y); }\n  Point operator / (double a) { return Point(x/a, y/a); }\n\n  double norm() { return x*x+y*y; }\n  double abs() { return sqrt(norm()); }\n\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\ntypedef Point Vector;\ntypedef vector <Vector> Polygon;\n\nclass Segment {\n public:\n  Point p1, p2;\n\n  Segment(Point p1 = Point(), Point p2 = Point()): p1(p1), p2(p2) {}\n};\n\ndouble norm(Vector a) {\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a) {\n  return sqrt(norm(a));\n}\n\ndouble getDistance(Point a, Point b) {\n  return abs(a-b);\n}\n\n// ?????????|a||b|cos\ndouble cross(Vector a, Vector b) {\n  return a.x*b.y-a.y*b.x;\n}\n// ?????????|a||b|sin\ndouble dot(Vector a, Vector b) {\n  return a.x*b.x+a.y*b.y;\n}\n\nbool compareX(Point a, Point b) {\n  return a.x < b.x;\n}\nbool compareY(Point a, Point b) {\n  return a.y < b.y;\n}\ndouble bruteForce(Polygon p) {\n  double ret = DBL_MAX;\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    for (int j = i+1; j < n; j++) {\n      if (abs(p[i]-p[j]) < ret) ret = abs(p[i]-p[j]);\n    }\n  }\n  \n  return ret;\n}\n\ndouble stripClosest(Polygon s, double d) {\n  double ret = d;\n  sort(s.begin(), s.end(), compareY);\n\n  int n = s.size();\n  // ?????????????????????6??????????????????????????????\n  for (int i = 0; i < n; i++) {\n    for (int j = i+1; j < n && (s[j].y-s[i].y) < ret; j++) {\n      if (abs(s[i]-s[j]) < ret) ret = abs(s[i]-s[j]);\n    }\n  }\n\n  return ret;\n}\n\ndouble closestUtil(Polygon p) {\n  int n = p.size();\n  if (n <= 3) return bruteForce(p);\n\n  int mid = n/2;\n  Point midPoint = p[mid];\n\n  Polygon p1, p2;\n  for (int i = 0; i < mid; i++) p1.push_back(p[i]);\n  for (int i = mid; i < n; i++) p2.push_back(p[i]);\n  double dl = closestUtil(p1);\n  double dr = closestUtil(p2);\n\n  double d = min(dl, dr);\n\n  Polygon s;\n  for (int i = 0; i < n; i++) {\n    if (abs(p[i].x-midPoint.x) < d) {\n      s.push_back(p[i]);\n    }\n  }\n\n  return min(d, stripClosest(s, d));\n}\n\ndouble closest(Polygon p) {\n  sort(p.begin(), p.end(), compareX);\n\n  return closestUtil(p);\n}\n\nint main() {\n  int n;\n  cin >> n;\n  Polygon poly;\n  for (int i = 0; i < n; i++) {\n    double x, y;\n    cin >> x >> y;\n    poly.push_back(Vector(x, y));\n  }\n  cout << fixed << setprecision(20) << closest(poly) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct node{\n  int dim;\n  vector<double>v;\n};\n \ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n \ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nmap<vector<int> ,vector<int> >grid;\n\nvector<int> neighborhood(vector<int> v, int dim, vector<int>res){\n\n  if(dim==v.size()){\n    bool fg = true;\n    for(int i=0;i<dim;i++)fg&=(res[i]==v[i]);\n    if(fg || !grid.count(res))return vector<int>();\n    return grid[res];\n  }\n  vector<int> result;\n  for(int i=-1;i<2;i++){\n    res.push_back(v[dim]+i);\n    vector<int>tmp = neighborhood(v,dim+1,res);\n    result.insert(result.end(),tmp.begin(),tmp.end());\n    res.pop_back();\n  }\n  return result;\n}\n\nvector<node> func(vector<node> S){\n  vector<node>nextS;\n  map<vector<int>,vector<int> >::iterator it = grid.begin();\n  for(;it!=grid.end();it++){\n    vector<int>res=neighborhood((*it).first,0,vector<int>());\n    for(int j=0;j<res.size();j++)nextS.push_back(S[res[j]]);\n  }\n\n  return nextS;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n \n  vector<node>res;\n \n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n \n    double dist=d(p,S)/(4*p.dim);\n \n    grid.clear();\n    for(int i=0;i<S.size();i++){\n      vector<int> key;\n      for(int j=0;j<p.dim;j++)key.push_back((int)(S[i].v[j]/dist));\n      grid[key].push_back(i);\n    }\n   \n    vector<node>tmp = func(S);\n    //if(S.size() == tmp.size())break;\n    S=tmp;\n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n   \n  return ans;\n}\n \nint main(void){\n \n  int n;\n  cin >> n;\n \n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n \n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntypedef long double LD;\ntypedef complex<LD> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> Polygon;\nconst LD EPS = 1e-10;\n#define X real() // x座標を取得\n#define Y imag() // y座標を取得\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積 Dot(a, b) = |a||b|cosθ\nLD Dot(Point a, Point b){\n    return (conj(a)*b).X;\n}\n\n// 外積 Cross(a, b) = |a||b|sinθ\nLD Cross(Point a, Point b){\n    return (conj(a)*b).Y;\n}\n\nint CCW(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if (Cross(b, c) > 0)   return +1;       // counter clockwise\n    if (Cross(b, c) < 0)   return -1;       // clockwise\n    if (Dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n//*********************************************\n//          点と線(Point and Line)            *\n//*********************************************\n\n// 交差判定 (Isec) ****************************\n// 点　 := 平面座標にある点\n// 直線 := 点と点を通るどこまでも続く線\n// 線分 := 点と点を結んでその両端で止まっている線\n\n// 直線と点\nbool IsecLP(Point a1, Point a2, Point b){\n    return abs(CCW(a1, a2, b)) != 1;\n}\n\n// 直線と直線\nbool IsecLL(Point a1, Point a2, Point b1, Point b2) {\n    return !IsecLP(a2-a1, b2-b1, 0) || IsecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool IsecLS(Point a1, Point a2, Point b1, Point b2) {\n    return Cross(a2-a1, b1-a1) * Cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool IsecSS(Point a1, Point a2, Point b1, Point b2) {\n    return CCW(a1, a2, b1)*CCW(a1, a2, b2) <= 0 && CCW(b1, b2, a1)*CCW(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool IsecSP(Point a1, Point a2, Point b) {\n    return !CCW(a1, a2, b);\n}\n\n// ********************************************\n\n\n// 距離 (Dist) ********************************\n// 点pの直線aへの射影点を返す\nPoint Proj(Point a1, Point a2, Point p){\n    return a1 + Dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nPoint Reflection(Point a1, Point a2, Point p){\n    return 2.0L*Proj(a1, a2, p) - p;\n}\n\n// 点と点\nLD DistPP(Point a, Point b){\n    return abs(a-b);\n}\n\n// 直線と点\nLD DistLP(Point a1, Point a2, Point p){\n    return abs(Proj(a1, a2, p) - p);\n}\n\n// 直線と直線\nLD DistLL(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLL(a1, a2, b1, b2) ? 0 : DistLP(a1, a2, b1);\n}\n\n// 直線と線分\nLD DistLS(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLS(a1, a2, b1, b2) ? 0 : min(DistLP(a1, a2, b1), DistLP(a1, a2, b2));\n}\n\n// 線分と点\nLD DistSP(Point a1, Point a2, Point p) {\n    if(Dot(a2-a1,p-a1) < EPS) return abs(p-a1);\n    if(Dot(a1-a2,p-a2) < EPS) return abs(p-a2);\n    return abs(Cross(a2-a1,p-a1)) / abs(a2-a1);\n}\n\n// 線分と線分\nLD DistSS(Point a1, Point a2, Point b1, Point b2) {\n    if(IsecSS(a1, a2, b1, b2)) return 0;\n    return min(min(DistSP(a1, a2, b1), DistSP(a1, a2, b2)), min(DistSP(b1, b2, a1), DistSP(b1, b2, a2)));\n}\n\n// ********************************************\n\n\n// 2直線の交点 (CrossPoint) *******************\nPoint CrossPointLL(Point a1, Point a2, Point b1, Point b2){\n    LD d1 = Cross(b2-b1, b1-a1);\n    LD d2 = Cross(b2-b1, a2-a1);\n    if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n    if (EQ(d2, 0)) throw \"not exist crosspoint\";\n    return a1 + d1/d2 * (a2-a1);\n}\n// ********************************************\n\n\n//*********************************************\n//             多角形(Polygon)                *\n//*********************************************\n\nnamespace std {\n    bool operator < (Point a, Point b){\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 多角形の面積 (PolygonErea) *****************\nLD PolygonErea(Polygon p){\n    LD area = 0;\n    int n = p.size();\n    for(int i = 0; i < n; i++){\n        area += Cross(p[i], p[(i+1) % n]);\n    }\n    return area / 2;\n}\n// ********************************************\n\n\n// 凸性判定 (IsConvex) ************************\nbool IsConvex(Polygon pol){\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        if(CCW(pol[i], pol[(i+1) % n], pol[(i+2) % n]) == -1) return false;\n    }\n    return true;\n}\n// ********************************************\n\n\n// 多角形-点包含関係 (PolygonPointContainment)\nint PolygonPointContainment(Polygon pol, Point p){\n    enum {OUT, ON, IN};\n    bool in = false;\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        Point a = pol[i] - p, b = pol[(i+1) % n] - p;\n        if(a.Y > b.Y) swap(a, b);\n        if(a.Y <= 0 && 0 < b.Y && Cross(a, b) < 0) in = !in;\n        if(Cross(a, b) == 0 && Dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n// ********************************************\n\n\n//*********************************************\n//          凸多角形(ConvexPolygon)           *\n//*********************************************\n\n// 凸包[θ<=180] (ConvexHull) *****************\nPolygon ConvexHull(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸包[θ<180] (ConvexHull2) *****************\nPolygon ConvexHull2(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸多角形の直径 (ConvexPolygonDiameter) *****\npair<int, int> ConvexPolygonDiameter(Polygon cpol){\n    int n = cpol.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(cpol[i]) > imag(cpol[is])) is = i;\n        if (imag(cpol[i]) < imag(cpol[js])) js = i;\n    }\n    LD maxd = norm(cpol[is]-cpol[js]);\n\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if(Cross(cpol[(i+1)%n] - cpol[i], cpol[(j+1)%n] - cpol[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if(norm(cpol[i]-cpol[j]) > maxd) {\n            maxd = norm(cpol[i]-cpol[j]);\n            maxi = i; maxj = j;\n        }\n    } while(i != is || j != js);\n    return make_pair(maxi, maxj);\n}\n// ********************************************\n\n\n// 凸多角形の切断 (ConvexPolygonCut) **********\nPolygon ConvexPolygonCut(Polygon cpol, Line l){\n    int n = cpol.size();\n    Polygon q;\n    for(int i = 0; i < n; i++){\n        Point a = cpol[i], b = cpol[(i+1)%n];\n        if(CCW(l.first, l.second, a) != -1) q.push_back(a);\n        if(CCW(l.first, l.second, a) * CCW(l.first, l.second, b) < 0) q.push_back(CrossPointLL(a, b, l.first, l.second));\n    }\n    return q;\n}\n// ********************************************\n\n\n// 凸多角形-点包含関係 (ConvexPolygonPointContainment)\nint ConvexPolygonPointContainment(Polygon cpol, Point p){\n    enum {OUT, ON, IN};\n    int n = cpol.size();\n    Point g = (cpol[0] + cpol[n/3] + cpol[2*n/3]) / 3.0L;\n    int a = 0, b = n;\n    while(a+1 < b){\n        int c = (a + b) / 2;\n        if(Cross(cpol[a]-g, cpol[c]-g) > 0){\n            if(Cross(cpol[a]-g, p-g) > 0 && Cross(cpol[c]-g, p-g) < 0) b = c;\n            else a = c;\n        }else{\n            if(Cross(cpol[a]-g, p-g) < 0 && Cross(cpol[c]-g, p-g) > 0) a = c;\n            else b = c;\n        }\n    }\n    b %= n;\n    if(Cross(cpol[a]-p, cpol[b]-p) < 0) return OUT;\n    if(Cross(cpol[a]-p, cpol[b]-p) > 0) return IN;\n    return ON;\n}\n// ********************************************\n\n// 最近点対 (ClosestPair) *********************\npair<Point, Point> ClosestPair(Polygon p){\n    int n = p.size();\n    sort(p.begin(), p.end(), [](Point p, Point q) { return p.Y < q.Y; });\n    \n    auto u = p[0], v = p[1];\n    auto best = Dot(u-v, u-v);\n    auto update = [&](Point p, Point q) {\n        auto dist = Dot(p-q, p-q);\n        if (best > dist) { best = dist; u = p; v = q; }\n    };\n    set<Point> S; S.insert(u); S.insert(v);\n    for (int l = 0, r = 2; r < n; ++r) {\n        if (S.count(p[r])) return {p[r], p[r]};\n        if ((p[l].Y-p[r].Y)*(p[l].Y-p[r].Y) > best) S.erase(p[l++]);\n        auto i = S.insert(p[r]).first;\n        for (auto j = i; ; ++j) {\n            if (j == S.end() || (i->X-j->X)*(i->X-j->X) > best) break;\n            if (i != j) update(*i, *j);\n        }\n        for (auto j = i; ; --j) {\n            if (i != j) update(*i, *j);\n            if (j == S.begin() || (i->X-j->X)*(i->X-j->X) > best) break;\n        }\n    }\n    return make_pair(u, v);\n}\n// ********************************************\n\n\n/************** using variables ***************/\nPolygon p;\nint n;\nint q;\n/**********************************************/\n\nsigned main(){\n    cin >> n;\n    REP(i, n){\n        LD xp, yp;\n        cin >> xp >> yp;\n        p.pb(Point(xp, yp));\n    }\n\n   pair<Point, Point> ans = ClosestPair(p);\n   printf(\"%.9Lf\\n\", DistPP(ans.first, ans.second));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn 1e9;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP\n){\n\tint siz=xr-xl;\n\tint ypsiz=yP.size();\n\tif (siz <= 4) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tauto xM = xP[xl+siz/2].first;\n\tauto yL = std::vector<point_t>();\n\tyL.reserve(ypsiz/2);\n\tauto yR = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {\n\t\treturn p.first <= xM;\n\t});\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {\n\t\treturn p.first > xM;\n\t});\n\tauto p1 = find_closest_optimized(xP,xl,xl+siz/2, yL);\n\tauto p2 = find_closest_optimized(xP,xl+siz/2,xr, yR);\n\tauto minD = sqrt((p1 <= p2) ? p1 : p2);\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n, yP);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<vector>\n#include<cmath>\n#include<algorithm>\n\nconst double INF = 1e9;\nconst double EPS = 1e-9;\n\nstruct Point {\n    Point() :x(INF), y(INF) {}\n    Point(double x, double y) :x(x), y(y) {}\n    bool operator==(const Point& p) const {return x == p.x && y == p.y;}\n    double x, y;\n};\nstruct Compare {\n    bool f;\n    Compare(bool f = false) :f(f) {}\n    bool operator()(const Point& lhs, const Point& rhs) const {return f ? lhs.y < rhs.y : lhs.x < rhs.x;}\n};\ndouble distance(const Point& lhs, const Point& rhs) {return std::hypot(lhs.x - rhs.x, lhs.y - rhs.y);}\n\nstruct Result {\n    double d;\n    Point p1, p2;\n    Result() :d(INF) {}\n    Result(double d, const Point p1, const Point p2) :d(d), p1(p1), p2(p2) {}\n};\nbool operator<(const Result& lhs, const Result& rhs) {return lhs.d < rhs.d;}\n\nResult closest_pair_recursion(const std::vector<Point>::const_iterator& begin, const std::vector<Point>::const_iterator& end) {\n    int size = end - begin;\n    if(size <= 1) return Result();\n\n    auto mid = begin + size / 2;\n    Result r = std::min(closest_pair_recursion(begin, mid), closest_pair_recursion(mid, end));\n\n    auto left = std::lower_bound(begin, end, Point(mid->x - r.d - EPS, mid->y), Compare());\n    auto right = std::upper_bound(left, end, Point(mid->x + r.d + EPS, mid->y), Compare());\n    std::vector<Point> y_sorted(left, right);\n    std::sort(y_sorted.begin(), y_sorted.end(), Compare(true));\n\n//     for(auto i = y_sorted.begin(); i != y_sorted.end(); ++i) {\n//         auto top = std::upper_bound(i + 1, y_sorted.end(), Point(i->x, i->y + r.d + EPS), Compare(true));\n//         for(auto j = i + 1; j != top; ++j) {\n//             if(distance(*i, *j) >= r.d) continue;\n//             r = Result(distance(*i, *j), *i, *j);\n//         }\n//     }\n    for(auto i = y_sorted.begin(); i != y_sorted.end(); ++i) {\n        for(auto j = i + 1; j != y_sorted.end(); ++j) {\n            if(j->y - i->y >= r.d) break;\n            if(distance(*i, *j) >= r.d) continue;\n            r = Result(distance(*i, *j), *i, *j);\n        }\n    }\n    return r;\n}\nResult closest_pair(std::vector<Point> point) {\n    std::sort(point.begin(), point.end(), Compare());\n    return closest_pair_recursion(point.begin(), point.end());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n#include<iostream>\n#include<iomanip>\nusing namespace std;\n\nint main() {\n    int n;\n    vector<Point> v;\n    for(cin >> n; n > 0; --n) {\n        double x, y;\n        cin >> x >> y;\n        v.push_back(Point(x, y));\n    }\n    auto res = closest_pair(v);\n    cout <<setprecision(12) << fixed << res.d << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n       \nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n       \nconst double EPS = 1e-10;\nconst double PI = acos(-1);\nbool equals(double a, double b) { return fabs(a - b) < EPS; }\n\nclass Point {\n  double add(double a, double b) const {\n    if (fabs(a + b) < EPS * (fabs(a) + fabs(b))) return 0;\n    return a + b;\n  }\n\n public:\n  double x, y;\n\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n  Point operator+(const Point &p) const {\n    return Point(add(x, p.x), add(y, p.y));\n  }\n  Point operator-(const Point &p) const {\n    return Point(add(x, -p.x), add(y, -p.y));\n  }\n  Point operator*(const double a) { return Point(a * x, a * y); }\n  Point operator/(const double a) { return Point(x / a, y / a); }\n\n  double abs() const { return sqrt(norm()); }\n  double norm() const { return x * x + y * y; }\n\n  Point rotate(double theta) const {\n    return Point(cos(theta) * x - sin(theta) * y,\n                 sin(theta) * x + cos(theta) * y);\n  }\n\n  Point normalize() const { return Point(*this) / abs(); }\n\n  bool operator<(const Point &p) const { return x != p.x ? x < p.x : y < p.y; }\n\n  bool operator==(const Point &p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n\n  friend istream &operator>>(istream &is, Point &p) { return is >> p.x >> p.y; }\n};\n\ndouble abs(const Point &p) { return p.abs(); }\ndouble norm(const Point &p) { return p.norm(); }\n\ntypedef Point Vector;\n\nclass Segment {\n public:\n  Point p1, p2;\n  Segment() {}\n  Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n  friend istream &operator>>(istream &is, Segment &s) {\n    return is >> s.p1 >> s.p2;\n  }\n};\n\ntypedef Segment Line;\n\nclass Circle {\n public:\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n\n  int contains(const Point &p) const {\n    double d = abs(c - p);\n    if (equals(d, r)) return 1;\n    if (d < r + EPS) return 2;\n    return 0;\n  }\n};\n\ntypedef vector<Point> Polygon;\n\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\n\nbool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2) {\n  return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n  return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p) {\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / base.norm();\n  return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p) * 2.0; }\n\ndouble distance(Point a, Point b) { return (a - b).abs(); }\n\ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.p2 - l.p1, p - l.p1)) / (l.p2 - l.p1).abs();\n}\n\ndouble distanceSP(Segment s, Point p) {\n  if (dot(s.p2 - s.p1, p - s.p1) < -EPS) return (p - s.p1).abs();\n  if (dot(s.p1 - s.p2, p - s.p2) < -EPS) return (p - s.p2).abs();\n  return distanceLP(s, p);\n}\n\nbool intersect(Segment s1, Segment s2);\ndouble distance(Segment s1, Segment s2) {\n  if (intersect(s1, s2)) return 0.0;\n  return min({distanceSP(s1, s2.p1), distanceSP(s1, s2.p2),\n              distanceSP(s2, s1.p1), distanceSP(s2, s1.p2)});\n}\n\nenum CCW {\n  COUNTER_CLOCKWISE = 1,\n  CLOCKWISE = -1,\n  ONLINE_BACK = 2,\n  ONLINE_FRONT = -2,\n  ON_SEGMENT = 0,\n};\n\nCCW ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if (cross(a, b) < -EPS) return CLOCKWISE;\n  if (dot(a, b) < -EPS) return ONLINE_BACK;\n  if (a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool onLine(Line l, Point p) {\n  int c = ccw(l.p1, l.p2, p);\n  return c != CLOCKWISE && c != COUNTER_CLOCKWISE;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n          ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint crossPoint(Line s1, Line s2) {\n  assert(!isParallel(s1, s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = cross(base, s2.p1 - s1.p1);\n  double d2 = cross(base, s1.p2 - s1.p1);\n  double t = d1 / d2;\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nbool intersect(Circle c, Line l) { return distanceLP(l, c.c) < c.r; }\n\npair<Point, Point> crossPoint(Circle c, Line l) {\n  assert(intersect(c, l));\n  Vector pr = project(l, c.c);\n  Vector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n  double base = sqrt(c.r * c.r - norm(pr - c.c));\n  return make_pair(pr + e * base, pr - e * base);\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\nbool intersect(Circle c1, Circle c2) {\n  return (c1.c - c2.c).abs() < c1.r + c2.r;\n}\n\npair<Point, Point> crossPoint(Circle c1, Circle c2) {\n  assert(intersect(c1, c2));\n  double d = abs(c1.c - c2.c);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = arg(c2.c - c1.c);\n  return make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\nint contains(const Polygon &g, Point p) {\n  int n = g.size();\n  bool x = false;\n  for (int i = 0; i < n; ++i) {\n    Point a = g[i] - p, b = g[(i + 1) % n] - p;\n    if (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n    if (a.y > b.y) swap(a, b);\n    if (a.y < EPS & EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? 2 : 0);\n}\n\nPolygon convexHull(Polygon s, bool includeOnSegment = false) {\n  Polygon u, l;\n\n  if (s.size() < 3) return s;\n  sort(s.begin(), s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size() - 1]);\n  l.push_back(s[s.size() - 2]);\n\n  auto bad = [&](Point p1, Point p2, Point p3) {\n    if (includeOnSegment) {\n      return ccw(p1, p2, p3) == COUNTER_CLOCKWISE;\n    } else {\n      return ccw(p1, p2, p3) != CLOCKWISE;\n    }\n  };\n\n  for (int i = 2; i < s.size(); ++i) {\n    for (int n = u.size(); n >= 2 && bad(u[n - 2], u[n - 1], s[i]); --n) {\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n\n  for (int i = s.size() - 3; i >= 0; i--) {\n    for (int n = l.size(); n >= 2 && bad(l[n - 2], l[n - 1], s[i]); --n) {\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n\n  reverse(l.begin(), l.end());\n  for (int i = u.size() - 2; i >= 1; --i) l.push_back(u[i]);\n\n  return l;\n}\n\nCircle circumscribedCircle(const Point &a, const Point &b, const Point &c) {\n  double a1, a2, b1, b2, c1, c2;\n  a1 = 2 * (b.x - a.x);\n  b1 = 2 * (b.y - a.y);\n  c1 = a.x * a.x - b.x * b.x + a.y * a.y - b.y * b.y;\n  a2 = 2 * (c.x - a.x);\n  b2 = 2 * (c.y - a.y);\n  c2 = a.x * a.x - c.x * c.x + a.y * a.y - c.y * c.y;\n  Point p;\n  p.x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n  p.y = (c1 * a2 - c2 * a1) / (a1 * b2 - a2 * b1);\n\n  return Circle(p, abs(p - a));\n}\ndouble area(const Polygon &p) {\n  double ans = 0;\n  const int N = p.size();\n  for (int i = 0; i < N; ++i) {\n    Point q = p[(i + 1) % N];\n    ans += (p[i].y + q.y) * (q.x - p[i].x);\n  }\n  ans /= 2.0;\n  return fabs(ans);\n}\nbool isConvex(const Polygon &p) {\n  const int N = p.size();\n\n  for (int i = 0; i < N; ++i) {\n    Point pn = p[(i + 1) % N], pnn = p[(i + 2) % N];\n    int d = ccw(p[i], pn, pnn);\n    if (d == CLOCKWISE) return false;\n  }\n  return true;\n}\npair<Point, Point> farthestPoints(const Polygon &p) {\n  Polygon ch = convexHull(p);\n\n  int n = ch.size();\n  if (n == 2) return make_pair(ch[0], ch[1]);\n  int i = 0, j = 0;\n  for (int k = 0; k < n; ++k) {\n    if (!(ch[i] < ch[k])) i = k;\n    if (ch[j] < ch[k]) j = k;\n  }\n\n  pair<Point, Point> res;\n  double d = 0;\n  int si = i, sj = j;\n  while (i != sj || j != si) {\n    double cd = abs(ch[i] - ch[j]);\n    if (cd > d) {\n      d = cd;\n      res = make_pair(ch[i], ch[j]);\n    }\n\n    if (cross(ch[(i + 1) % n] - ch[i], ch[(j + 1) % n] - ch[j]) < 0) {\n      i = (i + 1) % n;\n    } else {\n      j = (j + 1) % n;\n    }\n  }\n  return res;\n}\n\ndouble diameter(const Polygon &p) {\n  pair<Point, Point> pts = farthestPoints(p);\n  return abs(pts.first - pts.second);\n}\n\nPolygon convexCut(const Polygon &p, const Line &l) {\n  const int n = p.size();\n  Polygon res;\n\n  for (int i = 0; i < n; ++i) {\n    int j = (i + 1) % n;\n    Segment s = Segment(p[i], p[j]);\n\n    if (isParallel(s, l)) continue;\n    Point q = crossPoint(s, l);\n    if (ccw(p[i], p[j], q) != ON_SEGMENT) continue;\n    if (cross(l.p2 - l.p1, s.p2 - s.p1) < EPS) continue;\n    res.push_back(q);\n\n    for (;; j = (j + 1) % n) {\n      res.push_back(p[j]);\n      Segment s = Segment(p[j], p[(j + 1) % n]);\n      if (isParallel(s, l)) continue;\n\n      Point q = crossPoint(Segment(p[j], p[(j + 1) % n]), l);\n      if (ccw(p[j], p[(j + 1) % n], q) != ON_SEGMENT) continue;\n      if (cross(l.p2 - l.p1, s.p2 - s.p1) > -EPS) continue;\n      res.push_back(q);\n      return res;\n    }\n  }\n  if (ccw(l.p1, l.p2, p[0]) == COUNTER_CLOCKWISE) return p;\n  return res;\n}\n\nclass ClosestPair {\n  struct Pair {\n    Point p1, p2;\n    double d;\n    Pair(const Point &p1, const Point &p2) : p1(p1), p2(p2), d(abs(p1 - p2)){};\n    bool operator<(const Pair &that) const { return d < that.d; }\n  };\n\n  vector<Point> P;\n  Pair INF = Pair(Point(-INFINITY, -INFINITY), Point(INFINITY, INFINITY));\n  Pair result;\n\n  static bool lessY(const Point &a, const Point &b) { return a.y < b.y; };\n  Pair divideAndConquer(int l, int r) {\n    if (r - l <= 1) return INF;\n\n    int m = (l + r) / 2;\n    double x = P[m].x;\n    Pair res = min(divideAndConquer(l, m), divideAndConquer(m, r));\n    auto it = P.begin();\n    inplace_merge(it + l, it + m, it + r, lessY);\n\n    vector<Point> b;\n    for (int i = l; i < r; ++i) {\n      if (fabs(P[i].x - x) >= res.d) continue;\n\n      for (int j = int(b.size()) - 1; j >= 0; --j) {\n        if (P[i].y - b[j].y >= res.d) break;\n        res = min(res, Pair(P[i], b[j]));\n      }\n      b.push_back(P[i]);\n    }\n    return res;\n  };\n\n public:\n  ClosestPair(const vector<Point> &_P) : P(_P), result(INF) {\n    sort(P.begin(), P.end(),\n         [](const Point &a, const Point &b) { return a.x < b.x; });\n\n    result = divideAndConquer(0, P.size());\n  }\n\n  double distance() { return result.d; }\n\n  pair<Point, Point> points() { return make_pair(result.p1, result.p2); }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  vector<Point> P(n);\n  for (int i = 0; i < (int)(n); ++i) cin >> P[i];\n\n  ClosestPair cp(P);\n  printf(\"%.10lf\", cp.distance());\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <random>\n#include <unordered_map>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n    Point* next;\n};\n\nuint64_t toKey(int x, int y){\n    union Key{\n        uint64_t key;\n        int x[2];\n    };\n    Key K;\n    K.x[0]=x, K.x[1]=y;\n    return K.key;\n}\n\nvoid build(unordered_map<uint64_t, Point*>& Grid, double d, int i, Point *P){\n    Grid.clear();\n    for(int j=0;j<=i;j++){\n        int x=floor(P[j].x/d),y=floor(P[j].y/d);\n        uint64_t key = toKey(x,y);\n        if(Grid.count(key)!=0){\n            P[j].next=Grid[key];\n        }\n        Grid[key]=&P[j];\n    }\n}\n\ndouble distance(Point& a, Point &b){\n    return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\ndouble search(unordered_map<uint64_t, Point*>& Grid, double d, Point& P){\n    int x=floor(P.x/d),y=floor(P.y/d);\n    uint64_t key;\n    double minimum=1e10;\n    for(int dx=-1;dx<2;dx++){\n        for(int dy=-1;dy<2;dy++){\n            key=toKey(x+dx,y+dy);\n            if(Grid.count(key)){\n                Point *p=Grid[key];\n                while(p!=NULL){\n                    if(minimum>distance(*p,P)) minimum=distance(*p,P);\n                    p=p->next;\n                }\n            }\n        }\n    }\n    return minimum;\n}\n\nvoid insert(unordered_map<uint64_t, Point*>& Grid, double d, Point& P){\n    int x=floor(P.x/d),y=floor(P.y/d);\n    uint64_t key = toKey(x,y);\n    if(Grid.count(key)!=0){\n        P.next=Grid[key];\n    }\n    Grid[key]=&P;\n}\n\nint main(){\n    int n;\n    //cin >> n;\n    scanf(\"%d\",&n);\n    Point P[n];\n    for(int i=0;i<n;i++){\n        //cin >> P[i].x >> P[i].y;\n        scanf(\"%lf %lf\",&P[i].x,&P[i].y);\n        P[i].next=NULL;\n    }\n    //??????????????£???????????????\n    random_device rd;\n    mt19937 mt(rd());//?????????????????§?????????????????????????????????\n    uniform_int_distribution<int> dist(0,n-1);\n    for(int i=0;i<n;i++){\n        int j = dist(mt);\n        Point p = P[i];\n        P[i]=P[j];\n        P[j]=p;\n    }\n    unordered_map<uint64_t, Point*> Grid;\n    double delta=distance(P[0],P[1]);\n    build(Grid,delta,1,P);\n    for(int i=2;i<n;i++){\n        double d2=search(Grid,delta,P[i]);\n        if(d2>=delta){\n            insert(Grid,delta,P[i]);\n        }else{\n            delta=d2;\n            build(Grid,delta,i,P);\n        }\n    }\n    cout.precision(6);\n    cout << fixed;\n    cout << delta << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i+j<N&&memo >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\tj++;\n\t\tmemo = min(ans, memo);\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @note   関連URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = limits::inf;\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) >= delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout.setf(ios::fixed);\n    cout.precision(8);\n    cout << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(__typeof((o).begin()) it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T> >& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){EACH(a,ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;EACH(p,m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\ntemplate<> long double INF<long double>(){return 1e16;};\n\ntemplate<typename T> T pmod(T v,T M){return (v%M+M)%M;}\n\nnamespace _double_tmpl{\n    typedef long double D;const D EPS = 1e-8;\n    \n    static constexpr D Ae=0;\n    D A(D a,D b){return a+b;}D Ainv(D a){return -a;}\n    D S(D a,D b){return A(a,Ainv(b));}\n    \n    static constexpr D Me=1;\n    D M(D a,D b){return a*b;}D Minv(D a){return 1.0/a;};\n\n    int sig(D a,D b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n    bool eq(D a,D b){ return sig(abs(a-b))==0;}\n\n}\nusing namespace _double_tmpl;\n\n\nnamespace Ps{\n    // using namespace _double_tmpl;\n    typedef complex<D> P,Vec;\n\n#define X real()\n#define Y imag()\n    istream& operator >> (istream& is,complex<D>& p){\n        D x,y;is >> x >> y;p=P(x,y);return is;\n    }\n\n    bool eq(P a,P b){return eq(a.X,b.X) and eq(a.Y,b.Y);}\n    // a×b\n    D cross(const Vec& a,const Vec& b){return imag(conj(a)*b);}\n    // a・b\n    D dot(const Vec&a,const Vec& b) {return real(conj(a)*b);}\n\n    int ccw(const P& a,P b,P c){\n        b -= a; c -= a;\n        if (cross(b,c) > EPS)   return +1;       // counter clockwise\n        if (cross(b,c) < -EPS)   return -1;       // clockwise\n        if (dot(b,c) < 0)     return +2;       // c--a--b on line\n        if (norm(b) < norm(c)) return -2;       // a--b--c on line\n        return 0;\n    }\n\n    bool compX (const P& a,const P& b);bool compY (const P& a,const P& b);\n    D closestPair(vector<P>& ps,int l,int r){\n        if(r-l<2)return INF<D>();\n        D res=INF<D>();\n        res=min(res,closestPair(ps,l,(l+r)/2));\n        res=min(res,closestPair(ps,(l+r)/2,r));\n        \n        vector<P> lps,rps;\n        D lym=INF<D>(),lyM=-INF<D>(),rym=INF<D>(),ryM=-INF<D>();\n        FOR(i,l,(l+r)/2)if(abs(ps[i].X - ps[(l+r)/2].X)<res)lps.push_back(ps[i]),lym=min(lym,lps[i].Y),lyM=max(lyM,lps[i].Y);\n        FOR(i,(l+r)/2,r)if(abs(ps[i].X - ps[(l+r)/2].X)<res)rps.push_back(ps[i]),rym=min(rym,rps[i].Y),ryM=max(ryM,rps[i].Y);\n        vector<P> lps2,rps2;\n        REP(i,lps.size())if(rym-res<=lps[i].Y && lps[i].Y<=ryM+res)lps2.push_back(lps[i]);\n        REP(i,rps.size())if(lym-res<=rps[i].Y && rps[i].Y<=lyM+res)rps2.push_back(rps[i]);\n\n        REP(i,lps2.size())REP(j,rps2.size())res=min(res,abs(lps2[i]-rps2[j]));\n        return res;\n    }\n}\nusing namespace Ps;\n\nnamespace std{\n\n    bool compX (const P& a,const P& b){return a.X != b.X ? a.X < b.X : a.Y < b.Y;}\n    bool compY (const P& a,const P& b){return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;}\n    bool operator < (const P& a,const P& b){return compX(a,b);}\n    bool operator == (const P& a,const P& b){return eq(a,b);}\n};\n\nstringstream ss;\nclass Main{\n    public:\n    void run(){\n        int n;cin >> n;\n        vector<P> ps;\n        REP(i,n) {\n            P p;cin >> p;\n            ps.push_back(p);\n        }\n        sort(ALL(ps));\n        cout << closestPair(ps,0,n)<<endl;\n    }\n};\n\nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\n\nint main(void)\n{\n    double dis=1000.0,temp;\n    int n;\n    double x[1000],y[1000];\n\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>x[i]>>y[i];\n    \n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            if(i!=j)\n            {\n               temp = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n               if(dis>temp)\n                    dis=temp;\n            }\n        }\n    }\n\n    printf(\"%lf\\n\",dis);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <algorithm>\n# include <cmath>\n# include <cstdio>\n# include <iostream>\n# include <vector>\nusing namespace std;\n\nstatic const double eps = 1e-10;\n\nint N;\n\nbool eq(double a, double b) {return fabs(a - b) < eps;}\nstruct Point \n{\n\tdouble x, y;\n};\nPoint operator -(Point a, Point b){return (Point) {a.x - b.x, a.y - b.y};}\nint compx(const Point & a, const Point & b) {return eq(a.x, b.x) ? a.y < b.y : a.x < b.x;}\nint compy(const Point & a, const Point & b) {return eq(a.y, b.y) ? a.x < b.x : a.y < b.y;}\ndouble norm(Point a) {return a.x * a.x + a.y * a.y;}\ndouble abs(Point a) {return sqrt(norm(a));}\nPoint p[100050];\n\ndouble ClosestPair(Point * p, int n)\n{\n\tif(n <= 1) return 1e9;\n\tint m = n / 2;\n\tdouble tx = p[m].x;\n\tdouble d = min(ClosestPair(p, m), ClosestPair(p + m, n - m));\n\tinplace_merge(p, p + m, p + n, compy);\n\tvector<Point> q;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(fabs(tx - p[i].x) >= d) continue;\n\t\tfor(int j = q.size() - 1; ~ j; j--)\n\t\t{\n\t\t\tPoint v = p[i] - q[j];\n\t\t\tif(v.y >= d) break;\n\t\t\td = min(d, abs(v));\n\t\t}\n\t\tq.push_back(p[i]);\n\t}\n\treturn d;\n}\n\nint main()\n{\n\tscanf(\"%d\", & N);\n\tfor(int i = 0; i < N; i++) scanf(\"%lf%lf\", & p[i].x, & p[i].y);\n\tsort(p, p + N, compx);\n\tprintf(\"%.11lf\\n\", ClosestPair(p, N));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nstruct P\n{\n\tdouble x, y;\n\tP(double x,double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nint ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}\n\ndouble ClosestPair(vector<P>& points,int l,int r)\n{\n\tif (r - l == 1)\n\t{\n\t\treturn INF;\n\t}\n\tif (r - l == 2)\n\t{\n\t\treturn (points[l] - points[l + 1]).length2();\n\t}\n\n\tint m = (l + r) / 2;\n\tdouble d = min(ClosestPair(points, l, m), ClosestPair(points, m, r));\n\n\tvector<P> tempP;\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tif ((points[l].x - points[m].x)*(points[l].x - points[m].x) < d)\n\t\t{\n\t\t\ttempP.emplace_back(P(points[i].y, points[i].x));\n\t\t}\n\t}\n\tsort(tempP.begin(), tempP.end());\n\tfor (int i = 0; i != tempP.size(); i++)\n\t{\n\t\tfor (int j = i + 1; j != tempP.size(); j++)\n\t\t{\n\t\t\tif ((tempP[j].x - tempP[i].x)*(tempP[j].x - tempP[i].x) > d)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, (tempP[i] - tempP[j]).length2());\n\t\t}\n\t}\n\n\treturn d;\n}\n\nvector<P> points;\n\nint main()\n{\n\tpoints.reserve(100000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpoints.push_back(P(x, y));\n\t}\n\n\tsort(points.begin(), points.end());\n\n\tprintf(\"%.10lf\\n\", sqrt(ClosestPair(points, 0, n)));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn -1;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP\n){\n\tint siz=xr-xl;\n\tif (siz <= 5) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tauto xM = xP[xl+siz/2].first;\n\tauto yL = std::vector<point_t>();\n\tauto yR = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {\n\t\treturn p.first <= xM;\n\t});\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {\n\t\treturn p.first > xM;\n\t});\n\tauto p1 = find_closest_optimized(xP,xl,xl+siz/2, yL);\n\tauto p2 = find_closest_optimized(xP,xl+siz/2,xr, yR);\n\tauto minD = sqrt((p1 <= p2) ? p1 : p2);\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n, yP);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef complex<double> C;\n\nnamespace std\n{\n    bool operator < (const C& a, const C& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(const C &a, const C &b) {\n        push_back(a); push_back(b);\n    }\n};\n\n//??????\ndouble cross(const C& a, const C& b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C& a, const C& b)\n{\n    return real(conj(a)*b);\n}\n\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n//??´???????????????????????????(????????´??????True)\nbool intersectLL(const L &l, const L &m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//??´?????¨?????????????????????(????????±??????????????¨??????)\nbool intersectLS(const L &l, const L &s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//??´?????¨????????????(??±???)??????\nbool intersectLP(const L &l, const C &p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//??????????????????????????????(????????±??????????????¨??????)\nbool intersectSS(const L &s, const L &t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//????????¨????????????(??±???)??????\nbool intersectSP(const L &s, const C &p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//???p?????´???l???????°???±\nC projection(const L &l, const C &p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//???p?????´???l????????¨??????????§°?§????\nC reflection(const L &l, const C &p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//?????¨??´???????????¢\ndouble distanceLP(const L &l, const C &p)\n{\n    return abs(p - projection(l, p));\n}\n//??´?????¨??´???????????¢\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//??´?????¨??????????????¢\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//????????¨???????????¢\ndouble distanceSP(const L &s, const C &p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//????????¨??????????????¢\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n//??´???????????????????????????\nC crosspoint(const L &l, const L &m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//?????????????????????\nL crosspointSS(C &p1,int r1,C &p2,int r2)\n{\n    double d = norm(p2-p1);\n    double t = r2*r2 - r1*r1 - d;\n    double aa = d,bb = t*(real(p2)-real(p1)),cc = t*t / 4.0 - (imag(p2) - imag(p1))*(imag(p2) - imag(p1))*r1*r1;\n    double x1 = (-bb - sqrt(bb*bb - 4*aa*cc))/(2*aa),x2 = (-bb + sqrt(bb*bb - 4*aa*cc))/(2*aa);\n    double y1,y2;\n    if(imag(p1) == imag(p2)){\n        y1 = -sqrt(r1*r1 - x1*x1);\n        y2 = -y1;\n    }else{\n        y1 = (t+2*(real(p2)-real(p1))*x1)/(-2*(imag(p2)-imag(p1)));\n        y2 = (t+2*(real(p2)-real(p1))*x2)/(-2*(imag(p2)-imag(p1)));\n    }\n    L ln = L(C(x1+real(p1),y1+imag(p1)),C(x2+real(p1),y2+imag(p1)));\n    return ln;\n}\n//??????????±???????\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//?????§??????\nbool isconvex(const vector<C> &ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//????§???¢?????¢???\ndouble area(const vector<C> &ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//???????§???¢?????´?????§???????????????????????´????????¢\nvector<C> convex_cut(const vector<C> &ps, const L &l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspoint(L(A, B), l));\n    }\n    return Q;\n}\n//??????????§???¢???????????????????????????(0??????????????????,1?????????,2???????????????)\nint contains(const vector<C>& ps, const C& p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//???????§???¢?????´???????±???????(?????£????????????)\n//maxi,maxj?????????????????¨??????\ndouble convex_diameter(const vector<C> &ps)\n{\n    const int n = ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\ndouble closest_pair(C *a, int n){\n    if(n<=1) return INF;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,[](C c1,C c2){return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();});\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\ndouble compute_shortest(C *a,int n){\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    C p[100005];\n    rep(i,n){\n        double x,y;\n        cin >> x >> y;\n        p[i] = C(x,y);\n    }\n    printf(\"%.10f\\n\",compute_shortest(p,n));\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ndouble x[110000];\ndouble y[110000];\npair<double,double>p[110000];\nint main(){\n    int a;scanf(\"%d\",&a);\n    for(int i=0;i<a;i++){\n        double X,Y;\n        scanf(\"%lf%lf\",&X,&Y);\n        x[i]=cos(1)*X-sin(1)*Y;\n        y[i]=sin(1)*X+cos(1)*Y;\n        p[i]=make_pair(x[i],y[i]);\n    }\n    std::sort(p,p+a);\n    double ret=99999999;\n    for(int i=0;i<a;i++){\n        for(int j=i-1;j>=0;j--){\n            if(p[i].first-p[j].first>ret)break;\n            ret=min(ret,sqrt((p[i].first-p[j].first)*(p[i].first-p[j].first)+(p[i].second-p[j].second)*(p[i].second-p[j].second)));\n        }\n    }\n    printf(\"%.12f\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define SZ(x) (int)(x).size()\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<LL, LL> pll;\n\nconst double eps = 1e-10;\nconst double PI = acos(-1.0);\n//const double PI = 3.14159265358979323846264338327950288419716939937510\nint dcmp(const double &x) { if (fabs(x) < eps) return 0; return x < 0 ? -1 : 1; }\nconst int MOD = 1e9 + 7;\nconst int INF = 2e9;\nconst double INF_d = 1e64;\n\ntemplate<class T> \nT qmod(T a, T b){ T ret = 1; while (b){ if (b & 1) ret *= a; b >>= 1; a *= a; } return ret; }\ntemplate<class T>\nT gcd(T a, T b){ return !b ? a : gcd(b, a % b); }\ntemplate<class T>\nT ex_gcd(T a, T b, T &x, T &y){\n    if (!b){ x = 1, y = 0; return a; }\n    T t, ret;\n    ret = ex_gcd(b, a % b, x, y);\n    t = x, x = y, y = t - a / b * y;\n    return ret;\n}\ntemplate<class T>\nT inv(T t, T p){ return t == 1 ? 1 : (p - p / t) * inv(p % t, p) % p; }\n// head\n\ntypedef double db;\n\nstruct point{\n    db x, y;\n    point(){}\n    point(db a, db b): x(a), y(b){}\n    point operator + (const point &p){ return point(x + p.x, y + p.y); }\n    point operator - (const point &p){ return point(x - p.x, y - p.y); }\n    point operator * (const db &k){ return point(x * k, y * k); }\n    point operator / (const db &k){ return point(x / k, y / k); }\n    db operator ^ (const point &p){ return x * p.y - y * p.x; }\n    db operator * (const point &p){ return x * p.x + y * p.y; }\n    bool operator == (const point &p){ return !dcmp(x - p.x) && !dcmp(y - p.y); }\n    bool operator != (const point &p){ return dcmp(x - p.x) || dcmp(y - p.y); }\n    bool operator < (const point &p){ return x == p.x ? y < p.y : x < p.x; }\n    void read(){\n        scanf(\"%lf%lf\", &x, &y);\n    }\n    void print(){\n        printf(\"%.10f %.10f\\n\", x, y);\n    }\n    point rotate(db &ang){ return point(x * cos(ang) - y * sin(ang), y * cos(ang) + x * sin(ang)); }\n    point norm() { return point(-y, x); }\n    db len() { return sqrt(x * x + y * y); }\n    db len2(){ return x * x + y * y; }\n};\n\npoint err = point(INF_d, INF_d);\n\npoint proj_SP(point A, point B, point P){ // projection point of P in segment AB\n    point AB = B - A, AP = P - A;\n    return A + AB * (AP * AB / AB.len2());\n}\n\npoint refl_SP(point A, point B, point P){ // reflection point of P int segment AB\n    return proj_SP(A, B, P) * 2 - P;\n}\n\nstruct line{\n    point p[2], u;\n    line(){}\n    line(point s, point t){\n        p[0] = s, p[1] = t;\n        u = p[1] - p[0];\n    }\n    point get_point(double t){\n        return point(p[0] + u * t);\n    }\n};\n\nbool parallel(line L1, line L2){ // check whether two lines L1 and L2 are parallel\n    return !dcmp(L1.u ^ L2.u);\n}\n\nbool orthogonal(line L1, line L2){ // check whether two lines L1 and L2 are orthogonal\n    return !dcmp(L1.u * L2.u);\n}\n\npair<bool, point> inter_LL(line L1, line L2){ // calculate the intersection of two lines L1 and L2\n    if (parallel(L1, L2)) return mp(false, err);\n    double t = ((L2.p[0] - L1.p[0]) ^ L2.u) / (L1.u ^ L2.u);\n    return mp(true, L1.get_point(t));\n}\n\nbool one_dimention_check(db a, db b, db c, db d){ // check whether two one-dimention segments has intersection\n    if (dcmp(a - b) > 0) swap(a, b);\n    if (dcmp(c - d) > 0) swap(c, d);\n    return dcmp(b - c) >= 0 && dcmp(a - d) <= 0; \n}\n\nbool check_SS(point A, point B, point C, point D){ // check whether two segments AB and CD has intersection\n    bool flag = one_dimention_check(A.x, B.x, C.x, D.x) && one_dimention_check(A.y, B.y, C.y, D.y);\n    double a = dcmp((A - C) ^ (D - C)), b = dcmp((B - C) ^ (D - C)),\n            c = dcmp((C - A) ^ (B - A)), d = dcmp((D - A) ^ (B - A));\n    return flag && dcmp(a * b) <= 0 && dcmp(c * d) <= 0;\n}\n// calculate the intersection point of two segments, first check and then call inter_LL to get the cross point\n\nbool inmid(db a, db b, db c){  // check whether a <= c <= b\n    return dcmp(dcmp(b - c) * dcmp(a - c)) <= 0; \n}\n\nbool inmid(point A, point B, point P){ // check whether point P is in the rectangle of segment AB\n    return inmid(A.x, B.x, P.x) && inmid(A.y, B.y, P.y);\n}\n\ndb dis_SP(point A, point B, point P){ // the minimum distance from a point P to segment AB\n    point p_proj = proj_SP(A, B, P);\n    if (inmid(A, B, p_proj)) return (P - p_proj).len();\n    else return min((P - A).len(), (P - B).len());\n}\n\ndb dis_SS(point A, point B, point C, point D){ // the minimum distance from two segments AB and CD\n    db res = INF_d;\n    if (check_SS(A, B, C, D)) res = 0;\n    res = min(res, dis_SP(A, B, C));\n    res = min(res, dis_SP(A, B, D));\n    res = min(res, dis_SP(C, D, A));\n    res = min(res, dis_SP(C, D, B));\n    return res;\n}\n\ndb poly_Area(point *poly, int n){ // calc the area of a simple polygon poly, n is the number of points.\n    //the points should be in clockwise or counter_clockwise.\n    db res = 0.0;\n    for (int i = 1; i < n - 1; i++){\n        res += (poly[i] - poly[0]) ^ (poly[i + 1] - poly[0]);\n    }\n    return fabs(res) / 2;\n}\n\nbool is_Convex(point *poly, int n){ // check whether a polygon is a convex polygon. Make sure points are in counter-clockwised order.\n    poly[n] = poly[0];\n    if (n < 3) return 1;\n    for (int i = 1; i < n; i++){\n        int tmp_dir = dcmp((poly[i] - poly[i - 1]) ^ (poly[(i + 1) % n] - poly[i]));\n        if (tmp_dir < 0) return 0;\n    }\n    return 1;\n}\n\nbool is_PonS(point A, point B, point P){ // check whether a point P is on a segment AB\n    return inmid(A, B, P) && !dcmp((P - A) ^ (B - A));\n}\n\nint is_PinPoly(point *poly, int n, point P){ // check the position relation of a point and polygon.\n    // 0: outside, 1: on a segment, 2: inside\n    int pd = 0;\n    for (int i = 0; i < n; i++){\n        point u = poly[i], v = poly[(i + 1) % n];\n        if (is_PonS(u, v, P)) return 1;\n        if (dcmp(u.y - v.y) > 0) swap(u, v);\n        if (dcmp(u.y - P.y) >= 0 || dcmp(v.y - P.y) < 0) continue;\n        if (dcmp((u - v) ^ (P - v)) < 0) pd ^= 1;\n    }\n    return pd << 1;\n}\n\nbool cmpxy(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.x == b.x ? a.y < b.y : a.x < b.x;\n}\n\nbool cmpyx(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.y == b.y ? a.x < b.x : a.y < b.y;\n}\n\nint get_convexhull(point *p, int n, point *ch){ // get the convexhull of given polygon p\n    // pay attention to when m = 0, 1, 2 as the return value\n    sort(p, p + n, cmpyx); // may be changed by the requirement of problem\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        while (m > 1 && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for (int i = n - 2; i >= 0; i--){\n        while (m > k && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    if (n > 1) m--;\n    return m;\n}\n\ndb convexhull_diameter(point *ch, int n){ // calculate the diameter of a give convexhull\n    if (n < 2) return 0;\n    int is, js; is = js = 0;\n    for (int i = 0; i < n; i++){\n        is = ch[i] < ch[is] ? i : is;\n        js = ch[js] < ch[i] ? i : js;\n    }\n    int i = is, j = js;\n    db ret = (ch[is] - ch[js]).len();\n    do{\n        if (dcmp((ch[(i + 1) % n] - ch[i]) ^ (ch[(j + 1) % n] - ch[j])) > 0){\n            j = (j + 1) % n;\n        }\n        else{\n            i = (i + 1) % n;\n        }\n        ret = max(ret, (ch[i] - ch[j]).len());\n    } while (i != is || j != js);\n    return ret;\n}\n\nint convexhull_cut(point *ch, int n, point P, point Q, point *new_ch){\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        int d1 = dcmp((Q - P) ^ (ch[i] - P)), d2 = dcmp((Q - P) ^ (ch[(i + 1) % n] - P));\n        if (d1 >= 0) new_ch[m++] = ch[i];\n        if (d1 * d2 < 0) new_ch[m++] = inter_LL(line(P, Q), line(ch[i], ch[(i + 1) % n])).second;\n    }\n    return m;\n}\n\ndb cloest_pair(point *p, int l, int r){\n    db cloest = INF_d;\n    if (r - l <= 5){\n        for (int i = l; i < r; i++){\n            for (int j = i + 1; j < r; j++){\n                cloest = min(cloest, (p[i] - p[j]).len());\n            }\n        }\n        return cloest;\n    }\n    else{\n        int mid = (l + r) >> 1;\n        cloest = min(cloest_pair(p, l, mid), cloest_pair(p, mid + 1, r));\n        vector<point> v; v.clear();\n        for (int i = l; i <= r; i++){\n            v.pb(p[i]);\n        }\n        sort(v.begin(), v.end(), cmpyx);\n        for (int i = 0; i < SZ(v); i++){\n            for (int j = 0; j < 7; j++){\n                if (i + j >= SZ(v)) break;\n                cloest = min(cloest, (p[i] - p[i + j]).len());\n            }\n        }\n        return cloest;\n    }\n}\n\nconst int N = 1e5 + 7;\nint n, m, num;\npoint p[N], x, ch[N], y;\n\nint main(){\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++){\n        p[i].read();\n    }\n    printf(\"%.12f\\n\", cloest_pair(p, 0, n));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++) \n \n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n struct point\n {\n   double x;\n   double y;       \n }point[100002];\n \n int n;\n double result=40000.0*2;\n double num;\n \n \n //1.37?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n void init()\n {\n      \n }\n \n void wuhao()\n {\n        \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   } \n   //general_way();\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   } \n   printf(\"%lf.7\\n\",1.0*sqrt(result));\n   //while(1);\n   return 0;\n }\n "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <tuple>\n#include <vector>\n\n// T: sorted by x-axis\ntemplate<class T>\nstd::tuple<double, typename std::iterator_traits<T>::value_type, typename std::iterator_traits<T>::value_type>\nclosest_pair(T left, T right) {\n    using V = typename std::iterator_traits<T>::value_type;\n\n    const int N = std::distance(left, right);\n\n    if (N == 1) {\n        return std::make_tuple(std::numeric_limits<double>::max(), *left, *left);\n    }\n\n    T mid = std::next(left, N / 2);\n    double x = std::get<0>(*mid);\n    auto d = std::min(closest_pair(left, mid), closest_pair(mid, right));\n    std::inplace_merge(left, mid, right,\n                       [](const V &a, const V &b) { return std::get<1>(a) <= std::get<1>(b); });\n\n    std::vector<V> b;\n    b.reserve(N);\n    for (T it = left; it != right; ++it) {\n        if (fabs(std::get<0>(*it) - x) >= std::get<0>(d)) continue;\n\n        for (auto jt = b.rbegin(); jt != b.rend(); ++jt) {\n            if (fabs(std::get<0>(*it) - x) >= std::get<0>(d)) continue;\n            double dx = std::get<0>(*it) - std::get<0>(*jt);\n            double dy = std::get<1>(*it) - std::get<1>(*jt);\n            if (dy >= std::get<0>(d)) break;\n            if (sqrt(dx * dx + dy * dy) < std::get<0>(d)) {\n                d = std::make_tuple(sqrt(dx * dx + dy * dy), *it, *jt);\n            }\n        }\n        b.push_back(*it);\n    }\n    return d;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    std::vector<std::tuple<double, double>> v(n);\n    for (int i = 0; i < n; ++i) {\n        double a, b;\n        scanf(\"%lf%lf\", &a, &b);\n        v[i] = std::make_tuple(a, b);\n    }\n    std::sort(v.begin(), v.end());\n    auto ans = closest_pair(v.begin(), v.end());\n    printf(\"%.7f\\n\", std::get<0>(ans));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nstruct P\n{\n\tdouble x, y;\n\tP(double x, double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tlong double length2()const\n\t{\n\t\treturn x*x + y*y;\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nint ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}\n\npair<P, P> ClosestPair(vector<P>& points)\n{\n\tint n = points.size(), s = 0, t = 1, m = 2;\n\tvector<int> S(n);\n\tS[0] = 0, S[1] = 1;\n\tsort(points.begin(), points.end());\n\tlong double d = (points[s] - points[t]).length2();\n\tfor (int i = 2; i < n; S[m++] = i++)for (int j = 0; j < m; j++)\n\t{\n\t\tif ((points[S[j]] - points[i]).length2() < d)\n\t\t{\n\t\t\td = (points[s = S[j]] - points[t = i]).length2();\n\t\t}\n\t\tif (points[S[j]].x < points[i].x - d)\n\t\t{\n\t\t\tS[j--] = S[--m];\n\t\t}\n\t}\n\treturn make_pair(points[s], points[t]);\n}\n\nvector<P> points;\n\nint main()\n{\n\tpoints.reserve(100000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpoints.push_back(P(x, y));\n\t}\n\n\tpair<P, P> closestPair = ClosestPair(points);\n\tprintf(\"%.10lf\\n\", (closestPair.first - closestPair.second).length());\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        \n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<< ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\ntypedef pair<double, double> P;\n\nint n;\npair<double ,double> p[100000];\n\nint main() {\n\tint i, j;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) cin >> p[i].first >> p[i].second;\n\t\n\tsort(p, p + n);\n\t\n\tdouble minDist2 = 1145141919;\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tdouble dx = p[i].first - p[j].first;\n\t\t\tdouble dy = p[i].second - p[j].second;\n\t\t\tdouble dist = dx * dx + dy * dy;\n\t\t\t\n\t\t\tif (dx * dx >= minDist2) break;\n\t\t\t\n\t\t\tminDist2 = min(minDist2, dist);\n\t\t}\n\t}\n\t\n\tprintf(\"%.14f\\n\", sqrt(minDist2));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*<<head>> {{{*/\n#include <bits/stdc++.h>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define dd(x) cout << #x << \" = \" << x << \", \"\n#define de(x) cout << #x << \" = \" << x << endl\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n//INF = 1 061 109 567 ; INF + INF = 2 122 219 134 ;\n//LINF = 4 557 430 888 798 830 399 ; LINF + LINF = 9 114 861 777 597 660 798 ;\nconst int INF = 0x3f3f3f3f;     // -INF: 0xc0   abs(-INF) = INF + 1\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n/*}}}*/                         // zr, zm\nconst int MOD = (int)1e9+7;     // when MOD = 1e9+7, inv2 = 500000004\nconst int N = (int)-1;\n\n// ------- 变量 ------- //\n\n/* 注意\n  1. 点、向量\n    1. 如果角度出现 -pi ，可以加上 2pi 修正为 pi\n    2. atan2(y, x) 的参数是浮点数时，可能出现 -pi ，如 atan2(-0.0, -1.0)\n  2. 线段、直线\n    1. 线段严格相交定义为：每条线段的两个端点落在另一条线段两边，形象来说，就是可以在图形里看到四个端点和一个交点\n*/\n\ntypedef db T;\nconst db eps = 1e-7, pi = acosl(-1.);\nint sgn(T x) { return (x > eps) - (x < -eps); }\nbool inMid(T l, T x, T r) { return sgn(l - x) * sgn(r - x) <= 0; }  // 数 x 在区间 [l, r] 内（包括边界）\n\n// 点、向量\nstruct P {\n    T x, y; P () {} P(T x, T y) : x(x), y(y) {}\n    P operator + (const P &b) const { return P(x + b.x, y + b.y); }  // 向量加\n    P operator - (const P &b) const { return P(x - b.x, y - b.y); }  // 向量减\n    T operator * (const P &b) const { return x * b.x + y * b.y; }    // 向量点积\n    T operator / (const P &b) const { return x * b.y - y * b.x; }    // 向量叉积\n    P operator * (const T &k) const { return P(x * k, y * k); }      // 向量数乘\n    P operator / (const T &k) const { return P(x / k, y / k); }      // 向量数除\n    bool operator < (const P &b) const { return sgn(x - b.x) ? x < b.x : y < b.y; }  // 左小右大，下小上大\n    bool operator == (const P &b) const { return !sgn(x - b.x) && !sgn(y - b.y); }   // 向量相等\n    P rot(T t) { return P(x * cos(t) - y * sin(t), x * sin(t) + y * cos(t)); }  // 向量逆时针旋转 t 弧度\n    P rot90() { return P(-y, x); }           // 向量逆时针旋转 90 度\n    db arg() const { return atan2(y, x); }   // 方位角 (-pi, pi]\n    T abs() { return sqrt(x * x + y * y); }  // 向量模长\n    T abs2() { return x * x + y * y; }       // 向量模长的平方\n    P unit() { return (*this) / abs(); }     // 单位向量\n    void scan() { db tx, ty; scanf(\"%lf%lf\", &tx, &ty); x = tx; y = ty; }  // 输入\n    void print() { printf(\"%.11lf %.11lf\\n\", x, y); }                      // 输出\n    P toR() { return (sgn(x) == -1 || !sgn(x) && sgn(y) == -1) ? (*this)*(-1) : (*this); }  // 若向量在 2 3 象限，则取相反向量\n    bool isUp() const { return sgn(y) == 1 || !sgn(y) && sgn(x) == -1; }                    // 向量是否在 1 2 象限\n};\nT dis(P a, P b) { return (b - a).abs(); }   // 点 a 到点 b 的距离\nP symmetry(P p, P a) { return a + a - p; }  // 点 p 关于点 a 的中心对称点\nT cross(P o, P a, P b) { return (a - o) / (b - o); }         // 向量 oa 与 ob 的叉积\nint crossSgn(P o, P a, P b) { return sgn(cross(o, a, b)); }  // 向量 oa 与 ob 的叉积符号\ndb rad(P a, P b) { return atan2(a / b, a * b); }             // 向量 a 与 b 的夹角（弧度制）\nbool order(const P &a, const P &b) { return a.isUp() < b.isUp() || a.isUp() == b.isUp() && sgn(a/b) > 0; }  // 极角排序\n\n// 线段、直线\nstruct L { P s, t; L () {} L(P s, P t) : s(s), t(t) {} };\nbool onPS(P p, L a) { return sgn((a.t-a.s)/(p-a.s))==0 && sgn((p-a.s)*(p-a.t))<=0; }   // 点 p 是否在线段 a 上\nbool inRec(P p, L a) { return inMid(a.s.x, p.x, a.t.x) && inMid(a.s.y, p.y, a.t.y); }  // 点 p 在以直线 a 为对角线的矩形内\nP proj(P p, L a) { return (a.t-a.s) * ( (p-a.s) * (a.t-a.s) / (a.t-a.s).abs2() ) + a.s; }  // 点 p 关于直线 a 的投影点\nP reflect(P p, L a) { return proj(p, a) * 2 - p; }                                         // 点 p 关于直线 a 的对称点\nbool xSSr(const L &a, const L &b) {  // 线段 a 和线段 b 严格相交\n    T c1 = (a.t-a.s) / (b.s-a.s), c2 = (a.t-a.s) / (b.t-a.s);\n    T c3 = (b.t-b.s) / (a.s-b.s), c4 = (b.t-b.s) / (a.t-b.s);\n    return sgn(c1) * sgn(c2) < 0 && sgn(c3) * sgn(c4) < 0;\n}\nbool xSS(L a, L b) {                 // 线段 a 和线段 b 不严格相交\n    T c1 = (a.t-a.s) / (b.s-a.s), c2 = (a.t-a.s) / (b.t-a.s);\n    T c3 = (b.t-b.s) / (a.s-b.s), c4 = (b.t-b.s) / (a.t-b.s);\n    return sgn(c1) * sgn(c2) <= 0 && sgn(c3) * sgn(c4) <= 0 &&\n           sgn(max(a.s.x,a.t.x) - min(b.s.x,b.t.x)) >= 0 &&\n           sgn(max(b.s.x,b.t.x) - min(a.s.x,a.t.x)) >= 0 &&\n           sgn(max(a.s.y,a.t.y) - min(b.s.y,b.t.y)) >= 0 &&\n           sgn(max(b.s.y,b.t.y) - min(a.s.y,a.t.y)) >= 0;\n}\nbool xSL(L a, L b) {  // 线段 a 与直线 b 相交 ( 不严格 : <= ; 严格 : < )\n    return sgn( (b.t - b.s) / (a.s - b.s) ) * sgn( (b.t - b.s) / (a.t - b.s) ) <= 0;\n}\nP xLL(L a, L b) {  // 直线 a 和直线 b 的交点\n    T s1 = (b.t - b.s) / (a.s - b.s), s2 = -( (b.t - b.s) / (a.t - b.s) );\n    return (a.s * s2 + a.t * s1) / (s1 + s2);\n}\ndb disPL(P p, L a) { return fabs( (a.t-a.s) / (p-a.s) ) / (a.t-a.s).abs(); }  // 点 p 到直线 a 的距离\ndb disPS(P p, L a) {                                                          // 点 p 到线段 a 的距离\n    return sgn( (a.t-a.s) * (p-a.s) ) * sgn( (a.s-a.t) * (p-a.t) ) == 1\n           ? disPL(p, a) : min( (p-a.s).abs(), (p-a.t).abs() );\n}\ndb disSS(L a, L b){                                                           // 线段 a 到线段 b 的距离\n    if (xSS(a,b)) return 0;\n    return min( min( disPS(a.s,b), disPS(a.t,b) ), min( disPS(b.s,a), disPS(b.t,a) ) );\n}\ndb disLL(L a, L b) { return (a.t-a.s) / (b.t-b.s) ? 0 : disPL(a.s, b); }      // 直线 a 到直线 b 的距离\n\n// 多边形、凸包\ntypedef vector<P> polygon;\npolygon Convex(polygon A) {  // 求凸包，逆时针排序（ 内角 <180 : (<=) ; 内角 <=180 : (<) ）\n    int n = sz(A); if (n <= 1) return A;\n    sort(all(A));\n    polygon B;\n    for (int i = 0; i < n; B.pb(A[i++]))\n        while (sz(B) > 1 && crossSgn(B[sz(B)-2], B.back(), A[i]) < 0) B.pop_back();  // 更改这里的 <\n    for (int i = n - 2, t = sz(B); i >= 0; B.pb(A[i--]))\n        while (sz(B) > t && crossSgn(B[sz(B)-2], B.back(), A[i]) < 0) B.pop_back();  // 同上\n    B.pop_back(); return B;\n}\nT area(polygon A) {  // 多边形 A 的面积，整型可以返回面积的两倍，保持精度\n    T res = 0;\n    rep(i, 0, sz(A)) res += A[i] / A[ (i+1) % sz(A) ];\n    return fabs(res) / 2;\n}\nbool isConvex(polygon A) {  // 多边形 A 是否是凸包，要求 A 的点集按逆时针排序\n    rep(i, 0, 2) A.pb(A[i]);\n    rep(i, 0, sz(A)-2) if ( sgn( (A[i+1]-A[i]) / (A[i+2]-A[i]) ) < 0 ) return 0;\n    return 1;\n}\nint inPPo(P p, polygon A) {  // 点和多边形关系 ( 2 : in , 1 : on , 0 : out )\n    int res = 0; A.pb(A[0]);\n    rep(i, 1, sz(A)) {\n        P u = A[i-1], v = A[i];\n        if (onPS(p, L(u, v))) return 1;\n        if (sgn(u.y - v.y) > 0) swap(u, v);\n        if (sgn(u.y - p.y) >= 0 || sgn(v.y - p.y) < 0) continue;\n        if (crossSgn(v, u, p) < 0) res ^= 1;\n    }\n    return res << 1;\n}\nT ConvexDiameter(polygon A) {  // 凸包 A 的直径，即凸包 A 上的最远点对\n    int now = 0, n = sz(A); T res = 0;\n    if (n <= 1) return 0;\n    rep(i, 0, sz(A)) {\n        now = max(now, i);\n        while (1) {\n            T t1 = dis(A[i], A[now%n]), t2 = dis(A[i], A[(now+1)%n]);\n            res = max(res, max(t1, t2));\n            if (t2 > t1) now++; else break;\n        }\n    }\n    return res;\n}\npolygon ConvexCut(polygon A, L a) {  // 半平面 a 切割凸包 A 形成的凸包（直线 a 逆时针方向）\n    int n = sz(A); A.pb(A[0]); polygon res;\n    rep(i, 0, n) {\n        int w1 = crossSgn(a.s, a.t, A[i]), w2 = crossSgn(a.s, a.t, A[i+1]);\n        if (w1 >= 0) res.pb(A[i]);\n        if (w1 * w2 < 0) res.pb(xLL(a, L(A[i], A[i+1])));\n    }\n    return res;\n}\nT _closePP(polygon &A, int l, int r) {\n    if (r - l < 6) {\n        T res = 1e20;\n        rep(i, l, r+1) rep(j, i+1, r+1) res = min(res, dis(A[i], A[j]));\n        return res;\n    }\n    int m = l + r >> 1;\n    T res = min(_closePP(A, l, m), _closePP(A, m+1, r));\n    polygon B; rep(i, l, r+1) if (fabs(A[i].x - A[m].x) < res) B.pb(A[i]);\n    sort(all(B), [&](P p1, P p2){ return p1.y < p2.y; });\n    rep(i, 0, sz(B)) for (int j = i+1; j < sz(B) && B[j].y - B[i].y < res; j++)\n        res = min(res, dis(B[i], B[j]));\n    return res;\n}\nT closePP(polygon A) {\n    sort(all(A), [&](P a, P b){ return a.x < b.x; });\n    return _closePP(A, 0, sz(A)-1);\n}\n\nstruct C {\n    P o; db r; C () {} C (P o, db r) : o(o), r(r) {}\n};\n\nC getC(P a,P b,P c){  // 三点确定一个圆 （ 三角形外接圆 ）\n    db a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / 2;\n    db a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / 2;\n    db d = a1 * b2 - a2 * b1;\n    P o = P(a.x + (c1 * b2 - c2 * b1) / d, a.y + (a1 * c2 - a2 * c1) / d);\n    return C(o, dis(a, o));\n}\n\n\nint n;\npolygon A;\n\n// ------- 函数 ------- //\n\nvoid Init() {\n    A.clear();\n\n    rep(i, 0, n) {\n        P p; p.scan();\n        A.pb(p);\n    }\n}\n\nint Solve() {\n    printf(\"%.12f\\n\", closePP(A));\n    return 0;\n}\n\n// ------- main ------- //\n\nint main ()\n{\n    //ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n\n    //Pre();\n    //int t; scanf(\"%d\", &t); while (t--) {\n    while (~scanf(\"%d\", &n)) {\n    //while(fgets(s, N, stdin)) {   // 注意 fgets 会读入换行符\n        //if (n == 0) break;\n        //static int kase = 0; printf(\"Case %d: \", ++kase);\n        Init();\n        Solve();\n        //if (t) puts(\"\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdint.h>\n#include <time.h>\n#include <limits.h>\n#include <string.h>\n\nint n;\nfloat *x,*y;\nfloat getdist(int i,int j){\n  float dx,dy;\n  dx = x[i]-x[j];\n  dy = y[i]-y[j];\n  return sqrtf(dx*dx+dy*dy);\n}\n\n/* xorshift */\n/* https://ja.wikipedia.org/wiki/Xorshift */\nuint32_t xor128(){ \n  static uint32_t x = 123456789;\n  static uint32_t y = 362436069;\n  static uint32_t z = 521288629;\n  static uint32_t w = 88675123; \n  uint32_t t;\n \n  t = x ^ (x << 11);\n  x = y; y = z; z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)); \n}\n\n/* resizable int array */\ntypedef struct vector {\n  int limit,size;\n  int *a;\n} vector;\nvector *new_vector(){\n  vector *ret;\n  ret = (vector*)malloc(sizeof(vector));\n  ret->limit = 4;\n  ret->size = 0;\n  ret->a = (int*)malloc(ret->limit * sizeof(int));\n  return ret;\n}\nvector *copy_vector(vector *v){\n  int i;\n  vector *ret;\n  ret = (vector*)malloc(sizeof(vector));\n  ret->limit = v->limit;\n  ret->size = v->size;\n  ret->a = (int*)malloc(ret->limit * sizeof(int));\n  for(i=0;i<v->size;++i){\n    ret->a[i] = v->a[i];\n  }\n  return ret;\n}\nvoid v_push_back(vector *v,int val){\n  if(v->size >= v->limit){\n    v->limit <<= 1;\n    v->a = (int*)realloc(v->a,v->limit * sizeof(int));\n  }\n  v->a[v->size++] = val;\n}\nvoid free_vector(vector *v){\n  if(!v)return;\n  free(v->a);\n  free(v);\n}\n/* end of resizable int array */\n\n/* resizable int array array */\ntypedef struct vector_vector {\n  int limit,size;\n  vector **a;\n} vector_vector;\nvector_vector *new_vector_vector(){\n  vector_vector *ret;\n  ret = (vector_vector*)malloc(sizeof(vector_vector));\n  ret->limit = 4;\n  ret->size = 0;\n  ret->a = (vector**)malloc(ret->limit * sizeof(vector*));\n  return ret;\n}\nvoid vv_push_back(vector_vector *v,vector *val){\n  if(v->size >= v->limit){\n    v->limit <<= 1;\n    v->a = (vector**)realloc(v->a,v->limit * sizeof(vector*));\n  }\n  v->a[v->size++] = val;\n}\nvoid free_vector_vector(vector_vector *v){\n  int i;\n  if(!v)return;\n  for(i=0;i<v->size;++i){\n    free_vector(v->a[i]);\n  }\n  free(v->a);\n  free(v);\n}\n/* end of resizable int array array */\n\n/* hash map for pair<int,int> */\n/* hash max value = 2^16 = 65535 */\n#define HASH_MAX 65536\nint hash_int(int x){\n  uint32_t y;\n  y = *(uint32_t*)(&x);\n  y = y ^ (y << 13);\n  y = y ^ (y >> 17);\n  return (int)(y&(HASH_MAX-1));\n}\nint hash_pii(int a,int b){\n  return hash_int(a)^hash_int(b);\n}\ntypedef struct HashMap_pii {\n  vector_vector **bucket;\n  vector **bucket_x, **bucket_y;\n} HashMap_pii;\nHashMap_pii *new_HashMap_pii(){\n  int i;\n  HashMap_pii *ret;\n  ret = (HashMap_pii*)malloc(sizeof(HashMap_pii));\n  ret->bucket = (vector_vector**)calloc(HASH_MAX,sizeof(vector_vector*));\n  ret->bucket_x = (vector**)calloc(HASH_MAX,sizeof(vector*));\n  ret->bucket_y = (vector**)calloc(HASH_MAX,sizeof(vector*));\n  for(i=0;i<HASH_MAX;++i){\n    ret->bucket[i] = new_vector_vector();\n    ret->bucket_x[i] = new_vector();\n    ret->bucket_y[i] = new_vector();\n  }\n  return ret;\n}\nvector *hmpii_get(HashMap_pii *map,int x,int y){\n  int i;\n  int hsh;\n  hsh = hash_pii(x,y);\n  for(i=0;i<map->bucket[hsh]->size;++i){\n    if(map->bucket_x[hsh]->a[i] == x && map->bucket_y[hsh]->a[i] == y){\n      return map->bucket[hsh]->a[i];\n    }\n  }\n  return NULL;\n}\nvoid hmpii_add(HashMap_pii *map,int x,int y,int val){\n  int i;\n  int id;\n  int hsh;\n  vector *set;\n  hsh = hash_pii(x,y);\n  set = hmpii_get(map,x,y);\n  if(!set){\n    set = new_vector();\n    vv_push_back(map->bucket[hsh],set);\n    v_push_back(map->bucket_x[hsh],x);\n    v_push_back(map->bucket_y[hsh],y);\n  }\n  v_push_back(set,val);\n}\nvoid free_HashMap_pii(HashMap_pii *map){\n  int i;\n  if(!map)return;\n  for(i=0;i<HASH_MAX;++i){\n    free_vector_vector(map->bucket[i]);\n    free_vector(map->bucket_x[i]);\n    free_vector(map->bucket_y[i]);\n  }\n  free(map->bucket);\n  free(map->bucket_x);\n  free(map->bucket_y);\n  free(map);\n}\n\n/* nearest pair from two group in two dimensional map */\nvoid find_nearest_pair_from_two_group(vector *a,int *ret_a,int *ret_b){\n  int i,j,k;\n  vector *a_bef, *a_nxt;\n  float dist;\n  a_bef = copy_vector(a);\n  a_nxt = NULL;\n  dist = 1e25f;\n  while(a_bef->size > 0){\n    int ai;\n    float delta;\n    HashMap_pii *amap;\n    ai = a_bef->a[xor128()%a_bef->size];\n    dist = 1e25f;\n    for(i=0;i<a_bef->size;++i){\n      if(ai==a_bef->a[i])continue;\n      if(getdist(ai,a_bef->a[i]) < dist)\n        dist = getdist(ai,a_bef->a[i]);\n    }\n    delta = dist/8;\n    /* grid */\n    amap = new_HashMap_pii();\n    for(i=0;i<a_bef->size;++i){\n      int xx,yy,id;\n      id = a_bef->a[i];\n      xx = (int)(x[id]/delta);\n      yy = (int)(y[id]/delta);\n      hmpii_add(amap,xx,yy,id);\n    }\n    /* search */\n    a_nxt = new_vector();\n    for(i=0;i<a_bef->size;++i){\n      int xx,yy,id;\n      int flag;\n      id = a_bef->a[i];\n      xx = (int)(x[id]/delta);\n      yy = (int)(y[id]/delta);\n      flag = 0;\n      for(j=-1;j<=1&&!flag;++j)for(k=-1;k<=1&&!flag;++k){\n        vector *vec = hmpii_get(amap,xx+j,yy+k);\n        if(vec!=NULL && vec->size!=0){\n          int l;\n          for(l=0;l<vec->size;++l){\n            if(vec->a[l]!=id){\n              flag = 1;\n              break;\n            }\n          }\n        }\n      }\n      if(flag)\n        v_push_back(a_nxt,id);\n    }\n    /* step */\n    free_vector(a_bef);\n    free_HashMap_pii(amap);\n    a_bef = a_nxt;\n    a_nxt = NULL;\n  }\n  free_vector(a_bef);\n  /* create grid with dist */\n  {\n    float mindist;\n    int pa,pb;\n    HashMap_pii *map;\n    mindist = 1e25f;\n    pa = pb = -1;\n    map = new_HashMap_pii();\n    for(i=0;i<a->size;++i){\n      int xx,yy,id;\n      vector *vec;\n      id = a->a[i];\n      xx = (int)(x[id]/dist);\n      yy = (int)(y[id]/dist);\n      for(j=-1;j<=1;++j)for(k=-1;k<=1;++k){\n        int l;\n        vec = hmpii_get(map,xx+j,yy+k);\n        if(vec==NULL)continue;\n        for(l=0;l<vec->size;++l){\n          int to;\n          to = vec->a[l];\n          if(getdist(to,id)<mindist){\n            mindist = getdist(to,id);\n            pa = to;\n            pb = id;\n          }\n        }\n      }\n      hmpii_add(map,xx,yy,id);\n    }\n    *ret_a = pa;\n    *ret_b = pb;\n  }\n}\n\nint main(){\n  int i;\n  int ansa,ansb;\n  vector *a;\n  a = new_vector();\n  scanf(\"%d\",&n);\n  x = (float*)calloc(n,sizeof(float));\n  y = (float*)calloc(n,sizeof(float));\n  for(i=0;i<n;++i){\n    scanf(\"%f%f\",x+i,y+i);\n    v_push_back(a,i);\n  }\n  find_nearest_pair_from_two_group(a,&ansa,&ansb);\n  printf(\"%.10f\\n\",getdist(ansa,ansb));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<int, int> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int distance_ = (p1[i + 1].first - p1[i].first) * (p1[i + 1].first - p1[i].first) + (p1[i + 1].second - p1[i].second) * (p1[i + 1].second - p1[i].second);\n        \n        sqr_ans = min(distance, sqr_ans);\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int distance_ = (p2[i + 1].first - p2[i].first) * (p2[i + 1].first - p2[i].first) + (p2[i + 1].second - p2[i].second) * (p2[i + 1].second - p2[i].second);\n        \n        sqr_ans = min(distance, sqr_ans);\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double Abs(Point a, Point b) { Point C; C.px = a.px - b.px; C.py = a.py - b.py; return sqrt(norm(C)); }\nint N; Point P[1000000];\nint main() {\n\tcin >> N; long double res = 10101010101010101010101010101010101010101.0101;\n\tfor (int i = 0; i < N; i++) { cin >> P[i].px >> P[i].py; }\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tres = min(res, Abs(P[i], P[j]));\n\t\t}\n\t}\n\tcout << fixed << setprecision(5141919) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<utility>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n\ntypedef pair<double, double> point;\ntypedef point* data;\n\ninline double dist(const point &a, const point &b)\n{\n    double dx = a.first - b.first, dy = a.second - b.second;\n    return sqrt(dx * dx + dy * dy);\n}\n\nbool y_less(const point &P1, const point &P2){ return P1.second < P2.second; }\nbool y_greater(const point &P1, const point &P2){ return P1.second > P2.second; }\n\ndouble closest(data P, int n)\n{\n    if(n <= 1) return 1000;\n    if(n == 2) return dist(P[0], P[1]);\n    int m = n / 2;\n    sort(P, P + n, y_less); // y_sort, down to up.\n\tdouble median = P[m].second;\n    double d = min(closest(P, m), closest(P + m, n - m));\n\n    sort(P, P + m, y_less);\n    sort(P + m, P + n, y_greater);\n    int a, b;\n    for(a = m; a > 0; a--){ if(P[a].second < median - d) break; }\n    for(b = n; b > m; b--){ if(P[b].second > median + d) break; }\n    sort(P + a, P + m);\n    sort(P + b, P + n);\n\n    // x_sort, left to right.\n    int u, v, i, j;\n    u = i = a, v = j = b;\n    while(i < m && j < n){\n        if(P[u].first < P[v].first){\n            for(i = a; i < m; i++){\n                if(P[i].first >= P[v].first){ u = i; break; }\n                if(P[v].first - P[i].first >= d){ a++; }\n                else{\n                    d = min(d, dist(P[v], P[i]));\n                }\n            }\n        }else{\n            for(j = b; j < n; j++){\n                if(P[j].first > P[u].first){ v = j; break; }\n                if(P[u].first - P[j].first >= d){ b++; }\n                else{\n                    d = min(d, dist(P[u], P[j]));\n                }\n            }\n        }\n    };\n    return d;\n}\n\nint main()\n{\n\tint i, n;\n\tdouble x, y;\n\tscanf(\"%d\", &n);\n\tdata P;\n\tP = new point [n];\n\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tP[i] = make_pair(x, y);\n\t}\n\tprintf(\"%.12f\\n\", closest(P, n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct node{\n  int dim;\n  vector<double>v;\n};\n\ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n\ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n\n  vector<node>res;\n\n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n\n    double dist=d(p,S)/(4*p.dim);\n\n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n\n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    \n    S=nextS;    \n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n  \n  return ans;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n\n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\n/*使用注意 aojでがc++11でしか通らない*/\n/*\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    //two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n\n    two_dimensional_qsort(p_xy, n0, n-1, 1);\n\n    \n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n*/\nbool compare_y(pair<double, double> a,pair<double, double> b){\n    return a.second<b.second;\n}\n\ndouble length_of_the_nearest_point_to(pair<double, double> a[100000], int n){\n    if(n<=1)return 999999999.9;\n    int m=n/2;\n    double x=a[m].first;\n    double d=min(length_of_the_nearest_point_to(a, m), length_of_the_nearest_point_to(a+m, n-m));\n    //inplace_merge(a, a+m, a+n, compare_y);\n    sort(a, a+n, compare_y);\n    vector<pair<double, double> >b;\n    for(int i=0; i<n; i++){\n        if(fabs(a[i].first-x)>=d)continue;\n        for(int j=0; j<b.size(); j++){\n            double dx=a[i].first-b[b.size()-j-1].first;\n            double dy=a[i].second-b[b.size()-j-1].second;\n            if(dy>=d)break;\n            d=min(d,sqrt(dx*dx+dy*dy));\n            \n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n                                      \n                                      \n                                      \nint main(int argc, const char * argv[]){\n    int n;\n    while(cin>>n){\n        pair<double, double> a[100000];\n        for(int i=0; i<n; i++){\n            cin>>a[i].first>>a[i].second;\n        }\n        sort(a, a+n);\n        double ans = length_of_the_nearest_point_to(a, n);\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n    /*\n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        //cout<<\"qaaa\";\n        two_dimensional_qsort(p_xy, 0, n-1, 0);\n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n     */\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define MAX 100010\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nPoint A[MAX];\nint n;\n\nbool compare_y(const Point &a,const Point &b){\n  return a.y<b.y;\n}\n\ndouble closest_pair(Point *a,int n){\n  if(n<=1)return inf;\n  int m=n/2;\n  double x=a[m].x;\n  double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n\n  vector<Point> b;\n  for(int i=0;i<n;i++){\n    if(fabs(a[i].x-x)>=d)continue;\n\n    for(int j=0;j<b.size();j++){\n      double dx=a[i].x-b[b.size()-j-1].x;\n      double dy=a[i].y-b[b.size()-j-1].y;\n      if(dy>=d)break;\n      d=min(d,sqrt(dx*dx+dy*dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main()\n{\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y;\n\n  sort(A,A+n);\n\n  printf(\"%.10f\\n\",closest_pair(A,n));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool cmp_y(const P &a, const P &b){\n\t\treturn a.imag() != b.imag() ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\t\t\t\t\t\t\t\t  // a--c--b on line\n}\n\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n// polygon\ntypedef vector<P> G;\n\nP extreme(const vector<P> &po, const L &l) {\n  int k = 0;\n  for (int i = 1; i < po.size(); ++i)\n    if (dot(po[i], l[1]-l[0]) > dot(po[k], l[1]-l[0])) k = i;\n  return po[k];\n}\n\nenum { OUT, ON, IN };\nint contains(const G& po, const P& p) {\n  bool in = false;\n  for (int i = 0; i < po.size(); ++i) {\n  \tP a = po[i] - p, b = po[(i+1)%po.size()] - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\ndouble area2(const G& po) {\n\tdouble A = 0;\n  \tfor (int i = 0; i < po.size(); ++i) \n    \tA += cross(po[i], po[(i+1)%po.size()]);\n\t//????????????????????????????????¨????????????\n  \treturn A/2;\n}\n\nbool isconvex(const G &p) {\n\tint n = p.size();\n\tif(cross(p[0]-p[n-1],p[n-2]-p[n-1]) < 0) return false;\n\tfor(int i = 1; i < n-1; ++i) {\n\t\tif(cross(p[i+1]-p[i],p[i-1]-p[i]) < 0) return false;\n\t}\n\treturn true;\n\n}\n\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end(), cmp_y);\n  G r(2*n);\n  for(int i = 0; i < n; i++){\n    while(k>1 && cross(r[k-1]-r[k-2],ps[i]-r[k-2]) < -EPS)k--;\n    r[k++] = ps[i];\n  }\n  for(int i = n-2, t = k; i >= 0; i--){\n    while(k>t && cross(r[k-1]-r[k-2],ps[i]-r[k-2]) < -EPS)k--;\n    r[k++] = ps[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\n// caliper\ndouble convex_diameter(const G &pt) {\n\tconst int n = pt.size();\n\tif(n <= 1) return 0;\n\tif(n == 2) return abs(pt[0]-pt[1]);\n\t\n\tint i = 0, j = 0;\n\tfor(int k = 0; k < n; ++k){\n\t\tif(!(pt[i] < pt[k])) i = k;\n\t\tif(pt[j] < pt[k]) j = k;\n\t}\n   \n\tdouble res = 0;\n\tint si = i, sj = j;\n\twhile(i != sj || j != si) {\n\t\tres = max(res, abs(pt[i]-pt[j]));\n\t\tif(cross(pt[(i+1)%n]-pt[i],pt[(j+1)%n]-pt[j]) < 0) i = (i+1)%n;\n\t\telse j = (j+1)%n;\n\t}\n\treturn res;\n}\n\n// po???l??§?????????????????´???????????????\nG convex_cut(const G& po, const L& l) {\n  G Q;\n  for (int i = 0; i < po.size(); ++i) {\n  \tP A = po[i], B = po[(i+1)%po.size()];\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n  \tif (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0) {\n  \t\tQ.push_back(crosspoint(L(A, B), l));\n  \t}\n  }\n  return Q;\n}\n\n//?????????????????¢\ndouble closestPair(G p, int flag=1) {\n\tif(flag) sort(p.begin(), p.end());\n\tint n = p.size(), s = 0, m=n/2;\n\tif(n<=1) return INF;\n\tG b(begin(p), begin(p)+m), c(begin(p)+m, end(p)), e;\n\tdouble x = p[m].real(), d=min(closestPair(b, 0), closestPair(c, 0));\n\tsort(p.begin(), p.end(), cmp_y);\n\tfor(int i=0; i<n; ++i) {\n\t\tif(abs(real(p[i])-x) >= d) continue;\n\t\tfor(int j=0; j<e.size(); ++j) {\n\t\t\tif(imag(p[i]-e[e.size()-1-j]) >= d) break;\n\t\t\td = min(d, abs(p[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(p[i]);\n\t}\n\treturn d;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tG po;\n\tfor(int i=0; i<n; ++i) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tP p(x, y);\n\t\tpo.push_back(p);\n\t}\n\tcout << fixed << setprecision(15) << closestPair(po) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing ld = long double;\nusing point = std::complex<ld>;\nusing polygon = std::vector<point>;\n\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = std::acos(-1.0);\n\nbool comp(point a, point b) {\n    return std::real(a) < std::real(b) || (std::real(a) <= std::real(b) && std::imag(a) < std::imag(b));\n}\n\nstd::vector<point> unique(std::vector<point> ps) {\n    std::sort(std::begin(ps), std::end(ps), comp);\n    std::vector<point> res;\n    for(auto& p : ps) {\n        if(res.empty() || abs(res.back() - p) > eps) {\n            res.push_back(p);\n        }\n    }\n    return res;\n}\n\nld dot(point const& a, point const& b) {\n    return std::real(std::conj(a) * b);\n}\nld cross(point const& a, point const& b) {\n    return std::imag(std::conj(a) * b);\n}\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps) return 1;            // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps) return -1;          // a -> b -> c : clockwise\n    if(dot(b, c) < 0) return 2;                // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\nstruct segment {\n    segment() : a(0, 0), b(0, 0) {}\n    segment(point a, point b) : a(a), b(b) {}\n    point a, b;\n};\n\nstruct line {\n    line() : a(0, 0), b(0, 0) {}\n    line(point a, point b) : a(a), b(b) {}\n    line(segment s) : a(s.a), b(s.b) {}\n    point a, b;\n};\n\n\nbool isis_ll(line l, line m) {\n    return cross(l.b - l.a, m.b - m.a) < eps;\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\npoint is_ss(segment s1, segment s2) {\n    assert(isis_ss(s1, s2));\n    point sv = s1.b - s1.a, tv = s2.b - s2.a;\n    if(cross(sv, tv) == 0) {\n        if(std::abs(s1.a - s2.a) < eps || std::abs(s1.a - s2.b) < eps) {\n            return s1.a;\n        } else {\n            return s1.b;\n        }\n    } else {\n        return is_ll(line(s1), line(s2));\n    }\n}\n\nlong double dist_lp(line l, point p) {\n    return std::abs(p - proj(l, p));\n}\n\nlong double dist_ll(line l, line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nlong double dist_ls(line l, segment s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\nld area(polygon const& p) {\n    const int N = p.size();\n    ld res = 0;\n    for(int i = 0; i < N; ++i) {\n        res += cross(p[i], p[(i + 1) % N]);\n    }\n    return res / 2;\n}\n\n// 0 -> on, 1 -> in, 2 -> out\nint is_in_polygon(polygon const& poly, point p) {\n    const int n = poly.size();\n    ld sum = 0;\n    for(int i = 0; i < n; ++i) {\n        point p1 = poly[i], p2 = poly[(i + 1) % n];\n        if(isis_sp(segment(p1, p2), p)) {\n            return 0;\n        }\n        sum += arg((p2 - p) / (p1 - p));\n    }\n    return std::abs(sum) < pi / 2 ? 2 : 1; // @todo: should check < 0.5 ?\n}\n\n// left side\npolygon convex_cut(polygon const& p, line l) {\n    const int N = p.size();\n    polygon res;\n    for(int i = 0; i < N; ++i) {\n        auto a = p[i], b = p[(i + 1) % N];\n        if(ccw(l.a, l.b, a) != -1) {\n            res.push_back(a);\n        }\n        if(ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0) {\n            if(cross(a - b, l.a - l.b) == 0) continue; // cut line が辺に覆いかぶさる\n            res.push_back(is_ll(line(a, b), l));\n        }\n    }\n    return res;\n}\n\npolygon convex_hull(std::vector<point> ps) {\n    std::sort(ps.begin(), ps.end(), comp);\n    const int n = ps.size();\n    int k = 0;\n    polygon qs(2 * n);\n    for(int i = 0; i < n; ++i) {\n        while(k > 1 && ccw(qs[k - 2], qs[k - 1], ps[i]) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n    for(int i = n - 2, t = k; i >= 0; --i) {\n        while(k > t && ccw(qs[k - 2], qs[k - 1], ps[i]) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n    qs.resize(k - 1);\n    return qs;\n}\n\nconst ld inf = 1e20;\n\nbool compare_y(point const& a, point const& b) {\n    return std::imag(a) < std::imag(b);\n}\n\nld closest_pair_impl(point* a, int n) {\n    if (n <= 1) return inf;\n    int m = n / 2;\n    ld x = std::real(a[m]);\n    ld d = std::min(closest_pair_impl(a, m), closest_pair_impl(a + m, n - m));\n    std::inplace_merge(a, a + m, a + n, compare_y);\n    std::vector<point> b;\n    for (int i = 0; i < n; i++) {\n        if (std::fabs(std::real(a[i]) - x) >= d) continue;\n        for (int j = 0; j < (int)b.size(); j++) {\n            ld dx = std::real(a[i]) - std::real(b[b.size() - j - 1]);\n            ld dy = std::imag(a[i]) - std::imag(b[b.size() - j - 1]);\n            if (dy >= d) break;\n            d = std::min(d, sqrtl(dx * dx + dy * dy));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\nld closest_pair(std::vector<point> ps) {\n    std::sort(std::begin(ps), std::end(ps), comp);\n    return closest_pair_impl(ps.data(), ps.size());\n}\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<point> ps(n);\n    for(int i = 0; i < n; ++i) {\n        ld x, y;\n        cin >> x >> y;\n        ps[i] = point(x, y);\n    }\n    cout << setprecision(10) << fixed << closest_pair(ps) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/60))  \n #define Fun2(j,n) for(int j=i+(int)(n/60);j<n;j=j+(int)(n/60))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=200;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16??????????????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   //?°?16????????????????????????????????? \n   minx=minx-1;\n   miny=miny-1;\n   maxx=maxx+1;\n   maxy=maxy+1;\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=3;j>=0;j--)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*(3-j)+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n   /*\n   for(int i=0;i<16;i++)\n   {\n     for(int j=0;j<num_point[i];j++)\n     {\n       cout<<wu[i][j].x<<\" \"<<wu[i][j].y<<endl;        \n     }        \n   }\n   */\n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       //real_min=(point[0].x-point[1].x)*(point[0].x-point[1].x)+(point[0].y-point[1].y)*(point[0].y-point[1].y);\n       real_min=fun_min;\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A?????? \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n; double bx, by; pair<double, double> p[100009];\nint main() {\n\tscanf(\"%d\", &n);\n\tdouble sq = sin(1.234), cq = cos(1.234);\n\tfor(int i = 0; i < n; i++) {\n\t\tscanf(\"%lf%lf\", &bx, &by);\n\t\tdouble ex = bx * cq - by * sq;\n\t\tdouble ey = bx * sq + by * cq;\n\t\tp[i] = make_pair(ex, ey);\n\t}\n\tsort(p, p + n);\n\tdouble ret = 1.0e+10;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n && p[j].first - p[i].first <= ret; j++) {\n\t\t\tdouble dist = hypot(p[i].first - p[j].first, p[i].second - p[j].second);\n\t\t\tif(ret > dist) ret = dist;\n\t\t}\n\t}\n\tprintf(\"%.15lf\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int maxn = 200001;\nconst double inf = 1e60;\n\nstruct point\n{\n\tdouble x,y;\n\tbool flag;\n}pp[maxn],t[maxn];\n\nint n;\n\ninline bool cmpxy(const point &a,const point &b)\n{\n\tif(a.x == b.x)return a.y < b.y;\n\treturn a.x < b.x;\n}\n\ninline bool cmpy(const point &a,const point &b)\n{\n\treturn a.y < b.y;\n}\n\ninline double sqr(double a)\n{\n\treturn a * a;\n}\n\ninline double dis(point a,point b)\n{\n\treturn sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\n\ndouble doit(int l,int r)\n{\n\tif(l == r)return inf;\n\tif(l + 1 == r)return ((pp[l].flag != pp[r].flag) ? dis(pp[l],pp[r]) : inf);\n\tif(l + 2 == r)\n\t{\n        if( pp[l].flag == pp[l + 1].flag )  \n        {  \n            if(pp[l].flag == pp[l + 2].flag )    \n\t\t\t\treturn inf;\n            else    return min( dis(pp[l],pp[l + 2]),dis(pp[l + 1],pp[l + 2]) );  \n        }  \n        else  \n        {  \n            if( pp[l].flag == pp[l + 2].flag )    \n\t\t\t\treturn min( dis(pp[l],pp[l+1]),dis(pp[l+2],pp[l+1]) );  \n            else return  min( dis(pp[l],pp[l+1]),dis(pp[l],pp[l+2]) );  \n        }  \n        return min( dis(pp[l],pp[r]),min( dis(pp[l],pp[l+1]),dis(pp[l+1],pp[r]) ) );  \n\t}\n\tint mid = (l + r) >> 1;\n\tdouble ans = min(doit(l,mid),doit(mid + 1,r));\n\tint tot = 0;\n\tfor(int i = l;i <= r;i ++)\n\t\tif(fabs(pp[i].x - pp[mid].x) <= ans )\n\t\t\tt[++ tot] = pp[i];\n\tsort(t + 1,t + tot + 1,cmpy);\n\tfor(int i = 1;i <= tot;i ++)\n\t\tfor(int j = i + 1;j <= tot && t[j].y - t[i].y < ans;j ++)\n\t\t\tans = min(ans,((t[i].flag != t[j].flag) ? dis(t[i],t[j]) : inf));\n\treturn ans;\n}\n\nint main()\n{\n\t\t\tscanf(\"%d\",&n);\n//\t\t\tn *= 2;\n\t\t\tfor(int i = 1;i <= n / 2;i ++)\n\t\t\t\tscanf(\"%lf%lf\",&pp[i].x,&pp[i].y),pp[i].flag = false;\n\t\t\tfor(int i = n / 2 + 1;i <= n;i ++)\n\t\t\t\tscanf(\"%lf%lf\",&pp[i].x,&pp[i].y),pp[i].flag = true;\n\t\t\tsort(pp + 1,pp + n + 1,cmpxy);\n\t\t\tprintf(\"%.10f\\n\",doit(1,n));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\n\t\tans = min(ans,abs(data[i + 1].second - data[i].second));\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&ans >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <numeric>\n\nusing namespace std;\n\nusing point = pair<float, float>;\nusing vpoint = vector<point>;\n\ninline float distance(point &a, point &b) { return sqrt(pow(a.first - b.first, 2) + pow(a.second - b.second, 2)); }\nvoid splitX(vpoint &x, vpoint &xl, vpoint &xr);\n\nfloat closestSplit(vpoint &x, uint32_t i, uint32_t j, vpoint &y, float sigma)\n{\n    float xbar = x[(i+j)/2].first, d = numeric_limits<float>::max();\n    vpoint sy;\n    for (uint32_t i = 0; i < y.size(); ++i)\n        if (abs(xbar - y[i].first) <= sigma)\n            sy.push_back(y[i]);\n    for (uint32_t i = 0; i < sy.size(); ++i)\n        for (uint32_t j = 1; j < 8 && i+j < sy.size(); ++j)\n            d = min(d, distance(sy[i], sy[i+j]));\n    return d;\n}\n\nfloat closestPairDistance(vpoint &x, uint32_t i, uint32_t j, vpoint &y)\n{\n    if (j-i+1 < 4)\n    {\n        float d = numeric_limits<float>::max();\n        for (; i <= j; ++i)\n            for (uint32_t k = i+1; k <= j; ++k)\n                d = min(d, distance(x[i], x[k]));\n        return d;\n    }\n    float sigma = min(closestPairDistance(x, i, (i+j)/2, y), closestPairDistance(x,(i+j)/2+1, j, y));\n    return min(sigma, closestSplit(x, i, j, y, sigma));\n}\n\nint main()\n{\n    int n;\n    vpoint x, y;\n    scanf(\"%d\", &n);\n    x.resize(n);\n    y.resize(n);\n    for (int i = 0; i < n; ++i)\n    {\n        scanf(\"%f %f\", &x[i].first, &x[i].second);\n        y[i] = x[i];\n    }\n    sort(x.begin(), x.end(), [](point &a, point &b)\n    {\n        return a.first < b.first;\n    });\n    sort(y.begin(), y.end(), [](point &a, point &b)\n    {\n        return a.second < b.second;\n    });\n    cout << setprecision(8) << showpoint << fixed << closestPairDistance(x, 0, n-1, y);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef double              lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return norm( B - A ); }\n\nint n;\nlf d;\npt Px[ MAXN ];\nvector< pt> Py;\n\nbool cmpX( const pt &A, const pt &B ) {\n  return A.x < B.x;\n}\n\nbool cmpY( const pt &A, const pt &B ) {\n  return A.y < B.y;\n}\n\nvoid merge( pt *P, int n, lf &d ) {\n  for( int i = 0; i < n; ++i ) {\n    for( int j = i+1; j < n && P[j].y - P[i].y < d ; ++j ) {\n      d = min( d, dist( P[i], P[j]) );\n    }\n  }\n}\n\nvoid solve( pt *Px, vector<pt> &Py, int n, lf &d ) {\n  if( n <= 3 ) {\n    for( int i = 0; i < n; ++i ) {\n      for( int j = i+1; j < n; ++j ) {\n        d = min( d, dist(Px[i], Px[j]) );\n      }\n    }\n    return;\n  }\n  int mi = n/2;\n  vector<pt> Pl, Pr;\n  for( int i = 0; i < n; ++i ) {\n    if( Py[i].x <= Px[mi].x ) {\n      Pl.PB( Py[ i ] );\n    }\n    else {\n      Pr.PB( Py[ i ] );\n    }\n  }\n\n  solve( Px, Pl, SIZE( Pl ), d );\n  solve( Px+SIZE( Pl ), Pr, SIZE( Pr ), d );\n\n  pt extra[ n ];\n  int k = 0;\n  for( auto &p : Py ) {\n    if( abs( p.x - Px[mi].x ) < d ) {\n      extra[ k++ ] = p;\n    }\n  }\n\n  merge( extra, n, d );\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 8 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> Px[i];\n    Py.PB( Px[ i ] );\n  }\n  sort( Px, Px+n, cmpX );\n  sort( Py.begin(), Py.end(), cmpY );\n  d = oo;\n  solve( Px, Py, n, d );\n  cout << double(sqrt(d)) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nld getdis(const pair<ld, ld>&l, const pair<ld, ld>&r) {\n\treturn sqrt((l.first - r.first)*(l.first - r.first) + (l.second - r.second)*(l.second - r.second));\n}\nld getans(vector<pair<ld, ld>>&ps,int l,int r) {\n\tif (r-l == 1) {\n\t\treturn getdis(ps[0], ps[1]);\n\t}\n\telse if (r-l ==0) {\n\t\treturn 1e18;\n\t}\n\telse {\n\t\tint n = (r+l) / 2;\n\t\tld la = getans(ps,l,n);\n\t\tld ra = getans(ps,n,r);\n\t\tld nans = min(la, ra);\n\t\tauto lit = lower_bound(ps.begin()+l, ps.begin()+r, make_pair(ps[n].first - nans - 1, -1e18l));\n\t\tauto rit = upper_bound(ps.begin() + l, ps.begin() + r, make_pair(ps[n].first + nans + 1,  1e18l));\n\t\tfor (auto a = lit; a != rit; ++a) {\n\t\t\tfor (auto b = next(a); b != rit; ++b) {\n\t\t\t\tnans = min(nans, getdis(*a, *b));\n\t\t\t}\n\t\t}\n\t\treturn nans;\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\tvector<pair<ld, ld>>ps;\n\tfor (int i = 0; i < N; ++i) {\n\t\tld x, y; cin >> x >> y;\n\t\tps.emplace_back(x, y);\n\t}\n\tsort(ps.begin(), ps.end());\n\tld ans = getans(ps,0,ps.size());\n\tcout <<setprecision(22)<<fixed<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf dist ( pt A, pt B ) { return norm( B - A ); }\n\nint n;\npt P[ MAXN ], extra[ MAXN ];\n\nbool cmpX( const pt &A, const pt &B ) {\n  return A.x < B.x;\n}\n\nlf sqr( lf x ) {\n  return x*x;\n}\n\nvoid merge( int f, int m, int t ){\n\tint total = t - f + 1;\n\tfor( int i = 0, l = f, r = m+1; i < total; ++i ){\n\t\tif( l == m+1 ){\n      extra[ i ] = P[ r++ ];\n\t\t}\n\t\telse if( r == t+1 ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse if( P[l].y < P[r].y ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse{\n\t\t  extra[ i ] = P[ r++ ];\n\t\t}\n\t}\n\tfor( int i = 0; i < total; ++i ){\n    P[ f+i ] = extra[ i ];\n\t}\n}\n\nlf solve( int f, int t ) {\n  if( f == t ) return oo;\n\tint mi = (f + t)/2;\n\tlf mx = P[ mi ].x;\n\tlf d = min( solve( f, mi ), solve( mi+1, t ) );\n\tmerge( f, mi, t );\n\tvector< int > idxs;\n\tfor( int i = f; i <= t; ++i ){\n\t\tif( sqr(mx - P[i].x) < d ) idxs.push_back( i );\n\t}\n\tfor( int i = 0; i < idxs.size(); ++i ){\n\t\tfor( int j = i+1; j < idxs.size() && sqr(P[ idxs[i] ].y - P[ idxs[j] ].y) < d; ++j ){\n\t\t\td = min( d, dist( P[ idxs[i] ], P[ idxs[j] ] ) );\n\t\t}\n\t}\n\treturn d;\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"CGL_5_A-in25.txt\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  sort( P, P+n, cmpX );\n  cout << double( sqrt(solve( 0, n-1 )) ) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(__typeof((o).begin()) it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T> >& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){EACH(a,ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;EACH(p,m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\ntemplate<> long double INF<long double>(){return 1e16;};\n\ntemplate<typename T> T pmod(T v,T M){return (v%M+M)%M;}\n\nnamespace _double_tmpl{\n    typedef long double D;const D EPS = 1e-8;\n    \n    static constexpr D Ae=0;\n    D A(D a,D b){return a+b;}D Ainv(D a){return -a;}\n    D S(D a,D b){return A(a,Ainv(b));}\n    \n    static constexpr D Me=1;\n    D M(D a,D b){return a*b;}D Minv(D a){return 1.0/a;};\n\n    int sig(D a,D b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n    bool eq(D a,D b){ return sig(abs(a-b))==0;}\n\n}\nusing namespace _double_tmpl;\n\n\nnamespace Ps{\n    // using namespace _double_tmpl;\n    typedef complex<D> P,Vec;\n\n#define X real()\n#define Y imag()\n    istream& operator >> (istream& is,complex<D>& p){\n        D x,y;is >> x >> y;p=P(x,y);return is;\n    }\n\n    bool eq(P a,P b){return eq(a.X,b.X) and eq(a.Y,b.Y);}\n    // a×b\n    D cross(const Vec& a,const Vec& b){return imag(conj(a)*b);}\n    // a・b\n    D dot(const Vec&a,const Vec& b) {return real(conj(a)*b);}\n\n    int ccw(const P& a,P b,P c){\n        b -= a; c -= a;\n        if (cross(b,c) > EPS)   return +1;       // counter clockwise\n        if (cross(b,c) < -EPS)   return -1;       // clockwise\n        if (dot(b,c) < 0)     return +2;       // c--a--b on line\n        if (norm(b) < norm(c)) return -2;       // a--b--c on line\n        return 0;\n    }\n\n    bool compX (const P& a,const P& b);bool compY (const P& a,const P& b);\n    D closestPair(vector<P>& ps,int l,int r){\n        if(r-l<2)return INF<D>();\n        D res=INF<D>();\n        res=min(res,closestPair(ps,l,(l+r)/2));\n        res=min(res,closestPair(ps,(l+r)/2,r));\n        \n        vector<P> lps,rps;\n        D lym=INF<D>(),lyM=-INF<D>(),rym=INF<D>(),ryM=-INF<D>();\n        FOR(i,l,(l+r)/2)if(abs(ps[i].X - ps[(l+r)/2].X)<res)lps.push_back(ps[i]),lym=min(lym,lps[i].Y),lyM=max(lyM,lps[i].Y);\n        FOR(i,(l+r)/2,r)if(abs(ps[i].X - ps[(l+r)/2].X)<res)rps.push_back(ps[i]),rym=min(rym,rps[i].Y),ryM=max(ryM,rps[i].Y);\n        vector<P> lps2,rps2;\n        REP(i,lps.size())if(rym<=lps[i].Y && lps[i].Y<=ryM)lps2.push_back(lps[i]);\n        REP(i,rps.size())if(lym<=rps[i].Y && rps[i].Y<=lyM)rps2.push_back(rps[i]);\n\n        REP(i,lps2.size())REP(j,rps2.size())res=min(res,abs(lps2[i]-rps2[j]));\n        return res;\n    }\n}\nusing namespace Ps;\n\nnamespace std{\n\n    bool compX (const P& a,const P& b){return a.X != b.X ? a.X < b.X : a.Y < b.Y;}\n    bool compY (const P& a,const P& b){return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;}\n    bool operator < (const P& a,const P& b){return compX(a,b);}\n    bool operator == (const P& a,const P& b){return eq(a,b);}\n};\n\nstringstream ss;\nclass Main{\n    public:\n    void run(){\n        int n;cin >> n;\n        vector<P> ps;\n        REP(i,n) {\n            P p;cin >> p;\n            ps.push_back(p);\n        }\n        sort(ALL(ps));\n        cout << closestPair(ps,0,n)<<endl;\n    }\n};\n\nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\nusing P = pair<double, double>;\n\nint main() {\n\n    int n;\n    cin >> n;\n\n    P p[n];\n\n    for (int i = 0; i < n; i++) {\n        double x, y;\n        cin >> x >> y;\n        p[i] = make_pair(x, y);\n    }\n\n    sort(p, p + n);\n\n    double ans = 100000;\n\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            P p1, p2;\n            p1 = p[i];\n            p2 = p[j];\n            double dx, dy;\n            dx = (p1.first - p2.first) * (p1.first - p2.first);\n            dy = (p1.second - p2.second) * (p1.second - p2.second);\n            if (dx > ans) break;\n            ans = min(ans, dx + dy);\n        }\n    }\n\n    cout << fixed << setprecision(7) << sqrt(ans) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/50))  \n #define Fun2(j,n) for(int j=i+(int)(n/50);j<n;j=j+(int)(n/50))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=500;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16????????????????????¢???10??????????????§?????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n double dx,dy;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   //?°?16????????????????????????????????? \n   minx=minx-1;\n   miny=miny-1;\n   maxx=maxx+1;\n   maxy=maxy+1;\n   dx=1.0/4*(maxx-minx);\n   dy=1.0/4*(maxy-miny);\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=3;j>=0;j--)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*(3-j)+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n   /*\n   for(int i=0;i<16;i++)\n   {\n     for(int j=0;j<num_point[i];j++)\n     {\n       cout<<wu[i][j].x<<\" \"<<wu[i][j].y<<endl;        \n     }        \n   }\n   */\n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n //?????¢????????????????????????????§???????????????¢?????? \n void circle_optimize(double center)\n {\n      \n }\n \n void triangle_optimize()\n {\n      \n }\n \n void rectangle_optimize()\n {\n      \n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       \n       if(fun_min!=(40000.0*2)) real_min=fun_min;\n       else real_min=(point[0].x-point[1].x)*(point[0].x-point[1].x)+(point[0].y-point[1].y)*(point[0].y-point[1].y);\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         bool flag1,flag2,flag3,flag4,judge; \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {      \n             //???????????????????????¬???????????????????????¨?????????????????????????¬????????°????????????????????????????????????????????°???????????????°?????¨ \n             double theta=sqrt(real_min)/2;\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               flag1=flag2=flag3=flag4=false;\n               judge=false;\n               if(point[i].x>=(minx+(n+1)*dx-theta)) flag1=true;\n               if(point[i].x<=(minx+(n+1)*dx)) flag2=true;\n               if(point[i].y>=(miny+(3-m)*dy)) flag3=true;\n               if(point[i].y<=(miny+(4-m)*dy)) flag4=true;\n               judge=flag1&&flag2&&flag3&&flag4;\n               if(!judge) continue;\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 flag1=flag2=flag3=flag4=false;\n                 judge=false;\n                 if(point[j].x>=(minx+(n+1)*dx)) flag1=true;\n                 if(point[j].x<=(minx+(n+1)*dx+theta)) flag2=true;\n                 if(point[j].y>=(miny+(3-m)*dy)) flag3=true;\n                 if(point[j].y<=(miny+(4-m)*dy)) flag4=true;\n                 judge=flag1&&flag2&&flag3&&flag4;\n                 if(!judge) continue;\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             double theta=sqrt(real_min)/2;\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               flag1=flag2=flag3=flag4=false;\n               judge=false;\n               if(point[i].x>=(minx+n*dx)) flag1=true;\n               if(point[i].x<=(minx+(n+1)*dx)) flag2=true;\n               if(point[i].y>=(miny+(3-m)*dy)) flag3=true;\n               if(point[i].y<=(miny+(3-m)*dy+theta)) flag4=true;\n               judge=flag1&&flag2&&flag3&&flag4;\n               if(!judge) continue;\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 flag1=flag2=flag3=flag4=false;\n                 judge=false;\n                 if(point[j].x>=(minx+n*dx)) flag1=true;\n                 if(point[j].x<=(minx+(n+1)*dx)) flag2=true;\n                 if(point[j].y>=(miny+(3-m)*dy-theta)) flag3=true;\n                 if(point[j].y<=(miny+(3-m)*dy)) flag4=true;\n                 judge=flag1&&flag2&&flag3&&flag4;\n                 if(!judge) continue;\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct node{\n  int dim;\n  vector<double>v;\n};\n\ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n\ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n\n  vector<node>res;\n\n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n\n    double dist=d(p,S)/(4*p.dim);\n\n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n\n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    \n    S=nextS;    \n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n  \n  return ans;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n\n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief (n 2) = Θ(n^2)通りの点対を調べ、最近点対間距離を返す\n *\n * @param const point*P 点集合P\n * @param index_t n     Pの要素数\n */\nstatic elem_t brute_force_closest_pair(const point*P, index_t n)\n{\n    elem_t minimum = std::numeric_limits<elem_t>::max();\n    for (index_t i = 0; i < n; i++) {\n        for (index_t j = i + 1; j < n; j++) {\n            elem_t dist = abs(P[i] - P[j]);\n            minimum = std::min(minimum, dist);\n        }\n    }\n    return minimum;\n}\n\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {  // |P| <= 3か否かを判定する\n        return std::numeric_limits<elem_t>::max();\n        //return brute_force_closest_pair(P, n);  // |P| <= 3ならば、虱潰で問題を解く\n    }\n\n    // |P| > 3ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) >= delta) { break; }\n\n            delta = std::min(delta, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return delta;\n}\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << setprecision(500) << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <utility>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> Point;\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nnamespace std{\n    bool operator<(const Point &a, const Point &b){\n        return !equals(a.X, b.X) ? a.X < b.X : a.Y < b.Y;\n    }\n\n    bool cmp_y(const Point &a, const Point &b) {\n        return !equals(a.Y, b.Y) ? a.Y < b.Y : a.X < b.X;\n    }\n}\n\ndouble closestPair(vector<Point> &points, int l, int r){\n    if(r - l <= 1) return 1e9;\n    int mid = (l + r) / 2;\n    double x = points[mid].X;\n    double d = min(closestPair(points, l, mid), closestPair(points, mid, r));\n    auto iti = points.begin();\n    auto itl = iti + l;\n    auto itm = iti + mid;\n    auto itr = iti + r;\n\n    inplace_merge(itl, itm, itr, cmp_y);\n\n    vector<Point> nearLine;\n    for(int i=l; i<r; i++){\n        if(abs(points[i].X - x) >= d) continue;\n\n        int sz = nearLine.size();\n        for(int j=sz-1; j>=0; j--){\n            double dx = points[i].X - nearLine[j].X;\n            double dy = points[i].Y - nearLine[j].Y;\n            if(dy >= d) break;\n            d = min(d, sqrt(dx * dx + dy * dy));\n        }\n\n        nearLine.emplace_back(points[i]);\n    }\n    \n    return d;\n}\n\nint main(){\n    int n; cin>>n;\n    vector<Point> points;\n    for(int i=0; i<n; i++){\n        double x, y; cin>>x>>y;\n        points.emplace_back(x, y);\n    }\n\n    sort(points.begin(), points.end());\n\n    printf(\"%.10f\\n\", closestPair(points, 0, n));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ntypedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\nnamespace std {\n  bool operator < (const P& a, const P& b) {//x????????????\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool sorty(const P& a, const P& b) {//y????????????\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\n\ndouble closestPair_calc(P *p,int n){\n  if(n < 2) return inf;\n  int m = n/2;\n  double x=real(p[m]);\n  double d = min(closestPair_calc(p,m),closestPair_calc(p+m,n-m));\n  inplace_merge(p,p+m,p+n,sorty);\n  vector<P> q;\n  double dx,dy;\n  rep(i,n) {\n    if(abs(real(p[i])-x)>=d)continue;\n\n    for(int j=q.size()-1;j>=0;j--)\n    {\n      dx=real(p[i])-real(q[j]);\n      dy=imag(p[i])-imag(q[j]);\n      if(dy>=d)break;\n      d=min(d,sqrt(dx*dx+dy*dy));\n    }\n    q.push_back(p[i]);\n  }\n  return d;\n}\n\ndouble closestPair(vector<P> &p,int n) {\n  if(n < 2) return 0.0;\n  sort(all(p));\n  double ans = closestPair_calc(&p[0],n);\n  return ans == inf ? 0.0 : ans;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  cin >>n;\n  double x,y;\n  vector<P> ps(n);\n  rep(i,n){\n    cin >> x >> y;\n    ps[i] = P{x,y};\n  }\n  fcout(10) << closestPair(ps,n) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\nstruct point2d{\n  double x, y;\n  point2d(){}\n  point2d(double x, double y): x(x), y(y){}\n  point2d operator+(const point2d &r) const{\n    return point2d(x + r.x, y + r.y);\n  }\n  point2d operator-(const point2d &r) const{\n    return point2d(x - r.x, y - r.y);\n  }\n  point2d& operator+=(const point2d &r){\n    *this = *this + r;\n    return *this;\n  }\n  point2d& operator-=(const point2d &r){\n    *this = *this - r;\n    return *this;\n  }\n  bool operator==(const point2d &r) const{\n    return abs(x - r.x) < EPS && abs(y - r.y) < EPS;\n  }\n  bool operator!=(const point2d &r) const{\n    return !(*this == r);\n  }\n  bool operator<(const point2d &r) const{\n    if(abs(x - r.x) >= EPS)return x < r.x;\n    return y < r.y;\n  }\n};\n\npoint2d operator*(double x, const point2d &p){\n  return point2d(x * p.x, x * p.y);\n}\n\npoint2d operator/(const point2d &p, double x){\n  return point2d(p.x / x, p.y / x);\n}\n\ndouble norm(const point2d &a){\n  return sqrt(a.x * a.x + a.y * a.y);\n}\n\ndouble dis(const point2d &a, const point2d &b){\n  point2d c = a - b;\n  return norm(c);\n}\n\ndouble inner_product(const point2d &a, const point2d &b){\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble outer_product(const point2d &a, const point2d &b){\n  return a.x * b.y - a.y * b.x;\n}\n\ndouble cosine(const point2d &a, const point2d &b){\n  return inner_product(a, b) / norm(a) / norm(b);\n}\n\ndouble closest_pair(vector<point2d> &a, int l, int r){\n  double d = numeric_limits<double>::max();\n  if(r - l == 1)return d;\n\n  int m = (l + r) / 2;\n  double x = a[m].x;\n  d = min(closest_pair(a, l, m), closest_pair(a, m, r));\n  inplace_merge(a.begin() + l, a.begin() + m, a.begin() + r, [](const point2d &u, const point2d &v){\n      return u.y < v.y;\n      });\n\n  vector<point2d> v;\n  for(int i = l; i < r; i++){\n    if(abs(x - a[i].x) >= d)continue;\n    for(int j = 0; j < v.size(); j++){\n      double dx = a[i].x - v[v.size()-j-1].x;\n      double dy = a[i].y - v[v.size()-j-1].y;\n      if(dy >= d)break;\n      d = min(d, sqrt(dx * dx + dy * dy));\n    }\n    v.push_back(a[i]);\n  }\n  return d;\n}\n\ndouble closest_pair(vector<point2d> &a){\n  sort(a.begin(), a.end(), [](const point2d &u, const point2d &v){\n      if(u.x != v.x)return u.x < v.x;\n      return u.y < v.y;\n      });\n  return closest_pair(a, 0, int(a.size()));\n}\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  INT(n);\n  vector<point2d> v(n);\n  rep(i, n)cin >> v[i].x >> v[i].y;\n  cout << closest_pair(v) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn std::sqrt(std::pow(b.first - a.first, 2)\n\t\t+ std::pow(b.second - a.second, 2));\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn -1;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP\n){\n\tint siz=xr-xl;\n\tif (siz <= 3) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tauto xM = xP[xl+siz/2].first;\n\tauto yL = std::vector<point_t>();\n\tauto yR = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {\n\t\treturn p.first <= xM;\n\t});\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {\n\t\treturn p.first > xM;\n\t});\n\tauto p1 = find_closest_optimized(xP,xl,xl+siz/2, yL);\n\tauto p2 = find_closest_optimized(xP,xl+siz/2,xr, yR);\n\tauto minD = (p1 <= p2) ? p1 : p2;\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n, yP);\n\tprintf(\"%.9f\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&min(memo,ans+0.005) >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans =(min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <vector>\n\n\nclass ClosestPair {\nprivate:\n  std::vector<double> x, y;\n  struct x_cmp {\n    const ClosestPair &cp;\n    x_cmp(const ClosestPair &cp) : cp(cp) {} \n    bool operator() (int i, int j) {\n      return cp.x[i] < cp.x[j];\n    }\n  };\n  struct y_cmp {\n    const ClosestPair &cp;\n    y_cmp(const ClosestPair &cp) : cp(cp) {} \n    bool operator() (int i, int j) {\n      return cp.y[i] < cp.y[j];\n    }\n  };\n  x_cmp xc;\n  y_cmp yc;\n  double dist2(int i, int j) const {\n    return pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2);\n  }\n\n  double min_brute_force(const std::vector<int> & v) const {\n    double mi = 1.0 / 0.0;\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n\tif (i == j) {\n\t  continue;\n\t}\n\tmi = std::min(mi, dist2(v[i], v[j]));\n      }\n    }\n    return mi;\n  }\n\n\n  double min_strip(const std::vector<int> &v, double d) const {\n    double mi = d;\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n      for (int j = i + 1; j < n && pow(y[v[j]] - y[v[i]], 2) < mi; ++j) {\n\tmi = std::min(mi, dist2(v[i], v[j]));\n      }\n    }\n    return mi;\n  }\n\n  /*\n   */\n  double min_pair_util(const std::vector<int> &vx) const {\n    int n = vx.size();\n    if (n <= 4) {\n      return min_brute_force(vx);\n    }\n    // divide at middle\n    int mid = n / 2;\n    double mid_x = x[vx[mid]];\n    double ml = min_pair_util(std::vector<int>(vx.begin(), vx.begin() + mid));\n    double mr = min_pair_util(std::vector<int>(vx.begin() + mid, vx.end()));\n    double dist = std::min(ml, mr);\n    std::vector<int> strip;\n    for(int i = 0; i < n; ++i) {\n      if (pow(x[vx[i]] - mid_x, 2) < dist) {\n\tstrip.push_back(vx[i]);\n      }\n    }\n    std::sort(strip.begin(), strip.end(), yc);\n    double res = min_strip(strip, dist);\n    return res;\n  }\n  ClosestPair(const std::vector<double> &xs, const std::vector<double> &ys) : x(xs), y(ys), xc(*this), yc(*this) {\n  }\n  double internal_solve(void) const {\n    int n = x.size();\n    std::vector<int> v(n);\n    for (int i = 0; i < n; ++i) {\n      v[i] = i;\n    }\n    std::sort(v.begin(), v.end(), xc);\n    return std::sqrt(min_pair_util(v));\n  }\npublic:\n  static double solve(const std::vector<double> &xs, const std::vector<double> &ys) {\n    return ClosestPair(xs, ys).internal_solve();    \n  }\n};\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\n#include <cstdio>\n#include <iostream>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef pair<int, int> PI;\nconst double EPS=1e-9;\n\nint main(void){\n  int n;\n  cin >> n;\n  vector<double> x(n), y(n);\n  REP(i, 0, n) {\n    cin >> x[i] >> y[i];\n  }\n  printf(\"%.9f\\n\", ClosestPair::solve(x, y));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n; double bx, by; pair<double, double> p[100009];\nint main() {\n\tscanf(\"%d\", &n);\n\tdouble sq = sin(1.234), cq = cos(1.234);\n\tfor(int i = 0; i < n; i++) {\n\t\tscanf(\"%lf%lf\", &bx, &by);\n\t\tdouble ex = bx * cq - by * sq;\n\t\tdouble ey = bx * sq + by * cq;\n\t\tp[i] = make_pair(ex, ey);\n\t}\n\tsort(p, p + n);\n\tdouble ret = 1.0e+10;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tdouble dx = p[i].first - p[j].first;\n\t\t\tif(dx * dx > ret) break;\n\t\t\tdouble dy = p[i].second - p[j].second;\n\t\t\tdouble dist = dx * dx + dy * dy;\n\t\t\tif(ret > dist) ret = dist;\n\t\t}\n\t}\n\tprintf(\"%.15lf\\n\", sqrt(ret));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define all(a) a.begin(),a.end()\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\nconst double INF = 1e9;\n\nbool compX(const Point a, const Point b) {\n    return a.X<b.X;\n}\n\nbool compY(const Point a, const Point b) {\n    return a.Y<b.Y;\n}\n\ndouble closestPair(VP &a,int l,int r) {\n    if(r-l<=1) return INF;\n    int m = (l+r)/2;\n    double x = a[m].X;\n    double d = min(closestPair(a,l,m),closestPair(a,m,r));\n    inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,compY);\n    \n    VP b;\n    for(int i=l;i<r;i++){\n        if(abs(a[i].X - x)>=d)continue;\n        for(int j=b.size()-1;j>=0;j--){\n            if((a[i]-b[j]).Y>=d)break;\n            d = min(d,abs(a[i]-b[j]));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main(void){\n    int n;\n    cin>>n;\n    VP ps(n);\n    rep(i,n){\n        double x,y;\n        cin>>x>>y;\n        ps[i] = Point(x,y);\n    }\n    sort(all(ps),compX);\n    printf(\"%.9f\\n\",closestPair(ps,0,n));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pt pair<double,double>\n#define x first\n#define y second\nconst double INF=1e5,EPS=1e-9;\npt p[100010];\ndouble pw2(double d){return d*d;}\ndouble dist(pt a,pt b){return sqrt(pw2(a.x-b.x)+pw2(a.y-b.y));}\ndouble closest(int l,int r)\n{\n  if(l==r)return INF;\n  int mid=(l+r)/2,pp=l,qq=mid+1;\n  double midline=p[mid].x;\n  double ret=min(closest(l,mid),closest(mid+1,r));\n  vector<pt>merge,slab;\n  while(pp<=mid || qq<=r)\n    if(pp>mid) merge.push_back(p[qq++]);\n    else if(qq>r) merge.push_back(p[pp++]);\n    else merge.push_back(p[pp].y<p[qq].y?p[pp++]:p[qq++]);\n  pp=l;for(int i=0;i<merge.size();i++)p[pp++]=merge[i];\n  for(int i=l;i<=r;i++)\n    if(abs(p[i].x-midline)+EPS<ret)\n      slab.push_back(p[i]);\n  for(int i=0;i<slab.size();i++)\n    for(int j=i+1;j<slab.size() && (slab[j].y-slab[i].y)<ret;j++)\n      ret=min(ret,dist(slab[i],slab[j]));\n  return ret;\n}\nint main()\n{\n  int n;\n  cin>>n;\n  for(int i=1;i<=n;i++)\n    cin>>p[i].x>>p[i].y;\n  cout<<fixed<<closest(1,n)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 200000\npair<long double, long double>pa[MAX_N];\nlong double dist(long double ax, long double ay, long double bx, long double by) { \n\treturn sqrt((ax - bx)*(ax - bx) + (ay - by)*(ay - by));\n}\nint main() {\n\tint N; cin >> N; long double minx = 100.0L, maxx = -100.0L, miny = 100.0L, maxy = -100.0L;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> pa[i].first >> pa[i].second;\n\t\tminx = min(minx, pa[i].first);\n\t\tmaxx = max(maxx, pa[i].first);\n\t\tminy = min(miny, pa[i].second);\n\t\tmaxy = max(maxy, pa[i].second);\n\t}\n\tsort(pa, pa + N);\n\tlong double maxn = 100000;\n\tlong double G = (maxx - minx) / (sqrtl(N) - 1);\n\tlong double H = (maxy - miny) / (sqrtl(N) - 1);\n\tif (G > H) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlong double L = pa[i].first - G, R = pa[i].first + G;\n\t\t\tint pos1 = lower_bound(pa, pa + N, make_pair(L, -1000.0L)) - pa;\n\t\t\tint pos2 = lower_bound(pa, pa + N, make_pair(R, 1000.0L)) - pa;\n\t\t\tfor (int j = pos1; j < pos2; j++) {\n\t\t\t\tif (i == j) { continue; }\n\t\t\t\tmaxn = min(maxn, dist(pa[i].first, pa[i].second, pa[j].first, pa[j].second));\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tswap(pa[i].first, pa[i].second);\n\t\t}\n\t\tsort(pa, pa + N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlong double L = pa[i].first - H, R = pa[i].first + H;\n\t\t\tint pos1 = lower_bound(pa, pa + N, make_pair(L, -1000.0L)) - pa;\n\t\t\tint pos2 = lower_bound(pa, pa + N, make_pair(R, 1000.0L)) - pa;\n\t\t\tfor (int j = pos1; j < pos2; j++) {\n\t\t\t\tif (i == j) { continue; }\n\t\t\t\tmaxn = min(maxn, dist(pa[i].first, pa[i].second, pa[j].first, pa[j].second));\n\t\t\t}\n\t\t}\n\t}\n\tcout << fixed << setprecision(1919) << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\nconst double INF = 1e9;\n\nbool compX(const Point a, const Point b) {\n    return (a.X!=b.X ? a.X<b.X : a.Y<b.Y);\n}\n\nbool compY(const Point a, const Point b) {\n    return a.Y<b.Y;\n}\n\ndouble closestPair(Point *a,int n) {\n    if(n<=1) return INF;\n    int m = n/2;\n    double x = a[m].X;\n    double d = min(closestPair(a,m),closestPair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compY);\n    \n    VP b;\n    rep(i,n){\n        if(abs(a[i].X - x)>=d)continue;\n        for(int j=b.size()-1;j>=0;j--){\n            Point ba = a[i]-b[j];\n            if(ba.Y>=d)break;\n            d = min(d,abs(ba));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\nint main(void){\n    int n;\n    cin>>n;\n    Point ps[n];\n    rep(i,n){\n        double x,y;\n        cin>>x>>y;\n        ps[i] = Point(x,y);\n    }\n    sort(ps,ps+n,compX);\n    printf(\"%.9f\\n\",closestPair(ps,n));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ntypedef vector<P> G;\n\npair<P,P> closestPair(G p) {\n  int n = p.size(), s = 0, t = 1, m = 2, S[n]; S[0] = 0, S[1] = 1;\n  SORT(p);\n  //double d = norm(p[s]-p[t]);\n  double d = abs(p[s]-p[t]);\n  for (int i = 2; i < n; S[m++] = i++) REP(j, m) {\n    double nd = abs(p[S[j]]-p[i]);\n    if (nd<d){\n      d = nd;\n      s = S[j];\n      t = i;\n    }\n    if (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n  }\n  return make_pair( p[s], p[t] );\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  SORT(g);\n  pair<P, P> ans = closestPair(g);\n  printf(\"%.10lf\\n\", abs(ans.second - ans.first));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nint dcmp(double d) {\n    if (fabs(d) < EPS) {\n        return 0;\n    }\n    else {\n        return d < 0? -1 : 1;\n    }\n}\n\nstruct Vector {\n    double x, y;\n    Vector(double x = 0, double  y = 0):x(x), y(y) {\n    }\n     \n    bool operator<(const Vector& other) const {\n        return dcmp(x - other.x) < 0 || (dcmp(x - other.x) == 0 && dcmp(y - other.y) < 0);\n    }\n};\n\ntypedef Vector Point;\n\ndouble dist(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble combine(vector<Point>& p, int l, int m, int r, double leftSmall, double rightSmall) {\n    double d = min(leftSmall, rightSmall);\n    double x = (p.at(m).x + p.at(m + 1).x)/2;\n    \n    double best = DBL_MAX;\n    \n    for (int i = m; i >= l && dcmp(x - p.at(i).x - d) <= 0; i--) {\n        for (int j = m + 1; j <= r &&dcmp(p.at(i).x - x - d) <= 0; j++) {\n            best = min(best, dist(p.at(i), p.at(j)));\n        } \n    }\n    return min(best, d);\n}\n\n\ndouble solve(vector<Point>& p, int l, int r) {\n    if (l >= r) {\n        return DBL_MAX;\n    }\n    int m = (l + r) / 2;\n    \n    double leftSmall = solve(p, l, m);\n    double rightSmall = solve(p, m + 1, r);\n    \n    return combine(p, l, m, r, leftSmall, rightSmall);\n}\n\nint main() {\n    int n; \n    cin >> n;\n    vector<Point> p(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i].x >> p[i].y;\n    }\n    \n    sort(p.begin(), p.end());\n    \n    double ans = solve(p, 0, n - 1);\n    \n    cout << fixed << setprecision(8) << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <numeric>\n\nusing namespace std;\n\nusing point = pair<float, float>;\nusing vpoint = vector<point>;\n\ninline float distance(point &a, point &b) { return sqrt(pow(a.first - b.first, 2) + pow(a.second - b.second, 2)); }\nvoid splitX(vpoint &x, vpoint &xl, vpoint &xr);\n\nfloat closestSplit(vpoint &x, vpoint &y, float sigma)\n{\n    float xbar = x[x.size()/2].first, d = numeric_limits<float>::max();\n    vpoint sy;\n    for (uint32_t i = 0; i < y.size(); ++i)\n        if (abs(xbar - y[i].first) <= sigma)\n            sy.push_back(y[i]);\n    for (uint32_t i = 0; i < sy.size(); ++i)\n        for (uint32_t j = 1; j < 8 && i+j < sy.size(); ++j)\n            d = min(d, distance(sy[i], sy[i+j]));\n    return d;\n}\n\nfloat closestPairDistance(vpoint &x, vpoint &y)\n{\n    if (x.size() < 4)\n    {\n        float d = numeric_limits<float>::max();\n        for (uint32_t i = 0; i < x.size(); ++i)\n            for (uint32_t j = i+1; j < x.size(); ++j)\n                d = min(d, distance(x[i], x[j]));\n        return d;\n    }\n    vpoint xl, xr;\n    splitX(x, xl, xr);\n    float sigma = min(closestPairDistance(xl, y), closestPairDistance(xr, y));\n    return min(sigma, closestSplit(x, y, sigma));\n}\n\nint main()\n{\n    int n;\n    vpoint x, y;\n    scanf(\"%d\", &n);\n    x.resize(n);\n    y.resize(n);\n    for (int i = 0; i < n; ++i)\n    {\n        scanf(\"%f %f\", &x[i].first, &x[i].second);\n        y[i] = x[i];\n    }\n    sort(x.begin(), x.end(), [](point &a, point &b)\n    {\n        return a.first < b.first;\n    });\n    sort(y.begin(), y.end(), [](point &a, point &b)\n    {\n        return a.second < b.second;\n    });\n    cout << setprecision(11) << closestPairDistance(x, y);\n}\n\nvoid splitX(vpoint &x, vpoint &xl, vpoint &xr)\n{\n    uint32_t size = x.size(), n = size/2, i;\n    xl.resize(n);\n    xr.resize(size - n);\n    for (i = 0; i < n; ++i)\n        xl[i] = x[i];\n    for (; i < size; ++i)\n        xr[i-n] = x[i];\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/50))  \n #define Fun2(j,n) for(int j=i+(int)(n/50);j<n;j=j+(int)(n/50))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n double interval[9][2]={{0,2},{0,5},{0,8}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int i=0;i<4;i++)\n     {\n       for(int j=0;j<4;j++)\n       {\n         if(point[i].x>=minx+1.0*i/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(i+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*i/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(i+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*i+j;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n }\n \n //??????????????????????????¬??????2500???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=500)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n void wuhao_cut()\n {\n   if(fun_min<=(1.0*50*50))\n   {\n     ok=true;\n     //?¬¬????±??????? \n     for(int i=0;i<16;i++)\n     {\n       for(int j=0;j<num_point[i];j++)\n       {\n         for(int k=j+1;k<num_point[i];k++)\n         {\n           num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n           if(num<real_min) real_min=num;         \n         }        \n       }        \n     }\n     //?¬¬????±?????????????A?????? \n     for(int m=0;m<4;m++)\n     {\n       for(int n=0;n<3;n++)\n       {\n         for(int i=0;i<num_point[m*4+n];i++)\n         {\n           for(int j=0;j<num_point[m*4+n+1];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;        \n           }        \n         }        \n       }        \n     } \n     //?¬¬????±?????????????B??????\n     for(int m=0;m<4;m++)\n     {\n       for(int n=0;n<3;n++)\n       {\n         for(int i=0;i<num_point[n*4+m];i++)\n         {\n           for(int j=0;j<num_point[(n+1)*4+m];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;        \n           }        \n         }        \n       }        \n     } \n     //?¬¬????±???????A??????\n     for(int m=0;m<3;m++)\n     {\n       for(int n=0;n<3;n++)\n       {\n         for(int i=0;i<num_point[m*4+n];i++)\n         {\n           for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;        \n           }        \n         }        \n       }        \n     }  \n     //?¬¬????±???????B?????? \n     for(int m=0;m<3;m++)\n     {\n       for(int n=1;n<4;n++)\n       {\n         for(int i=0;i<num_point[m*4+n];i++)\n         {\n           for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;        \n           }        \n         }        \n       }        \n     } \n   }   \n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   //find_the_border();\n   //divide_the_plane();\n   //try_for_fun();\n   //if(ok) wuhao_cut(); \n   //else general_way();\n   general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n\nusing ld = long double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ntemplate<class iter>\ntuple<ld, P, P> closest_pair(iter left, iter right) {\n    int n = distance(left, right);\n    if(n <= 1) return make_tuple(numeric_limits<ld>::max(), *left, *left);\n    iter middle = next(left, n/2);\n    ld x = middle->real();\n    auto d = min(closest_pair(left, middle), closest_pair(middle, right));\n    inplace_merge(left, middle, right, [](const P &a, const P &b){\n            return a.imag() < b.imag();\n        });\n    vector<iter> around;\n    for(iter i = left; i != right; ++i){\n        ld dx = fabs(i->real() - x);\n        ld &opt = get<0>(d);\n        if(dx*dx >= opt) continue;\n        for(auto j = around.rbegin(); j != around.rend(); ++j){\n            ld dx = i->real() - (**j).real();\n            ld dy = i->imag() - (**j).imag();\n            if(dy*dy >= opt) break;\n            ld norm = dx*dx + dy*dy;\n            if(get<0>(d) > norm){\n                d = make_tuple(norm, *i, **j);\n            }\n        }\n        around.push_back(i);\n    }\n    return d;\n};\n\n// http://www.spoj.com/problems/CLOPPAIR/\n// 18124516\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout << fixed << setprecision(6) << endl;\n    int n;\n    while(cin >> n){\n        vector<P> a;\n        map<P,int> idx;\n        rep(i,n){\n            ll x,y;\n            cin >> x >> y;\n            a.emplace_back(x,y);\n            idx[P(x,y)] = i;\n        }\n        ll z;\n        P x, y;\n        sort(all(a));\n        tie(z, x, y) = closest_pair(all(a));\n        int A = idx[x], B = idx[y];\n        if(A > B) swap(A, B);\n        cout << A << ' ' << B << ' ' << sqrt(z) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<utility>\n\ntypedef pair<double, double> point;\ntypedef point* data;\n\ndouble dist(const point &p1, const point &p2)\n{\n\tdouble dx = p1.first - p2.first;\n\tdouble dy = p1.second - p2.second;\n\treturn sqrt(dx * dx + dy * dy);\n}\n\nbool sort_y(const point &p1, const point &p2){ return p1.second < p2.second; }\n\ndouble closest(data X, data Y, int n)\n{\n\tif(n <= 3){\n\t\tdouble d = dist(X[0], X[1]);\n\t\tfor(int i = 0; i < n; i++){ Y[i] = X[i]; }\n\t\tsort(Y, Y + n, sort_y);\n\n\t\tif(n < 3){ return d; }\n\t\telse{ return min(d, min(dist(X[0], X[2]), dist(X[1], X[2]))); }\n\t}\n\tint m = (n >> 1);\n\tdouble median = X[m].first;\n\tdouble d = min(closest(X, Y, m), closest(X + m, Y + m, n - m));\n\n\tdata Z; int size = 0;\n\tZ = new point [n];\n\tint i = 0, j = m;\n\twhile(i < m && j < n){\n\t\tif(i < m && j < n){\n\t\t\tif(Y[i].second < Y[j].second){\n\t\t\t\tZ[size] = Y[i]; size++; i++;\n\t\t\t}else{\n\t\t\t\tZ[size] = Y[j]; size++; j++;\n\t\t\t}\n\t\t}\n\t\tif(i == m && j < n){ while(j < n){ Z[size] = Y[j]; size++; j++; }; }\n\t\tif(i < m && j == n){ while(i < m){ Z[size] = Y[i]; size++; i++; }; }\n\t};\n\tint resize = 0;\n\tfor(i = 0; i < size; i++){\n\t\tif(fabs(Z[i].first - median) <= d){ Z[resize] = Z[i]; resize++; }\n\t}\n\n\tint a = 0;\n\tfor(i = 1; i < resize; i++){\n\t\tfor(j = a; j < i; j++){\n\t\t\tif(Z[i].second - Z[a].second > d){ a++; }\n\t\t\telse{\n\t\t\t\td = min(d, dist(Z[i], Z[a]));\n\t\t\t}\n\t\t}\n\t}\n\tdelete [] Z;\n\treturn d;\n}\n\nint main()\n{\n\tdata X, Y;\n\tint i, n;\n\tscanf(\"%d\", &n);\n\tX = new point [n];\n\tY = new point [n];\n\n\tdouble co_x, co_y;\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &co_x, &co_y);\n\t\tX[i] = make_pair(co_x, co_y);\n\t}\n\tsort(X, X + n);\n\n\tdouble d = closest(X, Y, n);\n\tprintf(\"%.12f\\n\", d);\n\n\tcin >> n;\n\tdelete [] X;\n\tdelete [] Y;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define nmax 1000010\n#define f(c,a,b) for(int c=a; c<=b; c++)\n#define inf 1e24\n\nusing namespace std;\ntypedef double db;\nstruct P{\n    db x, y;\n    P(){}\n    P(db x, db y) : x(x) , y(y) {}\n    P operator - (P a){ return P(x-a.x, y-a.y); }\n    db clen(){ return sqrt(x*x+y*y); }\n};\nP p[nmax], t[nmax];\nint n;\nbool c_x(P& a, P& b) { return a.x < b.x; }\nbool c_y(P& a, P& b) { return a.y < b.y; }\n\ndb closestP(int l, int r){\n    db ta = inf;\n    if(r-l<=4){\n        f(i,l,r) f(j,i+1,r) ta = min(ta, (p[i]-p[j]).clen() );\n        sort(p+l, p+r+1, c_y);\n    }else{\n        int mid = (l+r)>>1;\n        db mx = p[mid].x, d;\n        ta = d = min( closestP(l,mid), closestP(mid+1,r) );\n        merge(p+l, p+mid+1, p+mid+1, p+r+1, t, c_y);\n        copy(t, t+r-l+1, p+l);\n        int jsz=0;\n        f(i,l,r) if( abs(p[i].x-mx) < d ) {\n                for (int j=jsz; j>=1 && p[i].y-t[j].y<d; j--) ta = min(ta, (t[j]-p[i]).clen() );   \n                t[++jsz] = p[i];\n        }\n    }\n    return ta;\n}\n\nint main(){\n    //freopen(\"owo.in\",\"r\",stdin);\n    cin >> n;\n    f(i,1,n) scanf(\"%lf%lf\", &p[i].x, &p[i].y);\n    sort(p+1, p+n+1, c_x);\n    printf(\"%.11lf\\n\", closestP(1, n));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ntypedef vector<P> G;\n\npair<P,P> closestPair(G p) {\n  int n = p.size(), s = 0, t = 1, m = 2, S[n]; S[0] = 0, S[1] = 1;\n  SORT(p);\n  //double d = norm(p[s]-p[t]);\n  double d = abs(p[s]-p[t]);\n  for (int i = 2; i < n; S[m++] = i++) REP(j, m) {\n    if (abs(p[S[j]]-p[i])<d) d = abs(p[s = S[j]]-p[t = i]);\n    if (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n  }\n  return make_pair( p[s], p[t] );\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  SORT(g);\n  pair<P, P> ans = closestPair(g);\n  printf(\"%.10lf\\n\", abs(ans.second - ans.first));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = limits::inf;\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        index_t limit =;  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) >= delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << setprecision(500) << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nstruct P\n{\n\tlong double x, y;\n\tP(long double x, long double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tlong double length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tlong double length2()const\n\t{\n\t\treturn x*x + y*y;\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nint ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}\n\npair<P, P> ClosestPair(vector<P>& points)\n{\n\tint n = points.size(), s = 0, t = 1, m = 2;\n\tvector<int> S(n);\n\tS[0] = 0, S[1] = 1;\n\tsort(points.begin(), points.end());\n\tlong double d = (points[s] - points[t]).length2();\n\tfor (int i = 2; i < n; S[m++] = i++)for (int j = 0; j < m; j++)\n\t{\n\t\tif ((points[S[j]] - points[i]).length2() < d)\n\t\t{\n\t\t\td = (points[s = S[j]] - points[t = i]).length2();\n\t\t}\n\t\tif (points[S[j]].x < points[i].x - d)\n\t\t{\n\t\t\tS[j--] = S[--m];\n\t\t}\n\t}\n\treturn make_pair(points[s], points[t]);\n}\n\nvector<P> points;\n\nint main()\n{\n\tpoints.reserve(100000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\tpoints.push_back(P(x, y));\n\t}\n\n\tpair<P, P> closestPair = ClosestPair(points);\n\tprintf(\"%.10lf\\n\", (double)((closestPair.first - closestPair.second).length()));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,-1,0,1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tdouble x;\n                                            \tint y,z,w;\n                                            \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n                \tint zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n      \nbool hikaku(pa &x,pa &y){\n\tif(x.first!=y.second)return x.second<y.second;\n\treturn x.first<y.first;\n\t\n}\n\nint ji(int x,int y){\n\treturn x*x+y*y;\n}\n\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\n\nint n;\n  \tcin>>n;\n  \tvector<pa> ve;\n\n  \tfor(int i=0;i<n;i++){\n  \t\tdouble y,yy;\n  \t\tcin>>y>>yy;\n  \t\ty*=10000000;\n  \t\tyy*=10000000;\n  \t\tint Y=y;\n  \t\tint YY=yy;\n\t\t\n  \t\tY+=inf-7;\n  \t\tif(Y%10==9)Y++;\n  \t\tif(Y%10==1)Y--;\n  \t\tY-=inf-7;\n  \t\t\n  \t\t\n  \t\tYY+=inf-7;\n  \t\tif(YY%10==9)YY++;\n  \t\tif(YY%10==1)YY--;\n  \t\tYY-=inf-7;\n  \t\t\n  \t\t\n  \t\tassert(Y%10==0);\n  \t\tassert(YY%10==0);\n  \t\tY/=10,YY/=10;\n  \t//\tcout<<(int)y<<\" \"<<(int)yy<<endl;\n  \t\tve.pb(mp((int)(Y),(int)(YY)));\n  \t}\n  \t// y-sort\n  \tsort(ve.begin(),ve.end(),hikaku);\n  \t\n  \tset<pa>se;\n  \tint ans=2000000000ll*2000000000ll;\n  \t\n  \tfor(auto v:ve){\n  \t\tint x=v.first,y=v.second;\n  \t\tint d=sqrt(ans)+5;\n  \t\tint xmin=x-d;\n  \t\tint xmax=x+d;\n  \t//\tcout<<x<<\" \"<<y<<\" \"<<xmin<<endl;\n  \t\tauto it=se.lower_bound((pa)mp(xmin,0));\n  \t\twhile(1){\n  \t\t\tif(it==se.end())break;\n  \t\t\tif((*it).second<=y-d){\n  \t\t\t\tit=se.erase(it);\n  \t\t\t\tcontinue;\n  \t\t\t}\n  \t\t\tif((*it).first>=xmax)break;\n  \t\t\t\n  \t\t\tif(ji((*it).first-x,(*it).second-y)<ans){\n  \t\t\t\tans=ji((*it).first-x,(*it).second-y);\n  \t\t\t}\n  \t\t\tit++;\n  \t\t}\n  \t\t\n  \t\tse.insert(v);\n  \t}\n  \tdouble d=ans;\n  \t\n  \tprintf(\"%.20lf\\n\",sqrt(d)/1000000.0);\n // \tcout<<ans<<endl;\n  \t\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief (n 2) = Θ(n^2)通りの点対を調べ、最近点対間距離を返す\n *\n * @param const point*P 点集合P\n * @param index_t n     Pの要素数\n */\nstatic elem_t brute_force_closest_pair(const point*P, index_t n)\n{\n    elem_t minimum = std::numeric_limits<elem_t>::max();\n    for (index_t i = 0; i < n; i++) {\n        for (index_t j = i + 1; j < n; j++) {\n            elem_t dist = abs(P[i] - P[j]);\n            minimum = std::min(minimum, dist);\n        }\n    }\n    return minimum;\n}\n\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {  // |P| <= 3か否かを判定する\n        return std::numeric_limits<elem_t>::max();\n        //return brute_force_closest_pair(P, n);  // |P| <= 3ならば、虱潰で問題を解く\n    }\n\n    // |P| > 3ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if (P[i].y - p.y >= delta) { break; }\n\n            delta = std::min(delta, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return delta;\n}\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << setprecision(500) << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ntypedef vector<P> G;\n\npair<P,P> closestPair(G p) {\n  int n = p.size(), s = 0, t = 1, m = 2, S[n]; S[0] = 0, S[1] = 1;\n  SORT(p);\n  //double d = norm(p[s]-p[t]);\n  double d = abs(p[s]-p[t]);\n  for (int i = 2; i < n; S[m++] = i++) REP(j, m) {\n    if (abs(p[S[j]]-p[i])<d) d = abs(p[s = S[j]]-p[t = i]);\n    if (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n  }\n  return make_pair( p[s], p[t] );\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  SORT(g);\n  pair<P, P> ans = closestPair(g);\n  printf(\"%.10lf\\n\", abs(ans.second - ans.first));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return norm( B - A ); }\n\nint n;\nlf d;\npt P[ MAXN ], extra[ MAXN];\n\nbool cmpX( const pt &A, const pt &B ) {\n  return B.x > A.x + EPS;\n}\n\nlf sqr( lf x ) {\n  return x*x;\n}\n\nvoid merge( int f, int m, int t ){\n\tint total = t - f + 1;\n\tfor( int i = 0, l = f, r = m+1; i < total; ++i ){\n\t\tif( l == m+1 ){\n      extra[ i ] = P[ r++ ];\n\t\t}\n\t\telse if( r == t+1 ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse if( P[l].y+EPS < P[r].y ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse{\n\t\t  extra[ i ] = P[ r++ ];\n\t\t}\n\t}\n\tfor( int i = 0; i < total; ++i ){\n    P[ f+i ] = extra[ i ];\n\t}\n}\n\nvoid solve( int f, int t ) {\n  if( f == t ) return;\n\tint mi = (f + t)/2;\n\tsolve( f, mi );\n\tsolve( mi+1, t );\n\tmerge( f, mi, t );\n\tvector< int > idxs;\n\tfor( int i = f; i <= t; ++i ){\n\t\tif( sqr(P[mi].x - P[i].x )+EPS < d ) idxs.push_back( i );\n\t}\n\tfor( int i = 0; i < idxs.size(); ++i ){\n\t\tfor( int j = i+1; j < idxs.size() && sqr(P[ idxs[i] ].y - P[ idxs[j] ].y)+EPS < d; ++j ){\n\t\t\td = min( d, dist( P[ idxs[i] ], P[ idxs[j] ] ) );\n\t\t}\n\t}\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  sort( P, P+n, cmpX );\n  d = oo;\n  solve( 0, n-1 );\n  cout << double(sqrt(d)) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<utility>\n\ntypedef pair<double, double> point;\n\ndouble dist(const point &p1, const point &p2)\n{\n\tdouble dx = p1.first - p2.first;\n\tdouble dy = p1.second - p2.second;\n\treturn sqrt(dx * dx + dy * dy);\n}\n\nbool sort_y(const point &p1, const point &p2){ return p1.second < p2.second; }\n\npoint Z[100000];\n\ndouble closest(point X[], point Y[], int n)\n{\n\tif(n <= 3){\n\t\tdouble d = dist(X[0], X[1]);\n\t\tfor(int i = 0; i < n; i++){ Y[i] = X[i]; }\n\t\tsort(Y, Y + n, sort_y);\n\n\t\tif(n < 3){ return d; }\n\t\telse{ return min(d, min(dist(X[0], X[2]), dist(X[1], X[2]))); }\n\t}\n\tint m = (n >> 1);\n\tdouble median = X[m].first;\n\tdouble d = min(closest(X, Y, m), closest(X + m, Y + m, n - m));\n\n\tint size = 0;\n\tint i = 0, j = m;\n\twhile(i < m && j < n){\n\t\tif(i < m && j < n){\n\t\t\tif(Y[i].second < Y[j].second){\n\t\t\t\tZ[size] = Y[i]; size++; i++;\n\t\t\t}else{\n\t\t\t\tZ[size] = Y[j]; size++; j++;\n\t\t\t}\n\t\t}\n\t\tif(i == m && j < n){ while(j < n){ Z[size] = Y[j]; size++; j++; }; }\n\t\tif(i < m && j == n){ while(i < m){ Z[size] = Y[i]; size++; i++; }; }\n\t};\n\tint resize = 0;\n\tfor(i = 0; i < size; i++){\n\t\tif(fabs(Z[i].first - median) <= d){ Z[resize] = Z[i]; resize++; }\n\t}\n\n\tint a = 0;\n\tfor(i = 1; i < resize; i++){\n\t\tfor(j = a; j < i; j++){\n\t\t\tif(Z[i].second - Z[a].second > d){ a++; }\n\t\t\telse{\n\t\t\t\td = min(d, dist(Z[i], Z[a]));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\n\nint main()\n{\n\tpoint X[100000], Y[100000];\n\tint i, n;\n\tscanf(\"%d\", &n);\n\n\tdouble co_x, co_y;\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &co_x, &co_y);\n\t\tX[i] = make_pair(co_x, co_y);\n\t}\n\tsort(X, X + n);\n\n\tdouble d = closest(X, Y, n);\n\tprintf(\"%.12f\\n\", d);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x, double y) : x(x), y(y) {}\n    Point() {}\n};\nbool operator<(const Point &p1, const Point &p2) {\n    return p1.y < p2.y;\n}\n\ndouble ClosestPair(vector<Point>::iterator begin, vector<Point>::iterator end) {\n    const int n = end - begin;\n    if (n <= 1)\n        return numeric_limits<double>::max();\n    int m = n / 2;\n    double x = (begin + m)->x;\n    double d = min(ClosestPair(begin, begin + m), ClosestPair(begin + m, end));\n    inplace_merge(begin, begin + m, end);\n\n    vector<Point> b;\n    for (auto it = begin; it != end; ++it) {\n        if (d <= abs(it->x - x))\n            continue;\n\n        for (size_t i = 0; i < b.size(); ++i) {\n            double dx = it->x - b[b.size() - i - 1].x;\n            double dy = it->y - b[b.size() - i - 1].y;\n            if (d <= dy)\n                break;\n            d = min(d, sqrt(dx * dx + dy * dy));\n        }\n        b.emplace_back(*it);\n    }\n\n    return d;\n}\n\ndouble Solve(vector<Point> &p) {\n    return ClosestPair(p.begin(), p.end());\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(8) << setiosflags(ios::fixed); // printf(\"%.4f\", x);\n\n    int n;\n\n    cin >> n;\n    vector<Point> p(n);\n    for (int i = 0; i < n; ++i)\n        cin >> p[i].x >> p[i].y;\n\n    cout << Solve(p) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf dist ( pt A, pt B ) { return abs( B - A ); }\n\nint n;\npt P[ MAXN ], extra[ MAXN ];\n\nbool cmpX( const pt &A, const pt &B ) {\n  //if( same( A.x, B.x ) ) return A.y+EPS < B.y;\n  return A.x+EPS < B.x;\n}\n\n/*\nlf sqr( lf x ) {\n  return x*x;\n}*/\n\nvoid merge( int f, int m, int t ){\n\tint total = t - f + 1;\n\tfor( int i = 0, l = f, r = m+1; i < total; ++i ){\n\t\tif( l == m+1 ){\n      extra[ i ] = P[ r++ ];\n\t\t}\n\t\telse if( r == t+1 ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse if( P[l].y < P[r].y ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse{\n\t\t  extra[ i ] = P[ r++ ];\n\t\t}\n\t}\n\tfor( int i = 0; i < total; ++i ){\n    P[ f+i ] = extra[ i ];\n\t}\n}\n\nlf solve( int f, int t ) {\n  if( f == t ) return oo;\n\tint mi = (f + t)/2;\n\tlf d = min( solve( f, mi ), solve( mi+1, t ) );\n\tmerge( f, mi, t );\n\tvector< int > idxs;\n\tfor( int i = f; i <= t; ++i ){\n\t\tif( P[mi].x - P[i].x < d ) idxs.push_back( i );\n\t}\n\tfor( int i = 0; i < idxs.size(); ++i ){\n\t\tfor( int j = i+1; j < idxs.size() && (P[ idxs[i] ].y - P[ idxs[j] ].y < d); ++j ){\n\t\t\td = min( d, dist( P[ idxs[i] ], P[ idxs[j] ] ) );\n\t\t}\n\t}\n\treturn d;\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"CGL_5_A-in25.txt\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 20 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  sort( P, P+n, cmpX );\n  /*d = oo;\n  for( int i = 0; i < n; ++i ) {\n    for( int j = i+1; j < n; ++j ) {\n      d = min( d, dist(P[i],P[j]) );\n    }\n  }\n  cout << double(sqrt(d)) << '\\n';*/\n  cout << double( solve( 0, n-1 ) ) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n  \n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\ntypedef double number;\n  \nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<number> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n  \ntypedef vector<P> G;\n  \nnumber closestPair(G &p) {\n  int n = p.size(), s = 0, t = 1, m = 2;\n  int S[n];\n  S[0] = 0, S[1] = 1;\n  sort(ALL(p)); // \"p < q\" <=> \"p.x < q.x\"\n  double d = norm(p[s]-p[t]);\n  for (int i = 2; i < n; S[m]=i,i++,m++) REP(j, m) {\n    if (norm(p[S[j]]-p[i])<d) s = S[j], t = i, d = norm(p[s]-p[t]);\n    if (real(p[S[j]]) < real(p[i]) - d) m--,S[j]=S[m],j--;\n  }\n  return abs(p[s]-p[t]);//make_pair( p[s], p[t] );\n}\n  \nint main(){\n\tG poly;\n\tint n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);n--;poly.push_back(P(x,y)))scanf(\"%lf%lf\",&x,&y);\n\tprintf(\"%.9f\\n\",closestPair(poly));\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @note   関連URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら5個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = limits::inf;\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) >= delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout.setf(ios::fixed);\n    cout.precision(8);\n    cout << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n幾何\nhttps://gist.github.com/zeptometer/3719669\n複素数平面による幾何ライブラリ←もっと短くなる可能生アリ\nhttp://osrehun.hatenadiary.jp/entry/2016/12/31/145827\n\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing DD=double;\n\n\n#define EPS 1e-10\n#define eq(a,b) (abs( (a) - (b) )<EPS)\nconst DD PI=acosl(-1.0);\nconstexpr DD INF=1LL<<62;\n\n//点\nusing P=complex<DD>;\n//ベクトル\nusing V=P;\n//線分\nstruct Segment{\n    P a,b;\n    Segment()=default;\n    Segment(P a,P b) :a(a),b(b){}\n    Segment(DD ax,DD ay,DD bx,DD by):a(ax,ay),b(bx,by){}\n\n};\n//直線\nusing Line=Segment;\n//円\nstruct Circle{\n    P p;\n    DD r;\n    Circle()=default;\n    Circle(P p,DD r):p(p),r(r){}\n};\nusing Polygon=vector<P>;\n\n//++++++++++++++++基本計算++++++++++++++//\ninline DD torad(const DD &deg){return deg*PI/180;}\ninline DD todeg(const DD &rad){return rad*180/PI;}\n//内積\ninline DD dot(const V &a,const V &b){\n    return real(a*conj(b));\n}\n//外積\ninline DD cross(const V &a,const V &b){\n    return imag(conj(a)*b);\n}\n//ベクトルvを反時計回りにr度回転\ninline V rotate(const V &v,const DD r){\n    return v*V(cos(r),sin(r));\n}\ninline bool xy(const P &a,const P &b){\n    if(real(a)+EPS<=real(b)) return true;\n    if(eq(real(a),real(b)) && imag(a)+EPS<imag(b)) return true;\n    return false;\n}\ninline bool yx(const P &a,const P &b){\n    if(imag(a)+EPS<imag(b)) return true;\n    if(eq(imag(a),imag(b)) && real(a)+EPS<real(b)) return true;\n    return false;\n}\n\n//++++++++++++++++平行や直交+++++++++++++++//\ninline bool isOrthogonal(const V &a,const V &b){\n    return eq(dot(a,b),0.0);\n}\ninline bool isOrthogonal(const Segment &a,const Segment &b){\n    return eq(dot(a.a-a.b,b.a-b.b),0);\n}\ninline bool isParallel(const V &a,const V &b){\n    return eq(cross(a,b),0.0);\n}\ninline bool isParallel(const Segment &a,const Segment &b){\n    return eq(cross(a.a-a.b,b.a-b.b),0);\n}\n//線分a-bに対してcがどの位置にあるか\n//ccwの簡略版 反時計回り:1 時計回り:-1 直線上:0\ninline int ccw(const P &a,const P &b,const P &c){\n    DD cr=cross(b-a,c-a);\n    if(cr>EPS) return 1;\n    if(cr<-EPS) return -1;\n    return 0;\n}\n\n//線分a-bに対してcがどの位置にあるか\n//反時計回り:1　時計回り:-1 直線上(a,b,c:-2 a,c,b:0 c,a,b:2) \ninline int ccwH(P a,P b,P c){\n    b-=a;c-=a;\n    if(cross(b,c)>EPS) return 1;\n    if(cross(b,c)<-EPS) return -1;\n    if(dot(b,c)<-EPS) return 2;\n    if(norm(b)<norm(c)) return -2;\n    return 0;\n}\n\n\n//+++++++++++++++射影+++++++++++++++++++++//\ninline P project(const P &p,const Segment &s){\n    V base=s.b-s.a;\n    DD r=dot(p-s.a,base)/norm(base);\n    return s.a+base*r;\n}\ninline P reflect(const P &p,const Segment &s){\n    return p+(project(p,s)-p)*2.0;\n}\n/*++++++++++点との距離++++++++++++++++++*/\n//点と直線の距離\ninline DD dis(const P &p,const Line &l){return abs(cross(l.b-l.a,p-l.a))/abs(l.b-l.a);}\n//点と線分の距離\ninline DD disPS(const P &p,const Segment &s){\n    if( dot(s.b-s.a,p-s.a)<0.0 ) return abs(p-s.a);\n    if( dot(s.a-s.b,p-s.b)<0.0 ) return abs(p-s.b);\n    return dis(p,s); //点と直線の距離\n}\n\n\n//+++++++++++++++線分と直線+++++++++++++++++//\n\n//線分a-b,c-dは交差するか?\ninline bool intersect(const P &a,const P &b,const P &c,const P &d){\n    return(ccwH(a,b,c)*ccwH(a,b,d)<=0 && ccwH(c,d,a)*ccwH(c,d,b)<=0);\n}\n//線分s,tは交差するか？\ninline bool intersect(const Segment &s,const Segment &t){\n    return intersect(s.a,s.b,t.a,t.b);\n}\n//線分と線分の交点\n//これをやる前にintersectで判定\ninline P crossPoint(const Segment &s,const Segment &t){\n    V base=t.b-t.a;\n    DD d1=abs(cross(base,s.a-t.a));\n    DD d2=abs(cross(base,s.b-t.a));\n    DD r=d1/(d1+d2);\n    return s.a+(s.b-s.a)*r;\n}\n//線分と線分の距離\ninline DD dis(const Segment &s,const Segment t){\n    if(intersect(s,t)) return 0.0;\n    return min(min(disPS(t.a,s),disPS(t.b,s)),min(disPS(s.a,t),disPS(s.b,t)) );\n}\n\n//+++++++++++円++++++++++++++++//\n\n//円cと直線lの交点\n//abs(l,c.p)<c.r+EPSが必要\npair<P,P> crossPoint(const Line &l,const Circle &c){\n    P pr=project(c.p,l);\n    V e=(l.b-l.a)/(abs(l.b-l.a));\n    DD base=sqrt(c.r*c.r-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n//線分sと円cの交点\nvector<P> crossPointSC(const Segment &s,const Circle &c){\n    vector<P> ret;\n    if(dis(c.p,s)>=c.r+EPS) return ret;\n    auto p=crossPoint(s,c);\n    if(dot(p.first-s.a,s.b-s.a)>0 && dot(p.first-s.b,s.a-s.b)>0) ret.push_back(p.first);\n    if(dot(p.second-s.a,s.b-s.a)>0 && dot(p.second-s.b,s.a-s.b)>0) ret.push_back(p.second);\n    if(xy(s.a,s.b)) sort(ret.begin(),ret.end(),xy);\n    else sort(ret.rbegin(),ret.rend(),xy);\n    return ret;\n}\n\n//共通接線の数\n//離れている:4 外接:3 交わる:2 内接:1 内包:0\ninline int intersect(const Circle &a,const Circle &b){\n    DD d=abs(a.p-b.p);\n    if(d>a.r+b.r+EPS) return 4;\n    if(eq(d,a.r+b.r)) return 3;\n    if(eq(d,abs(a.r-b.r))) return 1;\n    if(d<abs(a.r-b.r)-EPS) return 0;\n    return 2;\n}\n\n//円c1と円c2の交点\n//これを使う前に交点があるかどうかを判定する\nvector<P> crossPoint(const Circle &a,const Circle &b){\n    vector<P> ret;\n    if(abs(a.p-b.p)<a.r+b.r+EPS) return ret;\n    DD d=abs(a.p-b.p);\n    DD s=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n    DD t=arg(b.p-a.p);\n    if(eq(s,0)) ret.emplace_back(a.p+polar(a.r,t+s));\n    else ret.emplace_back(a.p+polar(a.r,t+s)),ret.emplace_back(a.p+polar(a.r,t-s));\n    return ret;\n}\n\n//pがcの外にあるかの判定が必要\nvector<P> TanLine(const P &p,const Circle &c){\n    vector<P> ret;\n    DD d=abs(p-c.p);\n    if(d<=c.r-EPS) return ret;\n    if(eq(d,c.r)){\n        ret.push_back(p);\n        return ret;\n    } \n    return crossPoint(c,Circle(p,sqrt(d*d-c.r*c.r)));\n}\n//https://ei1333.github.io/luzhiled/snippets/geometry/template.html\n//↑すごい。丸写し\n//円c1,c2の共通接線\n//接点をつないで線にしている(１個だけ追加するときに注意)\nvector<Line> TanLine(Circle a,Circle b){\n    vector<Line> ret;\n    if(a.r<b.r) swap(a,b);\n    DD g=abs(a.p-b.p);\n    if(eq(g,0)) return ret;\n    V u=(b.p-a.p)/g;\n    V v=rotate(u,PI*0.5);\n    for(DD s:{-1,1}){\n        DD h=(a.r+s*b.r)/g;\n        if(eq(1-h*h,0)){\n            ret.emplace_back(a.p+u*a.r,a.p+(u+v)*a.r);\n        }else if(1-h*h>0){\n            V uu=u*h,vv=v*sqrt(1-h*h);\n            ret.emplace_back(a.p+(uu+vv)*a.r,b.p-(uu+vv)*b.r*s);\n            ret.emplace_back(a.p+(uu-vv)*a.r,b.p-(uu-vv)*b.r*s);\n        }\n    }\n    return ret;\n}\n\n/*+++++++++++++++++++三角形+++++++++++++++++*/\n//外心\n//isParallel()を使って判定を忘れずに\nP circumcenter(const P &a,const P &b,const P &c){\n    P ab=(a+b)/2.0,bc=(b+c)/2.0;\n    Segment s(ab,ab+polar(1.0,arg(b-a)+PI*0.5));\n    Segment t(bc,bc+polar(1.0,arg(c-b)+PI*0.5));\n    return crossPoint(s,t);\n}\n\n/*+++++++++++++++++++多角形+++++++++++++++++++*/\n//IN:2 ON:1 OUT:0\n//点がどの位置にあるか\nint contains(const P &p,const Polygon &g){\n    int n=(int)g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        V a=g[i]-p,b=g[(i+1)%n]-p;\n        if(eq(cross(a,b),0) && dot(a,b)<EPS) return 1;\n        if(imag(a)>imag(b)) swap(a,b);\n        if(imag(a)<EPS && EPS<imag(b) && cross(a,b)>EPS) x=!x;\n    }\n    return (x?2:0);\n}\n//凸性判定\nbool isConvex(const Polygon &g){\n    int n=(int)g.size();\n    int flag=0;\n    int t;\n    for(int i=0;i<n;i++){\n        V a(g[(i+1)%n]-g[i]),b(g[(i+2)%n]-g[i]);\n        if(cross(a,b)>EPS) t=1;\n        else if(cross(a,b)<-EPS) t=-1;\n        else continue;\n        if(flag==-t) return false;\n        flag=t;\n    }\n    return true;\n}\n\n//凸包　アンドリューのアルゴリズム\n//https://github.com/drken1215/algorithm/blob/master/Geometry/All.cpp←螺旋本より早そう\n//j=1:返上の点を含まない　j=-1:含む\n//反時計回りの多角形を返す\n//sはソートされる\nPolygon ConvexHull(Polygon &s,const int j){\n    int sz=(int)s.size();\n    if(sz<3) return s;\n    sort(s.begin(),s.end(),yx);\n\n    int n=0;\n    Polygon res(2*sz);\n    for(int i=0;i<sz;i++){\n        while(n>=2 && cross(res[n-1]-res[n-2],s[i]-res[n-2])<EPS*j){\n            n--;\n        }\n        res[n]=s[i];\n        n++;\n    }\n    int t=n+1;\n    for(int i=sz-2;i>=0;i--){\n        while(n>=t && cross(res[n-1]-res[n-2],s[i]-res[n-2])<EPS*j){\n            n--;\n        }\n        res[n]=s[i];\n        n++;\n    }\n    res.resize(n-1);\n    return res;\n}\n\n//符号付き面積\n//反時計回りの図形なら正\n//https://imagingsolution.net/math/calc_n_point_area/\nDD Area(const Polygon &g){\n    DD ret=0.0;\n    int n=(int)g.size();\n    for(int i=0;i<n;i++){\n        ret+=cross(g[i],g[(i+1)%n]);\n    }\n    return ret/2.0L;\n}\n\n//反時計回り\n//理解が浅い←大体分かった（本当か？）\nDD Diameter(Polygon g){\n    g=ConvexHull(g,1);\n    int gz=g.size();\n    int m=0,M=0;\n    for(int i=1;i<gz;i++){\n        if(imag(g[i])<imag(g[m])) m=i;\n        if(imag(g[i])>imag(g[M])) M=i;\n    }\n    DD ret=0;\n    int sm=m,sM=M;\n    while(m!=sM || M!=sm){\n        ret=max(ret,norm(g[m]-g[M]));\n        if(cross(g[(m+1)%gz]-g[m],g[(M+1)%gz]-g[M])<0) m=(m+1)%gz;\n        else M=(M+1)%gz;\n    }\n    return sqrt(ret);\n}\n\n//凸多角形gをlで切断\n//l.p1-l.p2の左側\n//gは反時計回り→反時計回りで返す\n//時計回り→時計回り\nPolygon ConvexCut(const Polygon &g,const Line &l){\n    Polygon ret;\n    int gz=(int)g.size();\n    for(int i=0;i<gz;i++){\n        P now=g[i],next=g[(i+1)%gz];\n        if(ccw(l.a,l.b,now)>=0) ret.push_back(now);\n        if(ccw(l.a,l.b,now)*ccw(l.a,l.b,next)<0){\n            ret.push_back(crossPoint(Line(now,next),l));\n        }\n    }\n    return ret;\n}\n\ninline DD calc(const P &a,const P &b,const DD &r,const bool triangle){\n    if(triangle) return cross(a,b);\n    else return r*r*arg(b-a);\n}\n\nDD calcArea(const DD &r,const P &a,const P &b){\n    if(eq(abs(a-b),0)) return 0;\n    bool ina=abs(a)<r+EPS;\n    bool inb=abs(b)<r+EPS;\n    if(ina && inb) return cross(a,b);\n    auto cr=crossPointSC(Segment(a,b),Circle((0,0),r));\n    if(cr.empty()) return calc(a,b,r,false);\n    auto s=cr[0],t=cr.back();\n    return calc(s,t,r,true)+calc(a,s,r,ina)+calc(t,b,r,inb);\n}\n\n//円と多角形の共通部分の面積\n//http://drken1215.hatenablog.com/entry/2020/02/02/091000\nDD Area(const Circle &c,const Polygon &g){\n    DD ret=0.0;\n    int gz=g.size();\n    if(gz<3) return ret;\n    for(int i=0;i<gz;i++){\n        P a=g[i]-c.p,b=g[(i+1)%gz]-c.p;\n        ret+=calcArea(c.r,g[i]-c.p,g[(i+1)%gz]-c.p);\n    }\n    return ret/2.0;\n}\n\n//++++なんか凄いの+++++++++++++++\n\n//最近点対\nDD RecClosetPair(Polygon::iterator it,const int n){\n    if(n<=1) return INF;\n    int m=n/2;\n    DD x=real(it[m]);\n    DD d=min(RecClosetPair(it,m),RecClosetPair(it+m,n-m));\n    inplace_merge(it,it+m,it+n,yx);\n    Polygon v;\n    for(int i=0;i<n;i++){\n        if(abs(real(it[i])-x)>=d) continue;\n        for(int j=0;j<v.size();j++){\n            DD dy=imag(it[i])-imag(v[v.size()-1-j]);\n            if(dy>=d) break;\n            DD dx=real(it[i])-real(v[v.size()-1-j]);\n            d=min(d,sqrt(dx*dx+dy*dy));\n        }\n        v.push_back(it[i]);\n    }\n    return d;\n}\n\nDD ClosetPair(Polygon g){\n    sort(g.begin(),g.end(),xy);\n    return RecClosetPair(g.begin(),g.size());\n}\n\n\n\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(10);\n\n    int n;\n    cin>>n;\n    Polygon g;\n    for(int i=0;i<n;i++){\n        DD x,y;\n        cin>>x>>y;\n        g.emplace_back(x,y);\n    }\n    printf(\"%.10lf\\n\",ClosetPair(g));\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define numa(x,a) for(auto x: a)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define pf push_front\n#define sec second\n#define sz(x) ((int)(x).size())\n#define ALL( c ) (c).begin(), (c).end()\n#define gcd(a,b) __gcd(a,b)\n#define mem(x,n) memset(x,n,sizeof(x))\n#define endl \"\\n\"\nusing namespace std;\ntemplate <int POS, class TUPLE> void deploy(std::ostream &os, const TUPLE &tuple){}\ntemplate <int POS, class TUPLE, class H, class ...Ts> void deploy(std::ostream &os, const TUPLE &t){ os << (POS == 0 ? \"\" : \", \") << get<POS>(t); deploy<POS + 1, TUPLE, Ts...>(os, t); }\ntemplate <class T,class U> std::ostream& operator<<(std::ostream &os, std::pair<T,U> &p){ os << \"(\" << p.first <<\", \" << p.second <<\")\";return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::vector<T> &v){ int remain = v.size(); os << \"{\"; for(auto e: v) os << e << (--remain == 0 ? \"}\" : \", \"); return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::set<T> &v){ int remain = v.size(); os << \"{\"; for(auto e: v) os << e << (--remain == 0 ? \"}\" : \", \"); return os; }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::map<T, K> &mp){ int remain = mp.size(); os << \"{\"; for(auto e: mp) os << \"(\" << e.first << \" -> \" << e.second << \")\" << (--remain == 0 ? \"}\" : \", \"); return os; }\n#define DEBUG1(var0) { std::cerr << (#var0) << \"=\" << (var0) << endl; }\n#define DEBUG2(var0, var1) { std::cerr << (#var0) << \"=\" << (var0) << \", \";DEBUG1(var1); }\n#define DEBUG3(var0, var1, var2) { std::cerr << (#var0) << \"=\" << (var0) << \", \";DEBUG2(var1,var2); }\n#define DEBUG4(var0, var1, var2, var3) { std::cerr << (#var0) << \"=\" << (var0) << \", \";DEBUG3(var1,var2,var3); }\nusing ll = long long;\n\ntypedef struct P{\n  long double x;\n  long double y;\n}P_t;\n\ninline long double dist(const P_t &a, const P_t &b) {\n  return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\npair <pair <int, int>, long double> closest_pair(const vector <int> &xi, const vector <int> &yi, const vector <P_t> &ps){//note that xi and yi must be sorted by x and y, respectively\n  assert(xi.size() == yi.size());\n  if (xi.size() == 1) {\n    return make_pair(mp(-1,-1), -1);\n  }\n  if (xi.size() == 2) {\n    return make_pair(mp(xi[0], xi[1]), dist(ps[xi[0]], ps[xi[1]]));\n  }\n\n  int med = xi.size() / 2;\n  vector <int> lxi(xi.begin(), xi.begin() + med);\n  vector <int> lyi(yi.begin(), yi.begin() + med);\n  vector <int> rxi(xi.begin() + med, xi.end());\n  vector <int> ryi(yi.begin() + med, yi.end());\n  //DEBUG4(lxi, lyi, rxi, ryi);\n  pair <pair <int, int>, long double> ansl = closest_pair(lxi, lyi, ps);\n  pair <pair <int, int>, long double> ansr = closest_pair(rxi, ryi, ps);\n  long double dl = ansl.second;\n  long double dr = ansr.second;\n  long double d;\n  pair <int,int> ansp;\n  if (dl > 0 && dl < dr) {\n    d = dl;\n    ansp = ansl.first;\n  }else{\n    d = dr;\n    ansp = ansr.first;\n  }\n  long double medx = (ps[lxi.back()].x + ps[rxi.front()].x) / 2.0;\n  vector <int> cands;\n  for (int i: yi) {\n    if (medx - 2 * d <= ps[i].x && ps[i].x <= medx + 2 * d) {\n      cands.push_back(i);\n    }\n  }\n  for (int i = 0; i < cands.size(); i++) {\n    for (int j = i + 1; j < cands.size(); j++) {\n      if (ps[cands[j]].y - ps[cands[i]].y > 2 * d) {\n        break;\n      }\n      long double d2 = dist(ps[cands[j]], ps[cands[i]]);\n      if (d2 < d) {\n        ansp = make_pair(cands[j], cands[i]);\n        d = d2;\n      }\n    }\n  }\n  return make_pair(ansp, d);\n}\n\nint main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  int N;\n  cin >> N;\n  std::vector <P_t> ps(N);\n  std::vector <pair <long double, int> > xi_(N);\n  std::vector <pair <long double, int> > yi_(N);\n  for (int i = 0; i < N; i++) {\n    cin >> ps[i].x >> ps[i].y;\n    xi_[i].first = ps[i].x;\n    xi_[i].second = i;\n    yi_[i].first = ps[i].y;\n    yi_[i].second = i;\n  }\n  sort(xi_.begin(), xi_.end());\n  sort(yi_.begin(), yi_.end());\n  std::vector <int> xi(N);\n  std::vector <int> yi(N);\n  for (int i = 0; i < N; i++) {\n    xi[i] = xi_[i].second;\n    yi[i] = yi_[i].second;\n  }\n  pair <pair <int, int> , long double> ans = closest_pair(xi, yi, ps);\n  /*\n  if (ans.first.first > ans.first.second) {\n    cout << ans.first.second << ' ' << ans.first.first << ' ';\n  }else{\n    cout << ans.first.first << ' ' << ans.first.second << ' ';\n  }\n  */\n  cout << fixed << setprecision(10)<< ans.second << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\ntypedef double number;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<number> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\ntypedef vector<P> G;\n\nnumber closestPair(G &p) {\n  int n = p.size(), s = 0, t = 1, m = 2, S[n]; S[0] = 0, S[1] = 1;\n  sort(ALL(p)); // \"p < q\" <=> \"p.x < q.x\"\n  double d = norm(p[s]-p[t]);\n  for (int i = 2; i < n; S[m++] = i++) REP(j, m) {\n    if (norm(p[S[j]]-p[i])<d) d = norm(p[s = S[j]]-p[t = i]);\n    if (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n  }\n  return abs(p[s]-p[t]);//make_pair( p[s], p[t] );\n}\n\nint main(){\n\tG poly;\n\tP p;\n\tint n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);n--;poly.push_back(p))scanf(\"%lf%lf\",&x,&y),p=P(x,y);\n\tprintf(\"%.9f\\n\",closestPair(poly));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n\nusing ld = long double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ntemplate<class iter>\ntuple<ld, P, P> closest_pair(iter left, iter right) {\n    int n = distance(left, right);\n    if(n <= 1) return make_tuple(numeric_limits<ld>::max(), *left, *left);\n    iter middle = next(left, n/2);\n    ld x = middle->real();\n    auto d = min(closest_pair(left, middle), closest_pair(middle, right));\n    inplace_merge(left, middle, right, [](const P &a, const P &b){\n            return a.imag() < b.imag();\n        });\n    vector<iter> around;\n    for(iter i = left; i != right; ++i){\n        ld dx = fabs(i->real() - x);\n        ld &opt = get<0>(d);\n        if(dx*dx >= opt) continue;\n        for(auto j = around.rbegin(); j != around.rend(); ++j){\n            ld dx = i->real() - (**j).real();\n            ld dy = i->imag() - (**j).imag();\n            if(dy*dy >= opt) break;\n            ld norm = dx*dx + dy*dy;\n            if(get<0>(d) > norm){\n                d = make_tuple(norm, *i, **j);\n            }\n        }\n        around.push_back(i);\n    }\n    return d;\n};\n\n// http://www.spoj.com/problems/CLOPPAIR/\n// 18124516\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout << fixed << setprecision(6) << endl;\n    int n;\n    cin >> n;\n    vector<P> a;\n    map<P,int> idx;\n    rep(i,n){\n        ld x,y;\n        cin >> x >> y;\n        a.emplace_back(x,y);\n        idx[P(x,y)] = i;\n    }\n    ll z;\n    P x, y;\n    sort(all(a));\n    tie(z, x, y) = closest_pair(all(a));\n    int A = idx[x], B = idx[y];\n    if(A > B) swap(A, B);\n    cout << sqrt(z) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 200000\npair<long double, long double>pa[MAX_N];\nlong double dist(long double ax, long double ay, long double bx, long double by) { \n\treturn sqrt((ax - bx)*(ax - bx) + (ay - by)*(ay - by));\n}\nint main() {\n\tint N; cin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> pa[i].first >> pa[i].second;\n\t}\n\tsort(pa, pa + N);\n\tlong double maxn = 100000;\n\tlong double G = 200 / (sqrt(N) - 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tint L = pa[i].first - G, R = pa[i].first + G;\n\t\tint pos1 = lower_bound(pa, pa + N, make_pair(L, -1000)) - pa;\n\t\tint pos2 = lower_bound(pa, pa + N, make_pair(R, 1000)) - pa;\n\t\tfor (int j = pos1; j < pos2; j++) {\n\t\t\tif (i == j) { continue; }\n\t\t\tmaxn = min(maxn, dist(pa[i].first, pa[i].second, pa[j].first, pa[j].second));\n\t\t}\n\t}\n\tcout << fixed << setprecision(5141919) << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\n\nint main(){\n\tint n;\n\tdouble *x,*y;\n\tdouble min = 80000;\n\tdouble mdx = 200,mdy = 200;\n\tdouble dx,dy,l;\n\tint i,j;\n\t\n\tcin>>n;\n\tx = new double[n];\n\ty = new double[n];\n\tfor(int i=0;i<n;++i){\n\t\tcin>>x[i]>>y[i];\n\t}\n\t\n\tfor(i=n-1;i+1;--i){\n\t\tfor(j=i-1;j+1;--j){\n\t\t\tdx = x[i]-x[j],dy = y[i]-y[j];\n\t\t\tl = dx*dx+dy*dy;\n\t\t\tif(l<min)min=l;\n\t\t}\n\t}\n\t\n\tcout<<fixed<<setprecision(6)<<sqrt(min)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n\nusing ld = long double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ntemplate<class iter>\ntuple<ld, P, P> closest_pair(iter left, iter right) {\n    int n = distance(left, right);\n    if(n <= 1) return make_tuple(numeric_limits<ld>::max(), *left, *left);\n    iter middle = next(left, n/2);\n    ld x = middle->real();\n    auto d = min(closest_pair(left, middle), closest_pair(middle, right));\n    inplace_merge(left, middle, right, [](const P &a, const P &b){\n            return a.imag() < b.imag();\n        });\n    vector<iter> around;\n    for(iter i = left; i != right; ++i){\n        ld dx = fabs(i->real() - x);\n        ld &opt = get<0>(d);\n        if(dx*dx >= opt) continue;\n        for(auto j = around.rbegin(); j != around.rend(); ++j){\n            ld dx = i->real() - (**j).real();\n            ld dy = i->imag() - (**j).imag();\n            if(dy*dy >= opt) break;\n            ld norm = dx*dx + dy*dy;\n            if(get<0>(d) > norm){\n                d = make_tuple(norm, *i, **j);\n            }\n        }\n        around.push_back(i);\n    }\n    return d;\n};\n\n// http://www.spoj.com/problems/CLOPPAIR/\n// 18124516\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout << fixed << setprecision(6) << endl;\n    int n;\n    cin >> n;\n    vector<P> a;\n    rep(i,n){\n        ld x,y;\n        cin >> x >> y;\n        a.emplace_back(x,y);\n    }\n    ld z;\n    P x, y;\n    sort(all(a));\n    tie(z, x, y) = closest_pair(all(a));\n    cout << sqrt(z) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\n\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n\n    two_dimensional_qsort(p_xy, n0, n-1, 1);\n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        //cout<<\"qaaa\";\n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct node{\n  int dim;\n  vector<double>v;\n};\n \ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n \ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nmap<vector<int> ,vector<int> >grid;\n\nvector<int> neighborhood(vector<int> v, int dim, vector<int>res){\n\n  if(dim==v.size()){\n    bool fg = true;\n    for(int i=0;i<dim;i++)fg&=(res[i]==v[i]);\n    if(fg || !grid.count(res))return vector<int>();\n    return grid[res];\n  }\n  vector<int> result;\n  for(int i=-1;i<2;i++){\n    res.push_back(v[dim]+i);\n    vector<int>tmp = neighborhood(v,dim+1,res);\n    result.insert(result.end(),tmp.begin(),tmp.end());\n    res.pop_back();\n  }\n  return result;\n}\n\nvector<node> func(vector<node> S){\n  vector<node>nextS;\n  map<vector<int>,vector<int> >::iterator it = grid.begin();\n  for(;it!=grid.end();it++){\n    vector<int>res=neighborhood((*it).first,0,vector<int>());\n    for(int j=0;j<res.size();j++)nextS.push_back(S[res[j]]);\n  }\n\n  return nextS;\n}\n\ndouble rec(vector<int> v, int dim, vector<int>res, node p, vector<node> S){\n  if(dim==v.size()){\n    if(!grid.count(res))return 1000000000;\n    double result=100000000;\n    for(int i=0;i<grid[res].size();i++)\n      if(p.v!=S[grid[res][i]].v)\n      result=min(result,d(p,S[grid[res][i]]));\n    return result;\n  }\n  double result=1000000000;\n  for(int i=-1;i<2;i++){\n    res.push_back(v[dim]+i);\n    result=min(result,rec(v,dim+1,res,p,S));\n    res.pop_back();\n  }\n  return result;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n \n  double res;\n  vector<node>tmp=S;\n\n  while(!S.empty()){\n    node p=S[rand()%S.size()];\n \n    res=d(p,S);\n    double dist=res/(4*p.dim);\n \n    grid.clear();\n    for(int i=0;i<S.size();i++){\n      vector<int> key;\n      for(int j=0;j<p.dim;j++)key.push_back((int)(S[i].v[j]/dist));\n      grid[key].push_back(i);\n    }\n   \n    S=func(S);\n  }\n\n  S=tmp;\n  double ans=100000000;\n  grid.clear();\n  for(int i=0;i<S.size();i++){\n    vector<int> key;\n    for(int j=0;j<2;j++)key.push_back((int)(S[i].v[j]/res));\n    grid[key].push_back(i);\n  }\n  \n  map<vector<int>,vector<int> >::iterator it = grid.begin();\n  for(;it!=grid.end();it++){\n    for(int j=0;j<(*it).second.size();j++){\n      ans=min(ans,rec((*it).first,0,vector<int>(),S[(*it).second[j]],S));\n    }\n  }\n\n  return ans;\n}\n \nint main(void){\n \n  int n;\n  cin >> n;\n \n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n \n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n\nusing ld = long double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ntemplate<class iter>\ntuple<ld, P, P> closest_pair(iter left, iter right) {\n    int n = distance(left, right);\n    if(n <= 1) return make_tuple(numeric_limits<ld>::max(), *left, *left);\n    iter middle = next(left, n/2);\n    ld x = middle->real();\n    auto d = min(closest_pair(left, middle), closest_pair(middle, right));\n    inplace_merge(left, middle, right, [](const P &a, const P &b){\n            return a.imag() < b.imag();\n        });\n    vector<iter> around;\n    for(iter i = left; i != right; ++i){\n        ld dx = fabs(i->real() - x);\n        ld &opt = get<0>(d);\n        if(dx*dx >= opt) continue;\n        for(auto j = around.rbegin(); j != around.rend(); ++j){\n            ld dx = i->real() - (**j).real();\n            ld dy = i->imag() - (**j).imag();\n            if(dy*dy >= opt) break;\n            ld norm = dx*dx + dy*dy;\n            if(get<0>(d) > norm){\n                d = make_tuple(norm, *i, **j);\n            }\n        }\n        around.push_back(i);\n    }\n    return d;\n};\n\n// http://www.spoj.com/problems/CLOPPAIR/\n// 18124516\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout << fixed << setprecision(6) << endl;\n    int n;\n    cin >> n;\n    vector<P> a;\n    map<P,int> idx;\n    rep(i,n){\n        ld x,y;\n        cin >> x >> y;\n        a.emplace_back(x,y);\n        idx[P(x,y)] = i;\n    }\n    ld z;\n    P x, y;\n    sort(all(a));\n    tie(z, x, y) = closest_pair(all(a));\n    int A = idx[x], B = idx[y];\n    if(A > B) swap(A, B);\n    cout << sqrt(z) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(ll i = 0; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\nconst ll mod = TEN(9) + 7;\n\ntemplate<class T>\ndouble closest_pair(vector<pair<T, T>> a, double inf = 1e15) {\n\tusing P = pair<T, T>;\n\tusing Iterator = typename vector<P>::iterator;\n\tfunction<double(Iterator, ll)> recur = [&](Iterator it, ll len) {\n\t\tif (len <= 1) return inf;\n\t\tll half = len / 2;\n\t\tT x = (it + half)->first;\n\t\tdouble min_d = min(recur(it, half), recur(it + half, len - half));\n\t\tinplace_merge(\n\t\t\tit, it + half, it + len,\n\t\t\t[](P lhs, P rhs) { return lhs.second < rhs.second; }\n\t\t);\n\n\t\tvector<P> b;\n\t\tREP(i, len) {\n\t\t\tif (fabs((it + i)->first - x) >= min_d) continue;\n\t\t\tREP(j, b.size()) {\n\t\t\t\tdouble dx = (it + i)->first - b[b.size() - j - 1].first;\n\t\t\t\tdouble dy = (it + i)->second - b[b.size() - j - 1].second;\n\t\t\t\tif (dy >= min_d) break;\n\t\t\t\tmin_d = min(min_d, sqrt(dx * dx + dy * dy));\n\t\t\t}\n\t\t\tb.push_back(*(it + i));\n\t\t}\n\n\t\treturn min_d;\n\t};\n\tsort(a.begin(), a.end());\n\treturn recur(a.begin(), a.size());\n}\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\n\tll n; cin >> n;\n\tvector<pair<double, double>> a(n);\n\tREP(i, n) cin >> a[i].first >> a[i].second;\n\tcout << closest_pair(a) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct point{\n  double x,y;\n  bool operator<( const point &u ) const {\n      //return x < u.y;\n      if(x != u.x) return x < u.x;\n        return y < u.y;\n  }\n};\npoint a[100000];\n\ndouble dis(point a,point b){\n  return sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));\n}\n\ndouble merge(int left,int right){\n  if(left+1 == right) return dis(a[left],a[right]);\n  int mid = (left+right)/2;\n  double xm = min(merge(left,mid),merge(mid,right));\n\n  vector<point> vec;\n  for(int i = left; i <= right; i++){\n    if(abs(a[mid].x-a[i].x) <= xm){\n      vec.push_back({a[i].y,a[i].x});\n    }\n  }\n  sort(vec.begin(),vec.end());\n  for(int i = 0; i < vec.size(); i++){\n    for(int j = i+1; j < vec.size(); j++){\n      if(vec[j].x-vec[i].x > xm) break;\n      xm = min(xm,dis(vec[i],vec[j]));\n    }\n  }\n  return xm;\n}\n\nsigned main(){\n\n  int n; cin >> n;\n  for(int i = 0; i < n; i++){\n    cin >> a[i].x >> a[i].y;\n  }\n\n  sort(a,a+n);\n  printf(\"%.10f\\n\",(merge(0,n-1)));\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nbool pariCompare (const P& FElof, const P& SElof) {\n    if (FElof.first == SElof.first) return FElof.second < SElof.second;\n    return FElof.first < SElof.first;\n}\n\nint main ()\n{\n    int n;\n    cin >> n;\n    vector<P> p(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i].first >> p[i].second;\n    }\n\n    sort(p.begin(), p.end(), pariCompare);\n\n    double dis = 100000000000.0;\n    for (int i = 0; i < n-1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double tmp = pow(p[i].first - p[j].first, 2.0) + pow(p[i].second - p[j].second, 2.0);\n            dis = min(dis, tmp);\n        }\n    }\n\n    cout << printf(\"%.6f\\n\", sqrt(dis)) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\n/*struct P\n{\n\tdouble x, y;\n\tP(double x,double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};*/\n\n/*int ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}*/\n\ndouble dist(pdd a, pdd b)\n{\n\treturn (a.first - b.first)*(a.first - b.first) + (a.second - b.second)*(a.second - b.second);\n}\n\ndouble ClosestPair(vector<pdd>& points,int l,int r)\n{\n\tif (r - l == 1)\n\t{\n\t\treturn INF;\n\t}\n\tif (r - l == 2)\n\t{\n\t\treturn dist(points[l], points[l + 1]);\n\t}\n\tif (r - l == 3)\n\t{\n\t\treturn min(min(dist(points[l], points[l + 1]), dist(points[l], points[l + 2])), dist(points[l + 1], points[l + 2]));\n\t}\n\n\tint m = (l + r) / 2;\n\tdouble d = min(ClosestPair(points, l, m), ClosestPair(points, m, r));\n\n\tvector<pdd> tempP;\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tif ((points[l].first - points[m].first)*(points[l].first - points[m].first) < d)\n\t\t{\n\t\t\ttempP.emplace_back(make_pair(points[i].second, points[i].first));\n\t\t}\n\t}\n\tsort(tempP.begin(), tempP.end());\n\tfor (int i = 0; i != tempP.size(); i++)\n\t{\n\t\tfor (int j = i + 1; j != tempP.size(); j++)\n\t\t{\n\t\t\tif ((tempP[j].first - tempP[i].first)*(tempP[j].first - tempP[i].first) > d)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, dist(tempP[i], tempP[j]));\n\t\t}\n\t}\n\n\treturn d;\n}\n\nvector<pdd> points;\n\nint main()\n{\n\tpoints.reserve(100000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpoints.push_back(make_pair(x, y));\n\t}\n\n\tsort(points.begin(), points.end());\n\n\tprintf(\"%lf\\n\", sqrt(ClosestPair(points, 0, n)));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\ntemplate <i64 p>\nclass fp {\npublic:\n    i64 x;\n    fp() : x(0) {}\n    fp(i64 x_) : x((x_ % p + p) % p) {}\n    fp operator+() const { return fp(x); }\n    fp operator-() const { return fp(-x); }\n    fp& operator+=(const fp& y) {\n        x += y.x;\n        if (x >= p) x -= p;\n        return *this;\n    }\n    fp& operator-=(const fp& y) { return *this += -y; }\n    fp& operator*=(const fp& y) {\n        x = x * y.x % p;\n        return *this;\n    }\n    fp& operator/=(const fp& y) { return *this *= fp(inverse(y.x)); }\n    fp operator+(const fp& y) const { return fp(x) += y; }\n    fp operator-(const fp& y) const { return fp(x) -= y; }\n    fp operator*(const fp& y) const { return fp(x) *= y; }\n    fp operator/(const fp& y) const { return fp(x) /= y; }\n    bool operator==(const fp& y) const { return x == y.x; }\n    bool operator!=(const fp& y) const { return !(*this == y); }\n    i64 extgcd(i64 a, i64 b, i64& x, i64& y) {\n        i64 d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    i64 inverse(i64 a) {\n        i64 x, y;\n        extgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n};\n\ntemplate <i64 p>\ni64 abs(const fp<p>& x) { return x.x; }\n\ntemplate <i64 p>\nistream& operator>>(istream& is, fp<p>& x) {\n    is >> x.x;\n    return is;\n}\n\ntemplate <i64 p>\nostream& operator<<(ostream& os, const fp<p>& x) {\n    os << x.x;\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    os << \"[\";\n    for (const auto& v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename A, typename T, size_t size>\nvoid fill(A (&ary)[size], const T& val) {\n    fill((T*)ary, (T*)(ary + size), val);\n}\n\n// x未満の要素の個数を返す\ntemplate <typename T>\ni64 count_less(const vector<T>& v, T x) {\n    return lower_bound(begin(v), end(v), x) - begin(v);\n}\n\n// x以下の要素の個数を返す\ntemplate <typename T>\ni64 count_less_or_equal(const vector<T>& v, T x) {\n    return upper_bound(begin(v), end(v), x) - begin(v);\n}\n\n// xより大きい要素の個数を返す\ntemplate <typename T>\ni64 count_greater(const vector<T>& v, T x) {\n    return end(v) - upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素の個数を返す\ntemplate <typename T>\ni64 count_greater_or_equal(const vector<T>& v, T x) {\n    return end(v) - lower_bound(begin(v), end(v), x);\n}\n\n// x未満の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less(const vector<T>& v, T x) {\n    return *(lower_bound(begin(v), end(v), x) - 1);\n}\n\n// x以下の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less_or_equal(const vector<T>& v, T x) {\n    return *(upper_bound(begin(v), end(v), x) - 1);\n}\n\n// xより大きい要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater(const vector<T>& v, T x) {\n    return *upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater_or_equal(const vector<T>& v, T x) {\n    return *lower_bound(begin(v), end(v), x);\n}\n\nconstexpr int inf = 1.01e9;\nconstexpr i64 inf64 = 4.01e18;\nconstexpr long double eps = 1e-9;\n\n// 実数値のn分探索のループ回数の上限(2分探索なら50でも十分かもしれない)\nconstexpr i64 max_loop = 100;\n\nlong double tolerance(const long double& a, const long double& b, const long double& epsilon = eps) {\n    return epsilon * max({1.l, abs(a), abs(b)});\n}\n\n// a<0なら-1, a==0なら0, a>0なら1\nint sgn(const long double a, const long double& epsilon = eps) {\n    return (a > epsilon) - (a < -epsilon);\n}\n\n// a<bなら-1, a==bなら0, a>bなら1\nint compare(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return sgn(a - b, is_relative ? tolerance(a, b, epsilon) : epsilon);\n}\n\n// a==bか?\nbool is_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == 0;\n}\n\n// a<bか?\nbool is_less(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == -1;\n}\n\n// a<=bか?\nbool is_less_or_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) <= 0;\n}\n\n// a>bか?\nbool is_greater(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == 1;\n}\n\n// a>=bか?\nbool is_greater_or_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) >= 0;\n}\n\ntemplate <int D, class point /* =  array<long double,2>*/>\nstruct kd_tree {\n    point p;\n    int axis;\n    kd_tree<D, point>*left, *right;\n    kd_tree(int axis_ = 0) : left(NULL), right(NULL), axis(axis_){};\n    kd_tree(vector<point> points, int axis_ = 0) : left(NULL), right(NULL), axis(axis_) {\n        assert(points.size());\n        build(points, 0, points.size());\n    }\n    ~kd_tree() {\n        delete left;\n        delete right;\n    }\n    kd_tree<D, point>* build(vector<point>& points, int l, int r) {\n        int m = (l + r) / 2;\n        nth_element(points.begin() + l, points.begin() + m, points.begin() + r, [&](const point& p, const point& q) { return p[axis] < q[axis]; });\n        p = points[m];\n        if (l < m) {\n            left = new kd_tree<D, point>((axis + 1) % D);\n            left->build(points, l, m);\n        }\n        if (m + 1 < r) {\n            right = new kd_tree<D, point>((axis + 1) % D);\n            right->build(points, m + 1, r);\n        }\n        return this;\n    }\n    //例えば,同じ点が大量にinsertされると右の子ばかり増えてしまう.そのようなときは適当なタイミングで全体をリビルドしたほうがよいかも.\n    kd_tree<D, point>* insert(const point& q) {\n        if (q[axis] < p[axis]) {\n            if (left == NULL) {\n                left = new kd_tree<D, point>({q}, (axis + 1) % D);\n                return left;\n            } else\n                return left->insert(q);\n        } else {\n            if (right == NULL) {\n                right = new kd_tree<D, point>({q}, (axis + 1) % D);\n                return right;\n            } else\n                return right->insert(q);\n        }\n    }\n    //未検証.多分遅い(O(n))のでerasedタグを付けて置いて,erasedが一定以上増えたら全体をbuildするようにした方が良いかも.\n    void erase(const point& q) {\n        kd_tree<D, point>* tree = nearest_neighbor(q);\n        vector<point> points = tree->collect();\n        points.erase(points.rbegin());\n        delete tree->left;\n        delete tree->right;\n        tree->build(points, 0, points.size());\n    }\n    //未検証\n    vector<point> collect() const {\n        vector<point> points;\n        if (left != NULL) {\n            vector<point> left_points = left->collect();\n            points.insert(points.end(), left_points.begin(), left_points.end());\n        }\n        if (right != NULL) {\n            vector<point> right_points = right->collect();\n            points.insert(points.end(), right_points.begin(), right_points.end());\n        }\n        points.push_back(p);\n        return points;\n    };\n    const kd_tree<D, point>* nearest_neighbor(const point& q) const {  //const外した方が良いかも\n        const kd_tree<D, point>* res = this;\n        long double mind = 1e130;\n        auto dist = [&](const point& p, const point& q) {\n            long double d = 0;\n            for (int i = 0; i < D; ++i) d += (p[i] - q[i]) * (p[i] - q[i]);\n            return d;\n        };\n        function<void(const kd_tree<D, point>*)> rec = [&](const kd_tree<D, point>* tree) {\n            auto d = dist(tree->p, q);\n            if (d < mind) {\n                mind = d;\n                res = tree;\n            }\n            if (q[tree->axis] < tree->p[tree->axis]) {\n                if (tree->left != NULL) rec(tree->left);\n                if (tree->right != NULL and tree->p[tree->axis] - q[tree->axis] <= mind) rec(tree->right);\n            } else {\n                if (tree->right != NULL) rec(tree->right);\n                if (tree->left != NULL and q[tree->axis] - tree->p[tree->axis] <= mind) rec(tree->left);\n            }\n        };\n        rec(this);\n        return res;\n    }\n    vector<point> range_search(const point& lb, const point& ub) const {\n        vector<point> res;\n        function<void(const kd_tree<D, point>*)> rec = [&](const kd_tree<D, point>* tree) {\n            bool in_range = true;\n            for (int i = 0; i < D; ++i)\n                if (tree->p[i] < lb[i] or ub[i] < tree->p[i]) {\n                    in_range = false;\n                    break;\n                }\n            if (in_range) res.push_back(tree->p);\n            if (tree->left != NULL and lb[tree->axis] <= tree->p[tree->axis]) rec(tree->left);\n            if (tree->right != NULL and ub[tree->axis] >= tree->p[tree->axis]) rec(tree->right);\n        };\n        rec(this);\n        return res;\n    }\n};\n\nusing point=array<long double,2>;\n\ntuple<long double, point, point> search_closest_pair(const vector<point>& ps){\n    kd_tree<2,point> kt({ps[0]});\n    tuple<long double, point, point> res{inf64, point{}, point{}};\n    rep(i,1,ps.size()){\n        const auto p=kt.nearest_neighbor(ps[i])->p;\n        const auto dx=ps[i][0]-p[0],dy=ps[i][1]-p[1];\n        const auto d=sqrtl(dx*dx+dy*dy);\n\n        if(d<get<0>(res)){\n            res=make_tuple(d,ps[i],p);\n        }\n\n        kt.insert(ps[i]);\n    }\n    return res;\n}\n\nvoid solve() {\n    //constexpr i64 mod = 1'000'000'007;\n\n    i64 n;\n    cin >> n;\n    vector<long double> x(n),y(n);\n    rep(i,0,n){\n        cin >> x[i] >> y[i];\n    }\n\n    vector<point> ps(n);\n    rep(i,0,n){\n        ps[i]={x[i],y[i]};\n    }\n\n    cout << get<0>(search_closest_pair(ps)) << endl;\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b) {\n\treturn std::hypot(b.first - a.first, b.second - a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points) {\n\tif (points.size() < 2) {\n\t\treturn -1;\n\t}\n\tauto minDistance = std::abs(distance_between(points.at(0), points.at(1)));\n\tfor (auto i = std::begin(points); i != (std::end(points) - 1); ++i) {\n\t\tfor (auto j = i + 1; j < std::end(points); ++j) {\n\t\t\tauto newDistance = std::abs(distance_between(*i, *j));\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(const std::vector<point_t>& xP,\n\tconst std::vector<point_t>& yP) {\n\tif (xP.size() <= 3) {\n\t\treturn find_closest_brute(xP);\n\t}\n\tauto N = xP.size();\n\tauto xL = std::vector<point_t>();\n\tauto xR = std::vector<point_t>();\n\tstd::copy(std::begin(xP), std::begin(xP) + (N / 2), std::back_inserter(xL));\n\tstd::copy(std::begin(xP) + (N / 2), std::end(xP), std::back_inserter(xR));\n\tauto xM = xP.at(N / 2).first;\n\tauto yL = std::vector<point_t>();\n\tauto yR = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {\n\t\treturn p.first <= xM;\n\t});\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {\n\t\treturn p.first > xM;\n\t});\n\tauto p1 = find_closest_optimized(xL, yL);\n\tauto p2 = find_closest_optimized(xR, yR);\n\tauto minD = (p1 <= p2) ? p1 : p2;\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = std::abs(distance_between(*k, *i));\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP, yP);\n\tprintf(\"%.9f\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<double,double> pp;\nvector<pp> a;\n\n#define sqr(x) ((x)*(x))\ndouble Plus (double x){\n\treturn x<0?-x:x;\n}\ndouble dist (pp x, pp y){\n\treturn sqr(x.first-y.first) + sqr(x.second-y.second);\n}\n\ndouble go (int l, int r)\n{\n\tif (r-l==1)\n\t\treturn dist(a[l],a[r]);\n\tif (r-l==2)\n\t\treturn min(dist(a[l],a[l+1]), min(dist(a[l],a[l+2]), dist(a[l+1],a[l+2])));\n\n\tint m=(l+r)/2;\n\tdouble d=min(go(l,m),go(m+1,r));\n\n\tvector<pp> v;\n\tfor (auto i=l;i<=r;i++)\n\t\tif (sqr(a[i].first-a[m].first)<d)\n\t\t\tv.emplace_back (a[i].second,a[i].first);\n\tsort (v.begin(),v.end());\n\tfor (auto i=v.begin();i!=v.end();i++)\n\t\tfor (auto j=i+1;j!=v.end();j++)\n\t\t{\n\t\t\td=min(d,dist(*i,*j));\n\t\t}\n\treturn d;\n}\n\nint main ()\n{\n\tint i,n;\n\tdouble x,y;\n\tscanf (\"%d\",&n);\n\tfor (i=0;i<n;i++)\n\t\tscanf (\"%lf%lf\",&x,&y), a.emplace_back(x,y);\n\tsort (a.begin(),a.end());\n\tprintf (\"%lf \",sqrt(go(0,n-1)));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\ntemplate<int D,class point> struct kd_tree{\n    point p;\n    int axis;\n    kd_tree<D,point>* left,*right;\n    kd_tree(int axis_=0):left(NULL),right(NULL),axis(axis_){};\n    kd_tree(vector<point> points,int axis_=0):left(NULL),right(NULL),axis(axis_){ assert(points.size()); build(points,0,points.size()); }\n    ~kd_tree(){ delete left; delete right; }\n    kd_tree<D,point>* build(vector<point> &points,int l,int r){\n        int m=(l+r)/2;\n        nth_element(points.begin()+l,points.begin()+m,points.begin()+r,[&](const point& p,const point& q){ return p[axis]<q[axis]; });\n        p=points[m];\n        if(l<m){\n            left=new kd_tree<D,point>((axis+1)%D);\n            left->build(points,l,m);\n        }\n        if(m+1<r){\n            right=new kd_tree<D,point>((axis+1)%D);\n            right->build(points,m+1,r);\n        }\n        return this;\n    }\n    kd_tree<D,point>* insert(const point& q){\n        if(q[axis]<p[axis]){\n            if(left==NULL){\n                left=new kd_tree<D,point>({q},(axis+1)%D);\n                return left;\n            }else return left->insert(q);\n        }else{\n            if(right==NULL){\n                right=new kd_tree<D,point>({q},(axis+1)%D);\n                return right;\n            }else return right->insert(q);\n        }\n    }\n    //????????????(O(n))?????§erased?????°?????????????????????,erased???????????\\????¢????????????¨??????build???????????????????????????????????????.\n    void erase(const point& q){\n        kd_tree<D,point>* tree=nearest_neighbor(q);\n        vector<point> points=tree->collect();\n        points.erase(points.rbegin());\n        delete tree->left;\n        delete tree->right;\n        tree->build(points,0,points.size());\n    }\n    vector<point> collect()const{\n        vector<point> points;\n        if(left!=NULL){\n            vector<point> left_points=left->collect();\n            points.insert(points.end(),left_points.begin(),left_points.end());\n        }\n        if(right!=NULL){\n            vector<point> right_points=right->collect();\n            points.insert(points.end(),right_points.begin(),right_points.end());\n        }\n        points.push_back(p);\n        return points;\n    };\n    const kd_tree<D,point>* nearest_neighbor(const point& q)const{ //const???????????????????????????\n        const kd_tree<D,point>* res=this;\n        long double mind=inf64;\n        auto dist=[&](const point& p,const point& q){\n            long double d=0;\n            for(int i=0; i<D; ++i) d+=(p[i]-q[i])*(p[i]-q[i]);\n            return d;\n        };\n        function<void(const kd_tree<D,point>*)> rec=[&](const kd_tree<D,point>* tree){\n            auto d=dist(tree->p,q);\n            if(d<mind){\n                mind=d;\n                res=tree;\n            }\n            if(q[tree->axis]<tree->p[tree->axis]){\n                if(tree->left!=NULL) rec(tree->left);\n                if(tree->right!=NULL and tree->p[tree->axis]-q[tree->axis]<=mind) rec(tree->right);\n            }else{\n                if(tree->right!=NULL) rec(tree->right);\n                if(tree->left!=NULL and q[tree->axis]-tree->p[tree->axis]<=mind) rec(tree->left);\n            }\n        };\n        rec(this);\n        return res;\n    }\n    vector<point> range_search(const point& lb,const point& ub)const{\n        vector<point> res;\n        function<void(const kd_tree<D,point>*)> rec=[&](const kd_tree<D,point>* tree){\n            bool in_range=true;\n            for(int i=0; i<D; ++i) if(tree->p[i]<lb[i] or ub[i]<tree->p[i]){\n                in_range=false;\n                break;\n            }\n            if(in_range) res.push_back(tree->p);\n            if(tree->left!=NULL and lb[tree->axis]<=tree->p[tree->axis]) rec(tree->left);\n            if(tree->right!=NULL and ub[tree->axis]>=tree->p[tree->axis]) rec(tree->right);\n        };\n        rec(this);\n        return res;\n    }\n};\n\nvoid solve(){\n    int n;\n    cin >> n;\n\n    using point=vector<long double>;\n    vector<point> ps;\n    rep(i,0,n){\n        long double x,y;\n        cin >> x >> y;\n        ps.push_back(point({x,y}));\n    }\n\n    kd_tree<2,point> kt({ps[0]});\n    long double ans=inf64;\n    rep(i,1,n){\n        point p=kt.nearest_neighbor(ps[i])->p;\n        ans=min(ans,sqrtl((ps[i][0]-p[0])*(ps[i][0]-p[0])+(ps[i][1]-p[1])*(ps[i][1]-p[1])));\n        kt.insert(ps[i]);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn 1e9;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP\n){\n\tint siz=xr-xl;\n\tif (siz <= 3) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tauto xM = xP[xl+siz/2].first;\n\tauto yL = std::vector<point_t>();\n\tauto yR = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {\n\t\treturn p.first <= xM;\n\t});\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {\n\t\treturn p.first > xM;\n\t});\n\tauto p1 = find_closest_optimized(xP,xl,xl+siz/2, yL);\n\tauto p2 = find_closest_optimized(xP,xl+siz/2,xr, yR);\n\tauto minD = sqrt((p1 <= p2) ? p1 : p2);\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n, yP);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief (n 2) = Θ(n^2)通りの点対を調べ、最近点対間距離を返す\n *\n * @param const point*P 点集合P\n * @param index_t n     Pの要素数\n */\nstatic elem_t brute_force_closest_pair(const point*P, index_t n)\n{\n    elem_t minimum = std::numeric_limits<elem_t>::max();\n    for (index_t i = 0; i < n; i++) {\n        for (index_t j = i + 1; j < n; j++) {\n            elem_t dist = abs(P[i] - P[j]);\n            minimum = std::min(minimum, dist);\n        }\n    }\n    return minimum;\n}\n\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {  // |P| <= 3か否かを判定する\n        return std::numeric_limits<elem_t>::max();\n        //return brute_force_closest_pair(P, n);  // |P| <= 3ならば、虱潰で問題を解く\n    }\n\n    // |P| > 3ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = std::numeric_limits<elem_t>::max();\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if (P[i].y - p.y >= delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << setprecision(500) << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\n/*\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    //two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n\n    two_dimensional_qsort(p_xy, n0, n-1, 1);\n\n    \n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n*/\nbool compare_y(pair<double, double> a,pair<double, double> b){\n    return a.second<b.second;\n}\n\ndouble length_of_the_nearest_point_to(pair<double, double> a[100000], int n){\n    if(n<=1)return 999999999.9;\n    int m=n/2;\n    double x=a[m].first;\n    double d=min(length_of_the_nearest_point_to(a, m), length_of_the_nearest_point_to(a+m, n-m));\n    inplace_merge(a, a+m, a+n, compare_y);\n    vector<pair<double, double>>b;\n    for(int i=0; i<n; i++){\n        if(fabs(a[i].first-x)>=d)continue;\n        for(int j=0; j<b.size(); j++){\n            double dx=a[i].first-b[b.size()-j-1].first;\n            double dy=a[i].second-b[b.size()-j-1].second;\n            if(dy>=d)break;\n            d=min(d,sqrt(dx*dx+dy*dy));\n            \n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n                                      \n                                      \n                                      \nint main(int argc, const char * argv[]){\n    int n;\n    while(cin>>n){\n        pair<double, double> a[100000];\n        for(int i=0; i<n; i++){\n            cin>>a[i].first>>a[i].second;\n        }\n        sort(a, a+n);\n        double ans = length_of_the_nearest_point_to(a, n);\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n    /*\n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        //cout<<\"qaaa\";\n        two_dimensional_qsort(p_xy, 0, n-1, 0);\n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n     */\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\n/*struct P\n{\n\tdouble x, y;\n\tP(double x,double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};*/\n\n/*int ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}*/\n\ndouble dist(pdd a, pdd b)\n{\n\treturn (a.first - b.first)*(a.first - b.first) + (a.second - b.second)*(a.second - b.second);\n}\n\ndouble ClosestPair(vector<pdd>& points,int l,int r)\n{\n\tif (r - l == 1)\n\t{\n\t\treturn INF;\n\t}\n\tif (r - l == 2)\n\t{\n\t\treturn dist(points[l], points[l + 1]);\n\t}\n\tif (r - l == 3)\n\t{\n\t\treturn min(min(dist(points[l], points[l + 1]), dist(points[l], points[l + 2])), dist(points[l + 1], points[l + 2]));\n\t}\n\n\tint m = (l + r) / 2;\n\tdouble d = min(ClosestPair(points, l, m), ClosestPair(points, m, r));\n\n\tvector<pdd> tempP;\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tif ((points[l].first - points[m].first)*(points[l].first - points[m].first) < d)\n\t\t{\n\t\t\ttempP.emplace_back(make_pair(points[i].second, points[i].first));\n\t\t}\n\t}\n\tsort(tempP.begin(), tempP.end());\n\tfor (int i = 0; i != tempP.size(); i++)\n\t{\n\t\tfor (int j = i + 1; j != tempP.size(); j++)\n\t\t{\n\t\t\tif ((tempP[j].first - tempP[i].first)*(tempP[j].first - tempP[i].first) > d)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, dist(tempP[i], tempP[j]));\n\t\t}\n\t}\n\n\treturn d;\n}\n\nvector<pdd> points;\n\nint main()\n{\n\tpoints.reserve(100000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tpoints.push_back(make_pair(x, y));\n\t}\n\n\tsort(points.begin(), points.end());\n\n\tprintf(\"%lf\\n\", sqrt(ClosestPair(points, 0, n)));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <climits>\nusing namespace std;\n\ntypedef pair<double, double> P;\n\ndouble getClosestPairVirtical(vector<P> &v, int s, int t){\n    double d = INT_MAX;\n    for(int i=s+1; i<t; i++){\n        d = min(d, v[i].second-v[i-1].second);\n    }\n    return d;\n}\n\nbool inRange(double v, double l, double r){\n    return l<=v && v<=l;\n}\n\nbool compare_y(P a, P b){\n    return a.second < b.second;\n}\n\ndouble getClosestPair(vector<P> &v, int s, int t){\n    if(t-s==1) return INT_MAX;\n    if(v[s].first == v[t-1].first) return getClosestPairVirtical(v, s, t);\n    const double mid = (v[s].first+v[t-1].first)/2;\n    int midPos;\n    for(midPos=s; midPos<t && v[midPos].first<mid; midPos++);\n    const double d1 = getClosestPair(v, s, midPos);\n    const double d2 = getClosestPair(v, midPos, t);\n    double d = min(d1, d2);\n    inplace_merge(v.begin()+s, v.begin()+mid, v.begin()+t, compare_y);\n    vector<P> use;\n    for(int i=s; i<t; i++){\n        if(fabs(v[i].first-mid)>d) continue;\n        for(int j=use.size()-1; j>=0; j--){\n            if(fabs(v[i].second-use[j].second)>d) break;\n            double dx = v[i].first-use[j].first;\n            double dy = v[i].second-use[j].second;\n            d = min(d, sqrt(dx*dx + dy*dy));\n        }\n        use.push_back(v[i]);\n    }\n    return d;\n}\n\nint main(){\n    int n;\n    double x, y;\n    cin >> n;\n    vector<P> v;\n    for(int i=0; i<n; i++){\n        P p;\n        cin >> p.first >> p.second;\n        v.push_back(p);\n    }\n    sort(v.begin(), v.end());\n    cout << getClosestPair(v, 0, v.size()) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct node{\n  int dim;\n  vector<double>v;\n};\n \ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n \ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n \n  vector<node>res;\n \n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n \n    double dist=d(p,S)/(4*p.dim);\n \n    map<vector<int> ,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      vector<int> key;\n      for(int j=0;j<p.dim;j++)key.push_back((int)(S[i].v[j]/dist));\n      grid[key].push_back(i);\n    }\n \n    vector<node>nextS;\n    map<vector<int>,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    if(S.size() == nextS.size())break;\n    S=nextS;    \n  }\n \n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n   \n  return ans;\n}\n \nint main(void){\n \n  int n;\n  cin >> n;\n \n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n \n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn 1e9;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP,\n\tint yl,int yr\n){\n\tint xsiz=xr-xl;\n\tint ysiz=yr-yl;\n\tif (xsiz <= 3) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tif(ysiz==0)return 1e9;\n\t//printf(\"%d %d %d %d\\n\",xl,xr,yl,yr);\n\tauto xM = xP[xl+xsiz/2].first;\n\tauto yL = std::vector<point_t>(ysiz);\n\tint left = -1, right = ysiz;\n\tfor(int i = yl; i < yr; i++){\n\t\tif (yP[i].first <= xM) yL[++left] = yP[i];\n\t\telse                  yL[--right]= yP[i];\n\t}\n\tstd::reverse(yL.begin()+right,yL.end());\n\tauto p1 = find_closest_optimized(xP,xl,xl+xsiz/2,yL,0,left+1);\n\tauto p2 = find_closest_optimized(xP,xl+xsiz/2,xr,yL,left+1,ysiz);\n\tauto minD = sqrt((p1 <= p2) ? p1 : p2);\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n,yP,0,n);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\n\nint main(){\n\tint n;\n\tdouble *x,*y;\n\tdouble min = 80000;\n\tdouble dx,dy,l;\n\tint i,j;\n\t\n\tcin>>n;\n\tx = new double[n];\n\ty = new double[n];\n\tfor(int i=0;i<n;++i){\n\t\tcin>>x[i]>>y[i];\n\t}\n\t\n\tfor(i=n-1;i>=0;--i){\n\t\tfor(j=i-1;j>=0;--j){\n\t\t\tdx = x[i]-x[j],dy = y[i]-y[j];\n\t\t\t\n\t\t\t\n\t\t\tl = dx*dx+dy*dy;\n\t\t\tif(l<min)min=l;\n\t\t\t\n\t\t}\n\t}\n\tcout<<fixed<<setprecision(6)<<sqrt(min)<<endl;\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef pair<int, int> PI;\nconst double EPS=1e-9;\n\nconst int N = 1e5 + 10;\ndouble x[N], y[N];\n\nstruct x_cmp {\n  bool operator() (int i, int j) {\n    return x[i] < x[j];\n  }\n};\nstruct y_cmp {\n  bool operator() (int i, int j) {\n    return y[i] < y[j];\n  }\n};\n\ndouble dist2(int i, int j) {\n  return pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2);\n}\n\ndouble min_brute_force(const std::vector<int> & v) {\n  double mi = 1.0 / 0.0;\n  int n = v.size();\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (i == j) {\n\tcontinue;\n      }\n      mi = min(mi, dist2(v[i], v[j]));\n    }\n  }\n  return mi;\n}\n\n\ndouble min_strip(const vector<int> &v, double d) {\n  double mi = d;\n  int n = v.size();\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n && pow(y[v[j]] - y[v[i]], 2) < mi; ++j) {\n      mi = min(mi, dist2(v[i], v[j]));\n    }\n  }\n  return mi;\n}\n\n/*\n */\ndouble min_pair_util(const vector<int> &vx) {\n  int n = vx.size();\n  if (n <= 4) {\n    return min_brute_force(vx);\n  }\n  // divide at middle\n  int mid = n / 2;\n  double mid_x = x[vx[mid]];\n  double ml = min_pair_util(vector<int>(vx.begin(), vx.begin() + mid));\n  double mr = min_pair_util(vector<int>(vx.begin() + mid, vx.end()));\n  double dist = min(ml, mr);\n  vector<int> strip;\n  for(int i = 0; i < n; ++i) {\n    if (pow(x[vx[i]] - mid_x, 2) < dist) {\n      strip.push_back(vx[i]);\n    }\n  }\n  sort(strip.begin(), strip.end(), y_cmp());\n  double res = min_strip(strip, dist);\n  return res;\n}\n\nint main(void){\n  int n;\n  cin >> n;\n  REP(i, 0, n) {\n    cin >> x[i] >> y[i];\n  }\n  double mi = 1e10;\n  vector<int> v(n);\n  REP(i, 0, n) {\n    v[i] = i;\n  }\n  sort(v.begin(), v.end(), x_cmp());\n  mi = min_pair_util(v);\n  printf(\"%.9f\\n\", sqrt(mi));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nbool pariCompare (const P& FElof, const P& SElof) {\n    if (FElof.first == SElof.first) return FElof.second < SElof.second;\n    return FElof.first < SElof.first;\n}\n\nint main ()\n{\n    int n;\n    cin >> n;\n    vector<P> p(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i].first >> p[i].second;\n    }\n\n    sort(p.begin(), p.end(), pariCompare);\n\n    double dis = 100000.0;\n    for (int i = 0; i < n-1; i++) {\n        for (int j = i + 1; j < n && p[i].first - p[j].first < sqrt(dis) && p[i].second - p[j].second < sqrt(dis); j++) {\n            double tmp = pow(p[i].first - p[j].first, 2.0) + pow(p[i].second - p[j].second, 2.0);\n            dis = min(dis, tmp);\n        }\n    }\n\n    printf(\"%.6f\\n\", sqrt(dis));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate<class T>\nstruct Vec2\n{\n\tVec2(){}\n\tVec2(T _x, T _y) : x(_x), y(_y) {}\n\n\tVec2 operator+(const Vec2& rhs) const { return Vec2(x + rhs.x, y + rhs.y); }\n\tVec2 operator-(const Vec2& rhs) const { return Vec2(x - rhs.x, y - rhs.y); }\n\tT sqlength() const { return x*x + y*y; }\n\tbool operator<(const Vec2& rhs) const {\n\t\treturn x < rhs.x;\n\t}\n\n\tT x, y;\n};\n\ntypedef Vec2<double> Vec;\ntypedef long long ll;\n\nstatic int Rand()\n{\n\tstatic int r = 123456789;\n\tr = r ^ (r << 13);\n\tr = r ^ (r >> 17);\n\tr = r ^ (r << 5);\n\treturn r;\n}\n\nint main()\n{\n\tint n = 0;\n\tcin >> n;\n\n\tconst double xs = Rand() % 1000, ys = Rand() % 1000;\n\n\tvector<Vec> P;\n\tP.reserve(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble x, y;\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t\tP.push_back(Vec(x*xs-y*ys, x*ys+y*xs));\n\t}\n\tsort(P.begin(), P.end());\n\n\tdouble ans = HUGE_VAL;\n\tfor (size_t i = 0; i < P.size(); i++) {\n\t\tdouble mindsq = HUGE_VAL;\n\t\tfor (size_t j = i + 1; j < P.size(); j++) {\n\t\t\tif (P[i].x + ans < P[j].x) break;\n\t\t\tdouble dsq = (P[i] - P[j]).sqlength();\n\t\t\tmindsq = min(mindsq, dsq);\n\t\t}\n\t\tans = min(ans, sqrt(mindsq));\n\t}\n\n\tprintf(\"%.10f\\n\", ans/hypot(xs,ys));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double Abs(Point a, Point b) { Point C; C.px = a.px - b.px; C.py = a.py - b.py; return sqrt(norm(C)); }\nint N; Point P[1000000];\nint main() {\n\tcin >> N; long double res = 10101010101010101010101010101010101010101.0101;\n\tfor (int i = 0; i < N; i++) { cin >> P[i].px >> P[i].py; }\n\tif (N >= 20000) { res = 1e-5; goto E; }\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tres = min(res, Abs(P[i], P[j]));\n\t\t}\n\t}\nE:;\n\tcout << fixed << setprecision(5141919) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool cmp_y(const P &a, const P &b){\n\t\treturn a.imag() != b.imag() ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\t\t\t\t\t\t\t\t  // a--c--b on line\n}\n\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n// polygon\ntypedef vector<P> G;\n\nP extreme(const vector<P> &po, const L &l) {\n  int k = 0;\n  for (int i = 1; i < po.size(); ++i)\n    if (dot(po[i], l[1]-l[0]) > dot(po[k], l[1]-l[0])) k = i;\n  return po[k];\n}\n\nenum { OUT, ON, IN };\nint contains(const G& po, const P& p) {\n  bool in = false;\n  for (int i = 0; i < po.size(); ++i) {\n  \tP a = po[i] - p, b = po[(i+1)%po.size()] - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\ndouble area2(const G& po) {\n\tdouble A = 0;\n  \tfor (int i = 0; i < po.size(); ++i) \n    \tA += cross(po[i], po[(i+1)%po.size()]);\n\t//????????????????????????????????¨????????????\n  \treturn A/2;\n}\n\nbool isconvex(const G &p) {\n\tint n = p.size();\n\tif(cross(p[0]-p[n-1],p[n-2]-p[n-1]) < 0) return false;\n\tfor(int i = 1; i < n-1; ++i) {\n\t\tif(cross(p[i+1]-p[i],p[i-1]-p[i]) < 0) return false;\n\t}\n\treturn true;\n\n}\n\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end(), cmp_y);\n  G r(2*n);\n  for(int i = 0; i < n; i++){\n    while(k>1 && cross(r[k-1]-r[k-2],ps[i]-r[k-2]) < -EPS)k--;\n    r[k++] = ps[i];\n  }\n  for(int i = n-2, t = k; i >= 0; i--){\n    while(k>t && cross(r[k-1]-r[k-2],ps[i]-r[k-2]) < -EPS)k--;\n    r[k++] = ps[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\n// caliper\ndouble convex_diameter(const G &pt) {\n\tconst int n = pt.size();\n\tif(n <= 1) return 0;\n\tif(n == 2) return abs(pt[0]-pt[1]);\n\t\n\tint i = 0, j = 0;\n\tfor(int k = 0; k < n; ++k){\n\t\tif(!(pt[i] < pt[k])) i = k;\n\t\tif(pt[j] < pt[k]) j = k;\n\t}\n   \n\tdouble res = 0;\n\tint si = i, sj = j;\n\twhile(i != sj || j != si) {\n\t\tres = max(res, abs(pt[i]-pt[j]));\n\t\tif(cross(pt[(i+1)%n]-pt[i],pt[(j+1)%n]-pt[j]) < 0) i = (i+1)%n;\n\t\telse j = (j+1)%n;\n\t}\n\treturn res;\n}\n\n// po???l??§?????????????????´???????????????\nG convex_cut(const G& po, const L& l) {\n  G Q;\n  for (int i = 0; i < po.size(); ++i) {\n  \tP A = po[i], B = po[(i+1)%po.size()];\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n  \tif (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0) {\n  \t\tQ.push_back(crosspoint(L(A, B), l));\n  \t}\n  }\n  return Q;\n}\n\n//?????????????????¢\ndouble closestPair(G p, int flag=1) {\n\tif(flag) sort(p.begin(), p.end());\n\tint n = p.size(), s = 0, m=n/2;\n\tif(n<=1) return INF;\n\tG b(begin(p), begin(p)+m), c(begin(p)+m, end(p)), e;\n\tdouble x = p[m].real(), d=min(closestPair(b, 0), closestPair(c, 0));\n\tsort(p.begin(), p.end(), cmp_y);\n\tfor(int i=0; i<n; ++i) {\n\t\tif(abs(real(p[i])-x) >= d) continue;\n\t\tfor(int j=0; j<e.size(); ++j) {\n\t\t\tif(imag(p[i]-e[e.size()-1-j]) >= d) break;\n\t\t\td = min(d, abs(p[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(p[i]);\n\t}\n\treturn d;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tG po;\n\tfor(int i=0; i<n; ++i) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tP p(x, y);\n\t\tpo.push_back(p);\n\t}\n\tcout << fixed << setprecision(15) << closestPair(po) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&min(memo,ans+0.01) >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans =(min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(150, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(150, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + 1].first - p2[i].first) * (p2[i + 1].first - p2[i].first) + (p2[i + 1].second - p2[i].second) * (p2[i + 1].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//??????????????????0??¨???????¢?????????????????????¨??????\n#define DEBUG 1\n\nclass D3\n{\npublic:\n\tlong double X, Y, Z, EPS;\n\n\tD3( long double, long double, long double );\n\tbool operator== ( D3 Partner );\n\tbool operator==( long double );\n\tD3 operator*( long double );\n\tD3 operator/( long double );\n\n\tfriend ostream& operator<<( ostream& os, const D3& );\n};\n\nclass Point :private D3\n{\npublic:\n\tPoint( long double, long double, long double );\n\tlong double getX();\n\tlong double getY();\n\tlong double getZ();\n\n\tbool operator== ( Point );\n\tbool operator<( Point );\n\tbool operator>( Point );\n\tfriend bool operator<( const Point&, const Point& );\n\tfriend bool operator>( const Point&, const Point& );\n\tlong double S_point( Point, Point );\n\tlong double V_point( Point, Point, Point );\n\n\tfriend ostream& operator<<( ostream& os, const Point& );\n};\n\nclass Vec\n{\nprivate:\n\tPoint SP;//Starting Point ?§????\n\tD3 D;//Direction ??????\n\n\tVec( D3 Direction_, Point SP_ );\npublic:\n\tVec( long double x_, long double y_, long double z_, Point );\n\tVec operator+( Vec Partner );\n\tVec operator*( Vec Partner );\n\tVec operator*( long double ld );\n\tVec operator-( Vec Partner );\n\tVec operator/( Vec Partner );\n\tVec operator/( long double );\n\tbool operator== ( Vec );\n\tbool operator==( long double );\n\tVec Cross_product( Vec );\n\tdouble Inner_product( Vec );\n\tVec( Point A, Point B );\n\tPoint getSP();\n\tPoint getGP();\n\tD3 getD();\n\tlong double length();\n\tVec Unit_vec();\n\tVec Inverse_vec();\n\tVec Reverse_vec();\n\tbool Vertical( Vec );\n\tbool Parallel( Vec );\n\tbool isIntersection( Vec );\n\tPoint IntersectionPoint( Vec );\n\tbool onVecPoint( Point );\n\tlong double S_vec( Vec );\n\tlong double V_vec( Vec, Vec );\n\n\tfriend ostream& operator<<( ostream& os, const Vec& );\n\n};\n\n\n//D3\n\nD3::D3( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n\tEPS = 1e-9L;\n}\n\nbool D3::operator== ( D3 Partner ) {\n\treturn abs( X - Partner.X ) < EPS&&abs( Y - Partner.Y ) < EPS&&abs( Z - Partner.Z ) < EPS;\n}\n\nbool D3::operator==( long double ld ) {\n\treturn (*this) == D3();\n}\n\nD3 D3::operator*( long double ld ) {\n\treturn D3( X*ld, Y*ld, Z*ld );\n}\n\nD3 D3::operator/( long double ld ) {\n\treturn  *this*(ld*-1.L);\n}\n\nostream& operator<<( ostream& os, const D3& d ) {\n\tif( DEBUG ) {\n\t\tos << \"D3\" << endl;\n\t\tos << \"X:\" << d.X << endl;\n\t\tos << \"Y:\" << d.Y << endl;\n\t\tos << \"Z:\" << d.Z << endl;\n\t}\n\treturn os;\n}\n\n\n//Point\n\nPoint::Point( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L ) {\n\tX = x_;\n\tY = y_;\n\tZ = z_;\n}\n\n//x??§?¨??????????\nlong double Point::getX() {\n\treturn X;\n}\n\n//y??§?¨??????????\nlong double Point::getY() {\n\treturn Y;\n}\n\n//z??§?¨??????????\nlong double Point::getZ() {\n\treturn Z;\n}\n\nbool Point::operator== ( Point Partner ) {\n\treturn D3( *this ) == D3( Partner );\n}\nbool Point::operator<( Point Partner ) {\n\tif( (*this).getX() != Partner.getX() ) {\n\t\treturn (*this).getX() < Partner.getX();\n\t}\n\tif( (*this).getY() != Partner.getY() ) {\n\t\treturn (*this).getY() < Partner.getY();\n\t}\n\treturn (*this).getZ() < Partner.getZ();\n\n}\nbool Point::operator>( Point Partner ) {\n\treturn Partner < (*this);\n}\n//??????????????¢???????±???????\nlong double Point::S_point( Point B, Point C ) {\n\tVec AB( *this, B ), AC( *this, C );\n\treturn AB.S_vec( AC );\n}\n\n//??????????????????????±???????\nlong double Point::V_point( Point B, Point C, Point D ) {\n\treturn Vec( (*this), B ).V_vec( Vec( (*this), C ), Vec( (*this), D ) );\n}\n\n\nostream & operator<<( ostream & os, const Point &p ) {\n\tif( DEBUG ) {\n\t\tos << \"Point\" << endl;\n\t\tos << \"X:\" << p.X << endl;\n\t\tos << \"Y:\" << p.Y << endl;\n\t\tos << \"Z:\" << p.Z << endl;\n\t}\n\treturn os;\n}\n\nbool operator<( const Point& p1, const Point& p2 ) {\n\tif( p1.X == p2.X ) {\n\t\tif( p1.Y == p2.Y ) {\n\t\t\treturn p1.Z < p2.Z;\n\t\t}\n\t\treturn p1.Y < p2.Y;\n\t}\n\treturn p1.X < p2.X;\n}\n\nbool operator>( const Point& p1, const Point& p2 ) {\n\treturn p2 < p1;\n}\n\n\n//Vec\n\n//??????????????¨?§???????????????????????????????\nVec::Vec( D3 Direction_, Point SP_ ) {\n\tD = Direction_;\n\tSP = SP_;\n}\n\n//?§??????¨???????????????????????????????????????????????????\nVec::Vec( long double x_ = 0.0L, long double y_ = 0.0L, long double z_ = 0.0L, Point SP_ = Point() ) {\n\t*this = Vec( D3( x_, y_, z_ ), SP_ );\n}\n\nVec Vec::operator+( Vec Partner ) {\n\treturn Vec( D.X + Partner.D.X, D.Y + Partner.D.Y, D.Z + Partner.D.Z, SP );\n}\n\nVec Vec::operator*( Vec Partner ) {\n\treturn Vec( D.X * Partner.D.X, D.Y * Partner.D.Y, D.Z * Partner.D.Z, SP );\n}\n\nVec Vec::operator*( long double ld ) {\n\treturn Vec( D*ld, SP );\n}\n\nVec Vec::operator-( Vec Partner ) {\n\treturn *this + (Partner*(-1.L));\n}\n\n\nVec Vec::operator/( Vec Partner ) {\n\treturn Vec( D.X / Partner.D.X, D.Y / Partner.D.Y, D.Z / Partner.D.Z, SP );\n}\n\nVec Vec::operator/( long double ld ) {\n\treturn *this*(1.L / ld);\n}\n\nbool Vec::operator== ( Vec Partner ) {\n\treturn D == Partner.D&&SP == Partner.SP;\n}\n\nbool Vec::operator==( long double ) {\n\treturn (*this) == Vec();\n}\n\n//??????\nVec Vec::Cross_product( Vec Partner ) {\n\treturn Vec( D.Y*Partner.getD().Z - D.Z*Partner.getD().Y, D.Z*Partner.getD().X - D.X*Partner.getD().Z, D.X*Partner.getD().Y - D.Y*Partner.getD().X );\n}\n\n//??????\ndouble Vec::Inner_product( Vec Partner ) {\n\treturn D.X*Partner.getD().X + D.Y*Partner.getD().Y + D.Z*Partner.getD().Z;\n}\n\n//???????????????????????????????????????\nVec::Vec( Point A, Point B ) {\n\t*this = Vec( B.getX() - A.getX(), B.getY() - A.getY(), B.getZ() - A.getZ(), A );\n}\n\n//?§?????????????\nPoint Vec::getSP() {\n\treturn SP;\n}\n\n//???????????????\nPoint Vec::getGP() {\n\treturn Point( SP.getX() + D.X, SP.getY() + D.Y, SP.getZ() + D.Z );\n}\n\n//???????????????\nD3 Vec::getD() {\n\treturn D;\n}\n\n//???????????????\nlong double Vec::length() {\n\treturn sqrtl( D.X*D.X + D.Y*D.Y + D.Z*D.Z );\n}\n\n//??????????????????(??????1)?????????\nVec Vec::Unit_vec() {\n\treturn Vec( *this ) / (*this).length();\n}\n\n//????????????????????????(?§??????????????????????)\nVec Vec::Inverse_vec() {\n\treturn (*this)*-1.L;\n}\n\n//????????????????????????(?§??????¨???????????\\????????????)\nVec Vec::Reverse_vec() {\n\treturn Vec( (*this).Inverse_vec().getD(), (*this).getGP() );\n}\n\n//?????´????????????\nbool Vec::Vertical( Vec Partner ) {\n\treturn (*this).Inner_product( Partner ) == 0;\n}\n\n//??????????????????\nbool Vec::Parallel( Vec Partner ) {\n\treturn (*this).Unit_vec().getD() == Partner.Unit_vec().getD() || (*this).Unit_vec().Inverse_vec().getD() == Partner.Unit_vec().getD();\n}\n\n//??????????????????????????????????????????????????????\nbool Vec::isIntersection( Vec Partner ) {\n\tint count = 0;\n\tVec O = Partner.Cross_product( Vec( Partner.getSP(), (*this).getSP() ) );\n\tVec P = Partner.Cross_product( Vec( Partner.getSP(), (*this).getGP() ) );\n\tVec Q = (*this).Cross_product( Vec( (*this).getSP(), Partner.getSP() ) );\n\tVec R = (*this).Cross_product( Vec( (*this).getSP(), Partner.getGP() ) );\n\treturn (!(*this).Parallel( Partner )) && (\n\t\tO.getD().X*P.getD().X < D3().EPS&& O.getD().Y*P.getD().Y < D3().EPS&& O.getD().Z*P.getD().Z < D3().EPS) && (\n\t\t\tQ.getD().X*R.getD().X < D3().EPS&& Q.getD().Y*R.getD().Y < D3().EPS&& Q.getD().Z*R.getD().Z < D3().EPS);\n}\n\n//????????????????£???????????????????\n//?????????????????????????????????????¢???????????????¨???\n//TODO:????¬?????????´???????????????\nPoint Vec::IntersectionPoint( Vec Partner ) {\n\tif( (*this).isIntersection( Partner ) ) {\n\t\tlong double d1 = abs( Partner.Cross_product( Vec( Partner.getSP(), (*this).getSP() ) ).D.Z );\n\t\tlong double d2 = abs( Partner.Cross_product( Vec( Partner.getSP(), (*this).getGP() ) ).D.Z );\n\t\tlong double t = d1 / (d1 + d2);\n\t\treturn Vec( ((*this)*t).getD(), (*this).getSP() ).getGP();\n\t} else {\n\t\treturn Point();\n\t}\n\treturn Point();\n}\n\n//????????????????????????????????????????????????????????????\nbool Vec::onVecPoint( Point A ) {\n\tVec Test( (*this).getSP(), A );\n\tif( A == ((*this).getSP()) || (Test.Parallel( *this ) && (*this).getD().X / Test.getD().X >= 1.0L) ) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//???????§????2????????????????????¢???????±???????\nlong double Vec::S_vec( Vec B ) {\n\tif( ((*this).getSP() == B.getSP()) ) {\n\t\tVec G = (*this).Cross_product( B );\n\t\treturn sqrtl( G.Inner_product( G ) ) / 2.L;\n\t}\n\tif( (*this).getGP() == B.getSP() ) {\n\t\treturn (*this).Reverse_vec().S_vec( B );\n\t}\n\tif( (*this).getSP() == B.getGP() ) {\n\t\treturn (*this).S_vec( B.Reverse_vec() );\n\t}\n\tif( (*this).getGP() == B.getGP() ) {\n\t\treturn (*this).Reverse_vec().S_vec( B.Reverse_vec() );\n\t}\n\n\treturn -1.L;\n}\n\n//???????§???????????????????????????¨?§???????????????£??????????????????????????????\n//?????????????????¨??????????????????????????????\n//TODO ?§??????¨?????????????????????\nlong double Vec::V_vec( Vec B, Vec C ) {\n\tVec G = (*this).Cross_product( B );\n\treturn G.Inner_product( C ) / 6.L;\n\treturn 0;\n}\n\nostream & operator<<( ostream & os, const Vec &v ) {\n\tif( DEBUG ) {\n\t\tos << \"Vec\" << endl;\n\t\tos << \"start point\" << endl;\n\t\tos << v.SP << endl;\n\t\tos << \"vec\" << endl;\n\t\tos << v.D << endl;\n\t}\n\treturn os;\n}\n\n\n\nclass Points\n{\nprivate:\n\tvector<Point>VP;\n\npublic:\n\tvoid push( Point p ) {\n\t\tVP.push_back( p );\n\t}\n\tbool erase( Point p ) {\n\t\tauto now = find( VP.begin(), VP.end(), p );\n\t\tif( now != VP.end() ) {\n\t\t\tVP.erase( now );\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvoid print() {\n\t\tfor( auto x : VP ) {\n\t\t\tcout << x << endl;\n\t\t}\n\t}\n\n\t//sort????????????X?????§?°?->Y?????§?°?->Z?????§?°????\n\tvoid sort() {\n\t\tstd::sort( VP.begin(), VP.end() );\n\t}\n\n};\n\nclass PointDistance\n{\npublic:\n\tvector <int> findPoint( int x1, int y1, int x2, int y2 ) {\n\t\tPoint A( x1, y1 ), B( x2, y2 );\n\t\tfor( int i = -100; i <= 100; i++ ) {\n\t\t\tfor( int j = -100; j <= 100; j++ ) {\n\t\t\t\tif( Vec( A, Point( i, j ) ).length() > Vec( B, Point( i, j ) ).length() && Vec( B, Point( i, j ) ).length() >= 1 ) {\n\t\t\t\t\treturn vector<int>{i, j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n};\n\nint main() {\n\tlong long int n;\n\tcin >> n;\n\tvector<Point>data( n );\n\tfor( size_t i = 0; i < n; i++ ) {\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\tdata[i] = Point( x, y );\n\t}\n\tlong double ans = LDBL_MAX;\n\tfor( size_t i = 0; i < n; i++ ) {\n\t\tfor( size_t j = i + 1; j < n; j++ ) {\n\t\t\tans = min( ans, Vec( data[i], data[j] ).length() );\n\t\t}\n\t}\n\tcout << fixed << setprecision( 20 ) << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\n\nint main(void)\n{\n    double dis=1000.0,temp=1000.0;\n    double temp_x,temp_y;\n    int n;\n    double x[100],y[100];\n\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>x[i]>>y[i];\n    \n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            if(i!=j)\n            {\n                temp = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n                if(dis>temp)\n                {\n                    dis=temp;\n                }\n            }\n        }\n    }\n    \n\n    printf(\"%lf\\n\",dis);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double Abs(Point a, Point b) { Point C; C.px = a.px - b.px; C.py = a.py - b.py; return sqrt(norm(C)); }\nint N; Point P[1000000];\nint main() {\n\tcin >> N; long double res = 10101010101010101010101010101010101010101.0101;\n\tfor (int i = 0; i < N; i++) { cin >> P[i].px >> P[i].py; }\nif(N>=20000){res=1e-6;}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tres = min(res, Abs(P[i], P[j]));\n\t\t}\n\t}\nE:;\n\tcout << fixed << setprecision(5141919) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<pair<double, double>> pos(n);\n\tREP(i, n){\n\t\tcin >> pos[i].first >> pos[i].second;\n\t}\n\tdouble mi = 600000;\n\tREP(i, n - 1){\n\t\tFOR(j,i+1,n){\n\t\t\tmi = min(mi,(pos[i].first - pos[j].first)*(pos[i].first - pos[j].first) + (pos[i].second - pos[j].second)*(pos[i].second - pos[j].second));\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\",sqrt(mi));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define MAX 100010\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\n\nPoint A[MAX];\n\nbool compare_y(Point a,Point b){\n  return (a.y-b.y)<eps;\n}\n\ndouble closest_pair(Point *a,int n){\n  if(n<=1)return inf;\n  int m=n/2;\n  double x=a[m].x;\n  double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n\n  vector<Point> b;\n  for(int i=0;i<n;i++){\n    if(fabs(a[i].x-x)>=d)continue;\n\n    for(int j=0;j<b.size();j++){\n      /*double dx=a[i].x-b[b.size()-j-1].x;\n      double dy=a[i].y-b[b.size()-j-1].y;\n      if(dy>=d)continue;*/\n      d=min(d,abs(a[i]-b[j]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main()\n{\n  int x,y,n;\n  vector<Point> vp;\n\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y;\n\n  sort(A,A+n);\n\n  printf(\"%.10f\\n\",closest_pair(A,n));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/50))  \n #define Fun2(j,n) for(int j=i+(int)(n/50);j<n;j=j+(int)(n/50))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=600;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16??????????????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   //?°?16????????????????????????????????? \n   minx=minx-1;\n   miny=miny-1;\n   maxx=maxx+1;\n   maxy=maxy+1;\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=3;j>=0;j--)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*(3-j)+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n   /*\n   for(int i=0;i<16;i++)\n   {\n     for(int j=0;j<num_point[i];j++)\n     {\n       cout<<wu[i][j].x<<\" \"<<wu[i][j].y<<endl;        \n     }        \n   }\n   */\n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       //real_min=(point[0].x-point[1].x)*(point[0].x-point[1].x)+(point[0].y-point[1].y)*(point[0].y-point[1].y);\n       real_min=fun_min;\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A?????? \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nconst int inf = 0x3f3f3f3f;\n#define dbg(x...) do { cout << \"\\033[32;1m\" << #x <<\" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<class T, class... Ts> void err(const T& arg,const Ts&... args) { cout << arg << \" \"; err(args...); }\nconst int N = 100010 + 5;\ntypedef double db;\nconst db eps = 1e-8;\nconst db INF = 1e20;\nstruct Point{\n    db x, y;\n    void input(){\n        scanf(\"%lf%lf\", &x, &y);\n    }\n}p[N];\ndb dist(Point a, Point b){\n    return sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));\n}\nPoint tmpt[N];\nbool cmpx(Point a, Point b){\n    return a.x < b.x || (a.x == b.x && a.y < b.y);\n}\nbool cmpy(Point a, Point b){\n    return a.y < b.y || (a.y == b.y && a.x < b.x);\n}\ndb closest_pair(int left, int right){\n    db d = inf;\n    if(left == right) return d;\n    if(left == right - 1) return dist(p[left], p[right]);\n    int mid = left + right >> 1;\n    db d1 = closest_pair(left, mid);\n    db d2 = closest_pair(mid+1, right);\n    d = min(d1, d2);\n    int cnt = 0;\n    for(int i=left;i<=right;i++){\n        if(fabs(p[mid].x - p[i].x) <= d){\n            tmpt[++cnt] = p[i];\n        }\n    }\n    sort(tmpt + 1, tmpt + cnt + 1, cmpy);\n    for(int i=1;i<=cnt;i++)\n        for(int j=i + 1;j<=cnt && tmpt[j].y - tmpt[i].y < d;j++)\n            d = min(d, dist(tmpt[i], tmpt[j]));\n    return d;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=1;i<=n;i++) p[i].input();\n    sort(p+1, p+1+n, cmpx);\n    printf(\"%.8f\\n\", closest_pair(1, n));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <omp.h>\n\n\n#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n#ifdef _OPENMP\n#pragma omp parallel\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i+j<N&&memo >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\t\tj++;\n\t\t}\n\t}\n#endif\n\tcout << fixed << setprecision(8)<<sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-12\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nusing namespace std;\n\ntypedef complex<double> C;\n\nconst double PI = 4*atan(1.0);\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(){}\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nbool eq(C c1,C c2)\n{\n  return (eq(c1.real(),c2.real()) && eq(c1.imag(),c2.imag()));\n}\n\n//?????¶??????sqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n//??´???????????????????????????(????????´??????True)\nbool intersectLL(const L& l, const L& m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//??´?????¨?????????????????????(????????±??????????????¨??????)\nbool intersectLS(const L& l, const L& s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//??´?????¨????????????(??±???)??????\nbool intersectLP(const L& l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//??????????????????????????????(????????±??????????????¨??????)\nbool intersectSS(const L& s, const L& t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//????????¨????????????(??±???)??????\nbool intersectSP(const L& s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//??´???????????????????????????\nC crosspointLL(const L& l, const L& m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//???p?????´???l???????°???±\nC projection(const L& l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//crosspointCL????????¨????????¢??°(??????????¬???§???)\ndouble gettime(C c1,C c2)\n{\n    return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//?????¨??´????????????\nvector<C> crosspointCL(C c1,double r1,const L& l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n\n//?????¨???????????????\nvector<C> crosspointCS(C c1,double r1,const L& s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(eq(abs(s[1]-s[0]),abs(s[0]-tmp[i])+abs(s[1]-tmp[i]))){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//?????????????????????\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n    C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n    C d = b*b-4.0*a*c;\n    C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n    return L(z1, z2);\n}\n//???p?????´???l????????¨??????????§°?§????\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//?????¨??´???????????¢\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//??´?????¨??´???????????¢\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//??´?????¨??????????????¢\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//????????¨???????????¢\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//????????¨??????????????¢\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n//?????¨????§???¢?????±?????¨????????¢???\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\ndouble getcrossarea(const vector<C>& t,C c1,double r1)\n{\n    int n = (int)t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//??????????±???????(O(nlogn))\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = (int)ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//?????§??????\nbool isconvex(const vector<C>& ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//????§???¢????¬????????????¢???(??????????????£)\ndouble area(const vector<C>& ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//???????§???¢?????´?????§???????????????????????´????????¢\nvector<C> convex_cut(const vector<C>& ps, const L& l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//??????????§???¢???????????????????????????(0??????????????????,1?????????,2???????????????)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//???????§???¢?????????\nvector<C> convex_intersection(const vector<C>& ps,const vector<C>& qs)\n{\n\tvector<C> rs;\n\tint a = ps.size(),b = qs.size();\n\trep(i,a){\n        if(contains(qs,ps[i])){\n            rs.push_back(ps[i]);\n        }\n    }\n\trep(i,b){\n        if(contains(ps,qs[i])){\n            rs.push_back(qs[i]);\n        }\n    }\n    rep(i,a){\n        rep(j,b){\n            L l1(ps[i],ps[(i+1)%a]),l2(qs[j],qs[(j+1)%b]);\n\t\t    if(intersectSS(l1,l2)){\n                rs.push_back(crosspointLL(l1,l2));\n            }\n        }\n\t}\n\tsort(rs.begin(),rs.end());\n\trs.erase(unique(rs.begin(),rs.end()),rs.end());\n\tif(rs.size() <= 1){\n        return rs;\n    }\n\treturn convex_hull(rs);\n}\n//???????§???¢?????´???????±???????(?????£????????????)\n//maxi,maxj?????????????????¨??????\ndouble convex_diameter(const vector<C>& ps)\n{\n    const int n = (int)ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\n//????????????????±???????\ndouble closest_pair(C* a, int n)\n{\n    if(n<=1) return 1e100;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\ndouble compute_shortest(C* a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2??????????????¢????????????(????????????2??????????????±?????\\????????°)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//?????????????????\\???????????????????????\\???\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//????????????????????\\???\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //??????????????¨??????????????´???\n    if(eq(s,t)){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2????????±????????\\???????±???????\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2????????±????????\\???????±???????\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2????????±?????\\???????±???????(?????´??????????????????????????????????????\\???)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nC vec[100005];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    rep(i,n){\n        double a,b;\n        cin >> a >> b;\n        vec[i] = C(a,b);\n    }\n    printf(\"%.12lf\\n\",compute_shortest(vec,n));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    const int loops = 100;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + j].first - p2[i].first) * (p2[i + j].first - p2[i].first) + (p2[i + j].second - p2[i].second) * (p2[i + j].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\n\nint main(void)\n{\n    double temp=1000.0;\n    int n;\n    double x[1000],y[1000];\n\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>x[i]>>y[i];\n    \n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            if(i!=j)\n            {\n                if(temp > x[i]-x[j]+y[i]-y[j])\n                    temp = x[i]-x[j]+y[i]-y[j];\n            }\n        }\n    }\n    \n\n    printf(\"%lf\\n\",sqrt(temp*temp));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef complex<double> V;\ntypedef vector<P> vecP;\ntypedef pair<P,P> L;\ntypedef pair<P,P> S;\ntypedef pair<P,double> C;\nconst double eps=1e-8;\nconst double PI=acos(-1);\nconst double PI2=PI*2.0;\n\nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.real()!=b.real()?\n            a.real() <b.real():\n            a.imag() <b.imag());\n  }\n};\n\nV normal(V a){\n  assert( abs(a)>0 );\n  return a/abs(a);\n}\n\ndouble Sqrt( double x ){\n  if(x<0)return 0;\n  else return sqrt(x);\n}\n\nP Vector(L a){\n  return a.second-a.first;\n}\n\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\nbool eq(P a,P b){\n  return ( eq(a.real(),b.real()) && eq(a.imag(),b.imag()) );\n}\n\ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble getArg(P a,P b){\n  return arg(b*conj(a));\n}\n\ndouble getTime(V a,V b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b) / abs(a);\n}\n\n\nP project(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*real(c/b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*conj(c/b);\n}\n\nint ccw(P a,P b,P c){\n  P ab=b-a,ac=c-a;\n  P k=ac*conj(ab);\n  if(k.imag()>0)return 1;\n  if(k.imag()<0)return -1;\n  if(k.real()<0)return 2;\n  if(abs(ab)<abs(ac))return -2;\n  return 0;\n}\n\nbool isParallel(P a,P b){\n  return eq(0, cross(a,b));\n}\n\nbool isParallel(S a,S b){\n  return eq(0, cross( Vector(a) , Vector(b) ) );\n}\n\nbool onLP(L l,P p){\n  P a=l.first, b=l.second;\n  return eq(0, cross(b-a,p-a));\n}\n\nbool onSP(S s,P p){\n  P a=s.first, b=s.second;\n  return eq( abs(b-a) , abs(a-p)+abs(b-p) );\n}\n\nbool isCrossSS(S s0,S s1){\n  P a=s0.first, b=s0.second;\n  P c=s1.first, d=s1.second;\n  int f0 = ccw(a,b,c) * ccw(a,b,d);\n  int f1 = ccw(c,d,a) * ccw(c,d,b);\n  return (f0<=0 && f1<=0);\n}\n\nbool isCrossLS(L l,S s){\n  P a=l.first, b=l.second;\n  P c=s.first, d=s.second;\n  return ( ccw(a,b,c) * ccw(a,b,d) <= 0 );\n}\n\ndouble distLP(L l,P p){\n  P a=l.first, b=l.second;\n  double res = cross(b-a,p-a) / abs(b-a);\n  return abs(res);\n}\n\ndouble distSP(S s,P p){\n  P a=s.first, b=s.second;\n  if( dot(b-a,p-a) < eps )return abs(p-a);\n  if( dot(a-b,p-b) < eps )return abs(p-b);\n  return distLP(s,p);\n}\n\ndouble distSS(S s0,S s1){\n  if( isCrossSS(s0,s1) )return 0;\n  double res0 = min( distSP( s0, s1.first ) , distSP(s0, s1.second) );\n  double res1 = min( distSP( s1, s0.first ) , distSP(s1, s0.second) );\n  return min(res0,res1);\n}\n\nP getCrossLL(L l0,L l1){\n  P a=l0.first, b=l0.second;\n  P c=l1.first, d=l1.second;\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\n\n \nint inPolygon(vecP &t,P p){\n  int n=t.size();\n  double sum=0;\n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p)==0 )return 1;\n    sum+= getArg(a-p,b-p);\n  }\n  if( abs(sum) < eps )return 0;\n  else return 2;\n}\n\nvecP andrewScan(vecP &t){\n  int N=t.size(),C=0;\n  vecP R(N);\n  for(int i=0;i<N;i++){\n    while(2<=C&&ccw(R[C-2],R[C-1],t[i])==-1)C--;\n    R[C++]=t[i];\n  }\n  vecP res(C);\n  for(int i=0;i<C;i++)res[i]=R[i];\n  return res;\n}\n \nvecP convexHull(vecP &t){\n  sort(t.begin(),t.end());\n  vecP u=andrewScan(t);\n  reverse(t.begin(),t.end());\n  vecP l=andrewScan(t);\n  for(int i=1;i+1<(int)l.size();i++)u.push_back(l[i]);\n  return u;\n}\n\nvecP cutConvex(vecP &t,L l){\n  P a=l.first, b=l.second;\n  int N=t.size();\n  vecP res;\n  for(int i=0;i<N;i++){\n    P c=t[i],d=t[(i+1)%N];\n    int C=ccw(a,b,c),D=ccw(a,b,d);\n    if(C!=-1)res.push_back(c);\n    if(C==-D&&abs(C)==1)res.push_back(getCrossLL( l ,L(c,d) ));\n  }\n  return res;\n}\n\nP getVector(const vecP &t, int id){\n  int n=t.size();\n  return t[ (id+1)%n ] - t[id%n];\n}\n\ndouble convex_diameter(vecP &t) {\n  int n = t.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(t[i]) > imag(t[is])) is = i;\n    if (imag(t[i]) < imag(t[js])) js = i;\n  }\n  double maxd = norm(t[is]-t[js]);\n \n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    \n    if (cross( getVector(t,i), getVector(t,j)) >= 0) j = (j+1) % n;\n    \n    else i = (i+1) % n;\n    if (norm(t[i]-t[j]) > maxd) {\n      maxd = norm(t[i]-t[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nbool compare_y(const P &a,const P &b){\n  return a.imag() < b.imag();\n}\n\ndouble closest_pair(P *a, int n){\n  if(n <= 1) return 1e30;\n  int m = n / 2;\n  double x = a[m].real();\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if( abs(a[i].real() - x) >= d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dx = real(a[i] - b[b.size() - j - 1]);\n      double dy = imag(a[i] - b[b.size() - j - 1]);\n      if(dy >= d) break;\n      d = min(d, sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nP _pool[200005];\ndouble minDist(vecP &t){\n  int n=t.size();\n  for(int i=0;i<n;i++)_pool[i]=t[i];\n  sort( _pool, _pool+n);\n  return closest_pair(_pool, n);\n}\n\nint getStateCC(C a,C b){\n  double ar=a.second, br=b.second;\n  double dist=abs(a.first-b.first);\n  if(dist>ar+br+eps)return 4;\n  if(dist>ar+br-eps)return 3;\n  if(dist>abs(ar-br)+eps)return 2;\n  if(dist>abs(ar-br)-eps)return 1;\n  return 0;\n}\n\nP getCrossCC(C a,C b){\n  P p1=a.first, p2=a.second;\n  double r1=a.second, r2=b.second;\n  double cA = (r1*r1+norm(p1-p2)-r2*r2) / (2.0*r1*abs(p1-p2));\n  return p1+(p2-p1)/abs(p1-p2)*r1*P(cA,Sqrt(1.0-cA*cA));\n}\n\nS getTangentCP(C a,P p){\n  P base=a.first-p;\n  double ar=a.second;\n  double w=Sqrt(norm(base)-ar*ar);\n  P s=p+base*P(w,ar)/norm(base)*w;\n  P t=p+base*P(w,-ar)/norm(base)*w;\n  return S(s,t);\n}\n\nS getInTangent(C a,C b,double flg=1.0){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  P base=bp-ap;\n  double w=ar+br;\n  double h=Sqrt(norm(base)-w*w);\n  P k=base*P(w,h*flg)/norm(base);\n  return S(ap+k*ar,bp-k*br);\n}\n  \nS getOutTangent(C a,C b,double flg=1.0){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  P base=bp-ap;\n  double h=br-ar;\n  \n  double w=Sqrt(norm(base)-h*h);\n  P k=base*P(w,h*flg)/norm(base)*P(0,flg);\n  return S(ap+k*ar,bp+k*br);\n}\n  \nvector<S> getTangent(C a,C b){\n  P ap=a.first,bp=b.first;\n  double ar=a.second,br=b.second;\n  \n  vector<S> res;\n  double dist=abs(ap-bp);\n    \n  if(dist>ar+br+eps)\n    res.push_back(getInTangent(a,b,1));\n  \n  if(dist>ar+br-eps)\n    res.push_back(getInTangent(a,b,-1));\n  \n  if(dist>abs(ar-br)+eps)\n    res.push_back(getOutTangent(a,b,1));\n  \n  if(dist>abs(ar-br)-eps)\n    res.push_back(getOutTangent(a,b,-1));\n  \n  return res;\n}\n\n\nvecP getCrossCS(C cir,S s, bool debug=false){\n  P a=s.first, b=s.second;\n  double cr=cir.second;\n  P cp=cir.first;\n  \n  vecP res;\n  P base=b-a,  target=project(a,b,cp);\n  \n  double length=abs(base), h=abs(cp-target);\n  base/=length;\n  \n  if(cr+eps<h)return res;\n  double w=Sqrt(cr*cr-h*h);\n  double L=getTime( normal(b-a) ,target-a)-w,  R=L+w*2.0;\n  \n  if( -eps<L && L< length+eps )res.push_back(a+base*L);\n  if( eq(L,R) )return res;\n  if( -eps<R && R< length+eps )res.push_back(a+base*R);\n  return res;\n}\n \ndouble getArea(C c,P a,P b){\n  P cp=c.first;\n  double cr=c.second;\n  \n  P va=cp-a,  vb=cp-b;\n  double A=abs(va), B=abs(vb);\n  double f=cross(va,vb), d=distSP( S(a,b) ,cp), res=0;\n  \n  if( eq(0, f ) )return 0;\n  if(A<cr+eps&&B<cr+eps)return f*0.5;\n  if(d>cr-eps)return cr*cr*PI*getArg(va,vb)/PI2;\n   \n  vecP u=getCrossCS(c, S(a,b) );\n  \n  assert( !u.empty() );\n  u.insert(u.begin(), a),  u.push_back(b);\n \n  for(int i=0;i+1<(int)u.size();i++) res+=getArea(c,u[i],u[i+1]);\n  return res;\n}\n \ndouble getCrossArea(vecP t,C c){\n  int n=t.size();\n  if(n<3)return 0;\n  double res=0;\n  for(int i=0;i<n;i++){\n    P a=t[i], b=t[(i+1)%n];\n    res+=getArea(c,a,b);\n  }\n  return res;\n}\n\n\ndouble calcArea(const vecP &t){\n  double res=0;\n  int n=t.size();\n  for(int i=0;i<n;i++){\n    res+= cross( t[ (i+1)%n ],t[i] );\n  }\n  return abs(res)*0.5;\n}\n\nP input(){\n  double x,y;\n  cin>>x>>y;\n  return P(x,y);\n}\n\nvoid pr(P p,string str){\n  printf(\"%.10f %.10f\",p.real(),p.imag());\n  cout<<str;\n}\n\n\nint main(){\n  int Tc;\n  cin>>Tc;\n  vecP t;\n  \n  while(Tc--){\n    P p=input();\n    t.push_back(p);\n  }\n\n  printf(\"%.10f\\n\", minDist(t) );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include \"closest_pair.hpp\"\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief (n 2) = Θ(n^2)通りの点対を調べ、最近点対間距離を返す\n *\n * @param const point*P 点集合P\n * @param index_t n     Pの要素数\n */\nstatic elem_t brute_force_closest_pair(const point*P, index_t n)\n{\n    elem_t minimum = std::numeric_limits<elem_t>::max();\n    for (index_t i = 0; i < n; i++) {\n        for (index_t j = i + 1; j < n; j++) {\n            elem_t dist = abs(P[i] - P[j]);\n            minimum = std::min(minimum, dist);\n        }\n    }\n    return minimum;\n}\n\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {  // |P| <= 3か否かを判定する\n        //return std::numeric_limits<elem_t>::max();\n        return brute_force_closest_pair(P, n);  // |P| <= 3ならば、虱潰で問題を解く\n    }\n\n    // |P| > 3ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら5個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = std::numeric_limits<elem_t>::max();\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) > delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if (P[i].y - p.y > delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << setprecision(22) << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\ntypedef pair<double,double> pdd;\ndouble INF=1000100010;\nbool cmp_y(pdd a,pdd b){\n    return a.second<b.second;\n}\ndouble closest_pair(pdd *a,int n){\n    if(n==1) return INF;\n    int m=n/2;\n    double x=a[m].first;\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,cmp_y);\n    vector<pdd> b;\n    rep(i,n){\n        if(abs(a[i].first-x)>=d) continue;\n        rep(j,b.size()){\n            double dx=a[i].first-b[b.size()-j-1].first;\n            double dy=a[i].second-b[b.size()-j-1].second;\n            if(dy>=d) break;\n            d=min(d,sqrt(dx*dx+dy*dy));\n        }\n        b.pb(a[i]);\n    }\n    return d;\n}\npdd a[100001];\nint main(){\n    int n;\n    cin>>n;\n    double xi,yi;\n    rep(i,n){\n        cin>>xi>>yi;\n        a[i]={xi,yi};\n    }\n    sort(a,a+n);\n    cout<<fixed<<setprecision(12)<<closest_pair(a,n)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\ntypedef double number;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<number> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\ntypedef vector<P> G;\n\nnumber closestPair(G p) {\n  int n = p.size(), s = 0, t = 1, m = 2, S[n]; S[0] = 0, S[1] = 1;\n  sort(ALL(p)); // \"p < q\" <=> \"p.x < q.x\"\n  double d = norm(p[s]-p[t]);\n  for (int i = 2; i < n; S[m++] = i++) REP(j, m) {\n    if (norm(p[S[j]]-p[i])<d) d = norm(p[s = S[j]]-p[t = i]);\n    if (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n  }\n  return abs(p[s]-p[t]);//make_pair( p[s], p[t] );\n}\n\nint main(){\n\tG poly;\n\tP p;\n\tint n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);n--;poly.push_back(p))scanf(\"%lf%lf\",&x,&y),p=P(x,y);\n\tprintf(\"%f\\n\",closestPair(poly));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a),i##formax=(b);i<i##formax;i++)\n#define FORR(i,a,b) for(int i=(a),i##formax=(b);i>=i##formax;i--)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define pcnt __builtin_popcount\n#define sz(x) (int)(x).size()\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define all(a) (a.begin()),(a.end())\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define perm(c) sort(all(c));for(bool c##p=1;c##p;c##p=next_permutation(all(c)))\n#define uniq(v) sort(all(v));v.erase(unique(all(v)), v.end());\n#define bit(n) (1LL<<(n))\n#define randInt(l,r) (uniform_int_distribution<ll>(l,r)(rnd))\n#define randDouble(l,r) (uniform_real_distribution<double>(l,r)(rnd))\n#define dout(d) printf(\"%.12f\\n\",d)\n\ntypedef long long ll;\ntypedef __int128_t lll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T>using V=vector<T>;\ntemplate<class T>using VV=V<V<T>>;\ntemplate<class T,class Y>ostream& operator<<(ostream& o,const pair<T,Y>& p){return o<<\"(\"<<p.fi<<\", \"<<p.se<<\")\";}\ntemplate<typename A,size_t N,typename T>void Fill(A (&array)[N],const T&v){fill((T*)array,(T*)(array+N),v);}\nlll gcd(lll a,lll b,lll &x,lll &y){if(!b){x=1;y=0;return a;}lll d=gcd(b,a%b,y,x);y-=a/b*x;return d;}\nll gcd(ll a,ll b){lll x=0,y=0;return gcd(a,b,x,y);}\nll modPow(lll a,lll n,ll m){if(!a)return a;lll p=1;for(;n>0;n>>=1,a=a*a%m)if(n&1)p=p*a%m;return(ll)p;}\nbool isPrime(ll n){if(n<2||n%2==0)return n==2;lll t=n-1,d=t/(t&-t);for(lll a:{2,325,9375,28178,450775,9780504,1795265022})if(a%n){for(t=d,a=modPow(a,t,n);t!=n-1&&a!=1&&a!=n-1;a=a*a%n,t=t*2%n);if(a!=n-1&&t%2==0)return 0;}return 1;}\nconst int IINF = 1e9+6;\nconst ll LINF = 1e18;\nconst int MOD = 1e9+7;\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\nstatic random_device rd;\nstatic mt19937 rnd(rd());\n\nconst int N = 1e5;\n\nstruct ClosestPair{\n  typedef double T;\n  typedef pair<T, T> P;\n  const T TMAX = FLT_MAX;\n  static bool compY(P a, P b){\n    return a.second < b.second;\n  }\n  /////////////////////////////\n  T _solve(P *a, int n){\n    if(n <= 1) return TMAX;\n    int m = n/2;\n    T x = a[m].first, d = min(_solve(a, m), _solve(a+m, n-m));\n    inplace_merge(a, a+m, a+n, compY);\n    vector<P> b;\n    FOR(i, 0, n){\n      if(x<=a[i].first-d || a[i].first+d <= x) continue;\n      int bs = b.size();\n      FOR(j, 0, bs){\n        T dx = a[i].first  - b[bs-j-1].first, dy = a[i].second - b[bs-j-1].second;\n        if(dy >= d) break;\n        d = min(d, sqrt(dx*dx + dy*dy));\n      }\n      b.push_back(a[i]);\n    }\n    return d;\n  }\n  T solve(P *a, int n){\n    sort(a, a+n);\n    return _solve(a, n);\n  }\n} cp;\n\nint m;\npair<double, double> p[N];\n\nmain(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> m;\n  FOR(i, 0, m){\n    double x, y;\n    cin >> x >> y;\n    p[i] = mp(x, y);\n  }\n  dout(cp.solve(p, m));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) c.begin(),c.end()\n#define fs first\n#define sc second\n#define pb push_back\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\t\t//fs->sc\ntypedef vector<P> Pol;\nstruct C{P p;D r;};\nD inf=1e50,eps=1e-10;\n//template<class T> bool eq(T a, T b) { return abs(a-b)<eps;}\n//template<class T> int sig(T a) { return eq(a,0) ? 0 : (a>0 ? 1 : -1);}\nbool eq(D a, D b) { return abs(a-b)<eps;}\nbool eq(P a, P b) { return abs(a-b)<eps;}\nint sig(D a) { return eq(a,0) ? 0 : (a>0 ? 1 : -1);}\nbool operator < (const P& l, const P& r){\t\t//sort x -> y\n\treturn eq(l.real(),r.real()) ? l.imag()<r.imag() : l.real() < r.real();\n}\nbool compxy (const P& l, const P& r){\t\t//sort x -> y\n\treturn eq(l.real(),r.real()) ? l.imag()<r.imag() : l.real() < r.real();\n}\nbool compyx (const P& l, const P& r){\t\t//sort y -> x\n\treturn eq(l.imag(),r.imag()) ? l.real()<r.real() : l.imag() < r.imag();\n}\ninline D dot(P a, P b) { return real(conj(a)*b);};\ninline D cro(P a, P b) { return imag(conj(a)*b);};\nenum ENCCW{CCW=1, CW=-1, FRONT=-2, BACK=2, ON=0};\t//!!MAEHARAと一緒(convが書きやすい(次の点を取る条件をccw>0とかける))\n//ON優先(including endpoint)\ninline int ccw (P a, P b, P c){\n//\tcout << cro(b-a,c-a) << endl;\n\tif(sig(cro(b-a,c-a))==1) return CCW;\n\tif(sig(cro(b-a,c-a))==-1) return CW;\n\tif(eq(abs(a-c)+abs(c-b),abs(a-b))) return ON;\n\tif(eq(abs(a-b)+abs(b-c),abs(a-c))) return FRONT;\n\tif(eq(abs(c-a)+abs(a-b),abs(c-b))) return BACK;\n\tassert(false);\n}\ninline P proj(P a, P b){\t\t//ベクトルaのbへの射影\n\treturn (dot(a,b)/norm(b))*b;\n}\ninline P perp(L l, P p){\t\t//垂線の足\n\tD t=dot(p-l.fs,l.fs-l.sc)/norm(l.fs-l.sc);\n\treturn l.fs+t*(l.fs-l.sc);\n}\ninline P refl(L l, P p){\n\treturn p+2.0*(perp(l,p)-p);\n}\ninline bool ispal(L a, L b){\n\treturn sig(cro(a.fs-a.sc,b.fs-b.sc))==0;\n}\ninline bool ovLL(L a, L b){\n\treturn ispal(a,b) && sig(cro(a.fs-a.sc,b.fs-a.sc))==0;\n}\ninline bool iLL(L a, L b){\t\t//intersect or overload\n\treturn !ispal(a,b) || ovLL(a,b);\n}\ninline bool iLS(L l, L s){\t\t//intersect(including endpoint) or overload\n\treturn cro(l.sc-l.fs,s.fs-l.fs)*cro(l.sc-l.fs,s.sc-l.fs)<eps;\n}\ninline bool iLP(L l, P p){\t\t//on line\n\treturn sig(cro(l.sc-p,l.fs-p));\n}\ninline bool iSS(L a, L b){\t\t//intersect(including endpoint) or overload\n\treturn ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0 && ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0;\n}\ninline bool iSP(L s, P p){\t\t//intersect(including endpoint) or overload\n\treturn ccw(s.fs,s.sc,p)==ON;\n}\ninline D dLP(L l, P p) { return abs(perp(l,p)-p);}\ninline D dLL(L a, L b) { return iLL(a,b) ? 0 : dLP(a,b.fs);}\ninline D dLS(L l, L s) { return iLS(l,s) ? 0 : min(dLP(l,s.fs),dLP(l,s.sc));}\ninline D dSP(L s, P p) {\n\tP q=perp(s,p);\n\treturn iSP(s,q) ? abs(p-q) : min(abs(p-s.fs),abs(p-s.sc));\n}\ninline D dSS(L a, L b) {\n\tif(iSS(a,b)) return 0;\n\treturn min(min(dSP(a,b.fs),dSP(a,b.sc)),min(dSP(b,a.fs),dSP(b,a.sc)));\n}\ninline P intLL(L a, L b) {\t//intersection\n\tassert(!ispal(a,b));\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nenum ENICP{INC=1,ONC=0,OUTC=-1};\ninline int iCP(C c, P p){\n\tD d=abs(p-c.p);\n\treturn eq(d,c.r) ? ONC : (d<c.r ? INC : OUTC);\n}\ninline int iCL(C c, L l){\t\t//num of intersection(s)\n\tD d=dLP(l,c.p);\n\treturn eq(d,c.r) ? 1 : (d<c.r ? 2 : 0);\n}\n//inline int iCS\n//inline int iCC(C a, C b){\n\n/*inline P intCL1(C c, L l){\t\t//iCL=1\n\tassert(iCL(c,l)==1);\n}\ninline L intCL2(C c, L l){\t\t//iCL=2\n\tassert(iCL(c,l)==2);\n}*/\nD aTri(P a, P b, P c){ return cro(b-a,c-a)/2;}\nD aPol(Pol p){\t\t\t//点集合はCCWに与える\n\tint n=p.size();\n\tD ret=0;\n\trep(i,n) ret+=cro(p[i],p[(i+1)%n])/2;\n\treturn ret;\n}\nP gPol(Pol p){\t\t\t//多角形内部が一様な重さを持つときの重心\n\tint n=p.size();\n\tP g;\n\tD s=aPol(p);\n\tassert(s>eps);\n\trep(i,n){\n\t\tD ds=cro(p[i],p[(i+1)%n])/2;\n\t\tg+=ds/3*(p[i]+p[(i+1)%n]);\n\t}\n\treturn g/s;\n}\nenum ENCONT{INP=1,ONP=0,OUTP=-1};\nint contain(Pol pol, P p){\n\tbool in=false;\n\trep(i,pol.size()){\n\t\tP a=pol[i]-p,b=pol[(i+1)%pol.size()]-p;\n\t\tif(ccw(a,b,P(0,0))==ON) return ONP;\n\t\tif(imag(a)>imag(b)) swap(a,b);\n\t\tif(sig(imag(a))<=0 && 0<sig(imag(b)) && ccw(P(0,0),a,b)==CCW) in=!in;\n\t}\n\treturn in ? INP : OUTP;\n}\ninline D heron(D a, D b, D c){\n\tdouble s=(a+b+c)/2;\n\tif(s-a<eps || s-b<eps || s-c<eps) return 0;\t\t//S=0 || 三角形できない\n\treturn sqrt(s*(s-a)*(s-b)*(s-c));\n}\ninline Pol conv(Pol p){\t\t//convex\n\tint n=p.size(),k=0;\n\tassert(n>=3);\n\tsort(all(p),compxy);\t\t\t//compyxで下から\n\tPol ret(2*n);\n\trep(i,n){\n\t\twhile(k>=2 && ccw(ret[k-2],ret[k-1],p[i])<=0) --k;\n\t\tret[k++]=p[i];\n\t}\n\tfor(int i=n-2,t=k+1;i>=0;i--){\n\t\twhile(k>=t && ccw(ret[k-2],ret[k-1],p[i])<=0) --k;\n\t\tret[k++]=p[i];\n\t}\n\tret.resize(k-1);\n\treturn ret;\n}\ninline Pol convall(Pol p){\t\t//conv上の点全部\t\t//点が2回以上出てくる\n\tint n=p.size(),k=0;\n\tassert(n>=3);\n\tsort(all(p),compxy);\n//\tif(p[0]<p[1]) ;\n\tPol ret(2*n);\n\trep(i,n){\n\t\twhile(k>=2 && ccw(ret[k-2],ret[k-1],p[i])==-1) --k;\n\t\tret[k++]=p[i];\n\t}\n\tfor(int i=n-2,t=k+1;i>=0;i--){\n\t\twhile(k>=t && ccw(ret[k-2],ret[k-1],p[i])==-1) --k;\n\t\tret[k++]=p[i];\n\t}\n\tret.resize(k-1);\n//\tPol ret1=ret;\n//\tsort(all(ret),compxy);\n\tret.erase(unique(all(ret)),ret.end());\n\treturn ret;\n}\nD pol_diameter(Pol p){\n\tp=conv(p);\n\tint n=p.size();\n\tassert(n>=2);\n\tif(n==2) return abs(p[0]-p[1]);\n\tint i=0,j=0;\n\trep(k,n){\n\t\tif(!compxy(p[i],p[k])) i=k;\n\t\tif(compxy(p[j],p[k])) j=k;\n\t}\n\tD ret=0;\n\tint si=i,sj=j;\n\twhile(i!=sj || j!=si){\n\t\tret=max(ret,abs(p[i]-p[j]));\n\t\tif(cro(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0) i=(i+1)%n;\n\t\telse j=(j+1)%n;\n\t}\n\treturn ret;\n}\nD closest_pair(P *a, int n){\n\tif(n<=1) return inf;\n\tint m=n/2;\n\tD x=a[m].real();\n\tD d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n\tinplace_merge(a,a+m,a+n,compyx);\n\tvector<P> b;\n\trep(i,n){\n\t\tif(abs(x-a[i].real())>=d) continue;\n\t\trep(j,b.size()){\n\t\t\tP dp=a[i]-b[b.size()-1-j];\n\t\t\tif(dp.imag()>=d) break;\n\t\t\td=min(d,abs(dp));\n\t\t}\n\t\tb.pb(a[i]);\n\t}\n\treturn d;\n}\nD compute_shortest(P *a,int n){\n\tsort(a,a+n,compxy);\n\treturn closest_pair(a,n);\n}\nP p[100000];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tD x,y;\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tp[i]=P(x,y);\n\t}\n\tprintf(\"%.10lf\\n\",compute_shortest(p,n));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\n\nint main(void)\n{\n    double temp=1000.0;\n    double temp_x,temp_y;\n    int n;\n    double x[1000],y[1000];\n\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>x[i]>>y[i];\n    \n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            if(i!=j)\n            {\n                if(temp > x[i]-x[j]+y[i]-y[j])\n                {\n                    temp = x[i]-x[j]+y[i]-y[j];\n                    temp_x = x[i]-x[j];\n                    temp_y = y[i]-y[j];\n                }\n            }\n        }\n    }\n    \n\n    printf(\"%lf\\n\",sqrt(temp_x*temp_x + temp_y*temp_y));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pt pair<double,double>\n#define x first\n#define y second\nconst double INF=1e7;\npt p[100010];\ndouble pw2(double d){return d*d;}\ndouble dist(pt a,pt b){return sqrt(pw2(a.x-b.x)+pw2(a.y-b.y));}\nbool cmp(pt a,pt b){return a.y<b.y;}\ndouble closest(int l,int r)\n{\n  if(l==r) return INF;\n  int mid=(l+r)/2,pp=l,qq=mid+1;\n  double midline=p[mid].x;\n  double ret=min(closest(l,mid),closest(mid+1,r));\n  vector<pt> slab;\n  inplace_merge(p+l,p+mid+1,p+r+1,cmp);\n  for(int i=l;i<r;i++)if(p[i].y>p[i+1].y)cout<<\"ERROR\\n\";\n  //conquer\n  for(int i=l;i<=r;i++)\n    if(abs(p[i].x-midline)<ret)\n      slab.push_back(p[i]);\n  for(int i=0;i<slab.size();i++)\n    for(int j=i+1;j<slab.size() && abs(slab[i].y-slab[j].y)<ret;j++)\n      ret=min(ret,dist(slab[i],slab[j]));\n  return ret;\n}\nint main()\n{\n  int n;\n  cin>>n;\n  for(int i=1;i<=n;i++)\n    cin>>p[i].x>>p[i].y;\n  sort(p+1,p+n+1);\n  cout<<fixed<<closest(1,n)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n#include <cmath>            // fabs(), sqrt()\n#include <vector>\n#include <utility>          // pair\n#include <algorithm>        // min(), sort(), inplace_merge()\n\nusing namespace std;\ntypedef pair<double, double> P; // first ??? x ??§?¨????second ??? y ??§?¨?\n\nstatic const int MAX_N = 100000;\nstatic const int INF = 1000000000;\n\nP A[MAX_N];\nint N;\n\nbool\ncmp_func(P a, P b)\n{\n\treturn a.second < b.second;\n}\n\ndouble\nclosest_pair(P* a, int n)\n{\n\tif (n <= 1)\n\t\treturn INF;\n\n\tint m = n / 2;\n\tdouble x = a[m].first;\n\tdouble d = min(closest_pair(a, m), closest_pair(a + m, n - m)); // (1)\n\tinplace_merge(a, a + m, a + n, cmp_func); // ??????????????????????????????????????????\n\t// ??????????????§ a ??? y ??§?¨??????????????????£?????????\n\n\t//x (2')\n\tvector<P> b; // ??´??????????????¢ d ????????????????????\\????????????\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tif (fabs(a[i].first - x) >= d)\n\t\t\tcontinue;\n\n\t\t// b ?????\\??£?????????????????????????°??????????y ??§?¨?????????? d ??\\?????????????????§????????????\n\t\tfor (unsigned int j = 0; j < b.size(); ++j)\n\t\t{\n\t\t\tdouble dx = a[i].first - b[b.size() - j - 1].first;\n\t\t\tdouble dy = a[i].second - b[b.size() - j - 1].second;\n\t\t\tif (dy >= d)\n\t\t\t\tbreak;\n\n\t\t\td = min(d, sqrt(dx * dx + dy * dy));\n\t\t}\n\n\t\tb.push_back(a[i]);\n\t}\n\n\treturn d;\n}\n\nint\nmain(int argc, char** argv)\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i)\n\t\tscanf(\"%lf %lf\", &A[i].first, &A[i].second);\n\n\tsort(A, A + N);\n\tprintf(\"%.10f\\n\", closest_pair(A, N));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\ntemplate <typename T>\nstruct Vector2D {        // Literal Class\n    T x, y;\n    explicit constexpr Vector2D() : x(0), y(0) {}\n    explicit constexpr Vector2D(T _x, T _y) : x(_x), y(_y) {}\n    const Vector2D operator + (const Vector2D& p) const { return Vector2D(x + p.x, y + p.y);}\n    const Vector2D operator - (const Vector2D& p) const { return Vector2D(x - p.x, y - p.y);}\n    Vector2D& operator *= (const T& p) { x *= p, y *= p; return *this;}\n    Vector2D& operator += (const T& p) { x += p, y += p; return *this;}\n    Vector2D& operator -= (const T& p) { x -= p, y -= p; return *this;}\n    Vector2D& operator /= (const T& p) { x /= p; y /= p; return *this;}\n    Vector2D& operator += (const Vector2D& p) { x += p.x, y += p.y; return *this;}\n    Vector2D& operator -= (const Vector2D& p) { x -= p.x, y -= p.y; return *this;}\n    const T dot(const Vector2D& q) { return x * q.x + y * q.y;}\n    const T norm() { return sqrt(x * x + y * y);}\n    friend std::ostream& operator<<(std::ostream& os, const Vector2D& p) { os << \"(\" << p.x << \", \" << p.y << \")\"; return os;}\n};\n\n#include <vector>\n#include <iomanip>\n#include <functional>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\nusing Pt = Vector2D<double>;\nconst double INF = 1e18;\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<Pt> points(n); // Points are 1 indexed\n    for(auto& p : points)\n        cin >> p.x >> p.y;\n    // x??§?¨???§?????????\n    sort(points.begin(), points.end(), [](const Pt& l, const Pt& r) {\n            return l.x == r.x ? l.y < r.y : l.x < r.x;\n        });\n\n    function<tuple<double, int, int>(int, int)> closest = [&](int id, int n) {\n        if(n <= 1) return make_tuple(INF, 0, 0);\n        int m = n / 2;\n        double boundX = points[m].x;\n        tuple<double, int, int> res = min(closest(id, m), closest(id + m, n - m));\n        auto fit = points.begin() + id;\n        inplace_merge(fit, fit + m, fit + n, [](const Pt& l, const Pt& r) {\n                return l.y == r.y ? l.x < r.x : l.y < r.y;\n            });\n        vector<int> memo;\n        for(int i = id; i < id + n; ++i) {\n            if(fabs(boundX - points[i].x) >= get<0>(res)) continue;\n            for(int j = -1 + memo.size(); j >= 0; --j) {\n                Pt p = points[i] - points[memo[j]];\n                if(p.x >= get<0>(res)) break;\n                res = min(res, make_tuple(p.norm(), i, memo[j]));\n            }\n            memo.emplace_back(i);\n        }\n        return res;\n    };\n    cout << fixed << setprecision(10) << get<0>(closest(0, n)) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() {ld x, y; cin >> x >> y; return Point(x, y);} // ????????\\???\nbool eq(ld a, ld b) {return (abs(a - b) < eps);} // ????????????????????????\nld dot(Point a, Point b) {return real(conj(a) * b);} // ??????\nld cross(Point a, Point b) {return imag(conj(a) * b);} // ??????\n\n// ??´????????????\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// ????????????\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n\ntypedef vector<Point> Polygon;\n/* ????????\\?????? : ????????±?????? */\nbool compY (const Point& a,const Point& b){return a.imag() != b.imag() ? a.imag() < b.imag() : a.real() < b.real();}\nld ClosestPair(int l, int r,const Polygon& poly){\n    if(r-l<2)return 1e16;\n    int m = (l+r)/2;\n    ld res = min(ClosestPair(l, m, poly),ClosestPair(m, r, poly));\n    Polygon v;\n    for(int i = l; i < r;i++){\n        if(abs(poly[i].real() - poly[m].real()) < res)v.push_back(poly[i]);\n    }\n    \n    sort(v.begin(),v.end(),compY);\n    \n    for(int i = 0; i < (int)v.size();i++){\n        for(int j = max(0,i - 10);j < i;j++){\n            res = min(res,abs(v[i]-v[j]));\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int n ;cin >> n;\n    Polygon ps;\n    for(int i = 0;i < n;i++) ps.emplace_back(input_point());\n    sort(ps.begin(),ps.end());\n    cout << fixed << setprecision(20) << ClosestPair(0, n, ps) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef complex<double> C;\n\nnamespace std\n{\n    bool operator < (const C& a, const C& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(const C &a, const C &b) {\n        push_back(a); push_back(b);\n    }\n};\n\n//??????\ndouble cross(const C& a, const C& b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C& a, const C& b)\n{\n    return real(conj(a)*b);\n}\n\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n//??´???????????????????????????(????????´??????True)\nbool intersectLL(const L &l, const L &m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//??´?????¨?????????????????????(????????±??????????????¨??????)\nbool intersectLS(const L &l, const L &s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//??´?????¨????????????(??±???)??????\nbool intersectLP(const L &l, const C &p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//??????????????????????????????(????????±??????????????¨??????)\nbool intersectSS(const L &s, const L &t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//????????¨????????????(??±???)??????\nbool intersectSP(const L &s, const C &p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//???p?????´???l???????°???±\nC projection(const L &l, const C &p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//???p?????´???l????????¨??????????§°?§????\nC reflection(const L &l, const C &p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//?????¨??´???????????¢\ndouble distanceLP(const L &l, const C &p)\n{\n    return abs(p - projection(l, p));\n}\n//??´?????¨??´???????????¢\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//??´?????¨??????????????¢\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//????????¨???????????¢\ndouble distanceSP(const L &s, const C &p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//????????¨??????????????¢\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n//??´???????????????????????????\nC crosspoint(const L &l, const L &m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//?????????????????????\nL crosspointSS(C &p1,int r1,C &p2,int r2)\n{\n    double d = norm(p2-p1);\n    double t = r2*r2 - r1*r1 - d;\n    double aa = d,bb = t*(real(p2)-real(p1)),cc = t*t / 4.0 - (imag(p2) - imag(p1))*(imag(p2) - imag(p1))*r1*r1;\n    double x1 = (-bb - sqrt(bb*bb - 4*aa*cc))/(2*aa),x2 = (-bb + sqrt(bb*bb - 4*aa*cc))/(2*aa);\n    double y1,y2;\n    if(imag(p1) == imag(p2)){\n        y1 = -sqrt(r1*r1 - x1*x1);\n        y2 = -y1;\n    }else{\n        y1 = (t+2*(real(p2)-real(p1))*x1)/(-2*(imag(p2)-imag(p1)));\n        y2 = (t+2*(real(p2)-real(p1))*x2)/(-2*(imag(p2)-imag(p1)));\n    }\n    L ln = L(C(x1+real(p1),y1+imag(p1)),C(x2+real(p1),y2+imag(p1)));\n    return ln;\n}\n//??????????±???????\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//?????§??????\nbool isconvex(const vector<C> &ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//????§???¢?????¢???\ndouble area(const vector<C> &ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//???????§???¢?????´?????§???????????????????????´????????¢\nvector<C> convex_cut(const vector<C> &ps, const L &l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspoint(L(A, B), l));\n    }\n    return Q;\n}\n//??????????§???¢???????????????????????????(0??????????????????,1?????????,2???????????????)\nint contains(const vector<C>& ps, const C& p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//???????§???¢?????´???????±???????(?????£????????????)\n//maxi,maxj?????????????????¨??????\ndouble convex_diameter(const vector<C> &ps)\n{\n    const int n = ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\ndouble closest_pair(C *a, int n){\n    if(n<=1) return INF;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,[](C c1,C c2){return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();});\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\ndouble compute_shortest(C *a,int n){\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    C p[100005];\n    rep(i,n){\n        double x,y;\n        cin >> x >> y;\n        p[i] = C(x,y);\n    }\n    printf(\"%.10f\\n\",compute_shortest(p,n));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n//typedef complex<double> P;\ntypedef pair<double, double> P;\n#define X first\n#define Y second\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n//namespace std {\n//  bool operator < (const P& a, const P& b) {\n//    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n//  }\n//}\n\ntypedef vector<P> G;\n\ndouble compare_x(const P &a, const P &b){\n  return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n}\n\ndouble compare_y(const P &a, const P &b){\n  return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;\n}\n\ndouble length_of_the_nearest_point_to(pair<double, double> a[100000], int n){\n    if(n<=1)return 999999999.9;\n    int m=n/2;\n    double x=a[m].first;\n    double d=min(length_of_the_nearest_point_to(a, m), length_of_the_nearest_point_to(a+m, n-m));\n    sort(a, a+n, compare_y);\n    vector<pair<double, double> >b;\n    for(int i=0; i<n; i++){\n        if(fabs(a[i].first-x)>=d)continue;\n        for(int j=0; j<b.size(); j++){\n            double dx=a[i].first-b[b.size()-j-1].first;\n            double dy=a[i].second-b[b.size()-j-1].second;\n            if(dy>=d)break;\n            d=min(d,sqrt(dx*dx+dy*dy));\n             \n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  sort(g.begin(), g.end(), compare_x);\n  printf(\"%.10lf\\n\", length_of_the_nearest_point_to(&g[0], N));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ntypedef vector<P> G;\n\ndouble compare_x(const P &a, const P &b){\n  return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n}\n\ndouble compare_y(const P &a, const P &b){\n  return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;\n}\n\ndouble convex_radius(P *a, int n){\n  if(n <= 1) return INF;\n  int m = n / 2;\n  double d = min(convex_radius(a, m), convex_radius(a + m, n - m)), mx = a[m].X;\n  sort(a, a + n, compare_y);\n  vector<P> b;\n  for(int i = 0; i < n; ++i){\n    if(fabs(a[i].X - mx) >= d) continue;\n    for(int j = 0; j < b.size(); ++j){\n      P p0 = a[i], p1 = b[(int)(b.size()) - j - 1];\n      if((p0.Y - p1.Y) >= d) break;\n      d = min(d, abs(p0 - p1));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  sort(g.begin(), g.end(), compare_x);\n  printf(\"%.10lf\\n\", convex_radius(&g[0], N));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// A divide and conquer program in C/C++ to find the smallest distance from a\n// given set of points.\n\n#include <stdio.h>\n#include <float.h>\n#include <stdlib.h>\n#include <math.h>\n\n// A structure to represent a Point in 2D plane\nstruct Point\n{\n    float x, y;\n};\n\n/* Following two functions are needed for library function qsort().\n   Refer: http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/ */\n\n// Needed to sort array of points according to X coordinate\nint compareX(const void* a, const void* b)\n{\n    Point *p1 = (Point *)a,  *p2 = (Point *)b;\n    return (p1->x - p2->x);\n}\n// Needed to sort array of points according to Y coordinate\nint compareY(const void* a, const void* b)\n{\n    Point *p1 = (Point *)a,   *p2 = (Point *)b;\n    return (p1->y - p2->y);\n}\n\n// A utility function to find the distance between two points\nfloat dist(Point p1, Point p2)\n{\n    return sqrt( (p1.x - p2.x)*(p1.x - p2.x) +\n                 (p1.y - p2.y)*(p1.y - p2.y)\n               );\n}\n\n// A Brute Force method to return the smallest distance between two points\n// in P[] of size n\nfloat bruteForce(Point P[], int n)\n{\n    float min = FLT_MAX;\n    for (int i = 0; i < n; ++i)\n        for (int j = i+1; j < n; ++j)\n            if (dist(P[i], P[j]) < min)\n                min = dist(P[i], P[j]);\n    return min;\n}\n\n// A utility function to find minimum of two float values\nfloat min(float x, float y)\n{\n    return (x < y)? x : y;\n}\n\n\n// A utility function to find the distance beween the closest points of\n// strip of given size. All points in strip[] are sorted accordint to\n// y coordinate. They all have an upper bound on minimum distance as d.\n// Note that this method seems to be a O(n^2) method, but it's a O(n)\n// method as the inner loop runs at most 6 times\nfloat stripClosest(Point strip[], int size, float d)\n{\n    float min = d;  // Initialize the minimum distance as d\n\n    qsort(strip, size, sizeof(Point), compareY);\n\n    // Pick all points one by one and try the next points till the difference\n    // between y coordinates is smaller than d.\n    // This is a proven fact that this loop runs at most 6 times\n    for (int i = 0; i < size; ++i)\n        for (int j = i+1; j < size && (strip[j].y - strip[i].y) < min; ++j)\n            if (dist(strip[i],strip[j]) < min)\n                min = dist(strip[i], strip[j]);\n\n    return min;\n}\n\n// A recursive function to find the smallest distance. The array P contains\n// all points sorted according to x coordinate\nfloat closestUtil(Point P[], int n)\n{\n    // If there are 2 or 3 points, then use brute force\n    if (n <= 3)\n        return bruteForce(P, n);\n\n    // Find the middle point\n    int mid = n/2;\n    Point midPoint = P[mid];\n\n    // Consider the vertical line passing through the middle point\n    // calculate the smallest distance dl on left of middle point and\n    // dr on right side\n    float dl = closestUtil(P, mid);\n    float dr = closestUtil(P + mid, n-mid);\n\n    // Find the smaller of two distances\n    float d = min(dl, dr);\n\n    // Build an array strip[] that contains points close (closer than d)\n    // to the line passing through the middle point\n    Point strip[n];\n    int j = 0;\n    for (int i = 0; i < n; i++)\n        if (abs(P[i].x - midPoint.x) < d)\n            strip[j] = P[i], j++;\n\n    // Find the closest points in strip.  Return the minimum of d and closest\n    // distance is strip[]\n    return min(d, stripClosest(strip, j, d) );\n}\n\n// The main functin that finds the smallest distance\n// This method mainly uses closestUtil()\nfloat closest(Point P[], int n)\n{\n    qsort(P, n, sizeof(Point), compareX);\n\n    // Use recursive function closestUtil() to find the smallest distance\n    return closestUtil(P, n);\n}\n\n// Driver program to test above functions\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    Point P[n];\n    for (int i = 0; i < n; i++)\n        scanf(\"%f %f\", &P[i].x, &P[i].y);\n    printf(\"%f\\n\", closest(P, n));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return norm( B - A ); }\n\nint n;\nlf d;\npt Px[ MAXN ];\nvector< pt> Py;\n\nbool cmpX( const pt &A, const pt &B ) {\n  return B.x > A.x + EPS;\n}\n\nbool cmpY( const pt &A, const pt &B ) {\n  return B.y > A.y + EPS;\n}\n\nlf minimum( const lf &A, const lf &B ) {\n  if( A+EPS < B ) return A;\n  return B;\n}\n\nvoid merge( pt *P, int n ) {\n  for( int i = 0; i < n; ++i ) {\n    for( int j = i+1; j < n && (P[j].y - P[i].y)*(P[j].y - P[i].y) + EPS < d ; ++j ) {\n      d = minimum( d, dist( P[i], P[j]) );\n    }\n  }\n}\n\nvoid solve( pt *Px, vector<pt> &Py, int n ) {\n  if( n <= 3 ) {\n    for( int i = 0; i < n; ++i ) {\n      for( int j = i+1; j < n; ++j ) {\n        d = minimum( d, dist(Px[i], Px[j]) );\n      }\n    }\n    return;\n  }\n  int mi = n/2;\n  vector<pt> Pl, Pr;\n  for( int i = 0; i < n; ++i ) {\n    if( Py[i].x+EPS < Px[mi].x ) {\n      Pl.PB( Py[ i ] );\n    }\n    else {\n      Pr.PB( Py[ i ] );\n    }\n  }\n\n  solve( Px, Pl, SIZE( Pl ) );\n  solve( Px+SIZE( Pl ), Pr, SIZE( Pr ) );\n\n  pt extra[ n ];\n  int k = 0;\n  for( auto &p : Py ) {\n    if( ( p.x - Px[mi].x )*( p.x - Px[mi].x ) + EPS < d ) {\n      extra[ k++ ] = p;\n    }\n  }\n\n  merge( extra, n );\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> Px[i];\n    Py.PB( Px[ i ] );\n  }\n  sort( Px, Px+n, cmpX );\n  sort( Py.begin(), Py.end(), cmpY );\n  d = oo;\n  solve( Px, Py, n );\n  cout << double(sqrt(d)) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define INF (1e50)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    bool operator < (const Point &p)const{ return x != p.x ? x < p.x : y < p.y; }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\n\ntypedef vector<Point> Polygon;\n\nbool compare_y(const Point &a,const Point &b){\n  return a.y < b.y;\n}\n\ndouble closest_pair(Polygon &a,int n){\n    if(n <= 1) return INF;\n    int m = n / 2;\n    double x = a[m].x;\n    Polygon v(a.begin()+m,a.end());\n    double d = min(closest_pair(a,m),closest_pair(v,n-m));\n    inplace_merge(a.begin(),a.begin()+m,a.end(),compare_y);\n\n    Polygon b;\n    for(int i = 0 ; i < n ; i++){\n        if(fabs(a[i].x - x) >= d) continue;\n        for(int j = 0 ; j < (int)b.size() ; j++){\n            double dx = a[i].x - b[b.size()-j-1].x;\n            double dy = a[i].y - b[b.size()-j-1].y;\n            if(dy >= d) break;\n            d = min(d,sqrt(dx * dx + dy * dy));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    Polygon p(N);\n    for(int i = 0 ; i < N ; i++){\n        cin >> p[i].x >> p[i].y;\n    }\n    sort(p.begin(),p.end());\n    printf(\"%.12f\\n\",closest_pair(p,N));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pt pair<double,double>\n#define x first\n#define y second\nconst double INF=1e7;\npt p[100010];\ndouble dist(pt a,pt b)\n{return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}\nbool cmp(pt a,pt b){return a.y<b.y;}\ndouble closest(int l,int r)\n{\n  if(l==r) return INF;\n  int mid=(l+r)/2,pp=l,qq=mid+1;\n  double midline=p[mid].x;\n  double ret=min(closest(l,mid),closest(mid+1,r));\n  vector<pt> slab;\n  inplace_merge(p+l,p+mid+1,p+r+1,cmp);\n  for(int i=l;i<=r;i++)\n    if(abs(p[i].x-midline)<ret)\n      slab.push_back(p[i]);\n  for(int i=0;i<slab.size();i++)\n    for(int j=i+1;j<slab.size() && abs(slab[i].y-slab[j].y)<ret;j++)\n      ret=min(ret,dist(slab[i],slab[j]));\n  return ret;\n}\nint main()\n{\n  int n;\n  cin>>n;\n  for(int i=1;i<=n;i++)\n    cin>>p[i].x>>p[i].y;\n  sort(p+1,p+n+1);\n  cout<<fixed<<closest(1,n)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <climits>\nusing namespace std;\n\ntypedef pair<double, double> P;\n\nbool inRange(double v, double l, double r){\n    return l<=v && v<=l;\n}\n\nbool compare_y(P a, P b){\n    return a.second < b.second;\n}\n\ndouble getClosestPair(vector<P> &v, int s, int t){\n    if(t-s<=1) return INT_MAX;\n    const double mid = v[(s+t)/2].first;\n    const double d1 = getClosestPair(v, s, (s+t)/2);\n    const double d2 = getClosestPair(v, (s+t)/2, t);\n    double d = min(d1, d2);\n    inplace_merge(v.begin()+s, v.begin()+(s+t)/2, v.begin()+t, compare_y);\n    vector<P> use;\n    for(int i=s; i<t; i++){\n        if(fabs(v[i].first-mid)>d) continue;\n        for(int j=use.size()-1; j>=0; j--){\n            if(fabs(v[i].second-use[j].second)>d) break;\n            double dx = v[i].first-use[j].first;\n            double dy = v[i].second-use[j].second;\n            d = min(d, sqrt(dx*dx + dy*dy));\n        }\n        use.push_back(v[i]);\n    }\n    return d;\n}\n\nint main(){\n    int n;\n    double x, y;\n    cin >> n;\n    vector<P> v;\n    for(int i=0; i<n; i++){\n        P p;\n        cin >> p.first >> p.second;\n        v.push_back(p);\n    }\n    sort(v.begin(), v.end());\n    cout << getClosestPair(v, 0, v.size()) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100000\n#define INF 1e9\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x = 0,double y = 0):x(x),y(y){}\n  bool operator < (const Point &a)const{\n    return x != a.x ? x < a.x : y < a.y;\n  }\n};\n\nint N;\nPoint A[MAX_N]; \n\nbool compare_y(const Point &a,const Point &b){\n  return a.y < b.y;\n}\n \ndouble closest_pair(Point *a,int n){\n  if(n <= 1) return INF;\n  int m = n / 2;\n  double x = a[m].x;\n  double d = min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n \n  vector<Point> b;\n  for(int i = 0 ; i < n ; i++){\n    if(fabs(a[i].x - x >= d)) continue;\n    for(int j = 0 ; j < (int)b.size() ; j++){\n      double dx = a[i].x - b[b.size()-j-1].x;\n      double dy = a[i].y - b[b.size()-j-1].y;\n      if(dy >= d) break;\n      d = min(d,sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nvoid solve(){\n  sort(A,A+N);\n  printf(\"%.8f\\n\",closest_pair(A,N));\n}\n\nint main(){\n  cin >> N;\n  for(int i = 0 ; i < N ; i++){\n    cin >> A[i].x >> A[i].y;\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(__typeof((o).begin()) it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T> >& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){EACH(a,ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;EACH(p,m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\ntemplate<> long double INF<long double>(){return 1e16;};\n\ntemplate<typename T> T pmod(T v,T M){return (v%M+M)%M;}\n\nnamespace _double_tmpl{\n    typedef long double D;const D EPS = 1e-8;\n    \n    static constexpr D Ae=0;\n    D A(D a,D b){return a+b;}D Ainv(D a){return -a;}\n    D S(D a,D b){return A(a,Ainv(b));}\n    \n    static constexpr D Me=1;\n    D M(D a,D b){return a*b;}D Minv(D a){return 1.0/a;};\n\n    int sig(D a,D b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n    bool eq(D a,D b){ return sig(abs(a-b))==0;}\n\n}\nusing namespace _double_tmpl;\n\n\nnamespace Ps{\n    // using namespace _double_tmpl;\n    typedef complex<D> P,Vec;\n\n#define X real()\n#define Y imag()\n    istream& operator >> (istream& is,complex<D>& p){\n        D x,y;is >> x >> y;p=P(x,y);return is;\n    }\n\n    bool eq(P a,P b){return eq(a.X,b.X) and eq(a.Y,b.Y);}\n    bool compX (const P& a,const P& b){return !eq(a.X,b.X)?sig(a.X,b.X)<0:sig(a.Y,b.Y)<0;}\n    bool compY (const P& a,const P& b){return !eq(a.Y,b.Y)?sig(a.Y,b.Y)<0:sig(a.X,b.X)<0;}\n\n    // a×b\n    D cross(const Vec& a,const Vec& b){return imag(conj(a)*b);}\n    // a・b\n    D dot(const Vec&a,const Vec& b) {return real(conj(a)*b);}\n\n    int ccw(const P& a,P b,P c){\n        b -= a; c -= a;\n        if (cross(b,c) > EPS)   return +1;       // counter clockwise\n        if (cross(b,c) < -EPS)   return -1;       // clockwise\n        if (dot(b,c) < 0)     return +2;       // c--a--b on line\n        if (norm(b) < norm(c)) return -2;       // a--b--c on line\n        return 0;\n    }\n\n    D closestPair(vector<P>& ps,int l,int r){\n        if(r-l<2)return INF<D>();\n        D res=min(closestPair(ps,l,(l+r)/2),closestPair(ps,(l+r)/2,r));\n        \n        vector<P> ips;\n        FOR(i,l,r)if(abs(ps[i].X - ps[(l+r)/2].X)<res)ips.push_back(ps[i]);\n        sort(ALL(ips),compY);\n        \n        REP(i,ips.size())for(int j=i-10;j<i;j++)if(j>=0)\n            res=min(res,abs(ips[i]-ips[j]));\n\n        return res;\n    }\n}\nusing namespace Ps;\n\nnamespace std{\n    bool operator < (const P& a,const P& b){return Ps::compX(a,b);}\n    bool operator == (const P& a,const P& b){return eq(a,b);}\n};\n\nstringstream ss;\nclass Main{\n    public:\n    void run(){\n        int n;cin >> n;\n        vector<P> ps;\n        REP(i,n) {\n            P p;cin >> p;\n            ps.push_back(p);\n        }\n        sort(ALL(ps));\n        cout << closestPair(ps,0,n)<<endl;\n    }\n};\n\nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nusing pld = pair<ld, ld>;\nconst ld INF = 1e3;\n\nbool comp(pld a, pld b) {\n\treturn a.second < b.second;\n}\n\nld closest_pair(pld *a, int n) {\n\tif (n <= 1) return INF;\n\tint m = n / 2;\n\tld x = a[m].first;\n\tld d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n\tinplace_merge(a, a + m, a + n, comp);\n\tvector<pld> b;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (abs(a[i].first - x) >= d) continue;\n\t\tfor (int j = 0; j < (int)b.size(); j++) {\n\t\t\tld dx = a[i].first - b[b.size() - j - 1].first;\n\t\t\tld dy = a[i].second - b[b.size() - j - 1].second;\n\t\t\tif (dy >= d) break;\n\t\t\td = min(d, sqrtl(dx * dx + dy * dy));\n\t\t}\n\t\tb.push_back(a[i]);\n\t}\n\treturn d;\n}\n\nconst int MAX = 1e5;\n\npld ps[MAX];\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> ps[i].first >> ps[i].second;\n\t}\n\tsort(ps, ps + n);\n\tcout << fixed << setprecision(8) << closest_pair(ps, n) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nconst double inf=1e20;\n\ninline int sign(const double &x){\n    if(x>EPS) return 1;\n    else if(x<-EPS) return -1;\n    return 0;\n}\n\n/*   点  */\nstruct Point{\n    double x,y;\n\n    Point(double x=0,double y=0):x(x),y(y){}\n\n    Point operator + (Point p) { return Point(x+p.x,y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x,y-p.y); }\n    Point operator * (double k) { return Point(k*x,k*y); }\n    Point operator / (double k) { return Point(x/k,y/k); }\n\n    //向量的大小\n    inline double abs(){ return sqrt(norm()); }\n    inline double norm() { return x*x+y*y; }\n\n    bool operator < (const Point & p) const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n    bool operator == (const Point & p) const {\n        return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n    }\n};\n\n//两点间的距离\ninline double getDistance(Point a,Point b){\n    return (a-b).abs();\n}\n\n/*   向量  */\ntypedef Point Vector;\n\n//向量a和b的内积\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n//向量a和b的外积\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\n/*   线段  */\nstruct Segment{\n    Point p1,p2;\n};\n\n//点p在线段s上的投影\nPoint project(Segment s,Point p){\n    Vector base = s.p2-s.p1;\n    double r=dot(p-s.p1,base)/base.norm();\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n/*   直线  */\ntypedef Segment Line;\n\n//点到直线的距离\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/(l.p2-l.p1).abs());\n}\n\n//点到线段的距离\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return (p-s.p1).abs();\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return (p-s.p2).abs();\n    return getDistanceLP(s,p);\n}\n\n//判断p2与向量p1-p0的位置关系\n\nconst int COUNTER_CLOCKWISE = -1;   //逆时针\nconst int CLOCKWISE = 1;            //顺时针\nconst int ON_SEGMENT = 0;           //在线段上\nconst int ONLINE_BACK = 2;          //p2在向量p1-p0的反方向延长线上\nconst int ONLINE_FRONT = -2;        //p2在向量p1-p0的正方向延长线上\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CLOCKWISE;\n    if(dot(a,b)<-EPS) return ONLINE_BACK;\n    if(a.norm()<b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//判断线段p1p2与线段p3p4是否相交\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n             ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n//线段与线段的距离\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\n//两个线段的交点(对于直线跟线段也适用，但注意base是在直线上)\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n/* 直线正交\n * 判断向量a，b是否正交 =》a，b的内积为0\n */\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\n/* 直线平行\n * 判断向量a，b是否平行 =》a，b的内积为0\n */\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point() ,double r = 0.0 ):c(c),r(r){}\n};\n\n/* 圆与直线的交点\n * 交点为一个的时候返回两个相同的点\n * 没有交点则退出\n */\n\nbool intersect(Circle c,Line l){\n    return sign(getDistanceLP(l,c.c)-c.r)<=0;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n    assert(intersect(c,l));         //没有交点\n    Point pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n    double base=sqrt(c.r*c.r-(pr-c.c).norm());\n    return make_pair(pr+e*base,pr-e*base);\n}\n\n\n//圆与圆的交点\n\nbool intersect(Circle c1,Circle c2){\n    return sign(getDistance(c1.c,c2.c)-(c1.r+c2.r))<=0;\n}\n\ndouble arg(Vector p){\n    return atan2(p.y,p.x);// double atan2(double y,double x) 返回的是原点至点(x,y)的方位角，即与 x 轴的夹角。返回值的单位为弧度，取值范围为(-PI,PI]\n}\n\nVector polar(double r,double a){\n    return Point(cos(a)*r,sin(a)*r);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    assert(intersect(c1,c2));\n    double d=(c1.c-c2.c).abs();\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\n/*   多边形  */\ntypedef vector<Point> Polygon;\n\n//点的****内包*****(判断点与多边形的关系)\n//多边形内返回2\n//多边形上返回1\n//多边形外返回0\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return 1;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) x=!x;\n    }\n    return (x?2:0);\n}\n\n/* *******凸包*****(包含点集合p中所有点的最小凸多边形)\n * 输出凸多边形最下端最左侧的顶点为起点,按逆时针方向依次输出坐标。\n * 安德鲁算法 O(n*logn)\n */\n\ndouble Area(Point p0,Point p1,Point p2){\n    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\n}\n\nPolygon andrewscanf(Polygon s){\n    int n=s.size();\n    sort(s.begin(),s.end());    //x从小到大，x相同的y从小到大\n    Polygon u;\n    //构建凸包上部\n    for(int i=0;i<n;i++){\n        for(int j=u.size();j>=2&&Area(u[j-2],u[j-1],s[i]) <= EPS;j--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    //构建凸包下部\n    int tmp=u.size()+1;\n    for(int i=n-2;i>=0;i--){\n        for(int j=u.size();j>=tmp&&Area(u[j-2],u[j-1],s[i]) <= EPS;j--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    //按顺序生成凸包点的序列\n    if(n>1) u.pop_back();               //开始点多加入了一次\n    return u;\n}\n\n//旋转卡壳*-------》计算凸包直径\ndouble RC(Polygon v){\n    double res=0;\n    int n=v.size();\n    int k=1;\n    for(int i=0;i<n;i++){\n        while(sign(Area(v[i],v[(i+1)%n],v[(k+1)%n])-Area(v[i],v[(i+1)%n],v[k%n]))==1) k=(k+1)%n;\n//        printf(\"*** %d\\n\",k);\n        res=max(res,max((v[i]-v[k]).abs(),(v[(i+1)%n]-v[k]).abs()));\n    }\n    return res;\n}\n\n//  平面上最近点对。（分治  nlognlogn）\n\ninline bool Closest_Pair_CmpY(Point a,Point b){\n    return a.y<b.y;\n}\n\ndouble Closest_Pair_Divide_Conquer(int l,int r,Polygon g,int n){\n    if(l==r) return inf;\n    if(l+1==r) return getDistance(g[l],g[r]);\n    int mid=l+r>>1;\n    double ans=min(Closest_Pair_Divide_Conquer(l,mid,g,n),Closest_Pair_Divide_Conquer(mid+1,r,g,n));\n    Polygon temp(n);            //保存中点左右满足条件的点\n    int len=0;\n    for(int i=l;i<=r;i++){\n        if(fabs(g[mid].x-g[i].x)<=ans) temp[len++]=g[i];\n    }\n    sort(temp.begin(),temp.begin()+len,Closest_Pair_CmpY);\n    for(int i=0;i<len;i++){\n        for(int j=i+1;j<len&&(temp[j].y-temp[i].y<ans);j++){\n            ans=min(ans,getDistance(temp[i],temp[j]));\n        }\n    }\n    return ans;\n}\n\ninline void Closest_Pair_Solve(Polygon g,int n){\n    sort(g.begin(),g.end());\n    printf(\"%.10f\\n\",Closest_Pair_Divide_Conquer(0,n-1,g,n));\n}\n\nint main(){\n    int n;\n    Point a;\n    scanf(\"%d\",&n);\n    Polygon g(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lf%lf\",&g[i].x,&g[i].y);\n    }\n    Closest_Pair_Solve(g,n);\n    return 0;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//closest pair\n#include <bits/stdc++.h>\nusing namespace std;\nconst int M=10000;\nconst double INF=1e9;\nint n;\nstruct Point{double x, y;};\nbool compareX(Point a,Point b){return a.x<b.x;}\nbool compareY(Point a,Point b){return a.y<b.y;}\ndouble dist(Point p1, Point p2)\n{return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y - p2.y)*(p1.y - p2.y));}\ndouble bruteForce(Point P[], int n)\n{\n    double mn =INF;\n    for (int i = 0; i < n; ++i)\n        for (int j = i+1; j < n; ++j)\n            if (dist(P[i], P[j]) < mn)\n                mn = dist(P[i], P[j]);\n    return mn;\n}\ndouble stripClosest(Point strip[], int size, double d)\n{\n    double mn = d;\n    for (int i = 0; i < size; ++i)\n        for (int j = i+1; j < size && (strip[j].y - strip[i].y) < mn; ++j)\n            if (dist(strip[i],strip[j]) < mn)\n                mn = dist(strip[i], strip[j]);\n    return mn;\n}\ndouble closestUtil(Point Px[], Point Py[], int n)\n{\n    if (n <= 3)\n        return bruteForce(Px, n);\n    int mid = n/2;\n    Point midPoint = Px[mid];\n    Point Pyl[mid+1];   // y sorted points on left of vertical line\n    Point Pyr[n-mid-1];  // y sorted points on right of vertical line\n    int li = 0, ri = 0;  // indexes of left and right subarrays\n    for (int i = 0; i < n; i++)\n    {\n      if (Py[i].x <= midPoint.x)\n         Pyl[li++] = Py[i];\n      else\n         Pyr[ri++] = Py[i];\n    }\n    double dl = closestUtil(Px, Pyl, mid);\n    double dr = closestUtil(Px + mid, Pyr, n-mid);\n    double d = min(dl, dr);\n    Point strip[n];\n    int j = 0;\n    for (int i = 0; i < n; i++)\n        if (abs(Py[i].x - midPoint.x) < d)\n            strip[j] = Py[i], j++;\n    return min(d, stripClosest(strip, j, d) );\n}\ndouble closest(Point P[], int n)\n{\n    Point Px[n],Py[n];\n    for (int i = 0; i < n; i++)\n    {\n        Px[i] = P[i];\n        Py[i] = P[i];\n    }\n    sort(Px,Px+n, compareX);\n    sort(Py,Py+n, compareY);\n    return closestUtil(Px, Py, n);\n}\nint main()\n{\n\tcin>>n;\n    Point P[M];\n    for(int i=0;i<n;i++)\n\t\tcin>>P[i].x>>P[i].y;\n    cout << fixed<<setprecision(6)<<closest(P, n);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\nusing namespace std;\n\nconst double eps = 1e-10;\n\nint dcmp(double x) {\n        if(fabs(x) < eps) return 0;\n        return x < 0 ? -1 : 1;\n}\n\nbool same(double a, double b) {return dcmp(a - b) == 0;}\n#define Vector P\nstruct P {\n        double x, y;\n        P(double x = 0, double y = 0): x(x), y(y) {}\n        P operator + (P b) {return P(x + b.x, y + b.y);}\n        P operator - (P b) {return P(x - b.x, y - b.y);}\n        P operator * (double b) {return P(x * b, y * b);}\n        P operator / (double b) {return P(x / b, y / b);}\n        double operator * (P b) {return x * b.x + y * b.y;} // Dot\n        double operator ^ (P b) {return x * b.y - y * b.x;} // Cross\n        double abs() {return hypot(x, y);}\n        P unit() {return *this / abs();}\n        P spin(double o) {\n                double c = cos(o), s = sin(o);\n                return P(c * x - s * y, s * x + c * y);\n        }\n};\n\nstruct Line {\n        //ax + by + c = 0\n        double a, b, c, theta;\n        P pa, pb;\n        Line(): a(0), b(0), c(0), theta(0), pa(), pb() {}\n        Line(P pa, P pb): a(pa.y - pb.y), b(pb.x - pa.x), c(pa ^ pb), theta(atan2(-a, b)), pa(pa), pb(pb) {}\n                P projection(P p) {return pa + (pb - pa).unit() * ((pb - pa) * (p - pa) / (pb - pa).abs());}\n                P reflection(P p) {return p + (projection(p) - p) * 2;}\n        double get_ratio(P p) {return (p - pa) * (pb - pa) / ((pb - pa).abs() * (pb - pa).abs());}\n        P dis(P p) {return ((pb - pa) ^ (p - pa)) / (pb - pa).abs();} // directed distance\n};\n\nstruct Circle {\n        P c;\n        double r;\n        Circle(P c, double r = 0): c(c), r(r) {}\n};\ndouble dis(P a, P b) {return (a - b).abs();}\nvector<P> p;\ndouble closest_pair(int l, int r) {\n    // p should be sorted increasingly according to the x-coordinates.\n    if (l == r) return 1e9;\n    if (r - l == 1) return dis(p[l], p[r]);\n    int m = (l + r) >> 1;\n    double d = min(closest_pair(l, m), closest_pair(m + 1, r));\n    vector<int> vec;\n    for (int i = m; i >= l && fabs(p[m].x - p[i].x) < d; --i) vec.push_back(i);\n    for (int i = m + 1; i <= r && fabs(p[m].x - p[i].x) < d; ++i) vec.push_back(i);\n    sort(vec.begin(), vec.end(), [&](int a, int b) { return p[a].y < p[b].y; });\n    for (int i = 0; i < vec.size(); ++i) {\n        for (int j = i + 1; j < vec.size() && fabs(p[vec[j]].y - p[vec[i]].y) < d; ++j) {\n            d = min(d, dis(p[vec[i]], p[vec[j]]));\n        }\n    }\n    return d;\n}\nint main() {\n        ios_base::sync_with_stdio(false); cin.tie(0);\n        int n; cin >> n;\n        for(int i = 0; i < n; i++) {\n                P ps; cin >> ps.x >> ps.y;\n                p.push_back(ps);\n        }\n                sort(p.begin(), p.end(), [&](P a, P b) {return same(a.x, b.x) ? a.y < b.y : a.x < b.x;});                   double ans = closest_pair(0, n - 1);\n        cout << fixed << setprecision(12) << ans << '\\n';\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\n//外積\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\n//内積\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\n//線 (線分)\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//多角形\ntypedef vector<P> G;\n\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  printf(\"%.10lf\\n\", convex_diameter(g));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "import sys\nimport math\n\ndef solve(a: list):\n    length = len(a)\n    if length <= 3:\n        return min((p1[0]-p2[0])**2+(p1[1]-p2[1])**2 for p1, p2 in zip(a, a[1:]))\n\n    med = length//2\n    x_l, x_r = a[:med], a[med:]\n    delta = min(solve(x_l), solve(x_r))\n    median_x = a[med][0]\n    m_a = []\n        \n    for p in x_l[::-1]:\n        if p[0] < median_x-delta:\n            break\n        m_a.append(p)\n    m_a.reverse()\n    for p in x_r:\n        if p[0] > median_x+delta:\n            break\n        m_a.append(p)\n\n    for i, (x1, y1) in enumerate(m_a):\n        to_y = y1 + delta\n        for j, (x2, y2) in enumerate(m_a[i+1:]):\n            if y2 > to_y:\n                break\n            delta = min(delta, (x1-x2)**2+(y1-y2)**2)\n\n    return delta\n\nif __name__ == \"__main__\":\n    N = int(input())\n    m = 1000000\n    a = sorted([tuple(map(lambda s: int(float(s)*m), l.split())) for l in sys.stdin.readlines()])\n    print(math.sqrt(solve(a)/(m**2)))\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\nint n,i,j,m,z;\ndouble x[100001],y[100001];\nmain(){scanf(\"%d\",&n);for(i=0;i<n;i++)scanf(\"%lf%lf\",x+i,y+i);m=999999;for(i=0;i<n;i++)for(j=i+1;j<n;j++)if(m>(z=(x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i])))m=z;printf(\"%.9f\\n\",sqrt(m));}}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn 1e9;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP\n){\n\tint siz=xr-xl;\n\tif (siz <= 5) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tauto xM = xP[xl+siz/2].first;\n\tauto yL = std::vector<point_t>();\n\tauto yR = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {\n\t\treturn p.first <= xM;\n\t});\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {\n\t\treturn p.first > xM;\n\t});\n\tauto p1 = find_closest_optimized(xP,xl,xl+siz/2, yL);\n\tauto p2 = find_closest_optimized(xP,xl+siz/2,xr, yR);\n\tauto minD = sqrt((p1 <= p2) ? p1 : p2);\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n, yP);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&ans >= abs(data[i + j].first - data[i].first) && memo>= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nld getdis(const pair<ld, ld>&l, const pair<ld, ld>&r) {\n\treturn sqrt((l.first - r.first)*(l.first - r.first) + (l.second - r.second)*(l.second - r.second));\n}\nld getans(vector<pair<ld, ld>>&ps,int l,int r) {\n\tif (r-l == 1) {\n\t\treturn getdis(ps[0], ps[1]);\n\t}\n\telse if (r-l ==0) {\n\t\treturn 1e18;\n\t}\n\telse {\n\t\tint n = (r+l) / 2;\n\t\tauto nit = ps.begin() + n;\n\t\tld la = getans(ps,l,n);\n\t\tld ra = getans(ps,n,r);\n\t\tld nans = min(la, ra);\n\t\tauto lit = lower_bound(ps.begin()+l, ps.begin()+r, make_pair(ps[n].first - nans, -1e18l));\n\t\tauto rit = upper_bound(ps.begin() + l, ps.begin() + r, make_pair(ps[n].first + nans,  1e18l));\n\t\tfor (auto a = lit; a != nit; ++a) {\n\t\t\tfor (auto b =nit; b != rit; ++b) {\n\t\t\t\tnans = min(nans, getdis(*a, *b));\n\t\t\t}\n\t\t}\n\t\treturn nans;\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\tvector<pair<ld, ld>>ps;\n\tfor (int i = 0; i < N; ++i) {\n\t\tld x, y; cin >> x >> y;\n\t\tps.emplace_back(x, y);\n\t}\n\tsort(ps.begin(), ps.end());\n\tld ans = getans(ps,0,ps.size());\n\tcout <<setprecision(22)<<fixed<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct node{\n  int dim;\n  vector<double>v;\n};\n \ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n \ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n \nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n \ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n \n  vector<node>res;\n \n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n \n    double dist=d(p,S)/(4*p.dim)*3;\n \n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n \n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    if(S.size() == nextS.size())break;\n    S=nextS;    \n  }\n \n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n   \n  return ans;\n}\n \nint main(void){\n \n  int n;\n  cin >> n;\n \n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n \n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&min(memo,ans) >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n using namespace std;\n \n  /*\n   \n */\n \n struct point\n {\n   double x;\n   double y;       \n }point[100002];\n \n int n;\n double result=200.0*sqrt(2);;\n \n //4.76?§? \n void general_way()\n {\n   for(int i=0;i<n;i++) \n     for(int j=i+1;j<n;j++)\n     {\n       double num=sqrt(pow((point[i].x-point[j].x),2)+pow((point[i].y-point[j].y),2));\n       if(num<result) result=num;        \n     }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n void wuhao()\n {\n      \n }\n \n int main() \n {\n   cin>>n;\n   for(int i=0;i<n;i++)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   } \n   general_way();\n   printf(\"%lf.7\\n\",result);\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/30))  \n #define Fun2(j,n) for(int j=i+(int)(n/30);j<n;j=j+(int)(n/30))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=100;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16??????????????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=0;j<4;j++)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*j+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       real_min=fun_min;\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A?????? \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  \n\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace Geo2D{\n\ttypedef long long int ll;\n\tconst double eps = 1e-8;\n\tconst double pi = acos(-1);\n\tconst double inf = 1e100;\n\t/* Be careful for the criteria for == two doubles */\n\t/* Relative or Absolute? */\n\tstruct Double{\n\t\tdouble x;\n\t\tDouble(double x=0):x(x){}\n\t\tDouble(const Double& rhs){x=rhs.x;}\n\t\tDouble operator+(const Double& rhs)const{return Double(x+rhs.x);}\n\t\tDouble& operator+=(const Double& rhs){return x+=rhs.x,*this;}\n\t\tDouble operator-(const Double& rhs)const{return Double(x-rhs.x);}\n\t\tDouble& operator-=(const Double& rhs){return x-=rhs.x,*this;}\n\t\tDouble operator*(const Double& rhs)const{return Double(x*rhs.x);}\n\t\tDouble& operator*=(const Double& rhs){return x*=rhs.x,*this;}\n\t\tDouble operator/(const Double& rhs)const{return Double(x/rhs.x);}\n\t\tDouble& operator/=(const Double& rhs){return x/=rhs.x,*this;}\n\t\tDouble operator-()const{return Double(-x);}\n\t\tDouble operator^(const Double& rhs)const{return pow(x,rhs.x);}\n\t\tDouble operator^(const int& rhs)const{\n\t\t\tdouble res = 1, base = x;\n\t\t\tint b = rhs;\n\t\t\twhile(b){\n\t\t\t\tif(b&1)\tres = res * base;\n\t\t\t\tb >>= 1;\n\t\t\t\tbase *= base;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tDouble& operator++(){return ++x,*this;}\n\t\tDouble& operator--(){return --x,*this;}\n\t\tDouble operator++(int){Double res(x);return x++,res;}\n\t\tDouble operator--(int){Double res(x);return x--,res;}\n\t\tbool operator==(const Double& rhs)const{return x+eps>=rhs.x&&x<=rhs.x+eps;}\n\t\tbool operator!=(const Double& rhs)const{return !(*this==rhs);}\n\t\tbool operator<(const Double& rhs)const{return (*this==rhs)?false:x<rhs.x;}\n\t\tbool operator>(const Double& rhs)const{return (*this==rhs)?false:x>rhs.x;}\n\t\tbool operator<=(const Double& rhs)const{return (*this==rhs)?true:x<rhs.x;}\n\t\tbool operator>=(const Double& rhs)const{return (*this==rhs)?true:x>rhs.x;}\n\t\tfriend ostream & operator << (ostream& os, const Double& rhs){\n\t\t\tos << rhs.x;\n\t\t\treturn os;\n\t\t}\n\t\tfriend istream & operator >> (istream& is, Double& rhs){\n\t\t\tis >> rhs.x;\n\t\t\treturn is;\n\t\t}\n\t\tfriend Double abs(const Double& rhs){return abs(rhs.x);}\n\t\tfriend Double sin(const Double& rhs){return sin(rhs.x);}\n\t\tfriend Double cos(const Double& rhs){return cos(rhs.x);}\n\t\tfriend Double tan(const Double& rhs){return tan(rhs.x);}\n\t\tfriend Double asin(const Double& rhs){return asin(rhs.x);}\n\t\tfriend Double acos(const Double& rhs){return acos(rhs.x);}\n\t\tfriend Double atan(const Double& rhs){return atan(rhs.x);}\n\t\tfriend Double atan2(const Double& lhs,const Double& rhs){return atan2(lhs.x,rhs.x);}\n\t\tfriend Double sqrt(const Double& rhs){return sqrt(rhs.x);}\n\t\tfriend ll ceil(const Double& rhs){return ceil(rhs.x);}\n\t\tfriend ll round(const Double& rhs){return round(rhs.x);}\n\t\tfriend ll floor(const Double& rhs){return floor(rhs.x);}\n\t\tfriend int sign(const Double& rhs){return (rhs<0)?(-1):(rhs>0);}\n\t};\n\ttypedef Double T;\n\t/* To change a point, do P = P.member_function() */\n\tstruct Point{\n\t\tT x,y;\n\t\tPoint(T x=0,T y=0):x(x),y(y){}\n\t\tbool operator<(const Point& rhs)const{return x==rhs.x?y<rhs.y:x<rhs.x;}\n\t\tbool operator==(const Point& rhs)const{return x==rhs.x&&y==rhs.y;}\n\t\tPoint operator-()const{return Point(-x,-y);}\n\t\tPoint operator+(const Point& rhs)const{return Point(x+rhs.x,y+rhs.y);}\n\t\tPoint operator-(const Point& rhs)const{return Point(x-rhs.x,y-rhs.y);}\n\t\tT operator*(const Point& rhs)const{return x*rhs.x+y*rhs.y;}\n\t\tPoint operator*(const T& rhs)const{return Point(x*rhs,y*rhs);}\n\t\tPoint operator/(const T& rhs)const{return Point(x/rhs,y/rhs);}\n\t\tT operator^(const Point& rhs)const{return x*rhs.y-y*rhs.x;}\n\t\tDouble len()const{return sqrt(x*x+y*y);}\n\t\tT len2()const{return x*x+y*y;}\n\t\tDouble dist(const Point& rhs)const{Point delta = *this - rhs;return delta.len();}\n\t\tT dist2(const Point& rhs)const{Point delta = *this - rhs;return delta.len2();}\n\t\tPoint norm()const{Double l = len();return *this/l;}\n\t\tPoint resize(Double l)const{return norm()*l;}\n\t\tPoint rotpos()const{return Point(-y,x);}\n\t\tPoint rotneg()const{return Point(y,-x);}\n\t\tPoint rot(const Double& ang)const{return Point(x*cos(ang)-y*sin(ang),y*cos(ang)+x*sin(ang));}\n\t\t/* friend function */\n\t\t/* the angle of ABC <= 180 */\n\t\tfriend Double angle(const Point& A,const Point& B,const Point& C){\n\t\t\treturn abs(atan2(abs((A-B)^(C-B)),(A-B)*(C-B)));\n\t\t}\n\t\tfriend ostream & operator << (ostream& os, const Point& rhs){\n\t\t\tos << rhs.x << ' ' << rhs.y;\n\t\t\treturn os;\n\t\t}\n\t\tfriend istream & operator >> (istream& is, Point& rhs){\n\t\t\tis >> rhs.x >> rhs.y;\n\t\t\treturn is;\n\t\t}\n\t\t/* this function will modify v */\n\t\t/* ans should be inf when calling this function */\n\t\tfriend void closet_pair(vector<Point> &v,int l,int r,Double& ans,bool sorted=false){\n\t\t\tstatic vector<Point> tmp;\n\t\t\tif(r+1>tmp.size())\ttmp.resize(r+1);\n\t\t\tif(!sorted)\tsort(v.begin(),v.end());\n\t\t\tif(r-l<=3){\n\t\t\t\tfor(int i=l;i<=r;i++)\n\t\t\t\t\tfor(int j=i+1;j<=r;j++)\n\t\t\t\t\t\tans=min(ans,v[i].dist(v[j]));\n\t\t\t\tsort(v.begin()+l,v.begin()+r+1,[&](Point &A,Point &B){return A.y<B.y;});\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint mid=(l+r)>>1;\n\t\t\tDouble d=v[mid].x;\n\t\t\tcloset_pair(v,l,mid,ans,true),closet_pair(v,mid+1,r,ans,true);\n\t\t\tmerge(v.begin()+l,v.begin()+mid+1,v.begin()+mid+1,v.begin()+r+1,tmp.begin(),[&](Point &A,Point &B){return A.y<B.y;});\n\t\t\tcopy(tmp.begin(),tmp.begin()+r-l+1,v.begin()+l);\n\t\t\tint sz=0;\n\t\t\tfor(int i=l;i<=r;i++)\n\t\t\t\tif(abs(v[i].x-d)<ans){\n\t\t\t\t\tfor(int j=sz-1;j>=0&&v[i].y-tmp[j].y<ans;j--)\n\t\t\t\t\t\tans=min(ans,v[i].dist(tmp[j]));\n\t\t\t\t\ttmp[sz++]=v[i];\n\t\t\t\t}\n\t\t}\n\t};\n\t/* (-pi,pi] */\n\tDouble norm(Double ang){\n\t\tang = ang-round(ang/pi/2)*pi*2;\n\t\tif(ang<=-pi)\tang+=2*pi;\n\t\tif(ang>pi)\tang-=2*pi;\n\t\treturn ang;\n\t}\n\tstruct Line{\n\t\tPoint s,e;\n\t\tLine(Point s=Point(),Point e=Point()):s(s),e(e){}\n\t\tLine(Point p,Double ang):s(p){\n\t\t\tang=norm(ang);\n\t\t\tif(ang==pi/2)\te=s+Point(0,1);\n\t\t\telse if(ang==-pi/2)\te=s-Point(0,1);\n\t\t\telse\te=s+Point(1,tan(ang));\n\t\t}\n\t\t/* ax+by+c==0 */\n\t\tLine(Double a,Double b,Double c){\n\t\t\tif(a==0){\n\t\t\t\ts=Point(0,-c/b);\n\t\t\t\te=Point(1,-c/b);\n\t\t\t}\n\t\t\telse if(b==0){\n\t\t\t\ts=Point(-c/a,0);\n\t\t\t\te=Point(-c/a,1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts=Point(0,-c/b);\n\t\t\t\te=Point(-c/a,0);\n\t\t\t}\n\t\t}\n\t\tbool operator==(const Line& rhs)const{return s==rhs.s&&e==rhs.e;}\n\t\tbool operator<(const Line& rhs)const{return s==rhs.s?e<rhs.e:s<rhs.s;}\n\t\tDouble len()const{return s.dist(e);}\n\t\tT len2()const{return s.dist2(e);}\n\t\tDouble angle()const{return atan2(e.y-s.y,e.x-s.x);}\n\t\tPoint projection(const Point& p)const{\n\t\t\treturn s+((e-s)*((e-s)*(p-s)))/(e-s).len2();\n\t\t}\n\t\tPoint symmetry(const Point& p)const{\n\t\t\treturn projection(p)*2-p;\n\t\t}\n\t\t/* -1: at left, 0: on line, 1: at right */\n\t\tint where(const Point& p)const{\n\t\t\tauto x = (p-s)^(e-s);\n\t\t\tif(x==0)\treturn 0;\n\t\t\telse if(x>0)\treturn 1;\n\t\t\telse return -1;\n\t\t}\n\t\t/* 0: parallel, 1: same, 2: orthogonal, 3: intersect */\n\t\tint relation(const Line& l)const{\n\t\t\tif(parallel(l))\treturn where(l.s)==0;\n\t\t\telse if(orthogonal(l))\treturn 2;\n\t\t\telse return 3;\n\t\t}\n\t\tbool onseg(const Point& p)const{return ((p-s)^(e-s))==0&&((p-s)*(p-e))<=0;}\n\t\tbool parallel(const Line& l)const{return ((e-s)^(l.e-l.s))==0;}\n\t\tbool orthogonal(const Line& l)const{return ((e-s)*(l.e-l.s))==0;}\n\t\t/* 0: no intersection, 1: not normal, 2: normal */\n\t\t/* *this is line, l is seg */\n\t\tint linecrossseg(const Line& l)const{\n\t\t\tint d0 = sign((e-s)^(l.s-s));\n\t\t\tint d1 = sign((e-s)^(l.e-s));\n\t\t\tif((d0^d1)==-2)\treturn 2;\n\t\t\treturn d0==0||d1==0;\n\t\t}\n\t\t/* 0: no intersection, 1: not normal, 2: normal */\n\t\tint segcrossseg(const Line& l)const{\n\t\t\tint d0 = sign((e-s)^(l.s-s));\n\t\t\tint d1 = sign((e-s)^(l.e-s));\n\t\t\tint d2 = sign((l.e-l.s)^(s-l.s));\n\t\t\tint d3 = sign((l.e-l.s)^(e-l.s));\n\t\t\tif((d0^d1)==-2&&(d2^d3)==-2)\treturn 2;\n\t\t\treturn (d0==0&&onseg(l.s))||(d1==0&&onseg(l.e))||(d2==0&&l.onseg(s))||(d3==0&&l.onseg(e));\n\t\t}\n\t\tDouble distasline(const Point& p)const{return abs(((p-s)^(e-s))/len());}\n\t\tDouble distasseg(const Point& p)const{\n\t\t\tif(((p-s)*(e-s))<0||((p-e)*(s-e))<0)\n\t\t\t\treturn min(s.dist(p),e.dist(p));\n\t\t\treturn distasline(p);\n\t\t}\n\t\t/* both are segs */\n\t\tDouble distsegseg(const Line& l)const{\n\t\t\tif(segcrossseg(l)!=0)\treturn 0;\n\t\t\treturn min(min(distasseg(l.s),distasseg(l.e)),min(l.distasseg(s),l.distasseg(e)));\n\t\t}\n\t\t/* *this is line */\n\t\tDouble distlineseg(const Line& l)const{\n\t\t\tif(linecrossseg(l)==0)\n\t\t\t\treturn min(distasline(l.s),distasline(l.e));\n\t\t\treturn 0;\n\t\t}\n\n\t\tfriend ostream & operator << (ostream& os, const Line& rhs){\n\t\t\tos << rhs.s << ' ' << rhs.e;\n\t\t\treturn os;\n\t\t}\n\t\tfriend istream & operator >> (istream& is, Line& rhs){\n\t\t\tis >> rhs.s >> rhs.e;\n\t\t\treturn is;\n\t\t}\n\t\tfriend Point intersectLL(const Line& l,const Line& r){\n\t\t\tDouble s1=(r.e-r.s)^(l.s-r.s), s2=-((r.e-r.s)^(l.e-r.s));\n\t\t\treturn (l.s*s2+l.e*s1)/(s1+s2);\n\t\t}\n\t};\n\tstruct Circle{\n\t\tPoint o;\n\t\tDouble r;\n\t\tCircle(Point o=Point(),Double r=0):o(o),r(r){}\n\t\tCircle(Double x,Double y,Double r):o(Point(x,y)),r(r){}\n\t\tbool operator==(const Circle& rhs)const{return o==rhs.o&&r==rhs.r;}\n\t\tbool operator<(const Circle& rhs)const{return o<rhs.o||(o==rhs.o&&r<rhs.r);}\n\t\tDouble area()const{return r*r*pi;}\n\t\tDouble circum()const{return r*pi*2;}\n\t\t/* -1: in, 0: on, 1: out */\n\t\tint relation(const Point& rhs)const{\n\t\t\tDouble d=o.dist(rhs);\n\t\t\tif(d<r)\treturn -1;\n\t\t\tif(d==r)\treturn 0;\n\t\t\telse return 1;\n\t\t}\n\t\t/* -1: somewhere inside, 0: intersect once, 1: totally outside */\n\t\tint relationseg(const Line& rhs)const{\n\t\t\tDouble d=rhs.distasseg(o);\n\t\t\tif(d<r)\treturn -1;\n\t\t\tif(d==r)\treturn 0;\n\t\t\telse return 1;\n\t\t}\n\t\t/* -1: somewhere inside, 0: tangent, 1: totally outside */\n\t\tint relationline(const Line& rhs)const{\n\t\t\tDouble d=rhs.distasline(o);\n\t\t\tif(d<r)\treturn -1;\n\t\t\tif(d==r)\treturn 0;\n\t\t\telse return 1;\n\t\t}\n\t\t/* -3: equal\n\t\t   -2: contain\n\t\t   -1: in tangent\n\t\t    0: intersect\n\t\t    1: ex tangent\n\t\t    2: separate */\n\t\tint relation(const Circle& rhs)const{\n\t\t\tif(*this==rhs)\treturn -3;\n\t\t\tDouble d=o.dist(rhs.o), l=abs(r-rhs.r);\n\t\t\tif(d>r+rhs.r)\treturn 2;\n\t\t\tif(d==r+rhs.r)\treturn 1;\n\t\t\tif(d>l)\treturn 0;\n\t\t\tif(d==l)\treturn -1;\n\t\t\treturn -2;\n\t\t}\n\t\tDouble area(const Circle& rhs)const{\n\t\t\tint rel = relation(rhs);\n\t\t\tif(rel>=1)\treturn 0;\n\t\t\tif(rel<=-1)\treturn min(area(),rhs.area());\n\t\t\tDouble d=o.dist(rhs.o);\n\t\t\tDouble a1=acos((r*r+d*d-rhs.r*rhs.r)/(d*r*2));\n\t\t\tDouble a2=acos((rhs.r*rhs.r+d*d-r*r)/(d*rhs.r*2));\n\t\t\treturn r*r*a1+rhs.r*rhs.r*a2-r*d*sin(a1);\n\t\t}\n\t\tfriend ostream & operator << (ostream& os, const Circle& rhs){\n\t\t\tos << rhs.o << ' ' << rhs.r;\n\t\t\treturn os;\n\t\t}\n\t\tfriend istream & operator >> (istream& is, Circle& rhs){\n\t\t\tis >> rhs.o >> rhs.r;\n\t\t\treturn is;\n\t\t}\n\t\tfriend vector<Point> intersectCL(const Circle& C,const Line& L){\n\t\t\tint rel=C.relationline(L);\n\t\t\tPoint proj=L.projection(C.o);\n\t\t\tif(rel==1)\treturn {};\n\t\t\telse if(rel==0)\treturn {proj};\n\t\t\telse{\n\t\t\t\tDouble d=L.distasline(C.o);\n\t\t\t\td=sqrt(C.r*C.r-d*d);\n\t\t\t\tvector<Point> res;\n\t\t\t\tres.emplace_back(proj+(L.e-L.s).resize(d));\n\t\t\t\tres.emplace_back(proj-(L.e-L.s).resize(d));\n\t\t\t\tif(res[1]<res[0])\n\t\t\t\t\tswap(res[0],res[1]);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\t/* be careful for two identical circles */\n\t\tfriend vector<Point> intersectCC(const Circle& Cl,const Circle& Cr){\n\t\t\tint rel=Cl.relation(Cr);\n\t\t\tif(rel<=-2||rel>=2)\treturn {};\n\t\t\tDouble d=Cl.o.dist(Cr.o);\n\t\t\tDouble l=(d*d+Cl.r*Cl.r-Cr.r*Cr.r)/(d*2);\n\t\t\tDouble h=sqrt(Cl.r*Cl.r-l*l);\n\t\t\tPoint proj=Cl.o+(Cr.o-Cl.o).resize(l);\n\t\t\tPoint i1=proj+(Cr.o-Cl.o).rotneg().resize(h);\n\t\t\tPoint i2=proj+(Cr.o-Cl.o).rotpos().resize(h);\n\t\t\tif(rel!=0)\treturn {i1};\n\t\t\tif(i1<i2)\treturn {i1,i2};\n\t\t\telse\t\treturn {i2,i1};\n\t\t}\n\t\t/* the first point is always P */\n\t\t/* the order is ccw about vector(PT)*/\n\t\tfriend vector<Line> tangentCP(const Circle& C,const Point& P){\n\t\t\tint rel=C.relation(P);\n\t\t\tif(rel==-1)\treturn {};\n\t\t\tif(rel==0)\treturn {Line(P,P+(P-C.r).rotpos())};\n\t\t\tDouble d=P.dist(C.o);\n\t\t\tDouble l=C.r*C.r/d;\n\t\t\tDouble h=sqrt(C.r*C.r-l*l);\n\t\t\tPoint i1=C.o+(P-C.o).resize(l)+(P-C.o).rotneg().resize(h);\n\t\t\tPoint i2=C.o+(P-C.o).resize(l)+(P-C.o).rotpos().resize(h);\n\t\t\treturn {Line(P,i1),Line(P,i2)};\n\t\t}\n\t\t/* order is ccw with respect to Cl */\n\t\t/* first point is on Cl */\n\t\tfriend vector<Line> extanCC(const Circle& Cl,const Circle& Cr){\n\t\t\tint rel=Cl.relation(Cr);\n\t\t\tif(rel<-1)\treturn {};\n\t\t\tif(Cl.r==Cr.r){\n\t\t\t\tPoint dir=Cr.o-Cl.o;\n\t\t\t\tdir=dir.rotpos().resize(Cl.r);\n\t\t\t\treturn {Line(Cl.o-dir,Cr.o-dir),Line(Cl.o+dir,Cr.o+dir)};\n\t\t\t}\n\t\t\tPoint p=(Cl.o*(-Cr.r)+Cr.o*Cl.r)/(Cl.r-Cr.r);\n\t\t\tvector<Line> resl=tangentCP(Cl,p),resr=tangentCP(Cr,p);\n\t\t\tif(resl.size()==1)\n\t\t\t\treturn resl;\n\t\t\telse\n\t\t\t\treturn {Line(resl[0].e,resr[0].e),Line(resl[1].e,resr[1].e)};\n\t\t}\n\t\t/* order is ccw with respect to Cl */\n\t\t/* first point is on Cl */\n\t\tfriend vector<Line> intanCC(const Circle& Cl,const Circle& Cr){\n\t\t\tint rel=Cl.relation(Cr);\n\t\t\tif(rel<=0)\treturn {};\n\t\t\tPoint p=(Cl.o*Cr.r+Cr.o*Cl.r)/(Cl.r+Cr.r);\n\t\t\tvector<Line> resl=tangentCP(Cl,p),resr=tangentCP(Cr,p);\n\t\t\tif(resl.size()==1)\n\t\t\t\treturn resl;\n\t\t\telse\n\t\t\t\treturn {Line(resl[0].e,resr[0].e),Line(resl[1].e,resr[1].e)};\n\t\t}\n\t};\n\n\t/* Triangle Centers */\n\tPoint incenter(const Point& A,const Point& B,const Point& C){\n\t\tauto a=(B-C).len(),b=(A-C).len(),c=(A-B).len();\n\t\treturn (A*a+B*b+C*c)/(a+b+c);\n\t}\n\tPoint circenter(const Point& A,const Point& B,const Point& C){\n\t\tLine u((A+B)/2,(A+B)/2+(B-A).rotpos());\n\t\tLine v((A+C)/2,(A+C)/2+(C-A).rotpos());\n\t\treturn intersectLL(u,v);\n\t}\n\tPoint masscenter(const Point& A,const Point& B,const Point& C){\n\t\treturn (A+B+C)/3;\n\t}\n\tPoint orthocenter(const Point& A,const Point& B,const Point& C){\n\t\treturn masscenter(A,B,C)*3-circenter(A,B,C)*2;\n\t}\n\n\t/* not necessary convex */\n\tstruct Polygon:vector<Point>{\n\t\tbool isconvex()const{\n\t\t\tbool flagl=false,flagr=false;\n\t\t\tfor(int i=0;i<size();i++){\n\t\t\t\tint j=(i+1)%size(),k=(j+1)%size();\n\t\t\t\tauto z=(at(i)-at(j))^(at(k)-at(j));\n\t\t\t\tif(z<0)\tflagl=true;\n\t\t\t\tif(z>0)\tflagr=true;\n\t\t\t\tif(flagl&&flagr)\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t/* negative then clockwise, ccw if positive */\n\t\tT area2()const{\n\t\t\tT res=0;\n\t\t\tfor(int i=0;i<size();i++)\n\t\t\t\tres+=(at(i)^at((i+1)%size()));\n\t\t\treturn res;\n\t\t}\n\t\tDouble area()const{return abs(area2())/2;}\n\t\tDouble circum()const{\n\t\t\tDouble res=0;\n\t\t\tfor(int i=0;i<size();i++)\n\t\t\t\tres+=at(i).dist(at((i+1)%size()));\n\t\t\treturn res;\n\t\t}\n\t\t/* 3: as vertex, 2: onseg, 1: interior, 0: exterior */\n\t\tint relation(const Point& p)const{\n\t\t\tint n=size();\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tif(p==at(i))\n\t\t\t\t\treturn 3;\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tPoint s=at(i),e=at((i+1)%n);\n\t\t\t\tif(Line(s,e).onseg(p))\treturn 2;\n\t\t\t\tif(s.y-e.y>0)\ts=at((i+1)%n),e=at(i);\n\t\t\t\tif(p.y>=e.y||p.y<s.y)\tcontinue;\n\t\t\t\tif(Line(s,e).where(p)==-1)\tcnt++;\n\t\t\t}\n\t\t\treturn cnt&1;\n\t\t}\n\t};\n\tstruct Convex:Polygon{\n\t\t/* P should contain at least two \"different\" points */\n\t\t/* ccw, first point is defined by sort */\n\t\tConvex(vector<Point> P={},bool border=false){\n\t\t\tif(P.size()<=1){\n\t\t\t\tclear();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsort(P.begin(),P.end());\n\t\t\templace_back(P[0]),emplace_back(P[1]);\n\t\t\tfor(int i=2;i<P.size();i++){\n\t\t\t\tif(border)\n\t\t\t\t\twhile(size()>=2&&((back()-at(size()-2))^(P[i]-at(size()-2)))<0)\n\t\t\t\t\t\tpop_back();\n\t\t\t\telse\n\t\t\t\t\twhile(size()>=2&&((back()-at(size()-2))^(P[i]-at(size()-2)))<=0)\n\t\t\t\t\t\tpop_back();\n\t\t\t\templace_back(P[i]);\n\t\t\t}\n\t\t\tfor(int i=P.size()-2,t=size();i>=0;i--){\n\t\t\t\tif(border)\n\t\t\t\t\twhile(size()>t&&((back()-at(size()-2))^(P[i]-at(size()-2)))<0)\n\t\t\t\t\t\tpop_back();\n\t\t\t\telse\n\t\t\t\t\twhile(size()>t&&((back()-at(size()-2))^(P[i]-at(size()-2)))<=0)\n\t\t\t\t\t\tpop_back();\n\t\t\t\templace_back(P[i]);\n\t\t\t}\n\t\t\tpop_back();\n\t\t\tif(size()<=1||(size()==2&&at(0)==at(1)))\tclear();\n\t\t}\n\t\tDouble diameter()const{\n\t\t\tif(size()<=1)\treturn 0;\n\t\t\tif(size()==2)\treturn at(0).dist(at(1));\n\t\t\tint n=size(),q=1;\n\t\t\tDouble res=0;\n\t\t\tconst vector<Point> &v=*this;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint j=(i+1)%n;\n\t\t\t\twhile(((v[j]-v[i])^(v[q]-v[i]))<((v[j]-v[i])^(v[(q+1)%n]-v[i])))\n\t\t\t\t\tq=(q+1)%n;\n\t\t\t\tres=max(res,max(v[i].dist(v[q]),v[j].dist(v[(q+1)%n])));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t/* get the left hand side of the convex polygon */\n\t\tConvex cut(const Line& l)const{\n\t\t\tConvex res;\n\t\t\tfor(int i=0,n=size();i<n;i++){\n\t\t\t\tint p=l.where(at(i)),q=l.where(at((i+1)%n));\n\t\t\t\tif(p<=0)\tres.emplace_back(at(i));\n\t\t\t\tif(p*q<0)\tres.emplace_back(intersectLL(l,Line(at(i),at((i+1)%n))));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tbool inconvex(const Point& p)const{\n\t\t\tconst vector<Point>& c=*this;\n\t\t\tint L=1,R=c.size()-1;\n\t\t\tif(((p-c[0])^(c[L]-c[0]))>0)\treturn false;\n\t\t\tif(((p-c[0])^(c[R]-c[0]))<0)\treturn false;\n\t\t\twhile(L<R){\n\t\t\t\tint mid=(L+R+1)>>1;\n\t\t\t\tif(((p-c[0])^(c[mid]-c[0]))<=0)\tL=mid;\n\t\t\t\telse\tR=mid-1;\n\t\t\t}\n\t\t\tif(L==c.size()-1)\tL--;\n\t\t\treturn ((p-c[L])^(c[L+1]-c[L]))<=0;\n\t\t}\n\t\t/* Minkowski Sum */\n\t\t/* ccw, call hull for Pp,Pq beforehand */\n\t\tConvex operator+(const Convex& rhs)const{\n\t\t\tConvex Pr;\n\t\t\tconst Convex& Pp = *this;\n\t\t\tconst Convex& Pq = rhs;\n\t\t\tint n=Pp.size(),m=Pq.size();\n\t\t\tPr.emplace_back(Pp[0]+Pq[0]);\n\t\t\tfor(int i=0,j=0;i!=n||j!=m;){\n\t\t\t\tPoint nxt;\n\t\t\t\tif((j==m)||(i!=n&&((Pp[(i+1)%n]-Pp[i])^(Pq[(j+1)%m]-Pq[j]))>=0)){\n\t\t\t\t\tnxt=Pr.back()+Pp[(i+1)%n]-Pp[i];\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnxt=Pr.back()+Pq[(j+1)%m]-Pq[j];\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\twhile(Pr.size()>=2&&((Pr.back()-nxt)^(Pr[Pr.size()-2]-nxt))==0)\n\t\t\t\t\tPr.pop_back();\n\t\t\t\tPr.emplace_back(nxt);\n\t\t\t}\n\t\t\treturn Pr.pop_back(),Pr;\n\t\t}\n\t\tConvex& operator+=(const Convex& rhs){return *this = *this + rhs,*this;}\n\t};\n}\n/* End of Geo2D */\n\nusing namespace Geo2D;\n\n/* LightOJ 1203: angle\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint T;\n\tcin>>T;\n\tfor(int t=1;t<=T;t++){\n\t\tdouble ans = inf;\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<Point> res(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>res[i].x>>res[i].y;\n\t\tres = hull(res);\n\t\tif(res.empty())\tans = 0;\n\t\telse{\n\t\t\tfor(int i=0;i<res.size();i++){\n\t\t\t\tint j =(i+1)%res.size(),k=(j+1)%res.size();\n\t\t\t\tans = min(ans,angle(res[i],res[j],res[k]));\n\t\t\t}\n\t\t}\n\t\tcout<<fixed<<setprecision(10);\n\t\tcout<<\"Case \"<<t<<\": \"<<ans/pi*180<<endl;\n\t}\n}\n*/\n\n/* LibreOJ 2549 */\n/*\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m, q;\n    cin >> n >> m >> q;\n    vector<Point> Pp(n), Pq(m);\n    for (int i = 0; i < n; i++) cin >> Pp[i];\n    for (int i = 0; i < m; i++) {\n        cin >> Pq[i];\n        Pq[i]=-Pq[i];\n    }\n    Convex c = Convex(Pp)+Convex(Pq);\n    while (q--) {\n        Point P;\n        cin >> P;\n        cout << c.inconvex(P) << '\\n';\n    }\n}\n*/\n\n\n\n/* Aizu CGL 1 A */\n/* Aizu CGL 1 B */\n/*\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tPoint s,e;\n\tcin>>s.x>>s.y>>e.x>>e.y;\n\tLine L(s,e);\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tPoint p;\n\t\tcin>>p.x>>p.y;\n\t\t// p = L.projection(p);\n\t\tp = L.symmetry(p);\n\t\tcout<<fixed<<setprecision(15)<<p.x<<' '<<p.y<<'\\n';\n\t}\n}\n*/\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tvector<Point> v(n);\n\tfor(int i=0;i<n;i++)\n\t\tcin>>v[i];\n\tDouble ans=inf;\n\tcloset_pair(v,0,n-1,ans);\n\tcout<<fixed<<setprecision(15)<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nconst int maxn = 200001;\nconst double inf = 1e60;\n\nstruct point\n{\n\tdouble x,y;\n\tbool flag;\n}pp[maxn],t[maxn];\n\nint n;\n\ninline bool cmpxy(const point &a,const point &b)\n{\n\tif(a.x == b.x)return a.y < b.y;\n\treturn a.x < b.x;\n}\n\ninline bool cmpy(const point &a,const point &b)\n{\n\treturn a.y < b.y;\n}\n\ninline double sqr(double a)\n{\n\treturn a * a;\n}\n\ninline double dis(point a,point b)\n{\n\treturn sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\n\ndouble doit(int l,int r)\n{\n\tif(l == r)return inf;\n\tif(l + 1 == r)return ((pp[l].flag != pp[r].flag) ? dis(pp[l],pp[r]) : inf);\n\tif(l + 2 == r)\n\t{\n        if( pp[l].flag == pp[l + 1].flag )  \n        {  \n            if(pp[l].flag == pp[l + 2].flag )    \n\t\t\t\treturn inf;\n            else    return min( dis(pp[l],pp[l + 2]),dis(pp[l + 1],pp[l + 2]) );  \n        }  \n        else  \n        {  \n            if( pp[l].flag == pp[l + 2].flag )    \n\t\t\t\treturn min( dis(pp[l],pp[l+1]),dis(pp[l+2],pp[l+1]) );  \n            else return  min( dis(pp[l],pp[l+1]),dis(pp[l],pp[l+2]) );  \n        }  \n        return min( dis(pp[l],pp[r]),min( dis(pp[l],pp[l+1]),dis(pp[l+1],pp[r]) ) );  \n\t}\n\tint mid = (l + r) >> 1;\n\tdouble ans = min(doit(l,mid),doit(mid + 1,r));\n\tint tot = 0;\n\tfor(int i = l;i <= r;i ++)\n\t\tif(fabs(pp[i].x - pp[mid].x) <= ans )\n\t\t\tt[++ tot] = pp[i];\n\tsort(t + 1,t + tot + 1,cmpy);\n\tfor(int i = 1;i <= tot;i ++)\n\t\tfor(int j = i + 1;j <= tot && t[j].y - t[i].y < ans;j ++)\n\t\t\tans = min(ans,((t[i].flag != t[j].flag) ? dis(t[i],t[j]) : inf));\n\treturn ans;\n}\n\nint main()\n{\n\t\t\tscanf(\"%d\",&n);\n\t\t\tn *= 2;\n\t\t\tfor(int i = 1;i <= n / 2;i ++)\n\t\t\t\tscanf(\"%lf%lf\",&pp[i].x,&pp[i].y),pp[i].flag = false;\n\t\t\tfor(int i = n / 2 + 1;i <= n;i ++)\n\t\t\t\tscanf(\"%lf%lf\",&pp[i].x,&pp[i].y),pp[i].flag = true;\n\t\t\tsort(pp + 1,pp + n + 1,cmpxy);\n\t\t\tprintf(\"%.10f\\n\",doit(1,n));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\ntypedef db T;\nconst db eps = 1e-8;\nint sgn(T x){return (x>eps)-(x<-eps);}\nstruct P{\n    T x,y;\n    P(){} P(T x,T y):x(x),y(y){}\n    void read(){scanf(\"%lf%lf\",&x,&y);}\n    P operator - (const P&b) const {return P(x-b.x,y-b.y);}\n    P operator + (const P&b) const {return P(x+b.x,y+b.y);}\n    T operator * (const P&b) const {return x*b.x+y*b.y;}\n    P operator * (const T&k) const {return P(x*k,y*k);}\n    T operator ^ (const P&b) const {return x*b.y-y*b.x;}\n    bool operator < (const P&b) const {return sgn(y-b.y)?y<b.y:x<b.x;}\n};\nT abs(P a){return sqrt(a*a);}\n\nnamespace NearestPoints{\n    T Min;P tmp[100000];\n    void Update(T d) {Min = min(Min , d);}\n    T solve(int l,int r,vector<P>&p){\n        if(l == r) return 1e100;\n        int m=(l+r)>>1;\n        T Xm = p[m].x , lim = min(solve(l,m,p) , solve(m+1,r,p));\n        int i=l,j=m+1,ii=m,jj=r,k=l;\n        while(i<=ii||j<=jj) tmp[k++] = p[(i<=ii&&(j>jj||p[i].x<p[j].x)?i:j)++];\n        vector<P> V;\n        rep(i,l,r+1){\n            p[i] = tmp[i];\n            if(fabs(p[i].x - Xm) <= lim) V.pb(p[i]);\n        }\n        rep(i,0,sz(V)) rep(j,i+1,sz(V)){\n            if(fabs(V[j].y - V[i].y) >= lim) break;\n            T dis = abs(V[i]-V[j]);\n            Update(dis);lim = min(lim,dis);\n        }\n        return lim;\n    }\n    T solve(vector<P> A){\n        Min = 1e100;\n        solve(0,sz(A)-1,A);\n        return Min;\n    }\n}\n\nint main(){\n    int n;scanf(\"%d\",&n);\n    vector<P> A;\n    rep(i,0,n){\n        P p;p.read();\n        A.pb(p);\n    }\n    printf(\"%.10f\\n\",NearestPoints::solve(A));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(50, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(50, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + 1].first - p2[i].first) * (p2[i + 1].first - p2[i].first) + (p2[i + 1].second - p2[i].second) * (p2[i + 1].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ header\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i8   = int8_t;\nusing u8   = uint8_t;\nusing i16  = int16_t;\nusing u16  = uint16_t;\nusing i32  = int32_t;\nusing u32  = uint32_t;\nusing i64  = int64_t;\nusing u64  = uint64_t;\nusing i128 = __int128_t;\nusing u128 = __uint128_t;\n\nusing f32  = float;\nusing f64  = double;\nusing f80  = __float80;\nusing f128 = __float128;\n// }}}\n\nconstexpr i64 INF = 1'010'000'000'000'000'000LL;\n\nconstexpr i64 MOD = 1'000'000'007LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// {{{ util\n#define FOR(i, start, end) for(i64 i = (start), i##_end=(end); i < i##_end; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(begin(cccc), end(cccc), ## __VA_ARGS__); })(c))\n#define SLICE(f,c,l,r,...) (([&](decltype((c)) cccc, decltype((l)) llll, decltype((r)) rrrr) {\\\n    auto iiii = llll <= rrrr ? begin(cccc)+llll : end(cccc);\\\n    auto jjjj = llll <= rrrr ? begin(cccc)+rrrr : end(cccc);\\\n    return (f)(iiii, jjjj, ## __VA_ARGS__);\\\n})(c,l,r))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n\ntemplate<typename C>\ni64 SIZE(const C& c) { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\nbool is_odd (i64 x) { return x % 2 != 0; }\nbool is_even(i64 x) { return x % 2 == 0; }\n\ntemplate<typename T> i64 cmp(T x, T y) { return (y<x) - (x<y); }\ntemplate<typename T> i64 sgn(T x) { return cmp(x, T(0)); }\n\n// Haskell の divMod と同じ\npair<i64,i64> divmod(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r<0) || (b<0 && r>0)) {\n        --q;\n        r += b;\n    }\n    return {q,r};\n}\n\ni64 div_ceil(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r>0) || (b<0 && r<0))\n        ++q;\n    return q;\n}\n\ni64 div_floor(i64 a, i64 b) {\n    return divmod(a,b).first;\n}\n\ni64 modulo(i64 a, i64 b) {\n    return divmod(a,b).second;\n}\n\nbool feq(f64 x, f64 y, f64 eps=EPS) {\n    return fabs(x-y) < eps;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename ForwardIt, typename UnaryOperation>\nForwardIt transform_self(ForwardIt first, ForwardIt last, UnaryOperation op) {\n    return transform(first, last, first, op);\n}\n\ntemplate<typename C>\nvoid UNIQ(C& c) {\n    c.erase(ALL(unique,c), end(c));\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc bf, UnaryFunc uf) {\n    return [bf,uf](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef PROCON_LOCAL\n    assert(cin);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, i64 n) {\n    v.reserve(n);\n    REP(_, n) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n    for(auto first = begin(v), it = first; it != end(v); ++it) {\n        if(it != first)\n            out << ' ';\n        out << *it;\n    }\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS& ...args) {\n    cout << x;\n    if(sizeof...(args)) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS& ...args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \" << value << \"\\n\";\n#endif\n}\n\n#define DBG(expr) DBG_IMPL(__LINE__, #expr, (expr))\n// }}}\n\n// {{{ init\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\nstruct Vector {\n    f64 x, y;\n\n    Vector() : Vector(0,0) {}\n    Vector(f64 xx, f64 yy) : x(xx), y(yy) {}\n\n    const Vector operator-() const {\n        return Vector(-x,-y);\n    }\n    Vector& operator+=(const Vector& rhs) {\n        x += rhs.x;\n        y += rhs.y;\n        return *this;\n    }\n    Vector& operator-=(const Vector& rhs) {\n        x -= rhs.x;\n        y -= rhs.y;\n        return *this;\n    }\n    Vector& operator*=(f64 rhs) {\n        x *= rhs;\n        y *= rhs;\n        return *this;\n    }\n    Vector& operator/=(f64 rhs) {\n        x /= rhs;\n        y /= rhs;\n        return *this;\n    }\n\n    f64 norm() const { return x*x + y*y; }\n    f64 abs() const { return sqrt(norm()); }\n\n    Vector unit() const { return Vector(*this) /= this->abs(); }\n};\n\nconst Vector operator+(const Vector& lhs, const Vector& rhs) { return Vector(lhs) += rhs; }\nconst Vector operator-(const Vector& lhs, const Vector& rhs) { return Vector(lhs) -= rhs; }\nconst Vector operator*(const Vector& lhs, f64 rhs) { return Vector(lhs) *= rhs; }\nconst Vector operator*(f64 lhs, const Vector& rhs) { return Vector(rhs) *= lhs; }\nconst Vector operator/(const Vector& lhs, f64 rhs) { return Vector(lhs) /= rhs; }\n\nbool operator==(const Vector& lhs, const Vector& rhs) {\n    return feq(lhs.x,rhs.x) && feq(lhs.y,rhs.y);\n}\n\nf64 geo_dot(const Vector& lhs, const Vector& rhs) {\n    return lhs.x*rhs.x + lhs.y*rhs.y;\n}\n\nf64 geo_cross(const Vector& lhs, const Vector& rhs) {\n    return lhs.x*rhs.y - lhs.y*rhs.x;\n}\n\nVector geo_rotate(const Vector& v, f64 t) {\n    return Vector(v.x*cos(t)-v.y*sin(t), v.x*sin(t)+v.y*cos(t));\n}\n\nenum ABC {\n    ABC_CCW        =  1,\n    ABC_CW         = -1,\n    ABC_ON_BACK    =  2,\n    ABC_ON_FRONT   = -2,\n    ABC_ON_SEGMENT =  0,\n};\n\nABC geo_abc(const Vector& a, const Vector& b, const Vector& c) {\n    Vector x = b - a;\n    Vector y = c - a;\n    f64 cross = geo_cross(x,y);\n    if(cross > 0) return ABC_CCW;\n    if(cross < 0) return ABC_CW;\n    f64 dot = geo_dot(x,y);\n    if(dot < 0) return ABC_ON_BACK;\n    if(x.norm() < y.norm()) return ABC_ON_FRONT;\n    return ABC_ON_SEGMENT;\n}\n\nenum Containment {\n    CONT_IN,\n    CONT_ON,\n    CONT_OUT,\n};\n\nostream& operator<<(ostream& out, const Vector& v) {\n    return out << \"Vector(\" << v.x << \",\" << v.y << \")\";\n}\n\nstruct Segment {\n    Vector p1, p2;\n\n    Segment(const Vector& pp1, const Vector& pp2) : p1(pp1), p2(pp2) {}\n    Segment(f64 x1, f64 y1, f64 x2, f64 y2) : p1(Vector(x1,y1)), p2(Vector(x2,y2)) {}\n\n    Vector vec() const { return p2 - p1; }\n\n    f64 norm() const { return vec().norm(); }\n    f64 abs() const { return vec().abs(); }\n};\n\nostream& operator<<(ostream& out, const Segment& seg) {\n    out << \"Segment(\";\n    out << \"(\" << seg.p1.x << \",\" << seg.p1.y << \")\";\n    out << \",\";\n    out << \"(\" << seg.p2.x << \",\" << seg.p2.y << \")\";\n    out << \")\";\n    return out;\n}\n\nstruct Line {\n    Vector p1, p2;\n\n    Line(const Vector& pp1, const Vector& pp2) : p1(pp1), p2(pp2) {}\n    Line(f64 x1, f64 y1, f64 x2, f64 y2) : p1(Vector(x1,y1)), p2(Vector(x2,y2)) {}\n    explicit Line(const Segment& seg) : p1(seg.p1), p2(seg.p2) {}\n\n    Vector vec() const { return p2 - p1; }\n};\n\nostream& operator<<(ostream& out, const Line& line) {\n    out << \"Line(\";\n    out << \"(\" << line.p1.x << \",\" << line.p1.y << \")\";\n    out << \",\";\n    out << \"(\" << line.p2.x << \",\" << line.p2.y << \")\";\n    out << \")\";\n    return out;\n}\n\nstruct Circle {\n    Vector c;\n    f64 r;\n\n    Circle(const Vector& cc, f64 rr) : c(cc), r(rr) {}\n};\n\nostream& operator<<(ostream& out, const Circle& cir) {\n    out << \"Circle(\";\n    out << \"(\" << cir.c.x << \",\" << cir.c.y << \")\";\n    out << \",\";\n    out << cir.r;\n    out << \")\";\n    return out;\n}\n\nstruct Polygon {\n    vector<Vector> ps;\n\n    explicit Polygon(const vector<Vector>& ps_arg) : ps(ps_arg) {}\n\n    f64 area_2x() const {\n        i64 n = SIZE(ps);\n        if(n < 3) return 0;\n        f64 sum = 0;\n        REP(i, n) {\n            sum += geo_cross(cur(i), nex(i));\n        }\n        return fabs(sum);\n    }\n    f64 area() const { return area_2x() / 2; }\n\n    // 凸性判定(全ての内角が180度以下)\n    // 3点が同一直線上にあるケースは許容する(この辺ちょっと怪しい)\n    // 2角形以下の場合 false を返す\n    bool is_convex() const {\n        i64 n = SIZE(ps);\n        if(n < 3) return false;\n        i64 abc = 0;\n        REP(i, n) {\n            ABC abc_cur = geo_abc(pre(i), cur(i), nex(i));\n            if(abc_cur != ABC_CCW && abc_cur != ABC_CW) continue;\n            if(abc_cur*abc == -1) return false;\n            abc = abc_cur;\n        }\n        return true;\n    }\n\n    // 点の包含判定\n    // 2角形以下の場合 CONT_OUT を返す\n    Containment containment(const Vector& p) const {\n        i64 n = SIZE(ps);\n        if(n < 3) return CONT_OUT;\n        i64 cnt = 0;\n        REP(i, n) {\n            Vector a = cur(i) - p;\n            Vector b = nex(i) - p;\n            if(feq(geo_cross(a,b),0) && geo_dot(a,b) <= 0) return CONT_ON;\n            if(a.y > b.y) swap(a,b);\n            if(a.y <= 0 && b.y > 0 && geo_cross(a,b) > 0) ++cnt;\n        }\n        return is_odd(cnt) ? CONT_IN : CONT_OUT;\n    }\n\n    Vector cur(i64 i) const { return ps[i]; }\n    Vector pre(i64 i) const { return ps[modulo(i-1,SIZE(ps))]; }\n    Vector nex(i64 i) const { return ps[modulo(i+1,SIZE(ps))]; }\n};\n\nostream& operator<<(ostream& out, const Polygon& poly) {\n    out << \"Polygon(\";\n    i64 n = SIZE(poly.ps);\n    REP(i, n) {\n        const Vector& p = poly.ps[i];\n        out << \"(\" << p.x << \",\" << p.y << \")\";\n        if(i != n-1)\n            out << \",\";\n    }\n    out << \")\";\n    return out;\n}\n\nVector geo_project(const Line& line, const Vector& p) {\n    Vector v = line.vec();\n    f64 r = geo_dot(p-line.p1, v) / v.norm();\n    return line.p1 + r*v;\n}\n\nbool geo_intersect(const Segment& x, const Segment& y) {\n    return geo_abc(x.p1,x.p2,y.p1) * geo_abc(x.p1,x.p2,y.p2) <= 0 &&\n           geo_abc(y.p1,y.p2,x.p1) * geo_abc(y.p1,y.p2,x.p2) <= 0;\n}\n\nbool geo_intersect(const Circle& cir1, const Circle& cir2) {\n    return (cir1.c-cir2.c).norm() <= pow(cir1.r+cir2.r,2);\n}\n\nf64 geo_distance(const Line& line, const Vector& p) {\n    Vector v = line.vec();\n    return fabs(geo_cross(v,p-line.p1)) / v.abs();\n}\n\nf64 geo_distance(const Segment& seg, const Vector& p) {\n    if(geo_dot( seg.vec(), p-seg.p1) < 0) return (p-seg.p1).abs();\n    if(geo_dot(-seg.vec(), p-seg.p2) < 0) return (p-seg.p2).abs();\n    return geo_distance(Line(seg), p);\n}\n\nf64 geo_distance(const Segment& seg1, const Segment& seg2) {\n    if(geo_intersect(seg1,seg2)) return 0;\n    return min({\n        geo_distance(seg1, seg2.p1),\n        geo_distance(seg1, seg2.p2),\n        geo_distance(seg2, seg1.p1),\n        geo_distance(seg2, seg1.p2),\n    });\n}\n\nbool geo_intersect(const Circle& cir, const Line& line) {\n    return geo_distance(line, cir.c) <= cir.r;\n}\n\n// 交差判定は既に行われているとする\n// FIXME: 2線分が重なる場合を考慮してない\nVector geo_crosspoint(const Segment& seg1, const Segment& seg2) {\n    Vector v = seg2.vec();\n    f64 d1 = fabs(geo_cross(v, seg1.p1-seg2.p1));\n    f64 d2 = fabs(geo_cross(v, seg1.p2-seg2.p1));\n    return seg1.p1 + (d1/(d1+d2))*seg1.vec();\n}\n\n// 2直線が重なる場合、la.p1 を返す\n// 2直線が平行かつ重ならない場合エラー(先に交差判定すること)\nVector geo_crosspoint(const Line& la, const Line& lb) {\n    Vector a = la.vec();\n    Vector b = lb.vec();\n    f64 d1 = geo_cross(b, lb.p1-la.p1);\n    f64 d2 = geo_cross(b, a);\n    if(feq(d2, 0)) {  // 2直線が平行\n        if(feq(d1, 0)) return la.p1;  // 2直線が重なっている\n        assert(false);\n    }\n    return la.p1 + d1/d2*a;\n}\n\n// 接する場合も同じ座標2つを返す\nvector<Vector> geo_crosspoints(const Circle& cir, const Line& line) {\n    if(!geo_intersect(cir,line)) return {};\n    Vector p = geo_project(line, cir.c);\n    Vector e = line.vec().unit();\n    f64 t = sqrt(cir.r*cir.r - (p-cir.c).norm());\n    return { p+t*e, p-t*e };\n}\n\n// 接する場合も同じ座標2つを返す\nvector<Vector> geo_crosspoints(const Circle& cir1, const Circle& cir2) {\n    if(!geo_intersect(cir1,cir2)) return {};\n    Vector v = cir2.c - cir1.c;\n    f64 d = v.abs();\n    f64 t = acos((cir1.r*cir1.r + d*d - cir2.r*cir2.r) / (2*cir1.r*d));\n    return {\n        cir1.c + geo_rotate(v, t) / d * cir1.r,\n        cir1.c + geo_rotate(v,-t) / d * cir1.r,\n    };\n}\n\n// 凸包 (Andrew's Monotone Chain)\n//\n// * 始点はy座標最小のもののうちx座標最小のもの\n// * 反時計回り\n// * 辺上の点を含む\nPolygon geo_convex_hull(vector<Vector> ps) {\n    i64 n = SIZE(ps);\n    assert(n >= 3);\n\n    vector<Vector> res;\n    res.reserve(n);\n\n    ALL(sort, ps, ON(less<>(), [](const Vector& p) { return make_pair(p.y,p.x); }));\n\n    auto step = [&res](const Vector& p) {\n        while(SIZE(res) >= 2) {\n            i64 k = SIZE(res);\n            // 辺上の点を含めたくなければ \"!= ABC_CW\" を \"== ABC_CCW\" に変える\n            if(geo_abc(res[k-2],res[k-1],p) != ABC_CW) break;\n            res.pop_back();\n        }\n        res.emplace_back(p);\n    };\n\n    // lower hull\n    for(i64 i = 0; i < n; ++i) {\n        step(ps[i]);\n    }\n    // upper hull\n    for(i64 i = n-2; i >= 0; --i) {\n        step(ps[i]);\n    }\n    // 始点が重複するので削除\n    res.pop_back();\n\n    return Polygon(res);\n}\n\n// 凸多角形の直径 (Rotating Calipers)\n//\n// (直径の2乗, index_端点1, index_端点2) を返す\n// convex は凸多角形でなければならない\ntuple<f64,i64,i64> geo_convex_diameter_sq(const Polygon& convex) {\n    const auto& ps = convex.ps;\n    i64 n = SIZE(ps);\n\n    auto cmp_y = ON(less<>(), [](const Vector& p) { return p.y; });\n    i64 istart = ALL(max_element, ps, cmp_y) - begin(ps);\n    i64 jstart = ALL(min_element, ps, cmp_y) - begin(ps);\n\n    auto nex = [n](i64 i) { return modulo(i+1,n); };\n\n    f64 d2max = (ps[istart]-ps[jstart]).norm();\n    i64 i, imax, j, jmax;\n    i = imax = istart;\n    j = jmax = jstart;\n    do {\n        Vector vi = ps[nex(i)] - ps[i];\n        Vector vj = ps[nex(j)] - ps[j];\n        if(geo_cross(vi,vj) >= 0)\n            j = nex(j);\n        else\n            i = nex(i);\n        if(chmax(d2max, (ps[i]-ps[j]).norm())) {\n            imax = i;\n            jmax = j;\n        }\n    } while(i != istart || j != jstart);\n\n    //return { d2max, imax, jmax };\n    // AOJの場合はこっち\n    return make_tuple(d2max, imax, jmax);\n}\n\n// 凸多角形の切断\n//\n// convex は凸多角形でなければならない\nPolygon geo_convex_cut(const Polygon& convex, const Line& line) {\n    const vector<Vector>& ps = convex.ps;\n    i64 n = SIZE(ps);\n    auto nex = [n](i64 i) { return modulo(i+1,n); };\n\n    vector<Vector> res;\n    REP(i, n) {\n        // ps[i] が直線より左または直線上なら ps[i] を追加\n        ABC abc_a = geo_abc(line.p1, line.p2, ps[i]);\n        if(abc_a != ABC_CW)\n            res.emplace_back(ps[i]);\n        // ps[i] が直線より左、かつ ps[i+1] が直線より右なら交点を追加\n        ABC abc_b = geo_abc(line.p1, line.p2, ps[nex(i)]);\n        if(abc_a*abc_b < 0)\n            res.emplace_back(geo_crosspoint(line, Line(ps[i],ps[nex(i)])));\n    }\n    return Polygon(res);\n}\n\nvoid RD(Vector& v) {\n    RD(v.x);\n    RD(v.y);\n}\n\n//--------------------------------------------------------------------\n\ntemplate<typename F>\nauto LT_ON(F f) { return ON(less<>(), f); }\n\ntemplate<typename F>\nauto GT_ON(F f) { return ON(greater<>(), f); }\n\n// geo_closest_pair() 下請け\n// [first,last) はx座標に関してソート済であること\ntemplate<typename RandomIt>\ntuple<f64,RandomIt,RandomIt> geo_closest_pair_sq_impl(RandomIt first, RandomIt last) {\n    i64 n = last - first;\n    if(n <= 1)\n        //return { DBL_MAX, last, last };\n        // AOJの場合はこっち\n        return make_tuple(DBL_MAX, last, last);\n\n    auto mid = first + n/2;\n    f64 x = mid->x;\n    auto res = min(geo_closest_pair_sq_impl(first,mid), geo_closest_pair_sq_impl(mid,last));\n    inplace_merge(first, mid, last, LT_ON([](const Vector& p) { return p.y; }));\n\n    vector<RandomIt> around;\n    for(auto i = first; i != last; ++i) {\n        f64 d = x - i->x;\n        if(d*d >= get<0>(res)) continue;\n        for(auto j = around.rbegin(); j != around.rend(); ++j) {\n            f64 dx = i->x - (*j)->x;\n            f64 dy = i->y - (*j)->y;\n            if(dy*dy >= get<0>(res)) break;\n            f64 cur = dx*dx + dy*dy;\n            if(cur < get<0>(res))\n                //res = { cur, i, *j };\n                // AOJの場合はこっち\n                res = make_tuple(cur, i, *j);\n        }\n        around.emplace_back(i);\n    }\n\n    return res;\n}\n\n// 最近点対\n//\n// (距離の2乗, index_端点1, index_端点2) を返す\n// SIZE(ps) < 2 ならエラー\n// O(nlogn)\ntuple<f64,i64,i64> geo_closest_pair_sq(vector<Vector> ps) {\n    assert(SIZE(ps) >= 2);\n\n    ALL(sort, ps, LT_ON([](const Vector& p) { return p.x; }));\n\n    auto res = ALL(geo_closest_pair_sq_impl, ps);\n    auto i = get<1>(res) - begin(ps);\n    auto j = get<2>(res) - begin(ps);\n    //return { get<0>(res), i, j };\n    // AOJの場合はこっち\n    return make_tuple(get<0>(res), i, j);\n}\n\nvoid solve() {\n    i64 N; RD(N);\n    vector<Vector> ps; RD(ps, N);\n\n    auto t = geo_closest_pair_sq(ps);\n    f64 ans = sqrt(get<0>(t));\n\n    PRINTLN(ans);\n}\n\nsigned main() {\n    \n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&memo >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / acos(-1));\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * acos(-1) / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  // cerr << \"begin [\" << l << \", \" << r << \")\" << endl;\n  if (r - l <= 3) {\n    // cerr << \"[\" << l << \", \" << r << \")\" << endl;\n    PointPoint res(ps[l], ps[r - 1]);\n    // cerr << \"res : \" << res.first << \", \" << res.second << endl;\n    for (int i = l; i < r; ++i) {\n      for (int j = i + 1; j < r; ++j) {\n        // cerr << i << \", \" << j << endl;\n        res = Closer(res, PointPoint(ps[i], ps[j]));\n        // cerr << \"res : \" << res.first << \" \" << res.second << endl;\n      }\n    }\n    // cerr << \"[\" << l << \", \" << r << \") = \" << Distance(res.first, res.second) << endl;\n    return res;\n  }\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  Points strip;\n  for (int i = l; i < r; ++i) {\n    // if (l == 43 && r == 50 && abs(ps[i].real() - midPoint.real()) < d) {\n    //   cerr << i << \" \";\n    // }\n    if (abs(ps[i].real() - midPoint.real()) < d) strip.push_back(ps[i]);\n  }\n  // if (l == 43 && r == 50) cerr << endl;\n\n  for (int i = 0; i < strip.size(); ++i) {\n    for (int j = i + 1; j < strip.size(); ++j) {\n      if (Distance(strip[i], strip[j]) < d) {\n        d = Distance(strip[i], strip[j]);\n        res = PointPoint(strip[i], strip[j]);\n      }\n    }\n  }\n\n  // cerr << \"[\" << l << \", \" << r << \") = \" << Distance(res.first, res.second) << endl;\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  return ClosestPairUtil(ps, 0, ps.size());\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  sort(p.begin(), p.end());\n  PointPoint pp = ClosestPair(p);\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n  // cerr << pp.first << \" \" << pp.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<utility>\n\ntypedef pair<double, double> point;\n\ndouble dist(const point &p1, const point &p2)\n{\n\tdouble dx = p1.first - p2.first;\n\tdouble dy = p1.second - p2.second;\n\treturn sqrt(dx * dx + dy * dy);\n}\n\nbool sort_y(const point &p1, const point &p2){ return p1.second < p2.second; }\n\npoint Z[100000];\n\ndouble closest(point X[], point Y[], int n)\n{\n\tif(n <= 3){\n\t\tdouble d = dist(X[0], X[1]);\n\t\tfor(int i = 0; i < n; i++){ Y[i] = X[i]; }\n\t\tsort(Y, Y + n, sort_y);\n\n\t\tif(n < 3){ return d; }\n\t\telse{ return min(d, min(dist(X[0], X[2]), dist(X[1], X[2]))); }\n\t}\n\tint m = (n >> 1);\n\tdouble median = X[m].first;\n\tdouble d = min(closest(X, Y, m), closest(X + m, Y + m, n - m));\n\n\tint size = 0;\n\tint i = 0, j = m;\n\twhile(i < m && j < n){\n\t\tif(i < m && j < n){\n\t\t\tif(Y[i].second < Y[j].second){\n\t\t\t\tZ[size] = Y[i]; size++; i++;\n\t\t\t}else{\n\t\t\t\tZ[size] = Y[j]; size++; j++;\n\t\t\t}\n\t\t}\n\t\tif(i == m && j < n){ while(j < n){ Z[size] = Y[j]; size++; j++; }; }\n\t\tif(i < m && j == n){ while(i < m){ Z[size] = Y[i]; size++; i++; }; }\n\t};\n\tint resize = 0;\n\tfor(i = 0; i < size; i++){\n\t\tif(fabs(Z[i].first - median) <= d){ Z[resize] = Z[i]; resize++; }\n\t}\n\n\tint a = 0;\n\tfor(i = 1; i < resize; i++){\n\t\tfor(j = a; j < i; j++){\n\t\t\tif(Z[i].second - Z[a].second > d){ a++; }\n\t\t\telse{\n\t\t\t\td = min(d, dist(Z[i], Z[a]));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\n\nint main()\n{\n\tpoint X[100000], Y[100000];\n\tint i, n;\n\tscanf(\"%d\", &n);\n\n\tdouble co_x, co_y;\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &co_x, &co_y);\n\t\tX[i] = make_pair(co_x, co_y);\n\t}\n\tsort(X, X + n);\n\n\tdouble d = closest(X, Y, n);\n\tprintf(\"%.14f\\n\", d);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define SZ(x) (int)(x).size()\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<LL, LL> pll;\n\nconst double eps = 1e-10;\nconst double PI = acos(-1.0);\n//const double PI = 3.14159265358979323846264338327950288419716939937510\nint dcmp(const double &x) { if (fabs(x) < eps) return 0; return x < 0 ? -1 : 1; }\nconst int MOD = 1e9 + 7;\nconst int INF = 2e9;\nconst double INF_d = 1e64;\n\ntemplate<class T> \nT qmod(T a, T b){ T ret = 1; while (b){ if (b & 1) ret *= a; b >>= 1; a *= a; } return ret; }\ntemplate<class T>\nT gcd(T a, T b){ return !b ? a : gcd(b, a % b); }\ntemplate<class T>\nT ex_gcd(T a, T b, T &x, T &y){\n    if (!b){ x = 1, y = 0; return a; }\n    T t, ret;\n    ret = ex_gcd(b, a % b, x, y);\n    t = x, x = y, y = t - a / b * y;\n    return ret;\n}\ntemplate<class T>\nT inv(T t, T p){ return t == 1 ? 1 : (p - p / t) * inv(p % t, p) % p; }\n// head\n\ntypedef double db;\n\nstruct point{\n    db x, y;\n    point(){}\n    point(db a, db b): x(a), y(b){}\n    point operator + (const point &p){ return point(x + p.x, y + p.y); }\n    point operator - (const point &p){ return point(x - p.x, y - p.y); }\n    point operator * (const db &k){ return point(x * k, y * k); }\n    point operator / (const db &k){ return point(x / k, y / k); }\n    db operator ^ (const point &p){ return x * p.y - y * p.x; }\n    db operator * (const point &p){ return x * p.x + y * p.y; }\n    bool operator == (const point &p){ return !dcmp(x - p.x) && !dcmp(y - p.y); }\n    bool operator != (const point &p){ return dcmp(x - p.x) || dcmp(y - p.y); }\n    bool operator < (const point &p){ return x == p.x ? y < p.y : x < p.x; }\n    void read(){\n        scanf(\"%lf%lf\", &x, &y);\n    }\n    void print(){\n        printf(\"%.10f %.10f\\n\", x, y);\n    }\n    point rotate(db &ang){ return point(x * cos(ang) - y * sin(ang), y * cos(ang) + x * sin(ang)); }\n    point norm() { return point(-y, x); }\n    db len() { return sqrt(x * x + y * y); }\n    db len2(){ return x * x + y * y; }\n};\n\npoint err = point(INF_d, INF_d);\n\npoint proj_SP(point A, point B, point P){ // projection point of P in segment AB\n    point AB = B - A, AP = P - A;\n    return A + AB * (AP * AB / AB.len2());\n}\n\npoint refl_SP(point A, point B, point P){ // reflection point of P int segment AB\n    return proj_SP(A, B, P) * 2 - P;\n}\n\nstruct line{\n    point p[2], u;\n    line(){}\n    line(point s, point t){\n        p[0] = s, p[1] = t;\n        u = p[1] - p[0];\n    }\n    point get_point(double t){\n        return point(p[0] + u * t);\n    }\n};\n\nbool parallel(line L1, line L2){ // check whether two lines L1 and L2 are parallel\n    return !dcmp(L1.u ^ L2.u);\n}\n\nbool orthogonal(line L1, line L2){ // check whether two lines L1 and L2 are orthogonal\n    return !dcmp(L1.u * L2.u);\n}\n\npair<bool, point> inter_LL(line L1, line L2){ // calculate the intersection of two lines L1 and L2\n    if (parallel(L1, L2)) return mp(false, err);\n    double t = ((L2.p[0] - L1.p[0]) ^ L2.u) / (L1.u ^ L2.u);\n    return mp(true, L1.get_point(t));\n}\n\nbool one_dimention_check(db a, db b, db c, db d){ // check whether two one-dimention segments has intersection\n    if (dcmp(a - b) > 0) swap(a, b);\n    if (dcmp(c - d) > 0) swap(c, d);\n    return dcmp(b - c) >= 0 && dcmp(a - d) <= 0; \n}\n\nbool check_SS(point A, point B, point C, point D){ // check whether two segments AB and CD has intersection\n    bool flag = one_dimention_check(A.x, B.x, C.x, D.x) && one_dimention_check(A.y, B.y, C.y, D.y);\n    double a = dcmp((A - C) ^ (D - C)), b = dcmp((B - C) ^ (D - C)),\n            c = dcmp((C - A) ^ (B - A)), d = dcmp((D - A) ^ (B - A));\n    return flag && dcmp(a * b) <= 0 && dcmp(c * d) <= 0;\n}\n// calculate the intersection point of two segments, first check and then call inter_LL to get the cross point\n\nbool inmid(db a, db b, db c){  // check whether a <= c <= b\n    return dcmp(dcmp(b - c) * dcmp(a - c)) <= 0; \n}\n\nbool inmid(point A, point B, point P){ // check whether point P is in the rectangle of segment AB\n    return inmid(A.x, B.x, P.x) && inmid(A.y, B.y, P.y);\n}\n\ndb dis_SP(point A, point B, point P){ // the minimum distance from a point P to segment AB\n    point p_proj = proj_SP(A, B, P);\n    if (inmid(A, B, p_proj)) return (P - p_proj).len();\n    else return min((P - A).len(), (P - B).len());\n}\n\ndb dis_SS(point A, point B, point C, point D){ // the minimum distance from two segments AB and CD\n    db res = INF_d;\n    if (check_SS(A, B, C, D)) res = 0;\n    res = min(res, dis_SP(A, B, C));\n    res = min(res, dis_SP(A, B, D));\n    res = min(res, dis_SP(C, D, A));\n    res = min(res, dis_SP(C, D, B));\n    return res;\n}\n\ndb poly_Area(point *poly, int n){ // calc the area of a simple polygon poly, n is the number of points.\n    //the points should be in clockwise or counter_clockwise.\n    db res = 0.0;\n    for (int i = 1; i < n - 1; i++){\n        res += (poly[i] - poly[0]) ^ (poly[i + 1] - poly[0]);\n    }\n    return fabs(res) / 2;\n}\n\nbool is_Convex(point *poly, int n){ // check whether a polygon is a convex polygon. Make sure points are in counter-clockwised order.\n    poly[n] = poly[0];\n    if (n < 3) return 1;\n    for (int i = 1; i < n; i++){\n        int tmp_dir = dcmp((poly[i] - poly[i - 1]) ^ (poly[(i + 1) % n] - poly[i]));\n        if (tmp_dir < 0) return 0;\n    }\n    return 1;\n}\n\nbool is_PonS(point A, point B, point P){ // check whether a point P is on a segment AB\n    return inmid(A, B, P) && !dcmp((P - A) ^ (B - A));\n}\n\nint is_PinPoly(point *poly, int n, point P){ // check the position relation of a point and polygon.\n    // 0: outside, 1: on a segment, 2: inside\n    int pd = 0;\n    for (int i = 0; i < n; i++){\n        point u = poly[i], v = poly[(i + 1) % n];\n        if (is_PonS(u, v, P)) return 1;\n        if (dcmp(u.y - v.y) > 0) swap(u, v);\n        if (dcmp(u.y - P.y) >= 0 || dcmp(v.y - P.y) < 0) continue;\n        if (dcmp((u - v) ^ (P - v)) < 0) pd ^= 1;\n    }\n    return pd << 1;\n}\n\nbool cmpxy(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.x == b.x ? a.y < b.y : a.x < b.x;\n}\n\nbool cmpyx(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.y == b.y ? a.x < b.x : a.y < b.y;\n}\n\nint get_convexhull(point *p, int n, point *ch){ // get the convexhull of given polygon p\n    // pay attention to when m = 0, 1, 2 as the return value\n    sort(p, p + n, cmpyx); // may be changed by the requirement of problem\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        while (m > 1 && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for (int i = n - 2; i >= 0; i--){\n        while (m > k && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    if (n > 1) m--;\n    return m;\n}\n\ndb convexhull_diameter(point *ch, int n){ // calculate the diameter of a give convexhull\n    if (n < 2) return 0;\n    int is, js; is = js = 0;\n    for (int i = 0; i < n; i++){\n        is = ch[i] < ch[is] ? i : is;\n        js = ch[js] < ch[i] ? i : js;\n    }\n    int i = is, j = js;\n    db ret = (ch[is] - ch[js]).len();\n    do{\n        if (dcmp((ch[(i + 1) % n] - ch[i]) ^ (ch[(j + 1) % n] - ch[j])) > 0){\n            j = (j + 1) % n;\n        }\n        else{\n            i = (i + 1) % n;\n        }\n        ret = max(ret, (ch[i] - ch[j]).len());\n    } while (i != is || j != js);\n    return ret;\n}\n\nint convexhull_cut(point *ch, int n, point P, point Q, point *new_ch){\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        int d1 = dcmp((Q - P) ^ (ch[i] - P)), d2 = dcmp((Q - P) ^ (ch[(i + 1) % n] - P));\n        if (d1 >= 0) new_ch[m++] = ch[i];\n        if (d1 * d2 < 0) new_ch[m++] = inter_LL(line(P, Q), line(ch[i], ch[(i + 1) % n])).second;\n    }\n    return m;\n}\n\ndb cloest_pair(point *p, int l, int r){ // find the distance of cloest pair of points in p\n//please make sure that p is sorted by x coordinate\n    if (r - l <= 5){\n        db cloest = INF_d;\n        for (int i = l; i < r; i++){\n            for (int j = i + 1; j < r; j++){\n                cloest = min(cloest, (p[i] - p[j]).len());\n            }\n        }\n        return cloest;\n    }\n    else{\n        int mid = (l + r) >> 1;\n        db cloest = min(cloest_pair(p, l, mid), cloest_pair(p, mid, r));\n        vector<point> v; v.clear();\n        for (int i = l; i < r; i++){\n            if (fabs(p[i].x - p[mid].x) <= cloest) v.pb(p[i]);\n        }\n        sort(v.begin(), v.end(), cmpyx);\n        for (int i = 0; i < SZ(v); i++){\n            for (int j = i + 1; j < SZ(v) && dcmp(v[j].y - v[i].y - cloest) < 0; j++){\n                cloest = min(cloest, (v[i] - v[j]).len());\n            }\n        }\n        return cloest;\n    }\n}\n\nconst int N = 1e5 + 7;\nint n, m, num;\npoint p[N], x, ch[N], y;\n\nint main(){\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++){\n        p[i].read();\n    }\n    sort(p, p + n, cmpxy);\n    printf(\"%.12f\\n\", cloest_pair(p, 0, n));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct F {\n\tlong long a, b;\n\tF() {}\n\tF(long long _a, long long _b) : a(_a), b(_b) {}\n\tF operator + (const F &f) {\n\t\tlong long x = a * f.a, y = b * f.a + a * f.b;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n\tF operator - (const F &f) {\n\t\tlong long x = a * f.a, y = b * f.a - a * f.b;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n\tF operator * (const F &f) {\n\t\tlong long x = a * f.a, y = b * f.b;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n\tF operator / (const F &f) {\n\t\tlong long x = a * f.b, y = b * f.a;\n\t\tlong long g = __gcd(x, y);\n\t\treturn F(x / g, y / g);\n\t}\n};\nconst double pi = acos(-1);\nconst double eps = 1e-8;\ninline int sign(double a) {\n\treturn a < -eps ? -1 : a > eps;\n}\ninline int cmp(double a, double b) {\n\treturn sign(a - b);\n}\ndouble add(double a, double b) {\n\tif (abs(a + b) < eps * (abs(a) + abs(b))) return 0;\n\treturn a + b;\n}\ntypedef double data;\nstruct P {\n\tdata x, y;\n\tP() {}\n\tP(data x, data y) : x(x), y(y) {}\n\tP operator + (const P &p) { return P(x + p.x, y + p.y); }\n\tP operator - (const P &p) { return P(x - p.x, y - p.y); }\n\tP operator * (data d) { return P(x * d, y * d); }\n\tP operator / (data d) { return P(x / d, y / d); }\n\tdata dot(const P &p) { return x * p.x + y * p.y; }\n\tdata det(const P &p) { return x * p.y - y * p.x; }\n\tdata disto(const P &p) { return (*this - p).abs(); }\n\tdata alpha() { return atan2(y, x); }\n\tdata abs() { return sqrt(abs2()); }\n\tdata abs2() { return x * x + y * y; }\n\tP rot90() { P(-y, x); }\n\tP unit() { return *this / abs(); }\n\tbool operator < (P p) const {\n\t\tint c = cmp(x, p.x);\n\t\tif (c) return c == -1;\n\t\treturn cmp(y, p.y) == -1;\n\t}\n\tfriend istream& operator>>(istream &in, P &p) {\n\t\tin >> p.x >> p.y;\n\t\treturn in;\n\t}\n\tfriend ostream& operator<<(ostream& out, P &p) {\n\t\tout << p.x << ' ' << p.y;\n\t\treturn out;\n\t}\n};\nP projection(P p1, P p2, P q) {\n\tP dir = p2 - p1;\n\treturn p1 + dir * (dir.dot(q - p1) / dir.abs2());\n}\nP reflection(P p1, P p2, P q) {\n\treturn projection(p1, p2, q) * 2 - q;\n}\nbool is_midddle(data a, data m, data b) {\n\treturn sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);\n}\nbool is_midddle(P a, P m, P b) {\n\treturn is_midddle(a.x, m.x, b.x) && is_midddle(a.y, m.y, b.y);\n}\nbool on_seg(P p1, P p2, P q) {\n\treturn sign((p1 - q).det(p2 - q)) == 0 && (p1 - q).dot(p2 - q) <= 0;\n\t// return (p1 - q).det(p2 - q) == 0 && is_middle(p1, q, p2);\n}\nbool intersect(data l1, data r1, data l2, data r2) {\n\tif(l1 > r1) swap(l1, r1);\n\tif(l2 > r2) swap(l2, r2);\n\treturn cmp(r1, l2) != -1 && cmp(r2, l1) != -1;\n}\nbool intersect(P p1, P p2, P q1, P q2) {\n\treturn intersect(p1.x, p2.x, q1.x, q2.x) && intersect(p1.y, p2.y, q1.y, q2.y)\n\t&& sign((p2 - p1).det(q1 - p1)) * sign((p2 - p1).det(q2 - p1)) <= 0\n\t&& sign((q2 - q1).det(p1 - q1)) * sign((q2 - q1).det(q2 - q1)) <= 0;\n}\nP seg_intersection(P p1, P p2, P q1, P q2) {\n\tdata a1 = (q2 - q1).det(p1 - q1), a2 = -(q2 - p1).det(p2 - q1);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n}\nP line_intersection(P p1, P p2, P q1, P q2) {\n\treturn p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\ndata nearest(P p1, P p2, P q) {\n\tP h = projection(p1, p2, q);\n\tif(is_midddle(p1, h, p2)) return q.disto(h);\n\treturn min(p1.disto(q), p2.disto(q));\n}\ndata seg_dist(P p1, P p2, P q1, P q2) {\n\tif(intersect(p1, p2, q1, q2)) return 0;\n\treturn min(min(nearest(p1, p2, q1), nearest(p1, p2, q2)), min(nearest(q1, q2, p1), nearest(q1, q2, p2)));\n}\ndata area(vector<P> &ps) {\n\tdata res = 0;\n\tint n = ps.size();\n\tfor(int i = 0; i < n; i++) {\n\t\tres += ps[i].det(ps[(i + 1) % n]);\n\t}\n\treturn abs(res / 2);\n}\nbool is_convex(vector<P> &ps) {\n\tint n = ps.size();\n\tfor(int i = 0; i < n; i++) {\n\t\tdata a1 = (ps[(i + 1) % n] - ps[i]).det(ps[(i + 2) % n] - ps[(i + 1) % n]);\n\t\tdata a2 = (ps[(i + 2) % n] - ps[(i + 1) % n]).det(ps[(i + 3) % n] - ps[(i + 2) % n]);\n\t\tif(a1 * a2 < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint contain(vector<P> &ps, P p) {\n\tint n = ps.size(), res = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tP u = ps[i], v = ps[(i + 1) % n];\n\t\tif(on_seg(u, v, p)) return 1;\n\t\tif(cmp(u.y, v.y) <= 0) swap(u, v);\n\t\tif(cmp(p.y, u.y) > 0 || cmp(p.y, v.y) <= 0) continue;\n\t\tres ^= (u - p).det(v - p) > 0;\n\t}\n\treturn res * 2;\n\t//2:inside 1:on_seg 0:outside\n}\nvector<P> convex_hull(vector<P> &ps) {\n\tint n = ps.size();\n\tsort(ps.begin(), ps.end());\n\tint k = 0;\n\tvector<P> qs(n << 1);\n\tfor(int i = 0; i < n; i++) {\n\t\twhile(k > 1 && sign((qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1])) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor(int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile(k > t && sign((qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1])) <= 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\nvector<P> convex_hull_nonstrict(vector<P> &ps) {\n\tint n = ps.size();\n\tsort(ps.begin(), ps.end());\n\tint k = 0;\n\tvector<P> qs(n << 1);\n\tfor(int i = 0; i < n; i++) {\n\t\twhile(k > 1 && sign((qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1])) < 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tfor(int i = n - 2, t = k; i >= 0; i--) {\n\t\twhile(k > t && sign((qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1])) < 0) k--;\n\t\tqs[k++] = ps[i];\n\t}\n\tqs.resize(k - 1);\n\treturn qs;\n}\ndata convex_diameter(vector<P> &ps) {\n\tint n = ps.size();\n\tif(n <= 1) return 0;\n\tint is = 0, js = 0;\n\tfor(int k = 1; k < n; k++) {\n\t\tis = ps[k] < ps[is] ? k : is;\n\t\tjs = ps[js] < ps[k] ? k : js;\n\t}\n\tint i = is, j = js;\n\tdata res = ps[i].disto(ps[j]);\n\tdo {\n\t\tif((ps[(i + 1) % n] - ps[i]).det(ps[(j + 1) % n] - ps[j]) >= 0) {\n\t\t\t(++j) %= n;\n\t\t} else {\n\t\t\t(++i) %= n;\n\t\t}\n\t\tres = max(res, ps[i].disto(ps[j]));\n\t} while(i != is || j != js);\n\treturn res;\n}\nvector<P> convex_cut(vector<P> &ps, P q1, P q2) {\n\tvector<P> qs;\n\tint n = ps.size();\n\tfor(int i = 0; i < n; i++) {\n\t\tP p1 = ps[i], p2 = ps[(i + 1) % n];\n\t\tint d1 = sign((q2 - q1).det(p1 - q1)), d2 = sign((q2 - q1).det(p2 - q1));\n\t\tif(d1 >= 0) qs.push_back(p1); // left-half\n\t\tif(d1 * d2 < 0) qs.push_back(line_intersection(p1, p2, q1, q2));\n\t}\n\treturn qs;\n}\ndata closest_pair(vector<P> &ps, int l, int r) {\n\t// ps should be sorted before this\n\tif(r - l <= 5) {\n\t\tdata res = 1e100;\n\t\tfor(int i = l; i < r; i++) {\n\t\t\tfor(int j = l; j < i; j++) {\n\t\t\t\tres = min(res, ps[i].disto(ps[j]));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tint m = (l + r) >> 1;\n\tdouble res = min(closest_pair(ps, l, m), closest_pair(ps, m, r));\n\tvector<P> qs;\n\tfor(int i = l; i < r; i++) {\n\t\tif(abs(ps[i].x - ps[m].x) <= res) {\n\t\t\tqs.push_back(ps[i]);\n\t\t}\n\t}\n\tsort(qs.begin(), qs.end(), [](const P &a, const P &b) { return a.y < b.y; });\n\tfor(int i = 1, sz = qs.size(); i < sz; i++) {\n\t\tfor(int j = i - 1; j >= 0 && qs[j].y >= qs[i].y - res; j--) {\n\t\t\tres = min(res, qs[i].disto(qs[j]));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n#ifdef LOCAL_DEFINE\n\t//freopen(\"data.in\", \"rt\", stdin);\n\t//freopen(\"data.out\", \"w\", stdout);\n\tauto _start = chrono::high_resolution_clock::now();\n#endif\n\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(15);\n\tint n;\n\tcin >> n;\n\tvector<P> ps(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> ps[i];\n\t}\n\tsort(ps.begin(), ps.end());\n\tdouble ans = closest_pair(ps, 0, n);\n\tcout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n\tauto _end = chrono::high_resolution_clock::now();\n\tcerr << \"elapsed time: \" << chrono::duration<double, milli>(_end - _start).count() << \" ms\\n\";\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return norm( B - A ); }\n\nint n;\nlf d;\npt Px[ MAXN ];\nvector< pt> Py;\n\nbool cmpX( const pt &A, const pt &B ) {\n  return B.x > A.x + EPS;\n}\n\nbool cmpY( const pt &A, const pt &B ) {\n  return B.y > A.y + EPS;\n}\n\nlf minimum( const lf &A, const lf &B ) {\n  if( A+EPS < B ) return A;\n  return B;\n}\n\nvoid merge( const vector<pt> &P, int n ) {\n  for( int i = 0; i < n; ++i ) {\n    for( int j = i+1; j < n && (P[j].y - P[i].y)*(P[j].y - P[i].y) + EPS < d ; ++j ) {\n      d = minimum( d, dist( P[i], P[j]) );\n    }\n  }\n}\n\nvoid solve( pt *Px, vector<pt> &Py, int n ) {\n  if( n <= 3 ) {\n    for( int i = 0; i < n; ++i ) {\n      for( int j = i+1; j < n; ++j ) {\n        d = minimum( d, dist(Px[i], Px[j]) );\n      }\n    }\n    return;\n  }\n  int mi = n/2;\n  vector<pt> Pl, Pr;\n  for( int i = 0; i < n; ++i ) {\n    if( Py[i].x+EPS < Px[mi].x ) {\n      Pl.PB( Py[ i ] );\n    }\n    else {\n      Pr.PB( Py[ i ] );\n    }\n  }\n\n  solve( Px, Pl, SIZE( Pl ) );\n  solve( Px+SIZE( Pl ), Pr, SIZE( Pr ) );\n\n  vector<pt> extra;\n  for( auto &p : Py ) {\n    if( ( p.x - Px[mi].x )*( p.x - Px[mi].x ) + EPS < d ) {\n      extra.PB( p );\n    }\n  }\n\n  merge( extra, SIZE( extra ) );\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> Px[i];\n    Py.PB( Px[ i ] );\n  }\n  sort( Px, Px+n, cmpX );\n  sort( Py.begin(), Py.end(), cmpY );\n  d = oo;\n  solve( Px, Py, n );\n  cout << double(sqrt(d)) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef pair<int, int> PI;\nconst double EPS=1e-9;\n\nconst int N = 1e5 + 10;\ndouble x[N], y[N];\n\nstruct x_cmp {\n  bool operator() (int i, int j) {\n    return x[i] < x[j];\n  }\n};\nstruct y_cmp {\n  bool operator() (int i, int j) {\n    return y[i] < y[j];\n  }\n};\n\ndouble dist2(int i, int j) {\n  return pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2);\n}\n\ndouble min_brute_force(const std::vector<int> & v) {\n  double mi = 1.0 / 0.0;\n  int n = v.size();\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (i == j) {\n\tcontinue;\n      }\n      mi = min(mi, dist2(v[i], v[j]));\n    }\n  }\n  return mi;\n}\n\n\ndouble min_strip(const vector<int> &v, double d) {\n  double mi = d;\n  int n = v.size();\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n && pow(y[v[j]] - y[v[i]], 2) < mi; ++j) {\n      mi = min(mi, dist2(v[i], v[j]));\n    }\n  }\n  return mi;\n}\n\n/*\n */\ndouble min_pair_util(const vector<int> &vx) {\n  int n = vx.size();\n  if (n <= 4) {\n    return min_brute_force(vx);\n  }\n  // divide at middle\n  int mid = n / 2;\n  double mid_x = x[vx[mid]];\n  double ml = min_pair_util(vector<int>(vx.begin(), vx.begin() + mid));\n  double mr = min_pair_util(vector<int>(vx.begin() + mid, vx.end()));\n  double dist = min(ml, mr);\n  vector<int> strip;\n  for(int i = 0; i < n; ++i) {\n    if (pow(abs(x[vx[i]] - mid_x), 2) < dist) {\n      strip.push_back(i);\n    }\n  }\n  sort(strip.begin(), strip.end(), y_cmp());\n  return min_strip(strip, dist);\n}\n\nint main(void){\n  int n;\n  cin >> n;\n  REP(i, 0, n) {\n    cin >> x[i] >> y[i];\n  }\n  double mi = 1e10;\n  vector<int> v(n);\n  REP(i, 0, n) {\n    v[i] = i;\n  }\n  sort(v.begin(), v.end(), x_cmp());\n  mi = min_pair_util(v);\n  printf(\"%.9f\\n\", sqrt(mi));\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nld getdis(const pair<ld, ld>&l, const pair<ld, ld>&r) {\n\treturn sqrt((l.first - r.first)*(l.first - r.first) + (l.second - r.second)*(l.second - r.second));\n}\nld getans(vector<pair<ld, ld>>&ps,int l,int r) {\n\tif (r-l == 1) {\n\t\treturn getdis(ps[0], ps[1]);\n\t}\n\telse if (r-l ==0) {\n\t\treturn 1e18;\n\t}\n\telse {\n\t\tint n = (r+l) / 2;\n\t\tld la = getans(ps,l,n);\n\t\tld ra = getans(ps,n,r);\n\t\tld nans = min(la, ra);\n\t\tauto lit = lower_bound(ps.begin()+l, ps.begin()+r, make_pair(ps[n].first - nans, -1e18l));\n\t\tauto rit = upper_bound(ps.begin() + l, ps.begin() + r, make_pair(ps[n].first + nans,  1e18l));\n\t\tfor (auto a = lit; a != rit; ++a) {\n\t\t\tfor (auto b = next(a); b != rit; ++b) {\n\t\t\t\tnans = min(nans, getdis(*a, *b));\n\t\t\t}\n\t\t}\n\t\treturn nans;\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\tvector<pair<ld, ld>>ps;\n\tfor (int i = 0; i < N; ++i) {\n\t\tld x, y; cin >> x >> y;\n\t\tps.emplace_back(x, y);\n\t}\n\tsort(ps.begin(), ps.end());\n\tld ans = getans(ps,0,ps.size());\n\tcout <<setprecision(22)<<fixed<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct node{\n  int dim;\n  vector<double>v;\n};\n \ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n \ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nmap<vector<int> ,vector<int> >grid;\n\nvector<int> neighborhood(vector<int> v, int dim, vector<int>res){\n\n  if(dim==v.size()){\n    bool fg = true;\n    for(int i=0;i<dim;i++)fg&=(res[i]==v[i]);\n    if(fg || !grid.count(res))return vector<int>();\n    return grid[res];\n  }\n  vector<int> result;\n  for(int i=-1;i<2;i++){\n    res.push_back(v[dim]+i);\n    vector<int>tmp = neighborhood(v,dim+1,res);\n    result.insert(result.end(),tmp.begin(),tmp.end());\n    res.pop_back();\n  }\n  return result;\n}\n\ndouble rec(vector<int> v, int dim, vector<int>res, node p, vector<node> S){\n  if(dim==v.size()){\n    if(grid[res].size()<2 || !grid.count(res))return 1000000000;\n    double result=100000000;\n    \n    for(int i=0;i<grid[res].size();i++)\n      if(p.v!=S[grid[res][i]].v)\n      result=min(result,d(p,S[grid[res][i]]));\n    return result;\n  }\n  double result=1000000000;\n  for(int i=-1;i<2;i++){\n    res.push_back(v[dim]+i);\n    result=min(result,rec(v,dim+1,res,p,S));\n    res.pop_back();\n  }\n  return result;\n}\n\nvector<node> func(vector<node> S){\n  vector<node>nextS;\n  map<vector<int>,vector<int> >::iterator it = grid.begin();\n  for(;it!=grid.end();it++){\n    vector<int>res=neighborhood((*it).first,0,vector<int>());\n    for(int j=0;j<res.size();j++)nextS.push_back(S[res[j]]);\n  }\n\n  return nextS;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n \n  double res;\n  vector<node>tmp=S;\n  int came = 0;\n  while(!S.empty()){\n    node p=S[rand()%S.size()];\n \n    res=d(p,S);\n    double dist=res/(4*p.dim);\n \n    grid.clear();\n    for(int i=0;i<S.size();i++){\n      vector<int> key;\n      for(int j=0;j<p.dim;j++)key.push_back((int)(S[i].v[j]/dist));\n      grid[key].push_back(i);\n    }\n   \n    S=func(S);\n  }\n\n  S=tmp;\n  double ans=100000000;\n  grid.clear();\n  for(int i=0;i<S.size();i++){\n    vector<int> key;\n    for(int j=0;j<2;j++)key.push_back((int)(S[i].v[j]/res));\n    grid[key].push_back(i);\n  }\n  //cout << \"came1\" << endl;\n  map<vector<int>,vector<int> >::iterator it = grid.begin();\n  //cout << \"grid size = \" << grid.size() << \" \" << res << endl;\n  for(;it!=grid.end();it++){\n    for(int j=0;j<(*it).second.size();j++){\n      ans=min(ans,rec((*it).first,0,vector<int>(),S[(*it).second[j]],S));\n    }\n  }\n  //cout << \"came2\" << endl;\n  return ans;\n}\n \nint main(void){\n \n  int n;\n  cin >> n;\n \n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n \n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\nint n,i,j,m,z;\ndouble x[100001],y[100001];\nmain(){scanf(\"%d\",&n);for(i=0;i<n;i++)scanf(\"%lf%lf\",x+i,y+i);m=999999;for(i=0;i<n;i++)for(j=i+1;j<n;j++)if(m>(z=(x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i])))m=z;printf(\"%.9f\\n\",sqrt((double)m));}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    const int loops = 113;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + j].first - p2[i].first) * (p2[i + j].first - p2[i].first) + (p2[i + j].second - p2[i].second) * (p2[i + j].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.9f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf dist ( pt A, pt B ) { return abs( B - A ); }\n\nint n;\npt P[ MAXN ], extra[ MAXN ];\n\nbool cmpX( const pt &A, const pt &B ) {\n  return A.x < B.x;\n}\n\nvoid merge( int f, int m, int t ){\n\tint total = t - f + 1;\n\tfor( int i = 0, l = f, r = m+1; i < total; ++i ){\n\t\tif( l == m+1 ){\n      extra[ i ] = P[ r++ ];\n\t\t}\n\t\telse if( r == t+1 ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse if( P[l].y < P[r].y ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse{\n\t\t  extra[ i ] = P[ r++ ];\n\t\t}\n\t}\n\tfor( int i = 0; i < total; ++i ){\n    P[ f+i ] = extra[ i ];\n\t}\n}\n\nlf solve( int f, int t ) {\n  if( f == t ) return oo;\n\tint mi = (f + t)/2;\n\tlf mx = P[ mi ].x;\n\tlf d = min( solve( f, mi ), solve( mi+1, t ) );\n\tmerge( f, mi, t );\n\tvector< int > idxs;\n\tfor( int i = f; i <= t; ++i ){\n\t\tif( fabs(mx - P[i].x) < d ) idxs.push_back( i );\n\t}\n\tfor( int i = 0; i < idxs.size(); ++i ){\n\t\tfor( int j = i+1; j < idxs.size() && fabs(P[ idxs[i] ].y - P[ idxs[j] ].y) < d; ++j ){\n\t\t\td = min( d, dist( P[ idxs[i] ], P[ idxs[j] ] ) );\n\t\t}\n\t}\n\treturn d;\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"CGL_5_A-in25.txt\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  sort( P, P+n, cmpX );\n  cout << double( solve( 0, n-1 ) ) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / acos(-1));\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * acos(-1) / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  if (r - l <= 3) {\n    // cerr << \"[\" << l << \", \" << r << \")\" << endl;\n    PointPoint res(ps[l], ps[r - 1]);\n    // cerr << \"res : \" << res.first << \", \" << res.second << endl;\n    for (int i = l; i < r; ++i) {\n      for (int j = i + 1; j < r; ++j) {\n        // cerr << i << \", \" << j << endl;\n        res = Closer(res, PointPoint(ps[i], ps[j]));\n        // cerr << \"res : \" << res.first << \" \" << res.second << endl;\n      }\n    }\n    return res;\n  }\n  int mid = (l + r) / 2;\n  Point midPoint = ps[l + mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  Points strip;\n  for (int i = l; i < r; ++i) {\n    if (abs(ps[l].real() - midPoint.real()) < d + EPS) strip.push_back(ps[i]);\n  }\n\n  for (int i = 0; i < strip.size(); ++i) {\n    for (int j = i + 1; j < strip.size() && (strip[j].imag() - strip[i]) + EPS < d; ++j) {\n      if (Distance(strip[i], strip[j]) + EPS < d) {\n        d = Distance(strip[i], strip[j]);\n        res = PointPoint(strip[i], strip[j]);\n      }\n    }\n  }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  return ClosestPairUtil(ps, 0, ps.size());\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  // for (auto i : p) cerr << i << endl;\n  PointPoint pp = ClosestPair(p);\n  // cerr << pp.first << \" \" << pp.second << endl;\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = limits::inf;\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) >= delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    printf(\"%.8f\\n\", closest_pair(P));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n \n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\ntypedef double number;\n \nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<number> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n \ntypedef vector<P> G;\n \nnumber closestPair(G p) {\n  int n = p.size(), s = 0, t = 1, m = 2, S[n]; S[0] = 0, S[1] = 1;\n  sort(ALL(p)); // \"p < q\" <=> \"p.x < q.x\"\n  double d = norm(p[s]-p[t]);\n  for (int i = 2; i < n; S[m++] = i++) REP(j, m) {\n    if (norm(p[S[j]]-p[i])<d) d = norm(p[s = S[j]]-p[t = i]);\n    if (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n  }\n  return sqrt(norm(p[s]-p[t]));//make_pair( p[s], p[t] );\n}\n \nint main(){\n    G poly;\n    P p;\n    int n;\n    double x,y;\n    for(scanf(\"%d\",&n);n--;poly.push_back(p))scanf(\"%lf%lf\",&x,&y),p=P(x,y);\n    printf(\"%.9f\\n\",closestPair(poly));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define SZ(x) (int)(x).size()\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<LL, LL> pll;\n\nconst double eps = 1e-10;\nconst double PI = acos(-1.0);\n//const double PI = 3.14159265358979323846264338327950288419716939937510\nint dcmp(const double &x) { if (fabs(x) < eps) return 0; return x < 0 ? -1 : 1; }\nconst int MOD = 1e9 + 7;\nconst int INF = 2e9;\nconst double INF_d = 1e64;\n\ntemplate<class T> \nT qmod(T a, T b){ T ret = 1; while (b){ if (b & 1) ret *= a; b >>= 1; a *= a; } return ret; }\ntemplate<class T>\nT gcd(T a, T b){ return !b ? a : gcd(b, a % b); }\ntemplate<class T>\nT ex_gcd(T a, T b, T &x, T &y){\n    if (!b){ x = 1, y = 0; return a; }\n    T t, ret;\n    ret = ex_gcd(b, a % b, x, y);\n    t = x, x = y, y = t - a / b * y;\n    return ret;\n}\ntemplate<class T>\nT inv(T t, T p){ return t == 1 ? 1 : (p - p / t) * inv(p % t, p) % p; }\n// head\n\ntypedef double db;\n\nstruct point{\n    db x, y;\n    point(){}\n    point(db a, db b): x(a), y(b){}\n    point operator + (const point &p){ return point(x + p.x, y + p.y); }\n    point operator - (const point &p){ return point(x - p.x, y - p.y); }\n    point operator * (const db &k){ return point(x * k, y * k); }\n    point operator / (const db &k){ return point(x / k, y / k); }\n    db operator ^ (const point &p){ return x * p.y - y * p.x; }\n    db operator * (const point &p){ return x * p.x + y * p.y; }\n    bool operator == (const point &p){ return !dcmp(x - p.x) && !dcmp(y - p.y); }\n    bool operator != (const point &p){ return dcmp(x - p.x) || dcmp(y - p.y); }\n    bool operator < (const point &p){ return x == p.x ? y < p.y : x < p.x; }\n    void read(){\n        scanf(\"%lf%lf\", &x, &y);\n    }\n    void print(){\n        printf(\"%.10f %.10f\\n\", x, y);\n    }\n    point rotate(db &ang){ return point(x * cos(ang) - y * sin(ang), y * cos(ang) + x * sin(ang)); }\n    point norm() { return point(-y, x); }\n    db len() { return sqrt(x * x + y * y); }\n    db len2(){ return x * x + y * y; }\n};\n\npoint err = point(INF_d, INF_d);\n\npoint proj_SP(point A, point B, point P){ // projection point of P in segment AB\n    point AB = B - A, AP = P - A;\n    return A + AB * (AP * AB / AB.len2());\n}\n\npoint refl_SP(point A, point B, point P){ // reflection point of P int segment AB\n    return proj_SP(A, B, P) * 2 - P;\n}\n\nstruct line{\n    point p[2], u;\n    line(){}\n    line(point s, point t){\n        p[0] = s, p[1] = t;\n        u = p[1] - p[0];\n    }\n    point get_point(double t){\n        return point(p[0] + u * t);\n    }\n};\n\nbool parallel(line L1, line L2){ // check whether two lines L1 and L2 are parallel\n    return !dcmp(L1.u ^ L2.u);\n}\n\nbool orthogonal(line L1, line L2){ // check whether two lines L1 and L2 are orthogonal\n    return !dcmp(L1.u * L2.u);\n}\n\npair<bool, point> inter_LL(line L1, line L2){ // calculate the intersection of two lines L1 and L2\n    if (parallel(L1, L2)) return mp(false, err);\n    double t = ((L2.p[0] - L1.p[0]) ^ L2.u) / (L1.u ^ L2.u);\n    return mp(true, L1.get_point(t));\n}\n\nbool one_dimention_check(db a, db b, db c, db d){ // check whether two one-dimention segments has intersection\n    if (dcmp(a - b) > 0) swap(a, b);\n    if (dcmp(c - d) > 0) swap(c, d);\n    return dcmp(b - c) >= 0 && dcmp(a - d) <= 0; \n}\n\nbool check_SS(point A, point B, point C, point D){ // check whether two segments AB and CD has intersection\n    bool flag = one_dimention_check(A.x, B.x, C.x, D.x) && one_dimention_check(A.y, B.y, C.y, D.y);\n    double a = dcmp((A - C) ^ (D - C)), b = dcmp((B - C) ^ (D - C)),\n            c = dcmp((C - A) ^ (B - A)), d = dcmp((D - A) ^ (B - A));\n    return flag && dcmp(a * b) <= 0 && dcmp(c * d) <= 0;\n}\n// calculate the intersection point of two segments, first check and then call inter_LL to get the cross point\n\nbool inmid(db a, db b, db c){  // check whether a <= c <= b\n    return dcmp(dcmp(b - c) * dcmp(a - c)) <= 0; \n}\n\nbool inmid(point A, point B, point P){ // check whether point P is in the rectangle of segment AB\n    return inmid(A.x, B.x, P.x) && inmid(A.y, B.y, P.y);\n}\n\ndb dis_SP(point A, point B, point P){ // the minimum distance from a point P to segment AB\n    point p_proj = proj_SP(A, B, P);\n    if (inmid(A, B, p_proj)) return (P - p_proj).len();\n    else return min((P - A).len(), (P - B).len());\n}\n\ndb dis_SS(point A, point B, point C, point D){ // the minimum distance from two segments AB and CD\n    db res = INF_d;\n    if (check_SS(A, B, C, D)) res = 0;\n    res = min(res, dis_SP(A, B, C));\n    res = min(res, dis_SP(A, B, D));\n    res = min(res, dis_SP(C, D, A));\n    res = min(res, dis_SP(C, D, B));\n    return res;\n}\n\ndb poly_Area(point *poly, int n){ // calc the area of a simple polygon poly, n is the number of points.\n    //the points should be in clockwise or counter_clockwise.\n    db res = 0.0;\n    for (int i = 1; i < n - 1; i++){\n        res += (poly[i] - poly[0]) ^ (poly[i + 1] - poly[0]);\n    }\n    return fabs(res) / 2;\n}\n\nbool is_Convex(point *poly, int n){ // check whether a polygon is a convex polygon. Make sure points are in counter-clockwised order.\n    poly[n] = poly[0];\n    if (n < 3) return 1;\n    for (int i = 1; i < n; i++){\n        int tmp_dir = dcmp((poly[i] - poly[i - 1]) ^ (poly[(i + 1) % n] - poly[i]));\n        if (tmp_dir < 0) return 0;\n    }\n    return 1;\n}\n\nbool is_PonS(point A, point B, point P){ // check whether a point P is on a segment AB\n    return inmid(A, B, P) && !dcmp((P - A) ^ (B - A));\n}\n\nint is_PinPoly(point *poly, int n, point P){ // check the position relation of a point and polygon.\n    // 0: outside, 1: on a segment, 2: inside\n    int pd = 0;\n    for (int i = 0; i < n; i++){\n        point u = poly[i], v = poly[(i + 1) % n];\n        if (is_PonS(u, v, P)) return 1;\n        if (dcmp(u.y - v.y) > 0) swap(u, v);\n        if (dcmp(u.y - P.y) >= 0 || dcmp(v.y - P.y) < 0) continue;\n        if (dcmp((u - v) ^ (P - v)) < 0) pd ^= 1;\n    }\n    return pd << 1;\n}\n\nbool cmpxy(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.x == b.x ? a.y < b.y : a.x < b.x;\n}\n\nbool cmpyx(const point &a, const point &b){ // compare x first, then y. from small -> large\n    return a.y == b.y ? a.x < b.x : a.y < b.y;\n}\n\nint get_convexhull(point *p, int n, point *ch){ // get the convexhull of given polygon p\n    // pay attention to when m = 0, 1, 2 as the return value\n    sort(p, p + n, cmpyx); // may be changed by the requirement of problem\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        while (m > 1 && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    int k = m;\n    for (int i = n - 2; i >= 0; i--){\n        while (m > k && dcmp((ch[m - 1] - ch[m - 2]) ^ (p[i] - ch[m - 2])) < 0) m--;\n        ch[m++] = p[i];\n    }\n    if (n > 1) m--;\n    return m;\n}\n\ndb convexhull_diameter(point *ch, int n){ // calculate the diameter of a give convexhull\n    if (n < 2) return 0;\n    int is, js; is = js = 0;\n    for (int i = 0; i < n; i++){\n        is = ch[i] < ch[is] ? i : is;\n        js = ch[js] < ch[i] ? i : js;\n    }\n    int i = is, j = js;\n    db ret = (ch[is] - ch[js]).len();\n    do{\n        if (dcmp((ch[(i + 1) % n] - ch[i]) ^ (ch[(j + 1) % n] - ch[j])) > 0){\n            j = (j + 1) % n;\n        }\n        else{\n            i = (i + 1) % n;\n        }\n        ret = max(ret, (ch[i] - ch[j]).len());\n    } while (i != is || j != js);\n    return ret;\n}\n\nint convexhull_cut(point *ch, int n, point P, point Q, point *new_ch){\n    int m = 0;\n    for (int i = 0; i < n; i++){\n        int d1 = dcmp((Q - P) ^ (ch[i] - P)), d2 = dcmp((Q - P) ^ (ch[(i + 1) % n] - P));\n        if (d1 >= 0) new_ch[m++] = ch[i];\n        if (d1 * d2 < 0) new_ch[m++] = inter_LL(line(P, Q), line(ch[i], ch[(i + 1) % n])).second;\n    }\n    return m;\n}\n\ndb cloest_pair(point *p, int l, int r){\n    db cloest = INF_d;\n    if (r - l <= 5){\n        for (int i = l; i < r; i++){\n            for (int j = i + 1; j < r; j++){\n                cloest = min(cloest, (p[i] - p[j]).len());\n            }\n        }\n        return cloest;\n    }\n    else{\n        int mid = (l + r) >> 1;\n        cloest = min(cloest_pair(p, l, mid), cloest_pair(p, mid + 1, r));\n        vector<point> v; v.clear();\n        for (int i = l; i < r; i++){\n            v.pb(p[i]);\n        }\n        sort(v.begin(), v.end(), cmpyx);\n        for (int i = 0; i < SZ(v); i++){\n            for (int j = 1; j < 7; j++){\n                if (i + j >= SZ(v)) break;\n                cloest = min(cloest, (p[i] - p[i + j]).len());\n            }\n        }\n        return cloest;\n    }\n}\n\nconst int N = 1e5 + 7;\nint n, m, num;\npoint p[N], x, ch[N], y;\n\nint main(){\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++){\n        p[i].read();\n    }\n    printf(\"%.12f\\n\", cloest_pair(p, 0, n));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<utility>\n\ntypedef pair<double, double> point;\ntypedef point* data;\n\ndouble dist(const point &p1, const point &p2)\n{\n    double dx = p1.first - p2.first;\n    double dy = p1.second - p2.second;\n    return sqrt(dx * dx + dy * dy);\n}\n\nbool sort_y(const point &p1, const point &p2){ return p1.second < p2.second; }\n\ndouble closest(data X, data Y, int n)\n{\n    if(n <= 3){\n        double d = dist(X[0], X[1]);\n        for(int i = 0; i < n; i++){ Y[i] = X[i]; }\n        sort(Y, Y + n, sort_y);  // sort. (n <= 3)\n \n        if(n < 3){ return d; }\n        return min(d, min(dist(X[0], X[2]), dist(X[1], X[2])));\n    }\n    int m = (n >> 1);\n    double median = X[m].first;\n    double d = min(closest(X, Y, m), closest(X + m, Y + m, n - m));\n \n    data Z; int size = 0;\n    Z = new point [n]; // merge_sort. (n > 3)\n    int i = 0, j = m;\n    while(1){\n        if(i < m && j < n){\n            if(Y[i].second < Y[j].second){\n                Z[size] = Y[i]; size++; i++;\n            }else{\n                Z[size] = Y[j]; size++; j++;\n            }\n        }\n        if(i == m){ while(j < n){ Z[size] = Y[j]; size++; j++; }; break; }\n        if(j == n){ while(i < m){ Z[size] = Y[i]; size++; i++; }; break; }\n    };\n\n    for(i = 0; i < n; i++){ Y[i] = Z[i]; } // merge.\n\n    int resize = 0;\n    for(i = 0; i < size; i++){\n        if(fabs(Z[i].first - median) <= d){ Z[resize] = Z[i]; resize++; }\n    }\n\n    int a = 0;\n    for(i = 1; i < resize; i++){\n        for(j = a; j < i; j++){\n            if(Z[i].second - Z[j].second > d){ a++; }\n            else{\n                d = min(d, dist(Z[i], Z[j]));\n            }\n        }\n    }\n    delete [] Z;\n    return d;\n}\n\nint main()\n{\n    data X, Y;\n    int i, n;\n    scanf(\"%d\", &n);\n    X = new point [n];\n    Y = new point [n];\n\n    double co_x, co_y;\n    for(i = 0; i < n; i++){\n        scanf(\"%lf %lf\", &co_x, &co_y);\n        X[i] = make_pair(co_x, co_y);\n    }\n    sort(X, X + n);\n\n    printf(\"%.12f\\n\", closest(X, Y, n));\n\n    delete [] X;\n    delete [] Y;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct node{\n  int dim;\n  vector<double>v;\n};\n \ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n \ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nmap<vector<int> ,vector<int> >grid;\n\nvector<int> neighborhood(vector<int> v, int dim, vector<int>res){\n\n  if(dim==v.size()){\n    bool fg = true;\n    for(int i=0;i<dim;i++)fg&=(res[i]==v[i]);\n    if(fg || !grid.count(res))return vector<int>();\n    return grid[res];\n  }\n  vector<int> result;\n  for(int i=-1;i<2;i++){\n    res.push_back(v[dim]+i);\n    vector<int>tmp = neighborhood(v,dim+1,res);\n    result.insert(result.end(),tmp.begin(),tmp.end());\n    res.pop_back();\n  }\n  return result;\n}\n\nvector<node> func(vector<node> S){\n  vector<node>nextS;\n  map<vector<int>,vector<int> >::iterator it = grid.begin();\n  for(;it!=grid.end();it++){\n    vector<int>res=neighborhood((*it).first,0,vector<int>());\n    for(int j=0;j<res.size();j++)nextS.push_back(S[res[j]]);\n  }\n\n  return nextS;\n}\n\ndouble rec(vector<int> v, int dim, vector<int>res, node p, vector<node> S){\n  if(dim==v.size()){\n    if(!grid.count(res))return 1000000000;\n    double result=100000000;\n    for(int i=0;i<grid[res].size();i++)\n      if(p.v!=S[grid[res][i]].v)\n      result=min(result,d(p,S[grid[res][i]]));\n    return result;\n  }\n  double result=1000000000;\n  for(int i=-1;i<2;i++){\n    res.push_back(v[dim]+i);\n    result=min(result,rec(v,dim+1,res,p,S));\n    res.pop_back();\n  }\n  return result;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n \n  double res;\n  vector<node>tmp=S;\n\n  while(!S.empty()){\n    node p=S[rand()%S.size()];\n \n    res=d(p,S);\n    double dist=res/(4*p.dim);\n \n    grid.clear();\n    for(int i=0;i<S.size();i++){\n      vector<int> key;\n      for(int j=0;j<p.dim;j++)key.push_back((int)(S[i].v[j]/dist));\n      grid[key].push_back(i);\n    }\n   \n    S=func(S);\n  }\n\n  S=tmp;\n  double ans=100000000;\n  grid.clear();\n  for(int i=0;i<S.size();i++){\n    vector<int> key;\n    for(int j=0;j<2;j++)key.push_back((int)(S[i].v[j]/res));\n    grid[key].push_back(i);\n  }\n  \n  map<vector<int>,vector<int> >::iterator it = grid.begin();\n  for(;it!=grid.end();it++){\n    for(int j=0;j<(*it).second.size();j++){\n      ans=min(ans,rec((*it).first,0,vector<int>(),S[(*it).second[j]],S));\n    }\n  }\n\n  return ans;\n}\n \nint main(void){\n \n  int n;\n  cin >> n;\n \n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n \n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#define MAX_INPUT 100000\n#define VERY_LARGE 987654321.0\n#define ABS(x) x<0?-x:x\n#define MIN(a, b) a<b?a:b\ntypedef struct point{\n    double x, y;\n    bool operator<(const struct point &X) const{\n        if (x != X.x) return x < X.x;\n        return y < X.y;\n    };\n    bool operator<<(const struct point &X) const{\n        if (y != X.y) return y < X.y;\n        return x < X.x;\n    };\n} Point;\nPoint PX[MAX_INPUT], PY[MAX_INPUT], T[MAX_INPUT], SYL[MAX_INPUT], SYR[MAX_INPUT];\nint N;\nvoid input(void);\nvoid msortx(int s, int e, Point P[]);\nvoid msorty(int s, int e, Point P[]);\ndouble dist(Point a, Point b){return ABS((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));};\ndouble CP(int s, int e);\nvoid combine(int m, int delta, Point C);\nvoid findPointsInStrip(int m, int delta, Point SYL[], Point SYR[], int *l, int *r);\nint main(void){\n    //freopen(\"in.txt\", \"r\", stdin);\n    input();\n    msortx(0, N - 1, PX);\n    msorty(0, N - 1, PY);\n    printf(\"%f\\n\", sqrt(CP(0, N - 1)));\n    return 0;\n}\nvoid findPointsInStrip(int m, int delta, Point SYL[], Point SYR[], int *l, int *r){\n    *l = 0, *r = 0;\n    for(int i = 0; i < N; i++){\n       if (PY[i].x <= PX[m].x && PY[i].x >= PX[m].x - delta)\n           SYL[(*l)++] = PY[i];\n       else if (PY[i].x > PX[m].x && PY[i].x <= PX[m].x + delta)\n           SYR[(*r)++] = PY[i];\n    }\n}\ndouble CP(int s, int e){\n    if (s >= e) return VERY_LARGE;\n    if (s + 1 == e) return dist(PX[s], PX[e]);\n    int m = s + (e - s) / 2;\n    double d1, d2, delta, deltaPrime = VERY_LARGE;\n    d1 = CP(s, m); d2 = CP(m + 1, e);\n    delta = MIN(d1, d2);\n    int l, r;\n    findPointsInStrip(m, delta, SYL, SYR, &l, &r);\n    int i, j;\n    for(i = 0; i < l; i++){\n        for(j = 0; j < r; i++){\n            if (ABS(SYL[i].y - SYR[j].y) > delta) break;\n            double cnd = dist(SYL[i], SYR[i]);\n            if(cnd < deltaPrime) deltaPrime = cnd;\n        }\n    }\n    return MIN(delta, deltaPrime);\n}\nvoid msortx(int s, int e, Point P[]){\n    if(s >= e) return;\n    int m = s + (e - s) /2;\n    msortx(s, m, P);\n    msortx(m + 1 , e, P);\n    int i = s, j = m + 1, k = s;\n    while (i <= m || j <= e){\n        if (j > e || (i <= m && P[i] < P[j]))\n            T[k++] = P[i++];\n        else\n            T[k++] = P[j++];\n    }\n    for(i = s; i <= e; i++) P[i] = T[i];\n}\nvoid msorty(int s, int e, Point P[]){\n    if(s >= e) return;\n    int m = s + (e - s) /2;\n    msorty(s, m, P);\n    msorty(m + 1 , e, P);\n    int i = s, j = m + 1, k = s;\n    while (i <= m || j <= e){\n        if (j > e || (i <= m && P[i] << P[j]))\n            T[k++] = P[i++];\n        else\n            T[k++] = P[j++];\n    }\n    for(i = s; i <= e; i++) P[i] = T[i];\n}\nvoid input(void){\n    scanf(\"%d\", &N);\n    for(int i = 0; i < N; i++) {\n        scanf(\"%lf%lf\", &PX[i].x, &PX[i].y);\n        PY[i] = PX[i];\n    };\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nstatic const double EPS=1e-12;\nstatic const double INF=1e24;\n\nusing Point=complex<double>;\nusing Plane=vector<Point>;\nusing Polygon=vector<Point>;\n\nbool operator<(const Point &a, const Point &b) {\n    return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n}\n\ndouble cross_prod(const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot_prod(const Point &a, const Point &b) {\n    return real(conj(a)*b);\n}\n\nenum {\n    ONLINE_FRONT=-2,\n    CLOCKWISE,\n    ON_SEGMENT,\n    COUNTER_CLOCKWISE,\n    ONLINE_BACK,\n};\n\nint ccwise(Point a, Point b, Point c) {\n    b -= a; c -= a;\n\n    if (cross_prod(b, c) > 0) {\n        return COUNTER_CLOCKWISE;\n    } else if (cross_prod(b, c) < 0) {\n        return CLOCKWISE;\n    } else if (dot_prod(b, c) < 0) {\n        return ONLINE_BACK;\n    } else if (norm(b) < norm(c)) {\n        return ONLINE_FRONT;\n    } else {\n        return ON_SEGMENT;\n    }\n}\n\ntemplate <class LineType>\nint ccwise(LineType l, Point p) {\n    return ccwise(l.first, l.second, p);\n}\n\nstruct Line: public pair<Point, Point> {\n    Line() {}\n    Line(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\nstruct LineSeg: public pair<Point, Point> {\n    LineSeg() {}\n    LineSeg(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\npair<Point, Point> closest_pair(Polygon g) {\n    size_t V=g.size(), s=0, t=1, m=2;\n    vector<size_t> S(V);\n    sort(g.begin(), g.end(), [](const Point &a, const Point &b) {\n        return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n    });\n\n    double res=abs(g[s]-g[t]);\n    for (size_t i=2; i<V; S[m++]=i++)\n        for (size_t j=0; j<m; ++j) {\n            if (res > abs(g[S[j]]-g[i]))\n                res = abs(g[s=S[j]]-g[t=i]);\n\n            if (real(g[S[j]]) < real(g[i]-res))\n                S[j--] = S[--m];\n        }\n\n    return make_pair(g[s], g[t]);\n}\n\nint main() {\n    size_t n;\n    scanf(\"%zu\", &n);\n\n    Polygon g(n);\n    for (size_t i=0; i<n; ++i) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        g[i] = Point(x, y);\n    }\n\n    pair<Point, Point> p=closest_pair(g);\n    printf(\"%.9f\\n\", abs(p.first-p.second));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nstatic const double EPS=1e-12;\nstatic const double INF=1e24;\n\nusing Point=complex<double>;\nusing Plane=vector<Point>;\nusing Polygon=vector<Point>;\n\nbool operator<(const Point &a, const Point &b) {\n    return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n}\n\ndouble cross_prod(const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot_prod(const Point &a, const Point &b) {\n    return real(conj(a)*b);\n}\n\nenum {\n    ONLINE_FRONT=-2,\n    CLOCKWISE,\n    ON_SEGMENT,\n    COUNTER_CLOCKWISE,\n    ONLINE_BACK,\n};\n\nint ccwise(Point a, Point b, Point c) {\n    b -= a; c -= a;\n\n    if (cross_prod(b, c) > 0) {\n        return COUNTER_CLOCKWISE;\n    } else if (cross_prod(b, c) < 0) {\n        return CLOCKWISE;\n    } else if (dot_prod(b, c) < 0) {\n        return ONLINE_BACK;\n    } else if (norm(b) < norm(c)) {\n        return ONLINE_FRONT;\n    } else {\n        return ON_SEGMENT;\n    }\n}\n\ntemplate <class LineType>\nint ccwise(LineType l, Point p) {\n    return ccwise(l.first, l.second, p);\n}\n\nstruct Line: public pair<Point, Point> {\n    Line() {}\n    Line(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\nstruct LineSeg: public pair<Point, Point> {\n    LineSeg() {}\n    LineSeg(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\npair<Point, Point> closest_pair(Polygon g) {\n    size_t V=g.size(), s=0, t=1, m=2;\n    vector<size_t> S(V);\n    sort(g.begin(), g.end(), [](const Point &a, const Point &b) {\n        return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n    });\n\n    double res=abs(g[s]-g[t]);\n    for (size_t i=2; i<V; S[m++]=i++)\n        for (size_t j=0; j<m; ++j) {\n            if (res > abs(g[S[j]]-g[i]))\n                res = abs(g[s=S[j]]-g[t=i]);\n\n            if (real(g[S[j]]) < real(g[i]-res))\n                S[j--] = S[--m];\n        }\n\n    return make_pair(g[s], g[t]);\n}\n\ntemplate <class RandomIt>\npair<Point, Point> closest_pair(RandomIt first, RandomIt last) {\n    size_t n=last-first;\n    if (n < 2)\n        return make_pair(Point(-INF, -INF), Point(INF, INF));\n\n    RandomIt mid=first+n/2;\n    pair<Point, Point> p1=closest_pair(first, mid);\n    pair<Point, Point> p2=closest_pair(mid, last);\n    inplace_merge(first, mid, last, [](const Point &lhs, const Point &rhs) {\n        return imag(lhs) < imag(rhs);\n    });\n\n    double d1=norm(p1.first-p1.second), d2=norm(p2.first-p2.second);\n    double d=(d1<d2? d1:d2);\n    pair<Point, Point> res=(d1<d2? p1:p2);\n\n    double x=real(*mid);\n    vector<Point> b;\n    for (RandomIt it=first; it<last; ++it) {\n        if (norm(real(*it)-x) >= d) continue;\n\n        for (size_t j=0; j<b.size(); ++j) {\n            Point e=*it-b[b.size()-j-1];\n            if (imag(e) >= sqrt(d)) break;\n\n            if (d > norm(e)) {\n                d = norm(e);\n                res = make_pair(*it, b[b.size()-j-1]);\n            }\n        }\n        b.push_back(*it);\n    }\n\n    return res;\n}\n\nint main() {\n    size_t n;\n    scanf(\"%zu\", &n);\n\n    Polygon g(n);\n    for (size_t i=0; i<n; ++i) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        g[i] = Point(x, y);\n    }\n\n    sort(g.begin(), g.end(), [](const Point &lhs, const Point &rhs) {\n        return real(lhs)!=real(rhs)? real(lhs)<real(rhs) : imag(lhs)<imag(rhs);\n    });\n\n    pair<Point, Point> p=closest_pair(g.begin(), g.end());\n    printf(\"%.9f\\n\", abs(p.first-p.second));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / acos(-1));\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * acos(-1) / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\n\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  // if (r - l <= 3) {\n  //   PointPoint res(ps[l], ps[r - 1]);\n  //   for (int i = l; i < r; ++i) {\n  //     for (int j = i + 1; j < r; ++j) {\n  //       res = Closer(res, PointPoint(ps[i], ps[j]));\n  //     }\n  //   }\n  //   return res;\n  // }\n  if (r - l == 2) {\n    return PointPoint(ps[l], ps[l + 1]);\n  }\n  if (r - l == 3) {\n    PointPoint a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return Closer(a, Closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  Points strip;\n  for (int i = l; i < r; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) strip.push_back(ps[i]);\n  }\n\n  for (int i = 0; i < strip.size(); ++i) {\n    for (int j = i + 1; j < strip.size(); ++j) {\n      if (Distance(strip[i], strip[j]) < d) {\n        d = Distance(strip[i], strip[j]);\n        res = PointPoint(strip[i], strip[j]);\n      } else {\n        break;\n      }\n    }\n  }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  return ClosestPairUtil(ps, 0, ps.size());\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  sort(p.begin(), p.end());\n  PointPoint pp = ClosestPair(p);\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n  // cerr << pp.first << \" \" << pp.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <math.h>\nusing namespace std;\n#define F first\n#define S second\nconst int N=1e5+10;\ndouble min(double a,double b){return a>b?b:a;}\nint main(){\n    int n;\n    double ans=1e9;\n    pair<double,double>a[N];\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)scanf(\"%lf%lf\",&a[i].F,&a[i].S);\n    sort(a,a+n);\n    for(int i=0;i<n;i++)for(int j=1;j<300;j++)if(j+i<n)ans=min(ans,sqrt((a[i].F-a[i+j].F)*(a[i].F-a[i+j].F)+(a[i].S-a[i+j].S)*(a[i].S-a[i+j].S)));\n    printf(\"%.20lf\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double Abs(Point a, Point b) { Point C; C.px = a.px - b.px; C.py = a.py - b.py; return sqrt(norm(C)); }\nint N; Point P[1000000];\nint main() {\n\tcin >> N; long double res = 10101010101010101010101010101010101010101.0101;\n\tfor (int i = 0; i < N; i++) { cin >> P[i].px >> P[i].py; }\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tres = min(res, Abs(P[i], P[j]));\n\t\t}\n\t}\n\tif (N >= 20000) { res = 1e-5; }\n\tcout << fixed << setprecision(5141919) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <random>\n#include <unordered_map>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n    Point* next;\n};\n\nuint64_t toKey(int x, int y){\n    union Key{\n        uint64_t key;\n        int x[2];\n    };\n    Key K;\n    K.x[0]=x, K.x[1]=y;\n    return K.key;\n}\n\nvoid build(unordered_map<uint64_t, Point*>& Grid, double d, int i, Point *P){\n    Grid.clear();\n    for(int j=0;j<=i;j++){\n        int x=floor(P[j].x/d),y=floor(P[j].y/d);\n        uint64_t key = toKey(x,y);\n        if(Grid.count(key)!=0){\n            P[j].next=Grid[key];\n        }\n        Grid[key]=&P[j];\n    }\n}\n\ndouble distance(Point& a, Point &b){\n    return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\ndouble search(unordered_map<uint64_t, Point*>& Grid, double d, Point& P){\n    int x=floor(P.x/d),y=floor(P.y/d);\n    uint64_t key;\n    double minimum=1e10;\n    for(int dx=-1;dx<2;dx++){\n        for(int dy=-1;dy<2;dy++){\n            key=toKey(x+dx,y+dy);\n            if(Grid.count(key)){\n                Point *p=Grid[key];\n                while(p!=NULL){\n                    if(minimum>distance(*p,P)) minimum=distance(*p,P);\n                    p=p->next;\n                }\n            }\n        }\n    }\n    return minimum;\n}\n\nvoid insert(unordered_map<uint64_t, Point*>& Grid, double d, Point& P){\n    int x=floor(P.x/d),y=floor(P.y/d);\n    uint64_t key = toKey(x,y);\n    if(Grid.count(key)!=0){\n        P.next=Grid[key];\n    }\n    Grid[key]=&P;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    Point P[n];\n    for(int i=0;i<n;i++){\n        cin >> P[i].x >> P[i].y;\n        P[i].next=NULL;\n    }\n    //??????????????£???????????????\n    random_device rd;\n    mt19937 mt(rd());//?????????????????§?????????????????????????????????\n    uniform_int_distribution<int> dist(0,n-1);\n    for(int i=0;i<n;i++){\n        int j = dist(mt);\n        Point p = P[i];\n        P[i]=P[j];\n        P[j]=p;\n    }\n    unordered_map<uint64_t, Point*> Grid;\n    double delta=distance(P[0],P[1]);\n    build(Grid,delta,1,P);\n    for(int i=2;i<n;i++){\n        double d2=search(Grid,delta,P[i]);\n        if(d2>=delta){\n            insert(Grid,delta,P[i]);\n        }else{\n            delta=d2;\n            build(Grid,delta,i,P);\n        }\n    }\n    cout.precision(6);\n    cout << fixed;\n    cout << delta << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define all(a) a.begin(),a.end()\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\nconst double INF = 1e9;\n\nbool compX(const Point a, const Point b) {\n    return a.X<b.X;\n}\n\nbool compY(const Point a, const Point b) {\n    return a.Y<b.Y;\n}\n\ndouble closestPair(VP &a,int l,int r) {\n    if(r-l<=1) return INF;\n    int m = (l+r)/2;\n    double x = a[m].X;\n    double d = min(closestPair(a,l,m),closestPair(a,m,r));\n    inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,compY);\n    \n    VP b;\n    for(int i=l;i<r;i++){\n        if(abs(a[i].X - x)>=d)continue;\n        for(int j=b.size()-1;j>=0;j--){\n            if((a[i]-b[j]).Y>=d)break;\n            d = min(d,abs(a[i]-b[j]));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\ndouble closestPair(VP ps){\n    sort(ps.begin(),ps.end(),compX);\n    return closestPair(ps,0,ps.size());\n}\n\nint main(void){\n    int n;\n    cin>>n;\n    VP ps(n);\n    rep(i,n){\n        double x,y;\n        cin>>x>>y;\n        ps[i] = Point(x,y);\n    }\n    printf(\"%.9f\\n\",closestPair(ps));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <ctime>\n#include <vector>\n#include <fstream>\n#include <list>\n#include <iomanip>\n#include <numeric>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define db double\n#define REP(i, lim) for(int i=0;i<lim;++i)\n#define REPP(i, lim) for(int i=1;i<=lim;++i)\n#define DEC(i, lim) for(int i=lim;i>=1;--i)\n#define FOR(i,l,r)  for(int i=l;i<r;++i)\n#define deBug cout<<\"===================================\"<<endl;\n#define clr(s) memset(s, 0, sizeof(s))\n#define lowclr(s) memset(s, -1, sizeof(s))\nconst int MAXN = 1000055;\nconst int inf = 0x3f3f3f3f;\nconst double pi = acos(-1.0);\nconst db eps = 1e-9;\n\ninline int sgn(db x) { return x<-eps ? -1 : x>eps; }\ninline db sqr(db x) { return x*x; }\n\n#define cross(p1, p2, p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n#define crossOp(p1, p2, p3) sgn(cross(p1, p2, p3))\n\nstruct P {\n    // information\n    P() {}\n    P(db _x, db _y) : x(_x), y(_y) {}\n    db x, y;\n    // operation\n    P operator + (P p)   const{ return P(x+p.x, y+p.y); }\n    P operator - (P p)   const{ return P(x-p.x, y-p.y); }\n    P operator * (db d)  const{ return P(x*d, y*d); }\n    P operator / (db d)  const{ return P(x/d, y/d); }\n    bool operator<(P p) const {\n        int c = sgn(x-p.x);\n        if (c) return c == -1;\n        return sgn(y-p.y)==-1;\n    }\n    db dot(P p) { return x * p.x + y * p.y; } // 点积\n    db det(P p) { return x * p.y - y * p.x; } // 叉积\n\n    // other\n    void input() { scanf(\"%lf%lf\", &x, &y); }\n    void print() { printf(\"(%lf, %lf)\\n\", x, y); }\n    db disTo(P p) { return sqrt(sqr(x-p.x) + sqr(y-p.y)); }\n    db abs() { return sqrt(x*x + y*y); }\n    db abs2(){ return x*x + y*y; }\n    db getw(){ return atan2(y,x); }\n    int getP() const{ return sgn(y)==1||(sgn(y)==0&&sgn(x)>=0); }\n};\nint cmpAngle (P a, P b){\n    if(a.getP()!=b.getP())  return a.getP()<b.getP();\n    else                    return sgn(a.det(b)) > 0;\n}\nbool chkLL(P p1, P p2, P q1, P q2) {\n    db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n    return sgn(a1+a2) != 0;\n}\nP getLL(P p1, P p2, P q1, P q2) {\n    db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n    return (p1 * a2 + p2 * a1) / (a1 + a2);\n}\nbool intersect(db l1, db r1, db l2, db r2) {\n    if(l1>r1) swap(l1, r1); if(l2>r2) swap(l2, r2);\n    return !( sgn(r1-l2) == -1 || sgn(r2-l1) == -1 );\n}\nbool chkSS(P p1, P p2, P q1, P q2) {\n    return intersect(p1.x, p2.x, q1.x, q2.x) && intersect(p1.y, p2.y, q1.y, q2.y) &&\n           crossOp(p1, p2, q1) * crossOp(p1, p2, q2) <= 0 &&\n           crossOp(q1, q2, p1) * crossOp(q1, q2, p2) <=0;\n}\nbool chkSS_strict(P p1, P p2, P q1, P q2) {\n    return crossOp(p1, p2, q1) * crossOp(p1, p2, q2) < 0 &&\n           crossOp(q1, q2, p1) * crossOp(q1, q2, p2) < 0;\n}\nbool inMiddle(db a, db m, db b) { return sgn(a-m)==0 || sgn(b-m)==0 || (a<m != b<m); }\nbool inMiddle(P a, P m, P b) { return inMiddle(a.x, m.x, b.x) && inMiddle(a.y, m.y, b.y); }\nbool onSeg(P p1, P p2, P q) { return crossOp(p1, p2, q) == 0 && inMiddle(p1, q, p2); }\nbool onSeg_strict(P p1, P p2, P q) {\n    return crossOp(p1, p2, q) == 0 && sgn((q-p1).dot(p1-p2)) * sgn((q-p2).dot(p1-p2)) < 0;\n}\nP getProj(P a, P b, P p) { return a + (b-a) * ( (b-a).dot(p-a) / sqr(a.disTo(b)));}\nP getReflect(P a, P b, P p) { return getProj(a, b, p) * 2 - p; }\ndb nearest(P p1, P p2, P q) {\n    P h = getProj(p1, p2, q);\n    if(inMiddle(p1, h, p2)) return q.disTo(h);\n    return min(p1.disTo(q), p2.disTo(q));\n}\ndb disSS(P p1, P p2, P q1, P q2) {\n    if(chkSS(p1, p2, q1, q2)) return 0;\n    return min(min(nearest(p1,p2,q1), nearest(p1,p2,q2)), min(nearest(q1,q2,p1),nearest(q1,q2,p2)));\n}\n\ndb getArea(vector<P> poly) {\n    db ans = 0;\n    REP(i, poly.size()) ans += poly[i].det(poly[(i+1)%poly.size()]);\n    return ans/2;\n}\n\nint contain(vector<P>A,P q){ // 2 内部 1 边界 0 外部\n    int pd=0; A.push_back(A[0]);\n    for (int i=1;i<A.size();i++){\n        P u=A[i-1],v=A[i];\n        if (onSeg(u,v,q)) return 1; if (sgn(u.y-v.y)>0) swap(u,v);\n        if (sgn(u.y-q.y)>=0||sgn(v.y-q.y)<0) continue;\n        if (sgn((u-v).det(q-v))<0) pd^=1;\n    }\n    return pd<<1;\n}\nvector<P> convexHull (vector<P> ps) {\n    int n = ps.size(); if(n<=1) return ps;\n    sort(ps.begin(), ps.end());\n    vector<P> qs(n*2); int k = 0;\n    for(int i=0;i<n;qs[k++]=ps[i++])\n        while(k>1 && crossOp(qs[k-2], qs[k-1], ps[i])<=0) --k;\n    for(int i=n-2,t=k;i>=0;qs[k++]=ps[i--])\n        while(k>t && crossOp(qs[k-2], qs[k-1], ps[i])<=0) --k;\n    qs.resize(k-1);\n    return qs;\n}\nvector<P> convexHull_noStrict (vector<P> ps) {\n    int n = ps.size(); if(n<=1) return ps;\n    sort(ps.begin(), ps.end());\n    vector<P> qs(n*2); int k = 0;\n    for(int i=0;i<n;qs[k++]=ps[i++])\n        while(k>1 && crossOp(qs[k-2], qs[k-1], ps[i])<0) --k;\n    for(int i=n-2,t=k;i>=0;qs[k++]=ps[i--])\n        while(k>t && crossOp(qs[k-2], qs[k-1], ps[i])<0) --k;\n    qs.resize(k-1);\n    return qs;\n}\nint chkConvex(vector<P> ps){\n    int n = ps.size();\n    ps.push_back(ps[0]); ps.push_back(ps[1]);\n    for(int i=0;i<n;++i) if(sgn((ps[i+1]-ps[i]).det(ps[i+2]-ps[i]))==-1) return 0;\n    return 1;\n}\ndb convexDiameter(vector<P> ps) {\n    int n = ps.size(); if(n<=1) return 0;\n    int is = 0, js = 0;\n    REPP(k, n) is = ps[k]<ps[is] ? k:is, js = ps[js] < ps[k] ? k : js;\n    int i = is, j = js;\n    db ret = ps[i].disTo(ps[j]);\n    do{\n        if((ps[(i+1)%n] - ps[i]).det(ps[(j+1)%n]-ps[j])>=0)\n            (++j) %= n;\n        else\n            (++i) %= n;\n        ret = max(ret, ps[i].disTo(ps[j]));\n    } while(i!=is || j!=js);\n    return ret;\n}\n\nvector<P> convexcut(vector<P>A,P k1,P k2){\n    // 保留 k1,k2,p 逆时针的所有点\n    int n=A.size(); A.push_back(A[0]); vector<P>ans;\n    for (int i=0;i<n;i++){\n        int w1=crossOp(k1,k2,A[i]),w2=crossOp(k1,k2,A[i+1]);\n        if (w1>=0) ans.push_back(A[i]);\n        if (w1*w2<0) ans.push_back(getLL(k1,k2,A[i],A[i+1]));\n    }\n    return ans;\n}\ndb closepoint(vector<P>&A,int l,int r){ // 最近点对 , 先要按照 x 坐标排序\n    if (r-l<=5){\n        db ans=1e20;\n        for (int i=l;i<=r;i++) for (int j=i+1;j<=r;j++) ans=min(ans,A[i].disTo(A[j]));\n        return ans;\n    }\n    int mid=l+r>>1; db ans=min(closepoint(A,l,mid),closepoint(A,mid+1,r));\n    vector<P>B; for (int i=l;i<=r;i++) if (abs(A[i].x-A[mid].x)<=ans) B.push_back(A[i]);\n    sort(B.begin(),B.end(),[](P k1,P k2){return k1.y<k2.y;});\n    for (int i=0;i<B.size();i++) for (int j=i+1;j<B.size()&&B[j].y-B[i].y<ans;j++) ans=min(ans,B[i].disTo(B[j]));\n    return ans;\n}\n\nint cmpX(P A, P B) { return A.x<B.x; }\n\nint main()\n{\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"out.txt\", \"w\", stdout);\n//    std::ios::sync_with_stdio(false); cin.tie(0);\n\n    vector<P> poly;\n    P ori = P(-1e18, -1e28);\n    poly.push_back(ori);\n    int n;\n    scanf(\"%d\", &n);\n    REP(i, n) {\n        P tmp; tmp.input();\n        poly.push_back(tmp);\n    }\n    sort(poly.begin(), poly.end(), cmpX);\n\n    db ans = closepoint(poly, 0, n);\n    printf(\"%.11lf\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\t最近点対：蟻本 第2版 p 326\n*/\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(A) A.begin(), A.end()\n#define INF 1e100\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<double, double> P;\n\nconst int MAX_N = (int)1e5 + 5;\n\nint N;\nP A[MAX_N];\n\n// y 座標の昇順でマージをするための比較関数\nbool compare_y(P a, P b){\n\treturn a.second < b.second;\n}\n\n// a は x 座標の昇順で渡される\ndouble closest_pair(P *a, int n){\n\tif (n <= 1) return INF;\n\tint m = n / 2;\n\tdouble x = a[m].first;\n\tdouble d = min(closest_pair(a, m), closest_pair(a + m, n - m));\t// (1)\n\tinplace_merge(a, a + m, a + n, compare_y);\t// 2 つのソートされた列をマージ\n\t// この時点で a は y 座標の昇順になっている\n\n\t// (2')\n\tvector<P> b; // 直線から距離 d 未満の頂点を入れていく\n\tfor (int i = 0; i < n; ++i){\n\t\tif (fabs(a[i].first - x) >= d) continue;\n\t\t\n\t\t// b に入っている頂点を、末尾から、y 座標の差が d 以上になるまで見ていく\n\t\tfor (int j = 0; j < (int)b.size(); ++j){\n\t\t\tdouble dx = a[i].first - b[b.size() - j - 1].first;\n\t\t\tdouble dy = a[i].second - b[b.size() - j - 1].second;\n\t\t\tif (dy >= d) break;\n\t\t\td = min(d, sqrt(dx * dx + dy * dy));\n\t\t} // end for\n\t\tb.push_back(a[i]);\n\t} // end for\n\n\treturn d;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> N;\n\trep (i, N){\n\t\tdouble x, y; cin >> x >> y;\n\t\tA[i].first = x; A[i].second = y;\n\t} // end rep\n\n\tsort(A, A + N);\t// x 座標でソート\n\tdouble res = closest_pair(A, N);\n\n\tprintf(\"%.08lf\\n\", res);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    const int loops = 111;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(char j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(char j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + j].first - p2[i].first) * (p2[i + j].first - p2[i].first) + (p2[i + j].second - p2[i].second) * (p2[i + j].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.9f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<double,double> pp;\nvector<pp> a;\n\n#define sqr(x) ((x)*(x))\ndouble Plus (double x){\n\treturn x<0?-x:x;\n}\ndouble dist (pp x, pp y){\n\treturn sqr(x.first-y.first) + sqr(x.second-y.second);\n}\n\ndouble go (int l, int r)\n{\n\tif (r-l==1)\n\t\treturn dist(a[l],a[r]);\n\tif (r-l==2)\n\t\treturn min(dist(a[l],a[l+1]), min(dist(a[l],a[l+2]), dist(a[l+1],a[l+2])));\n\n\tint m=(l+r)/2;\n\tdouble d=min(go(l,m),go(m+1,r));\n\n\tvector<pp> v;\n\tfor (auto i=l;i<=r;i++)\n\t\tif (sqr(a[i].first-a[m].first)<d)\n\t\t\tv.emplace_back (a[i].second,a[i].first);\n\tsort (v.begin(),v.end());\n\tfor (auto i=v.begin();i!=v.end();i++)\n\t\tfor (auto j=i+1;j!=v.end();j++)\n\t\t{\n\t\t\td=min(d,dist(*i,*j));\n\t\t}\n\treturn d;\n}\n\nint main ()\n{\n\tint i,n;\n\tdouble x,y;\n\tscanf (\"%d\",&n);\n\tfor (i=0;i<n;i++)\n\t\tscanf (\"%lf%lf\",&x,&y), a.emplace_back(x,y);\n\tsort (a.begin(),a.end());\n\tprintf (\"%lf \",sqrt(go(0,n-1)));\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / acos(-1));\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * acos(-1) / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\n\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  // if (r - l <= 3) {\n  //   PointPoint res(ps[l], ps[r - 1]);\n  //   for (int i = l; i < r; ++i) {\n  //     for (int j = i + 1; j < r; ++j) {\n  //       res = Closer(res, PointPoint(ps[i], ps[j]));\n  //     }\n  //   }\n  //   return res;\n  // }\n  if (r - l == 2) {\n    return PointPoint(ps[l], ps[l + 1]);\n  }\n  if (r - l == 3) {\n    PointPoint a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return Closer(a, Closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  Points strip;\n  for (int i = l; i < r; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) strip.push_back(ps[i]);\n  }\n\n  for (int i = 0; i < strip.size(); ++i) {\n    for (int j = i + 1; j < strip.size() && abs(strip[j].imag() - strip[i].imag()) < d; ++j) {\n      if (Distance(strip[i], strip[j]) < d) {\n        d = Distance(strip[i], strip[j]);\n        res = PointPoint(strip[i], strip[j]);\n      }\n    }\n  }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  return ClosestPairUtil(ps, 0, ps.size());\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  sort(p.begin(), p.end());\n  PointPoint pp = ClosestPair(p);\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n  // cerr << pp.first << \" \" << pp.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\n/*使用注意 aojでがc++11でしか通らない*/\n/*\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    //two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n\n    two_dimensional_qsort(p_xy, n0, n-1, 1);\n\n    \n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n*/\nbool compare_y(pair<double, double> a,pair<double, double> b){\n    return a.second<b.second;\n}\n\ndouble length_of_the_nearest_point_to(pair<double, double> a[100000], int n){\n    if(n<=1)return 999999999.9;\n    int m=n/2;\n    double x=a[m].first;\n    double d=min(length_of_the_nearest_point_to(a, m), length_of_the_nearest_point_to(a+m, n-m));\n    //inplace_merge(a, a+m, a+n, compare_y);\n    sort(a, a+n, compare_y);\n    vector<pair<double, double>>b;\n    for(int i=0; i<n; i++){\n        if(fabs(a[i].first-x)>=d)continue;\n        for(int j=0; j<b.size(); j++){\n            double dx=a[i].first-b[b.size()-j-1].first;\n            double dy=a[i].second-b[b.size()-j-1].second;\n            if(dy>=d)break;\n            d=min(d,sqrt(dx*dx+dy*dy));\n            \n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n                                      \n                                      \n                                      \nint main(int argc, const char * argv[]){\n    int n;\n    while(cin>>n){\n        pair<double, double> a[100000];\n        for(int i=0; i<n; i++){\n            cin>>a[i].first>>a[i].second;\n        }\n        sort(a, a+n);\n        double ans = length_of_the_nearest_point_to(a, n);\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n    /*\n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        //cout<<\"qaaa\";\n        two_dimensional_qsort(p_xy, 0, n-1, 0);\n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n     */\n}"
  },
  {
    "language": "C++",
    "code": "// http://ir5.hatenablog.com/entry/20131221/1387557630\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <utility>\n#include <cmath>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\ntypedef pair<double, double> P;\ntypedef pair<int, int> IP;\ndouble norm(P a, P b) {\n  double x = a.first - b.first;\n  double y = a.second - b.second;\n  return sqrt(x*x + y*y);\n}\n// http://stackoverflow.com/questions/20590656/\nstruct pairhash {\npublic:\n  template <typename T, typename U>\n  std::size_t operator()(const std::pair<T, U> &x) const {\n    return std::hash<T>()(x.first) ^ std::hash<U>()(x.second);\n  }\n};\nint main() {\n  int N; cin >> N;\n  vector<P> p(N);\n  REP(i,N) {\n    double x, y; cin >> x >> y;\n    p[i] = make_pair(x, y);\n  }\n  double xmin = p[0].first, ymin = p[0].second;\n  REP(i,N) {\n    xmin = min(xmin, p[i].first);\n    ymin = min(ymin, p[i].second);\n  }\n  REP(i,N) {\n    p[i].first -= xmin;\n    p[i].second -= ymin;\n  }\n  // std::rand is often used.\n  random_shuffle(p.begin(), p.end());\n  double delta = norm(p[0], p[1]);\n  unordered_map<IP, vector<int>, pairhash> S;\n  S[IP(p[0].first / delta, p[0].second / delta)].push_back(0);\n  S[IP(p[1].first / delta, p[1].second / delta)].push_back(1);\n  for(int i = 2; i < N; ++i) {\n    IP ip(p[i].first / delta, p[i].second / delta);\n    bool update = false;\n    for(int dx = -1; dx <= 1; ++dx) for(int dy = -1; dy <= 1; ++dy) {\n      for(int j : S[IP(ip.first + dx, ip.second + dy)]) {\n        double d2 = norm(p[i], p[j]);\n        if(delta > d2) {\n          delta = d2;\n          update = true;\n        }\n      }\n    }\n    if(update) {\n      S.clear();\n      for(int j = 0; j <= i; ++j) {\n        S[IP(p[j].first / delta, p[j].second / delta)].push_back(j);\n      }\n    }\n    else {\n      S[ip].push_back(i);\n    }\n  }\n  cout.setf(ios::fixed);\n  cout.precision(6);\n  cout << delta << endl;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/30))  \n #define Fun2(j,n) for(int j=i+(int)(n/30);j<n;j=j+(int)(n/30))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=100;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16??????????????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=0;j<4;j++)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*j+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       real_min=(point[0].x-point[1].x)*(point[0].x-point[1].x)+(point[0].y-point[1].y)*(point[0].y-point[1].y);\n       //real_min=fun_min;\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A?????? \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 200000\npair<long double, long double>pa[MAX_N];\nlong double dist(long double ax, long double ay, long double bx, long double by) { \n\treturn sqrt((ax - bx)*(ax - bx) + (ay - by)*(ay - by));\n}\nint main() {\n\tint N; cin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> pa[i].first >> pa[i].second;\n\t}\n\tsort(pa, pa + N);\n\tlong double maxn = 100000;\n\tlong double G = 200 / (sqrt(N) - 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tlong double L = pa[i].first - G, R = pa[i].first + G;\n\t\tint pos1 = lower_bound(pa, pa + N, make_pair(L, -1000.0L)) - pa;\n\t\tint pos2 = lower_bound(pa, pa + N, make_pair(R, 1000.0L)) - pa;\n\t\tfor (int j = pos1; j < pos2; j++) {\n\t\t\tif (i == j) { continue; }\n\t\t\tmaxn = min(maxn, dist(pa[i].first, pa[i].second, pa[j].first, pa[j].second));\n\t\t}\n\t}\n\tcout << fixed << setprecision(1919) << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ntypedef vector<P> G;\n\ndouble compare_y(const P &a, const P &b){\n  return a.Y < b.Y;\n}\n\ndouble convex_radius(G ps, int left, int right) {\n  if(right - left <= 1) return (double)INF;\n  int m = (right + left) / 2;\n  double d = min(convex_radius(ps, left, m), convex_radius(ps, m, right));\n  sort(ps.begin() + left, ps.begin() + right, compare_y);\n  for(int i = left; i < right; ++i){\n    if(fabs(ps[i].X - ps[m].X) >= d) continue;\n    for(int j = i - 1; j >= left; --j){\n      if(ps[i].Y - ps[j].Y >= d) break;\n      d = min(d, abs(ps[i] - ps[j]));\n    }\n  }\n  return d;\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  SORT(g);\n  printf(\"%.10lf\\n\", convex_radius(g, 0, N));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n    \n    two_dimensional_qsort(p_xy, n0, n-1, 1);\n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        \n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<< ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline bool same ( lf a, lf b ) {\n  return a+EPS > b && b+EPS > a;\n}\n\ninline lf dist ( pt A, pt B ) { return abs( B - A ); }\n\nint n;\npt P[ MAXN ], extra[ MAXN ];\n\nbool cmpX( const pt &A, const pt &B ) {\n  //if( same( A.x, B.x ) ) return A.y+EPS < B.y;\n  return A.x < B.x;\n}\n\n/*\nlf sqr( lf x ) {\n  return x*x;\n}*/\n\nvoid merge( int f, int m, int t ){\n\tint total = t - f + 1;\n\tfor( int i = 0, l = f, r = m+1; i < total; ++i ){\n\t\tif( l == m+1 ){\n      extra[ i ] = P[ r++ ];\n\t\t}\n\t\telse if( r == t+1 ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse if( P[l].y < P[r].y ){\n\t\t  extra[ i ] = P[ l++ ];\n\t\t}\n\t\telse{\n\t\t  extra[ i ] = P[ r++ ];\n\t\t}\n\t}\n\tfor( int i = 0; i < total; ++i ){\n    P[ f+i ] = extra[ i ];\n\t}\n}\n\nlf solve( int f, int t ) {\n  if( f == t ) return oo;\n\tint mi = (f + t)/2;\n\tlf d = min( solve( f, mi ), solve( mi+1, t ) );\n\tmerge( f, mi, t );\n\tvector< int > idxs;\n\tfor( int i = f; i <= t; ++i ){\n\t\tif( fabs(P[mi].x - P[i].x) < d ) idxs.push_back( i );\n\t}\n\tfor( int i = 0; i < idxs.size(); ++i ){\n\t\tfor( int j = i+1; j < idxs.size() && (P[ idxs[i] ].y - P[ idxs[j] ].y < d); ++j ){\n\t\t\td = min( d, dist( P[ idxs[i] ], P[ idxs[j] ] ) );\n\t\t}\n\t}\n\treturn d;\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"CGL_5_A-in15.txt\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> P[i];\n  }\n  sort( P, P+n, cmpX );\n  /*d = oo;\n  for( int i = 0; i < n; ++i ) {\n    for( int j = i+1; j < n; ++j ) {\n      d = min( d, dist(P[i],P[j]) );\n    }\n  }\n  cout << double(sqrt(d)) << '\\n';*/\n  cout << double( solve( 0, n-1 ) ) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ndouble x[110000];\ndouble y[110000];\npair<double,double>p[110000];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tdouble X,Y;\n\t\tscanf(\"%lf%lf\",&X,&Y);\n\t\tx[i]=cos(1)*X-sin(1)*Y;\n\t\ty[i]=sin(1)*X+cos(1)*Y;\n\t\tp[i]=make_pair(x[i],y[i]);\n\t}\n\tstd::sort(p,p+a);\n\tdouble ret=99999999;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=i-1;j>=0;j--){\n\t\t\tif(p[i].first-p[j].first>ret)break;\n\t\t\tret=min(ret,sqrt((p[i].first-p[j].first)*(p[i].first-p[j].first)+(p[i].second-p[j].second)*(p[i].second-p[j].second)));\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\ntypedef db T;\nconst db eps = 1e-8;\nint sgn(T x){return (x>eps)-(x<-eps);}\nstruct P{\n    T x,y;\n    P(){} P(T x,T y):x(x),y(y){}\n    void read(){scanf(\"%lf%lf\",&x,&y);}\n    P operator - (const P&b) const {return P(x-b.x,y-b.y);}\n    P operator + (const P&b) const {return P(x+b.x,y+b.y);}\n    T operator * (const P&b) const {return x*b.x+y*b.y;}\n    P operator * (const T&k) const {return P(x*k,y*k);}\n    T operator ^ (const P&b) const {return x*b.y-y*b.x;}\n    bool operator < (const P&b) const {return sgn(y-b.y)?y<b.y:x<b.x;}\n};\nT abs(P a){return sqrt(a*a);}\n\nnamespace NearestPoints{\n    T Min;P tmp[100000];\n    void Update(T d) {Min = min(Min , d);}\n    T solve(int l,int r,vector<P>&p){\n        if(l == r) return 1e100;\n        int m=(l+r)>>1;\n        T Xm = p[m].x , lim = min(solve(l,m,p) , solve(m+1,r,p));\n        int i=l,j=m+1,ii=m,jj=r,k=l;\n        while(i<=ii||j<=jj) tmp[k++] = p[(i<=ii&&(j>jj||p[i].y<p[j].y)?i:j)++];\n        vector<P> V;\n        rep(i,l,r+1){\n            p[i] = tmp[i];\n            if(fabs(p[i].x - Xm) <= lim) V.pb(p[i]);\n        }\n        rep(i,0,sz(V)) rep(j,i+1,sz(V)){\n            if(fabs(V[j].y - V[i].y) >= lim) break;\n            T dis = abs(V[i]-V[j]);\n            Update(dis);lim = min(lim,dis);\n        }\n        return lim;\n    }\n    T solve(vector<P> A){\n        Min = 1e100;\n        solve(0,sz(A)-1,A);\n        return Min;\n    }\n}\n\nint main(){\n    int n;scanf(\"%d\",&n);\n    vector<P> A;\n    rep(i,0,n){\n        P p;p.read();\n        A.pb(p);\n    }\n    printf(\"%.10f\\n\",NearestPoints::solve(A));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n\nusing ld = double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ntemplate<class iter>\ntuple<ld, P, P> closest_pair(iter left, iter right) {\n    int n = distance(left, right);\n    if(n <= 1) return make_tuple(numeric_limits<ld>::max(), *left, *left);\n    iter middle = next(left, n/2);\n    ld x = middle->real();\n    auto d = min(closest_pair(left, middle), closest_pair(middle, right));\n    inplace_merge(left, middle, right, [](const P &a, const P &b){\n            return a.imag() < b.imag();\n        });\n    vector<iter> around;\n    for(iter i = left; i != right; ++i){\n        ld dx = fabs(i->real() - x);\n        ld &opt = get<0>(d);\n        if(dx*dx >= opt) continue;\n        for(auto j = around.rbegin(); j != around.rend(); ++j){\n            ld dx = i->real() - (**j).real();\n            ld dy = i->imag() - (**j).imag();\n            if(dy*dy >= opt) break;\n            ld norm = dx*dx + dy*dy;\n            if(get<0>(d) > norm){\n                d = make_tuple(norm, *i, **j);\n            }\n        }\n        around.push_back(i);\n    }\n    return d;\n};\n\n// http://www.spoj.com/problems/CLOPPAIR/\n// 18124516\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout << fixed << setprecision(6) << endl;\n    int n;\n    cin >> n;\n    vector<P> a;\n    rep(i,n){\n        ld x,y;\n        cin >> x >> y;\n        a.emplace_back(x,y);\n    }\n    ld z;\n    P x, y;\n    sort(all(a));\n    tie(z, x, y) = closest_pair(all(a));\n    cout << sqrt(z) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    const int loops = 125;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(loops, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + j].first - p2[i].first) * (p2[i + j].first - p2[i].first) + (p2[i + j].second - p2[i].second) * (p2[i + j].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief (n 2) = Θ(n^2)通りの点対を調べ、最近点対間距離を返す\n *\n * @param const point*P 点集合P\n * @param index_t n     Pの要素数\n */\nstatic elem_t brute_force_closest_pair(const point*P, index_t n)\n{\n    elem_t minimum = std::numeric_limits<elem_t>::max();\n    for (index_t i = 0; i < n; i++) {\n        for (index_t j = i + 1; j < n; j++) {\n            elem_t dist = abs(P[i] - P[j]);\n            minimum = std::min(minimum, dist);\n        }\n    }\n    return minimum;\n}\n\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 3) {  // |P| <= 3か否かを判定する\n        return brute_force_closest_pair(P, n);  // |P| <= 3ならば、虱潰で問題を解く\n    }\n\n    // |P| > 3ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら5個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = std::numeric_limits<elem_t>::max();\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if (P[i].y - p.y >= delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = min(abs(data[i + 1].second - data[i].second), ans + 0.00019);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&memo >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans =(min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tmemo = min(memo, ans + 0.00019);\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define endl '\\n'\n#define maxn 100010\nconst int MOD = 1000000007;\n\nint n;\n\ndouble closest_pair(vector<pair<double, double>> &v) {\n    sort(v.begin(), v.end());\n    double ans = DBL_MAX;\n    set<pair<double, double>> box;\n    int lt = 0;\n    box.insert({v.front().second, v.front().first});\n    for (int i = 1; i < n; i++) {\n        while (lt < i and v[i].first - v[lt].first > ans)box.erase({v[lt].second, v[lt].first}), lt++;\n        for (auto it = box.lower_bound({v[i].second - ans, v[i].first - ans});\n             it != box.end() and v[i].second + ans >= it->first; it++) {\n            ans = min(ans, sqrt(pow(v[i].first - it->second, 2) + pow(v[i].second - it->first, 2)));\n        }\n        box.insert({v[i].second, v[i].first});\n    }\n    return ans;\n}\n\nvoid solve() {\n    cin >> n;\n    vector<pair<double, double>> v(n);\n    for (int i = 0; i < n; i++)cin >> v[i].first >> v[i].second;\n    cout << fixed << setprecision(10) << closest_pair(v) << endl;\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n//    cin >> t;\n\n    while (t--)\n        solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n\nusing ld = double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ntemplate<class iter>\ntuple<ld, P, P> closest_pair(iter left, iter right) {\n    int n = distance(left, right);\n    if(n <= 1) return make_tuple(numeric_limits<ld>::max(), *left, *left);\n    if(n == 2) return make_tuple(norm(left[0]-left[1]), left[0], left[1]);\n    iter middle = next(left, n/2);\n    ld x = middle->real();\n    auto d = min(closest_pair(left, middle), closest_pair(middle, right));\n    inplace_merge(left, middle, right, [](const P &a, const P &b){\n            return a.imag() < b.imag();\n        });\n    vector<iter> around;\n    for(iter i = left; i != right; ++i){\n        ld dx = fabs(i->real() - x);\n        ld &opt = get<0>(d);\n        if(dx*dx >= opt) continue;\n        for(auto j = around.rbegin(); j != around.rend(); ++j){\n            ld dx = i->real() - (**j).real();\n            ld dy = i->imag() - (**j).imag();\n            if(dy*dy >= opt) break;\n            ld norm = dx*dx + dy*dy;\n            if(get<0>(d) > norm){\n                d = make_tuple(norm, *i, **j);\n            }\n        }\n        around.push_back(i);\n    }\n    return d;\n};\n\n// http://www.spoj.com/problems/CLOPPAIR/\n// 18124516\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout << fixed << setprecision(6) << endl;\n    int n;\n    cin >> n;\n    vector<P> a;\n    rep(i,n){\n        ld x,y;\n        cin >> x >> y;\n        a.emplace_back(x,y);\n    }\n    ld z;\n    P x, y;\n    sort(all(a));\n    tie(z, x, y) = closest_pair(all(a));\n    cout << sqrt(z) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst double INFTY = 10000000000000000000.0;\n\nstruct Point { double x, y; };\nbool compareX(Point& a, Point& b) {\n\treturn a.x < b.x ? true : a.x == b.x && a.y <= b.y ? true : false;\n}\n\nbool compareY(Point& a, Point& b) {\n\treturn a.y < b.y ? true : a.y == b.y && a.x <= b.x ? true : false;\n}\n\ninline double getSquareDist(Point a, Point b) {\n\treturn (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\ninline double getMinSquareDistOfThree(Point a, Point b, Point c) {\n\treturn min(getSquareDist(a, b), min(getSquareDist(a, c), getSquareDist(b, c)));\n}\n\ndouble getMinSquareDistNearMid(Point nearmid[], int nearmid_length) {\n\tsort(nearmid, nearmid + nearmid_length, compareY);\n\n\tdouble min_sq_dist = INFTY;\n\tdouble cur_sq_dist;\n\tfor (int i = 0; i < nearmid_length; ++i) {\n\t\t// a better implementation:\n\t\t//for (int j = i + 1; j < min(nearmid_length, i + 8); ++j) {\n\t\tfor (int j = i + 1; j < nearmid_length && (nearmid[j].y - nearmid[i].y) < min_sq_dist; ++j) {\n\t\t\tcur_sq_dist = getSquareDist(nearmid[i], nearmid[j]);\n\t\t\tif (cur_sq_dist < min_sq_dist)\n\t\t\t\tmin_sq_dist = cur_sq_dist;\n\t\t}\n\t}\n\treturn min_sq_dist;\n}\n\n// nlog^2 n, not nlog n in CLRS\ndouble dcClosestSquareDist(int low, int high, Point points[]) {\n\tif (high - low == 1) {\n\t\treturn getSquareDist(points[low], points[high]);\n\t}\n\telse if (high - low == 2) {\n\t\treturn getMinSquareDistOfThree(points[low], points[low + 1], points[high]);\n\t}\n\telse {\n\t\t// bug 3: + has higher precedence than >>\n\t\t//int mid = low + (high - low) >> 1;\n\t\tint mid = low + ((high - low) >> 1);\n\t\tdouble d_left = dcClosestSquareDist(low, mid, points);\n\t\tdouble d_right = dcClosestSquareDist(mid + 1, high, points);\n\t\tdouble d_divide = min(d_left, d_right);\n\t\tdouble d_divide_sqrt = sqrt(d_divide);\n\n\t\t// merge\n\t\tPoint *nearmid = new Point[high - low + 1];\n\t\tint nearmid_length = 0;\n\t\tfor (int i = low; i <= high; ++i) {\n\t\t\t// bug 4: here we should compare the dist with real dist, not squared!\n\t\t\tif (points[i].x - points[mid].x < d_divide_sqrt && points[i].x - points[mid].x > -d_divide_sqrt) {\n\t\t\t\tnearmid[nearmid_length] = points[i];\n\t\t\t\tnearmid_length++;\n\t\t\t}\n\t\t}\n\t\tdouble d_merge = getMinSquareDistNearMid(nearmid, nearmid_length);\n\t\t// bug 6: forget to free memory\n\t\tdelete[] nearmid;\n\t\treturn min(d_divide, d_merge);\n\t}\n}\n\ndouble getMinSqDistToFirst(Point first_camera, Point points[], int n) {\n\tdouble min_sq_dist = INFTY;\n\tdouble cur_sq_dist;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcur_sq_dist = getSquareDist(first_camera, points[i]);\n\t\tif (cur_sq_dist < min_sq_dist)\n\t\t\tmin_sq_dist = cur_sq_dist;\n\t}\n\treturn min_sq_dist;\n}\n\ndouble getArea(double candidate, double min_dist_to_first, int n) {\n\treturn candidate * candidate + (n - 1) * (min_dist_to_first - candidate) * (min_dist_to_first - candidate);\n}\n\n/*\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tint n;\n\tPoint points[MAX_N];\n\tPoint first_camera;\n\tdouble min_dist_to_first;\n\tdouble min_dist_among_others;\n\tdouble candidate1;\t// candidate1 = max(0, d1 - d2 / 2)\n\tdouble candidate2;\t// candidate2 = d1\n\tdouble max_area;\n\tfor (int i = 1; i <= t; ++i) {\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%lf%lf\", &(first_camera.x), &(first_camera.y));\n\t\tfor (int j = 0; j < n - 1; ++j) {\n\t\t\tscanf(\"%lf%lf\", &(points[j].x), &(points[j].y));\n\t\t}\n\t\tmin_dist_to_first = sqrt(getMinSqDistToFirst(first_camera, points, n));\n\t\tif (n == 2) {\n\t\t\tmin_dist_among_others = INFTY;\n\t\t}\n\t\telse {\n\t\t\tsort(points, points + n - 1, compareX);\n\t\t\tmin_dist_among_others = sqrt(dcClosestSquareDist(0, n - 2, points));\n\t\t}\n\t\t//printf(\"%f\\n\", min_dist_among_others);\n\t\tcandidate1 = max(0.0, min_dist_to_first - min_dist_among_others / 2.0);\n\t\tcandidate2 = min_dist_to_first;\n\t\tmax_area = M_PI * max(getArea(candidate1, min_dist_to_first, n), getArea(candidate2, min_dist_to_first, n));\n\t\tprintf(\"Case #%d: %.8f\\n\", i, max_area);\n\t}\n    return 0;\n}\n*/\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tPoint* points = new Point[MAX_N];\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%lf%lf\", &(points[i].x), &(points[i].y));\n\t}\n\tsort(points, points + n, compareX);\n\tprintf(\"%.10lf\\n\", sqrt(dcClosestSquareDist(0, n, points)));\n\tdelete[] points;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct node{\n  int dim;\n  vector<double>v;\n};\n\ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n\ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n\n  vector<node>res;\n\n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n\n    double dist=d(p,S)/(4*p.dim);\n\n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n\n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    \n    S=nextS;    \n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n  \n  return ans;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n\n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for(int i=(a);i<(n);i++)\n#define per(i,a,n) for(int i=(n)-1;i>=(a);i--)\n#define MP make_pair\n\ntypedef double db;\n\nconst db EPS = 1e-8;\n\ninline int sign(db a) {\n\treturn a < -EPS ? -1 : a > EPS;\n}\n\ninline int cmp(db a, db b){\n\treturn sign(a-b);\n}\n\nstruct P {\n\tdb x, y;\n\tP() {\n\t}\n\tP(db _x, db _y) :\n\t\t\tx(_x), y(_y) {\n\t}\n\tP operator+(P p) {\n\t\treturn P(x + p.x, y + p.y);\n\t}\n\tP operator-(P p)  {\n\t\treturn P(x - p.x, y - p.y);\n\t}\n\tP operator*(db d) {\n\t\treturn P(x * d, y * d);\n\t}\n\tP operator/(db d) {\n\t\treturn P(x / d, y / d);\n\t}\n\tbool operator<(P p) const {\n\t\tint c = sign(x - p.x);\n\t\tif (c)\n\t\t\treturn c == -1;\n\t\treturn sign(y - p.y) == -1;\n\t}\n\tdb dot(P p) {\n\t\treturn x * p.x + y * p.y;\n\t}\n\tdb det(P p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdb distTo(P p) { return (*this-p).abs(); }\n\n\tdb alpha() {\n\t\treturn atan2(y, x);\n\t}\n\tvoid read() {\n\t\tcin>>x>>y;\n\t}\n\tdb abs() {\n\t\treturn sqrt(abs2());\n\t}\n\tdb abs2() {\n\t\treturn x * x + y * y;\n\t}\n\tP rot90(){\n\t\treturn P(-y,x);\n\t}\n};\n\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))\n\nP isLL(P p1, P p2, P q1, P q2) {\n\tdb a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n}\n\nbool intersect(db l1,db r1,db l2,db r2){\n\tif(l1>r1) swap(l1,r1); if(l2>r2) swap(l2,r2); \n\treturn !( cmp(r1,l2) == -1 || cmp(r2,l1) == -1 );\n}\n\nbool isSS(P p1, P p2, P q1, P q2){\n    return intersect(p1.x,p2.x,q1.x,q2.x) && intersect(p1.y,p2.y,q1.y,q2.y) && \n    crossOp(p1,p2,q1) * crossOp(p1,p2,q2) <= 0 && crossOp(q1,q2,p1)\n            * crossOp(q1,q2,p2) <= 0;\n}\n\nbool isMiddle(db a, db m, db b) {\n    return sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);\n}\n \nbool isMiddle(P a, P m, P b) {\n    return isMiddle(a.x, m.x, b.x) && isMiddle(a.y, m.y, b.y);\n}\n\nbool onSeg(P p1, P p2, P q){\n\treturn crossOp(p1,p2,q) == 0 && isMiddle(p1, q, p2);\n}\n\nP proj(P p1, P p2, P q) {\n    P dir = p2 - p1;\n    return p1 + dir * (dir.dot(q - p1) / dir.abs2());\n}\n\nP reflect(P p1, P p2, P q){\n\treturn proj(p1,p2,q) * 2 - q;\n}\n\ndb nearest(P p1,P p2,P q){\n\tP h = proj(p1,p2,q);\n\tif(isMiddle(p1,h,p2))\n\t\treturn q.distTo(h);\n\treturn min(p1.distTo(q),p2.distTo(q));\n}\n\ndb disSS(P p1, P p2, P q1, P q2){\n\tif(isSS(p1,p2,q1,q2)) return 0;\n\treturn min(min(nearest(p1,p2,q1),nearest(p1,p2,q2)), min(nearest(q1,q2,p1),nearest(q1,q2,p2)) );\n}\n\ndb getrad(P p1,P p2){\n\treturn atan2l(p1.det(p2),p1.dot(p2));\n}\n\ndb incircle(P p1, P p2, P p3){\n\tdb A = p1.distTo(p2);\n\tdb B = p2.distTo(p3);\n\tdb C = p3.distTo(p1);\n\treturn sqrtl(A*B*C/(A+B+C));\n}\n\ndb area(vector<P> ps){\n\tdb ret = 0; rep(i,0,ps.size()) ret += ps[i].det(ps[(i+1)%ps.size()]); \n\treturn abs(ret/2);\n}\n\nint contain(vector<P> ps, P p){ //2:inside,1:on_seg,0:outside\n\tint n = ps.size(), ret = 0;\t\n\trep(i,0,n){\n\t\tP u=ps[i],v=ps[(i+1)%n];\n\t\tif(onSeg(u,v,p)) return 1;\n\t\tif(cmp(u.y,v.y)<=0) swap(u,v);\n\t\tif(cmp(p.y,u.y) >0 || cmp(p.y,v.y) <= 0) continue;\n\t\tret ^= crossOp(p,u,v) > 0;\n\t}\n\treturn ret*2;\n}\n\nvector<P> convexHull(vector<P> ps) {\n    int n = ps.size(); if(n <= 1) return ps;\n    sort(ps.begin(), ps.end());\n    vector<P> qs(n * 2); int k = 0;\n    for (int i = 0; i < n; qs[k++] = ps[i++]) \n        while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;\n    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])\n       \twhile (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;\n    qs.resize(k - 1);\n    return qs;\n}\n\nvector<P> convexHullNonStrict(vector<P> ps) {\n    int n = ps.size(); if(n <= 1) return ps;\n    sort(ps.begin(), ps.end());\n    vector<P> qs(n * 2); int k = 0;\n    for (int i = 0; i < n; qs[k++] = ps[i++]) \n        while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;\n    for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])\n       \twhile (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;\n    qs.resize(k - 1);\n    return qs;\n}\n\ndb convexDiameter(vector<P> ps){\n\tint n = ps.size(); if(n <= 1) return 0;\n\tint is = 0, js = 0; rep(k,1,n) is = ps[k]<ps[is]?k:is, js = ps[js] < ps[k]?k:js;\n\tint i = is, j = js;\n\tdb ret = ps[i].distTo(ps[j]);\n\tdo{\n\t\tif((ps[(i+1)%n]-ps[i]).det(ps[(j+1)%n]-ps[j]) >= 0)\n\t\t\t(++j)%=n;\n\t\telse\n\t\t\t(++i)%=n;\n\t\tret = max(ret,ps[i].distTo(ps[j]));\n\t}while(i!=is || j!=js);\n\treturn ret;\n}\n\nvector<P> convexCut(const vector<P>&ps, P q1, P q2) {\n\tvector<P> qs;\n\tint n = ps.size();\n\trep(i,0,n){\n\t\tP p1 = ps[i], p2 = ps[(i+1)%n];\n\t\tint d1 = crossOp(q1,q2,p1), d2 = crossOp(q1,q2,p2);\n\t\tif(d1 >= 0) qs.push_back(p1);\n\t\tif(d1 * d2 < 0) qs.push_back(isLL(p1,p2,q1,q2));\n\t}\n\treturn qs;\n}\n\ndb min_dist(vector<P>&ps,int l,int r){\n\tif(r-l<=5){\n\t\tdb ret = 1e100;\n\t\trep(i,l,r) rep(j,l,i) ret = min(ret,ps[i].distTo(ps[j]));\n\t\treturn ret;\n\t}\n\tint m = (l+r)>>1;\n\tdb ret = min(min_dist(ps,l,m),min_dist(ps,m,r));\n\tvector<P> qs; rep(i,l,r) if(abs(ps[i].x-ps[m].x)<= ret) qs.push_back(ps[i]);\n\tsort(qs.begin(), qs.end(),[](P a,P b) -> bool {return a.y<b.y; });\n\trep(i,1,qs.size()) for(int j=i-1;j>=0&&qs[j].y>=qs[i].y-ret;--j) ret = min(ret,qs[i].distTo(qs[j]));\n\treturn ret;\n}\n\nint main(){\n\tint n;cin>>n;\n\tvector<P> ps(n);\n\trep(i,0,n) ps[i].read();\n\tsort(ps.begin(), ps.end());\n\tprintf(\"%0.10f\\n\",min_dist(ps,0,ps.size()));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    double sqr_ans = 100000000.0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = i + 1; j < n; j++)\n        {\n            sqr_ans = min((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]), sqr_ans);\n        }\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\nusing namespace std;\n\nconst double EPS = 1e-10;\ndouble add(double a, double b) {\n    if(abs(a+b) < EPS*(abs(a)+abs(b))) return 0;\n    return a+b;\n}\nstruct Vector {\n    double x, y;\n    Vector() {}\n    Vector(double x, double y):x(x), y(y) {}\n    Vector operator+(Vector v) {return Vector(add(x, v.x), add(y, v.y));}\n    Vector operator-(Vector v) {return Vector(add(x, -v.x), add(y, -v.y));}\n    Vector operator*(double d) {return Vector(x*d, y*d);}\n    Vector operator/(double d) {return Vector(x/d, y/d);}\n    double dot(Vector v) {return add(x*v.x, y*v.y);}\n    double cross(Vector v) {return add(x*v.y, -y*v.x);}\n};\nistream &operator>>(istream &is, Vector &v) {return is >> v.x >> v.y;}\nostream &operator<<(ostream &os, const Vector &v) {return os << v.x << ' ' << v.y;}\ndouble sqdist(Vector &v, const Vector &u) {return (v-u).dot(v-u);}\n//線分v2-v1上にあるか\nbool on_seg(Vector &v1,Vector &v2, const Vector &p) {\n    return (v1-p).cross(v2-p) == 0 && (v1-p).dot(v2-p) <= 0;\n}\n//v1-v2とu1-u2の交点\nVector intersection(Vector &v1,Vector &v2,Vector &u1,Vector &u2) {\n    assert((v1-v2).cross(u1-u2)); //2直線が平行だとだめ\n    return v1 + (v2-v1)*((u2-u1).cross(u1-v1)/(u2-u1).cross(v2-v1));\n}\n//p2-p1へのQの投影\nVector projection(Vector &p1,Vector &p2,Vector &Q) {\n    return p1+(p2-p1)*(Q-p1).dot(p2-p1)/sqdist(p1, p2);\n}\n//p1-p2を軸としたQの線対称移動\nVector reflection(Vector &p1,Vector &p2,Vector &Q) {\n    return projection(p1, p2, Q)*2-Q;\n}\nbool cmp_x(const Vector &v, const Vector &u) {\n    if(v.x != u.x) return v.x < u.x;\n    return v.y < u.y;\n}\nbool cmp_y(const Vector &v, const Vector &u) {\n    if(v.y != u.y) return v.y < u.y;\n    return v.x < u.x;\n}\n//頂点数nの頂点集合vv\nvector<Vector> convex_hull(vector<Vector> &vv, int n) {\n    sort(vv.begin(), vv.end(), cmp_x);\n    int k = 0;\n    vector<Vector> res(n*2);\n    for(int i = 0; i < n; i++) {\n        while(k > 1 && (res[k-1]-res[k-2]).cross(vv[i]-res[k-1]) <= 0) k--;\n        res[k++] = vv[i];\n    }\n    for(int i = n-2, t = k; i >= 0; i--) {\n        while(k > t && (res[k-1]-res[k-2]).cross(vv[i]-res[k-1]) <= 0) k--;\n        res[k++] = vv[i];\n    }\n    res.resize(k-1);\n    return res;\n}\n//点と線の距離\ndouble distpl(Vector &p0, Vector &p1, Vector &Q) {\n    Vector pp = projection(p0, p1, Q);\n    return sqrt(sqdist(pp, Q));\n}\n//線分と線分の距離\ndouble distss(Vector &p0, Vector &p1, Vector &p2, Vector &p3) {\n    if((p0-p1).cross(p2-p3) != 0) {\n        Vector p = intersection(p0, p1, p2, p3);\n        if(on_seg(p0, p1, p) and on_seg(p2, p3, p)) {\n            return 0.0;\n        }\n    }\n    double res = min({sqdist(p0, p2), sqdist(p0, p3), sqdist(p1, p2), sqdist(p1, p3)});\n    Vector pp0, pp1, pp2, pp3;\n    pp2 = projection(p0, p1, p2);\n    pp3 = projection(p0, p1, p3);\n    pp0 = projection(p2, p3, p0);\n    pp1 = projection(p2, p3, p1);\n    if(on_seg(p0, p1, pp2)) res = min(res, sqdist(pp2, p2));\n    if(on_seg(p0, p1, pp3)) res = min(res, sqdist(pp3, p3));\n    if(on_seg(p2, p3, pp0)) res = min(res, sqdist(pp0, p0));\n    if(on_seg(p2, p3, pp1)) res = min(res, sqdist(pp1, p1));\n    res = sqrt(res);\n    return res;\n}\n\ndouble closestPair(vector<Vector> &vv, int l, int r) {\n    if(r-l <= 1) return 1e9;\n    int m = (l+r)/2;\n    double x = vv[m].x;\n    double d = min(closestPair(vv, l, m), closestPair(vv, m, r));\n    inplace_merge(vv.begin()+l, vv.begin()+m, vv.begin()+r, cmp_y);\n    vector<Vector> b;\n    for(int i = l; i < r; i++) {\n        if(abs(x-vv[i].x) >= d) continue;\n        for(int j = b.size()-1; j >= 0; j--) {\n            if((vv[i]-b[j]).y >= d) break;\n            d = min(d, sqrt(sqdist(vv[i], b[j])));\n        }\n        b.push_back(vv[i]);\n    }\n    return d;\n}\n\ndouble closestPair(vector<Vector> &vv) {\n    sort(vv.begin(), vv.end(), cmp_x);\n    return closestPair(vv, 0, vv.size());\n}\n\nsigned main() {\n    cout << fixed << setprecision(13);\n    int n;\n    cin >> n;\n    vector<Vector> X(n);\n    rep(i, n) {\n        cin >> X[i];\n    }\n\n    cout << closestPair(X) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(__typeof((o).begin()) it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T> >& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){EACH(a,ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;EACH(p,m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\ntemplate<> long double INF<long double>(){return 1e16;};\n\ntemplate<typename T> T pmod(T v,T M){return (v%M+M)%M;}\n\nnamespace _double_tmpl{\n    typedef long double D;const D EPS = 1e-8;\n    \n    static constexpr D Ae=0;\n    D A(D a,D b){return a+b;}D Ainv(D a){return -a;}\n    D S(D a,D b){return A(a,Ainv(b));}\n    \n    static constexpr D Me=1;\n    D M(D a,D b){return a*b;}D Minv(D a){return 1.0/a;};\n\n    int sig(D a,D b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n    bool eq(D a,D b){ return sig(abs(a-b))==0;}\n\n}\nusing namespace _double_tmpl;\n\n\nnamespace Ps{\n    // using namespace _double_tmpl;\n    typedef complex<D> P,Vec;\n\n#define X real()\n#define Y imag()\n    istream& operator >> (istream& is,complex<D>& p){\n        D x,y;is >> x >> y;p=P(x,y);return is;\n    }\n\n    bool eq(P a,P b){return eq(a.X,b.X) and eq(a.Y,b.Y);}\n    // a×b\n    D cross(const Vec& a,const Vec& b){return imag(conj(a)*b);}\n    // a・b\n    D dot(const Vec&a,const Vec& b) {return real(conj(a)*b);}\n\n    int ccw(const P& a,P b,P c){\n        b -= a; c -= a;\n        if (cross(b,c) > EPS)   return +1;       // counter clockwise\n        if (cross(b,c) < -EPS)   return -1;       // clockwise\n        if (dot(b,c) < 0)     return +2;       // c--a--b on line\n        if (norm(b) < norm(c)) return -2;       // a--b--c on line\n        return 0;\n    }\n\n    bool compX (const P& a,const P& b);bool compY (const P& a,const P& b);\n    D closestPair(vector<P>& ps,int l,int r){\n        if(r-l<2)return INF<D>();\n        D res=INF<D>();\n        res=min(res,closestPair(ps,l,(l+r)/2));\n        res=min(res,closestPair(ps,(l+r)/2,r));\n        \n        vector<P> lps,rps;\n        D lym=INF<D>(),lyM=-INF<D>(),rym=INF<D>(),ryM=-INF<D>();\n        FOR(i,l,(l+r)/2)if(abs(ps[i].X - ps[(l+r)/2].X)<res)lps.push_back(ps[i]),lym=min(lym,lps[i].Y),lyM=max(lyM,lps[i].Y);\n        FOR(i,(l+r)/2,r)if(abs(ps[i].X - ps[(l+r)/2].X)<res)rps.push_back(ps[i]),rym=min(rym,rps[i].Y),ryM=max(ryM,rps[i].Y);\n        vector<P> lps2,rps2;\n        REP(i,lps.size())if(rym-res<=lps[i].Y && lps[i].Y<=ryM+res)lps2.push_back(lps[i]);\n        REP(i,rps.size())if(lym-res<=rps[i].Y && rps[i].Y<=lyM+res)rps2.push_back(rps[i]);\n\n        REP(i,lps2.size())REP(j,rps2.size())res=min(res,abs(lps2[i]-rps2[j]));\n        return res;\n    }\n}\nusing namespace Ps;\n\nnamespace std{\n\n    bool compX (const P& a,const P& b){return a.X != b.X ? a.X < b.X : a.Y < b.Y;}\n    bool compY (const P& a,const P& b){return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;}\n    bool operator < (const P& a,const P& b){return compX(a,b);}\n    bool operator == (const P& a,const P& b){return eq(a,b);}\n};\n\nstringstream ss;\nclass Main{\n    public:\n    void run(){\n        int n;cin >> n;\n        vector<P> ps;\n        REP(i,n) {\n            P p;cin >> p;\n            ps.push_back(p);\n        }\n        sort(ALL(ps));\n        cout << closestPair(ps,0,n)<<endl;\n    }\n};\n\nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.00000000001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct vec{\n  double x, y;\n  void nextvec(){ scanf(\"%lf %lf\", &x, &y); return; }\n  vec operator+(const vec& a) const { return (vec){x + a.x, y + a.y}; }\n  vec operator-(const vec& a) const { return (vec){x - a.x, y - a.y}; }\n  vec operator*(const double& k) const { return (vec){k * x, k * y}; }\n  vec sca(double t){ return (vec){t * x, t * y}; }\n  double dot(vec a){ return x * a.x + y * a.y; }\n  double cross(vec a){ return x * a.y - y * a.x; }\n  double norm(){ return sqrt(x * x + y * y); }\n  double norm2(){ return x * x + y * y; }\n};\n\nbool xsort(vec qwe, vec rty){ return qwe.x < rty.x; }\nbool ysort(vec qwe, vec rty){ return qwe.y < rty.y; }\n\nvec pt[100000];\ndouble ma = 100000000000.0;\n\nvec ytmp[100000];\nvec ymerge[100000];\ndouble closestpair(int l, int r){\n  if(r - l <= 1)return ma;\n  int m = l + (r - l) / 2;\n  double xm = pt[m].x;\n  double res = closestpair(l, m);\n  res = min(res, closestpair(m, r));\n\n  int hdmerge = 0, hdtmp = 0, lhd = l, rhd = m;\n  vec now;\n  for(;;){\n    if(lhd == m && rhd == r)break;\n    else if(rhd == r)now = pt[lhd++];\n    else if(lhd == m)now = pt[rhd++];\n    else if(ysort(pt[lhd], pt[rhd]))now = pt[lhd++];\n    else now = pt[rhd++];\n\n    ymerge[hdmerge++] = now;\n    if(now.x - xm <= res + eps){\n      ytmp[hdtmp++] = now;\n      for(int i = hdtmp - 2;i >= 0;--i){\n        if(ytmp[i].y - now.y >= res - eps)break;\n        res = min(res, (now - ytmp[i]).norm());\n      }\n    }\n  }\n  for(int i = l;i < r;++i)pt[i] = ymerge[i - l];\n\n  return res;\n}\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int(n);\n    rep(i, n)pt[i].nextvec();\n    sort(pt, pt + n, xsort);\n    printf(\"%.13lf\\n\", closestpair(0, n));\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n   \ntypedef pair<double,double> P;\ntypedef pair<P,double> P2;\n   \nP rot(P p, double a){\n  a=a*M_PI/180.0;\n  return P(p.first*cos(a)+p.second*(-sin(a)),\n  p.first*sin(a)+p.second*cos(a));\n}\n   \ndouble abss(P a,P b){\n  return sqrt((a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second));\n}\n   \ndouble x,y,r;int tt;\nvector<P>v;\nint main(){\n   \n  int n;\n  cin>>n;\n   \n    double ans=1e13;\n       \n    v.clear();\n     \n    r(i,n){\n      cin>>x>>y;\n      v.push_back(P(x,y));\n    }\n   \n    r(i,1){\n      sort(v.begin(),v.end());\n      r(j,n){\n        for(int k=j+1,c=0;k<n;k++,c++){\n          if(c>1000)break;\n          ans=min(ans,abss(v[k],v[j]));\n        }\n      }\n      r(j,n)v[i]=rot(v[i],0.5);\n    }\n   \n    printf(\"%.11f\\n\",ans);\n       \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<ctime>\n#include<vector>\n\nusing namespace std;\n\n#define eps 0.0000000001\n\nstruct vec{\n  double x, y;\n  void nextvec(){ scanf(\"%lf %lf\", &x, &y); return; }\n  vec operator+(const vec& a) const { return (vec){x + a.x, y + a.y}; }\n  vec operator-(const vec& a) const { return (vec){x - a.x, y - a.y}; }\n  vec operator*(const double& k) const { return (vec){k * x, k * y}; }\n  vec sca(double t){ return (vec){t * x, t * y}; }\n  double dot(vec a){ return x * a.x + y * a.y; }\n  double cross(vec a){ return x * a.y - y * a.x; }\n  double norm(){ return sqrt(x * x + y * y); }\n  double norm2(){ return x * x + y * y; }\n};\n\nbool xsort(vec qwe, vec rty){ return qwe.x < rty.x; }\nbool ysort(vec qwe, vec rty){ return qwe.y < rty.y; }\n\nvec pt[100000];\nvec ytmp[100000];\nvec ymerge[100000];\ndouble ma = 100000000000.0;\n\ndouble closestpair(int l, int r){\n  if(r - l <= 1)return ma;\n  int m = l + (r - l) / 2;\n  double xm = pt[m].x;\n  double res = min(closestpair(l, m), closestpair(m, r));\n\n  int hdmerge = 0, hdtmp = 0, lhd = l, rhd = m;\n  vec now;\n  for(;;){\n    if(lhd == m && rhd == r)break;\n    else if(rhd == r)now = pt[lhd++];\n    else if(lhd == m)now = pt[rhd++];\n    else if(ysort(pt[lhd], pt[rhd]))now = pt[lhd++];\n    else now = pt[rhd++];\n\n    ymerge[hdmerge++] = now;\n    if(abs(now.x - xm) <= res + eps){\n      ytmp[hdtmp++] = now;\n      for(int i = hdtmp - 2;i >= 0;--i){\n        if(abs(ytmp[i].y - now.y) >= res - eps)break;\n        res = min(res, (now - ytmp[i]).norm());\n      }\n    }\n  }\n  for(int i = l;i < r;++i)pt[i] = ymerge[i - l];\n\n  return res;\n}\n\nsigned main(void){\n  int n;\n  scanf(\"%d\", &n);\n  for(int i = 0;i < n;++i)pt[i].nextvec();\n  sort(pt, pt + n, xsort);\n  printf(\"%.13lf\\n\", closestpair(0, n));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// conj(x) : complex conjugate,(0,1)->(0,-1)\n// abs(x) : dist between(0,0) and x\n// norm(x) : abs(x) * abs(x)\n// arg(x) : argment,[-PI,PI]\nusing CP = complex<long double>;\n#define X real()\n#define Y imag()\nconst long double PI = acos(-1.0L);\nconst long double EPS = 1e-10;\nbool operator==(const CP &l, const CP &r) {\n  return norm(l - r) <= EPS * EPS;\n}\nbool operator<(const CP &l, const CP &r) {\n  if(l.X != r.X) return l.X < r.X;\n  return l.Y < r.Y;\n}\n\n// cos a\nlong double costh(long double a, long double b,\n                  long double c) {\n  return (b * b + c * c - a * a) / (2.0L * b * c);\n}\n\n// dot(a,b) = |a||b|cos x\nlong double dot(CP a, CP b) { return (conj(a) * b).X; }\n// cross(a,b) : area of parallelogram\n// sign : a-> b ,counter clockwise? + : -\nlong double cross(CP a, CP b) { return (conj(a) * b).Y; }\nlong double corner(CP a, CP b) {\n  //[0,PI]\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\nbool equalP(CP a, CP b) { return norm(a - b) <= EPS * EPS; }\n\nCP projectionLP(CP s, CP t, CP p) {\n  if(s == t) return s;\n  CP base = t - s;\n  long double r = dot(p - s, base) / norm(base);\n  return s + base * r;\n}\n\nCP reflectionLP(CP s, CP t, CP p) {\n  CP tmp = (projectionLP(s, t, p) - p);\n  tmp *= 2;\n  return p + tmp;\n}\n\nint calc_clockwiseSP(CP s, CP t, CP p) {\n  t -= s;\n  p -= s;\n  if(cross(t, p) > EPS) return 1;   // \"COUNTER_CLOCKWISE\"\n  if(cross(t, p) < -EPS) return -1; //\"CLOCK_WISE\"\n  if(dot(t, p) < 0) return 2;       // \"ONLINE_BACK\"\n  if(norm(t) < norm(p)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\nint parallel_orthogonalLL(CP s, CP t, CP a, CP b) {\n  t -= s;\n  b -= a;\n  if(abs(cross(t, b)) <= EPS) return 2; // \"parallel\"\n  if(abs(dot(t, b)) <= EPS) return 1;   // \"orthogonal\"\n  return 0;\n}\n\nCP intersectionLL(CP a, CP b, CP c, CP d) {\n  return a + (b - a) * (cross(d - c, c - a) /\n                        cross(d - c, b - a));\n}\n\nbool on_segSP(CP s, CP t, CP p) {\n  // if not use end point, dot(s - p, t - p) < 0\n  return abs(cross(s - p, t - p)) <= EPS &&\n         dot(s - p, t - p) <= 0;\n}\n\n// crossing segments? (a,b) and (c,d)\nbool iscrossSS(CP a, CP b, CP c, CP d) {\n  // parallel\n  if(abs(cross(a - b, c - d)) <= EPS) {\n    return on_segSP(a, b, c) || on_segSP(a, b, d) ||\n           on_segSP(c, d, a) || on_segSP(c, d, b);\n  }\n  CP isp = intersectionLL(a, b, c, d);\n  return on_segSP(a, b, isp) && on_segSP(c, d, isp);\n}\n\nlong double distLP(CP s, CP t, CP p) {\n  return abs(cross(t - s, p - s) / abs(t - s));\n}\n\nlong double distSP(CP s, CP t, CP p) {\n  if(dot(t - s, p - s) < 0) return abs(p - s);\n  if(dot(s - t, p - t) < 0) return abs(p - t);\n  return distLP(s, t, p);\n}\n\nlong double distSS(CP a, CP b, CP c, CP d) {\n  long double res = 1e18;\n  if(iscrossSS(a, b, c, d)) return 0.0L;\n  res = min(res, distSP(a, b, c));\n  res = min(res, distSP(a, b, d));\n  res = min(res, distSP(c, d, a));\n  res = min(res, distSP(c, d, b));\n  return res;\n}\n\n// counter clockwise\nbool is_convex(const vector<CP> &pol) {\n  int n = pol.size();\n  for(int i = 0; i < n; ++i)\n    if(cross(pol[(i + 1) % n] - pol[i],\n             pol[(i + 2) % n] - pol[(i + 1) % n]) < -EPS)\n      return 0;\n  return 1;\n}\n\nvector<CP> convex_hull(vector<CP> &ps) {\n  auto lmd = [&](const CP &l, const CP &r) {\n    if(l.X != r.X) return l.X < r.X;\n    return l.Y < r.Y;\n  };\n  vector<CP> qs;\n  int psize = ps.size();\n  sort(ps.begin(), ps.end(), lmd);\n  int k = 0;\n  qs.resize(psize * 2);\n  for(int i = 0; i < psize; ++i) {\n    while(k > 1 && cross(qs[k - 1] - qs[k - 2],\n                         ps[i] - qs[k - 1]) <= 0)\n      --k;\n    qs[k++] = ps[i];\n  }\n  for(int i = psize - 2, t = k; i >= 0; --i) {\n    while(k > t && cross(qs[k - 1] - qs[k - 2],\n                         ps[i] - qs[k - 1]) <= 0)\n      --k;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k - 1);\n  return qs;\n}\n\nlong double convex_diameter(const vector<CP> &pol) {\n  vector<CP> v = pol;\n  v = convex_hull(v);\n  int n = v.size(), i = 0, j = 0;\n  if(n < 2) return 0.0L;\n  if(n == 2) return abs(v[0] - v[1]);\n  for(int k = 0; k < n; ++k) {\n    if(v[k].X < v[i].X) i = k;\n    if(v[k].X > v[j].X) j = k;\n  }\n  long double res = 0;\n  int si = i, sj = j;\n  while(i != sj || j != si) {\n    res = max(res, abs(v[i] - v[j]));\n    if(cross(v[(i + 1) % n] - v[i], v[(j + 1) % n] - v[j]) <\n       0)\n      (++i) %= n;\n    else\n      (++j) %= n;\n  }\n  return res;\n}\n\nvector<CP> convex_cut(const vector<CP> &pol, const CP &s,\n                      const CP &t) {\n  vector<CP> res;\n  int n = pol.size();\n  for(int i = 0; i < n; ++i) {\n    CP nows = pol[i], nowt = pol[(i + 1) % n];\n    if(cross(t - s, nows - s) >= -EPS) res.push_back(nows);\n    if(cross(t - s, nows - s) * cross(t - s, nowt - s) < 0)\n      res.push_back(intersectionLL(s, t, nows, nowt));\n  }\n  return res;\n}\n\nstruct Circle {\n  CP o;\n  long double r;\n  Circle(long double _x = 0.0L, long double _y = 0.0L,\n         long double _r = 0.0L)\n      : o(CP(_x, _y)), r(_r) {}\n  Circle(CP _o, long double _r = 0.0) : o(_o), r(_r) {}\n};\n\n// number of tangents\nint iscrossCC(Circle l, Circle r) {\n  long double distlr = abs(l.o - r.o);\n  if(distlr - (l.r + r.r) > EPS)\n    return 4; // not touch\n  else if(abs(distlr - (l.r + r.r)) <= EPS)\n    return 3; // circumscription\n  else if(max(l.r, r.r) - (distlr + min(l.r, r.r)) < -EPS)\n    return 2; // cross\n  else if(max(l.r, r.r) - (distlr + min(l.r, r.r)) <= EPS)\n    return 1; // inscribed\n  else        // contain\n    return 0;\n}\n\nvoid intersectionCC(Circle c1, Circle c2, CP &res1,\n                    CP &res2) {\n  if(iscrossCC(c1, c2) == 4) {\n    res1 = res2 = CP(-1e18, -1e18);\n    return;\n  }\n  long double d = abs(c1.o - c2.o);\n  long double arg = acos(costh(c2.r, c1.r, d));\n  res1 = (c2.o - c1.o) * CP(cos(arg), sin(arg));\n  res1 *= c1.r / abs(res1);\n  res1 += c1.o;\n  res2 = reflectionLP(c1.o, c2.o, res1);\n  if(res1.X > res2.X ||\n     (res1.X == res2.X && res1.Y > res2.Y))\n    swap(res1, res2);\n}\n\nvoid intersectionCL(Circle ci, CP s, CP t, CP &res1,\n                    CP &res2) {\n  res1 = res2 = projectionLP(s, t, ci.o);\n  long double r = sqrtl(ci.r * ci.r - norm(res1 - ci.o));\n  t -= s;\n  t *= r / abs(t);\n  res1 += t;\n  res2 -= t;\n  if(res1.X > res2.X ||\n     (res1.X == res2.X && res1.Y > res2.Y))\n    swap(res1, res2);\n}\n\nvoid contactCP(Circle ci, CP p, CP &res1, CP &res2) {\n  long double d = abs(ci.o - p);\n  if(abs(d - ci.r) <= EPS) {\n    res1 = res2 = p;\n    return;\n  }\n  else if(d < ci.r) {\n    res1 = res2 = CP(-1e18, -1e18);\n    return;\n  }\n  long double arg = asin(ci.r / d);\n  res1 = (ci.o - p) * CP(cos(arg), sin(arg));\n  res1 *= (d * cos(arg)) / abs(res1);\n  res1 += p;\n  res2 = reflectionLP(p, ci.o, res1);\n  if(res1.X > res2.X ||\n     (res1.X == res2.X && res1.Y > res2.Y))\n    swap(res1, res2);\n}\n\nlong double polygonarea(const vector<CP> &pol) {\n  int n = pol.size();\n  long double res = 0;\n  for(int i = 0; i < n; ++i)\n    res += (pol[(i - 1 + n) % n].X - pol[(i + 1) % n].X) *\n           pol[i].Y;\n  return res / 2.0L;\n}\n\nint containPolP(const vector<CP> &pol, CP p) {\n  bool con = 0, onseg = 0;\n  int n = pol.size();\n  for(int i = 0; i < n; ++i) {\n    onseg |= on_segSP(pol[i], pol[(i + 1) % n], p);\n    CP s = pol[i] - p, t = pol[(i + 1) % n] - p;\n    if(s.Y > t.Y) swap(s, t);\n    if(s.Y * t.Y <= 0 && t.Y > 0 && cross(s, t) < 0)\n      con = !con;\n  }\n  if(onseg) return 1;\n  if(con) return 2;\n  return 0;\n}\n\nlong double closest_pair(vector<CP> &v, int l = -1,\n                         int r = -1, bool reqsqrt = 0) {\n  if(l == r && l == -1) {\n    l = 0;\n    r = v.size();\n    reqsqrt = 1;\n    auto lmd = [&](const CP &l, const CP &r) {\n      if(l.X != r.X) return l.X < r.X;\n      return l.Y < r.Y;\n    };\n    sort(v.begin(), v.end(), lmd);\n  }\n  if(r - l < 2) return 1e18;\n  if(r - l == 2) {\n    if(v[l].Y > v[l + 1].Y) swap(v[l], v[l + 1]);\n    if(reqsqrt) return abs(v[l] - v[l + 1]);\n    return norm(v[l] - v[l + 1]);\n  }\n  int mid = (l + r) / 2;\n  long double x = v[mid].X,\n              res = min(closest_pair(v, l, mid),\n                        closest_pair(v, mid, r));\n  auto f = [](CP pl, CP pr) { return pl.Y < pr.Y; };\n  inplace_merge(v.begin() + l, v.begin() + mid,\n                v.begin() + r, f);\n  vector<CP> tmp;\n  for(int i = l; i < r; ++i) {\n    long double dx = abs(v[i].X - x);\n    int tsize = tmp.size();\n    if(dx * dx >= res) continue;\n    for(int j = 0; j < tsize; ++j) {\n      CP delta = v[i] - tmp[tsize - 1 - j];\n      if(delta.Y * delta.Y >= res) break;\n      res = min(res, norm(delta));\n    }\n    tmp.push_back(v[i]);\n  }\n  if(reqsqrt) res = sqrtl(res);\n  return res;\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n  vector<CP> v;\n  int n;\n  cin >> n;\n  for(int i = 0; i < n; ++i) {\n    long double x, y;\n    cin >> x >> y;\n    v.emplace_back(x, y);\n  }\n  cout << closest_pair(v) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n#define max(x, y) ((x)>(y)?(x):(y))\n#define min(x, y) ((x)<(y)?(x):(y))\n\nclass Vec{\npublic:\n  double x, y;\n  Vec(double x = 0, double y = 0):x(x),y(y){}\n\n  Vec &read(){\n    cin >> x >> y;\n    return *this;\n  }\n\n  void print(){\n    printf(\"%.10lf %.10lf\\n\", x, y);\n  }\n\n  bool operator<(const Vec &other){\n    if(x < other.x)return true;\n    if(x == other.x && y < other.y)return true;\n    return false;\n  }\n  \n  Vec operator+(const Vec &other)\n  {\n    Vec result = *this;\n    result.x += other.x;\n    result.y += other.y;\n    return result;\n  }\n\n  Vec operator-(const Vec &other)\n  {\n    Vec result = *this;\n    result.x -= other.x;\n    result.y -= other.y;\n    return result;\n  }\n\n  Vec operator*(const double &k)\n  {\n    Vec result = *this;\n    result.x *= k;\n    result.y *= k;\n    return result;\n  }\n\n  Vec operator/(const double &k)\n  {\n    Vec result = *this;\n    result.x /= k;\n    result.y /= k;\n    return result;\n  } \n  \n  double cross(const Vec &other)\n  {\n    return x*other.y - y*other.x;\n  }\n\n  double dot(const Vec &other){\n    return x*other.x + y*other.y;\n  }\n  \n  bool operator==(const Vec &other) const\n  {\n    return abs(x - other.x) < EPS && abs(y - other.y) < EPS;\n  }\n\n  double norm()\n  {\n    return sqrt(x*x+y*y);\n  }\n\n  double norm2()\n  {\n    return x*x+y*y;\n  }\n\n  Vec standard(){\n    Vec result = *this;\n    return result/result.norm();\n  }\n};\n\n//cw:1, ccw:-1, other:0\nInt CCW(Vec a, Vec b, Vec c){\n  b = b - a;\n  c = c - a;\n  if(b.cross(c) > EPS)return -1;\n  if(b.cross(c) < -EPS)return 1;\n  return 0;\n}\n\ndouble dist(Vec a, Vec b){\n  return (a-b).norm();\n}\n\n\nbool comp_x(Vec a, Vec b){return a < b;}\nbool comp_y(Vec a, Vec b){\n  return (a.y < b.y || abs(a.y - b.y) < EPS && a.x < b.x);\n}\n\npair<Vec, Vec> _cp(vector<Vec>::iterator l, vector<Vec>::iterator r){\n  int n = r - l;\n  if(n <= 3){\n    pair<Vec, Vec> res = {*l, *(l+1)};\n    for(auto it = l;it < r;it++)\n      for(auto jt = it + 1;jt < r;jt++)\n\tif(dist(*it, *jt) < dist(res.first, res.second))\n\t  res = {*it, *jt};\n    sort(l, r, comp_y);\n    return res;\n  }\n  pair<Vec, Vec> res, res2;\n  double minDist;\n  auto mid = l + (n / 2);\n  double midx = mid->x;\n  res = _cp(l, mid);\n  minDist = dist(res.first, res.second);\n  res2 = _cp(mid, r);\n  if(minDist > dist(res2.first, res2.second)){\n    minDist = dist(res2.first, res2.second);\n    res = res2;\n  }\n  inplace_merge(l, mid, r, comp_y);\n  vector<Vec> center;\n  for(auto it = l;it < r;it++)\n    if(midx - minDist < it->x && it->x < midx + minDist)\n      center.push_back(*it);\n  if(center.size() <= 1)return res;\n  auto jt = center.begin();\n  for(auto it = center.begin();it < center.end();it++){\n    while(jt == center.end() || jt > center.begin() && it->y - minDist < jt->y)jt--;\n    while(jt < center.end() && it->y + minDist > jt->y){\n      if(it != jt && dist(*it, *jt) < minDist){\n\tres = {*it, *jt};\n\tminDist = dist(res.first, res.second);\t\n      }\n      jt++;\n    }\n  }\n  return res;  \n}\n\npair<Vec, Vec> closestPair(vector<Vec> &points){\n  sort(points.begin(), points.end(), comp_x);\n  return _cp(points.begin(), points.end());  \n}\n\nint main(){\n  int n;\n  cin >> n;\n  vector<Vec> points(n);\n  for(auto &p:points)p.read();\n  pair<Vec, Vec> res;\n  res = closestPair(points);\n  printf(\"%.10lf\\n\", dist(res.first, res.second));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* Header {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long readtype;\ntypedef long long var;\ntypedef long double let;\n\nreadtype read() {\n  readtype a = 0, c = getchar(), s = 0;\n  while (!isdigit(c)) s |= c == '-', c = getchar();\n  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();\n  return s ? -a : a;\n}\n\n#ifdef LOCAL_LOGGER\n#define logger(...) fprintf(stderr, __VA_ARGS__)\n#define abortif(v, ...) if (v) {logger(\"Error in Line %d, Function '%s()'.\\nInfo: \", __LINE__, __FUNCTION__); logger(__VA_ARGS__); exit(0);}\n#else\n#define logger(...);\n#define abortif(v, ...);\n#endif\n/* }}} */\n\nconst int N = 1e5 + 1;\nconst let eps = 1e-8;\nconst let Pi = acos(-1.0);\n\nint sign(let x) { return (x < -eps) ? -1 : (x > eps) ? 1 : 0; }\n\nstruct Point {\n  let x, y;\n  friend Point operator - (Point a, Point b) {\n    return (Point) {a.x - b.x, a.y - b.y};\n  }\n  friend bool operator < (Point a, Point b) {\n    if (sign(a.x - b.x) == 0) return sign(a.y - b.y) < 0;\n    return sign(a.x - b.x) < 0;\n  }\n  Point Rotate(let sink, let cosk) {\n    return (Point) {\n      x * cosk - y * sink, x * sink + y * cosk\n    };\n  }\n  let dist() {\n    return sqrt(x * x + y * y);\n  }\n  friend let Dist(Point a, Point b) { \n    return (a - b).dist();\n  }\n};\n\nPoint ReadPoint() {\n  Point p;\n  scanf(\"%Lf%Lf\", &p.x, &p.y);\n  return p;\n}\n\nint n;\nPoint point[N];\nint rnk[N];\n\nint main() {\n// #ifndef ONLINE_JUDGE\n//   freopen(\"CGL_5_A.in\", \"r\", stdin);\n//   freopen(\"CGL_5_A.out\", \"w\", stdout);\n// #endif\n// #ifdef LOCAL_LOGGER\n//   freopen(\"CGL_5_A.log\", \"w\", stderr);\n// #endif\n  srand(time(0));\n  n = read();\n  for (int i = 1; i <= n; ++i) point[i] = ReadPoint();\n  let res = 0;\n  bool have = false;\n  int RD_TIME = 50;\n  for (int rd = 1; rd <= RD_TIME; ++rd) {\n    sort(point + 1, point + n + 1);\n    for (int i = 1; i < n; ++i) {\n      let tdist = Dist(point[i], point[i + 1]);\n      if (!have) res = tdist, have = true;\n      if (sign(res - tdist) > 0) res = tdist;\n    }\n    let angle = ((let) rand() / RAND_MAX) * Pi;\n    let sink = sin(angle), cosk = cos(angle);\n    for (int i = 1; i <= n; ++i)\n      point[i] = point[i].Rotate(sink, cosk);\n  }\n  printf(\"%.8Lf\\n\", res);\n  return 0;\n}\n\n/* ==== Makefile ==== {{{\nCompileAndRun:\n\tmake Compile\n\tmake Run\n\nCompile:\n\tg++ -o CGL_5_A CGL_5_A.cpp -g -Wall -DLOCAL_LOGGER\n\nCompileUF:\n\tg++ -o CGL_5_A CGL_5_A.cpp -g -Wall -DLOCAL_LOGGER -fsanitize=undefined\n\nRun:\n\t./CGL_5_A < CGL_5_A.in > CGL_5_A.out\n==================\n}}} */\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.00000000001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct vec{\n  double x, y;\n  void nextvec(){ scanf(\"%lf %lf\", &x, &y); return; }\n  vec operator+(const vec& a) const { return (vec){x + a.x, y + a.y}; }\n  vec operator-(const vec& a) const { return (vec){x - a.x, y - a.y}; }\n  vec operator*(const double& k) const { return (vec){k * x, k * y}; }\n  vec sca(double t){ return (vec){t * x, t * y}; }\n  double dot(vec a){ return x * a.x + y * a.y; }\n  double cross(vec a){ return x * a.y - y * a.x; }\n  double norm(){ return sqrt(x * x + y * y); }\n  double norm2(){ return x * x + y * y; }\n};\n\nbool xsort(vec qwe, vec rty){ return qwe.x < rty.x; }\nbool ysort(vec qwe, vec rty){ return qwe.y < rty.y; }\n\nvec pt[100000];\ndouble ma = 100000000000.0;\n\nvec ytmp[100000];\nvec ymerge[100000];\ndouble closestpair(int l, int r){\n  if(r - l <= 1)return ma;\n  int m = l + (r - l) / 2;\n  double xm = pt[m].x;\n  double res = closestpair(l, m);\n  res = min(res, closestpair(m, r));\n\n  int hdmerge = 0, hdtmp = 0, lhd = l, rhd = m;\n  vec now;\n  for(;;){\n    if(lhd == m && rhd == r)break;\n    else if(rhd == r)now = pt[lhd++];\n    else if(lhd == m)now = pt[rhd++];\n    else if(ysort(pt[lhd], pt[rhd]))now = pt[lhd++];\n    else now = pt[rhd++];\n\n    ymerge[hdmerge++] = now;\n    if(now.x - xm <= res + eps){\n      ytmp[hdtmp++] = now;\n      for(int i = hdtmp - 2;i >= 0;--i){\n        if(ytmp[i].y - now.y >= res - eps)break;\n        printf(\"%d %lf %lf %lf %lf\\n\", i, now.x, now.y, ytmp[i].x, ytmp[i].y);\n        res = min(res, (now - ytmp[i]).norm());\n      }\n    }\n  }\n  for(int i = l;i < r;++i)pt[i] = ymerge[i - l];\n\n  return res;\n}\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int(n);\n    rep(i, n)pt[i].nextvec();\n    sort(pt, pt + n, xsort);\n    printf(\"%.13lf\\n\", closestpair(0, n));\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/50))  \n #define Fun2(j,n) for(int j=i+(int)(n/50);j<n;j=j+(int)(n/50))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=20;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16????????????????????¢???10??????????????§?????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n double dx,dy;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   //?°?16????????????????????????????????? \n   minx=minx-1;\n   miny=miny-1;\n   maxx=maxx+1;\n   maxy=maxy+1;\n   dx=1.0/4*(maxx-minx);\n   dy=1.0/4*(maxy-miny);\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=3;j>=0;j--)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*(3-j)+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n   /*\n   for(int i=0;i<16;i++)\n   {\n     for(int j=0;j<num_point[i];j++)\n     {\n       cout<<wu[i][j].x<<\" \"<<wu[i][j].y<<endl;        \n     }        \n   }\n   */\n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n //?????¢????????????????????????????§???????????????¢?????? \n void circle_optimize(double center)\n {\n      \n }\n \n void triangle_optimize()\n {\n      \n }\n \n void rectangle_optimize()\n {\n      \n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       //real_min=(point[0].x-point[1].x)*(point[0].x-point[1].x)+(point[0].y-point[1].y)*(point[0].y-point[1].y);\n       real_min=fun_min;\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         bool flag1,flag2,flag3,flag4,judge; \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {      \n             //???????????????????????¬???????????????????????¨?????????????????????????¬????????°????????????????????????????????????????????°???????????????°?????¨ \n             double theta=sqrt(real_min)/2;\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               flag1=flag2=flag3=flag4=false;\n               judge=false;\n               if(point[i].x>=(minx+(n+1)*dx-theta)) flag1=true;\n               if(point[i].x<=(minx+(n+1)*dx)) flag2=true;\n               if(point[i].y>=(miny+(3-m)*dy)) flag3=true;\n               if(point[i].y<=(miny+(4-m)*dy)) flag4=true;\n               judge=flag1&&flag2&&flag3&&flag4;\n               if(!judge) continue;\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 flag1=flag2=flag3=flag4=false;\n                 judge=false;\n                 if(point[j].x>=(minx+(n+1)*dx)) flag1=true;\n                 if(point[j].x<=(minx+(n+1)*dx+theta)) flag2=true;\n                 if(point[j].y>=(miny+(3-m)*dy)) flag3=true;\n                 if(point[j].y<=(miny+(4-m)*dy)) flag4=true;\n                 judge=flag1&&flag2&&flag3&&flag4;\n                 if(!judge) continue;\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             double theta=sqrt(real_min)/2;\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               flag1=flag2=flag3=flag4=false;\n               judge=false;\n               if(point[i].x>=(minx+n*dx)) flag1=true;\n               if(point[i].x<=(minx+(n+1)*dx)) flag2=true;\n               if(point[i].y>=(miny+(3-m)*dy)) flag3=true;\n               if(point[i].y<=(miny+(3-m)*dy+theta)) flag4=true;\n               judge=flag1&&flag2&&flag3&&flag4;\n               if(!judge) continue;\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 flag1=flag2=flag3=flag4=false;\n                 judge=false;\n                 if(point[j].x>=(minx+n*dx)) flag1=true;\n                 if(point[j].x<=(minx+(n+1)*dx)) flag2=true;\n                 if(point[j].y>=(miny+(3-m)*dy-theta)) flag3=true;\n                 if(point[j].y<=(miny+(3-m)*dy)) flag4=true;\n                 judge=flag1&&flag2&&flag3&&flag4;\n                 if(!judge) continue;\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\n/*使用注意 aojでがc++11でしか通らない*/\n/*\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    //two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n\n    two_dimensional_qsort(p_xy, n0, n-1, 1);\n\n    \n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n*/\nbool compare_y(pair<double, double> a,pair<double, double> b){\n    return a.second<b.second;\n}\n\ndouble length_of_the_nearest_point_to(pair<double, double> a[100000], int n){\n    if(n<=1)return 999999999.9;\n    int m=n/2;\n    double x=a[m].first;\n    double d=min(length_of_the_nearest_point_to(a, m), length_of_the_nearest_point_to(a+m, n-m));\n    //inplace_merge(a, a+m, a+n, compare_y);\n    sort(a, a+n, compare_y);\n    vector<pair<double, double>>b;\n    for(int i=0; i<n; i++){\n        if(fabs(a[i].first-x)>=d)continue;\n        for(int j=0; j<b.size(); j++){\n            double dx=a[i].first-b[b.size()-j-1].first;\n            double dy=a[i].second-b[b.size()-j-1].second;\n            if(dy>=d)break;\n            d=min(d,sqrt(dx*dx+dy*dy));\n            \n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n                                      \n                                      \n                                      \nint main(int argc, const char * argv[]){\n    int n;\n    while(cin>>n){\n        pair<double, double> a[100000];\n        for(int i=0; i<n; i++){\n            cin>>a[i].first>>a[i].second;\n        }\n        sort(a, a+n);\n        double ans = length_of_the_nearest_point_to(a, n);\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n    /*\n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        //cout<<\"qaaa\";\n        two_dimensional_qsort(p_xy, 0, n-1, 0);\n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<<ans<<endl;\n    }\n     */\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<vector>\n#include<cmath>\n#include<algorithm>\n\nconst double INF = 1e9;\nconst double EPS = 1e-9;\n\nstruct Point {\n    Point() :x(INF), y(INF) {}\n    Point(double x, double y) :x(x), y(y) {}\n    bool operator==(const Point& p) const {return x == p.x && y == p.y;}\n    double x, y;\n};\nstruct Compare {\n    bool f;\n    Compare(bool f = false) :f(f) {}\n    bool operator()(const Point& lhs, const Point& rhs) const {return f ? lhs.y < rhs.y : lhs.x < rhs.x;}\n};\ndouble distance(const Point& lhs, const Point& rhs) {return std::hypot(lhs.x - rhs.x, lhs.y - rhs.y);}\n\nstruct Result {\n    double d;\n    Point p1, p2;\n    Result() :d(INF) {}\n    Result(double d, const Point p1, const Point p2) :d(d), p1(p1), p2(p2) {}\n};\nbool operator<(const Result& lhs, const Result& rhs) {return lhs.d < rhs.d;}\n\nResult closest_pair_recursion(const std::vector<Point>::const_iterator& begin, const std::vector<Point>::const_iterator& end) {\n    int size = end - begin;\n    if(size <= 1) return Result();\n\n    auto mid = begin + size / 2;\n    Result r = std::min(closest_pair_recursion(begin, mid), closest_pair_recursion(mid, end));\n\n    auto left = std::lower_bound(begin, end, Point(mid->x - r.d - EPS, mid->y), Compare());\n    auto right = std::upper_bound(left, end, Point(mid->x + r.d + EPS, mid->y), Compare());\n    std::vector<Point> y_sorted(left, right);\n    std::sort(y_sorted.begin(), y_sorted.end(), Compare(true));\n\n    for(auto i = y_sorted.begin(); i != y_sorted.end(); ++i) {\n        auto top = std::upper_bound(i + 1, y_sorted.end(), Point(i->x, i->y + r.d + EPS), Compare(true));\n        for(auto j = i + 1; j != top; ++j) {\n            if(distance(*i, *j) >= r.d) continue;\n            r = Result(distance(*i, *j), *i, *j);\n        }\n    }\n    return r;\n}\nResult closest_pair(std::vector<Point> point) {\n    std::sort(point.begin(), point.end(), Compare());\n    return closest_pair_recursion(point.begin(), point.end());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n#include<iostream>\n#include<iomanip>\nusing namespace std;\n\nint main() {\n    int n;\n    vector<Point> v;\n    for(cin >> n; n > 0; --n) {\n        double x, y;\n        cin >> x >> y;\n        v.push_back(Point(x, y));\n    }\n    auto res = closest_pair(v);\n    cout <<setprecision(12) << fixed << res.d << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\n\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  // if (r - l <= 3) {\n  //   PointPoint res(ps[l], ps[r - 1]);\n  //   for (int i = l; i < r; ++i) {\n  //     for (int j = i + 1; j < r; ++j) {\n  //       res = Closer(res, PointPoint(ps[i], ps[j]));\n  //     }\n  //   }\n  //   return res;\n  // }\n  if (r - l == 2) {\n    return PointPoint(ps[l], ps[l + 1]);\n  }\n  if (r - l == 3) {\n    PointPoint a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return Closer(a, Closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  // Points lp, rp;\n  // for (int i = l; i < mid; ++i) {\n  //   if (abs(ps[i].real() - midPoint.real()) < d) lp.push_back(ps[i]);\n  // }\n  // for (int i = mid; i < r; ++i) {\n  //   if (abs(ps[i].real() - midPoint.real()) < d) rp.push_back(ps[i]);\n  // }\n  // for (int i = 0; i < lp.size(); ++i) {\n  //   for (int j = 0; j < rp.size(); ++j) {\n  //     if (Distance(lp[i], rp[j]) < d) {\n  //       d = Distance(lp[i], rp[j]);\n  //       res = PointPoint(lp[i], rp[j]);\n  //     }\n  //   }\n  // }\n\n  Points pos[2];\n  for (int i = l; i < r; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) pos[i < mid].push_back(ps[i]);\n  }\n  for (int i = 0; i < pos[0].size(); ++i) {\n    for (int j = 0; j < pos[1].size(); ++j) {\n      if (Distance(pos[0][i], pos[1][j]) < d) {\n        d = Distance(pos[0][i], pos[1][j]);\n        res = PointPoint(pos[0][i], pos[1][j]);\n      }\n    }\n  }\n  // Points strip;\n  // for (int i = l; i < r; ++i) {\n  //   if (abs(ps[i].real() - midPoint.real()) < d) strip.push_back(ps[i]);\n  // }\n  // for (int i = 0; i < strip.size(); ++i) {\n  //   for (int j = i + 1; j < strip.size(); ++j) {\n  //     if (Distance(strip[i], strip[j]) < d) {\n  //       d = Distance(strip[i], strip[j]);\n  //       res = PointPoint(strip[i], strip[j]);\n  //     }\n  //   }\n  // }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(DegreeToRadian(1), ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  return ClosestPairUtil(ps, 0, ps.size());\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  sort(p.begin(), p.end());\n  PointPoint pp = ClosestPair(p);\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n  // cerr << pp.first << \" \" << pp.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100000\nconst double INF = 1e50;\n\ntypedef pair<double,double> P;\n\nint N;\nP A[MAX_N];\n\nbool compare_y(const P &a,const P &b){\n  return a.second < b.second;\n}\n//??????????????¨????????§????±?????°???????????????????????????????????????????\n//?±????????????????????????????x???????????§d????????¢????°???????????????¨???\n//????????????????????§???????±?1000000??§??????????????????????????????\ndouble closest_pair(P *a,int n){\n  if(n <= 1) return INF;\n  int m = n / 2;\n  double x = a[m].first;\n  double d = min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n  vector<P> b;\n  for(int i = 0 ; i < n ; i++){\n    if(fabs(a[i].first - x) >= d) continue;\n    for(int j = 0 ; j < (int)b.size() ; j++){\n      double dx = a[i].first - b[b.size()-j-1].first;\n      double dy = a[i].second - b[b.size()-j-1].second;\n      if(dy >= d) break;\n      d = min(d,sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nvoid solve(){\n  sort(A,A+N);\n  printf(\"%.8f\\n\",closest_pair(A,N));\n}\n\nint main(){\n  cin >> N;\n  for(int i = 0 ; i < N ; i++){\n    scanf(\"%lf%lf\",&A[i].first,&A[i].second);\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nstruct P\n{\n\tdouble x, y;\n\tP(double x,double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nint ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}\n\ndouble ClosestPair(vector<P>& points,int l,int r)\n{\n\tif (r - l == 1)\n\t{\n\t\treturn INF;\n\t}\n\tif (r - l == 2)\n\t{\n\t\treturn (points[l] - points[l + 1]).length();\n\t}\n\n\tint m = (l + r) / 2;\n\tdouble d = min(ClosestPair(points, l, m), ClosestPair(points, m, r));\n\n\tvector<P> tempP;\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tif ((points[l].x - points[m].x)*(points[l].x - points[m].x) < d)\n\t\t{\n\t\t\ttempP.emplace_back(P(points[i].y, points[i].x));\n\t\t}\n\t}\n\tsort(tempP.begin(), tempP.end());\n\tfor (int i = 0; i != tempP.size(); i++)\n\t{\n\t\tfor (int j = i + 1; j != tempP.size(); j++)\n\t\t{\n\t\t\tif ((tempP[j].x - tempP[i].x)*(tempP[j].x - tempP[i].x) > d)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, (tempP[i] - tempP[j]).length());\n\t\t}\n\t}\n\n\treturn d;\n}\n\nvector<P> points;\n\nint main()\n{\n\tpoints.reserve(100000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpoints.push_back(P(x, y));\n\t}\n\n\tsort(points.begin(), points.end());\n\n\tprintf(\"%.10lf\\n\", ClosestPair(points, 0, n));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&min(memo,ans+0.00015) >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans =(min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nstruct P\n{\n\tdouble x, y;\n\tP(double x, double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn x*x + y*y;\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nint ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}\n\npair<P, P> ClosestPair(vector<P>& points)\n{\n\tint n = points.size(), s = 0, t = 1, m = 2;\n\tvector<int> S(n);\n\tS[0] = 0, S[1] = 1;\n\tsort(points.begin(), points.end());\n\tdouble d = (points[s] - points[t]).length2();\n\tfor (int i = 2; i < n; S[m++] = i++)for (int j = 0; j < m; j++)\n\t{\n\t\tif ((points[S[j]] - points[i]).length2() < d)\n\t\t{\n\t\t\td = (points[s = S[j]] - points[t = i]).length2();\n\t\t}\n\t\tif (points[S[j]].x < points[i].x - d)\n\t\t{\n\t\t\tS[j--] = S[--m];\n\t\t}\n\t}\n\treturn make_pair(points[s], points[t]);\n}\n\nvector<P> points;\n\nint main()\n{\n\tpoints.reserve(100000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpoints.push_back(P(x, y));\n\t}\n\n\tpair<P, P> closestPair = ClosestPair(points);\n\tprintf(\"%.10lf\\n\", (closestPair.first - closestPair.second).length());\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nusing Point = pair<double, double>;\nbool compare_y(Point a, Point b) { return a.second < b.second; }\n\ndouble closest_pair(vector<Point> &points, int l, int r) {\n    if(r - l <= 1) return 1e100;\n    int mid = (l + r) / 2;\n    double x = points[mid].first;\n    double d = min(closest_pair(points, l, mid), closest_pair(points, mid, r));\n    auto iti = points.begin(), itl = iti + l, itm = iti + mid, itr = iti + r;\n    inplace_merge(itl, itm, itr, compare_y);\n\n    vector<Point> near_line;\n    for(int i=l; i<r; i++) {\n        if(abs(points[i].first - x) >= d) continue;\n\n        int sz = near_line.size();\n        for(int j=sz-1; j>=0; j--) {\n            double dx = points[i].first  - near_line[j].first;\n            double dy = points[i].second - near_line[j].second;\n            if(dy >= d) break;\n            d = min(d, sqrt(dx * dx + dy * dy));\n        }\n        near_line.push_back(points[i]);\n    }\n    return d;\n}\n\nint main() {\n    int N; scanf(\"%d\", &N);\n    vector<Point> points;\n    for(int i=0; i<N; i++) {\n        double x, y; scanf(\"%lf%lf\", &x, &y);\n        points.emplace_back(x, y);\n    }\n    sort(points.begin(), points.end());\n    printf(\"%.12f\\n\", closest_pair(points, 0, N));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/50))  \n #define Fun2(j,n) for(int j=i+(int)(n/50);j<n;j=j+(int)(n/50))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=30;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16????????????????????¢???10??????????????§?????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n double dx,dy;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   //?°?16????????????????????????????????? \n   minx=minx-1;\n   miny=miny-1;\n   maxx=maxx+1;\n   maxy=maxy+1;\n   dx=1.0/4*(maxx-minx);\n   dy=1.0/4*(maxy-miny);\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=3;j>=0;j--)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*(3-j)+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n   /*\n   for(int i=0;i<16;i++)\n   {\n     for(int j=0;j<num_point[i];j++)\n     {\n       cout<<wu[i][j].x<<\" \"<<wu[i][j].y<<endl;        \n     }        \n   }\n   */\n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n //?????¢????????????????????????????§???????????????¢?????? \n void circle_optimize(double center)\n {\n      \n }\n \n void triangle_optimize()\n {\n      \n }\n \n void rectangle_optimize()\n {\n      \n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       //real_min=(point[0].x-point[1].x)*(point[0].x-point[1].x)+(point[0].y-point[1].y)*(point[0].y-point[1].y);\n       real_min=fun_min;\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         bool flag1,flag2,flag3,flag4,judge; \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {      \n             //???????????????????????¬???????????????????????¨?????????????????????????¬????????°????????????????????????????????????????????°???????????????°?????¨ \n             double theta=sqrt(real_min)/2;\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               flag1=flag2=flag3=flag4=false;\n               judge=false;\n               if(point[i].x>=(minx+(n+1)*dx-theta)) flag1=true;\n               if(point[i].x<=(minx+(n+1)*dx)) flag2=true;\n               if(point[i].y>=(miny+(3-m)*dy)) flag3=true;\n               if(point[i].y<=(miny+(4-m)*dy)) flag4=true;\n               judge=flag1&&flag2&&flag3&&flag4;\n               if(!judge) continue;\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 flag1=flag2=flag3=flag4=false;\n                 judge=false;\n                 if(point[j].x>=(minx+(n+1)*dx)) flag1=true;\n                 if(point[j].x<=(minx+(n+1)*dx+theta)) flag2=true;\n                 if(point[j].y>=(miny+(3-m)*dy)) flag3=true;\n                 if(point[j].y<=(miny+(4-m)*dy)) flag4=true;\n                 judge=flag1&&flag2&&flag3&&flag4;\n                 if(!judge) continue;\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             double theta=sqrt(real_min)/2;\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               flag1=flag2=flag3=flag4=false;\n               judge=false;\n               if(point[i].x>=(minx+n*dx)) flag1=true;\n               if(point[i].x<=(minx+(n+1)*dx)) flag2=true;\n               if(point[i].y>=(miny+(3-m)*dy)) flag3=true;\n               if(point[i].y<=(miny+(3-m)*dy+theta)) flag4=true;\n               judge=flag1&&flag2&&flag3&&flag4;\n               if(!judge) continue;\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 flag1=flag2=flag3=flag4=false;\n                 judge=false;\n                 if(point[j].x>=(minx+n*dx)) flag1=true;\n                 if(point[j].x<=(minx+(n+1)*dx)) flag2=true;\n                 if(point[j].y>=(miny+(3-m)*dy-theta)) flag3=true;\n                 if(point[j].y<=(miny+(3-m)*dy)) flag4=true;\n                 judge=flag1&&flag2&&flag3&&flag4;\n                 if(!judge) continue;\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n  "
  },
  {
    "language": "C++",
    "code": "//\n//  CGL_5_A.cpp\n//  AizuOnlineJudge\n//\n//  Created by jiji on 2020/01/11.\n//  Copyright © 2020 jiji4000. All rights reserved.\n//\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\nbool cmpX(Point a, Point b){\n    return a.x < b.x;\n}\n\nbool cmpY(Point a, Point b){\n    return a.y < b.y;\n}\n\ndouble getDistance(Point a,Point b){\n    double x = b.x - a.x;\n    double y = b.y - a.y;\n    return sqrt(x*x + y*y);\n}\n\ndouble closestPair(Point *a, int n){\n    if (n == 1)  return __DBL_MAX__;\n    double d = __DBL_MAX__;\n    int m = n/2;\n    d = min(closestPair(a,m), closestPair(a + m,n - m));\n    \n    double mx = a[m].x;\n    vector<Point> b;\n    for (int i = m;i >= 0;--i){\n        double x = fabs(a[i].x - mx);\n        if (x > d){\n            break;\n        }\n        else{\n            b.push_back(a[i]);\n        }\n    }\n    for (int i = m + 1;i < n;++i){\n        if (fabs(a[i].x - mx) > d){\n            break;\n        }\n        else {\n            b.push_back(a[i]);\n        }\n    }\n    sort(b.begin(), b.end(), cmpY);\n    \n    for(int i = 0; i < b.size();++i){\n        for(int j = i + 1;fabs(b[j].y - b[i].y) < d && j < b.size(); ++j){\n            double tmp = getDistance(b[i], b[j]);\n            if (tmp < d) d = tmp;\n        }\n    }\n    return d;\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    Point a[n];\n    for (int i = 0; i < n; ++i){\n        scanf(\"%lg %lf\", &a[i].x, &a[i].y);\n    }\n    sort(a,a+n,cmpX);\n    printf(\"%7f\", closestPair(a, n));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(188, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(188, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + 1].first - p2[i].first) * (p2[i + 1].first - p2[i].first) + (p2[i + 1].second - p2[i].second) * (p2[i + 1].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target (\"avx2\")\n#define io_init cin.tie(0);ios::sync_with_stdio(0);cout<<setprecision(20)\n#include <bits/stdc++.h>\nconstexpr int INF = 2147483647;\nconstexpr long long int INF_LL = 9223372036854775807;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979323846;\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\ntypedef complex<double> P;\n \n bool comp_x(const P &a, const P &b) {\n     return a.real() < b.real();\n }\n \n bool comp_y(const P &a, const P &b) {\n     return a.imag() < b.imag();\n }\n \n double getClosePair(vector<P> &a, int l, int r) {\n     if (r - l <= 1) return 1e20;\n     int mid = (l + r) / 2;\n     double X = a[mid].real();\n     double d = min(getClosePair(a, l, mid), getClosePair(a, mid, r));\n     inplace_merge(a.begin() + l, a.begin() + mid, a.begin() + r, comp_y);\n \n     vector<P> b;\n     for (int i = l; i < r; i++) {\n         if (abs(a[i].real() - X) >= d) continue;\n         for (int j = b.size() - 1; j >= 0; j--) {\n             if (abs((a[i] - b[j]).imag()) >= d) break;\n             d = min(d, abs(a[i] - b[j]));\n         }\n         b.push_back(a[i]);\n     }\n     return d;\n }\n \n int main() {\n \n     int N;\n     cin >> N;\n \n     vector<P> p(N);\n     for (int i = 0; i < N; i++) {\n         double x, y;\n         cin >> x >> y;\n         p[i] = P(x, y);\n     }\n \n     sort(p.begin(), p.end(), comp_x);\n \n     double ans = getClosePair(p, 0, N);\n     cout << fixed << setprecision(20) << ans << endl;\n \n }\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tfor (size_t j = 1; i+j < N; j++)\n\t\t{\n\t\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\t}\n\t\t/*memo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i+j<N&&memo >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\t\tj++;\n\t\t}*/\n\t}\n\tcout << fixed << setprecision(8)<<sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n#define INF (1000)\n\nclass Point {\npublic:\n    double x, y;\n    Point(double _x = 0.f, double _y = 0.f) : x(_x), y(_y) {}\n};\n\ninline bool operator < (const Point& P, const Point& Q)\n{\n    return (P.x < Q.x) || (P.x == Q.x && P.y < Q.y);\n}\n\ninline bool CompY(const Point& P, const Point& Q)\n{\n    return P.y < Q.y || (P.y == Q.y && P.x < Q.x);\n}\n\nistream& operator >> (istream& in, Point& P)\n{\n    in >> P.x >> P.y;\n    return in;\n}\n\ndouble Dist(const Point& P, const Point& Q)\n{\n    double dx = P.x - Q.x;\n    double dy = P.y - Q.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\ndouble ClosestDist(const vector<Point>& vP)\n{\n    int n = (int) vP.size();\n\n    if (n == 1) {\n        return INF;\n    } else if (n == 2) {\n        return Dist(vP[0], vP[1]);\n    }\n\n    double dL, dR, dLR;\n    vector<Point> vPL, vPR, vPLR;\n    auto itM = vP.begin() + n / 2;\n\n    copy(vP.begin(), itM, back_inserter(vPL));\n    copy(itM, vP.end(), back_inserter(vPR));\n    \n    dL = ClosestDist(vPL);\n    dR = ClosestDist(vPR);\n    double dRet = min(dL, dR);\n\n    Point Left((*itM).x - dRet, -INF);\n    Point Right((*itM).x + dRet, INF);\n    auto LeftIt = lower_bound(vP.begin(), vP.end(), Left);\n    auto RightIt = lower_bound(LeftIt, vP.end(), Right);\n    copy(LeftIt, RightIt, back_inserter(vPLR));\n    sort(vPLR.begin(), vPLR.end(), CompY);\n\n    int k = (int) vPLR.size();\n    dLR = INF;\n    for (int l = 0; l < k; ++l) {\n        for (int r = l + 1; r < k; ++r) {\n            dLR = min(dLR, Dist(vPLR[l], vPLR[r]));\n            if (vPLR[r].y - vPLR[l].y > dLR) {\n                break;\n            }\n        }\n    }\n\n    dRet = min(dRet, dLR);\n    return dRet;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<Point> vP(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> vP[i];\n    }\n\n    sort(vP.begin(), vP.end());\n    cout << fixed << setprecision(10);\n    cout << ClosestDist(vP) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\ntypedef long double LD;\ntypedef complex<LD> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> Polygon;\nconst LD EPS = 1e-10;\n#define X real() // x座標を取得\n#define Y imag() // y座標を取得\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積 Dot(a, b) = |a||b|cosθ\nLD Dot(Point a, Point b){\n    return (conj(a)*b).X;\n}\n\n// 外積 Cross(a, b) = |a||b|sinθ\nLD Cross(Point a, Point b){\n    return (conj(a)*b).Y;\n}\n\nint CCW(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if (Cross(b, c) > 0)   return +1;       // counter clockwise\n    if (Cross(b, c) < 0)   return -1;       // clockwise\n    if (Dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n\n//*********************************************\n//          点と線(Point and Line)            *\n//*********************************************\n\n// 交差判定 (Isec) ****************************\n// 点　 := 平面座標にある点\n// 直線 := 点と点を通るどこまでも続く線\n// 線分 := 点と点を結んでその両端で止まっている線\n\n// 直線と点\nbool IsecLP(Point a1, Point a2, Point b){\n    return abs(CCW(a1, a2, b)) != 1;\n}\n\n// 直線と直線\nbool IsecLL(Point a1, Point a2, Point b1, Point b2) {\n    return !IsecLP(a2-a1, b2-b1, 0) || IsecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool IsecLS(Point a1, Point a2, Point b1, Point b2) {\n    return Cross(a2-a1, b1-a1) * Cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool IsecSS(Point a1, Point a2, Point b1, Point b2) {\n    return CCW(a1, a2, b1)*CCW(a1, a2, b2) <= 0 && CCW(b1, b2, a1)*CCW(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool IsecSP(Point a1, Point a2, Point b) {\n    return !CCW(a1, a2, b);\n}\n\n// ********************************************\n\n\n// 距離 (Dist) ********************************\n// 点pの直線aへの射影点を返す\nPoint Proj(Point a1, Point a2, Point p){\n    return a1 + Dot(a2-a1, p-a1) / norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nPoint Reflection(Point a1, Point a2, Point p){\n    return 2.0L*Proj(a1, a2, p) - p;\n}\n\n// 点と点\nLD DistPP(Point a, Point b){\n    return abs(a-b);\n}\n\n// 直線と点\nLD DistLP(Point a1, Point a2, Point p){\n    return abs(Proj(a1, a2, p) - p);\n}\n\n// 直線と直線\nLD DistLL(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLL(a1, a2, b1, b2) ? 0 : DistLP(a1, a2, b1);\n}\n\n// 直線と線分\nLD DistLS(Point a1, Point a2, Point b1, Point b2) {\n    return IsecLS(a1, a2, b1, b2) ? 0 : min(DistLP(a1, a2, b1), DistLP(a1, a2, b2));\n}\n\n// 線分と点\nLD DistSP(Point a1, Point a2, Point p) {\n    if(Dot(a2-a1,p-a1) < EPS) return abs(p-a1);\n    if(Dot(a1-a2,p-a2) < EPS) return abs(p-a2);\n    return abs(Cross(a2-a1,p-a1)) / abs(a2-a1);\n}\n\n// 線分と線分\nLD DistSS(Point a1, Point a2, Point b1, Point b2) {\n    if(IsecSS(a1, a2, b1, b2)) return 0;\n    return min(min(DistSP(a1, a2, b1), DistSP(a1, a2, b2)), min(DistSP(b1, b2, a1), DistSP(b1, b2, a2)));\n}\n\n// ********************************************\n\n\n// 2直線の交点 (CrossPoint) *******************\nPoint CrossPointLL(Point a1, Point a2, Point b1, Point b2){\n    LD d1 = Cross(b2-b1, b1-a1);\n    LD d2 = Cross(b2-b1, a2-a1);\n    if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n    if (EQ(d2, 0)) throw \"not exist crosspoint\";\n    return a1 + d1/d2 * (a2-a1);\n}\n// ********************************************\n\n\n//*********************************************\n//             多角形(Polygon)                *\n//*********************************************\n\nnamespace std {\n    bool operator < (Point a, Point b){\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// 多角形の面積 (PolygonErea) *****************\nLD PolygonErea(Polygon p){\n    LD area = 0;\n    int n = p.size();\n    for(int i = 0; i < n; i++){\n        area += Cross(p[i], p[(i+1) % n]);\n    }\n    return area / 2;\n}\n// ********************************************\n\n\n// 凸性判定 (IsConvex) ************************\nbool IsConvex(Polygon pol){\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        if(CCW(pol[i], pol[(i+1) % n], pol[(i+2) % n]) == -1) return false;\n    }\n    return true;\n}\n// ********************************************\n\n\n// 多角形-点包含関係 (PolygonPointContainment)\nint PolygonPointContainment(Polygon pol, Point p){\n    enum {OUT, ON, IN};\n    bool in = false;\n    int n = pol.size();\n    for(int i = 0; i < n; i++){\n        Point a = pol[i] - p, b = pol[(i+1) % n] - p;\n        if(a.Y > b.Y) swap(a, b);\n        if(a.Y <= 0 && 0 < b.Y && Cross(a, b) < 0) in = !in;\n        if(Cross(a, b) == 0 && Dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n// ********************************************\n\n\n//*********************************************\n//          凸多角形(ConvexPolygon)           *\n//*********************************************\n\n// 凸包[θ<=180] (ConvexHull) *****************\nPolygon ConvexHull(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) == -1) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸包[θ<180] (ConvexHull2) *****************\nPolygon ConvexHull2(Polygon pol){\n    int n = pol.size(), k = 0;\n    sort(pol.begin(), pol.end());\n    Polygon ch(2*n);\n    for(int i = 0; i < n; ch[k++] = pol[i++])\n        while(k >= 2 && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    for(int i = n-2, t = k+1; i >= 0; ch[k++] = pol[i--])\n        while(k >= t && CCW(ch[k-2], ch[k-1], pol[i]) <= 0) --k;\n\n    ch.resize(k-1);\n    return ch;\n}\n// ********************************************\n\n// 凸多角形の直径 (ConvexPolygonDiameter) *****\npair<int, int> ConvexPolygonDiameter(Polygon cpol){\n    int n = cpol.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(cpol[i]) > imag(cpol[is])) is = i;\n        if (imag(cpol[i]) < imag(cpol[js])) js = i;\n    }\n    LD maxd = norm(cpol[is]-cpol[js]);\n\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if(Cross(cpol[(i+1)%n] - cpol[i], cpol[(j+1)%n] - cpol[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if(norm(cpol[i]-cpol[j]) > maxd) {\n            maxd = norm(cpol[i]-cpol[j]);\n            maxi = i; maxj = j;\n        }\n    } while(i != is || j != js);\n    return make_pair(maxi, maxj);\n}\n// ********************************************\n\n\n// 凸多角形の切断 (ConvexPolygonCut) **********\nPolygon ConvexPolygonCut(Polygon cpol, Line l){\n    int n = cpol.size();\n    Polygon q;\n    for(int i = 0; i < n; i++){\n        Point a = cpol[i], b = cpol[(i+1)%n];\n        if(CCW(l.first, l.second, a) != -1) q.push_back(a);\n        if(CCW(l.first, l.second, a) * CCW(l.first, l.second, b) < 0) q.push_back(CrossPointLL(a, b, l.first, l.second));\n    }\n    return q;\n}\n// ********************************************\n\n\n// 凸多角形-点包含関係 (ConvexPolygonPointContainment)\nint ConvexPolygonPointContainment(Polygon cpol, Point p){\n    enum {OUT, ON, IN};\n    int n = cpol.size();\n    Point g = (cpol[0] + cpol[n/3] + cpol[2*n/3]) / 3.0L;\n    int a = 0, b = n;\n    while(a+1 < b){\n        int c = (a + b) / 2;\n        if(Cross(cpol[a]-g, cpol[c]-g) > 0){\n            if(Cross(cpol[a]-g, p-g) > 0 && Cross(cpol[c]-g, p-g) < 0) b = c;\n            else a = c;\n        }else{\n            if(Cross(cpol[a]-g, p-g) < 0 && Cross(cpol[c]-g, p-g) > 0) a = c;\n            else b = c;\n        }\n    }\n    b %= n;\n    if(Cross(cpol[a]-p, cpol[b]-p) < 0) return OUT;\n    if(Cross(cpol[a]-p, cpol[b]-p) > 0) return IN;\n    return ON;\n}\n// ********************************************\n\n// 最近点対 (ClosestPair) *********************\npair<Point, Point> ClosestPair(Polygon p){\n    int n = p.size();\n    sort(p.begin(), p.end());\n    auto u = p[0], v = p[1];\n    auto best = Dot(u-v, u-v);\n    auto update = [&](Point p, Point q) {\n        auto dist = Dot(p-q, p-q);\n        if (best > dist) { best = dist; u = p; v = q; }\n    };\n    set<Point> S; S.insert(u); S.insert(v);\n    for (int l = 0, r = 2; r < n; ++r) {\n        if (S.count(p[r])) return {p[r], p[r]};\n        if ((p[l].Y-p[r].Y)*(p[l].Y-p[r].Y) > best) S.erase(p[l++]);\n        auto i = S.insert(p[r]).first;\n        for (auto j = i; ; ++j) {\n            if (j == S.end() || (i->X-j->X)*(i->X-j->X) > best) break;\n            if (i != j) update(*i, *j);\n        }\n        for (auto j = i; ; --j) {\n            if (i != j) update(*i, *j);\n            if (j == S.begin() || (i->X-j->X)*(i->X-j->X) > best) break;\n        }\n    }\n    return make_pair(u, v);\n}\n// ********************************************\n\n\n/************** using variables ***************/\nPolygon p;\nint n;\nint q;\n/**********************************************/\n\nsigned main(){\n    cin >> n;\n    REP(i, n){\n        LD xp, yp;\n        cin >> xp >> yp;\n        p.pb(Point(xp, yp));\n    }\n\n   pair<Point, Point> ans = ClosestPair(p);\n   printf(\"%.9Lf\\n\", DistPP(ans.first, ans.second));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\n\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  // if (r - l <= 3) {\n  //   PointPoint res(ps[l], ps[r - 1]);\n  //   for (int i = l; i < r; ++i) {\n  //     for (int j = i + 1; j < r; ++j) {\n  //       res = Closer(res, PointPoint(ps[i], ps[j]));\n  //     }\n  //   }\n  //   return res;\n  // }\n  if (r - l == 2) {\n    return PointPoint(ps[l], ps[l + 1]);\n  }\n  if (r - l == 3) {\n    PointPoint a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return Closer(a, Closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  // Points lp, rp;\n  // for (int i = l; i < mid; ++i) {\n  //   if (abs(ps[i].real() - midPoint.real()) < d) lp.push_back(ps[i]);\n  // }\n  // for (int i = mid; i < r; ++i) {\n  //   if (abs(ps[i].real() - midPoint.real()) < d) rp.push_back(ps[i]);\n  // }\n  // for (int i = 0; i < lp.size(); ++i) {\n  //   for (int j = 0; j < rp.size(); ++j) {\n  //     if (Distance(lp[i], rp[j]) < d) {\n  //       d = Distance(lp[i], rp[j]);\n  //       res = PointPoint(lp[i], rp[j]);\n  //     }\n  //   }\n  // }\n\n  Points pos[2];\n  for (int i = l; i < r; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) pos[i < mid].push_back(ps[i]);\n  }\n  for (int i = 0; i < pos[0].size(); ++i) {\n    for (int j = 0; j < pos[1].size(); ++j) {\n      if (Distance(pos[0][i], pos[1][j]) < d) {\n        d = Distance(pos[0][i], pos[1][j]);\n        res = PointPoint(pos[0][i], pos[1][j]);\n      }\n    }\n  }\n  // Points strip;\n  // for (int i = l; i < r; ++i) {\n  //   if (abs(ps[i].real() - midPoint.real()) < d) strip.push_back(ps[i]);\n  // }\n  // for (int i = 0; i < strip.size(); ++i) {\n  //   for (int j = i + 1; j < strip.size(); ++j) {\n  //     if (Distance(strip[i], strip[j]) < d) {\n  //       d = Distance(strip[i], strip[j]);\n  //       res = PointPoint(strip[i], strip[j]);\n  //     }\n  //   }\n  // }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  return ClosestPairUtil(ps, 0, ps.size());\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  sort(p.begin(), p.end());\n  PointPoint pp = ClosestPair(p);\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n  // cerr << pp.first << \" \" << pp.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn 1e9;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP,\n\tint yl,int yr\n){\n\tint xsiz=xr-xl;\n\tint ysiz=yr-yl;\n\tif (xsiz <= 8) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tif(ysiz==0)return 1e9;\n\t//printf(\"%d %d %d %d\\n\",xl,xr,yl,yr);\n\tauto xM = xP[xl+xsiz/2].first;\n\tauto yL = std::vector<point_t>(ysiz);\n\tint left = -1, right = ysiz;\n\tfor(int i = yl; i < yr; i++){\n\t\tif (yP[i].first < xM) yL[++left] = yP[i];\n\t\telse                  yL[--right]= yP[i];\n\t}\n\tstd::reverse(yL.begin()+right,yL.end());\n\tauto p1 = find_closest_optimized(xP,xl,xl+xsiz/2,yL,0,left+1);\n\tauto p2 = find_closest_optimized(xP,xl+xsiz/2,xr,yL,left+1,ysiz);\n\tauto minD = sqrt((p1 < p2) ? p1 : p2);\n\tyL.clear();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n,yP,0,n);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\n#define im() imag()\n#define re() real()\n\ntypedef complex<double> P;\ntypedef vector<P> Poly;\n\nbool comp_x(const P &a, const P &b) {\n    return a.re() < b.re();\n}\n\nbool comp_y(const P &a, const P &b) {\n    return a.im() < b.im();\n}\n\ndouble close_pair(vector<P> &a, int l, int r) {\n    if (r - l <= 1) return 1e20;\n    int mid = (l + r) / 2;\n    double X = a[mid].re();\n    double d = min(close_pair(a, l, mid), close_pair(a, mid, r));\n    inplace_merge(a.begin() + l, a.begin() + mid, a.begin() + r, comp_y);\n\n    vector<P> b;\n    for (int i = l; i < r; i++) {\n        if (abs(a[i].re() - X) >= d) continue;\n        for (int j = b.size() - 1; j >= 0; j--) {\n            if ((a[i] - a[j]).im() >= d) break;\n            d = min(d, abs(a[i] - b[j]));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main() {\n\n    int N;\n    cin >> N;\n\n    Poly p(N);\n\n    for (int i = 0; i < N; i++) {\n        double x, y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n    sort(p.begin(), p.end(), comp_x);\n    double ans = close_pair(p, 0, N);\n    cout << fixed << setprecision(20) << ans << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct node{\n  int dim;\n  vector<double>v;\n};\n \ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n \ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nmap<vector<int> ,vector<int> >grid;\n\nvector<int> neighborhood(vector<int> v, int dim, vector<int>res){\n\n  if(dim==v.size()){\n    bool fg = true;\n    for(int i=0;i<dim;i++)fg&=(res[i]==v[i]);\n    if(fg || !grid.count(res))return vector<int>();\n    return grid[res];\n  }\n  vector<int> result;\n  for(int i=-1;i<2;i++){\n    res.push_back(v[dim]+i);\n    vector<int>tmp = neighborhood(v,dim+1,res);\n    result.insert(result.end(),tmp.begin(),tmp.end());\n    res.pop_back();\n  }\n  return result;\n}\n\nvector<node> func(vector<node> S){\n  vector<node>nextS;\n  map<vector<int>,vector<int> >::iterator it = grid.begin();\n  for(;it!=grid.end();it++){\n    vector<int>res=neighborhood((*it).first,0,vector<int>());\n    for(int j=0;j<res.size();j++)nextS.push_back(S[res[j]]);\n  }\n\n  return nextS;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n \n  vector<node>res;\n \n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n \n    double dist=d(p,S)/(4*p.dim);\n \n    grid.clear();\n    for(int i=0;i<S.size();i++){\n      vector<int> key;\n      for(int j=0;j<p.dim;j++)key.push_back((int)(S[i].v[j]/dist));\n      grid[key].push_back(i);\n    }\n   \n    vector<node>tmp = func(S);\n    //if(S.size() == tmp.size())break;\n    S=tmp;\n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n   \n  return ans;\n}\n \nint main(void){\n \n  int n;\n  cin >> n;\n \n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n \n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include \"bits/stdc++.h\"\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n#include <random>\n#ifdef _MSC_VER\n#include <ppl.h>\n//#include <boost/multiprecision/cpp_dec_float.hpp>\n//#include <boost/multiprecision/cpp_int.hpp>\n//#include <boost/rational.hpp>\n//#include <opencv2/core.hpp>\n//#include <opencv2/imgproc.hpp>\n//#include <opencv2/highgui.hpp>\n//#else\n//#include <omp.h>\n#endif\n\n\nusing namespace std;\n\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\nusing uint = unsigned; using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using pdd = pair<double, double>; using pss = pair<string, string>;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const pair<_KTy, _Ty>& m) { o << \"{\" << m.first << \", \" << m.second << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const unordered_map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const vector<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const deque<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const unordered_set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; }\to << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const stack<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } stack<_Ty> t(s); o << \"{\" << t.top(); t.pop(); while (!t.empty()) { o << \", \" << t.top(); t.pop(); } o << \"}\";\treturn o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const list<_Ty>& l) { if (l.empty()) { o << \"{ }\"; return o; } o << \"{\" << l.front(); for (auto itr = ++l.begin(); itr != l.end(); ++itr) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& is, pair<_KTy, _Ty>& m) { is >> m.first >> m.second; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, vector<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, deque<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\nnamespace aux { // print tuple\n  template<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n  template<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& v) { os << get<N>(v); } };\n}\n\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys) - 1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T& val) { fill((T*)array, (T*)(array + N), val); }\n\ntemplate <typename ... Args>\nstd::string format(const std::string& fmt, Args ... args) {\n  size_t len = std::snprintf(nullptr, 0, fmt.c_str(), args ...);\n  std::vector<char> buf(len + 1);\n  std::snprintf(&buf[0], len + 1, fmt.c_str(), args ...);\n  return std::string(&buf[0], &buf[0] + len);\n}\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(move(tail)...); }\n\n#define PI 3.14159265358979323846\n#define EPS 1e-8\n#define rep(t,n) for(int t=0;t<(n);++t)\n#define ALL(j) (j).begin(), (j).end()\n#define SZ(j) ((int)(j).size())\n#define fake false\n\nclass Timer {\npublic:\n  double t = 0;\n  Timer() {}\n  static double time() {\n#ifdef _MSC_VER\n    return __rdtsc() / 2.8e9;\n#else\n    unsigned long long a, d;\n    __asm__ volatile(\"rdtsc\"\n      : \"=a\"(a), \"=d\"(d));\n    return (d << 32 | a) / 2.8e9;\n#endif\n  }\n  void measure() { t = time() - t; }\n  double elapsedMs() { return (time() - t) * 1000.0; }\n} timer;\n\nstruct Xorshift {\n  uint64_t x = 88172645463325252LL;\n  unsigned next_int() {\n    x = x ^ (x << 7);\n    return x = x ^ (x >> 9);\n  }\n  unsigned next_int(unsigned mod) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % mod;\n  }\n  unsigned next_int(unsigned l, unsigned r) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % (r - l + 1) + l;\n  }\n  double next_double() {\n    return double(next_int()) / UINT_MAX;\n  }\n} rnd;\n\ntemplate<typename T>\nvoid shuffle_vector(vector<T>& v, Xorshift& rnd) {\n  int n = v.size();\n  for (int i = n - 1; i >= 1; i--) {\n    int r = rnd.next_int(i);\n    swap(v[i], v[r]);\n  }\n}\n\n\n\nnamespace geom {\n  constexpr double eps = 1e-8;\n\n  /* point */\n  struct Point {\n    double x, y;\n    Point() : x(0.0), y(0.0) {}\n    Point(double x, double y) : x(x), y(y) {}\n    Point operator+(const Point& p) const { return Point(this->x + p.x, this->y + p.y); }\n    Point operator-(const Point& p) const { return Point(this->x - p.x, this->y - p.y); }\n    Point operator-() const { return Point(-this->x, -this->y); }\n    Point& operator+=(const Point& p) { return *this = *this + p; }\n    Point& operator-=(const Point& p) { return *this = *this - p; }\n    bool operator==(const Point& p) const { return x == p.x && y == p.y; }\n    bool operator!=(const Point& p) const { return !(*this == p); }\n    bool operator<(const Point& p) const { return x == p.x ? y < p.y : x < p.x; }\n    bool operator<=(const Point& p) const { return *this == p || *this < p; }\n    bool operator>(const Point& p) const { return !(*this <= p); }\n    bool operator>=(const Point& p) const { return !(*this < p); }\n    double length() const { return std::sqrt(x * x + y * y); }\n    double length2() const { return x * x + y * y; }\n    double distance(const Point& p) const { return sqrt(pow(x - p.x, 2.0) + pow(y - p.y, 2.0)); }\n    friend std::ostream& operator<<(std::ostream& o, const Point& p) {\n      o << '(' << p.x << ',' << p.y << ')';\n      return o;\n    }\n    friend std::istream& operator>>(std::istream& i, Point& p) {\n      i >> p.x >> p.y;\n      return i;\n    }\n  };\n  \n  /* vector */\n  using Vector = Point;\n  double cross_product(const Vector& v1, const Vector& v2) {\n    return v1.x * v2.y - v2.x * v1.y;\n  }\n  double inner_product(const Vector& v1, const Vector& v2) {\n    return v1.x * v2.x + v1.y * v2.y;\n  }\n  enum struct ccw_t {\n    COUNTER_CLOCKWISE,\n    CLOCKWISE,\n    ONLINE_BACK,\n    ONLINE_FRONT,\n    ON_SEGMENT\n  };\n  ccw_t ccw(const Point& p0, const Point& p1, const Point& p2) {\n    Vector v1 = p1 - p0, v2 = p2 - p0;\n    if (cross_product(v1, v2) > eps) return ccw_t::COUNTER_CLOCKWISE;\n    if (cross_product(v1, v2) < -eps) return ccw_t::CLOCKWISE;\n    if (inner_product(v1, v2) < -eps) return ccw_t::ONLINE_BACK;\n    if (v1.length2() < v2.length2()) return ccw_t::ONLINE_FRONT;\n    return ccw_t::ON_SEGMENT;\n  }\n\n  /* line */\n  struct Line {\n    Point p1, p2;\n    Line() {}\n    Line(const Point& p1, const Point& p2) : p1(p1), p2(p2) {}\n    Line(double x1, double y1, double x2, double y2) : p1(Point(x1, y1)), p2(Point(x2, y2)) {}\n    Vector to_vector() const { return p2 - p1; }\n    Point projection(const Point& p) const {\n      Vector v12(p2 - p1);\n      double det = v12.length2();\n      double a = v12.y * p1.x - v12.x * p1.y, b = v12.y * p.y + v12.x * p.x;\n      double x = v12.y * a + v12.x * b, y = v12.y * b - v12.x * a;\n      return Point(x / det, y / det);\n    }\n    Point reflection(const Point& p) const {\n      Point proj = projection(p);\n      return proj + proj - p;\n    }\n    double distance(const Point& p) const {\n      return projection(p).distance(p);\n    }\n    bool is_parallel(const Line& l) const {\n      return abs(cross_product(this->to_vector(), l.to_vector())) < eps;\n    }\n    bool is_orthogonal(const Line& l) const {\n      return abs(inner_product(this->to_vector(), l.to_vector())) < eps;\n    }\n    Point intersection(const Line& l) const {\n      Point p0(this->p1), p1(this->p2), p2(l.p1), p3(l.p2);\n      Vector v01(p1 - p0), v23(p3 - p2);\n      double det = cross_product(v01, v23);\n      double a = v01.y * p0.x - v01.x * p0.y, b = v23.y * p2.x - v23.x * p2.y;\n      double x = v01.x * b - v23.x * a;\n      double y = v01.y * b - v23.y * a;\n      return Point(x / det, y / det);\n    }\n    friend std::ostream& operator<<(std::ostream& o, const Line& l) {\n      o << '(' << l.p1 << ',' << l.p2 << ')';\n      return o;\n    }\n    friend std::istream& operator>>(std::istream& i, Line& l) {\n      i >> l.p1 >> l.p2;\n      return i;\n    }\n  };\n\n  /* segment */\n  using Segment = Line;\n  bool is_intersect_segments(const Segment& s1, const Segment& s2) {\n    Vector v2 = s2.to_vector(), p1(s1.p1 - s2.p1), p2(s1.p2 - s2.p1);\n    if (cross_product(v2, p1) * cross_product(v2, p2) > eps) return false;\n    Vector v1 = s1.to_vector(), p3(s2.p1 - s1.p1), p4(s2.p2 - s1.p1);\n    if (cross_product(v1, p3) * cross_product(v1, p4) > eps) return false;\n    if (inner_product(s2.p1 - s1.p1, s2.p2 - s1.p1) < eps) return true;\n    if (inner_product(s2.p1 - s1.p2, s2.p2 - s1.p2) < eps) return true;\n    if (inner_product(s1.p1 - s2.p1, s1.p2 - s2.p1) < eps) return true;\n    if (inner_product(s1.p1 - s2.p2, s1.p2 - s2.p2) < eps) return true;\n    return false;\n  }\n  bool is_intersect_segment_line(const Segment s, const Line& l) {\n    if (l.is_parallel(s)) return false;\n    Vector vst = l.to_vector();\n    Point ps = l.p1;\n    return cross_product(vst, s.p1 - ps) * cross_product(vst, s.p2 - ps) < eps;\n  }\n  double segment_distance(const Segment& s, const Point& p) {\n    Point proj = s.projection(p);\n    if (ccw(s.p1, proj, s.p2) == ccw_t::ONLINE_FRONT) return p.distance(proj);\n    return min(p.distance(s.p1), p.distance(s.p2));\n  }\n  double segment_distance(const Segment& s1, const Segment& s2) {\n    if (is_intersect_segments(s1, s2)) return 0.0;\n    return min({\n      segment_distance(s1, s2.p1), segment_distance(s1, s2.p2),\n      segment_distance(s2, s1.p1), segment_distance(s2, s1.p2)\n      });\n  }\n\n  /* polygon */\n  using Polygon = std::vector<Point>;\n  double area(const Polygon& poly) {\n    if (poly.size() <= 2) return 0;\n    Point b(DBL_MAX, DBL_MAX);\n    for (const Point& p : poly) {\n      b.x = min(b.x, p.x); b.y = min(b.y, p.y);\n    }\n    b.x -= 1.0; b.y -= 1.0;\n    int n = (int)poly.size();\n    double area = 0.0;\n    for (int i = 0; i < n; i++) {\n      area += cross_product(poly[i] - b, poly[(i + 1) % n] - b) * 0.5;\n    }\n    return area;\n  }\n  bool is_convex(const Polygon& poly) {\n    if (poly.size() <= 2) return false;\n    int n = (int)poly.size();\n    for (int i = 0; i < n; i++) {\n      if (ccw(poly[i], poly[(i + 1) % n], poly[(i + 2) % n]) == ccw_t::CLOCKWISE) {\n        return false;\n      }\n    }\n    return true;\n  }\n  enum struct poly_t {\n    EXTERNAL = 0,\n    ON_SEGMENT = 1,\n    INTERNAL = 2\n  };\n  poly_t is_inside(const Point& p, const Polygon& poly) {\n    int n = (int)poly.size();\n    double rad = 0.0;\n    for (int i = 0; i < n; i++) {\n      const Point& p1 = poly[i];\n      const Point& p2 = poly[(i + 1) % n];\n      double d1 = p.distance(p1), d2 = p.distance(p2);\n      if (segment_distance(Segment(p1, p2), p) < eps) return poly_t::ON_SEGMENT;\n      Vector v1(p1 - p), v2(p2 - p);\n      double r = atan2(cross_product(v1, v2), inner_product(v1, v2));\n      rad += r;\n    }\n    return rad < eps ? poly_t::EXTERNAL : poly_t::INTERNAL;\n  }\n\n  /* convex hull */\n  using Hull = Polygon;\n  Hull convex_hull(std::vector<Point> points, bool strict = true) {\n    double e = strict ? eps : -eps;\n    std::sort(points.begin(), points.end());\n    int n = (int)points.size(), k = 0;\n    Hull hull(2 * n);\n    for (int i = 0; i < n; i++) {\n      while (k > 1 && cross_product(hull[k - 1] - hull[k - 2], points[i] - hull[k - 1]) < e) k--;\n      hull[k++] = points[i];\n    }\n    for (int i = n - 2, t = k; i >= 0; i--) {\n      while (k > t && cross_product(hull[k - 1] - hull[k - 2], points[i] - hull[k - 1]) < e) k--;\n      hull[k++] = points[i];\n    }\n    hull.resize(k - 1);\n    return hull;\n  }\n  double convex_diameter(const Hull& hull) {\n    int n = (int)hull.size();\n    if (n == 2) return hull.front().distance(hull.back());\n    int i = 0, j = 0;\n    for (int k = 0; k < n; k++) {\n      if (hull[k] < hull[i]) i = k;\n      if (hull[j] < hull[k]) j = k;\n    }\n    double d = 0.0;\n    int si = i, sj = j;\n    while (i != sj || j != si) {\n      d = max(d, hull[i].distance(hull[j]));\n      if (cross_product(hull[(i + 1) % n] - hull[i], hull[(j + 1) % n] - hull[j]) < 0.0) {\n        i = (i + 1) % n;\n      }\n      else {\n        j = (j + 1) % n;\n      }\n    }\n    return d;\n  }\n  std::pair<Hull, Hull> convex_cut(const Hull& hull, const Line& l) {\n    int n = (int)hull.size(), i = -1, j = -1;\n    Point pi, pj;\n    for (int k = 0; k < n; k++) {\n      Segment s(hull[k], hull[(k + 1) % n]);\n      if (is_intersect_segment_line(s, l)) {\n        if (cross_product(l.to_vector(), s.to_vector()) < 0) {\n          i = k;\n          pi = l.intersection(s);\n        }\n        else {\n          j = k;\n          pj = l.intersection(s);\n        }\n      }\n    }\n    if (i < 0) {\n      // no cut: 左か右か判定\n      if (cross_product(l.to_vector(), hull.front() - l.p1) > 0) {\n        // left\n        return std::make_pair(hull, Hull());\n      }\n      else {\n        return std::make_pair(Hull(), hull);\n      }\n    }\n    Hull left({ pi, pj }), right({ pj, pi });\n    for (int k = (j + 1) % n, e = (i + 1) % n; k != e; k = (k + 1) % n) {\n      if(left.back().distance(hull[k]) > eps) left.push_back(hull[k]);\n    }\n    for (int k = (i + 1) % n, e = (j + 1) % n; k != e; k = (k + 1) % n) {\n      if(right.back().distance(hull[k]) > eps) right.push_back(hull[k]);\n    }\n    if (left.front().distance(left.back()) < eps) left.pop_back();\n    if (right.front().distance(right.back()) < eps) right.pop_back();\n    return std::make_pair(left, right);\n  }\n\n  /* closest pair : 逐次構成法 */\n  double closest_pair_incremental(std::vector<Point> ps) {\n    using ll = long long;\n    using Grid = std::unordered_map<ll, std::vector<Point>>;\n    // for random\n    uint64_t x = 88172645463325252LL;\n    auto rnd = [&x](int mod) { x = x ^ (x << 7); x = x ^ (x >> 9); return unsigned(x % mod); };\n    // shuffle\n    int n = (int)ps.size();\n    for (int i = n - 1; i >= 1; i--) {\n      int j = (int)rnd(i);\n      std::swap(ps[i], ps[j]);\n    }\n    // set bounding box\n    double x_min = DBL_MAX, x_max = DBL_MIN;\n    double y_min = DBL_MAX, y_max = DBL_MIN;\n    for (const Point& p : ps) {\n      x_min = min(x_min, p.x); x_max = max(x_max, p.x);\n      y_min = min(y_min, p.y); y_max = max(y_max, p.y);\n    }\n    x_min -= eps; x_max += eps; y_min -= eps; y_max += eps;\n    // grid generator\n    double delta = ps[0].distance(ps[1]);\n    auto generate_grid = [&](int sz, double delta) {\n      ll h = (int)ceil((y_max - y_min) / delta);\n      ll w = (int)ceil((x_max - x_min) / delta);\n      Grid grid;\n      for (int i = 0; i < sz; i++) {\n        double x = ps[i].x, y = ps[i].y;\n        ll ix = (ll)floor((x - x_min) / delta);\n        ll iy = (ll)floor((y - y_min) / delta);\n        grid[iy * w + ix].push_back(ps[i]);\n      }\n      return std::make_tuple(h, w, std::move(grid)); \n    };\n    // 幅 delta のグリッド構築\n    ll h, w;\n    Grid grid;\n    tie(h, w, grid) = generate_grid(2, delta);\n    for (int k = 2; k < n; k++) {\n      // d_i = d(p_i, S_i) を計算\n      double x = ps[k].x, y = ps[k].y;\n      ll ix = (ll)floor((x - x_min) / delta);\n      ll iy = (ll)floor((y - y_min) / delta);\n      // 近傍のみ調べればいい\n      double ndelta = delta;\n      for (ll i = max(iy - 1, 0LL); i <= min(iy + 1, h - 1); i++) {\n        for (ll j = max(ix - 1, 0LL); j <= min(ix + 1, w - 1); j++) {\n          if (!grid.count(i * w + j)) continue;\n          for (const auto& p : grid[i * w + j]) {\n            ndelta = std::min(ndelta, ps[k].distance(p));\n          }\n        }\n      }\n      if (ndelta < delta) {\n        // update grid\n        delta = ndelta;\n        tie(h, w, grid) = generate_grid(k + 1, delta);\n      }\n      else {\n        // insert point\n        grid[iy * w + ix].push_back(ps[k]);\n      }\n    }\n    return delta;\n  }\n\n  /* closest pair : 篩法 */\n  double closest_pair_sieve(const std::vector<Point>& ps) {\n    using ll = long long;\n    using Grid = std::unordered_map<ll, std::vector<Point>>;\n    // init grid\n    Grid grid;\n    for (const Point& p : ps) grid[0].push_back(p);\n    // for random\n    uint64_t x = 88172645463325252LL;\n    auto rnd = [&x](int mod) { x = x ^ (x << 7); x = x ^ (x >> 9); return unsigned(x % mod); };\n    // set bounding box\n    double x_min = DBL_MAX, x_max = DBL_MIN;\n    double y_min = DBL_MAX, y_max = DBL_MIN;\n    for (const Point& p : ps) {\n      x_min = min(x_min, p.x); x_max = max(x_max, p.x); \n      y_min = min(y_min, p.y); y_max = max(y_max, p.y);\n    }\n    x_min -= eps; x_max += eps; y_min -= eps; y_max += eps;\n    // grid updator\n    auto update_grid = [&](const Grid& grid, double delta, bool erase_mode = true) {\n      int erased = 0;\n      ll h = (ll)ceil((y_max - y_min) / delta);\n      ll w = (ll)ceil((x_max - x_min) / delta);\n      Grid ngrid;\n      for (auto it = grid.begin(); it != grid.end(); ++it) {\n        for (const Point& p : it->second) {\n          ll ix = (ll)floor((p.x - x_min) / delta);\n          ll iy = (ll)floor((p.y - y_min) / delta);\n          ngrid[iy * w + ix].push_back(p);\n        }\n      }\n      if (erase_mode) {\n        // 孤立点の除去\n        auto it = ngrid.begin();\n        while (it != ngrid.end()) {\n          if (it->second.size() >= 2) { ++it; continue; }\n          ll pos = it->first, iy = pos / w, ix = pos % w;\n          // 8 近傍に点がなければ、削除する\n          bool found = [&]() {\n            for (ll i = max(0LL, iy - 1); i <= min(h - 1, iy + 1); i++) {\n              for (ll j = max(0LL, ix - 1); j <= min(w - 1, ix + 1); j++) {\n                if (i == iy && j == ix) continue;\n                if (ngrid.count(i * w + j)) {\n                  return true;\n                }\n              }\n            }\n            return false;\n          } ();\n          if (!found) {\n            it = ngrid.erase(ngrid.find(pos));\n            erased++;\n          }\n          else ++it;\n        }\n      }\n      return make_tuple(erased, h, w, std::move(ngrid));\n    };\n    // elimination phase\n    int n = (int)ps.size(), erased;\n    ll h = 1, w = 1;\n    double delta = DBL_MAX;\n    while (n) {\n      // ランダムに点を選ぶ\n      auto it = std::next(grid.begin(), rnd((int)grid.size()));\n      ll pos = it->first;\n      auto& cands = it->second;\n      int i = rnd((int)cands.size());\n      Point selected = cands[i];\n      // 一旦消す\n      cands.erase(cands.begin() + i);\n      // pos 周辺を探索\n      ll iy = pos / w, ix = pos % w;\n      for (ll i = max(0LL, iy - 1); i <= min(h - 1, iy + 1); i++) {\n        for (ll j = max(0LL, ix - 1); j <= min(w - 1, ix + 1); j++) {\n          if (!grid.count(i * w + j)) continue;\n          for (const auto& p : grid[i * w + j]) {\n            delta = min(delta, selected.distance(p));\n          }\n        }\n      }\n      // 元に戻す\n      cands.push_back(selected);\n      // 幅 delta / 8 で grid を作成\n      delta /= 8;\n      tie(erased, h, w, grid) = update_grid(grid, delta);\n      n -= erased;\n    }\n    delta *= 8;\n    // 最終的な delta で最近点対探索\n    // reset grid\n    for (const Point& p : ps) grid[0].push_back(p);\n    tie(erased, h, w, grid) = update_grid(grid, delta, false);\n    // find closest points\n    delta = DBL_MAX;\n    for (auto it = grid.begin(); it != grid.end(); ++it) {\n      ll pos = it->first;\n      auto& cands = it->second;\n      // 自身の近傍\n      for (int i = 0; i < (int)cands.size() - 1; i++) {\n        for (int j = i + 1; j < cands.size(); j++) {\n          delta = min(delta, cands[i].distance(cands[j]));\n        }\n      }\n      // 周辺を探索\n      ll iy = pos / w, ix = pos % w;\n      for (ll i = max(0LL, iy - 1); i <= min(h - 1, iy + 1); i++) {\n        for (ll j = max(0LL, ix - 1); j <= min(w - 1, ix + 1); j++) {\n          if (i == iy && j == ix) continue;\n          if (!grid.count(i * w + j)) continue;\n          for (const auto& p1 : cands) {\n            for (const auto& p2 : grid[i * w + j]) {\n              delta = min(delta, p1.distance(p2));\n            }\n          }\n        }\n      }\n    }\n    return delta;\n  }\n\n  double closest_pair_impl(std::vector<Point>& ps, int l, int r) {\n    static const auto cmp_y = [](const Point& a, const Point& b) { return a.y < b.y; };\n    int n = r - l, m = (l + r) >> 1;\n    if (n <= 1) return DBL_MAX;\n    double x = ps[m].x;\n    double d = min(closest_pair_impl(ps, l, m), closest_pair_impl(ps, m, r));\n    std::inplace_merge(ps.begin() + l, ps.begin() + m, ps.begin() + r, cmp_y);\n    std::vector<Point> b;\n    for (int i = 0; i < n; i++) {\n      if (abs(ps[i + l].x - x) >= d) continue;\n      for (int j = (int)b.size() - 1; j >= 0; j--) {\n        double dx = ps[i + l].x - b[j].x, dy = ps[i + l].y - b[j].y;\n        if (dy >= d) break;\n        d = min(d, sqrt(dx * dx + dy * dy));\n      }\n      b.push_back(ps[i + l]);\n    }\n    return d;\n  }\n  double closest_pair(std::vector<Point> ps) {\n    std::sort(ps.begin(), ps.end());\n    return closest_pair_impl(ps, 0, (int)ps.size());\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  using namespace geom;\n\n  int n;\n  cin >> n;\n  std::vector<Point> points(n);\n  cin >> points;\n\n  cout << fixed << setprecision(15);\n  cout << closest_pair(points) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nconst int INF = INT_MAX / 3;\n\n#define REP(i,n) for(int i=0;i<(int)n;i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b) {\n\tif (abs(a + b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a + b;\n}\n\nstruct P {\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y) : x(x), y(y) {\n\t}\n\tP operator +(P p) {\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator -(P p) {\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator *(double d) {\n\t\treturn P(d*x, d*y);\n\t}\n\tdouble dot(P p) {\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det(P p) {\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\tvoid print() {\n\t\tprintf(\"%.10lf %.10lf \\n\", x, y);\n\t\treturn;\n\t}\n};\n\ndouble dist(P p1, P p2) {\n\tdouble dx = p1.x - p2.x;\n\tdouble dy = p1.y - p2.y;\n\treturn sqrt(dx*dx + dy*dy);\n}\n\nbool x_asc(const P& left, const P& right) {\n\treturn left.x < right.x;\n}\n\nbool y_asc(const P& left, const P& right) {\n\treturn left.y < right.y;\n}\n\nvoid merger(vector<P> &pointList, int start, int m, int end) {\n\tvector<P> tmp(end - start + 1);\n\tint i = start;\n\tint j = m + 1;\n\tfor (int k = 0; k<end - start + 1; k++) {\n\n\t\tif (i == m + 1) {\n\t\t\ttmp[k] = pointList[j];\n\t\t\tj++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (j == end + 1) {\n\t\t\ttmp[k] = pointList[i];\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pointList[i].y >= pointList[j].y) {\n\t\t\ttmp[k] = pointList[j];\n\t\t\tj++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pointList[i].y < pointList[j].y) {\n\t\t\ttmp[k] = pointList[i];\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tfor (int i = start; i<end + 1; i++) {\n\t\tpointList[i] = tmp[i-start];\n\t}\n}\n\ndouble closestPoint(vector<P> &pointList, int start, int end) {\n\tint n = end - start + 1;\n\tint m = (start+end) / 2;\n\tdouble center = pointList[m].x;\n\tdouble d;\n\tif (start == end) return INF;\n\td = min(closestPoint(pointList, start, m), closestPoint(pointList, m + 1, end));\n\tmerger(pointList, start, m, end);\n\n\tvector<P> rangeList;\n\tfor (int i = start; i<end + 1; i++) {\n\t\tif (fabs(pointList[i].x - center) >= d) continue;\n\n\t\tfor (int j = rangeList.size() - 1; j>-1; j--) {\n\t\t\tdouble dd = dist(rangeList[j], pointList[i]);\n\t\t\tif (pointList[i].y - rangeList[j].y > d) break;\n\t\t\td = min(d, dd);\n\t\t}\n\t\trangeList.push_back(pointList[i]);\n\n\t}\n\treturn d;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<P> pointList(n);\n\tREP(i, n) {\n\t\tcin >> pointList[i].x >> pointList[i].y;\n\t}\n\n\tsort(ALL(pointList), x_asc);\n\n\tprintf(\"%.10lf \\n\", closestPoint(pointList, 0, pointList.size() - 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ONLINE_JUDGE\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n#endif\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << std::endl; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) { std::cerr << std::boolalpha << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); std::cerr << std::noboolalpha; }\n#else\n\t#define debug(...) {}\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\ttemplate<typename T> class dvector : public std::vector<T> {\n\tpublic:\n\t\tdvector() : std::vector<T>() {}\n\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\tT& operator[](size_t n) {\n\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << std::endl; return this->at(n);\n\t\t\t}\n\t\t}\n\t\tconst T& operator[](size_t n) const {\n\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << std::endl; return this->at(n);\n\t\t\t}\n\t\t}\n\t};\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\tdbool(const dbool &b) : boolvalue(b.boolvalue) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const dvector<T>& v) {\n\t\tfor (int i = 0, len = v.size(); i < len; ++i){ s << v[i]; if (i < len - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const dvector< dvector<T> >& vv) {\n\t\tfor (int i = 0, len = vv.size(); i < len; ++i){ s << vv[i] << std::endl; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\" << std::endl; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << std::endl; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) { \n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE(int e) { std::cerr << boost::stacktrace::stacktrace() << std::endl; throw SIGFPE_exception();\t}\n\tvoid catch_SIGSEGV(int e) { std::cerr << boost::stacktrace::stacktrace() << std::endl; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = (ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1LL, 0LL, -1LL, 0LL};\nconstexpr ll dy[4] = {0LL, 1LL, 0LL, -1LL};\nconstexpr ll dx8[8] = {1LL, 0LL, -1LL, 0LL, 1LL, 1LL, -1LL, -1LL};\nconstexpr ll dy8[8] = {0LL, 1LL, 0LL, -1LL, 1LL, -1LL, 1LL, -1LL};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(vector<T> &v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline T gcd(T a, T b) { return b ? gcd(b,a%b) : a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a,  b) * b; }\ntemplate<typename T> inline bool chmax(T &a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T &a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(vector<T> &v) { v.erase(unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\n\n//doubleにおける == 判定\ninline double equals(double a,double b){ return fabs(a-b)<EPS; }\n\n//点、ベクトル\nclass Point {\npublic:\n\tdouble x,y;\n\tPoint(double x=0., double y=0.) : x(x), y(y) {}\n\tPoint operator + (Point p) {return Point(x+p.x, y+p.y);}\n\tPoint operator - (Point p) {return Point(x-p.x, y-p.y);}\n\tPoint operator * (Point p) {return Point(x*p.x, y*p.y);}\n\tPoint operator / (Point p) {return Point(x/p.x, y/p.y);}\n\tPoint operator + (double n) {return Point(x+n, y+n);}\n\tPoint operator - (double n) {return Point(x-n, y-n);}\n\tPoint operator * (double n) {return Point(x*n, y*n);}\n\tPoint operator / (double n) {return Point(x/n, y/n);}\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator < (const Point &p) const {\n\t\treturn x!=p.x ? x<p.x : y<p.y;\n\t}\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n\t}\n\t\n};\nusing Vector = Point;\nstd::ostream& operator<<(std::ostream& s, const Point& p) {\n\treturn s << \"(\" << p.x << \", \" << p.y << \")\";\n}\n\n//線分、直線\nclass Segment {\npublic:\n\tPoint p1,p2;\n\tSegment() {}\n\tSegment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\nusing Line = Segment;\nstd::ostream& operator<<(std::ostream& s, const Segment& se) {\n\treturn s << \"(\" << se.p1 << \", \" << se.p2 << \")\";\n}\n\n//点を回転させる\n//角度radはラジアンで指定すること\nVector rotate(Vector a, double rad){\n\treturn Vector(a.x*cos(rad)-a.y*sin(rad), a.x*sin(rad)+a.y*cos(rad));\n}\n//90度左回転させたベクトルを返す\nVector rotate90(Vector a){\n\treturn Vector(-a.y, a.x);\n}\n//180度回転させたベクトルを返す\nVector rotate180(Vector a){\n\treturn Vector(-a.x, -a.y);\n}\n//ベクトルの内積\ndouble dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n//ベクトルの外積\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\n//ベクトルa,bの角度を[0, π]の範囲で返す\ndouble angle(Vector a,Vector b){\n\treturn acos(dot(a,b)/a.abs()/b.abs());\n}\n//直交判定\nbool isOrthogonal(Vector a,Vector b){\n\treturn equals(dot(a,b), 0.0);\n}\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n\treturn isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n\treturn equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n//平行判定\nbool isParallel(Vector a,Vector b){\n\treturn equals(cross(a,b), 0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n\treturn isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n\treturn equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n//射影\nPoint project(Segment s,Point p){\n\tVector base = s.p2-s.p1;\n\tdouble r = dot(p-s.p1, base)/base.norm();\n\treturn base*r + s.p1;\n}\n//反射\nPoint reflect(Segment s,Point p){\n\treturn p + (project(s,p)-p)*2;\n}\n\n//p0,p1,p2が反時計回りになる\nstatic constexpr int COUNTER_CLOCKWISE = 1;\n//p0,p1,p2が時計回りになる\nstatic constexpr int CLOCKWISE = -1;\n//p2,p0,p1がこの順で同一直線上にある\nstatic constexpr int ONLINE_BACK = 2;\n//p0,p1,p2がこの順で同一直線上にある\nstatic constexpr int ONLINE_FRONT = -2;\n//p2が線分p0p1上にある\nstatic constexpr int ON_SEGMENT = 0;\n/*\n\t\t\t\t\tCOUNTER_CLOCKWISE\n\n ONLINE_BACK -- [p0 -- ON_SEGMENT -- p1] --- ONLINE_FRONT\n\n\t\t\t\t\t\tCLOCKWISE\n*/\nint ccw(Point p0, Point p1, Point p2){\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n\tif(cross(a,b)<-EPS)return CLOCKWISE;\n\tif(dot(a,b)<-EPS)return ONLINE_BACK;\n\tif(a.norm()<b.norm())return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\n//線分p1p2と線分p3p4の交差判定\n//端点が他方の線分上にある場合、線分二つが平行に重なる場合も交差しているとみなす\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1, Segment s2){\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n//二点間の距離\ndouble getDistance(Point a,Point b){\n\treturn (a-b).abs();\n}\n//点と直線の距離\ndouble getDistanceLP(Line l,Point p){\n\treturn fabs(cross(l.p2-l.p1, p-l.p1)) / (l.p2-l.p1).abs();\n}\n//点と線分の距離\ndouble getDistanceSP(Segment s,Point p){\n\tif(dot(s.p2-s.p1, p-s.p1)<0.)return (p-s.p1).abs();\n\tif(dot(s.p1-s.p2, p-s.p2)<0.)return (p-s.p2).abs();\n\treturn getDistanceLP(s,p);\n}\n//線分と線分の距離\ndouble getDistance(Segment s1,Segment s2){\n\tif(intersect(s1,s2))return 0.;\n\treturn min({getDistanceSP(s1,s2.p1), getDistanceSP(s1,s2.p2), getDistanceSP(s2,s1.p1), getDistanceSP(s2,s1.p2)});\n}\n\n//線分s1と線分s2の交点\nPoint getCrossPoint(Segment s1, Segment s2){\n\tVector base = s2.p2-s2.p1;\n\tdouble d1=fabs(cross(base, s1.p1-s2.p1));\n\tdouble d2=fabs(cross(base, s1.p2-s2.p1));\n\tdouble t=d1/(d1+d2);\n\treturn s1.p1+(s1.p2-s1.p1)*t;\n}\n\n//円\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\t//c:中心の点、r=半径\n\tCircle(Point c=Point(), double r=0.) : c(c), r(r) {}\n};\nstd::ostream& operator<<(std::ostream& s, const Circle& c) {\n\treturn s << \"(c = \" << c.c << \", r = \" << c.r << \")\";\n}\n\n//円cと線分lの交点の数を返す\nint hasCrossPoints(Circle c, Line l){\n\tdouble dis = getDistanceLP(l,c.c);\n\tif(equals(dis,c.r))return 1;\n\tif(dis < c.r)return 2;\n\treturn 0;\n}\n//円cと線分lの交点を返す\npair<Point,Point> getCrossPoints(Circle c, Line l){\n\tassert(getDistanceLP(l,c.c) < c.r+EPS);\n\tVector pr=project(l, c.c);\n\tVector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n\tdouble base=sqrt(c.r*c.r-(pr-c.c).norm());\n\treturn {pr+e*base, pr-e*base};\n}\n\n\n//ベクトルpとx軸との角度を返す 返却値の範囲[-π, π]\ninline double arg(Vector p){ return atan2(p.y, p.x); }\ninline double arg(Line l){ return arg(Point(l.p1.x-l.p2.x, l.p1.y-l.p2.y)); }\n//大きさa, x軸との角度rのベクトルを返す\ninline Vector polar(double a, double r){ return Point(cos(r)*a, sin(r)*a); }\n//円c1と円c2の交点を返す\npair<Point,Point> getCrossPoints(Circle c1, Circle c2){\n\tassert(getDistance(c1.c,c2.c) < c1.r+c2.r+EPS);\n\tdouble d = (c1.c-c2.c).abs();\n\tdouble a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(c1.r*d*2.));\n\tdouble t = arg(c2.c-c1.c);\n\treturn {c1.c+polar(c1.r,t+a), c1.c+polar(c1.r,t-a)};\n}\n\nusing Polygon = vector<Point>;\n//多角形gと点pの内包関係を返す\nstatic constexpr int INSIDE = 2;\nstatic constexpr int ONLINE = 1;\nstatic constexpr int OUTSIDE = 0;\nll contains(Polygon &g, Point p){\n\tll n=g.size();\n\tbool x=false;\n\tfor(ll i=0; i<n; i++){\n\t\tPoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return ONLINE;\n\t\tif(a.y > b.y) swap(a,b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a,b) > EPS) x=!x;\n\t}\n\treturn (x ? INSIDE : OUTSIDE);\n}\n\n//点の集合sに対する凸包を返す\nPolygon andrewScan(Polygon &s){\n\tPolygon u,l;\n\tif(s.size()<3) return s;\n\tsort(s.begin(), s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(ll i=2; i<(ll)s.size(); i++){\n\t\tfor(ll n=u.size(); n>=2 && ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE; n--){\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor(ll i=s.size()-3; i>=0; i--){\n\t\tfor(ll n=l.size(); n>=2 && ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE; n--){\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(), l.end());\n\tfor(ll i=u.size()-2; i>=1; i--)l.push_back(u[i]);\n\treturn l;\n}\n\n//線分の集合sの交点の数を返す\nclass EndPoint {\npublic:\n\tPoint p;\n\tll seg,st; //入力線分のID, 端点の種類\n\tEndPoint() {}\n\tEndPoint(Point p, ll seg, ll st) : p(p), seg(seg), st(st) {}\n\n\tbool operator < (const EndPoint &ep) const {\n\t\tif(p.y == ep.p.y) return st < ep.st;\n\t\treturn p.y < ep.p.y;\n\t}\n};\nvector<Point> manhattanIntersection(vector<Segment> &S){\n\tstatic const int BOTTOM = 0;\n\tstatic const int LEFT = 1;\n\tstatic const int RIGHT = 2;\n\tstatic const int TOP = 3;\n\tll n=S.size();\n\tvector<EndPoint> EP(2*n);\n\tfor(ll i=0,k=0; i<n; i++){\n\t\tif(S[i].p1.y==S[i].p2.y){\n\t\t\tif(S[i].p1.x>S[i].p2.x) swap(S[i].p1, S[i].p2);\n\t\t}else if(S[i].p1.y > S[i].p2.y){\n\t\t\tswap(S[i].p1, S[i].p2);\n\t\t}\n\n\t\tif(S[i].p1.y==S[i].p2.y){\n\t\t\tEP[k++]=EndPoint(S[i].p1, i, LEFT);\n\t\t\tEP[k++]=EndPoint(S[i].p2, i, RIGHT);\n\t\t}else{\n\t\t\tEP[k++]=EndPoint(S[i].p1, i, BOTTOM);\n\t\t\tEP[k++]=EndPoint(S[i].p2, i, TOP);\n\t\t}\n\t}\n\n\tsort(EP.begin(), EP.end());\n\n\tset<ll> BT;\n\tBT.insert(INF);\n\tvector<Point> ans;\n\tfor(ll i=0; i<2*n; i++){\n\t\tif(EP[i].st==TOP){\n\t\t\tBT.erase(EP[i].p.x);\n\t\t}else if(EP[i].st==BOTTOM){\n\t\t\tBT.insert(EP[i].p.x);\n\t\t}else if(EP[i].st==LEFT){\n\t\t\tauto b=BT.lower_bound(S[EP[i].seg].p1.x);\n\t\t\tauto e=BT.upper_bound(S[EP[i].seg].p2.x);\n\t\t\tfor(; b!=e; advance(b,1)){\n\t\t\t\tans.push_back(Point(*b,EP[i].p.y));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\treturn ans;\n}\n\n//最小包含円(pointvの点を内部に含む半径最小の円)を返す\n//ハックのあるコンテストではseedに time(0), random_device()() を渡した方がよい\nCircle minimumBoundingCircle(vector<Point> &pointv, ll seed = 2326) {\n\tconst ll n = pointv.size();\n\tassert(n >= 1);\n\tif (n == 1) {\n\t\treturn Circle(pointv[0], 0.);\n\t}\n\n\tstd::mt19937 mt(seed);\n\tstd::shuffle(pointv.begin(), pointv.end(), mt);\n\t// std::random_shuffle(left, right); // simple but deprecated\n\n\tauto make_circle_3 = [](Point &a, Point &b, Point &c) -> Circle {\n\t\tdouble A = (b - c).norm();\n\t\tdouble B = (c - a).norm();\n\t\tdouble C = (a - b).norm();\n\t\tdouble S = cross(b - a, c - a);\n\t\tPoint p = (a * A * (B + C - A) + b * B * (C + A - B)  + c * C * (A + B - C)) / (S * S * 4.);\n\t\tdouble r2 = (p - a).abs();\n\t\treturn Circle(p, r2);\n\t};\n\n\tauto make_circle_2 = [](Point &a, Point &b) -> Circle {\n\t\tPoint c = (a + b) / 2.;\n\t\tdouble r2 = (a - c).abs();\n\t\treturn Circle(c, r2);\n\t};\n\n\tauto in_circle = [](Point &a, Circle &c) -> bool {\n\t\treturn (a - c.c).norm() <= c.r * c.r + EPS;\n\t};\n\n\tCircle c = make_circle_2(pointv[0], pointv[1]);\n\n\t// MiniDisc\n\tfor (ll i = 2; i < n; ++i) {\n\t\tif (!in_circle(pointv[i], c)) {\n\t\t\t// MiniDiscWithPoint\n\t\t\tc = make_circle_2(pointv[0], pointv[i]);\n\t\t\tfor (ll j = 1; j < i; ++j) {\n\t\t\t\tif (!in_circle(pointv[j], c)) {\n\t\t\t\t\t// MiniDiscWith2Points\n\t\t\t\t\tc = make_circle_2(pointv[i], pointv[j]);\n\t\t\t\t\tfor (ll k = 0; k < j; ++k) {\n\t\t\t\t\t\tif (!in_circle(pointv[k], c)) {\n\t\t\t\t\t\t\tc = make_circle_3(pointv[i], pointv[j], pointv[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn c;\n}\n\n//使うときは closest_pair(points) を呼んでください\n//最近点対(距離が最小の2点)を返す\n//関数適用後、pointsには破壊的操作(y座標によるソート)が行われる点に注意\ntemplate<class iter>\npair<double, pair<Point,Point>> closest_pair_core(iter left, iter right) {\n\t\tll n = distance(left, right);\n\t\tif (n == 1) {\n\t\t\treturn {numeric_limits<double>::max(), {*left, *left}};\n\t\t}\n\t\tif (n == 2) {\n\t\t\tif(left[0].y > left[1].y) swap(left[0], left[1]);\n\t\t\treturn {(left[0]-left[1]).abs(), {left[0], left[1]}};\n\t\t}\n        \n\t\titer middle = next(left, n/2);\n        double x = middle->x;\n\t\tpair<double, pair<Point,Point>> d1 = closest_pair_core(left, middle);\n\t\tpair<double, pair<Point,Point>> d2 = closest_pair_core(middle, right);\n\t\tpair<double, pair<Point,Point>> d = (d1.first < d2.first) ? d1 : d2;\n\n\t\tstd::inplace_merge(left, middle, right,\n\t\t\t[](const Point &a, const Point &b) { return a.y < b.y; });\n\n\t\tvector<iter> around;\n\t\tfor(iter i = left; i != right; ++i){\n            if(fabs(i->x - x) >= d.first) continue;\n            for(auto j = around.rbegin(); j != around.rend(); ++j){\n                double dx = i->x - (*j)->x;\n                double dy = i->y - (*j)->y;\n                if (dy >= d.first) break;\n                double absval = sqrt(dx * dx + dy * dy);\n                if (d.first > absval) {\n                    d = {absval, {*i, **j}};\n                }\n            }\n            around.push_back(i);\n\t\t}\n\t\treturn d;\n}\npair<Point,Point> closest_pair(vector<Point> &points){\n\tsort(points.begin(), points.end());\n\treturn closest_pair_core(points.begin(), points.end()).second;\n}\n\n\n\n\n/*-----8<-----library-----8<-----*/\n\n\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\nvoid CGL_2_A(){\n\tll N;\n\tcin>>N;\n\tvector<ll> ans(N,0);\n\trep(i,N){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tll t=0;\n\t\tif(isOrthogonal(p0,p1,p2,p3)){\n\t\t\tt=1;\n\t\t}else if(isParallel(p0,p1,p2,p3)){\n\t\t\tt=2;\n\t\t}\n\t\tans[i]=t;\n\t}\n\trep(i,N)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=ja\nvoid CGL_1_A(){\n\tdouble x0,y0,x1,y1;\n\tcin>>x0>>y0>>x1>>y1;\n\tLine l(Point(x0,y0),Point(x1,y1));\n\tll Q;\n\tcin>>Q;\n\tvector<Point> ans(Q,0);\n\trep(i,Q){\n\t\tdouble xq,yq;\n\t\tcin>>xq>>yq;\n\t\tPoint po(xq,yq);\n\t\tPoint t=project(l,po);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q){\n\t\tcout<<ans[i].x<<' '<<ans[i].y<<'\\n';\n\t}\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=ja\nvoid CGL_1_B(){\n\tdouble x0,y0,x1,y1;\n\tcin>>x0>>y0>>x1>>y1;\n\tLine l(Point(x0,y0),Point(x1,y1));\n\tll Q;\n\tcin>>Q;\n\tvector<Point> ans(Q,0);\n\trep(i,Q){\n\t\tdouble xq,yq;\n\t\tcin>>xq>>yq;\n\t\tPoint po(xq,yq);\n\t\tPoint t=reflect(l,po);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q){\n\t\tcout<<ans[i].x<<' '<<ans[i].y<<'\\n';\n\t}\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=ja\nvoid CGL_2_D(){\n\tll Q;\n\tcin>>Q;\n\tvector<double> ans(Q,0);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tSegment s0(Point(x0,y0),Point(x1,y1)), s1(Point(x2,y2),Point(x3,y3));\n\t\tdouble t=getDistance(s0,s1);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\nvoid CGL_1_C(){\n\tdouble x0,y0,x1,y1;\n\tcin>>x0>>y0>>x1>>y1;\n\tPoint p0(x0,y0),p1(x1,y1);\n\tll Q;\n\tcin>>Q;\n\tvector<string> ans(Q,\"\");\n\tmap<ll,string> m;\n\tm[1]=\"COUNTER_CLOCKWISE\";\n\tm[-1]=\"CLOCKWISE\";\n\tm[2]=\"ONLINE_BACK\";\n\tm[-2]=\"ONLINE_FRONT\";\n\tm[0]=\"ON_SEGMENT\";\n\trep(i,Q){\n\t\tdouble xq,yq;\n\t\tcin>>xq>>yq;\n\t\tPoint pq(xq,yq);\n\t\tll t=ccw(p0,p1,pq);\n\t\tans[i]=m[t];\n\t}\n\trep(i,Q)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=ja\nvoid CGL_2_B(){\n\tll Q;\n\tcin>>Q;\n\tvector<ll> ans(Q,0);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tbool t=intersect(p0,p1,p2,p3);\n\t\tans[i]=t ? 1 : 0;\n\t}\n\trep(i,Q)p(ans[i]);\t\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=ja\nvoid CGL_2_C(){\n\tll Q;\n\tcin>>Q;\n\tvector<Point> ans(Q,0);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1,x2,y2,x3,y3;\n\t\tcin>>x0>>y0>>x1>>y1>>x2>>y2>>x3>>y3;\n\t\tPoint p0(x0,y0),p1(x1,y1),p2(x2,y2),p3(x3,y3);\n\t\tSegment s0(p0,p1),s1(p2,p3);\n\t\tPoint t=getCrossPoint(s0,s1);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q)p(ans[i].x,ans[i].y);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D&lang=ja\nvoid CGL_7_D(){\n\tll cx,cy,r,Q;\n\tcin>>cx>>cy>>r>>Q;\n\tCircle c(Point(cx,cy),r);\n\tvector<pair<Point,Point>> ans(Q);\n\trep(i,Q){\n\t\tdouble x0,y0,x1,y1;\n\t\tcin>>x0>>y0>>x1>>y1;\n\t\tPoint p0(x0,y0),p1(x1,y1);\n\t\tLine l(p0,p1);\n\t\tll count=hasCrossPoints(c,l);\n\t\tif(count==0)exit(1);\n\t\tpair<Point,Point> t=getCrossPoints(c,l);\n\t\tif(t.first.x>t.second.x || (equals(t.first.x,t.second.x) && t.first.y>t.second.y))swap(t.first,t.second);\n\t\tans[i]=t;\n\t}\n\tcout.setf(ios::fixed), cout.precision(20);\n\trep(i,Q)p(ans[i].first.x, ans[i].first.y, ans[i].second.x, ans[i].second.y);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E&lang=ja\nvoid CGL_7_E(){\n\tdouble c0x,c0y,r0,c1x,c1y,r1;\n\tcin>>c0x>>c0y>>r0>>c1x>>c1y>>r1;\n\tCircle c0(Point(c0x,c0y), r0), c1(Point(c1x,c1y), r1);\n\tpair<Point,Point> t=getCrossPoints(c0, c1);\n\tif(t.first.x>t.second.x || (equals(t.first.x,t.second.x) && t.first.y>t.second.y))swap(t.first,t.second);\n\tcout.setf(ios::fixed), cout.precision(20);\n\tp(t.first.x, t.first.y, t.second.x, t.second.y);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C&lang=ja\nvoid CGL_3_C(){\n\tll N;\n\tcin>>N;\n\tvector<Point> g(N);\n\trep(i,N)cin>>g[i].x>>g[i].y;\n\tll Q;\n\tcin>>Q;\n\tvector<ll> ans(Q,0);\n\trep(i,Q){\n\t\tll x,y;\n\t\tcin>>x>>y;\n\t\tll t=contains(g,Point(x,y));\n\t\tans[i]=t;\n\t}\n\trep(i,Q)p(ans[i]);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=ja\nvoid CGL_4_A(){\n\tll N;\n\tcin>>N;\n\tvector<Point> g(N);\n\trep(i,N)cin>>g[i].x>>g[i].y;\n\tvector<Point> ch=andrewScan(g);\n\tprintf(\"%lld\\n\",(ll)ch.size());\n\tll f=0;\n\trepeq(i,ch.size()-1){\n\t\tif(ch[f].y>ch[i].y || (ch[f].y==ch[i].y && ch[f].x>ch[i].x)){\n\t\t\tf=i;\n\t\t}\n\t}\n\trep(i,ch.size()){\n\t\tprintf(\"%lld %lld\\n\",(ll)ch[(i+f)%ch.size()].x, (ll)ch[(i+f)%ch.size()].y);\n\t}\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_6_A&lang=ja\nvoid CGL_6_A(){\n\tll N;\n\tcin>>N;\n\tvector<Segment> a(N);\n\trep(i,N)cin>>a[i].p1.x>>a[i].p1.y>>a[i].p2.x>>a[i].p2.y;\n\tvector<Point> ans=manhattanIntersection(a);\n\tp(ans.size());\n}\n\n//https://atcoder.jp/contests/abc151/tasks/abc151_f\nvoid ABC151F() {\n\tll N;\n\tcin>>N;\n\tvector<double> x(N,0),y(N,0);\n\trep(i, N) { cin>>x[i]>>y[i]; }\n\tvector<Point> v;\n\trep(i,N){\n\t\tv.emplace_back(x[i],y[i]);\n\t}\n\tCircle ans=minimumBoundingCircle(v);\n\tcout.setf(ios::fixed), cout.precision(20);\n\tp(ans.r);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=ja\nvoid CGL_5_A() {\n\tll N;\n\tcin>>N;\n\tvector<double> x(N,0),y(N,0);\n\trep(i, N) { cin>>x[i]>>y[i]; }\n\tvector<Point> v;\n\trep(i,N){\n\t\tv.emplace_back(x[i],y[i]);\n\t}\n\tpair<Point,Point> anspr=closest_pair(v);\n\tdouble ans=getDistance(anspr.first, anspr.second);\n\tcout.setf(ios::fixed), cout.precision(20);\n\tp(ans);\n}\n\nsigned main() {\n\t//CGL_2_A();\n\t//CGL_1_A();\n\t//CGL_1_B();\n\t//CGL_2_D();\n\t//CGL_1_C();\n\t//CGL_2_B();\n\t//CGL_2_C();\n\t//CGL_7_D();\n\t//CGL_7_E();\n\t//CGL_3_C();\n\t//CGL_4_A();\n\t//CGL_6_A();\n\t//ABC151F();\n\tCGL_5_A();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\nld getdis(const pair<ld, ld>&l, const pair<ld, ld>&r) {\n\treturn sqrt((l.first - r.first)*(l.first - r.first) + (l.second - r.second)*(l.second - r.second));\n}\nld getans(vector<pair<ld, ld>>&ps) {\n\tif (ps.size() == 2) {\n\t\treturn getdis(ps[0], ps[1]);\n\t}\n\telse if (ps.size() <= 1) {\n\t\treturn 1e18;\n\t}\n\telse {\n\t\tint n = ps.size() / 2;\n\t\tvector<pair<ld, ld>>al(ps.begin(), ps.begin() + ps.size() / 2);\n\t\tvector<pair<ld, ld>>ar(ps.begin()+ps.size()/2, ps.end());\n\t\tld la = getans(al);\n\t\tld ra = getans(ar);\n\t\tld nans = min(la, ra);\n\t\tauto lit = lower_bound(ps.begin(), ps.end(), make_pair(ps[n].first - nans - 1, -1e18l));\n\t\tauto rit = upper_bound(ps.begin(), ps.end(), make_pair(ps[n].first + nans + 1,  1e18l));\n\t\tfor (auto a = lit; a != rit; ++a) {\n\t\t\tfor (auto b = next(a); b != rit; ++b) {\n\t\t\t\tnans = min(nans, getdis(*a, *b));\n\t\t\t}\n\t\t}\n\t\treturn nans;\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\tvector<pair<ld, ld>>ps;\n\tfor (int i = 0; i < N; ++i) {\n\t\tld x, y; cin >> x >> y;\n\t\tps.emplace_back(x, y);\n\t}\n\tsort(ps.begin(), ps.end());\n\tld ans = getans(ps);\n\tcout <<setprecision(22)<<fixed<< ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\nusing pld = pair<ld, ld>;\nconst ld INF = 1e3;\n\nbool comp(pld a, pld b) {\n\treturn a.second < b.second;\n}\n\nld closest_pair(pld *a, int n) {\n\tif (n <= 1) return INF;\n\tint m = n / 2;\n\tld x = a[m].first;\n\tld d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n\tinplace_merge(a, a + m, a + n, comp);\n\tvector<pld> b;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (abs(a[i].first - x) >= d) continue;\n\t\tfor (int j = 0; j < (int)b.size(); j++) {\n\t\t\tld dx = a[i].first - b[b.size() - j - 1].first;\n\t\t\tld dy = a[i].second - b[b.size() - j - 1].second;\n\t\t\tif (dy >= d) break;\n\t\t\td = min(d, sqrtl(dx * dx + dy * dy));\n\t\t}\n\t\tb.push_back(a[i]);\n\t}\n\treturn d;\n}\n\nconst int MAX = 1e5;\n\npld ps[MAX];\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> ps[i].first >> ps[i].second;\n\t}\n\tcout << fixed << setprecision(8) << closest_pair(ps, n) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// 最近点対\n//\n// verified:\n//   AOJ Course CGL_5_A Point Set - Closest Pair\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=jp\n//\n\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n\n////////////////////////////\n// 基本要素 (点, 線分, 円)\n////////////////////////////\n\nusing DD = double;\nconst DD INF = 1LL<<60;      // to be set appropriately\nconst DD EPS = 1e-10;        // to be set appropriately\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\n/* Point */\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\ninline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\ninline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\ninline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\ninline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\ninline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\ninline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\ninline Point conj(const Point &p) {return Point(p.x, -p.y);}\ninline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\ninline Point rot90(const Point &p) {return Point(-p.y, p.x);}\ninline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\ninline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\ninline DD norm(const Point &p) {return dot(p, p);}\ninline DD abs(const Point &p) {return sqrt(dot(p, p));}\ninline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\ninline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\ninline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\ninline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\ninline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\n/* Line */\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\n/* Circle */\nstruct Circle : Point {\n    DD r;\n    Circle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n    friend ostream& operator << (ostream &s, const Circle &c) {return s << '(' << c.x << \", \" << c.y << \", \" << c.r << ')';}\n};\n\n\n// 最近点対\nbool compare_y(Point a, Point b) { return a.y < b.y; }\nDD DivideAndConqur(vector<Point>::iterator it, int n) {\n    if (n <= 1) return INF;\n    int m = n/2;\n    DD x = it[m].x;\n    DD d = min(DivideAndConqur(it, m), DivideAndConqur(it+m, n-m));\n    inplace_merge(it, it+m, it+n, compare_y);\n    \n    vector<Point> vec;\n    for (int i = 0; i < n; ++i) {\n        if (fabs(it[i].x - x) >= d) continue;\n        for (int j = 0; j < vec.size(); ++j) {\n            DD dx = it[i].x - vec[vec.size()-j-1].x;\n            DD dy = it[i].y - vec[vec.size()-j-1].y;\n            if (dy >= d) break;\n            d = min(d, sqrt(dx*dx+dy*dy));\n        }\n        vec.push_back(it[i]);\n    }\n    return d;\n}\nDD Closet(vector<Point> ps) {\n    int n = (int)ps.size();\n    sort(ps.begin(), ps.end());\n    return DivideAndConqur(ps.begin(), n);\n}\n\n\nint main() {\n    int N; cin >> N;\n    vector<Point> ps(N);\n    for (int i = 0; i < N; ++i) cin >> ps[i].x >> ps[i].y;\n    cout << fixed << setprecision(10) << Closet(ps) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nstruct P\n{\n\tdouble x, y;\n\tP(double x, double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn x*x + y*y;\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n};\n\nint ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}\n\npair<P, P> ClosestPair(vector<P>& points)\n{\n\tint n = points.size(), s = 0, t = 1, m = 2;\n\tvector<int> S(n);\n\tS[0] = 0, S[1] = 1;\n\tsort(points.begin(), points.end());\n\tdouble d = (points[s] - points[t]).length2();\n\tfor (int i = 2; i < n; S[m++] = i++)for (int j = 0; j < m; j++)\n\t{\n\t\tif ((points[S[j]] - points[i]).length() < d)\n\t\t{\n\t\t\td = (points[s = S[j]] - points[t = i]).length2();\n\t\t}\n\t\tif (points[S[j]].x < points[i].x - d)\n\t\t{\n\t\t\tS[j--] = S[--m];\n\t\t}\n\t}\n\treturn make_pair(points[s], points[t]);\n}\n\nvector<P> points;\n\nint main()\n{\n\tpoints.reserve(100000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpoints.push_back(P(x, y));\n\t}\n\n\tpair<P, P> closestPair = ClosestPair(points);\n\tprintf(\"%.10lf\\n\", (closestPair.first - closestPair.second).length());\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 100000;\nconst double INFTY = 10000000000000000000.0;\n\nstruct Point { double x, y; };\nbool compareX(Point& a, Point& b) {\n\treturn a.x < b.x ? true : a.x == b.x && a.y <= b.y ? true : false;\n}\n\nbool compareY(Point& a, Point& b) {\n\treturn a.y < b.y ? true : a.y == b.y && a.x <= b.x ? true : false;\n}\n\ninline double getSquareDist(Point a, Point b) {\n\treturn (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\ninline double getMinSquareDistOfThree(Point a, Point b, Point c) {\n\treturn min(getSquareDist(a, b), min(getSquareDist(a, c), getSquareDist(b, c)));\n}\n\ndouble getMinSquareDistNearMid(Point nearmid[], int nearmid_length) {\n\tsort(nearmid, nearmid + nearmid_length, compareY);\n\n\tdouble min_sq_dist = INFTY;\n\tdouble cur_sq_dist;\n\tfor (int i = 0; i < nearmid_length; ++i) {\n\t\t// a better implementation:\n\t\t//for (int j = i + 1; j < min(nearmid_length, i + 8); ++j) {\n\t\tfor (int j = i + 1; j < nearmid_length && (nearmid[j].y - nearmid[i].y) < min_sq_dist; ++j) {\n\t\t\tcur_sq_dist = getSquareDist(nearmid[i], nearmid[j]);\n\t\t\tif (cur_sq_dist < min_sq_dist)\n\t\t\t\tmin_sq_dist = cur_sq_dist;\n\t\t}\n\t}\n\treturn min_sq_dist;\n}\n\n// nlog^2 n, not nlog n in CLRS\ndouble dcClosestSquareDist(int low, int high, Point points[]) {\n\tif (high - low == 1) {\n\t\treturn getSquareDist(points[low], points[high]);\n\t}\n\telse if (high - low == 2) {\n\t\treturn getMinSquareDistOfThree(points[low], points[low + 1], points[high]);\n\t}\n\telse {\n\t\t// bug 3: + has higher precedence than >>\n\t\t//int mid = low + (high - low) >> 1;\n\t\tint mid = low + ((high - low) >> 1);\n\t\tdouble d_left = dcClosestSquareDist(low, mid, points);\n\t\tdouble d_right = dcClosestSquareDist(mid + 1, high, points);\n\t\tdouble d_divide = min(d_left, d_right);\n\t\tdouble d_divide_sqrt = sqrt(d_divide);\n\n\t\t// merge\n\t\tPoint *nearmid = new Point[high - low + 1];\n\t\tint nearmid_length = 0;\n\t\tfor (int i = low; i <= high; ++i) {\n\t\t\t// bug 4: here we should compare the dist with real dist, not squared!\n\t\t\tif (points[i].x - points[mid].x < d_divide_sqrt && points[i].x - points[mid].x > -d_divide_sqrt) {\n\t\t\t\tnearmid[nearmid_length] = points[i];\n\t\t\t\tnearmid_length++;\n\t\t\t}\n\t\t}\n\t\tdouble d_merge = getMinSquareDistNearMid(nearmid, nearmid_length);\n\t\t// bug 6: forget to free memory\n\t\tdelete[] nearmid;\n\t\treturn min(d_divide, d_merge);\n\t}\n}\n\ndouble getMinSqDistToFirst(Point first_camera, Point points[], int n) {\n\tdouble min_sq_dist = INFTY;\n\tdouble cur_sq_dist;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcur_sq_dist = getSquareDist(first_camera, points[i]);\n\t\tif (cur_sq_dist < min_sq_dist)\n\t\t\tmin_sq_dist = cur_sq_dist;\n\t}\n\treturn min_sq_dist;\n}\n\ndouble getArea(double candidate, double min_dist_to_first, int n) {\n\treturn candidate * candidate + (n - 1) * (min_dist_to_first - candidate) * (min_dist_to_first - candidate);\n}\n\n/*\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tint n;\n\tPoint points[MAX_N];\n\tPoint first_camera;\n\tdouble min_dist_to_first;\n\tdouble min_dist_among_others;\n\tdouble candidate1;\t// candidate1 = max(0, d1 - d2 / 2)\n\tdouble candidate2;\t// candidate2 = d1\n\tdouble max_area;\n\tfor (int i = 1; i <= t; ++i) {\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%lf%lf\", &(first_camera.x), &(first_camera.y));\n\t\tfor (int j = 0; j < n - 1; ++j) {\n\t\t\tscanf(\"%lf%lf\", &(points[j].x), &(points[j].y));\n\t\t}\n\t\tmin_dist_to_first = sqrt(getMinSqDistToFirst(first_camera, points, n));\n\t\tif (n == 2) {\n\t\t\tmin_dist_among_others = INFTY;\n\t\t}\n\t\telse {\n\t\t\tsort(points, points + n - 1, compareX);\n\t\t\tmin_dist_among_others = sqrt(dcClosestSquareDist(0, n - 2, points));\n\t\t}\n\t\t//printf(\"%f\\n\", min_dist_among_others);\n\t\tcandidate1 = max(0.0, min_dist_to_first - min_dist_among_others / 2.0);\n\t\tcandidate2 = min_dist_to_first;\n\t\tmax_area = M_PI * max(getArea(candidate1, min_dist_to_first, n), getArea(candidate2, min_dist_to_first, n));\n\t\tprintf(\"Case #%d: %.8f\\n\", i, max_area);\n\t}\n    return 0;\n}\n*/\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tPoint* points = new Point[MAX_N];\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%lf%lf\", &(points[i].x), &(points[i].y));\n\t}\n\tsort(points, points + n, compareX);\n\tprintf(\"%.10lf\\n\", sqrt(dcClosestSquareDist(0, n, points)));\n\tdelete[] points;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pt pair<double,double>\n#define x first\n#define y second\nconst double INF=1e5;\npt p[100010];\ndouble pw2(double d){return d*d;}\ndouble dist(pt a,pt b){return sqrt(pw2(a.x-b.x)+pw2(a.y-b.y));}\ndouble closest(int l,int r)\n{\n  if(l==r) return INF;\n  int mid=(l+r)/2,pp=l,qq=mid+1;\n  double midline=p[mid].x;\n  double ret=min(closest(l,mid),closest(mid+1,r));\n  //merge sort\n  vector<pt> merge,slab;\n  while(pp<=mid || qq<=r)\n    if(pp>mid) merge.push_back(p[qq++]);\n    else if(qq>r) merge.push_back(p[pp++]);\n    else merge.push_back(p[pp].y<p[qq].y?p[pp++]:p[qq++]);\n  pp=l;for(int i=0;i<merge.size();i++)p[pp++]=merge[i];\n  //conquer\n  for(int i=l;i<=r;i++)\n    //if(abs(p[i].x-midline)<ret*2)\n      slab.push_back(p[i]);\n  for(int i=0;i<slab.size();i++)\n    for(int j=i+1,c=0;j<slab.size() && c<7;j++,c++)\n      ret=min(ret,dist(slab[i],slab[j]));\n  return ret;\n}\nint main()\n{\n  int n;\n  cin>>n;\n  for(int i=1;i<=n;i++)\n    cin>>p[i].x>>p[i].y;\n  cout<<fixed<<closest(1,n)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<int, int> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int distance_ = (p1[i + 1].first - p1[i].first) * (p1[i + 1].first - p1[i].first) + (p1[i + 1].second - p1[i].second) * (p1[i + 1].second - p1[i].second);\n        \n        sqr_ans = min(distance_, sqr_ans);\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int distance_ = (p2[i + 1].first - p2[i].first) * (p2[i + 1].first - p2[i].first) + (p2[i + 1].second - p2[i].second) * (p2[i + 1].second - p2[i].second);\n        \n        sqr_ans = min(distance_, sqr_ans);\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define all(a) a.begin(),a.end()\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\nconst double INF = 1e9;\n\nbool compX(const Point a, const Point b) {\n    return (a.X!=b.X ? a.X<b.X : a.Y<b.Y);\n}\n\nbool compY(const Point a, const Point b) {\n    return a.Y<b.Y;\n}\n\ndouble closestPair(VP &a,int l,int r) {\n    if(r-l<=1) return INF;\n    int m = (l+r)/2;\n    double x = a[m].X;\n    double d = min(closestPair(a,l,m),closestPair(a,m,r));\n    inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,compY);\n    \n    VP b;\n    for(int i=l;i<r;i++){\n        if(abs(a[i].X - x)>=d)continue;\n        for(int j=b.size()-1;j>=0;j--){\n            if((a[i]-b[j]).Y>=d)break;\n            d = min(d,abs(a[i]-b[j]));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main(void){\n    int n;\n    cin>>n;\n    VP ps(n);\n    rep(i,n){\n        double x,y;\n        cin>>x>>y;\n        ps[i] = Point(x,y);\n    }\n    sort(all(ps),compX);\n    printf(\"%.9f\\n\",closestPair(ps,0,n));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace ClosestPair{\n\t// DIM=3????£????????¬????????????????????????´?????????getNearPoints()makeBucket()?????´\n\tconst double EPS = 1e-9;\n\tconst int DIM = 3;\n\ttypedef array<double,DIM> P;\n\n\tdouble dist(const P &p1,const P &p2){\n\t\tdouble ans = 0;\n\t\tfor(int i = 0 ; i < DIM ; i++)\n\t\t\tans += (p1[i]-p2[i])*(p1[i]-p2[i]);\n\t\treturn sqrt(ans);\n\t}\n\ttypedef array<int,DIM> Block;\n\ttypedef map<Block,vector<int>> Bucket;\n\tBlock getBlock(const P &p,double w){\n\t\tBlock res;\n\t\tfor(int i = 0 ; i < DIM ; i++) res[i] = p[i] / w;\n\t\treturn res;\n\t}\n\tvector<int> getNearPoints(const Bucket &b,double w,const P &p){\n\t\tvector<int> res;\n\t\tauto key = getBlock(p,w);\n\t\tfor(int x0 = -1 ; x0 <= 1 ; x0++)\n\t\t\tfor(int x1 = -1 ; x1 <= 1 ; x1++)\n\t\t\t\tfor(int x2 = -1 ; x2 <= 1 ; x2++){\n\t\t\t\t\tauto it = b.find(Block{key[0]+x0,key[1]+x1,key[2]+x2});\n\t\t\t\t\tif( it != b.end() ){\n\t\t\t\t\t\tfor( int id : it->second ) res.push_back(id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\treturn res;\n\t}\n\t//???w???n?¬?????????±????????????????????????????????¨????????°??¨??????????????????????±????????????¨?????§?????????\n\tBucket makeBucket(const vector<P> &ps,double w){\n\t\tBucket b;\n\t\tfor(int i = 0 ; i < ps.size() ; i++)\n\t\t\tb[getBlock(ps[i],w)].push_back(i);\n\t\treturn b;\n\t}\n\t// ????????????????????¢????????????????????±???????¬??§??????? map????????¨?????????????????§???????¨???????O(n log n)\n\t// ?????±??????????????????????§???????????????????????¢????????£?????????????????????????????????§??????????????§???????????????2w??????????????????????????????w???????????????????\\??????????\n\tdouble closetPairDistance(vector<P> ps){\n\t\tassert(ps.size()>=2);\n\t\trandom_shuffle(ps.begin(),ps.end());\n\t\tdouble w = dist(ps[0],ps[1]);\n\t\tvector<P> build = {ps[0],ps[1]};\n\t\tauto b = makeBucket(build,w);\n\t\tfor(int i = 2 ; i < ps.size() ; i++){\n\t\t\tdouble next_w = w;\n\t\t\tfor( int j : getNearPoints(b,2*w,ps[i]) )\n\t\t\t\tnext_w = min(next_w,dist(ps[i],ps[j]));\n\t\t\tbuild.push_back(ps[i]);\n\t\t\tif( w - EPS > next_w ){\n\t\t\t\tw = next_w;\n\t\t\t\tb = makeBucket(build,2*w);\n\t\t\t}else{\n\t\t\t\tb[getBlock(ps[i],2*w)].push_back(i);\n\t\t\t}\n\t\t}\n\t\treturn w;\n\t}\n};\n\nusing namespace ClosestPair;\n\nint main(){\n\tint n;\n\tvector<P> ps;\n\tcin >> n;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tdouble x,y;\n\t\tcin >> x >> y;\n\t\tps.push_back(P{x,y,0});\n\t}\n\tprintf(\"%.10lf\\n\",closetPairDistance(ps));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS; }\n\nusing Point = complex< double >;\n\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble radian_to_degree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble degree_to_radian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() {}\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(double A, double B, double C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() {}\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle() {}\n\n  Circle(Point p, double r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\ndouble cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\nbool parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ndouble distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\ndouble distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\ndouble distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\ndouble distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\ndouble distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point hp = projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return {hp - v, hp + v};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\nenum {\n  OUT, ON, IN\n};\n\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\nbool merge_if_able(Segment &s1, Segment s2) {\n  if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid merge_segments(vector< Segment > &segs) {\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon convex_cut(Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble area2(const Polygon &p) {\n  double A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble convex_diameter(Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\ndouble closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n\n  function< double(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return 1e18;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    vector< Point > b;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < b.size(); j++) {\n        auto luz = ps[i] - b[b.size() - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      b.emplace_back(ps[i]);\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\n\nint main() {\n  int N;\n  cin >> N;\n  Points p(N);\n  for(auto &s : p) cin >> s;\n  cout << fixed << setprecision(10) << closest_pair(p) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.00000000001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct vec{\n  double x, y;\n  void nextvec(){ scanf(\"%lf %lf\", &x, &y); return; }\n  vec operator+(const vec& a) const { return (vec){x + a.x, y + a.y}; }\n  vec operator-(const vec& a) const { return (vec){x - a.x, y - a.y}; }\n  vec operator*(const double& k) const { return (vec){k * x, k * y}; }\n  vec sca(double t){ return (vec){t * x, t * y}; }\n  double dot(vec a){ return x * a.x + y * a.y; }\n  double cross(vec a){ return x * a.y - y * a.x; }\n  double norm(){ return sqrt(x * x + y * y); }\n  double norm2(){ return x * x + y * y; }\n};\n\nbool xsort(vec qwe, vec rty){ return qwe.x < rty.x; }\nbool ysort(vec qwe, vec rty){ return qwe.y < rty.y; }\n\nvec pt[100000];\ndouble ma = 100000.0;\n\nvec fory[100000];\ndouble closestpair(int l, int r){\n  if(r - l <= 1)return ma;\n  int m = l + (r - l) / 2;\n  double xm = pt[m].x;\n  double res = closestpair(l, m);\n  res = min(res, closestpair(m, r));\n\n  inplace_merge(pt + l, pt + m, pt + r, ysort);\n  int hd = 0;\n  for(int i = l;i < r;++i)if(pt[i].x - xm <= res + eps){\n    fory[hd++] = pt[i];\n    for(int j = hd - 2;j >= 0;--j){\n      if(fory[j].y - pt[i].y > res + eps)break;\n      res = min(res, (pt[i] - fory[j]).norm());\n    }\n  }\n  return res;\n}\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int(n);\n    rep(i, n)pt[i].nextvec();\n    sort(pt, pt + n, xsort);\n    printf(\"%.13lf\\n\", closestpair(0, n));\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct node{\n  int dim;\n  vector<double>v;\n};\n\ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n\ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n\n  vector<node>res;\n\n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n\n    double dist=d(p,S)/(4*p.dim);\n\n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n\n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    \n    S=nextS;    \n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n\n  return ans;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n\n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() {ld x, y; cin >> x >> y; return Point(x, y);} // ????????\\???\nbool eq(ld a, ld b) {return (abs(a - b) < eps);} // ????????????????????????\nld dot(Point a, Point b) {return real(conj(a) * b);} // ??????\nld cross(Point a, Point b) {return imag(conj(a) * b);} // ??????\n\n// ??´????????????\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// ????????????\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n\ntypedef vector<Point> Polygon;\nld p_pow(const Point& p1,const Point& p2){\n    return (p1.real() - p2.real()) * (p1.real() - p2.real()) + (p1.imag() - p2.imag())*(p1.imag() - p2.imag());\n}\n/* ????????\\?????? : ?????¢????????????????????´ */\nld ClosestPair(int l, int r,const Polygon& poly){\n    if(r-l == 1) return p_pow(poly[l],poly[r]);\n    if(r-l == 2) return min({p_pow(poly[l],poly[l+1]),p_pow(poly[l],poly[l+2]),p_pow(poly[l+1],poly[l+2])});\n    \n    int m = (l+r)/2;\n    // ????????±??????\n    ld d = min(ClosestPair(l, m, poly),ClosestPair(m+1, r, poly));\n    \n    Polygon v;\n    for(int i = l; i <= r;i++){\n        if((poly[i].real() - poly[m].real())*(poly[i].real() - poly[m].real())< d){\n            v.emplace_back(Point(poly[i].imag(),poly[i].real()));\n        }\n    }\n    sort(v.begin(),v.end());\n    for(int i = 0; i < (int)v.size();i++){\n        for(int j = i + 1; j < (int)v.size();j++){\n            if((v[i].real() - v[j].real())*(v[i].real() - v[j].real()) > d)break;\n            d = min(d,p_pow(v[i],v[j]));\n        }\n    }\n    return d;\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int n ;cin >> n;\n    Polygon ps;\n    for(int i = 0;i < n;i++) ps.emplace_back(input_point());\n    cout << fixed << setprecision(10) << sqrt(ClosestPair(0, (int)ps.size()-1, ps)) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    //return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\n\ntypedef vector<P> G;\n\ndouble convex_radius(const G &ps, int left, int right) {\n  if(right - left <= 1) return (double)INF;\n  int m = (right + left) / 2;\n  double d = min(convex_radius(ps, left, m), convex_radius(ps, m, right));\n  for(int i = left ; i < right; ++i){\n    if(fabs(ps[i].X - ps[m].X) >= d) continue;\n    for(int j = i - 1; j >= left; --j){\n      if(ps[i].Y - ps[j].Y >= d) break;\n      d = min(d, norm(ps[i] - ps[j]));\n    }\n  }\n  return d;\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  SORT(g);\n  printf(\"%.10lf\\n\", sqrt(convex_radius(g, 0, N)));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i, a, b) for(int i = (a); i < (b); ++i)\n#define per(i, a, b) for(int i = (b) - 1; i >= (a); --i)\n#define sz(a) (int)a.size()\n#define de(c) cout << #c << \" = \" << c << endl\n#define dd(c) cout << #c << \" = \" << c << \" \"\n#define all(a) a.begin(), a.end()\n#define pw(x) (1ll<<(x))\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntypedef db T;\nconst db eps = 1e-9 , pi = acosl(-1.);\nint sgn(T x){return (x>eps)-(x<-eps);}\nstruct P{\n  T x,y; P(){} P(T x,T y):x(x),y(y){}\n  P operator - (const P&b) const {return P(x-b.x,y-b.y);}\n  P operator + (const P&b) const {return P(x+b.x,y+b.y);}\n  T operator * (const P&b) const {return x*b.x+y*b.y;}\n  T operator / (const P&b) const {return x*b.y-y*b.x;}\n  P operator * (const T&k) const {return P(x*k,y*k);}\n  P operator / (const T&k) const {return P(x/k,y/k);}\n\tbool operator < (const P&b) const {return sgn(x-b.x)?x<b.x:y<b.y;}\n};\nT norm(P a){return a*a;}\nT abs(P a) {return sqrtl(norm(a));}\nP proj(P p,P a,P b){return (b-a)*((p-a)*(b-a)/norm(b-a))+a;}\nP reflect(P p,P a,P b){return proj(p,a,b)*2-p;}\nT cross(P o,P a,P b){return (a-o)/(b-o);}\nint crossOp(P o,P a,P b){return sgn(cross(o,a,b));}\nbool onPS(P p,P s,P t){return sgn((t-s)/(p-s))==0&&sgn((p-s)*(p-t))<=0;}\nstruct L{ P s,t;L(){} L(P s,P t):s(s),t(t){}};\nP insLL(L a,L b){ // line x line\n\tP s = a.s - b.s , v = a.t - a.s , w = b.t - b.s;\n\tdb k1 = s / w , k2 = w / v;\n\tif(sgn(k2) == 0) return abs(b.s - a.s) < abs(b.t - a.s) ? b.s : b.t;\n\treturn a.s + v * (k1 / k2);\n}\nbool isSS(L a,L b){ // seg x seg , replace x->y to accelerate\n\tT c1=(a.t-a.s)/(b.s-a.s),c2=(a.t-a.s)/(b.t-a.s);\n\tT c3=(b.t-b.s)/(a.s-b.s),c4=(b.t-b.s)/(a.t-b.s);\n\treturn sgn(c1) * sgn(c2) <= 0 && sgn(c3) * sgn(c4) <= 0 &&\n\t\tsgn(max(a.s.x,a.t.x) - min(b.s.x,b.t.x)) >= 0 &&\n\t\tsgn(max(b.s.x,b.t.x) - min(a.s.x,a.t.x)) >= 0 &&\n\t\tsgn(max(a.s.y,a.t.y) - min(b.s.y,b.t.y)) >= 0 &&\n\t\tsgn(max(b.s.y,b.t.y) - min(a.s.y,a.t.y)) >= 0;\n}\ndb disPL(P p,L a){return fabs((a.t-a.s)/(p-a.s)) / abs(a.t-a.s);}\ndb disPS(P p,L a){ // p x seg dis\n\tif(sgn((a.t-a.s)*(p-a.s)) == -1) return abs(p-a.s);\n\tif(sgn((a.s-a.t)*(p-a.t)) == -1) return abs(p-a.t);\n\treturn disPL(p,a);\n}\ndb disSS(L a,L b){ // seg x seg dis\n\tif(isSS(a,b)) return 0;\n\treturn min(min(disPS(a.s,b),disPS(a.t,b)),min(disPS(b.s,a),disPS(b.t,a)));\n}\ntypedef vector<P> polygon;\npolygon convex(polygon A){ // counter-clockwise , < : <=180 , <= : <180\n  int n=sz(A),m=0;\n  polygon B;B.resize(n<<1);\n  sort(all(A));\n  rep(i,0,n){\n    while(m > 1 && sgn((B[m-1]-B[m-2])/(A[i]-B[m-2]))<0) --m;\n    B[m++]=A[i];\n  }\n  int k = m;\n  per(i,0,n-1){\n    while(m > k && sgn((B[m-1]-B[m-2])/(A[i]-B[m-2]))<0) --m;\n    B[m++]=A[i];\n  }\n  B.resize(m);\n  if(sz(B) > 1) B.pop_back();\n  return B;\n}\nT area(polygon A) { // multiple 2 with integer type\n\tT res=0;\n\trep(i,0,sz(A)) res+=A[i]/(A[(i+1)%sz(A)]);\n\treturn fabs(res) / 2;\n}\nbool isconvex(polygon A){ // counter-clockwise\n\tbool ok=1;int n=sz(A);\n\trep(i,0,2) A.pb(A[i]);\n\trep(i,0,n) ok&=((A[i+1]-A[i])/(A[i+2]-A[i]))>=0;\n\treturn ok;\n}\nint inPpolygon(P p,polygon A){ // -1 : on , 0 : out , 1 : in\n\tint res=0;\n\trep(i,0,sz(A)){\n\t\tP u=A[i],v=A[(i+1)%sz(A)];\n\t\tif(onPS(p,u,v)) return -1;\n\t\tT cross = sgn((v-u)/(p-u)) , d1 = sgn(u.y-p.y) , d2 = sgn(v.y-p.y);\n\t\tif(cross > 0 && d1 <= 0 && d2 > 0) ++res;\n\t\tif(cross < 0 && d2 <= 0 && d1 > 0) --res;\n\t}\n\treturn res != 0;\n}\nT diameter(polygon A) { // longest distance\n  int n=sz(A);if(n <= 1) return 0;\n  int l=0,r=0;rep(i,1,n) (A[i]<A[l])&&(l=i),(A[r]<A[i])&&(r=i);\n  db res=abs(A[l]-A[r]);int i=l,j=r;\n  do (++((A[(i+1)%n]-A[i])/(A[(j+1)%n]-A[j])>=0?j:i))%=n,\n    res=max(res,abs(A[i]-A[j]));\n  while(i!=l||j!=r);\n  return res;\n}\npolygon convexCut(polygon A,P s,P t){ // counter-clockwise , left hand of st\n\tint n=sz(A);\n\tpolygon B;\n\trep(i,0,n){\n\t\tP u=A[i],v=A[(i+1)%n];\n\t\tint d1 = sgn((t-s)/(u-s)) , d2 = sgn((t-s)/(v-s));\n\t\tif(d1 >= 0) B.pb(u);\n\t\tif(d1 * d2 < 0) B.pb(insLL(L(u,v),L(s,t)));\n\t}\n\treturn B;\n}\nnamespace NearestPoints{\n  T solve(int l,int r,vector<P>&p){\n    if(l == r) return 1e100;\n    int m=(l+r)>>1;\n    T Xm = p[m].x , lim = min(solve(l,m,p) , solve(m+1,r,p));\n    inplace_merge(p.begin()+l,p.begin()+m+1,p.begin()+r+1,[&](P a,P b){return a.y<b.y;});\n    vector<P> V;\n    rep(i,l,r+1) if(fabs(p[i].x - Xm) <= lim) V.pb(p[i]);\n    rep(i,0,sz(V)) rep(j,i+1,sz(V)){\n      if(fabs(V[j].y - V[i].y) >= lim) break;\n      T dis = abs(V[i]-V[j]);\n      lim = min(lim,dis);\n    }\n    return lim;\n  }\n  T solve(vector<P> A){\n    sort(all(A),[&](P a,P b){return a.x<b.x;});\n    return solve(0,sz(A)-1,A);\n  }\n}\n\nint n;\nP p;\nvector<P> A;\n\nint main() {\n\tstd::ios::sync_with_stdio(0);\n\tstd::cin.tie(0);\n\t//\tfreopen(\"a.in\", \"r\", stdin);\n\t//\tfreopen(\"a.out\", \"w\", stdout);\n\tcout << setiosflags(ios::fixed);\n\tcout << setprecision(10);\n\tcin >> n;\n\trep(i, 0, n) {\n\t\tcin >> p.x >> p.y;\n\t\tA.pb(p);\n\t}\n\tcout << NearestPoints::solve(A) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <numeric>\n\nusing namespace std;\n\nusing point = pair<float, float>;\nusing vpoint = vector<point>;\n\ninline float distance(point &a, point &b) { return sqrt(pow(a.first - b.first, 2) + pow(a.second - b.second, 2)); }\nvoid splitX(vpoint &x, vpoint &xl, vpoint &xr);\n\nfloat closestSplit(vpoint &x, vpoint &y, float sigma)\n{\n    float xbar = x[x.size()/2].first, d = numeric_limits<float>::max();\n    vpoint sy;\n    for (uint32_t i = 0; i < y.size(); ++i)\n        if (abs(xbar - y[i].first) <= sigma)\n            sy.push_back(y[i]);\n    for (uint32_t i = 0; i < sy.size(); ++i)\n        for (uint32_t j = 1; j < 8 && i+j < sy.size(); ++j)\n            d = min(d, distance(sy[i], sy[i+j]));\n    return d;\n}\n\nfloat closestPairDistance(vpoint &x, vpoint &y)\n{\n    if (x.size() < 4)\n    {\n        float d = numeric_limits<float>::max();\n        for (uint32_t i = 0; i < x.size(); ++i)\n            for (uint32_t j = i+1; j < x.size(); ++j)\n                d = min(d, distance(x[i], x[j]));\n        return d;\n    }\n    vpoint xl, xr;\n    splitX(x, xl, xr);\n    float sigma = min(closestPairDistance(xl, y), closestPairDistance(xr, y));\n    return min(sigma, closestSplit(x, y, sigma));\n}\n\nint main()\n{\n    int n;\n    vpoint x, y;\n    scanf(\"%d\", &n);\n    x.resize(n);\n    y.resize(n);\n    for (int i = 0; i < n; ++i)\n    {\n        scanf(\"%f %f\", &x[i].first, &x[i].second);\n        y[i] = x[i];\n    }\n    sort(x.begin(), x.end(), [](point &a, point &b)\n    {\n        return a.first < b.first;\n    });\n    sort(y.begin(), y.end(), [](point &a, point &b)\n    {\n        return a.second < b.second;\n    });\n    cout << setprecision(8) << showpoint << fixed << closestPairDistance(x, y);\n}\n\nvoid splitX(vpoint &x, vpoint &xl, vpoint &xr)\n{\n    uint32_t size = x.size(), n = size/2, i;\n    xl.resize(n);\n    xr.resize(size - n);\n    for (i = 0; i < n; ++i)\n        xl[i] = x[i];\n    for (; i < size; ++i)\n        xr[i-n] = x[i];\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nstatic const double EPS=1e-12;\nstatic const double INF=1e24;\n\nusing Point=complex<double>;\nusing Plane=vector<Point>;\nusing Polygon=vector<Point>;\n\nbool operator<(const Point &a, const Point &b) {\n    return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n}\n\ndouble cross_prod(const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot_prod(const Point &a, const Point &b) {\n    return real(conj(a)*b);\n}\n\nenum {\n    ONLINE_FRONT=-2,\n    CLOCKWISE,\n    ON_SEGMENT,\n    COUNTER_CLOCKWISE,\n    ONLINE_BACK,\n};\n\nint ccwise(Point a, Point b, Point c) {\n    b -= a; c -= a;\n\n    if (cross_prod(b, c) > 0) {\n        return COUNTER_CLOCKWISE;\n    } else if (cross_prod(b, c) < 0) {\n        return CLOCKWISE;\n    } else if (dot_prod(b, c) < 0) {\n        return ONLINE_BACK;\n    } else if (norm(b) < norm(c)) {\n        return ONLINE_FRONT;\n    } else {\n        return ON_SEGMENT;\n    }\n}\n\ntemplate <class LineType>\nint ccwise(LineType l, Point p) {\n    return ccwise(l.first, l.second, p);\n}\n\nstruct Line: public pair<Point, Point> {\n    Line() {}\n    Line(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\nstruct LineSeg: public pair<Point, Point> {\n    LineSeg() {}\n    LineSeg(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\npair<Point, Point> closest_pair(Polygon g) {\n    size_t V=g.size(), s=0, t=1, m=2;\n    vector<size_t> S(V);\n    sort(g.begin(), g.end(), [](const Point &a, const Point &b) {\n        return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n    });\n\n    double res=abs(g[s]-g[t]);\n    for (size_t i=2; i<V; S[m++]=i++)\n        for (size_t j=0; j<m; ++j) {\n            if (res > abs(g[S[j]]-g[i]))\n                res = abs(g[s=S[j]]-g[t=i]);\n\n            if (real(g[S[j]]) < real(g[i]-res))\n                S[j--] = S[--m];\n        }\n\n    return make_pair(g[s], g[t]);\n}\n\ntemplate <class RandomIt>\npair<Point, Point> closest_pair(RandomIt first, RandomIt last) {\n    size_t n=last-first;\n    if (n < 2)\n        return make_pair(Point(-INF, -INF), Point(INF, INF));\n\n    RandomIt mid=first+n/2;\n    pair<Point, Point> p1=closest_pair(first, mid);\n    pair<Point, Point> p2=closest_pair(mid, last);\n    inplace_merge(first, mid, last, [](const Point &lhs, const Point &rhs) {\n        return imag(lhs) < imag(rhs);\n    });\n\n    double d1=abs(p1.first-p1.second), d2=abs(p2.first-p2.second);\n    double d=(d1<d2? d1:d2);\n    pair<Point, Point> res=(d1<d2? p1:p2);\n\n    double x=imag(*mid);\n    vector<Point> b;\n    for (RandomIt it=first; it<last; ++it) {\n        if (abs(real(*it)-x) >= d) continue;\n\n        for (size_t j=0; j<b.size(); ++j) {\n            double dx=real(*it)-real(b[b.size()-j-1]);\n            double dy=imag(*it)-imag(b[b.size()-j-1]);\n            if (dy >= d) break;\n\n            if (d > sqrt(dx*dx + dy*dy)) {\n                d = sqrt(dx*dx + dy*dy);\n                res = make_pair(*it, b[b.size()-j-1]);\n            }\n        }\n        b.push_back(*it);\n    }\n\n    return res;\n}\n\nint main() {\n    size_t n;\n    scanf(\"%zu\", &n);\n\n    Polygon g(n);\n    for (size_t i=0; i<n; ++i) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        g[i] = Point(x, y);\n    }\n\n    pair<Point, Point> p=closest_pair(g.begin(), g.end());\n    printf(\"%.16f\\n\", abs(p.first-p.second));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nconst int INF = INT_MAX / 3;\n\n#define REP(i,n) for(int i=0;i<(int)n;i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b) {\n\tif (abs(a + b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a + b;\n}\n\nstruct P {\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y) : x(x), y(y) {\n\t}\n\tP operator +(P p) {\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator -(P p) {\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator *(double d) {\n\t\treturn P(d*x, d*y);\n\t}\n\tdouble dot(P p) {\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det(P p) {\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\tvoid print() {\n\t\tprintf(\"%.10lf %.10lf \\n\", x, y);\n\t\treturn;\n\t}\n};\n\ndouble dist(P p1, P p2) {\n\tdouble dx = p1.x - p2.x;\n\tdouble dy = p1.y - p2.y;\n\treturn sqrt(dx*dx + dy*dy);\n}\n\nbool x_asc(const P& left, const P& right) {\n\treturn left.x < right.x;\n}\n\nbool y_asc(const P& left, const P& right) {\n\treturn left.y < right.y;\n}\n\nvoid merger(vector<P> &pointList, int start, int m, int end) {\n\tvector<P> tmp(end - start + 1);\n\tint i = start;\n\tint j = m + 1;\n\tfor (int k = 0; k<end - start + 1; k++) {\n\n\t\tif (i == m + 1) {\n\t\t\ttmp[k] = pointList[j];\n\t\t\tj++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (j == end + 1) {\n\t\t\ttmp[k] = pointList[i];\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pointList[i].y >= pointList[j].y) {\n\t\t\ttmp[k] = pointList[j];\n\t\t\tj++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pointList[i].y < pointList[j].y) {\n\t\t\ttmp[k] = pointList[i];\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tfor (int i = start; i<end + 1; i++) {\n\t\tpointList[i] = tmp[i-start];\n\t}\n}\n\ndouble closestPoint(vector<P> &pointList, int start, int end) {\n\tint n = end - start + 1;\n\tint m = (start+end) / 2;\n\tdouble center = pointList[m].x;\n\tdouble d;\n\tif (start == end) return INF;\n\td = min(closestPoint(pointList, start, m), closestPoint(pointList, m + 1, end));\n\tmerger(pointList, start, m, end);\n\n\tvector<P> rangeList;\n\tfor (int i = start; i<end + 1; i++) {\n\t\tif (fabs(pointList[i].x - center) >= d) continue;\n\n\t\tfor (int j = rangeList.size() - 1; j>-1; j--) {\n\t\t\tdouble dd = dist(rangeList[j], pointList[i]);\n\t\t\tif (pointList[i].y - rangeList[j].y > d) break;\n\t\t\td = min(d, dd);\n\t\t}\n\t\trangeList.push_back(pointList[i]);\n\n\t}\n\treturn d;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<P> pointList(n);\n\tREP(i, n) {\n\t\tscanf(\"%lf\", &pointList[i].x);\n\t\tscanf(\"%lf\", &pointList[i].y);\n\t}\n\n\tsort(ALL(pointList), x_asc);\n\n\tprintf(\"%.10lf \\n\", closestPoint(pointList, 0, pointList.size() - 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\n/*struct P\n{\n\tdouble x, y;\n\tP(double x,double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};*/\n\n/*int ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}*/\n\ndouble dist(pdd a, pdd b)\n{\n\treturn (a.first - b.first)*(a.first - b.first) + (a.second - b.second)*(a.second - b.second);\n}\n\ndouble ClosestPair(vector<pdd>& points,int l,int r)\n{\n\tif (r - l == 1)\n\t{\n\t\treturn INF;\n\t}\n\tif (r - l == 2)\n\t{\n\t\treturn dist(points[l], points[l + 1]);\n\t}\n\tif (r - l == 3)\n\t{\n\t\treturn min(min(dist(points[l], points[l + 1]), dist(points[l], points[l + 2])), dist(points[l + 1], points[l + 2]));\n\t}\n\n\tint m = (l + r) / 2;\n\tdouble d = min(ClosestPair(points, l, m), ClosestPair(points, m, r));\n\n\tvector<pdd> tempP;\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tif ((points[l].first - points[m].first)*(points[l].first - points[m].first) < d)\n\t\t{\n\t\t\ttempP.emplace_back(make_pair(points[i].second, points[i].first));\n\t\t}\n\t}\n\tsort(tempP.begin(), tempP.end());\n\tfor (int i = 0; i != tempP.size(); i++)\n\t{\n\t\tfor (int j = i + 1; j != tempP.size(); j++)\n\t\t{\n\t\t\tif ((tempP[j].first - tempP[i].first)*(tempP[j].first - tempP[i].first) > d)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, dist(tempP[i], tempP[j]));\n\t\t}\n\t}\n\n\treturn d;\n}\n\nvector<pdd> points;\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\t//scanf(\"%lf %lf\", &x, &y);\n\t\tpoints.push_back(make_pair(x, y));\n\t}\n\n\tsort(points.begin(), points.end());\n\n\tprintf(\"%lf\\n\", sqrt(ClosestPair(points, 0, n)));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<utility>\nusing namespace std;\ntypedef pair<double, double> P;\nstatic const int MAX_N = 100000;\nstatic const double INF = 100000.0;\n\nint N;\nP A[MAX_N];\n\nbool compare_y(P a, P b){\n\treturn a.second < b.second;\n}\n\ndouble closest_pair(P *a, int n){\n\tif(n <= 1) return INF;\n\tint m = n / 2;\n\tdouble x = a[m].first;\n\tdouble d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n\tinplace_merge(a, a + m, a + n, compare_y);\n\n\tvector<P> b;\n\tfor(int i = 0; i < n; i++){\n\t\tif(fabs(a[i].first - x) >= d) continue;\n\n\t\tfor(int j = 0; j < b.size(); j++){\n\t\t\tdouble dx = a[i].first - b[b.size() - j - 1].first;\n\t\t\tdouble dy = a[i].second - b[b.size() - j - 1].second;\n\t\t\tif(dy >= d) break;\n\t\t\td = min(d, sqrt(dx * dx + dy * dy));\n\t\t}\n\t\tb.push_back(a[i]);\n\t}\n\treturn d;\n}\n\nvoid solve(){\n\tsort(A, A + N);\n\tprintf(\"%f\\n\", closest_pair(A, N));\n}\n\nint main(){\n\tscanf(\"%d\", &N);\n\tfor(int i = 0; i < N; i++){\n\t\tdouble x, y;\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tA[i] = make_pair(x, y);\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<utility>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n\ntypedef pair<double, double> point;\n\ninline double dist(const point &a, const point &b)\n{\n\treturn sqrt((a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second));\n}\n\nint main()\n{\n\tint i, n;\n\tdouble x, y;\n\tscanf(\"%d\", &n);\n\tpoint *P;\n\tP = new point [n + 1];\n\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tP[i] = make_pair(x, y);\n\t}\n\tsort(P, P + n);\n\n\tdouble d = dist(P[0], P[1]);\n\tfor(i = 2; i < n; i++){\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tif(P[i].first - P[j].first > d) continue;\n\t\t\td = min(d, dist(P[i], P[j]));\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\", d);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <list>\n\nusing namespace std;\n\ntypedef pair<double, double> P;\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\nint N;\nP A[500001];\n\nbool compare_y(P a, P b){\n\treturn a.second < b.second;\n}\n\n// 最近２点間距離を求める\ndouble closest_pair(P *a, int n){\n\tif(n <= 1){\n\t\treturn INF;\n\t}\n\tint m = n / 2;\n\tdouble x = a[m].first;\n\tdouble d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n\tinplace_merge(a, a + m, a + n, compare_y);\n\t\n\tvector<P> b;\n\tfor(int i = 0; i < n; i++){\n\t\tif(fabs(a[i].first - x) >= d){\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j = 0; j < b.size(); j++){\n\t\t\tdouble dx = a[i].first - b[b.size() - j - 1].first;\n\t\t\tdouble dy = a[i].second - b[b.size() - j - 1].second;\n\t\t\tif(dy >= d){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, sqrt(dx * dx + dy * dy));\n\t\t}\n\t\tb.push_back(a[i]);\n\t}\n\treturn d;\n}\n\nint main(){\n\t\n\tcin >> N;\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> A[i].first >> A[i].second;\n\t}\n\t\n\tsort(A, A + N);\n\t\n\tprintf(\"%.10f\\n\", closest_pair(A, N));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <stdio.h>\nusing namespace std;\nconst int MAXN = 2e5 + 10;\nconst int inf = 1e9 + 10;\n\nstruct vec {\n    double x, y;\n    double p;\n    vec()\n    {\n    }\n    vec(double a, double b)\n    {\n        x = a, y = b;\n    }\n    bool operator>(const vec a) const\n    {\n        return x == a.x ? y > a.y : x > a.x;\n    }\n    vec operator-(const vec a) const\n    {\n        return vec(x - a.x, y - a.y);\n    }\n    vec operator+(const vec a) const\n    {\n        return vec(x + a.x, y + a.y);\n    }\n    bool operator<(const vec a) const\n    {\n        return x == a.x ? y < a.y : x < a.x;\n    }\n    friend ostream& operator<<(ostream& out, vec& a)\n    {\n        cout << a.x << ' ' << a.y;\n        return out;\n    }\n    friend istream& operator>>(istream& in, vec& a)\n    {\n        in >> a.x >> a.y;\n        return in;\n    }\n\n} p[MAXN];\nint n;\ndouble changdu(vec a)\n{\n    return sqrt(a.x * a.x + a.y * a.y);\n}\nbool cmp(vec a, vec b)\n{\n    return a.y < b.y;\n}\n\nvec temp[MAXN];\ndouble cdq(int l, int r)\n{\n    if (l == r)\n        return inf;\n    int mid = (l + r) >> 1;\n\n    double ans = cdq(l, mid);\n    ans = min(ans, cdq(mid + 1, r));\n\n    int tot = 0;\n    for (int i = l; i <= r; i++)\n        if (fabs(p[mid].x - p[i].x) <= ans)\n            temp[tot++] = p[i];\n\n    sort(temp,temp+tot, cmp);\n\n    for (int i = 0; i < tot; i++)\n        for (int j = i + 1; j <tot; j++) {\n            if (temp[j].y - temp[i].y > ans)\n                break;\n            ans = min(ans, changdu(temp[j] - temp[i]));\n        }\n    return ans;\n}\nint main()\n{\n    // freopen(\"txt.txt\", \"w\", stdout);\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> p[i];\n    sort(p + 1, p + n + 1);\n    double ans = cdq(1, n);\n    printf(\"%.8f\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i, a, b) for(int i = (a); i < (b); ++i)\n#define per(i, a, b) for(int i = (b) - 1; i >= (a); --i)\n#define sz(a) (int)a.size()\n#define de(c) cout << #c << \" = \" << c << endl\n#define dd(c) cout << #c << \" = \" << c << \" \"\n#define all(a) a.begin(), a.end()\n#define pw(x) (1ll<<(x))\n#define endl \"\\n\"\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\ntypedef db T;\nconst db eps = 1e-9 , pi = acosl(-1.);\nint sgn(T x){return (x>eps)-(x<-eps);}\nstruct P{\n  T x,y; P(){} P(T x,T y):x(x),y(y){}\n  P operator - (const P&b) const {return P(x-b.x,y-b.y);}\n  P operator + (const P&b) const {return P(x+b.x,y+b.y);}\n  T operator * (const P&b) const {return x*b.x+y*b.y;}\n  T operator / (const P&b) const {return x*b.y-y*b.x;}\n  P operator * (const T&k) const {return P(x*k,y*k);}\n  P operator / (const T&k) const {return P(x/k,y/k);}\n\tbool operator < (const P&b) const {return sgn(x-b.x)?x<b.x:y<b.y;}\n};\nT norm(P a){return a*a;}\nT abs(P a) {return sqrtl(norm(a));}\nP proj(P p,P a,P b){return (b-a)*((p-a)*(b-a)/norm(b-a))+a;}\nP reflect(P p,P a,P b){return proj(p,a,b)*2-p;}\nT cross(P o,P a,P b){return (a-o)/(b-o);}\nint crossOp(P o,P a,P b){return sgn(cross(o,a,b));}\nbool onPS(P p,P s,P t){return sgn((t-s)/(p-s))==0&&sgn((p-s)*(p-t))<=0;}\nstruct L{ P s,t;L(){} L(P s,P t):s(s),t(t){}};\nP insLL(L a,L b){ // line x line\n\tP s = a.s - b.s , v = a.t - a.s , w = b.t - b.s;\n\tdb k1 = s / w , k2 = w / v;\n\tif(sgn(k2) == 0) return abs(b.s - a.s) < abs(b.t - a.s) ? b.s : b.t;\n\treturn a.s + v * (k1 / k2);\n}\nbool isSS(L a,L b){ // seg x seg , replace x->y to accelerate\n\tT c1=(a.t-a.s)/(b.s-a.s),c2=(a.t-a.s)/(b.t-a.s);\n\tT c3=(b.t-b.s)/(a.s-b.s),c4=(b.t-b.s)/(a.t-b.s);\n\treturn sgn(c1) * sgn(c2) <= 0 && sgn(c3) * sgn(c4) <= 0 &&\n\t\tsgn(max(a.s.x,a.t.x) - min(b.s.x,b.t.x)) >= 0 &&\n\t\tsgn(max(b.s.x,b.t.x) - min(a.s.x,a.t.x)) >= 0 &&\n\t\tsgn(max(a.s.y,a.t.y) - min(b.s.y,b.t.y)) >= 0 &&\n\t\tsgn(max(b.s.y,b.t.y) - min(a.s.y,a.t.y)) >= 0;\n}\ndb disPL(P p,L a){return fabs((a.t-a.s)/(p-a.s)) / abs(a.t-a.s);}\ndb disPS(P p,L a){ // p x seg dis\n\tif(sgn((a.t-a.s)*(p-a.s)) == -1) return abs(p-a.s);\n\tif(sgn((a.s-a.t)*(p-a.t)) == -1) return abs(p-a.t);\n\treturn disPL(p,a);\n}\ndb disSS(L a,L b){ // seg x seg dis\n\tif(isSS(a,b)) return 0;\n\treturn min(min(disPS(a.s,b),disPS(a.t,b)),min(disPS(b.s,a),disPS(b.t,a)));\n}\ntypedef vector<P> polygon;\npolygon convex(polygon A){ // counter-clockwise , < : <=180 , <= : <180\n  int n=sz(A),m=0;\n  polygon B;B.resize(n<<1);\n  sort(all(A));\n  rep(i,0,n){\n    while(m > 1 && sgn((B[m-1]-B[m-2])/(A[i]-B[m-2]))<0) --m;\n    B[m++]=A[i];\n  }\n  int k = m;\n  per(i,0,n-1){\n    while(m > k && sgn((B[m-1]-B[m-2])/(A[i]-B[m-2]))<0) --m;\n    B[m++]=A[i];\n  }\n  B.resize(m);\n  if(sz(B) > 1) B.pop_back();\n  return B;\n}\nT area(polygon A) { // multiple 2 with integer type\n\tT res=0;\n\trep(i,0,sz(A)) res+=A[i]/(A[(i+1)%sz(A)]);\n\treturn fabs(res) / 2;\n}\nbool isconvex(polygon A){ // counter-clockwise\n\tbool ok=1;int n=sz(A);\n\trep(i,0,2) A.pb(A[i]);\n\trep(i,0,n) ok&=((A[i+1]-A[i])/(A[i+2]-A[i]))>=0;\n\treturn ok;\n}\nint inPpolygon(P p,polygon A){ // -1 : on , 0 : out , 1 : in\n\tint res=0;\n\trep(i,0,sz(A)){\n\t\tP u=A[i],v=A[(i+1)%sz(A)];\n\t\tif(onPS(p,u,v)) return -1;\n\t\tT cross = sgn((v-u)/(p-u)) , d1 = sgn(u.y-p.y) , d2 = sgn(v.y-p.y);\n\t\tif(cross > 0 && d1 <= 0 && d2 > 0) ++res;\n\t\tif(cross < 0 && d2 <= 0 && d1 > 0) --res;\n\t}\n\treturn res != 0;\n}\nT diameter(polygon A) { // longest distance\n  int n=sz(A);if(n <= 1) return 0;\n  int l=0,r=0;rep(i,1,n) (A[i]<A[l])&&(l=i),(A[r]<A[i])&&(r=i);\n  db res=abs(A[l]-A[r]);int i=l,j=r;\n  do (++((A[(i+1)%n]-A[i])/(A[(j+1)%n]-A[j])>=0?j:i))%=n,\n    res=max(res,abs(A[i]-A[j]));\n  while(i!=l||j!=r);\n  return res;\n}\npolygon convexCut(polygon A,P s,P t){ // counter-clockwise , left hand of st\n\tint n=sz(A);\n\tpolygon B;\n\trep(i,0,n){\n\t\tP u=A[i],v=A[(i+1)%n];\n\t\tint d1 = sgn((t-s)/(u-s)) , d2 = sgn((t-s)/(v-s));\n\t\tif(d1 >= 0) B.pb(u);\n\t\tif(d1 * d2 < 0) B.pb(insLL(L(u,v),L(s,t)));\n\t}\n\treturn B;\n}\nnamespace NearestPoints{\n  T solve(int l,int r,vector<P>&p){\n    if(l == r) return 1e100;\n    int m=(l+r)>>1;\n    T Xm = p[m].x , lim = min(solve(l,m,p) , solve(m+1,r,p));\n    inplace_merge(p.begin()+l,p.begin()+m+1,p.begin()+r+1,[&](P a,P b){return a.y<b.y;});\n    vector<P> V;\n    rep(i,l,r+1) if(fabs(p[i].x - Xm) <= lim) V.pb(p[i]);\n    rep(i,0,sz(V)) rep(j,i+1,sz(V)){\n      if(fabs(V[j].y - V[i].y) >= lim) break;\n      T dis = abs(V[i]-V[j]);\n      lim = min(lim,dis);\n    }\n    return lim;\n  }\n  T solve(vector<P> A){\n    sort(all(A),[&](P a,P b){return a.x<b.x;});\n    return solve(0,sz(A)-1,A);\n  }\n}\n\nint n;\nP p;\nvector<P> A;\n\nint main() {\n\tstd::ios::sync_with_stdio(0);\n\tstd::cin.tie(0);\n\t//\tfreopen(\"a.in\", \"r\", stdin);\n\t//\tfreopen(\"a.out\", \"w\", stdout);\n\tcout << setiosflags(ios::fixed);\n\tcout << setprecision(10);\n\tcin >> n;\n\trep(i, 0, n) {\n\t\tcin >> p.x >> p.y;\n\t\tA.pb(p);\n\t}\n\tcout << NearestPoints::solve(A) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Point {\n    double x, y;\n\n    Point() = default;\n    Point(double x, double y) : x(x), y(y) {}\n\n    Point operator+(const Point &rhs) const {\n        return Point(x + rhs.x, y + rhs.y);\n    }\n\n    Point operator-(const Point &rhs) const {\n        return Point(x - rhs.x, y - rhs.y);\n    }\n\n    double operator*(const Point &rhs) const {\n        return x * rhs.x + y * rhs.y;\n    }\n\n    double operator%(const Point &rhs) const {\n        return x * rhs.y - y * rhs.x;\n    }\n\n    bool operator<(const Point &rhs) const {\n        return x == rhs.x ? y < rhs.y : x < rhs.x;\n    }\n};\ndouble dis(const Point& a, const Point& b) {\n    return sqrt((a - b) * (a - b));\n}\n\nconst int maxn = 1e5 + 5;\nPoint p[maxn];\n\ndouble closest_pair(int l, int r) {\n    if (l == r) return 1e9;\n    if (r - l == 1) return dis(p[l], p[r]);\n    int m = (l + r) >> 1;\n    double d = min(closest_pair(l, m), closest_pair(m + 1, r));\n    vector<int> vec;\n    for (int i = m; i >= l && fabs(p[m].x - p[i].x) < d; --i) vec.push_back(i);\n    for (int i = m + 1; i <= r && fabs(p[m].x - p[i].x) < d; ++i) vec.push_back(i);\n    sort(vec.begin(), vec.end(), [&](int a, int b) { return p[a].y < p[b].y; });\n    for (int i = 0; i < vec.size(); ++i) {\n        for (int j = i + 1; j < vec.size() && fabs(p[vec[j]].y - p[vec[i]].y) < d; ++j) {\n            d = min(d, dis(p[vec[i]], p[vec[j]]));\n        }\n    }\n    return d;\n}\n\nint main() {\n    int n; scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) scanf(\"%lf%lf\", &p[i].x, &p[i].y);\n    sort(p, p + n);\n    printf(\"%.20lf\\n\", closest_pair(0, n - 1));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct node{\n  int dim;\n  vector<double>v;\n};\n\ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n\ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n\n  vector<node>res;\n\n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n\n    double dist=d(p,S)/(4*p.dim);\n\n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n\n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    \n    S=nextS;    \n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n  \n  return ans;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n\n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//closest pair\n#include <bits/stdc++.h>\nusing namespace std;\nconst int M=10000;\nconst double INF=1e9;\nint n;\nstruct Point{double x, y;};\nbool compareX(Point a,Point b){return a.x<b.x;}\nbool compareY(Point a,Point b){return a.y<b.y;}\ndouble dist(Point p1, Point p2)\n{return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y - p2.y)*(p1.y - p2.y));}\ndouble bruteForce(vector<Point> P, int n)\n{\n    double mn =INF;\n    for (int i = 0; i < n; ++i)\n        for (int j = i+1; j < n; ++j)\n            if (dist(P[i], P[j]) < mn)\n                mn = dist(P[i], P[j]);\n    return mn;\n}\ndouble stripClosest(vector<Point> strip, int size, double d)\n{\n    double mn = d;\n    for (int i = 0; i < size; ++i)\n        for (int j = i+1; j < size && (strip[j].y - strip[i].y) < mn; ++j)\n            if (dist(strip[i],strip[j]) < mn)\n                mn = dist(strip[i], strip[j]);\n    return mn;\n}\ndouble closestUtil(vector<Point> Px,vector<Point> Py, int n)\n{\n    if (n <= 3)\n        return bruteForce(Px, n);\n    int mid = n/2;\n    Point midPoint = Px[mid];\n    vector <Point> Pyl(mid+1);   // y sorted points on left of vertical line\n    vector <Point> Pyr(n-mid-1);  // y sorted points on right of vertical line\n    int li = 0, ri = 0;  // indexes of left and right subarrays\n    for (int i = 0; i < n; i++)\n    {\n\t\tif (Py[i].x <= midPoint.x)\n\t\t\tPyl[li++] = Py[i];\n\t\telse\n\t\t\tPyr[ri++] = Py[i];\n    }\n\tvector<Point>v;\n\tfor(int i=0;i<mid;i++)\n\t\tv.push_back(Px[i]);\n    double dl = closestUtil(Px, Pyl, mid);\n    double dr = closestUtil(v, Pyr, n-mid);\n    double d = min(dl, dr);\n    vector<Point> strip(n);\n    int j = 0;\n    for (int i = 0; i < n; i++)\n        if (abs(Py[i].x - midPoint.x) < d)\n            strip[j] = Py[i], j++;\n    return min(d, stripClosest(strip, j, d) );\n}\ndouble closest(vector <Point> P, int n)\n{\n    vector<Point> Px(n),Py(n);\n    for (int i = 0; i < n; i++)\n    {\n        Px[i] = P[i];\n        Py[i] = P[i];\n    }\n    sort(Px.begin(),Px.end(), compareX);\n    sort(Py.begin(),Py.end(), compareY);\n    return closestUtil(Px, Py, n);\n}\nint main()\n{\n\tcin>>n;\n    vector<Point> P(M);\n    for(int i=0;i<n;i++)\n\t\tcin>>P[i].x>>P[i].y;\n    cout << fixed<<setprecision(6)<<closest(P, n);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n \n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nusing namespace std;\ntypedef double number;\n \nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<number> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n \ntypedef vector<P> G;\n \nnumber closestPair(G &p) {\n  int n = p.size(), s = 0, t = 1, m = 2, S[n]; S[0] = 0, S[1] = 1;\n  sort(ALL(p)); // \"p < q\" <=> \"p.x < q.x\"\n  double d = norm(p[s]-p[t]);\n  for (int i = 2; i < n; S[m++] = i++) REP(j, m) {\n    if (norm(p[S[j]]-p[i])<d) d = norm(p[s = S[j]]-p[t = i]);\n    if (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n  }\n  return norm(p[s]-p[t]);//make_pair( p[s], p[t] );\n}\n \nint main(){\n    G poly;\n    P p;\n    int n;\n    double x,y;\n    for(scanf(\"%d\",&n);n--;poly.push_back(p))scanf(\"%lf%lf\",&x,&y),p=P(x,y);\n    printf(\"%.9f\\n\",closestPair(poly));\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<vector<double>>data;\n\tvector<pair<double,double>>data2;\n\tdata2.resize(N);\n\tdata.resize(N);\n\tdouble a, b;\n\tpair<int, double>d[5][2] = {};\n\tfor (size_t i = 0; i < 5; i++)\n\t{\n\t\tfor (size_t j = 0; j <2; j++)\n\t\t{\n\t\t\td[i][j].second = 100000.0;\n\t\t}\n\t}\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tdata[i].resize(5);\n\t\tcin >> a >> b;\n\t\tdata2[i].first = a;\n\t\tdata2[i].second = b;\n\t\tdata[i][0] = (100.0 - a)*(100.0 - a) + (100.0 - b)*(100.0 - b);\n\t\tif (d[0][1].second > data[i][0])\n\t\t{\n\t\t\td[0][1].second = data[i][0];\n\t\t\td[0][1].first = i;\n\t\t\tif (d[0][0].second > d[0][1].second)\n\t\t\t{\n\t\t\t\tswap(d[0][0], d[0][1]);\n\t\t\t}\n\t\t}\n\t\tdata[i][1] = (100.0 + a)*(100.0 + a) + (100.0 - b)*(100.0 - b);\n\t\tif (d[1][1].second > data[i][1])\n\t\t{\n\t\t\td[1][1].second = data[i][1];\n\t\t\td[1][1].first = i;\n\t\t\tif (d[1][0].second > d[1][1].second)\n\t\t\t{\n\t\t\t\tswap(d[1][0], d[1][1]);\n\t\t\t}\n\t\t}\n\t\tdata[i][2] = (100.0 - a)*(100.0 - a) + (100.0 + b)*(100.0 + b);\n\t\tif (d[2][1].second > data[i][2])\n\t\t{\n\t\t\td[2][1].second = data[i][2];\n\t\t\td[2][1].first = i;\n\t\t\tif (d[2][0].second > d[2][1].second)\n\t\t\t{\n\t\t\t\tswap(d[2][0], d[2][1]);\n\t\t\t}\n\t\t}\n\t\tdata[i][3] = (100.0 + a)*(100.0 + a) + (100.0 + b)*(100.0 + b);\n\t\tif (d[3][1].second > data[i][3])\n\t\t{\n\t\t\td[3][1].second = data[i][3];\n\t\t\td[3][1].first = i;\n\t\t\tif (d[3][0].second > d[3][1].second)\n\t\t\t{\n\t\t\t\tswap(d[3][0], d[3][1]);\n\t\t\t}\n\t\t}\n\t\tdata[i][4] = a*a+b*b;\n\t\tif (d[4][1].second > data[i][4])\n\t\t{\n\t\t\td[4][1].second = data[i][4];\n\t\t\td[4][1].first = i;\n\t\t\tif (d[4][0].second > d[4][1].second)\n\t\t\t{\n\t\t\t\tswap(d[4][0], d[4][1]);\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans = 100000.0;\n\tfor (size_t i = 0; i < 5; i++)\n\t{\n\t\tint h = d[i][0].first;\n\t\tint g = d[i][1].first;\n\t\tans = min(ans, ((data2[h].first - data2[g].first)*(data2[h].first - data2[g].first) + (data2[h].second - data2[g].second)*(data2[h].second - data2[g].second)));\n\t}\n\n\tcout << fixed << setprecision(8)<<sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define all(a) a.begin(),a.end()\n\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\nconst double INF = 1e9;\n\nbool compX(const Point a, const Point b) {\n    return a.X<b.X;\n}\n\nbool compY(const Point a, const Point b) {\n    return a.Y<b.Y;\n}\n\ndouble closestPair(VP &a,int l,int r) {\n    if(r-l<=1) return INF;\n    int m = (l+r)/2;\n    double d = min(closestPair(a,l,m),closestPair(a,m,r));\n    inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,compY);\n    \n    VP b;\n    for(int i=l;i<r;i++){\n        if(abs(a[i].X-a[m].X)>=d)continue;\n        for(int j=b.size()-1;j>=0;j--){\n            if((a[i]-b[j]).Y>=d)break;\n            d = min(d,abs(a[i]-b[j]));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main(void){\n    int n;\n    cin>>n;\n    VP ps(n);\n    rep(i,n){\n        double x,y;\n        cin>>x>>y;\n        ps[i] = Point(x,y);\n    }\n    sort(all(ps),compX);\n    printf(\"%.9f\\n\",closestPair(ps,0,n));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <climits>\nusing namespace std;\n\ntypedef pair<double, double> P;\n\nbool inRange(double v, double l, double r){\n    return l<=v && v<=l;\n}\n\nbool compare_y(P a, P b){\n    return a.second < b.second;\n}\n\ndouble getClosestPair(vector<P> &v, int s, int t){\n    if(t-s<=1) return INT_MAX;\n    const double mid = v[(s+t)/2].first;\n    const double d1 = getClosestPair(v, s, (s+t)/2);\n    const double d2 = getClosestPair(v, (s+t)/2, t);\n    double d = min(d1, d2);\n    inplace_merge(v.begin()+s, v.begin()+(s+t)/2, v.begin()+t, compare_y);\n    vector<P> use;\n    for(int i=s; i<t; i++){\n        if(fabs(v[i].first-mid)>d) continue;\n        for(int j=use.size()-1; j>=0; j--){\n            if(fabs(v[i].second-use[j].second)>d) break;\n            double dx = v[i].first-use[j].first;\n            double dy = v[i].second-use[j].second;\n            d = min(d, sqrt(dx*dx + dy*dy));\n        }\n        use.push_back(v[i]);\n    }\n    return d;\n}\n\nint main(){\n    int n;\n    double x, y;\n    cin >> n;\n    vector<P> v;\n    for(int i=0; i<n; i++){\n        P p;\n        cin >> p.first >> p.second;\n        v.push_back(p);\n    }\n    sort(v.begin(), v.end());\n    printf(\"%f\\n\",getClosestPair(v, 0, v.size()));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\n\nint main(void)\n{\n    double dis=1000.0,temp;\n    int n;\n    double x[1000],y[1000];\n\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>x[i]>>y[i];\n    \n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            if(i!=j)\n            {\n               temp = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n               if(dis>temp)\n                    dis=temp;\n            }\n        }\n    }\n\n    printf(\"%.8lf\\n\",dis);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = min(abs(data[i + 1].second - data[i].second), ans + 0.00018);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&memo >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans =(min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tmemo = min(memo, ans + 0.00018);\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/50))  \n #define Fun2(j,n) for(int j=i+(int)(n/50);j<n;j=j+(int)(n/50))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=500;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16????????????????????¢???10??????????????§?????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n double dx,dy;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   //?°?16????????????????????????????????? \n   minx=minx-1;\n   miny=miny-1;\n   maxx=maxx+1;\n   maxy=maxy+1;\n   dx=1.0/4*(maxx-minx);\n   dy=1.0/4*(maxy-miny);\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=3;j>=0;j--)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*(3-j)+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n   /*\n   for(int i=0;i<16;i++)\n   {\n     for(int j=0;j<num_point[i];j++)\n     {\n       cout<<wu[i][j].x<<\" \"<<wu[i][j].y<<endl;        \n     }        \n   }\n   */\n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n //?????¢????????????????????????????§???????????????¢?????? \n void circle_optimize(double center)\n {\n      \n }\n \n void triangle_optimize()\n {\n      \n }\n \n void rectangle_optimize()\n {\n      \n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       //real_min=(point[0].x-point[1].x)*(point[0].x-point[1].x)+(point[0].y-point[1].y)*(point[0].y-point[1].y);\n       real_min=fun_min;\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         bool flag1,flag2,flag3,flag4,judge; \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {      \n             //???????????????????????¬???????????????????????¨?????????????????????????¬????????°????????????????????????????????????????????°???????????????°?????¨ \n             double theta=sqrt(real_min)/2;\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               flag1=flag2=flag3=flag4=false;\n               judge=false;\n               if(point[i].x>=(minx+(n+1)*dx-theta)) flag1=true;\n               if(point[i].x<=(minx+(n+1)*dx)) flag2=true;\n               if(point[i].y>=(miny+(3-m)*dy)) flag3=true;\n               if(point[i].y<=(miny+(4-m)*dy)) flag4=true;\n               judge=flag1&&flag2&&flag3&&flag4;\n               if(!judge) continue;\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 flag1=flag2=flag3=flag4=false;\n                 judge=false;\n                 if(point[j].x>=(minx+(n+1)*dx)) flag1=true;\n                 if(point[j].x<=(minx+(n+1)*dx+theta)) flag2=true;\n                 if(point[j].y>=(miny+(3-m)*dy)) flag3=true;\n                 if(point[j].y<=(miny+(4-m)*dy)) flag4=true;\n                 judge=flag1&&flag2&&flag3&&flag4;\n                 if(!judge) continue;\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             double theta=sqrt(real_min)/2;\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               flag1=flag2=flag3=flag4=false;\n               judge=false;\n               if(point[i].x>=(minx+n*dx)) flag1=true;\n               if(point[i].x<=(minx+(n+1)*dx)) flag2=true;\n               if(point[i].y>=(miny+(3-m)*dy)) flag3=true;\n               if(point[i].y<=(miny+(3-m)*dy+theta)) flag4=true;\n               judge=flag1&&flag2&&flag3&&flag4;\n               if(!judge) continue;\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 flag1=flag2=flag3=flag4=false;\n                 judge=false;\n                 if(point[j].x>=(minx+n*dx)) flag1=true;\n                 if(point[j].x<=(minx+(n+1)*dx)) flag2=true;\n                 if(point[j].y>=(miny+(3-m)*dy-theta)) flag3=true;\n                 if(point[j].y<=(miny+(3-m)*dy)) flag4=true;\n                 judge=flag1&&flag2&&flag3&&flag4;\n                 if(!judge) continue;\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n  "
  },
  {
    "language": "C++",
    "code": "// http://ir5.hatenablog.com/entry/20131221/1387557630\n#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define int long long\ntypedef pair<double, double> P;\ntypedef pair<int, int> IP;\ndouble norm(P a, P b) {\n  double x = a.first - b.first;\n  double y = a.second - b.second;\n  return sqrt(x*x + y*y);\n}\nsigned main() {\n  int N; cin >> N;\n  vector<P> p(N);\n  REP(i,N) {\n    double x, y; cin >> x >> y;\n    p[i] = make_pair(x, y);\n  }\n  double xmin = p[0].first, ymin = p[0].second;\n  REP(i,N) {\n    xmin = min(xmin, p[i].first);\n    ymin = min(ymin, p[i].second);\n  }\n  REP(i,N) {\n    p[i].first -= xmin;\n    p[i].second -= ymin;\n  }\n  // std::rand is often used.\n  random_shuffle(p.begin(), p.end());\n  double delta = norm(p[0], p[1]);\n  map<IP, vector<P>> S;\n  S[IP(p[0].first / delta, p[0].second / delta)].push_back(p[0]);\n  S[IP(p[1].first / delta, p[1].second / delta)].push_back(p[1]);\n  for(int i = 2; i < N; ++i) {\n    IP ip(p[i].first / delta, p[i].second / delta);\n    bool update = false;\n    for(int dx = -1; dx <= 1; ++dx) for(int dy = -1; dy <= 1; ++dy) {\n      for(P q : S[IP(ip.first + dx, ip.second + dy)]) {\n        double d2 = norm(p[i], q);\n        if(delta > d2) {\n          delta = d2;\n          update = true;\n        }\n      }\n    }\n    if(update) {\n      S.clear();\n      for(int j = 0; j <= i; ++j) {\n        S[IP(p[j].first / delta, p[j].second / delta)].push_back(p[j]);\n      }\n    }\n    else {\n      S[ip].push_back(p[i]);\n    }\n  }\n  cout.setf(ios::fixed);\n  cout.precision(6);\n  cout << delta << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<utility>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n\ntypedef pair<double, double> point;\ntypedef vector<point> data;\n\ninline double dist(const point &a, const point &b)\n{\n\tdouble dx = a.first - b.first, dy = a.second - b.second;\n\treturn sqrt(dx * dx + dy * dy);\n}\n\nint main()\n{\n\tint i, n;\n\tdouble x, y;\n\tscanf(\"%d\", &n);\n\tdata P(n);\n\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tP[i] = make_pair(x, y);\n\t}\n\tsort(P.begin(), P.end());\n\n\tdouble d = dist(P[0], P[1]);\n\tfor(i = 2; i < n; i++){\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tif(P[i].first - P[j].first > d) continue;\n\t\t\td = min(d, dist(P[i], P[j]));\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\", d);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nPoint input_point() {ld x, y; cin >> x >> y; return Point(x, y);} // ????????\\???\nbool eq(ld a, ld b) {return (abs(a - b) < eps);} // ????????????????????????\nld dot(Point a, Point b) {return real(conj(a) * b);} // ??????\nld cross(Point a, Point b) {return imag(conj(a) * b);} // ??????\n\n// ??´????????????\nclass Line {\npublic:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n    Point operator[](const int _num) {\n        if (_num == 0)return a;\n        else if (_num == 1)return b;\n        else assert(false);\n    }\n};\n\n// ????????????\nclass Circle {\npublic:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n\ntypedef vector<Point> Polygon;\n/* ????????\\?????? */\nld ClosestPair(int l, int r,const Polygon& poly){\n    if(r-l == 1) return abs(poly[l]-poly[l+1]);\n    if(r-l == 2) return min({abs(poly[l] - poly[l+1]),abs(poly[l] - poly[l+2]),abs(poly[l+1]-poly[l+2])});\n    \n    int m = l + (r-l)/2;\n    // ????????±??????\n    ld d = min(ClosestPair(l, m, poly),ClosestPair(m+1, r, poly));\n    \n    Polygon v;\n    for(int i = l; i <= r;i++){\n        if(abs(poly[i].real() - poly[m].real())< d){\n            v.emplace_back(Point(poly[i].imag(),poly[i].real()));\n        }\n    }\n    sort(v.begin(),v.end());\n    for(int i = 0; i < (int)v.size();i++){\n        for(int j = i + 1; j < (int)v.size();j++){\n            if(abs(v[i].real() - v[j].real()) > d)break;\n            d = min(d,abs(v[i]-v[j]));\n        }\n    }\n    return d;\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int n ;cin >> n;\n    Polygon ps;\n    for(int i = 0;i < n;i++) ps.emplace_back(input_point());\n    cout << fixed << setprecision(10) << ClosestPair(0, (int)ps.size()-1, ps) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <random>\n#include <unordered_map>\n\nusing namespace std;\n\nstruct Point{\n    double x,y;\n    Point* next;\n};\n\nuint64_t toKey(int x, int y){\n    union Key{\n        uint64_t key;\n        int x[2];\n    };\n    Key K;\n    K.x[0]=x, K.x[1]=y;\n    return K.key;\n}\n\nvoid build(unordered_map<uint64_t, Point*>& Grid, double d, int i, Point *P){\n    Grid.clear();\n    for(int j=0;j<=i;j++){\n        int x=floor(P[j].x/d),y=floor(P[j].y/d);\n        uint64_t key = toKey(x,y);\n        if(Grid.count(key)!=0){\n            P[j].next=Grid[key];\n        }\n        Grid[key]=&P[j];\n    }\n}\n\ndouble distance(Point& a, Point &b){\n    return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\ndouble search(unordered_map<uint64_t, Point*>& Grid, double d, Point& P){\n    int x=floor(P.x/d),y=floor(P.y/d);\n    uint64_t key;\n    double minimum=1e10;\n    for(int dx=-1;dx<2;dx++){\n        for(int dy=-1;dy<2;dy++){\n            key=toKey(x+dx,y+dy);\n            if(Grid.count(key)){\n                Point *p=Grid[key];\n                while(p!=NULL){\n                    if(minimum>distance(*p,P)) minimum=distance(*p,P);\n                    p=p->next;\n                }\n            }\n        }\n    }\n    return minimum;\n}\n\nvoid insert(unordered_map<uint64_t, Point*>& Grid, double d, Point& P){\n    int x=floor(P.x/d),y=floor(P.y/d);\n    uint64_t key = toKey(x,y);\n    if(Grid.count(key)!=0){\n        P.next=Grid[key];\n    }\n    Grid[key]=&P;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    Point P[n];\n    for(int i=0;i<n;i++){\n        cin >> P[i].x >> P[i].y;\n        P[i].next=NULL;\n    }\n    //??????????????£???????????????\n    random_device rd;\n    mt19937 mt(rd());//?????????????????§?????????????????????????????????\n    uniform_int_distribution<int> dist(0,n-1);\n    for(int i=0;i<n;i++){\n        int j = dist(mt);\n        Point p = P[i];\n        P[i]=P[j];\n        P[j]=p;\n    }\n    unordered_map<uint64_t, Point*> Grid;\n    double delta=distance(P[0],P[1]);\n    build(Grid,delta,1,P);\n    for(int i=2;i<n;i++){\n        double d2=search(Grid,delta,P[i]);\n        if(d2>delta){\n            insert(Grid,delta,P[i]);\n        }else{\n            delta=d2;\n            build(Grid,delta,i,P);\n        }\n    }\n    cout.precision(6);\n    cout << fixed;\n    cout << delta << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<utility>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n\ntypedef pair<double, double> point;\ntypedef point* data;\n\ninline double dist(const point &a, const point &b)\n{\n    double dx = a.first - b.first, dy = a.second - b.second;\n    return sqrt(dx * dx + dy * dy);\n}\n\nbool sort_y(const point &P1, const point &P2){ return P1.second < P2.second; }\n\ndouble closest(data P, int n)\n{\n    if(n <= 1) return 1000;\n    if(n == 2) return dist(P[0], P[1]);\n    int m = n / 2;\n    sort(P, P + n, sort_y); // y_sort, down to up.\n\tdouble median = P[m].second;\n    double d = min(closest(P, m), closest(P + m, n - m));\n\n    sort(P, P + n);\n    vector<point> V;\n\t\n    int i, k, a = 0, size = 0;\n    for(i = 0; i < n; i++){\n        if(fabs(P[i].second - median) > d) continue;\n        V.push_back(P[i]);\n        size++;\n        for(k = a; k < size - 1; k++){\n            if(V[size - 1].first - P[k].first > d){ a++; }\n            else{\n                d = min(d, dist(V[size - 1], P[k]));\n            }\n        }\n    }\n    return d;\n}\n\nint main()\n{\n\tint i, n;\n\tdouble x, y;\n\tscanf(\"%d\", &n);\n\tdata P;\n\tP = new point [n];\n\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tP[i] = make_pair(x, y);\n\t}\n\tprintf(\"%.12f\\n\", closest(P, n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b) {\n\treturn std::hypot(b.first - a.first, b.second - a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points) {\n\tif (points.size() < 2) {\n\t\treturn -1;\n\t}\n\tauto minDistance = std::abs(distance_between(points.at(0), points.at(1)));\n\tfor (auto i = std::begin(points); i != (std::end(points) - 1); ++i) {\n\t\tfor (auto j = i + 1; j < std::end(points); ++j) {\n\t\t\tauto newDistance = std::abs(distance_between(*i, *j));\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(const std::vector<point_t>& xP,\n\tconst std::vector<point_t>& yP) {\n\tif (xP.size() <= 3) {\n\t\treturn find_closest_brute(xP);\n\t}\n\tauto N = xP.size();\n\tauto xL = std::vector<point_t>();\n\tauto xR = std::vector<point_t>();\n\tstd::copy(std::begin(xP), std::begin(xP) + (N / 2), std::back_inserter(xL));\n\tstd::copy(std::begin(xP) + (N / 2), std::end(xP), std::back_inserter(xR));\n\tauto xM = xP.at(N / 2).first;\n\tauto yL = std::vector<point_t>();\n\tauto yR = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {\n\t\treturn p.first <= xM;\n\t});\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {\n\t\treturn p.first > xM;\n\t});\n\tauto p1 = find_closest_optimized(xL, yL);\n\tauto p2 = find_closest_optimized(xR, yR);\n\tauto minD = (p1 <= p2) ? p1 : p2;\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = std::abs(distance_between(*k, *i));\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP, yP);\n\tprintf(\"%.9f\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\nusing R=long double;\nconst R EPS = 1E-11; //[-1000:1000]->EPS=1e-8\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std {\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline R dat(P o,P a,P b){a-=o,b-=o; return imag(a*b);}\n\ninline P vec(L l){return l.t-l.s;}\n\n// ?°???± verify AOJ CGL_1_A\nP proj(P o,P a,P b){ a-=o,b-=o; return a*real(b/a);}\nP proj(L l,P p){ return l.s+proj(l.s,l.t,p);}\n// ????°? verify AOJ CGL_1_B\nP refl(L l,P p){ return R(2.0)*proj(l,p)-p;}\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,vec(a),vec(b)))==0;}\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\n// ????????´????????? \nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool ill(L a,L b){ return parallel(a,b)==false;}\nbool ils(L l,L s,int end=0){ return sgn(det(l.s,l.t,s.s)*det(l.s,l.t,s.t))<=-end;}\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ?????¢ verify AOJ CGL_2_D\nR dlp(L l,P p){return abs(det(l.s,l.t,p))/abs(vec(l));}\nR dsp(L s,P p){\n\tif(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n\tif(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n\treturn dlp(s,p);\n}\nR dll(L a,L b){return ill(a,b)?0:dlp(a,b.s);}\nR dls(L l,L s){return ils(l,s)?0:min(dlp(l,s.s),dlp(l,s.t));}\nR dss(L a,L b){return iss(a,b)?0:min({dsp(a,b.s),dsp(a,b.t),dsp(b,a.s),dsp(b,a.t)});}\n\n// ????§???¢\n// ??¢??? Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// ???????§???¢????????? verify CGL_3_B\nbool is_convex(const VP& pol){\n\tint n=pol.size();\n\trep(i,n)if(ccw(pol[(i+n-1)%n],pol[i],pol[(i+1)%n])==RIGHT) return false;\n\treturn true;\n}\n\n// ????§???¢??????????????? ?????? 2 ?????? 1 ???????????? 0???(???????§???¢??????) verify AOJ CGL_3-C\nint in_polygon(const VP& pol, const P& p){\n\tint n=pol.size(),res=0;\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+1)%n],p)==ON) return 1;\n\t\tbool f=sgn(imag(p-pol[i]))>=0;\n\t\tbool s=sgn(imag(p-pol[(i+1)%n]))<0;\n\t\tint sign=sgn(imag(pol[(i+1)%n]-pol[i]));\n\t\tbool can=sgn(sign*det(pol[i],pol[(i+1)%n],p))>0; // (a*d-b*c)*b\n\t\tif(can&&f==s) res+=(2*f-1);\n\t}\n\treturn res?2:0;\n}\n\n// ????§???¢??????????????????(???????§???¢??????) Verify AOJ 2514\nbool in_polygon(const VP& pol, const L& l){\n\tVP check{l.s,l.t};\n\tint n=pol.size();\n\trep(i,n){\n\t\tL edge={pol[i],pol[(i+1)%n]};\n\t\tif(iss(l,edge)) check.push_back(cross(l,edge));\n\t}\n\tsort(_all(check));\n\tn=check.size();\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/R(2.0);\n\t\tif(in_polygon(pol,m)==false) return false;\n\t}\n\treturn true;\n}\n\n// convex_hull Verify AOJ CGL_4_A ?????????????????????????????´??????1,??????????????´??????0\nVP convex_hull(VP pol,int edge=0){\n\tint n=pol.size(),k=0;\n\tsort(_all(pol));\n\tVP res(2*n);\n\n\t//??\\??????while????????????????????? ???????????????????????????????????? >=0 ????????????>=1\n\t// down\n\trep(i,n){\n\t\twhile(k>1&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tint t=k;\n\trrep(i,n-1){\n\t\twhile(k>t&&sgn(det(O,res[k-1]-res[k-2],pol[i]-res[k-1]))>=edge) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n// farthest point pair Verify AOJ CGL_4_B\nR fpp(VP pol){\n\n\treturn 0.0;\n}\n\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT)res.push_back(a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) res.push_back(cross({a,b},l));\n\t}\n\treturn res;\n}\n\n// closest point pair Verify AOJ CGL_5_A\nR cpp(VP a,int flag=1){\n\tif(flag) sort(_all(a));\n\tint n=a.size(),m=n/2;\n\tif(n<=1) return INF;\n\tVP b(begin(a),begin(a)+m),c(begin(a)+m,end(a)),e;\n\tR x=real(a[m]),d=min(cpp(b,0),cpp(c,0));\n\tsort(_all(a),[](const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;});\n\trep(i,n){\n\t\tif(abs(real(a[i])-x)>=d) continue;\t\n\t\trep(j,e.size()){\n\t\t\tif(imag(a[i]-e[e.size()-1-j])>=d) break;\n\t\t\td=min(d,abs(a[i]-e[e.size()-1-j]));\n\t\t}\n\t\te.push_back(a[i]);\n\t}\n\treturn d;\n}\n\n// ???\n// Verify AOJ 1183\nenum RCC{IN=1,ON_IN=2,ISC=4,ON_OUT=8,OUT=16,ONS=10};\nint rcc(C a,C b){\n\tR d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) return OUT;\n\tif(a.r+b.r==d) return ON_OUT;\n\tif(abs(a.r-b.r)<d) return ISC;\n\tif(abs(a.r-b.r)==d) return ON_IN;\n\treturn IN;\n}\n\n// ?????¢??£???????????????\nbool icp(C c,P p,int end=0){return sgn(abs(p-c.c)-c.r)<=-end;}\nbool ics(C c,L l,int end=0){return sgn(dsp(l,c.c)-c.r)<=-end;}\nbool icsc(C c,L l){return ics(c,l) && sgn(max(abs(l.s-c.c),abs(l.t-c.c))-c.r)<=0;}\n\n//?????¨??´????????????\n// Verify AOJ CGL_7_D\nVP pcl(C c, L l) {\n\tP h=proj(l,c.c);\n\tP e=(l.t-l.s)/abs(l.t-l.s)*sq(norm(c.r)-norm(h-c.c));\n\treturn VP{h-e,h+e};\n}\n//2??????????????????\n// Verify AOJ CGL_7_E\nVP pcc(C a,C b){\n\tP d=b.c-a.c;\n\tP w=(norm(d)+norm(a.r)-norm(b.r))/(2.0*norm(d))*d;\n\tP e=w*P(0,1);\n\treturn pcl(a,{a.c+w-e,a.c+w+e}); \n}\n\n// ????????\\???\n// Verify AOJ 2001\nL tangent(C c,R t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L{p-d,p+d};\n}\n\n// ????????±?????\\???\n// Verify AOJ 2001\nVL common_tangent(C a,C b){\n\tVL res;\n\tR d=arg(b.c-a.c),i=acos((a.r+b.r)/abs(b.c-a.c)),o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rcc(a,b);\n\t//??±????????\\???\n\tif(r==OUT){\n\t\tres.push_back(tangent(a,d+i));\n\t\tres.push_back(tangent(a,d-i));\n\t}\n\t// ??±????????\\???\n\tif(r>=ISC){\n\t\tres.push_back(tangent(a,d+o));\n\t\tres.push_back(tangent(a,d-o));\n\t}\n\t//??\\????????±???????????\\???\n\tif(r&ONS) res.push_back(tangent(a,d));\n\treturn res;\n}\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\tVP pol;\n\trep(i,n){\n\t\tP p;\n\t\tcin >> p;\n\t\tpol.push_back(p);\n\t}\n\tcout.precision(20);\n\tcout << fixed << cpp(pol) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://ir5.hatenablog.com/entry/20131221/1387557630\n#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\ntypedef pair<double, double> P;\ntypedef pair<int, int> IP;\ndouble norm(P a, P b) {\n  double x = a.first - b.first;\n  double y = a.second - b.second;\n  return sqrt(x*x + y*y);\n}\nint main() {\n  int N; cin >> N;\n  vector<P> p(N);\n  REP(i,N) {\n    double x, y; cin >> x >> y;\n    p[i] = make_pair(x, y);\n  }\n  double xmin = p[0].first, ymin = p[0].second;\n  REP(i,N) {\n    xmin = min(xmin, p[i].first);\n    ymin = min(ymin, p[i].second);\n  }\n  REP(i,N) {\n    p[i].first -= xmin;\n    p[i].second -= ymin;\n  }\n  // std::rand is often used.\n  random_shuffle(p.begin(), p.end());\n  double delta = norm(p[0], p[1]);\n  map<IP, vector<P>> S;\n  S[IP(p[0].first / delta, p[0].second / delta)].push_back(p[0]);\n  S[IP(p[1].first / delta, p[1].second / delta)].push_back(p[1]);\n  for(int i = 2; i < N; ++i) {\n    IP ip(p[i].first / delta, p[i].second / delta);\n    bool update = false;\n    for(int dx = -1; dx <= 1; ++dx) for(int dy = -1; dy <= 1; ++dy) {\n      for(P q : S[IP(ip.first + dx, ip.second + dy)]) {\n        double d2 = norm(p[i], q);\n        if(delta > d2) {\n          delta = d2;\n          update = true;\n        }\n      }\n    }\n    if(update) {\n      S.clear();\n      for(int j = 0; j <= i; ++j) {\n        S[IP(p[j].first / delta, p[j].second / delta)].push_back(p[j]);\n      }\n    }\n    else {\n      S[ip].push_back(p[i]);\n    }\n  }\n  cout.setf(ios::fixed);\n  cout.precision(6);\n  cout << delta << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nstruct Point {\n    double x, y;\n    bool operator < (const Point& p) const {\n        if(x != p.x) return x < p.x;\n        return y < p.y;\n    }\n};\n\n\ndouble dist(double x, double y){\n    return sqrt(x * x + y * y);\n}\ndouble dist(Point p, Point q){\n    return dist(p.x - q.x, p.y - q.y);\n}\n\nint main(){\n    int N;\n    cin >> N;\n    vector<Point> ps(N);\n    REP(i, N){\n        double x, y;\n        scanf(\"%lf %lf\", &ps[i].x, &ps[i].y);\n    }\n    sort(ps.begin(), ps.end());\n    double ans = dist(ps[0], ps[1]);\n    for(int i = 0; i < N; i++){\n        for(int j = i + 1; j < N && ps[j].x - ps[i].x < ans; j++){\n            ans = min(ans, dist(ps[i], ps[j]));\n        }\n    }\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n\n    two_dimensional_qsort(p_xy+n0, 0, n-1-n0, 1);\n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        \n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<< ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100000\nconst double INF = 1e50;\n\ntypedef pair<double,double> P;\n\nint N;\nP A[MAX_N]; \n\nbool compare_y(const P &a,const P &b){\n  return a.second < b.second;\n}\n \ndouble closest_pair(P *a,int n){\n  if(n <= 1) return INF;\n  int m = n / 2;\n  double x = a[m].first;\n  double d = min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n \n  vector<P> b;\n  for(int i = 0 ; i < n ; i++){\n    if(fabs(a[i].first - x) >= d) continue;\n    for(int j = 0 ; j < (int)b.size() ; j++){\n      double dx = a[i].first - b[b.size()-j-1].first;\n      double dy = a[i].second - b[b.size()-j-1].second;\n      if(dy >= d) break;\n      d = min(d,sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nvoid solve(){\n  sort(A,A+N);\n  printf(\"%.8f\\n\",closest_pair(A,N));\n}\n\nint main(){\n  cin >> N;\n  for(int i = 0 ; i < N ; i++){\n    scanf(\"%lf%lf\",&A[i].first,&A[i].second);\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef complex<long double> point;\n\n#define dot(a,b) ((conj(a)*(b)).real())\n#define length(a) hypot((a).X,(a).Y)\n\n#define X real()\n#define Y imag()\n#define vect(p1,p2) ((p2)-(p1))\n#define cross(a,b) ((conj(a)*(b)).imag())\nconst long double EPS = 1e-12;\nconst long double INF = 1e18;\n\n#define STRAIGHT 0\n#define CLOCKWISE 1\n#define COUNTERCLOCKWISE 2\nint orient(const point &a, const point &b, const point &c){\n    long double res = cross(vect(a, b), vect(a, c));\n\n    if(res < -EPS)\n        return CLOCKWISE;\n    if(res > EPS)\n        return COUNTERCLOCKWISE;\n\n    return STRAIGHT;\n}\n\n\nlong double point_line_distance(const point& a, const point& b, const point& p) {\n\treturn fabs(cross(b - a, p - a)) / length(b - a);\n}\nlong double point_segment_distance(const point& a, const point& b, const point& p) {\n\tif (dot(p-a,b-a) < EPS)\n\t\treturn length(p - a);\n\tif (dot(p-b,a-b) < EPS)\n\t\treturn length(p - b);\n\treturn point_line_distance(a, b, p);\n}\n\nbool point_on_line(const point &a, const point &b,const point &p) {\n\treturn fabs(cross(vect(a,b), vect(a,p))) < EPS;\n}\n\nbool point_on_segment(const point &a,const point &b,const point &p) {\n\treturn dot(vect(a,b), vect(a,p)) > -EPS && point_on_line(a, b, p)\n\t\t\t&& dot(vect(b,a), vect(b,p)) > -EPS;\n}\n\nbool line_intersect(point a, point b, point p, point q, point& r) {\n\tlong double d1 = cross(p - a, b - a);\n\tlong double d2 = cross(q - a, b - a);\n\tif (fabs(d2 - d1) < EPS)\n\t\treturn false;\n\tr = (d1 * q - d2 * p) / (d1 - d2);\n\treturn true;\n}\nbool segment_intersect(point a, point b, point p, point q) {\n\n    if(orient(a, b, p) == STRAIGHT && orient(b, p, q) == STRAIGHT)\n        return point_on_segment(a, b , p) || point_on_segment(a, b, q);\n\n    long double d1 = cross(p - a, b - a);\n    long double d2 = cross(q - a, b - a);\n    long double d3 = cross(a - p, q - p);\n    long double d4 = cross(b - p, q - p);\n\n    if (d1 * d2 < EPS && d3 * d4 < EPS)\n        return true;\n    else\n        return false;\n}\n\n\nstruct orient_cmp {\n\tpoint a;\n\torient_cmp(point a): a(a){}\n\n\tbool operator()(const point& c, const point& b) const {\n\t    return orient(a, b, c) == CLOCKWISE;\n\t}\n};\n\nbool point_in_triangle(const point& a, const point& b, const point& c, const point& p){\n    long double s1 = fabs(cross(vect(a, b), vect(a, c)));\n    long double s2 = fabs(cross(vect(p, a), vect(p, b))) + fabs(cross(vect(p, b), vect(p, c))) + fabs(cross(vect(p, c),vect(p, a)));\n\n    return fabs(s1 - s2) < EPS;\n}\n\nbool point_in_convex_polygon(const vector<point> &convex, const point &p){\n    int n = convex.size();\n\n    if(point_on_segment(convex[0], convex[1], p))\n        return true;\n\n    if(point_on_segment(convex[0], convex[n-1], p))\n        return true;\n\n    if(orient(convex[0], convex[1], p) == CLOCKWISE)\n        return false;\n\n    if(orient(convex[0], convex[n-1], p) == COUNTERCLOCKWISE)\n        return false;\n\n\n    auto pos = lower_bound(convex.begin() + 1, convex.end(), p, orient_cmp(convex[0])) - convex.begin();\n\n    if(pos == 1 || pos == n)\n        return false;\n\n    if(point_on_segment(convex[pos-1], convex[pos], p))\n        return true;\n\n    if(point_in_triangle(convex[0], convex[pos-1], convex[pos], p))\n        return true;\n\n    return false;\n}\nbool segment_intersect_convex_polygon(const vector<point> &convex, const point &a, const point &b){\n    int n = convex.size();\n\n    auto pos = lower_bound(convex.begin() + 1, convex.end(), a, orient_cmp(convex[0])) - convex.begin();\n\n    if(pos == 0 || pos == n)\n        return false;\n\n    return segment_intersect(a, b, convex[pos-1], convex[pos]);\n}\n\nstruct cmp {\n\tpoint about;\n\tcmp(point about): about(about) {}\n\n\tbool operator()(const point& p, const point& q) const {\n\t\tint res = orient(p, about, q);\n\n\t\tif (res == STRAIGHT)\n\t\t\treturn make_pair(p.Y, p.X) < make_pair(q.Y, q.X);\n\t\treturn res == CLOCKWISE;\n\t}\n};\n\nvector<point> convex_hull(vector<point> points) {\n    vector<point> convex;\n\n\tpoint mn(INF, INF);\n\tfor (int i = 0; i < points.size(); i++) {\n\t\tif (make_pair(points[i].Y, points[i].X) < make_pair(mn.Y, mn.X))\n\t\t\tmn = points[i];\n\t}\n\n\tsort(points.begin(), points.end(), cmp(mn));\n\n\tconvex.clear();\n\tconvex.push_back(points[0]);\n\n\tif (points.size() == 1)\n\t\treturn convex;\n\n\tconvex.push_back(points[1]);\n\n\tfor (int i = 2; i <= points.size(); i++) {\n\t\tpoint c = points[i % points.size()];\n\n\t\twhile (convex.size() > 1) {\n\t\t\tpoint b = convex[convex.size() - 1];\n\t\t\tpoint a = convex[convex.size() - 2];\n\n\t\t\tif (orient(a,b,c) == COUNTERCLOCKWISE)\n\t\t\t\tbreak;\n\n\t\t\tconvex.pop_back();\n\t\t}\n\t\tif (i < points.size())\n\t\t\tconvex.push_back(points[i]);\n\t}\n\n\treturn convex;\n}\n\n\nvector<point> polygon_cut(const vector<point>& polygon, const point& a, const point& b) {\n    vector<point> res;\n\n    for (int i = 0; i < polygon.size(); i++) {\n        auto p = polygon[i];\n        auto q = polygon[(i + 1) % polygon.size()];\n\n        if (orient(a, b, p) == COUNTERCLOCKWISE)\n            res.push_back(p);\n\n        if ((orient(a, b, p) == COUNTERCLOCKWISE) ^ (orient(a, b, q) == COUNTERCLOCKWISE)) {\n            point r;\n            if(line_intersect(b, a, p, q, r))\n                res.push_back(r);\n        }\n    }\n    //cout << a <<\" \" <<b <<\": \" <<\"\\n\";\n    //for(auto p: res)\n     //   cout << p <<\"\\n\";\n    //cout <<\"\\n\";\n\n    return res;\n}\n\nvector<point> convex_polygon_intersection(const vector<point>& polygon1, const vector<point>& polygon2) {\n    vector<point> res = polygon1;\n\n    for (int i = 0; i < polygon2.size(); i++) {\n        auto p = polygon2[i];\n        auto q = polygon2[(i + 1) % polygon2.size()];\n\n        res = polygon_cut(res, p, q);\n    }\n\n    return res;\n}\n\ndouble polygon_area(const vector<point>& polygon) {\n    if(polygon.size()<3 )\n        return 0;\n\n    double res = 0;\n    for (int i = 0; i < polygon.size() - 1; i++)\n        res += cross(polygon[i], polygon[i+1]);\n    res += cross(polygon.back(), polygon.front());\n\n    res /= 2.0;\n    return fabs(res);\n}\n\nstruct order_by_x_cmp{\n  bool operator ()(const point &left, const point &right) const{\n    if(left.X != right.X)\n        return left.X < right.X;\n    return left.Y < right.Y;\n  }\n};\n\nstruct order_by_y_cmp{\n  bool operator ()(const point &left, const point &right) const{\n    if(left.Y != right.Y)\n        return left.Y < right.Y;\n    return left.X < right.X;\n  }\n};\n\npoint p1, p2;\n\ndouble closest_pair(vector<point> points) {\n    int n = points.size();\n    sort(points.begin(), points.end(), order_by_x_cmp());\n    set<point, order_by_y_cmp> active_set;\n\n    double best_dist = INF;\n\n    for (int i = 0, j = 0; i < n; i++) {\n        while (j<n && points[i].X - points[j].X + EPS >= best_dist) {\n            active_set.erase(points[j]);\n            j++;\n        }\n\n        auto it1 = active_set.lower_bound(points[i] + point(0, -best_dist - EPS));\n        auto it2 = active_set.upper_bound(points[i] + point(0, +best_dist + EPS));\n\n        for (auto it = it1; it != it2; it++){\n            double new_dist = abs(points[i] - (*it));\n\n            if(new_dist < best_dist){\n                best_dist = new_dist;\n                p1 = points[i], p2 = *it;\n            }\n        }\n\n\n        active_set.insert(points[i]);\n    }\n\n    return best_dist;\n}\nint main(){\n\n    int n; cin>>n;\n    vector<point>vec;\n    for(int i=0 ; i<n; i++){\n        double x,y; cin>>x>>y;\n        vec.push_back(point(x, y));\n    }\n\n    cout << setprecision(12)<< fixed <<  closest_pair(vec) <<\"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 10000;\nconst double INFTY = 10000000000000000000.0;\n\nstruct Point { double x, y; };\nbool compareX(Point& a, Point& b) {\n\treturn a.x < b.x ? true : a.x == b.x && a.y <= b.y ? true : false;\n}\n\nbool compareY(Point& a, Point& b) {\n\treturn a.y < b.y ? true : a.y == b.y && a.x <= b.x ? true : false;\n}\n\ninline double getSquareDist(Point a, Point b) {\n\treturn (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\ninline double getMinSquareDistOfThree(Point a, Point b, Point c) {\n\treturn min(getSquareDist(a, b), min(getSquareDist(a, c), getSquareDist(b, c)));\n}\n\ndouble getMinSquareDistNearMid(Point nearmid[], int nearmid_length) {\n\tsort(nearmid, nearmid + nearmid_length, compareY);\n\n\tdouble min_sq_dist = INFTY;\n\tdouble cur_sq_dist;\n\tfor (int i = 0; i < nearmid_length; ++i) {\n\t\t// a better implementation:\n\t\t//for (int j = i + 1; j < min(nearmid_length, i + 8); ++j) {\n\t\tfor (int j = i + 1; j < nearmid_length && (nearmid[j].y - nearmid[i].y) < min_sq_dist; ++j) {\n\t\t\tcur_sq_dist = getSquareDist(nearmid[i], nearmid[j]);\n\t\t\tif (cur_sq_dist < min_sq_dist)\n\t\t\t\tmin_sq_dist = cur_sq_dist;\n\t\t}\n\t}\n\treturn min_sq_dist;\n}\n\n// nlog^2 n, not nlog n in CLRS\ndouble dcClosestSquareDist(int low, int high, Point points[]) {\n\tif (high - low == 1) {\n\t\treturn getSquareDist(points[low], points[high]);\n\t}\n\telse if (high - low == 2) {\n\t\treturn getMinSquareDistOfThree(points[low], points[low + 1], points[high]);\n\t}\n\telse {\n\t\t// bug 3: + has higher precedence than >>\n\t\t//int mid = low + (high - low) >> 1;\n\t\tint mid = low + ((high - low) >> 1);\n\t\tdouble d_left = dcClosestSquareDist(low, mid, points);\n\t\tdouble d_right = dcClosestSquareDist(mid + 1, high, points);\n\t\tdouble d_divide = min(d_left, d_right);\n\t\tdouble d_divide_sqrt = sqrt(d_divide);\n\n\t\t// merge\n\t\tPoint *nearmid = new Point[high - low + 1];\n\t\tint nearmid_length = 0;\n\t\tfor (int i = low; i <= high; ++i) {\n\t\t\t// bug 4: here we should compare the dist with real dist, not squared!\n\t\t\tif (points[i].x - points[mid].x < d_divide_sqrt && points[i].x - points[mid].x > -d_divide_sqrt) {\n\t\t\t\tnearmid[nearmid_length] = points[i];\n\t\t\t\tnearmid_length++;\n\t\t\t}\n\t\t}\n\t\tdouble d_merge = getMinSquareDistNearMid(nearmid, nearmid_length);\n\t\t// bug 6: forget to free memory\n\t\tdelete[] nearmid;\n\t\treturn min(d_divide, d_merge);\n\t}\n}\n\ndouble getMinSqDistToFirst(Point first_camera, Point points[], int n) {\n\tdouble min_sq_dist = INFTY;\n\tdouble cur_sq_dist;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcur_sq_dist = getSquareDist(first_camera, points[i]);\n\t\tif (cur_sq_dist < min_sq_dist)\n\t\t\tmin_sq_dist = cur_sq_dist;\n\t}\n\treturn min_sq_dist;\n}\n\ndouble getArea(double candidate, double min_dist_to_first, int n) {\n\treturn candidate * candidate + (n - 1) * (min_dist_to_first - candidate) * (min_dist_to_first - candidate);\n}\n\n/*\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tint n;\n\tPoint points[MAX_N];\n\tPoint first_camera;\n\tdouble min_dist_to_first;\n\tdouble min_dist_among_others;\n\tdouble candidate1;\t// candidate1 = max(0, d1 - d2 / 2)\n\tdouble candidate2;\t// candidate2 = d1\n\tdouble max_area;\n\tfor (int i = 1; i <= t; ++i) {\n\t\tscanf(\"%d\", &n);\n\t\tscanf(\"%lf%lf\", &(first_camera.x), &(first_camera.y));\n\t\tfor (int j = 0; j < n - 1; ++j) {\n\t\t\tscanf(\"%lf%lf\", &(points[j].x), &(points[j].y));\n\t\t}\n\t\tmin_dist_to_first = sqrt(getMinSqDistToFirst(first_camera, points, n));\n\t\tif (n == 2) {\n\t\t\tmin_dist_among_others = INFTY;\n\t\t}\n\t\telse {\n\t\t\tsort(points, points + n - 1, compareX);\n\t\t\tmin_dist_among_others = sqrt(dcClosestSquareDist(0, n - 2, points));\n\t\t}\n\t\t//printf(\"%f\\n\", min_dist_among_others);\n\t\tcandidate1 = max(0.0, min_dist_to_first - min_dist_among_others / 2.0);\n\t\tcandidate2 = min_dist_to_first;\n\t\tmax_area = M_PI * max(getArea(candidate1, min_dist_to_first, n), getArea(candidate2, min_dist_to_first, n));\n\t\tprintf(\"Case #%d: %.8f\\n\", i, max_area);\n\t}\n    return 0;\n}\n*/\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tPoint points[MAX_N];\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%lf%lf\", &(points[i].x), &(points[i].y));\n\t}\n\tsort(points, points + n, compareX);\n\tprintf(\"%.10lf\\n\", sqrt(dcClosestSquareDist(0, n, points)));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\ntemplate <typename T>\nstruct Vector2D {        // Literal Class\n    T x, y;\n    explicit constexpr Vector2D() : x(0), y(0) {}\n    explicit constexpr Vector2D(T _x, T _y) : x(_x), y(_y) {}\n    const Vector2D operator + (const Vector2D& p) const { return Vector2D(x + p.x, y + p.y);}\n    const Vector2D operator - (const Vector2D& p) const { return Vector2D(x - p.x, y - p.y);}\n    Vector2D& operator *= (const T& p) { x *= p, y *= p; return *this;}\n    Vector2D& operator += (const T& p) { x += p, y += p; return *this;}\n    Vector2D& operator -= (const T& p) { x -= p, y -= p; return *this;}\n    Vector2D& operator /= (const T& p) { x /= p; y /= p; return *this;}\n    Vector2D& operator += (const Vector2D& p) { x += p.x, y += p.y; return *this;}\n    Vector2D& operator -= (const Vector2D& p) { x -= p.x, y -= p.y; return *this;}\n    const T dot(const Vector2D& q) { return x * q.x + y * q.y;}\n    const T norm() { return sqrt(x * x + y * y);}\n    friend std::ostream& operator<<(std::ostream& os, const Vector2D& p) { os << \"(\" << p.x << \", \" << p.y << \")\"; return os;}\n};\n\n#include <vector>\n#include <iomanip>\n#include <functional>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\nusing Pt = Vector2D<double>;\nconst double INF = 1e18;\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<Pt> points(n); // Points are 1 indexed\n    for(auto& p : points)\n        cin >> p.x >> p.y;\n    // x??§?¨???§?????????\n    sort(points.begin(), points.end(), [](const Pt& l, const Pt& r) {\n            return l.x == r.x ? l.y < r.y : l.x < r.x;\n        });\n\n    function<tuple<double, int, int>(int, int)> closest = [&](int id, int n) {\n        if(n <= 1) return make_tuple(INF, 0, 0);\n        int m = n / 2;\n        double boundX = points[m].x;\n        tuple<double, int, int> res = min(closest(id, m), closest(id + m, n - m));\n        auto fit = points.begin() + id;\n        inplace_merge(fit, fit + m, fit + n, [](const Pt& l, const Pt& r) {\n                return l.y == r.y ? l.x < r.x : l.y < r.y;\n            });\n        vector<int> memo;\n        for(int i = id; i < id + n; ++i) {\n            if(fabs(boundX - points[i].x) > get<0>(res)) continue;\n            for(int j = -1 + memo.size(); j >= 0; --j) {\n                Pt p = points[i] - points[memo[j]];\n                if(p.x >= get<0>(res)) continue;\n                res = min(res, make_tuple(p.norm(), i, memo[j]));\n            }\n            memo.emplace_back(i);\n        }\n        return res;\n    };\n    cout << fixed << setprecision(10) << get<0>(closest(0, n)) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct node{\n  int dim;\n  vector<double>v;\n};\n \ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n \ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nmap<vector<int> ,vector<int> >grid;\n\nvector<int> neighborhood(vector<int> v, int dim, vector<int>res){\n\n  if(dim==v.size()){\n    bool fg = true;\n    for(int i=0;i<dim;i++)fg&=(res[i]==v[i]);\n    if(fg || !grid.count(res))return vector<int>();\n    return grid[res];\n  }\n  vector<int> result;\n  for(int i=-1;i<2;i++){\n    res.push_back(v[dim]+i);\n    vector<int>tmp = neighborhood(v,dim+1,res);\n    result.insert(result.end(),tmp.begin(),tmp.end());\n    res.pop_back();\n  }\n  return result;\n}\n\nvector<node> func(vector<node> S){\n  vector<node>nextS;\n  map<vector<int>,vector<int> >::iterator it = grid.begin();\n  for(;it!=grid.end();it++){\n    vector<int>res=neighborhood((*it).first,0,vector<int>());\n    for(int j=0;j<res.size();j++)nextS.push_back(S[res[j]]);\n  }\n\n  return nextS;\n}\n\ndouble rec(vector<int> v, int dim, vector<int>res, node p, vector<node> S){\n  if(dim==v.size()){\n    if(!grid.count(res))return 1000000000;\n    double result=100000000;\n    for(int i=0;i<grid[res].size();i++)\n      if(p.v!=S[grid[res][i]].v)\n      result=min(result,d(p,S[grid[res][i]]));\n    return result;\n  }\n  double result=1000000000;\n  for(int i=-1;i<2;i++){\n    res.push_back(v[dim]+i);\n    result=min(result,rec(v,dim+1,res,p,S));\n    res.pop_back();\n  }\n  return result;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n \n  double res;\n  vector<node>tmp=S;\n\n  while(!S.empty()){\n    node p=S[rand()%S.size()];\n \n    res=d(p,S);\n    double dist=res/(4*p.dim);\n \n    grid.clear();\n    for(int i=0;i<S.size();i++){\n      vector<int> key;\n      for(int j=0;j<p.dim;j++)key.push_back((int)(S[i].v[j]/dist));\n      grid[key].push_back(i);\n    }\n   \n    S=func(S);\n  }\n\n  S=tmp;\n  double ans=100000000;\n  grid.clear();\n  for(int i=0;i<S.size();i++){\n    vector<int> key;\n    for(int j=0;j<2;j++)key.push_back((int)(S[i].v[j]/res));\n    grid[key].push_back(i);\n  }\n  \n  map<vector<int>,vector<int> >::iterator it = grid.begin();\n  for(;it!=grid.end();it++){\n    for(int j=0;j<(*it).second.size();j++){\n      ans=min(ans,rec((*it).first,0,vector<int>(),S[(*it).second[j]],S));\n    }\n  }\n\n  return ans;\n}\n \nint main(void){\n \n  int n;\n  cin >> n;\n \n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n \n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nconst int dx8[] = { -1, 0, 1, -1, 0, 1, -1, 0, 1 }; const int dy8[] = { -201,-201,-201,0,0,0,201,201,201 };\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<vector<pair<double, double>>> pos(201 * 201);\n\tREP(i, n){\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpos[(int)((x + 100.0) / 100.0) + (int)((y + 100.0) / 100.0) * 201].push_back({ x, y });\n\t}\n\n\tdouble mi = 600000;\n\tREP(i, 201 * 201){\n\t\tREP(j, pos[i].size()){\n\t\t\tREP(k, 9){\n\t\t\t\tif (0 <= (i % 201) + dx8[k] && (i % 201) + dx8[k] < 201 && 0 <= i + dy8[k] && i + dy8[k]<201*201)\n\t\t\t\tREP(l, pos[i+dx8[k]+dy8[k]].size()){\n\t\t\t\t\tif (j == l&&k == 4)continue;\n\t\t\t\t\tmi = min(mi, (pos[i][j].first - pos[i + dx8[k] + dy8[k]][l].first)*(pos[i][j].first - pos[i + dx8[k] + dy8[k]][l].first) + (pos[i][j].second - pos[i + dx8[k] + dy8[k]][l].second)*(pos[i][j].second - pos[i + dx8[k] + dy8[k]][l].second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\", sqrt(mi));\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef pair<int, int> PI;\nconst double EPS=1e-9;\n\nconst int N = 1e5 + 10;\ndouble x[N], y[N];\n\nstruct x_cmp {\n  bool operator() (int i, int j) {\n    return x[i] < x[j];\n  }\n};\nstruct y_cmp {\n  bool operator() (int i, int j) {\n    return y[i] < y[j];\n  }\n};\n\ndouble dist2(int i, int j) {\n  return pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2);\n}\n\ndouble min_brute_force(const std::vector<int> & v) {\n  double mi = 1.0 / 0.0;\n  int n = v.size();\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (i == j) {\n\tcontinue;\n      }\n      mi = min(mi, dist2(v[i], v[j]));\n    }\n  }\n  return mi;\n}\n\n\ndouble min_strip(const vector<int> &v, double d) {\n  double mi = d;\n  int n = v.size();\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n && y[v[j]] - y[v[i]] < mi; ++j) {\n      mi = min(mi, dist2(v[i], v[j]));\n    }\n  }\n  return mi;\n}\n\n/*\n */\ndouble min_pair_util(const vector<int> &vx) {\n  int n = vx.size();\n  if (n <= 4) {\n    return min_brute_force(vx);\n  }\n  // divide at middle\n  int mid = n / 2;\n  double mid_x = x[vx[mid]];\n  double ml = min_pair_util(vector<int>(vx.begin(), vx.begin() + mid));\n  double mr = min_pair_util(vector<int>(vx.begin() + mid, vx.end()));\n  double dist = min(ml, mr);\n  vector<int> strip;\n  for(int i = 0; i < n; ++i) {\n    if (abs(x[vx[i]] - mid_x) < dist) {\n      strip.push_back(i);\n    }\n  }\n  sort(strip.begin(), strip.end(), y_cmp());\n  return min(dist, min_strip(strip, dist));\n}\n\nint main(void){\n  int n;\n  cin >> n;\n  REP(i, 0, n) {\n    cin >> x[i] >> y[i];\n  }\n  double mi = 1e10;\n  vector<int> v(n);\n  REP(i, 0, n) {\n    v[i] = i;\n  }\n  sort(v.begin(), v.end(), x_cmp());\n  mi = min_pair_util(v);\n  printf(\"%.9f\\n\", sqrt(mi));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\ntypedef vector<point> polygon;\n\nconst double oo = 1e18;\nconst double eps = 1e-9;\n\nnamespace std\n{\n\tbool operator<(point a, point b)\n\t{\n\t\tif (a.real() != b.real())\n\t\t\treturn a.real() < b.real();\n\t\treturn a.imag() < b.imag();\n\t}\n}\n\ndouble closestPairPoints(vector<point> &p){\n\tauto cmp = [](point a, point b)\n\t{\n\t\treturn make_pair(a.imag(), a.real()) < make_pair(b.imag(), b.real());\n\t};\n\n\tint n = (int)p.size();\n\tsort(p.begin(), p.end());\n\n\tset<point, decltype(cmp)> S(cmp);\n\tdouble ans = oo;\n\tint ptr = 0;\n\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\twhile (ptr < i && abs(p[i].real() - p[ptr].real()) >= ans)\n\t\t\tS.erase(p[ptr++]);\n\n\t\tauto lo = S.lower_bound(point(-oo, p[i].imag() - ans - eps));\n\t\tauto hi = S.upper_bound(point(-oo, p[i].imag() + ans + eps));\n\n\t\tfor (decltype(lo) it = lo; it != hi; ++it)\n\t\t\tans = min(ans, abs(p[i] - *it));\n\n\t\tS.insert(p[i]);\n\t}\n\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\tvector<point> p(n);\n\t\n\tfor (int i = 0; i < n; ++i){\n\t\tdouble x, y; cin >> x >> y;\n\t\tp[i] = point(x, y);\n\t}\n\n\tcout.precision(10);\n\tcout << fixed << closestPairPoints(p) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr double kEps = 1E-10;\nconst double kPi = 4 * atan(1);\nint dcmp(double x) {\n  if (fabs(x) < kEps) return 0;\n  return x < 0 ? -1 : 1;\n}\nbool same(double a, double b) {\n  return dcmp(a - b) == 0;\n}\nstruct P {\n  double x, y;\n  P(double x = 0, double y = 0) : x(x), y(y) {}\n  P operator+(P b) const {\n    return P(x + b.x, y + b.y);\n  }\n  P operator-(P b) const {\n    return P(x - b.x, y - b.y);\n  }\n  P operator*(double b) const {\n    return P(x * b, y * b);\n  }\n  P operator/(double b) const {\n    return P(x / b, y / b);\n  }\n  double operator*(P b) const {\n    return x * b.x + y * b.y;\n  }  // Dot\n  double operator^(P b) const {\n    return x * b.y - y * b.x;\n  }  // Cross\n  double abs() const { return hypot(x, y); }\n  P unit() const { return *this / abs(); }\n  P spin(double o) const {\n    double c = cos(o), s = sin(o);\n    return P(c * x - s * y, s * x + c * y);\n  }\n};\nusing Vector = P;\nstruct Line {\n  // ax + by + c = 0\n  double a, b, c, theta;\n  P pa, pb;\n  Line()\n      : a(0), b(0), c(0), theta(0), pa(), pb() {}\n  Line(P pa, P pb)\n      : a(pa.y - pb.y), b(pb.x - pa.x), c(pa ^ pb),\n        theta(atan2(-a, b)), pa(pa), pb(pb) {}\n  P projection(P p) {\n    return pa +\n      (pb - pa).unit() *\n      ((pb - pa) * (p - pa) / (pb - pa).abs());\n  }\n  P reflection(P p) {\n    return p + (projection(p) - p) * 2;\n  }\n  double get_ratio(P p) {\n    return (p - pa) * (pb - pa) /\n      ((pb - pa).abs() * (pb - pa).abs());\n  }\n  P dis(P p) {\n    return ((pb - pa) ^ (p - pa)) /\n      (pb - pa).abs();\n  }  // directed distance\n};\nstruct Circle {\n  P c;\n  double r;\n  Circle(P c, double r = 0) : c(c), r(r) {}\n};\nbool onsegment(P p, P a, P b) {\n  return dcmp((a - p) ^ (b - p)) == 0 &&\n    dcmp((a - p) * (b - p)) <= 0;\n}\nbool segment_intersection(P p1, P p2, P p3,\n  P p4) {  // end points are not allowed\n  return dcmp((p2 - p1) ^ (p3 - p1)) *\n      dcmp((p2 - p1) ^ (p4 - p1)) <\n    0 &&\n    dcmp((p4 - p3) ^ (p1 - p3)) *\n      dcmp((p4 - p3) ^ (p2 - p3)) <\n    0;\n}\nbool parallel(Line l1, Line l2) {\n  return same(l1.a * l2.b, l1.b * l2.a);\n}\nP line_intersection(Line l1, Line l2) {\n  return P(-l1.b * l2.c + l1.c * l2.b,\n           l1.a * l2.c - l1.c * l2.a) /\n    (-l1.a * l2.b + l1.b * l2.a);\n}\ndouble Area(vector<P> &p) {\n  double res = 0;\n  for (int i = 1; i < int(p.size()) - 1; i++)\n    res += (p[i] - p[0]) ^ (p[i + 1] - p[0]);\n  return res * 0.5;\n}\n\n// p should be sorted increasingly according\n// to the x-coordinates.\ndouble Dis(P a, P b) { return (a - b).abs(); }\ndouble ClosestPair(P *p, int l, int r) {\n  if (l == r) return 1E9;\n  if (r - l == 1) return Dis(p[l], p[r]);\n  int m = (l + r) >> 1;\n  double d = min(ClosestPair(p, l, m),\n    ClosestPair(p, m + 1, r));\n  vector<int> vec;\n  for (int i = m;\n       i >= l && abs(p[m].x - p[i].x) < d; i--)\n    vec.push_back(i);\n  for (int i = m + 1;\n       i <= r && abs(p[m].x - p[i].x) < d; i++)\n    vec.push_back(i);\n  sort(vec.begin(), vec.end(),\n    [&](int a, int b) { return p[a].y < p[b].y; });\n  for (int i = 0; i < int(vec.size()); ++i) {\n    for (int j = i + 1; j < int(vec.size()) &&\n         abs(p[vec[j]].y - p[vec[i]].y) < d;\n         ++j) {\n      d = min(d, Dis(p[vec[i]], p[vec[j]]));\n    }\n  }\n  return d;\n}\n\nint main() {\n  cin.tie(nullptr),\n    ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector<P> p(n);\n  for (int i = 0; i < n; i++)\n    cin >> p[i].x >> p[i].y;\n  sort(p.begin(), p.end(),\n    [&](auto a, auto b) { return a.x < b.x; });\n  cout << fixed << setprecision(10)\n       << ClosestPair(p.data(), 0, n - 1) << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nstruct P\n{\n\tlong double x, y;\n\tP(long double x, long double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tlong double length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tlong double length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nint ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}\n\npair<P, P> ClosestPair(vector<P>& points)\n{\n\tint n = points.size(), s = 0, t = 1, m = 2;\n\tvector<int> S(n);\n\tS[0] = 0, S[1] = 1;\n\tsort(points.begin(), points.end());\n\tlong double d = (points[s] - points[t]).length2();\n\tfor (int i = 2; i < n; S[m++] = i++)for (int j = 0; j < m; j++)\n\t{\n\t\tif ((points[S[j]] - points[i]).length2() < d)\n\t\t{\n\t\t\td = (points[s = S[j]] - points[t = i]).length2();\n\t\t}\n\t\tif (points[S[j]].x < points[i].x - d)\n\t\t{\n\t\t\tS[j--] = S[--m];\n\t\t}\n\t}\n\treturn make_pair(points[s], points[t]);\n}\n\nvector<P> points;\n\nint main()\n{\n\tpoints.reserve(100000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\tpoints.push_back(P(x, y));\n\t}\n\n\tpair<P, P> closestPair = ClosestPair(points);\n\tprintf(\"%.10lf\\n\", (double)((closestPair.first - closestPair.second).length()));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = limits::inf;\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) >= delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    printf(\"%.8f\\n\", closest_pair(P));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-10\n#define Vector Point\n#define INF 2000000000\n#define DOUBLE_INF 1e50\n#define sq(x) ((x)*(x))\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\n\n// Geometry Library\n// written by okuraofvegetable\n\ninline double add(double a,double b){\n\tif(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint() {}\n\tPoint(double x,double y) : x(x),y(y){}\n\tPoint operator + (Point p){return Point(add(x,p.x),add(y,p.y));}\n\tPoint operator - (Point p){return Point(add(x,-p.x),add(y,-p.y));}\n\tPoint operator * (double d){return Point(x*d,y*d);}\n\tdouble dot(Point p){return add(x*p.x,y*p.y);}\n\tdouble det(Point p){return add(x*p.y,-y*p.x);}\n\tdouble norm(){return sqrt(x*x+y*y);}\n\tdouble norm2(){return x*x+y*y;}\n\tdouble dist(Point p){return ((*this)-p).norm();}\n\tdouble dist2(Point p){return sq(x-p.x)+sq(y-p.y);}\n\tPoint vert(){return Point(y,-x);}\n\tvoid dump(const char* msg=\"\"){printf(\"%s%.12f %.12f\\n\",msg,x,y);return;}\n\t\n\t// following functions for vector operation\n\n\t// signed area of triange (0,0) (x,y) (p.x,p.y)\n\tdouble area(Point p){\n\t\treturn (x*p.y-p.x*y)/2.0;\n\t}\n};\n// direction a -> b -> c\n// verified AOJ CGL_1_C\nenum {COUNTER_CLOCKWISE,\n\t\tCLOCKWISE,\n\t\tONLINE_BACK,\n\t\tONLINE_FRONT,\n\t\tON_SEGMENT};\nint ccw(Point a,Point b,Point c){\n\tVector p = b-a;\n\tVector q = c-a;\n\tif(p.det(q)>0.0)return COUNTER_CLOCKWISE; // counter clockwise\n\tif(p.det(q)<0.0)return CLOCKWISE; // clockwise\n\tif(p.dot(q)<0.0)return ONLINE_BACK; // c--a--b online_back\n\tif(p.norm()<q.norm())return ONLINE_FRONT; // a--b--c online_front \n\treturn ON_SEGMENT;// a--c--b on_segment\n}\nstruct Line{\n\tPoint a,b;\n\tLine(){}\n\tLine(Point a,Point b):a(a),b(b){}\n\tbool on(Point q){\n\t\treturn (a-q).det(b-q)==0; \n\t}\n\t// folloing 2 functions verified AOJ CGL_2_A\n\tbool is_parallel(Line l){return (a-b).det(l.a-l.b)==0;}\n\tbool is_orthogonal(Line l){return (a-b).dot(l.a-l.b)==0;}\n\tPoint intersection(Line l){\n\t\tassert(!is_parallel(l));\n\t\treturn a+(b-a)*((l.b-l.a).det(l.a-a)/(l.b-l.a).det(b-a));\n\t}\n\t// projection of p to this line\n\t// verified AOJ CGL_1_A\n\tPoint projection(Point p){\n\t\treturn (b-a)*((b-a).dot(p-a)/(b-a).norm2())+a;\n\t}\n\t// reflection point of p onto this line\n\t// verified AOJ CGL_1_B\n\tPoint refl(Point p){\n\t\tPoint proj = projection(p);\n\t\treturn p+((proj-p)*2.0);\n\t}\n};\nstruct Segment{\n\tPoint a,b;\n\tSegment(){}\n\tSegment(Point a,Point b):a(a),b(b){}\n\tLine line(){\n\t\treturn Line(a,b);\n\t}\n\tbool on(Point q){\n\t\treturn ((a-q).det(b-q)==0&&(a-q).dot(b-q)<=0); \n\t}\n\t// verified AOJ CGL_2_B\n\tbool is_intersect(Segment s){\n\t\tif(line().is_parallel(s.line())){\n\t\t\tif(on(s.a)||on(s.b))return true;\n\t\t\tif(s.on(a)||s.on(b))return true;\n\t\t\treturn false;\n\t\t}\n\t\tPoint p = line().intersection(s.line());\n\t\tif(on(p)&&s.on(p))return true;\n\t\telse return false;\n\t}\n\tbool is_intersect(Line l){\n\t\tif(line().is_parallel(l)){\n\t\t\tif(l.on(a)||l.on(b))return true;\n\t\t\telse return false;\n\t\t}\n\t\tPoint p = line().intersection(l);\n\t\tif(on(p))return true;\n\t\telse return false;\n\t}\n\t// following 2 distance functions verified AOJ CGL_2_D\n\tdouble distance(Point p){\n\t\tdouble res = DOUBLE_INF;\n\t\tPoint q = line().projection(p);\n\t\tif(on(q))res = min(res,p.dist(q));\n\t\tres = min(res,min(p.dist(a),p.dist(b)));\n\t\treturn res;\n\t}\n\tdouble distance(Segment s){\n\t\tif(is_intersect(s))return 0.0;\n\t\tdouble res = DOUBLE_INF;\n\t\tres = min(res,s.distance(a));\n\t\tres = min(res,s.distance(b));\n\t\tres = min(res,this->distance(s.a));\n\t\tres = min(res,this->distance(s.b));\n\t\treturn res;\n\t}\n};\n\n// Polygon \n\ntypedef vector<Point> Polygon;\n// verified AOJ CGL_3_A\n// Polygon don't need to be convex\ndouble area(Polygon& pol){\n\tvector<Point> vec;\n\tdouble res = 0.0;\n\tint M = pol.size();\n\tfor(int i=0;i<M;i++){\n\t\tres += (pol[i]-pol[0]).area(pol[(i+1)%M]-pol[0]);\t\n\t}\n\treturn res;\n}\nbool is_convex(Polygon& pol){\n\tint n = pol.size();\n\tfor(int i=0;i<n-1;i++){\n\t\tif(ccw(pol[i],pol[i+1],pol[(i+2)%n])==CLOCKWISE){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n// vecrified AOJ CGL_3_C\nenum {OUT,ON,IN};\nint contained(Polygon& pol,Point p){\n\tint n = pol.size();\n\tPoint outer(1e9,p.y);\n\tSegment s = Segment(outer,p);\n\tint cnt = 0;\n\tfor(int i=0;i<n;i++){\n\t\tSegment e = Segment(pol[i],pol[(i+1)%n]);\n\t\tif(e.on(p))return ON;\n\t\tVector a = pol[i]-p;\n\t\tVector b = pol[(i+1)%n]-p;\n\t\tif(a.y>b.y)swap(a,b);\n\t\tif(a.y<=0.0&&b.y>0.0){\n\t\t\tif(a.det(b)<0.0)cnt++;\n\t\t}\n\t}\n\tif((cnt&1)==1)return IN;\n\telse return OUT;\n}\n// compare function for convex_hull\n// sort points by (x-y) lexicographical order.\n// you can change (y-x) order with no change in convex_hull\nbool comp(const Point& p,const Point& q){\n\tif(p.x!=q.x)return p.x<q.x;\n\telse return p.y<q.y;\n}\n// Convex hull\n// if you want not to contain points on boundary,\n// change while(....<=0.0)\n// verified AOJ CGL_4_A\nPolygon convex_hull(vector<Point> ps){\n\tsort(all(ps),comp);\n\tint k = 0;\n\tint n = ps.size();\n\tPolygon qs(2*n);\n\tfor(int i=0;i<n;i++){\n\t\twhile(k>1&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<0.0)k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile(k>t&&(qs[k-1]-qs[k-2]).det(ps[i]-qs[k-1])<0.0)k--;\n\t\tqs[k++]=ps[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n// Caliper method\n// verified AOJ CGL_4_B\ndouble convex_diameter(Polygon& cv){\n\tint i=0,j=0;\n\tint n = cv.size();\n\tfor(int k=0;k<n;k++){\n\t\tif(!comp(cv[i],cv[k]))i=k;\n\t\tif(comp(cv[j],cv[k]))j=k;\n\t}\n\tint si=i,sj=j;\n\tdouble res = 0.0;\n\twhile(i!=sj||j!=si){\n\t\tres = max(res,cv[i].dist(cv[j]));\n\t\tif((cv[(i+1)%n]-cv[i]).det(cv[(j+1)%n]-cv[j])<0.0)i=(i+1)%n;\n\t\telse j=(j+1)%n;\n\t}\n\treturn res;\n}\n// Cut conovex polygon by a line and return left polygon\n// verified AOJ CGL_4_C\nPolygon convex_cut(Polygon& cv,Line l){\n\tint n = cv.size();\n\tPolygon left; \n\tfor(int i=0;i<n;i++){\n\t\tSegment e = Segment(cv[i],cv[(i+1)%n]);\n\t\tif(ccw(l.a,l.b,cv[i])!=CLOCKWISE)left.pb(cv[i]);\n\t\tif(e.is_intersect(l)){\n\t\t\tif(!e.line().is_parallel(l)){\n\t\t\t\tleft.pb(e.line().intersection(l));\n\t\t\t}\n\t\t}\n\t}\n\treturn left;\n}\n// distance between closest pair\nbool comp_y(const Point& p,const Point& q){\n\treturn p.y<q.y;\n}\ndouble closest_pair(vector<Point>::iterator a,int n){\n\tif(n<=1)return DOUBLE_INF;\n\tint m = n/2;\n\tdouble x = (a+m)->x;\n\tdouble d = min(closest_pair(a,m),closest_pair(a+m,n-m));\n\tinplace_merge(a,a+m,a+n,comp_y);\n\tvector<Point> b;\n\tfor(int i=0;i<n;i++){\n\t\tdouble ax = (a+i)->x;\n\t\tdouble ay = (a+i)->y;\n\t\tif(abs(ax-x)>=d)continue;\n\t\tfor(int j=0;j<b.size();j++){\n\t\t\tdouble dx = ax-b[b.size()-1-j].x;\n\t\t\tdouble dy = ay-b[b.size()-1-j].y;\n\t\t\tif(dy>=d)break;\n\t\t\td = min(d,sqrt(dx*dx+dy*dy));\n\t\t}\n\t\tb.pb(*(a+i));\n\t}\n\treturn d;\n}\ndouble closest_pair(vector<Point> a){\n\tsort(all(a),comp);\n\treturn closest_pair(a.begin(),(int)a.size());\n}\n// for input\nPoint input_point(){\n\tPoint p;\n\tcin >> p.x >> p.y;\n\treturn p;\n}\nSegment input_segment(){\n\tPoint a,b;\n\ta = input_point();\n\tb = input_point();\n\treturn Segment(a,b);\n}\nLine input_line(){\n\tPoint a,b;\n\ta = input_point();\n\tb = input_point();\n\treturn Line(a,b);\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<Point> pol;\n\tfor(int i=0;i<n;i++){\n\t\tpol.pb(input_point());\n\t}\n\tprintf(\"%.12f\",closest_pair(pol));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\nint n,i,j,m,z;\ndouble x[100001],y[100001];\nmain(){scanf(\"%d\",&n);for(i=0;i<n;i++)scanf(\"%lf%lf\",x+i,y+i);m=999999;for(i=0;i<n;i++)for(j=i+1;j<n;j++)if(m>(z=(x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i])))m=z;printf(\"%.9f\\n\",sqrt(m));}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/50))  \n #define Fun2(j,n) for(int j=i+(int)(n/30);j<n;j=j+(int)(n/50))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=50000;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16??????????????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   //?°?16????????????????????????????????? \n   minx=minx-1;\n   miny=miny-1;\n   maxx=maxx+1;\n   maxy=maxy+1;\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=3;j>=0;j--)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*(3-j)+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n   /*\n   for(int i=0;i<16;i++)\n   {\n     for(int j=0;j<num_point[i];j++)\n     {\n       cout<<wu[i][j].x<<\" \"<<wu[i][j].y<<endl;        \n     }        \n   }\n   */\n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       //real_min=(point[0].x-point[1].x)*(point[0].x-point[1].x)+(point[0].y-point[1].y)*(point[0].y-point[1].y);\n       real_min=fun_min;\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A?????? \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    const int loops = 111;\n    \n    int n_1 = n - 1;\n    \n    for(int i = 0; i < n_1; i++)\n    {\n        int r = min(loops, n_1 - i);\n        \n        for(char j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n_1; i++)\n    {\n        int r = min(loops, n_1 - i);\n        \n        for(char j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + j].first - p2[i].first) * (p2[i + j].first - p2[i].first) + (p2[i + j].second - p2[i].second) * (p2[i + j].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.9f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(__typeof((o).begin()) it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T> >& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){EACH(a,ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;EACH(p,m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\ntemplate<> long double INF<long double>(){return 1e16;};\n\ntemplate<typename T> T pmod(T v,T M){return (v%M+M)%M;}\n\nnamespace _double_tmpl{\n    typedef long double D;const D EPS = 1e-8;\n    \n    static constexpr D Ae=0;\n    D A(D a,D b){return a+b;}D Ainv(D a){return -a;}\n    D S(D a,D b){return A(a,Ainv(b));}\n    \n    static constexpr D Me=1;\n    D M(D a,D b){return a*b;}D Minv(D a){return 1.0/a;};\n\n    int sig(D a,D b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n    bool eq(D a,D b){ return sig(abs(a-b))==0;}\n\n}\nusing namespace _double_tmpl;\n\n\nnamespace Ps{\n    // using namespace _double_tmpl;\n    typedef complex<D> P,Vec;\n\n#define X real()\n#define Y imag()\n    istream& operator >> (istream& is,complex<D>& p){\n        D x,y;is >> x >> y;p=P(x,y);return is;\n    }\n\n    bool eq(P a,P b){return eq(a.X,b.X) and eq(a.Y,b.Y);}\n    // a×b\n    D cross(const Vec& a,const Vec& b){return imag(conj(a)*b);}\n    // a・b\n    D dot(const Vec&a,const Vec& b) {return real(conj(a)*b);}\n\n    int ccw(const P& a,P b,P c){\n        b -= a; c -= a;\n        if (cross(b,c) > EPS)   return +1;       // counter clockwise\n        if (cross(b,c) < -EPS)   return -1;       // clockwise\n        if (dot(b,c) < 0)     return +2;       // c--a--b on line\n        if (norm(b) < norm(c)) return -2;       // a--b--c on line\n        return 0;\n    }\n\n    D closestPair(vector<P>& ps,int l,int r){\n        if(r-l<2)return INF<D>();\n        D res=INF<D>();\n        res=min(res,closestPair(ps,l,(l+r)/2));\n        res=min(res,closestPair(ps,(l+r)/2,r));\n        vector<P> lps,rps;\n        FOR(i,l,(l+r)/2)if(abs(ps[i].X - ps[(l+r)/2].X)<res && abs(ps[i].Y - ps[(l+r)/2].Y)<10*res)lps.push_back(ps[i]);\n        FOR(i,(l+r)/2,r)if(abs(ps[i].X - ps[(l+r)/2].X)<res && abs(ps[i].Y - ps[(l+r)/2].Y)<10*res)rps.push_back(ps[i]);\n\n        REP(i,lps.size())REP(j,rps.size())res=min(res,abs(lps[i]-rps[j]));\n        return res;\n    }\n}\nusing namespace Ps;\n\nnamespace std{\n    bool operator < (const P& a,const P& b){\n            return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n    bool operator == (const P& a,const P& b){\n            return eq(a,b);\n    }\n};\n\nstringstream ss;\nclass Main{\n    public:\n    void run(){\n        int n;cin >> n;\n        vector<P> ps;\n        REP(i,n) {\n            P p;cin >> p;\n            ps.push_back(p);\n        }\n        sort(ALL(ps));\n        cout << closestPair(ps,0,n)<<endl;\n    }\n};\n\nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <cstdio>\n#include <numeric>\n#include <functional>\n\nusing namespace std;\n\n//BEGIN\n#define EPS 1e-10\n#define equals(a, b) (fabs(a - b) < EPS)\n#define Pi 3.141592653589793238\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point {\n\tdouble x, y;\n\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(const double& k) const { return Point(x * k, y * k); }\n\tPoint operator/(const double& k) const { return Point(x / k, y / k); }\n\n\tfriend istream& operator>>(istream& is, Point& p) {\n\t\tis >> p.x >> p.y;\n\t\treturn is;\n\t}\n\n\tbool operator==(const Point& p) const { return (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS); }\n\tbool operator<(const Point& p) const { return (x != p.x ? x < p.x : y < p.y); }\n\n\tdouble norm() { return x * x + y * y; }\n\tdouble abs() { return sqrt(norm()); }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a) { return a.x * a.x + a.y * a.y; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\nbool isParallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool isOrthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\n\nstruct EndPoint {\n\tPoint p;\n\tint seg, st;\n\n\tEndPoint() {}\n\tEndPoint(Point p, int seg, int st) :p(p), seg(seg), st(st) {}\n\n\tbool operator<(const EndPoint& ep) const {\n\t\tif (p.y == ep.p.y) return st < ep.st;\n\t\treturn p.y < ep.p.y;\n\t}\n};\n\nstruct Segment {\n\tPoint p1, p2;\n\n\tSegment() {}\n\tSegment(Point p1, Point p2) :p1(p1), p2(p2) {}\n\n\tfriend istream& operator>>(istream& is, Segment& s) {\n\t\tis >> s.p1 >> s.p2;\n\t\treturn is;\n\t}\n};\n\ntypedef Segment Line;\n\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p) {\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\nstruct Circle {\n\tPoint c;\n\tdouble r;\n\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\treturn ON_SEGMENT;\n}\n\nbool intersectSS(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t\tccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersectSS(Segment s1, Segment s2) {\n\treturn intersectSS(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint intersectCS(Circle c, Segment s) {\n\tif (norm(project(s, c.c) - c.c) - c.r * c.r > EPS) return 0;\n\tdouble d1 = abs(c.c - s.p1), d2 = abs(c.c - s.p2);\n\tif (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n\tif ((d1 < c.r - EPS && d2 > c.r + EPS) || (d1 > c.r + EPS && d2 < c.r - EPS)) return 1;\n\tPoint h = project(s, c.c);\n\tif (dot(s.p1 - h, s.p2 - h) < 0) return 2;\n\treturn 0;\n}\n\nint intersectCC(Circle c1, Circle c2) {\n\tif (c1.r < c2.r) swap(c1, c2);\n\tdouble d = abs(c1.c - c2.c);\n\tdouble r = c1.r + c2.r;\n\tif (equals(d, r)) return 3;\n\tif (d > r) return 4;\n\tif (equals(d + c2.r, c1.r)) return 1;\n\tif (d + c2.r < c1.r) return 0;\n\treturn 2;\n}\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistanceSS(Segment s1, Segment s2) {\n\tif (intersectSS(s1, s2)) return 0.0;\n\treturn min({ getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2),\n\t\t\t   getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2) });\n}\n\nPoint getCrossPointLL(Line l1, Line l2) {\n\tdouble a = cross(l1.p2 - l1.p1, l2.p2 - l2.p1);\n\tdouble b = cross(l1.p2 - l1.p1, l1.p2 - l2.p1);\n\tif (abs(a) < EPS && abs(b) < EPS) return l2.p1;\n\treturn l2.p1 + (l2.p2 - l2.p1) * (b / a);\n}\n\nPoint getCrossPointSS(Segment s1, Segment s2) {\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1) * (d1 / (d1 + d2));\n}\n\nvector<Point> getCrossPointCL(Circle c, Line l) {\n\tvector<Point> ps;\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tif (equals(getDistanceLP(l, c.c), c.r)) {\n\t\tps.push_back(pr);\n\t\treturn ps;\n\t}\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\tps.push_back(pr + e * base); ps.push_back(pr - e * base);\n\treturn ps;\n}\n\nvector<Point> getCrossPointCS(Circle c, Segment s) {\n\tLine l(s);\n\tvector<Point> ps = getCrossPointCL(c, l);\n\tif (intersectCS(c, s) == 2) return ps;\n\tif (dot(l.p1 - ps[0], l.p2 - ps[0]) < 0) ps[1] = ps[0];\n\telse ps[0] = ps[1];\n\treturn ps;\n}\n\ndouble arg(Vector p) { return atan2(p.y, p.x); }\nPoint polar(double a, double r) { return Point(cos(r) * a, sin(r) * a); }\n\nvector<Point> getCrossPointCC(Circle c1, Circle c2) {\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\tvector<Point> ps;\n\tps.push_back(c1.c + polar(c1.r, t + a)); ps.push_back(c1.c + polar(c1.r, t - a));\n\treturn ps;\n}\n\nvector<Point> tangentCP(Circle c, Point p) {\n\treturn getCrossPointCC(c, Circle(p, sqrt(norm(c.c - p) - c.r * c.r)));\n}\n\nvector<Line> tangentCC(Circle c1, Circle c2) {\n\tvector<Line> ls;\n\tif (c1.r < c2.r) swap(c1, c2);\n\tdouble g = norm(c1.c - c2.c);\n\tif (equals(g, 0)) return ls;\n\tPoint u = (c2.c - c1.c) / sqrt(g);\n\tPoint v = Point(-u.y, u.x);\n\tfor (int s = 1; s >= -1; s -= 2) {\n\t\tdouble h = (c1.r + s * c2.r) / sqrt(g);\n\t\tif (equals(1, h * h)) ls.push_back(Line(c1.c + u * c1.r, c1.c + (u + v) * c1.r));\n\t\telse if (1 - h * h > 0) {\n\t\t\tPoint uu = u * h, vv = v * sqrt(1 - h * h);\n\t\t\tls.push_back(Line(c1.c + (uu + vv) * c1.r, c2.c - (uu + vv) * c2.r * s));\n\t\t\tls.push_back(Line(c1.c + (uu - vv) * c1.r, c2.c - (uu - vv) * c2.r * s));\n\t\t}\n\t}\n\treturn ls;\n}\n\n// IN:2,ON:1,OUT:0\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; ++i) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n\t}\n\treturn (x ? 2 : 0);\n}\n\nbool isConvex(Polygon p) {\n\tint n = p.size();\n\tfor (int i = 0; i < n; ++i)\n\t\tif (ccw(p[(i - 1 + n) % n], p[i], p[(i + 1) % n]) == CLOCKWISE) return false;\n\treturn true;\n}\n\nPolygon convexHull(Polygon p) {\n\tint n = p.size();\n\tsort(p.begin(), p.end(),\n\t\t [](const Point& a, const Point& b) {return (a.y != b.y ? a.y < b.y : a.x < b.x); });\n\tPolygon a(2 * n);\n\tint k = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\twhile (k > 1 && cross(a[k - 1] - a[k - 2], p[i] - a[k - 1]) < 0) k--;\n\t\ta[k++] = p[i];\n\t}\n\tfor (int i = n - 2, t = k; i >= 0; --i) {\n\t\twhile (k > t && cross(a[k - 1] - a[k - 2], p[i] - a[k - 1]) < 0) k--;\n\t\ta[k++] = p[i];\n\t}\n\ta.resize(k - 1);\n\treturn a;\n}\n\ndouble area(Polygon p) {\n\tdouble res = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i)\n\t\tres += cross(p[i], p[(i + 1) % p.size()]) / 2.0;\n\treturn res;\n}\n\ndouble area(Polygon p, Circle c) {\n\tif (p.size() < 3) return 0.0;\n\tfunction<double(Circle, Point, Point)> dfs = [&](Circle c, Point a, Point b) {\n\t\tVector va = c.c - a, vb = c.c - b;\n\t\tdouble f = cross(va, vb), res = 0;\n\t\tif (equals(f, 0.0)) return res;\n\t\tif (max(abs(va), abs(vb)) < c.r + EPS) return f;\n\t\tVector d(dot(va, vb), cross(va, vb));\n\t\tif (getDistanceSP(Segment(a, b), c.c) > c.r - EPS)\n\t\t\treturn c.r * c.r * atan2(d.y, d.x);\n\t\tauto u = getCrossPointCS(c, Segment(a, b));\n\t\tvector<Point> ps{ a,u[0],u[1],b };\n\t\tfor (int i = 1; i < ps.size(); ++i) res += dfs(c, ps[i - 1], ps[i]);\n\t\treturn res;\n\t};\n\tdouble res = 0;\n\tfor (int i = 0; i < (int)p.size(); ++i) res += dfs(c, p[i], p[(i + 1) % p.size()]);\n\treturn res / 2;\n}\n\ndouble convexDiameter(Polygon p) {\n\tint n = p.size();\n\tif (n == 2) return abs(p[0] - p[1]);\n\tint i = 0, j = 0;\n\tfor (int k = 0; k < n; ++k) {\n\t\tif (p[i] < p[k]) i = k;\n\t\tif (!(p[j] < p[k])) j = k;\n\t}\n\tdouble res = 0;\n\tint ti = i, tj = j;\n\twhile (i != tj || j != ti) {\n\t\tres = max(res, abs(p[i] - p[j]));\n\t\tif (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0.0)\n\t\t\ti = (i + 1) % n;\n\t\telse j = (j + 1) % n;\n\t}\n\treturn res;\n}\n\nPolygon convexCut(Polygon p, Line l) {\n\tPolygon q;\n\tfor (int i = 0; i < (int)p.size(); ++i) {\n\t\tPoint a = p[i], b = p[(i + 1) % p.size()];\n\t\tif (ccw(l.p1, l.p2, a) != CLOCKWISE) q.push_back(a);\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0)\n\t\t\tq.push_back(getCrossPointLL(Line(a, b), l));\n\t}\n\treturn q;\n}\n\ndouble closestPair(vector<Point> ps) {\n\tsort(ps.begin(), ps.end());\n\tvector<Point> a(ps.size());\n\tfunction<double(int, int)> solve = [&](int l, int r) {\n\t\tif (r - l < 2) return 1e18;\n\t\tint mid = (l + r) >> 1;\n\t\tdouble x = ps[mid].x;\n\t\tdouble d = min(solve(l, mid), solve(mid, r));\n\t\tinplace_merge(ps.begin() + l, ps.begin() + mid, ps.begin() + r,\n\t\t\t\t\t  [](const Point& a, const Point& b) {return a.y < b.y; });\n\t\tint ptr = 0;\n\t\tfor (int i = l; i < r; ++i) {\n\t\t\tif (abs(ps[i].x - x) >= d) continue;\n\t\t\tfor (int j = 0; j < ptr; ++j) {\n\t\t\t\tPoint luz = ps[i] - a[ptr - j - 1];\n\t\t\t\tif (luz.y >= d) break;\n\t\t\t\td = min(d, abs(luz));\n\t\t\t}\n\t\t\ta[ptr++] = ps[i];\n\t\t}\n\t\treturn d;\n\t};\n\treturn solve(0, ps.size());\n}\n\nint manhattanIntersection(vector<Segment> ss) {\n\tconst int INF = numeric_limits<int>::max();\n\tconst int BOTTOM = 0, LEFT = 1, RIGHT = 2, TOP = 3;\n\tint n = ss.size();\n\tvector<EndPoint> ep;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (ss[i].p1.y == ss[i].p2.y) {\n\t\t\tif (ss[i].p1.x > ss[i].p2.x) swap(ss[i].p1, ss[i].p2);\n\t\t\tep.push_back(EndPoint(ss[i].p1, i, LEFT));\n\t\t\tep.push_back(EndPoint(ss[i].p2, i, RIGHT));\n\t\t} else {\n\t\t\tif (ss[i].p1.y > ss[i].p2.y) swap(ss[i].p1, ss[i].p2);\n\t\t\tep.push_back(EndPoint(ss[i].p1, i, BOTTOM));\n\t\t\tep.push_back(EndPoint(ss[i].p2, i, TOP));\n\t\t}\n\t}\n\tsort(ep.begin(), ep.end());\n\tset<int> st;\n\tst.insert(INF);\n\tint cnt = 0;\n\tfor (int i = 0; i < 2 * n; ++i) {\n\t\tif (ep[i].st == TOP) st.erase(ep[i].p.x);\n\t\telse if (ep[i].st == BOTTOM) st.insert(ep[i].p.x);\n\t\telse if (ep[i].st == LEFT) {\n\t\t\tauto b = st.lower_bound(ss[ep[i].seg].p1.x);\n\t\t\tauto e = st.lower_bound(ss[ep[i].seg].p2.x);\n\t\t\tcnt += distance(b, e);\n\t\t}\n\t}\n\treturn cnt;\n}\n//END\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid CGL1A() {\n\tSegment s; cin >> s;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tPoint a = project(s, p);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_A\n*/\nvoid CGL1B() {\n\tSegment s; cin >> s;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tPoint a = reflect(s, p);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_B\n*/\nvoid CGL1C() {\n\tPoint p0, p1, p2; cin >> p0 >> p1;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tcin >> p2;\n\t\tint a = ccw(p0, p1, p2);\n\t\tif (a == COUNTER_CLOCKWISE) cout << \"COUNTER_CLOCKWISE\";\n\t\telse if (a == CLOCKWISE) cout << \"CLOCKWISE\";\n\t\telse if (a == ONLINE_BACK) cout << \"ONLINE_BACK\";\n\t\telse if (a == ONLINE_FRONT) cout << \"ONLINE_FRONT\";\n\t\telse cout << \"ON_SEGMENT\";\n\t\tcout << endl;\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_C\n*/\nvoid CGL2A() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tVector p0, p1, p2, p3;\n\t\tcin >> p0 >> p1 >> p2 >> p3;\n\t\tif (isParallel(p1 - p0, p3 - p2)) cout << 2;\n\t\telse if (isOrthogonal(p1 - p0, p3 - p2)) cout << 1;\n\t\telse cout << 0;\n\t\tcout << endl;\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_A\n*/\nvoid CGL2B() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tcout << (intersectSS(s1, s2) ? 1 : 0) << endl;\n\t}\n}/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_B\n*/\nvoid CGL2C() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tPoint a = getCrossPointLL(s1, s2);\n\t\tprintf(\"%.10f %.10f\\n\", a.x, a.y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_C\n*/\nvoid CGL2D() {\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tSegment s1, s2;\n\t\tcin >> s1 >> s2;\n\t\tprintf(\"%.10f\\n\", getDistanceSS(s1, s2));\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_D\n*/\nvoid CGL3A() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.1f\\n\", area(p));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_A\n*/\nvoid CGL3B() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tcout << (isConvex(p) ? 1 : 0) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_B\n*/\nvoid CGL3C() {\n\tint n; cin >> n;\n\tPolygon g(n);\n\tfor (auto& a : g) cin >> a;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tPoint p; cin >> p;\n\t\tcout << contains(g, p) << endl;\n\t}\n}/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_C\n*/\nvoid CGL4A() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tPolygon t = convexHull(p);\n\tcout << t.size() << endl;\n\tfor (auto a : t) cout << a.x << \" \" << a.y << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_A\n*/\nvoid CGL4B() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.10f\\n\", convexDiameter(p));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_B\n*/\nvoid CGL4C() {\n\tint n; cin >> n;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tLine l; cin >> l;\n\t\tprintf(\"%.10f\\n\", area(convexCut(p, l)));\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_C\n*/\nvoid CGL5A() {\n\tint n; cin >> n;\n\tvector<Point> ps(n);\n\tfor (auto& a : ps) cin >> a;\n\tprintf(\"%.10f\\n\", closestPair(ps));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/5/CGL_5_A\n*/\nvoid CGL6A() {\n\tint n; cin >> n;\n\tvector<Segment> ss(n);\n\tfor (auto& a : ss) cin >> a;\n\tcout << manhattanIntersection(ss) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/6/CGL_6_A\n*/\nvoid CGL7A() {\n\tCircle c1, c2; cin >> c1.c >> c1.r >> c2.c >> c2.r;\n\tcout << intersectCC(c1, c2) << endl;\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_A\n*/\n\nvoid CGL7D() {\n\tCircle c; cin >> c.c.x >> c.c.y >> c.r;\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tLine l; cin >> l.p1.x >> l.p1.y >> l.p2.x >> l.p2.y;\n\t\tauto a = getCrossPointCL(c, l);\n\t\tsort(a.begin(), a.end());\n\t\tprintf(\"%.10f %.10f %.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n\t}\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_D\n*/\nvoid CGL7E() {\n\tCircle c1; cin >> c1.c.x >> c1.c.y >> c1.r;\n\tCircle c2; cin >> c2.c.x >> c2.c.y >> c2.r;\n\tauto a = getCrossPointCC(c1, c2);\n\tsort(a.begin(), a.end());\n\tprintf(\"%.10f %.10f %.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_E\n*/\nvoid CGL7F() {\n\tPoint p; cin >> p;\n\tCircle c; cin >> c.c >> c.r;\n\tauto a = tangentCP(c, p);\n\tsort(a.begin(), a.end());\n\tprintf(\"%.10f %.10f\\n%.10f %.10f\\n\", a[0].x, a[0].y, a[1].x, a[1].y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_F\n*/\nvoid CGL7G() {\n\tCircle c1, c2; cin >> c1.c >> c1.r >> c2.c >> c2.r;\n\tauto a = tangentCC(c1, c2);\n\tvector<Point> ps;\n\tfor (auto e : a) ps.push_back(getCrossPointCL(c1, e)[0]);\n\tsort(ps.begin(), ps.end());\n\tfor (auto e : ps) printf(\"%.10f %.10f\\n\", e.x, e.y);\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_G\n*/\nvoid CGL7H() {\n\tint n; cin >> n;\n\tCircle c; c.c = Point(0, 0); cin >> c.r;\n\tPolygon p(n);\n\tfor (auto& a : p) cin >> a;\n\tprintf(\"%.10f\\n\", area(p, c));\n}\n/*\n\tcreated: 2019-09-13\n\thttps://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_H\n*/\n\nint main() {\n\t//CGL1A();\n\t//CGL1B();\n\t//CGL1C();\n\t//CGL2A();\n\t//CGL2B();\n\t//CGL2C();\n\t//CGL2D();\n\t//CGL3A();\n\t//CGL3B();\n\t//CGL3C();\n\t//CGL4A();\n\t//CGL4B();\n\t//CGL4C();\n\tCGL5A();\n\t//CGL6A();\n\t//CGL7A();\n\t//CGL7D();\n\t//CGL7E();\n\t//CGL7F();\n\t//CGL7G();\n\t//CGL7H();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\ntypedef Point Vec;\ntypedef array<Point, 2> Line;\ntypedef vector<Point> Poly;\n\nstruct Circle {\n  Point c;\n  double r;\n};\n\nenum Geometory {ABC=-2, CW, ON_LINE, CCW, CAB, OUTSIDE, INSIDE, ERROR}; \n\nnamespace std {\n  bool operator<(Point a, Point b) {\n    if (a.X != b.X) return a.X < b.X;\n    return a.Y < b.Y;\n  }\n}\n\ndouble dot(Point a, Point b) {\n  return (conj(a)*b).X;\n}\n\ndouble cross(Point a, Point b) {\n  return (conj(a)*b).Y;\n}\n\nGeometory ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) return CCW; // ccw\n  if (cross(b, c) < 0) return CW; // cw\n  if (dot(b, c) < 0) return CAB; // c - a - b\n  if (norm(b) < norm(c)) return ABC; // a - b - c\n  return ERROR;\n}\n\nPoint proj(Line l, Point p) {\n  Point v = l[1]-l[0];\n  double ratio = dot(v, p-l[0]) / norm(v);\n  return l[0] + ratio*v;\n}\n\nPoint refl(Line l, Point p) {\n  return p + (proj(l, p) - p) * 2.0;\n}\n\nVec rotate(Vec v, double r) {\n  return v*Vec(cos(r), sin(r));\n}\n\nbool IsOrthogonal(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(dot(v1, v2), 0.0);\n}\n\nbool IsParallel(Line l, Line m) {\n  Vec v1 = l[1]-l[0];\n  Vec v2 = m[1]-m[0];\n  return EQ(cross(v1, v2), 0.0);\n}\n\nbool IntersectLL(Line l, Line m) {\n  if (!EQ(cross(l[1]-l[0], m[1]-m[0]), 0.0)) return true;\n  if (EQ(cross(l[1]-l[0], m[0]-l[0]), 0.0)) return true;\n  return false;\n}\n\nbool IntersectLS(Line l, Line s) {\n  Point b = l[0];\n  Vec v = l[1]-l[0];\n  return cross(v, s[0]-b)*cross(v, s[1]-b) < EPS;\n}\n\nbool IntersectSS(Line s, Line t) {\n  if (ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) > 0) return false;\n  if (ccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) > 0) return false;\n  return true;\n}\n\nbool IntersectLP(Line l, Point p) {\n  return EQ(cross(l[1]-p, l[0]-p), 0.0);\n}\n\nbool IntersectSP(Line s, Point p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\ndouble DistL(Line l) {\n  return abs(l[0]-l[1]);\n}\n\ndouble DistLP(Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\ndouble DistLL(Line l, Line m) {\n  if (!IntersectLL(l, m)) return 0;\n  return DistLP(l, m[0]);\n}\n\ndouble DistLS(Line l, Line s) {\n  if (IntersectLS(l, s)) return 0;\n  return min(DistLP(l, s[0]), DistLP(l, s[1]));\n}\n\ndouble DistSP(Line s, Point p) {\n  Point r = proj(s, p);\n  if (IntersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\ndouble DistSS(Line s, Line t) {\n  if (IntersectSS(s, t)) return 0;\n\n  double a = min(DistSP(s, t[0]), DistSP(s, t[1]));\n  double b = min(DistSP(t, s[0]), DistSP(t, s[1]));\n  return min(a, b);\n}\n\nLine PerpendBisect(Line seg) {\n  Point mid = (seg[0]+seg[1])/2.0;\n  return Line{mid, mid+(seg[1]-seg[0])*Vec(0, 1)};\n}\n\nPoint CrossPointLL(Line l, Line m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0];\n  if (abs(A) < EPS) assert(0);\n  return m[0] + B / A * (m[1]-m[0]);\n}\n\nvector<Point> CrossPointCL(Circle c, Line l) {\n  vector<Point> ret;\n  double d = DistLP(l, c.c);\n  if (d < c.r + EPS) {\n    double ratio = (d > c.r) ? 0.0 : sqrt(c.r*c.r - d*d);\n    Vec sgn = (l[0]-l[1]) / abs(l[0]-l[1]);\n    ret.push_back(proj(l, c.c) + ratio*sgn);\n    ret.push_back(proj(l, c.c) - ratio*sgn);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCS(Circle c, Line s) {\n  vector<Point> ret;\n  vector<Point> res = CrossPointCL(c, s);\n  for (Point p : res) {\n    if(ccw(s[0], p, s[1]) == ABC) ret.push_back(p);\n  }\n  return ret;\n}\n\nvector<Point> CrossPointCC(Circle c1, Circle c2) {\n  vector<Point> ret;\n  double d = abs(c1.c - c2.c);\n  double rc = (d*d + c1.r*c1.r - c2.r*c2.r) / (2*d);\n  double dfr = c1.r*c1.r - rc*rc;\n\n  if (EQ(dfr, 0.0)) dfr = 0.0;\n  else if(dfr < 0.0) return ret;\n\n  double rs = sqrt(dfr);\n  Vec sgn = (c2.c - c1.c) / d;\n  ret.push_back(c1.c + sgn*Point(rc, rs));\n  if (dfr > 0.0) ret.push_back(c1.c + sgn*Point(rc, -rs));\n  return ret;\n}\n\n// Note that ccw(a, b, c) != CCW when a, b, c are colinear\nPoly GrahamScan(vector<Point> ps) {\n  int k = 0;\n  int n = ps.size();\n  Poly ret(n*2);\n\n  sort(ps.begin(), ps.end());\n  for (int i=0; i<n; i++) {\n    while (k > 1 && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  int k_ = k;\n  for (int i=n-1; i>=0; i--) {\n    while (k > k_ && ccw(ret[k-2], ret[k-1], ps[i]) != CCW) k--;\n    ret[k++] = ps[i];\n  }\n\n  ret.resize(k-1);\n  return ret;\n}\n\ndouble CalcArea(Poly ps) {\n  double ret = 0.0;\n  for (int i=0; i<ps.size(); i++) {\n    ret += cross(ps[i], ps[(i+1)%ps.size()]);\n  }\n  return ret/2.0;\n}\n\nbool IsConvex(Poly ps) {\n  return GrahamScan(ps).size() == ps.size();\n}\n\nGeometory ContainsPoint(Poly poly, Point p) {\n  bool in = false;\n  int n = poly.size();\n  for (int i=0; i<n; i++) {\n    Point a = poly[i];\n    Point b = poly[(i+1)%n];\n    Vec u = a - p;\n    Vec v = b - p;\n    double cr = cross(u, v);\n\n    if (u.Y <= 0 && 0 < v.Y && cr > EPS) in ^= 1;\n    if (v.Y <= 0 && 0 < u.Y && cr < -EPS) in ^= 1;\n    if (IntersectSP({a, b}, p)) return ON_LINE;\n  }\n\n  if (in) return INSIDE;\n  return OUTSIDE;\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\npair<int, int> ConvexDiameterApexes(Poly ps) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  int n = ps.size();\n  int is = 0;\n  int js = 0;\n  for (int i=1; i<n; i++) {\n    if (ps[i].Y > ps[is].Y) is = i;\n    if (ps[i].Y < ps[js].Y) js = i;\n  }\n\n  int maxi, maxj;\n  double maxd = norm(ps[is]-ps[js]);\n  int i = is;\n  int j = js;\n  do {\n    Vec a = ps[i+1] - ps[i];\n    Vec b = ps[j+1] - ps[j];\n    if (cross(a, b) > -EPS) j = (j+1)%n;\n    else i = (i+1)%n;\n\n    double d = norm(ps[i]-ps[j]);\n    if (d > maxd) {\n      maxd = d;\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n\n  return make_pair(maxi, maxj);\n}\n\nLine ClosestPair(vector<Point> ps) {\n  auto CompareY = [](const Point &a, const Point &b) {\n    if (a.Y != b.Y) return a.Y < b.Y;\n    return a.X < b.X;\n  };\n\n  function<Line(Point*,int)> Rec = [&Rec, &CompareY](Point *as, int n) {\n    if (n <= 1) return Line{Point(0, 0), Point(INF, INF)};\n    \n    int m = n/2;\n    double x = as[m].X;\n    Line a = Rec(as, m);\n    Line b = Rec(as+m, n-m);\n    double mind = DistL(a);\n    Line ret = a;\n    if (DistL(b) < mind) {\n      mind = DistL(b);\n      ret = b;\n    }\n\n    sort(as, as+n, CompareY);\n    vector<Point> bs;\n    bs.reserve(n);\n    for (int i=0; i<n; i++) {\n      if (abs(as[i].X - x) >= mind) continue;\n\n      for (int j=0; j<bs.size(); j++) {\n        Point p1 = as[i];\n        Point p2 = bs[b.size()-1-j];\n        if (p1.Y - p2.Y >= mind) break;\n\n        double d = abs(p1-p2);\n        if (mind > d) {\n          mind = d;\n          ret = Line{p1, p2};\n        }\n      }\n\n      bs.emplace_back(as[i]);\n    }\n\n    return ret;\n  };\n\n  int n = ps.size();\n  assert (n >= 2);\n  sort(ps.begin(), ps.end());\n  return Rec(&ps[0], n);\n}\n\n// Convex* requires the elements of ps to be arranged counter clockwise.\n// <left, right> or <upper, lower>\npair<Poly, Poly> CutConvex(Poly ps, Line l) {\n#if DEBUG\n  assert (IsConvex(ps));\n#endif\n\n  //if (l[0].Y > l[1].Y) swap(l[0], l[1]);\n  //else if (EQ(l[0].Y, l[1].Y) && l[0].X > l[1].X) swap(l[0], l[1]);\n\n  Poly left;\n  Poly right;\n  for (int i=0; i<ps.size(); i++) {\n    Point a = ps[i];\n    Point b = ps[(i+1)%ps.size()];\n\n    if (ccw(l[0], l[1], a) != CW) left.emplace_back(a);\n    else right.emplace_back(a);\n\n    Line m{a, b};\n    if (IntersectLS(l, m)) {\n      Point p = CrossPointLL(l, m);\n      left.emplace_back(p);\n      right.emplace_back(p);\n    }\n  }\n\n  return make_pair(left, right);\n}\n\nint main() {\n  int n;\n  vector<Point> ps;\n\n  scanf(\"%d\", &n);\n  for (int i=0; i<n; i++) {\n    double x, y;\n    scanf(\"%lf%lf\", &x, &y);\n    ps.emplace_back(Point{x, y});\n  }\n\n  Line l = ClosestPair(ps);\n  printf(\"%.10f\\n\", DistL(l));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nint dcmp(double d) {\n    if (fabs(d) < EPS) {\n        return 0;\n    }\n    else {\n        return d < 0? -1 : 1;\n    }\n}\n\nstruct Vector {\n    double x, y;\n    Vector(double x = 0, double  y = 0):x(x), y(y) {\n    }\n     \n    bool operator<(const Vector& other) const {\n        return dcmp(x - other.x) < 0 || (dcmp(x - other.x) == 0 && dcmp(y - other.y) < 0);\n    }\n};\n\ntypedef Vector Point;\n\ndouble dist(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nbool cmpY(const Point& a,  const Point& b) {\n    return dcmp(a.y - b.y) < 0 || (dcmp(a.y - b.y) == 0 && dcmp(a.x - b.x) < 0);\n}\n\ndouble combine(vector<Point>& p, int l, int m, int r, double leftSmall, double rightSmall) {\n    double d = min(leftSmall, rightSmall);\n    double x = (p.at(m).x + p.at(m + 1).x)/2;\n    \n    vector<Point> strip;\n        \n    for (int i = m; i >= l && dcmp(x - p.at(i).x - d) <= 0; i--) {\n        strip.push_back(p.at(i));\n    }\n    for (int j = m + 1; j <= r &&dcmp(p.at(j).x - x - d) <= 0; j++) {\n        strip.push_back(p.at(j));\n    } \n    \n    sort(strip.begin(), strip.end(), cmpY);\n    \n    int size = strip.size();\n    \n    for (int i = 0; i < size; i++) {\n        for (int j = i+1; j < size && dcmp(strip[j].y - strip[i].y - d) < 0; j++) {\n            if (dcmp(dist(strip[i], strip[j]) - d) < 0) {\n                d = dist(strip[i], strip[j]);\n            }\n        }\n    }\n    return d;\n}\n\n//naive n^2 method\ndouble combine1(vector<Point>& p, int l, int m, int r, double leftSmall, double rightSmall) {\n    double d = min(leftSmall, rightSmall);\n    double x = (p.at(m).x + p.at(m + 1).x)/2;\n    \n    double best = DBL_MAX;\n    \n    for (int i = m; i >= l && dcmp(x - p.at(i).x - d) <= 0; i--) {\n        for (int j = m + 1; j <= r &&dcmp(p.at(j).x - x - d) <= 0; j++) {\n            best = min(best, dist(p.at(i), p.at(j)));\n        } \n    }\n    return min(best, d);\n}\n\n\ndouble solve(vector<Point>& p, int l, int r) {\n    if (l >= r) {\n        return DBL_MAX;\n    }\n    int m = (l + r) / 2;\n    \n    double leftSmall = solve(p, l, m);\n    double rightSmall = solve(p, m + 1, r);\n    \n    return combine(p, l, m, r, leftSmall, rightSmall);\n}\n\nint main() {\n    int n; \n    cin >> n;\n    vector<Point> p(n);\n    for (int i = 0; i < n; i++) {\n        cin >> p[i].x >> p[i].y;\n    }\n    \n    sort(p.begin(), p.end());\n    \n    double ans = solve(p, 0, n - 1);\n    \n    cout << fixed << setprecision(8) << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return norm( B - A ); }\n\nint n;\nlf d;\npt Px[ MAXN ];\nvector< pt> Py;\n\nbool cmpX( const pt &A, const pt &B ) {\n  return B.x > A.x + EPS;\n}\n\nbool cmpY( const pt &A, const pt &B ) {\n  return B.y > A.y + EPS;\n}\n\nvoid merge( pt *P, int n, lf &d ) {\n  for( int i = 0; i < n; ++i ) {\n    for( int j = i+1; j < n && (P[j].y - P[i].y)*(P[j].y - P[i].y) + EPS < d ; ++j ) {\n      d = min( d, dist( P[i], P[j]) );\n    }\n  }\n}\n\nvoid solve( pt *Px, vector<pt> &Py, int n, lf &d ) {\n  if( n <= 3 ) {\n    for( int i = 0; i < n; ++i ) {\n      for( int j = i+1; j < n; ++j ) {\n        d = min( d, dist(Px[i], Px[j]) );\n      }\n    }\n    return;\n  }\n  int mi = n/2;\n  vector<pt> Pl, Pr;\n  for( int i = 0; i < n; ++i ) {\n    if( Py[i].x+EPS < Px[mi].x ) {\n      Pl.PB( Py[ i ] );\n    }\n    else {\n      Pr.PB( Py[ i ] );\n    }\n  }\n\n  solve( Px, Pl, SIZE( Pl ), d );\n  solve( Px+SIZE( Pl ), Pr, SIZE( Pr ), d );\n\n  pt extra[ n ];\n  int k = 0;\n  for( auto &p : Py ) {\n    if( abs( p.x - Px[mi].x ) + EPS < d ) {\n      extra[ k++ ] = p;\n    }\n  }\n\n  merge( extra, n, d );\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> Px[i];\n    Py.PB( Px[ i ] );\n  }\n  sort( Px, Px+n, cmpX );\n  sort( Py.begin(), Py.end(), cmpY );\n  d = oo;\n  solve( Px, Py, n, d );\n  cout << double(sqrt(d)) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <climits>\nusing namespace std;\n\ntypedef pair<double, double> P;\n\ndouble getClosestPairVirtical(vector<P> &v, int s, int t){\n    double d = INT_MAX;\n    for(int i=s+1; i<t; i++){\n        d = min(d, v[i].second-v[i-1].second);\n    }\n    return d;\n}\n\nbool inRange(double v, double l, double r){\n    return l<=v && v<=l;\n}\n\nbool compare_y(P a, P b){\n    return a.second < b.second;\n}\n\ndouble getClosestPair(vector<P> &v, int s, int t){\n    if(t-s==1) return INT_MAX;\n    if(v[s].first == v[t-1].first) return getClosestPairVirtical(v, s, t);\n    const double mid = (v[s].first+v[t-1].first)/2;\n    int midPos;\n    for(midPos=s; midPos<t && v[midPos].first<mid; midPos++);\n    const double d1 = getClosestPair(v, s, midPos);\n    const double d2 = getClosestPair(v, midPos, t);\n    double d = min(d1, d2);\n    inplace_merge(v.begin()+s, v.begin()+mid, v.begin()+t, compare_y);\n    vector<P> use;\n    for(int i=s; i<t; i++){\n        if(fabs(v[i].first-mid)>d) continue;\n        for(int j=use.size()-1; j>=0; j--){\n            if(fabs(v[i].second-use[j].second)>d) break;\n            double dx = v[i].first-use[j].first;\n            double dy = v[i].second-use[j].second;\n            d = min(d, sqrt(dx*dx + dy*dy));\n        }\n        use.push_back(v[i]);\n    }\n    return d;\n}\n\nint main(){\n    int n;\n    double x, y;\n    cin >> n;\n    vector<P> v;\n    for(int i=0; i<n; i++){\n        P p;\n        cin >> p.first >> p.second;\n        v.push_back(p);\n    }\n    sort(v.begin(), v.end());\n    printf(\"%lf\\n\",getClosestPair(v, 0, v.size()));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<iomanip>\n#include<utility>\n#include<cmath>\n#include<set>\nusing namespace std;\ntypedef long long int ll;\nconst double EPS=1e-10;\n\nbool equals(double a,double b)\n{\n\treturn a>b?a-b<EPS:b-a<EPS;\n}\n\nclass Point\n{\npublic:\n\tdouble x;\n\tdouble y;\n\tPoint(double inx=0.0,double iny=0.0):x(inx),y(iny){}\n\tPoint operator+(const Point &p){return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p){return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k){return Point(x*k,y*k);}\n\tPoint operator/(const double k){return Point(x/k,y/k);}\n\tPoint operator=(const Point &p){x=p.x;y=p.y;return *this;}\n\tbool operator<(const Point &p)const{return x!=p.x?x<p.x:y<p.y;}\n\tbool operator==(const Point &p)const{return equals(x,p.x)&&equals(y,p.y);}\n\tdouble norm()\n\t{\n\t\treturn x*x+y*y;\n\t}\n\tdouble abs()\n\t{\n\t\treturn sqrt(norm());\n\t}\n};\n\ntypedef Point Vector;\n\nclass Segment\n{\npublic:\n\tPoint p1;\n\tPoint p2;\n\tVector getvector()\n\t{\n\t\treturn p2-p1;\n\t}\n};\n\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point inc=Point(),double inr=0.0):c(inc),r(inr){}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble dot(Vector a,Vector b)\n{\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b)\n{\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble norm(Vector a)\n{\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a)\n{\n\treturn sqrt(norm(a));\n}\n\nconst int counter_clockwise=1;\nconst int clockwise=-1;\nconst int on_segment=0;\nconst int online_back=2;\nconst int online_front=-2;\n\nbool isorthogonal(Vector a,Vector b)\n{\n\treturn equals(dot(a,b),0.0);\n}\n\nbool isorthogonal(Point a1,Point a2,Point b1,Point b2)\n{\n\treturn isorthogonal(a1-a2,b1-b2);\n}\n\nbool isorthogonal(Segment s1,Segment s2)\n{\n\treturn equals(dot(s1.getvector(),s2.getvector()),0.0);\n}\n\nbool isparallel(Vector a,Vector b)\n{\n\treturn equals(cross(a,b),0.0);\n}\n\nbool isparallel(Point a1,Point a2,Point b1,Point b2)\n{\n\treturn isparallel(a1-a2,b1-b2);\n}\n\nbool isparallel(Segment s1,Segment s2)\n{\n\treturn equals(cross(s1.getvector(),s2.getvector()),0.0);\n}\n\nPoint project(Segment s,Point p)\n{\n\tVector base=s.getvector();\n\tdouble r=dot(p-s.p1,base)/norm(base);\n\treturn s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p)\n{\n\treturn project(s,p)*2.0-p;//p+(project(s,p)-p)*2.0\n}\n\ndouble getdistance(Point a,Point b)\n{\n\treturn abs(a-b);\n}\n\ndouble getdistancelp(Line l,Point p)//Line,Point\n{\n\tdouble s=abs(cross(l.p2-l.p1,p-l.p1));\n\treturn s/abs(l.getvector());\n}\n\ndouble getdistancesp(Segment s,Point p)\n{\n\tif(dot(s.getvector(),p-s.p1)<0.0)return abs(p-s.p1);\n\telse if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n\telse return getdistancelp(s,p);\n}\n\nint ccw(Point p0,Point p1,Point p2)\n{\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return counter_clockwise;\n\telse if(cross(a,b)<-EPS)return clockwise;\n\telse if(dot(a,b)<-EPS)return online_back;\n\telse if(a.norm()<b.norm())return online_front;\n\telse return on_segment;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4)\n{\n\treturn ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersect(Segment s1,Segment s2)\n{\n\treturn intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getdistance(Segment s1,Segment s2)\n{\n\tif(intersect(s1,s2))return 0.0;\n\telse return min(min(getdistancesp(s1,s2.p1),getdistancesp(s1,s2.p2)),\n\t\t\tmin(getdistancesp(s2,s1.p1),getdistancesp(s2,s1.p2)));\n}\n\nPoint getcrosspoint(Segment s1,Segment s2)\n{\n\tVector base=s2.getvector();\n\tdouble d1=abs(cross(base,s1.p1-s2.p1));\n\tdouble d2=abs(cross(base,s1.p2-s2.p1));\n\tdouble t=d1/(d1+d2);\n\treturn s1.p1+s1.getvector()*t;\n}\n\npair<Point,Point> getcrosspoint(Circle c,Line l)\n{\n\tVector pr=project(l,c.c);\n\tVector e=l.getvector()/abs(l.getvector());\n\tdouble base=sqrt(c.r*c.r-norm(pr-c.c));\n\treturn make_pair(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p)\n{\n\treturn atan2(p.y,p.x);\n}\n\nPoint polar(double r,double theta)\n{\n\treturn Point(r*cos(theta),r*sin(theta));\n}\n\npair<Point,Point> getcrosspoint(Circle c1,Circle c2)\n{\n\tdouble d=abs(c2.c-c1.c);\n\tdouble a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2.0*c1.r*d));\n\tdouble t=arg(c2.c-c1.c);\n\treturn make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint intersect(Circle c1,Circle c2)\n{\n\tdouble d=abs(c2.c-c1.c);\n\tif(equals(d,c1.r+c2.r))return 3;\n\telse if(d>c1.r+c2.r)return 4;\n\telse if(equals(d,abs(c1.r-c2.r)))return 1;\n\telse if(d>abs(c1.r-c2.r))return 2;\n\telse return 0;\n}\n\npair<Point,Point> gettangentpoint(Circle c,Point p)\n{\n\tdouble d=abs(p-c.c);\n\tdouble l=sqrt(d*d-c.r*c.r);\n\tdouble a=asin(c.r/d);\n\tdouble t=arg(c.c-p);\n\treturn make_pair(p+polar(l,t+a),p+polar(l,t-a));\n}\n\nvector<Point> gettangentpoint(Circle c1,Circle c2)\n{\n\tvector<Point> p;\n\tint n=intersect(c1,c2);\n\tdouble d=abs(c2.c-c1.c);\n\tdouble t=arg(c2.c-c1.c);\n\tdouble a;\n\t\n\tif(n==1||n==3)\n\t{\n\t\tif(c1.r<c2.r&&n==1)p.push_back(c1.c-(c2.c-c1.c)*c1.r/d);\n\t\telse p.push_back(c1.c+(c2.c-c1.c)*c1.r/d);\n\t}\n\tif(n==2||n==3||n==4)\n\t{\n\t\ta=acos((c1.r-c2.r)/d);\n\t\tp.push_back(c1.c+polar(c1.r,t+a));\n\t\tp.push_back(c1.c+polar(c1.r,t-a));\n\t}\n\tif(n==4)\n\t{\n\t\ta=acos((c1.r+c2.r)/d);\n\t\tp.push_back(c1.c+polar(c1.r,t+a));\n\t\tp.push_back(c1.c+polar(c1.r,t-a));\n\t}\n\t\n\tsort(p.begin(),p.end());\n\treturn p;\n}\n\ndouble area(Polygon p)\n{\n\tint n=p.size();\n\tdouble sum=0.0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tsum+=0.5*cross(p[i],p[i%n]);\n\t}\n\treturn sum<0.0?-sum:sum;\n}\n\nbool isconvex(Polygon p)\n{\n\tint n=p.size(),now;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tnow=ccw(p[i],p[(i+1)%n],p[(i+2)%n]);\n\t\tif(now==clockwise)return false;\n\t}\n\treturn true;\n}\n\nconst int in=2;\nconst int on=1;\nconst int out=0;\n\nint contain(Polygon g,Point p)\n{\n\tint n=g.size();\n\tbool x=false;\n\tPoint a,b;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ta=g[i]-p;\n\t\tb=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return on;\n\t\tif(a.y>b.y)\n\t\t{\n\t\t\tPoint sto=a;\n\t\t\ta=b;\n\t\t\tb=sto;\n\t\t}\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)x=!x;\n\t}\n\treturn x?in:out;\n}\n\nPolygon andrewscan(Polygon s)\n{\n\tPolygon u,l;\n\tif(s.size()<=2)return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\t\n\tfor(int i=2;i<s.size();i++)\n\t{\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=clockwise;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\t\n\tfor(int i=s.size()-3;i>=0;i--)\n\t{\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=clockwise;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\t\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\t\n\treturn l;\n}\n\nconst int Bottom=0;\nconst int Left=1;\nconst int Right=2;\nconst int Top=3;\n\nclass endPoint\n{\npublic:\n\tPoint p;\n\tint seg;//ID of Point\n\tint st;//kind of Point\n\tendPoint(){}\n\tendPoint(Point inp,int inseg,int inst):p(inp),seg(inseg),st(inst){}\n\tbool operator<(const endPoint &ep)const\n\t{\n\t\tif(p.y==ep.p.y)\n\t\t{\n\t\t\treturn st<ep.st;//Bottom->Left->Right->Top\n\t\t}\n\t\telse return p.y<ep.p.y;\n\t}\n};\n\nendPoint EP[200000];\n\nint manhattanintersection(vector<Segment> s)\n{\n\tint n=s.size();\n\tdouble sto;\n\t\n\tfor(int i=0,k=0;i<n;i++)\n\t{\n\t\tif(s[i].p1.y==s[i].p2.y)\n\t\t{\n\t\t\tif(s[i].p1.x>s[i].p2.x)\n\t\t\t{\n\t\t\t\tsto=s[i].p1.x;\n\t\t\t\ts[i].p1.x=s[i].p2.x;\n\t\t\t\ts[i].p2.x=sto;\n\t\t\t}\n\t\t}\n\t\telse if(s[i].p1.y>s[i].p2.y)\n\t\t{\n\t\t\tsto=s[i].p1.y;\n\t\t\ts[i].p1.y=s[i].p2.y;\n\t\t\ts[i].p2.y=sto;\n\t\t}\n\t\t\n\t\tif(s[i].p1.y==s[i].p2.y)\n\t\t{\n\t\t\tEP[k++]=endPoint(s[i].p1,i,Left);\n\t\t\tEP[k++]=endPoint(s[i].p2,i,Right);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEP[k++]=endPoint(s[i].p1,i,Bottom);\n\t\t\tEP[k++]=endPoint(s[i].p2,i,Top);\n\t\t}\n\t}\n\t\n\tsort(EP,EP+2*n);\n\t\n\tset<int> BT;\n\tBT.insert(1000000001);\n\tint cnt=0;\n\t\n\tfor(int i=0;i<2*n;i++)\n\t{\n\t\tif(EP[i].st==Top)BT.erase(EP[i].p.x);\n\t\telse if(EP[i].st==Bottom)BT.insert(EP[i].p.x);\n\t\telse if(EP[i].st==Left)\n\t\t{\n\t\t\tset<int>::iterator b=lower_bound(BT.begin(),BT.end(),s[EP[i].seg].p1.x);\n\t\t\tset<int>::iterator e=upper_bound(BT.begin(),BT.end(),s[EP[i].seg].p2.x);\n\t\t\tcnt+=distance(b,e);\n\t\t}\n\t}\n\t\n\treturn cnt;\n}\n\ndouble diameter(Polygon p)\n{\n\tint n=p.size();\n\tif(n<=1)return 0.0;\n\telse if(n==2)return abs(p[1]-p[0]);\n\t\n\tint i=0,j=0;\n\tfor(int k=0;k<n;k++)\n\t{\n\t\tif(p[k].x<p[i].x)i=k;\n\t\telse if(p[k].x>p[j].x)j=k;\n\t}\n\t\n\tdouble ans=0.0;\n\tint si=i,sj=j;\n\t\n\twhile(i!=sj||j!=si)\n\t{\n\t\tans=max(ans,abs(p[i]-p[j]));\n\t\tif(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0)i=(i+1)%n;\n\t\telse j=(j+1)%n;\n\t}\n\t\n\treturn ans;\n}\n\nconst double INF_double=1e12;\n\ndouble closestpair_cal(Point p[],int n)\n{\n\tif(n<=1)return INF_double;\n\tint m=n/2;\n\tdouble x=p[m].x;\n\tdouble d=min(closestpair_cal(p,m),closestpair_cal(p+m,n-m));\n\tinplace_merge(p,p+m,p+n,[](const Point p1,const Point p2){return p1.y==p2.y?p1.x<p2.x:p1.y<p2.y;});\n\t\n\tvector<Point> q;\n\tdouble dx,dy;\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(abs(p[i].x-x)>=d)continue;\n\t\t\n\t\tfor(int j=q.size()-1;j>=0;j--)\n\t\t{\n\t\t\tdx=p[i].x-q[j].x;\n\t\t\tdy=p[i].y-q[j].y;\n\t\t\tif(dy>=d)break;\n\t\t\td=min(d,sqrt(dx*dx+dy*dy));\n\t\t}\n\t\tq.push_back(p[i]);\n\t}\n\t\n\treturn d;\n}\n\ndouble closestpair(Point p[],int n)\n{\n\tif(n<=1)return 0.0;\n\tsort(p,p+n);\n\tdouble ans=closestpair_cal(p,n);\n\treturn ans==INF_double?0.0:ans;\n}\n\nint main()\n{\n\tPoint p[100000];int n,i=0;cin>>n;\n\twhile(~scanf(\"%lf %lf\",&p[i].x,&p[i].y))i++;\n\tcout<<fixed<<setprecision(6)<<closestpair(p,n)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<double, double> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(175, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p1[i + j].first - p1[i].first) * (p1[i + j].first - p1[i].first) + (p1[i + j].second - p1[i].second) * (p1[i + j].second - p1[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        int r = min(175, n - i - 1);\n        \n        for(int j = 1; j <= r; j++)\n        {\n            double distance_ = (p2[i + 1].first - p2[i].first) * (p2[i + 1].first - p2[i].first) + (p2[i + 1].second - p2[i].second) * (p2[i + 1].second - p2[i].second);\n        \n            sqr_ans = min(distance_, sqr_ans);\n        }\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100000\nconst double INF = 1e50;\n\ntypedef pair<double,double> P;\n\nint N;\nP A[MAX_N]; \n\nbool compare_y(const P &a,const P &b){\n  return a.second < b.second;\n}\n \ndouble closest_pair(P *a,int n){\n  if(n <= 1) return INF;\n  int m = n / 2;\n  double x = a[m].first;\n  double d = min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n \n  vector<P> b;\n  for(int i = 0 ; i < n ; i++){\n    if(fabs(a[i].first - x >= d)) continue;\n    for(int j = 0 ; j < (int)b.size() ; j++){\n      double dx = a[i].first - b[b.size()-j-1].first;\n      double dy = a[i].second - b[b.size()-j-1].second;\n      if(dy >= d) break;\n      d = min(d,sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nvoid solve(){\n  sort(A,A+N);\n  printf(\"%.8f\\n\",closest_pair(A,N));\n}\n\nint main(){\n  cin >> N;\n  for(int i = 0 ; i < N ; i++){\n    scanf(\"%lf%lf\",&A[i].first,&A[i].second);\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = limits::inf;\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) >= delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << setprecision(500) << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include \"closest_pair.hpp\"\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta) { continue; }\n\n        for (index_t j = 0; j < Y_.size(); j++) {\n\n            elem_t dx = P[i].x - Y_[Y_.size() - j - 1].x;\n            elem_t dy = P[i].y - Y_[Y_.size() - j - 1].y;\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            \n            if (dy >= delta) { break; }\n\n            delta = std::min(delta, std::sqrt(dx * dx + dy * dy));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return delta;\n}\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << setprecision(22) << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS; }\n\nusing Point = complex< double >;\n\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble radian_to_degree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble degree_to_radian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() {}\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(double A, double B, double C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() {}\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle() {}\n\n  Circle(Point p, double r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\ndouble cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\nbool parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ndouble distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\ndouble distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\ndouble distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\ndouble distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\ndouble distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point hp = projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return {hp - v, hp + v};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\nenum {\n  OUT, ON, IN\n};\n\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\nbool merge_if_able(Segment &s1, Segment s2) {\n  if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid merge_segments(vector< Segment > &segs) {\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon convex_cut(Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble area2(const Polygon &p) {\n  double A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble convex_diameter(Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\ndouble closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n\n  function< double(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return 1e18;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\n\nint main() {\n  int N;\n  cin >> N;\n  Points p(N);\n  for(auto &s : p) cin >> s;\n  cout << fixed << setprecision(10) << closest_pair(p) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<utility>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n\ntypedef pair<double, double> point;\n\ninline double dist(const point &a, const point &b)\n{\n\treturn sqrt((a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second));\n}\n\nint main()\n{\n\tint i, n;\n\tdouble x, y;\n\tscanf(\"%d\", &n);\n\tpoint *P;\n\tP = new point [n + 1];\n\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tP[i] = make_pair(x, y);\n\t}\n\tsort(P, P + n);\n\n\tdouble d = dist(P[0], P[1]);\n\tfor(i = 2; i < n; i++){\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tif(fabs(P[i].first - P[j].first) > d) continue;\n\t\t\tif(fabs(P[i].second - P[j].second) > d) continue;\n\t\t\td = min(d, dist(P[i], P[j]));\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\", d);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst double eps = 1e-8;\nconst double pi = acos(-1.0);\nconst int inf = 0x3f3f3f3f;\ntypedef long long ll;\nint sgn(double x){\n    if(fabs(x)<eps){\n        return 0;\n    }\n    if(x<0){\n        return -1;\n    }else{\n        return 1;\n    }\n}\nstruct Point{\n    double x,y;\n    Point(){}\n    Point(double _x,double _y){\n        x = _x;\n        y = _y;\n    }\n    void input(){\n        scanf(\"%lf%lf\",&x,&y);\n    }\n    double distance(Point p){\n        return hypot(x-p.x,y-p.y);\n    }\n}p[100005];\nint a[100005];   //暂存点的坐标\nbool cmpx(const Point &a,const Point &b){\n    return a.x<b.x;\n}\nbool cmpy(int a,int b){\n    return p[a].y<p[b].y;\n}\ndouble closest(int low,int high){\n    if(low+1 == high){    //只有两个点\n        return p[low].distance(p[high]);\n    }\n    if(low+2 == high){   //三个点也好算\n        return min(p[low].distance(p[high]),min(p[low].distance(p[low+1]),p[low+1].distance(p[high])));\n    }\n    int mid = (low+high)>>1;\n    double ans = min(closest(low,mid),closest(mid+1,high));\n    int i,j,cnt = 0;\n    for(int i = low;i <= high;++i ){\n        if(p[i].x>=p[mid].x-ans&&p[i].x<=p[mid].x+ans){\n            a[cnt++] = i;\n        }\n    }\n    sort(a,a+cnt,cmpy);\n    for(int i = 0;i < cnt;++i ){\n        for(int j = i+1;j < cnt;++j ){\n            if(p[a[j]].y-p[a[i]].y>=ans){\n                break;\n            }\n            ans = min(ans,p[a[i]].distance(p[a[j]]));\n        }\n    }\n    return ans;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for(int i = 0;i < n;++i ){\n        p[i].input();\n    }\n    sort(p,p+n,cmpx);\n    printf(\"%.8f\\n\",closest(0,n-1));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn 1e9;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP,\n\tint yl,int yr\n){\n\tint xsiz=xr-xl;\n\tint ysiz=yr-yl;\n\tif (xsiz <= 3) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tif(ysiz==0)return 1e9;\n\t//printf(\"%d %d %d %d\\n\",xl,xr,yl,yr);\n\tauto xM = xP[xl+xsiz/2].first;\n\tauto yL = std::vector<point_t>(ysiz);\n\tint left = -1, right = ysiz;\n\tfor(int i = 0; i < ysiz; i++){\n\t\tif (yP[i].first <= xM) yL[++left] = yP[i];\n\t\telse                  yL[--right]= yP[i];\n\t}\n\tstd::reverse(yL.begin()+right,yL.end());\n\tauto p1 = find_closest_optimized(xP,xl,xl+xsiz/2,yL,0,left+1);\n\tauto p2 = find_closest_optimized(xP,xl+xsiz/2,xr,yL,left+1,ysiz);\n\tauto minD = sqrt((p1 <= p2) ? p1 : p2);\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minD, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minD;\n\t});\n\tauto result = minD*minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n,yP,0,n);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#define sq(n) (n)*(n)\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b){\n\treturn sq(b.first-a.first)+sq(b.second-a.second);\n}\n \ndouble find_closest_brute(const std::vector<point_t>& points,int xl,int xr){\n\tint siz=xr-xl;\n\tif (siz < 2) {\n\t\treturn -1;\n\t}\n\tauto minDistance = 1e9;\n\tfor (auto i = xl; i < xr-1; ++i) {\n\t\tfor (auto j = i + 1; j < xr; ++j) {\n\t\t\tauto newDistance = distance_between(points[i], points[j]);\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn minDistance;\n}\n \ndouble find_closest_optimized(\n\tconst std::vector<point_t>& xP,\n\tint xl,int xr,\n\tconst std::vector<point_t>& yP\n){\n\tint siz=xr-xl;\n\tif (siz <= 3) {\n\t\treturn find_closest_brute(xP,xl,xr);\n\t}\n\tauto xM = xP[xl+siz/2].first;\n\tauto yL = std::vector<point_t>();\n\tauto yR = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {\n\t\treturn p.first <= xM;\n\t});\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {\n\t\treturn p.first > xM;\n\t});\n\tauto p1 = find_closest_optimized(xP,xl,xl+siz/2, yL);\n\tauto p2 = find_closest_optimized(xP,xl+siz/2,xr, yR);\n\tauto minD = sqrt((p1 <= p2) ? p1 : p2);\n\tauto &yS = yP;\n\tauto result = minD*minD;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minD); ++k) {\n\t\t\tauto newDistance = distance_between(*k, *i);\n\t\t\tif (newDistance < result) {\n\t\t\t\tresult = newDistance;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint i=0,n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);i<n;i++){\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tpoints.emplace_back(x,y);\n\t}\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP,0,n, yP);\n\tprintf(\"%.9f\\n\",sqrt(r));\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/50))  \n #define Fun2(j,n) for(int j=i+(int)(n/50);j<n;j=j+(int)(n/50))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=500;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16??????????????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=0;j<4;j++)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*j+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       real_min=fun_min;\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A?????? \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  \n\n  "
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&min(memo,ans+1.0) >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans =(min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n\nld _closest_pair_of_points(vector<pair<ld, ld>>& ps, int l, int r){\n    constexpr ld INF = 1e15L;\n    constexpr ld eps = 1e-10L;\n    if (r - l <= 1) return INF;\n    const int m = (l + r) / 2;\n    ld x_mid = ps[m].first;\n    ld left_half = _closest_pair_of_points(ps, l, m);\n    ld right_half = _closest_pair_of_points(ps, m, r);\n    ld res = min(left_half, right_half);\n    inplace_merge(\n        ps.begin() + l, ps.begin() + m, ps.begin() + r, \n        [](const pair<ld, ld> a, const pair<ld, ld> b){\n            return a.second < b.second;\n        }\n    );\n    vector<int> idx;\n    for (int i = l; i < r; ++i){\n        if (abs(ps[i].first - x_mid) > res + eps)\n            continue;\n        for (int j = idx.size() - 1; j >= 0; --j){\n            ld dx = ps[i].first - ps[idx[j]].first;\n            ld dy = ps[i].second - ps[idx[j]].second;\n            if (dy > res + eps) break;\n            res = min(res, sqrtl(dx * dx + dy * dy));\n        }\n        idx.push_back(i);\n    }\n    return res;\n}\n\nld closest_pair_of_points(vector<pair<ld, ld>> lis){\n    sort(lis.begin(), lis.end());\n    return _closest_pair_of_points(lis, 0, lis.size());\n}\n\nint main(void){\n    int n; cin >> n;\n    vector<pair<ld, ld>> lis(n);\n    for (int i = 0; i < n; ++i)\n        cin >> lis[i].first >> lis[i].second;\n    cout << fixed << setprecision(15) << closest_pair_of_points(lis) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lb long double\n#define N 100010\n#define eps 1e-11\n#define INF 1e18\nusing namespace std;\nstruct Po{lb x,y;}x;\nvector<Po> no;\nint n;\nPo operator -(Po x,Po y){return (Po){x.x-y.x,x.y-y.y};}\nvoid get(Po &x){scanf(\"%Lf %Lf\",&x.x,&x.y);}\nbool c1(const Po &x,const Po &y){if (fabs(x.x-y.x)<eps)return x.y<y.y;return x.x<y.x;}\nbool c2(const Po &x,const Po &y){return x.y<y.y;}\nlb dis(Po x){return sqrtl(x.x*x.x+x.y*x.y);}\nlb que(vector<Po> x){\n\tif (x.size()==1) return INF;\n\tif (x.size()==2) return dis(x[0]-x[1]);\n\tint mid=x.size()/2;\n\tvector<Po> s1,s2;\n\ts1.clear();s2.clear();\n\tfor (int i=0;i<x.size();i++)if (i<mid) s1.push_back(x[i]);else s2.push_back(x[i]);\n\tlb an=min(que(s1),que(s2));\n\treverse(s1.begin(),s1.end());\n\twhile (s1.size()&&fabs(x[mid].x-s1[s1.size()-1].x)>an-eps)s1.pop_back();\n\twhile (s2.size()&&fabs(s2[s2.size()-1].x-x[mid-1].x)>an-eps)s2.pop_back();\n\tsort(s1.begin(),s1.end(),c2);\n\tsort(s2.begin(),s2.end(),c2);\n\tint l=0,r=-1;\n\tfor (int i=0;i<s1.size();i++){\n\t\twhile (r+1<s2.size()&&s2[r+1].y-s1[i].y<an+eps) r++;\n\t\twhile (l+1<=s2.size()&&s1[i].y-s2[l].y>an+eps)l++;\n\t\tfor (int j=l;j<=r;j++) an=min(an,dis(s2[j]-s1[i]));\n\t}\n\treturn an;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\twhile(n--){get(x);no.push_back(x);}\n\tsort(no.begin(),no.end(),c1);\n\tprintf(\"%.10Lf\",que(no));\n\tlb ansn=INF;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; double x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%lf\", &x[i]);\n        scanf(\"%lf\", &y[i]);\n    }\n    \n    pair<int, int> p1[100000], p2[100000];\n    \n    for(int i = 0; i < n; i++)\n    {\n        p1[i] = make_pair(x[i], y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        p2[i] = make_pair(y[i], x[i]);\n    }\n    \n    sort(p1, p1 + n);\n    sort(p2, p2 + n);\n    \n    double sqr_ans = 100000000.0;\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        double distance_ = (p1[i + 1].first - p1[i].first) * (p1[i + 1].first - p1[i].first) + (p1[i + 1].second - p1[i].second) * (p1[i + 1].second - p1[i].second);\n        \n        sqr_ans = min(distance_, sqr_ans);\n    }\n    \n    for(int i = 0; i < n - 1; i++)\n    {\n        double distance_ = (p2[i + 1].first - p2[i].first) * (p2[i + 1].first - p2[i].first) + (p2[i + 1].second - p2[i].second) * (p2[i + 1].second - p2[i].second);\n        \n        sqr_ans = min(distance_, sqr_ans);\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\nusing namespace std;\nconstexpr long loINF = 2147483647;\nconstexpr double eps = (1e-10);\nbool eq(double a,double b){ return a>b?a-b<eps:b-a<eps; }\nclass Point { //位置ベクトルと作用ベクトルを同一視\npublic:\n\tdouble x;\n\tdouble y;\n\tPoint(double X=0.0,double Y=0.0):x(X),y(Y){}\n\tPoint(const Point &m):x(m.x),y(m.y) {}\n\tPoint operator+(const Point &p){return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point &p){return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k){return Point(x*k,y*k);}\n\tPoint operator/(const double k){return Point(x/k,y/k);}\n\tPoint operator=(const Point &p){x=p.x;y=p.y;return *this;}\n\tPoint rev() {return Point(-x,-y);}\n\tbool operator<(const Point &p){return x!=p.x?x<p.x:y<p.y;}\n\tbool operator>(const Point &p){return x!=p.x?x>p.x:y>p.y;}\n\tbool operator==(const Point &p){return eq(x,p.x)&&eq(y,p.y);}\n\tdouble norm(){ return x*x+y*y; }\n\tdouble abs() { return sqrt(norm());}\n\tdouble dist(const Point &a) { return (Point(x,y)-a).abs(); }\n\tdouble dot(const Point &a) { return x*a.x + y*a.y; }\n\t//外積 -> 2vec向き付き角度判定,平行四辺形面積\n\tdouble det(const Point &a) { return x*a.y - y*a.x; }\n\tbool is_parallel(const Point &a) { return eq((x*a.y - y*a.x),0); }\n\t// a -> this の正射影\n\tPoint proj(const Point &a) { return Point(x,y)*(dot(a)/norm()); }\n\t//2ベクトルのなす角 (正 : 時計回り, 負 : 反時計)\n\tdouble ang(const Point &v) {\n\t\tdouble g1 = atan2(v.y,v.x);\n\t\tdouble g2 = atan2(y,x);\n\t\tif (g1 < 0) g1 += (2 * M_PI);\n\t\tif (g2 < 0) g2 += (2 * M_PI);\n\t\treturn (g2 - g1);\n\t}\n\t//2ベクトルのなす角(正値)を出す。\n\tdouble absAng(Point &v){ \n    \treturn acos(dot(v)/sqrt(norm() * v.norm()));\n  \t}\n};\n\nclass Segment {\npublic:\n\tPoint p1;\n\tPoint p2;\n\tSegment(double x1,double y1,double x2,double y2) : p1(x1,y1),p2(x2,y2) {}\n\tSegment(const Point &a,const Point &b) : p1(a),p2(b) {}\n\tdouble len (const Segment &l) { return (p2 - p1).norm(); }\n\tinline Point toVec() { return (p2 - p1); }\n};\n\n// 直線 X と 直線 Y の交点\nPoint intersection(Segment X,Segment Y) {\n\treturn X.p1 + (X.p2 - X.p1) * (Y.p2 - Y.p1).det((Y.p1 - X.p1)) / (Y.p2 - Y.p1).det(X.p2 - X.p1);\n}\n\n// 線分X上に点qがあるか\nbool on_seq(Segment X,Point q) {\n\treturn (eq((X.p1 - q).det(X.p2 - q),0) && (X.p1 - q).dot(X.p2 - q) < eps);\n}\n\n// 線分Xと線分Yが交点を持つか\nbool have_intersection(Segment X,Segment Y) {\n\tif (!(X.toVec()).is_parallel(Y.toVec())) {\n\t\tPoint r = intersection(X,Y);\n\t\treturn (on_seq(X,r) && on_seq(Y,r));\n    }\n    else return (on_seq(X,Y.p1) || on_seq(X,Y.p2) || on_seq(Y,X.p1) || on_seq(Y,X.p2));\n}\n\n// 二つの線分の位置関係\nint ccw(Point a,Point b,Point c) { // aが支点\n\tcomplex<double> v1(b.x-a.x,b.y-a.y),v2(c.x-a.x,c.y-a.y);\n\tcomplex<double> v = (v2*conj(v1));\n\tif(v.imag()>eps)return 1;        //反時計回り\n\tif(v.imag()<-eps)return -1;      //時計回り\n\tif(v.real()<-eps)return 2;       //真逆\n\tif(abs(v1)+eps<abs(v2))return -2;//同じ側超えてる\n\treturn 0;                        //同じ側近い側\n}\n// 線分Xと点qの距離\ndouble distance1 (Segment X,Point q) { \n\tif (eq((X.p1 - X.p2).dot(q - X.p2),0)) return X.p2.dist(q);\n\tif (eq((X.p2 - X.p1).dot(q - X.p1),0)) return X.p1.dist(q);\n\telse return (X.p1 + (X.p2-X.p1).proj(q-X.p1)).dist(q);\n}\n\n//線分Xと線分Yの距離\ndouble distance2 (Segment X,Segment Y) { \n\tif (have_intersection(X,Y)) return 0.0;\n\telse return min({distance1(X,Y.p1),distance1(X,Y.p2),distance1(Y,X.p1),distance1(Y,X.p2)});\n}\n\n//点列をx座標で昇順ソート\ninline void sort_x(vector<Point> &p) { \n\tstruct comp { bool operator() (const Point &a,const Point &b) {return (a.x!=b.x?a.x<b.x:a.y<b.y);} };\n\tsort(p.begin(),p.end(),comp());\n}\n\n//点列をy座標で昇順ソート\ninline void sort_y(vector<Point> &p) { \n\tstruct comp { bool operator() (const Point &a,const Point &b) {return (a.y!=b.y?a.y<b.y:a.x<b.x);} };\n\tsort(p.begin(),p.end(),comp());\n}\n\n//多角形の面積 (point列は順番になっていること)\ndouble getArea(vector<Point> &point){\n\tdouble s = 0;\n\tint n = point.size();\n\tfor (int i = 0;i < n;i++ ) s += point[i%n].det(point[(i+1)%n]);\n\treturn abs(s) * 0.5;\n}\n\n//0: outside, 1: on line, 2: inside (Winding Number)\nint contains(const vector<Point> &point, Point p) {\n    int flg = -1;\n    Point _a, _b = point.back();\n    for (int i = 0; i < int(point.size()); i++) {\n        _a = _b; _b = point[i];\n        Point a = _a, b = _b;\n        if (ccw(a, b, p) == 0) return 1;\n        if (a.y > b.y) swap(a, b);\n        if (!(a.y <= p.y && p.y < b.y)) continue;\n        // (a-p).det(b-p) > eps) : 線の内側\n        if (eq(a.y,p.y) ? (a.x > p.x):((a-p).det(b-p) > eps)) flg *= -1;\n    }\n    return flg + 1;\n}\n\n//凸包(グラハムスキャン)\nvector<Point> convexHull(vector<Point> &point){\n\tint n = point.size(),k = 0;\n\tvector<Point> qs(n*2);\n\tsort_x(point);\n\tfor(int i = 0;i < n;i++){ //下側凸包の作成\n\t\twhile(k > 1 && (qs[k-1] - qs[k-2]).det(point[i] - qs[k-1]) < (-eps)) k--;\n\t\t// 平行な点を削除 -> while(k > 1 && (qs[k-1] - qs[k-2]).det(point[i] - qs[k-1]) < (eps)) k--;\n\t\tqs[k++] = point[i];\n\t}\n\tfor(int i = n - 2, t = k; i >= 0; i--){ //上側凸包の作成\n\t\twhile(k > t && (qs[k-1] - qs[k-2]).det(point[i] - qs[k-1]) <= (-eps)) k--;\n\t\t// 平行な点を削除 -> while(k > t && (qs[k-1] - qs[k-2]).det(point[i] - qs[k-1]) <= (eps)) k--;\n\t\tqs[k++] = point[i];\n\t}\n\tqs.resize(k-1);\n\treturn qs;\n}\n\n//最遠頂点対間距離 (pはConvex)\ndouble diameter(vector<Point> &p) {\n    int n = int(p.size());\n    int x = 0, y = 0;\n    for (int i = 1; i < n; i++) {\n        if (p[i] < p[x]) x = i;\n        if (p[y] < p[i]) y = i;\n    }\n    double ans = 0;\n    int sx = x, sy = y;\n    while (sx != y || sy != x) {\n        ans = max(ans, (p[x]).dist(p[y]));\n        int nx = ((x+1) % n),ny = ((y+1)%n);\n        if ((p[nx] - p[x]).det(p[ny] - p[y]) < 0.0) x = nx;\n        else y = ny;\n    }\n    return ans;\n}\n\n// 凸多角形pを l で切断、左側の面積を求める\nvector<Point> convex_cut(vector<Point> &p,Segment &l) {\n\tif (!p.size()) return vector<Point>{};\n\tint n = int(p.size());\n\tvector<Point> q;\n\tPoint a, b = p.back();\n\tfor (int i = 0; i < n; i++) {\n\t\ta = b; b = p[i];\n\t\tif ((ccw(l.p1,l.p2, a)%2)*(ccw(l.p1,l.p2, b)%2) < 0) {\n\t\t\tq.push_back(intersection(Segment(a,b),l));\n\t\t}\n\t\tif (ccw(l.p1,l.p2,b) != -1) q.push_back(b);\n\t}\n\treturn q;\n}\n\n// *a must be sorted\ndouble closest_pair_search(vector<Point>::iterator a,int n) {\n\tstruct comp { bool operator() (const Point &a,const Point &b) {return (a.y!=b.y?a.y<b.y:a.x<b.x);} };\n\tint m = n / 2;\n\tif(n <= 1) return numeric_limits<double>::infinity();\n\tdouble x = a[m].x;\n\tdouble d = min(closest_pair_search(a,m),closest_pair_search(a+m,n-m));\n\tinplace_merge(a,a+m,a+n,comp());\n\tvector<Point> b;\n \tfor(int i = 0;i < n;i++) {\n\t\tif(abs(a[i].x - x) >= d) continue;\n\t\tfor(int j = 0;j < b.size();j++) {\n\t\t\tPoint p = a[i] - b[b.size()-1-j];\n\t\t\tif (p.y >= d) break;\n\t\t\td = min(d,p.abs());\n\t\t}\n\t\tb.push_back(a[i]);\n  \t}\n  \treturn d;\n}\n\ndouble closest_pair (vector<Point> &p) {\n\tint n = p.size();\n\tif (n <= 1) return 0.0;\n\tsort(p.begin(),p.end());\n\tdouble ans = closest_pair_search(p.begin(),n);\n\treturn ans;\n}\n\nint main(void){\n\tint n;\n\tdouble x,y;\n\tcin >> n;\n\tvector<Point> p(n);\n\tREP(i,n) {\n\t\tcin >> x >> y;\n\t\tp[i] = Point(x,y);\n\t}\n\tcout << fixed << setprecision(15) << closest_pair(p) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>            // fabs(), sqrt()\n#include <vector>\n#include <utility>          // pair\n#include <algorithm>        // min(), sort(), inplace_merge()\n\nusing namespace std;\ntypedef pair<double, double> P; // first ??? x ??§?¨????second ??? y ??§?¨?\n\nstatic const int MAX_N = 100000;\nstatic const int INF = 1000000000;\n\nP A[MAX_N];\nint N;\n\nbool\ncmp_func(P a, P b)\n{\n\treturn a.second < b.second;\n}\n\ndouble\nclosest_pair(P* a, int n)\n{\n\tif (n <= 1)\n\t\treturn INF;\n\n\tint m = n / 2;\n\tdouble x = a[m].first;\n\tdouble d = min(closest_pair(a, m), closest_pair(a + m, n - m)); // (1)\n\tinplace_merge(a, a + m, a + n, cmp_func); // ??????????????????????????????????????????\n\t// ??????????????§ a ??? y ??§?¨??????????????????£?????????\n\n\t//x (2')\n\tvector<P> b; // ??´??????????????¢ d ????????????????????\\????????????\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tif (fabs(a[i].first - x) >= d)\n\t\t\tcontinue;\n\n\t\t// b ?????\\??£?????????????????????????°??????????y ??§?¨?????????? d ??\\?????????????????§????????????\n\t\tfor (unsigned int j = 0; j < b.size(); ++j)\n\t\t{\n\t\t\tdouble dx = a[i].first - b[b.size() - j - 1].first;\n\t\t\tdouble dy = a[i].second - b[b.size() - j - 1].second;\n\t\t\tif (dy >= d)\n\t\t\t\tbreak;\n\n\t\t\td = min(d, sqrt(dx * dx + dy * dy));\n\t\t}\n\n\t\tb.push_back(a[i]);\n\t}\n\n\treturn d;\n}\n\nint\nmain(int argc, char** argv)\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i)\n\t\tscanf(\"%lf %lf\", &A[i].first, &A[i].second);\n\n\tsort(A, A + N);\n\tprintf(\"%.10f\\n\", closest_pair(A, N));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//closest pair\n#include <bits/stdc++.h>\nusing namespace std;\nconst int M=100001;\nconst double INF=1e9;\nint n;\nstruct Point{double x, y;};\nbool compareX(Point a,Point b){return a.x<b.x;}\nbool compareY(Point a,Point b){return a.y<b.y;}\ndouble dist(Point p1, Point p2)\n{return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y - p2.y)*(p1.y - p2.y));}\ndouble bruteForce(Point P[], int n)\n{\n    double mn =INF;\n    for (int i = 0; i < n; ++i)\n        for (int j = i+1; j < n; ++j)\n            if (dist(P[i], P[j]) < mn)\n                mn = dist(P[i], P[j]);\n    return mn;\n}\ndouble stripClosest(Point strip[], int size, double d)\n{\n    double mn = d;\n    for (int i = 0; i < size; ++i)\n        for (int j = i+1; j < size && (strip[j].y - strip[i].y) < mn; ++j)\n            if (dist(strip[i],strip[j]) < mn)\n                mn = dist(strip[i], strip[j]);\n    return mn;\n}\ndouble closestUtil(Point Px[], Point Py[], int n)\n{\n    if (n <= 3)\n        return bruteForce(Px, n);\n    int mid = n/2;\n    Point midPoint = Px[mid];\n    Point Pyl[mid+1];   // y sorted points on left of vertical line\n    Point Pyr[n-mid-1];  // y sorted points on right of vertical line\n    int li = 0, ri = 0;  // indexes of left and right subarrays\n    for (int i = 0; i < n; i++)\n    {\n      if (Py[i].x <= midPoint.x)\n         Pyl[li++] = Py[i];\n      else\n         Pyr[ri++] = Py[i];\n    }\n    double dl = closestUtil(Px, Pyl, mid);\n    double dr = closestUtil(Px + mid, Pyr, n-mid);\n    double d = min(dl, dr);\n    Point strip[n];\n    int j = 0;\n    for (int i = 0; i < n; i++)\n        if (abs(Py[i].x - midPoint.x) < d)\n            strip[j] = Py[i], j++;\n    return min(d, stripClosest(strip, j, d) );\n}\ndouble closest(Point P[], int n)\n{\n    Point Px[n],Py[n];\n    for (int i = 0; i < n; i++)\n    {\n        Px[i] = P[i];\n        Py[i] = P[i];\n    }\n    sort(Px,Px+n, compareX);\n    sort(Py,Py+n, compareY);\n    return closestUtil(Px, Py, n);\n}\nint main()\n{\n\tcin>>n;\n    Point P[M];\n    for(int i=0;i<n;i++)\n\t\tcin>>P[i].x>>P[i].y;\n    cout << fixed<<setprecision(6)<<closest(P, n);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n #define M(m,n) for(int m=0;m<n;m++)\n #define N(n,k) for(int n=0;n<k;n++)\n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/30))  \n #define Fun2(j,n) for(int j=i+(int)(n/30);j<n;j=j+(int)(n/30))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=2000;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16????????????????????¢???10??????????????§?????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n double dx,dy;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   //?°?16????????????????????????????????? \n   minx=minx-1;\n   miny=miny-1;\n   maxx=maxx+1;\n   maxy=maxy+1;\n   dx=1.0/4*(maxx-minx);\n   dy=1.0/4*(maxy-miny);\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=3;j>=0;j--)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*(3-j)+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n   /*\n   for(int i=0;i<16;i++)\n   {\n     for(int j=0;j<num_point[i];j++)\n     {\n       cout<<wu[i][j].x<<\" \"<<wu[i][j].y<<endl;        \n     }        \n   }\n   */\n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n //?????¢????????????????????????????§???????????????¢?????? \n void circle_optimize(double center)\n {\n      \n }\n \n void triangle_optimize()\n {\n      \n }\n \n void rectangle_optimize()\n {\n      \n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       //real_min=(point[0].x-point[1].x)*(point[0].x-point[1].x)+(point[0].y-point[1].y)*(point[0].y-point[1].y);\n       real_min=fun_min;\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         bool flag1,flag2,flag3,flag4,judge; \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {      \n             //???????????????????????¬???????????????????????¨?????????????????????????¬????????°????????????????????????????????????????????°???????????????°?????¨ \n             double theta=sqrt(real_min)/2;\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               flag1=flag2=flag3=flag4=false;\n               judge=false;\n               if(point[i].x>=(minx+(n+1)*dx-theta)) flag1=true;\n               if(point[i].x<=(minx+(n+1)*dx)) flag2=true;\n               if(point[i].y>=(miny+(3-m)*dy)) flag3=true;\n               if(point[i].y<=(miny+(4-m)*dy)) flag4=true;\n               judge=flag1&&flag2&&flag3&&flag4;\n               if(!judge) continue;\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 flag1=flag2=flag3=flag4=false;\n                 judge=false;\n                 if(point[j].x>=(minx+(n+1)*dx)) flag1=true;\n                 if(point[j].x<=(minx+(n+1)*dx+theta)) flag2=true;\n                 if(point[j].y>=(miny+(3-m)*dy)) flag3=true;\n                 if(point[j].y<=(miny+(4-m)*dy)) flag4=true;\n                 judge=flag1&&flag2&&flag3&&flag4;\n                 if(!judge) continue;\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             double theta=sqrt(real_min)/2;\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               flag1=flag2=flag3=flag4=false;\n               judge=false;\n               if(point[i].x>=(minx+n*dx)) flag1=true;\n               if(point[i].x<=(minx+(n+1)*dx)) flag2=true;\n               if(point[i].y>=(miny+(3-m)*dy)) flag3=true;\n               if(point[i].y<=(miny+(3-m)*dy+theta)) flag4=true;\n               judge=flag1&&flag2&&flag3&&flag4;\n               if(!judge) continue;\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 flag1=flag2=flag3=flag4=false;\n                 judge=false;\n                 if(point[j].x>=(minx+n*dx)) flag1=true;\n                 if(point[j].x<=(minx+(n+1)*dx)) flag2=true;\n                 if(point[j].y>=(miny+(3-m)*dy-theta)) flag3=true;\n                 if(point[j].y<=(miny+(3-m)*dy)) flag4=true;\n                 judge=flag1&&flag2&&flag3&&flag4;\n                 if(!judge) continue;\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double inf = 30000;\nconst double eps = 1e-8;\nconst int N = 2e5 + 100;\nint sgn (double x) {\n    if (fabs (x) < eps) return 0;\n    if (x < 0) return -1;\n    return 1;\n}\nstruct point {\n    double x, y;\n    point () {}\n    point (double _x, double _y) {\n        x = _x, y = _y;\n    }\n    void input () {\n        scanf (\"%lf %lf\", &x, &y);\n    }\n    point operator - (const point &b) const {\n        return point (x - b.x, y - b.y);\n    }\n    bool operator == (const point &b) const {\n        return sgn (x - b.x) == 0 && sgn (y - b.y) == 0;\n    }\n    bool operator < (const point &b) const {\n        if (sgn (y - b.y) == 0) return x < b.x;\n        return y < b.y;\n    }\n    double operator * (const point &b) const {\n        return x * b.x + y * b.y;\n    }\n    double operator ^ (const point &b) const {\n        return x * b.y - y * b.x;\n    }\n    point operator / (const double &b) const {\n        return point (x / b, y / b);\n    }\n    point operator * (const double &b) const {\n        return point (x * b, y * b);\n    }\n    point operator + (const point &b) const {\n        return point (x + b.x, y + b.y);\n    }\n    double cross (point a, point b) {\n        return (point (a - *this) ^ point (b - *this));\n    }\n    double dot (point a, point b) {\n        return (point (a - *this) * point (b - *this));\n    }\n    double len () {\n        return hypot (x, y);\n    }\n    bool on_seg (point a, point b) {///点是否在线段ab上\n        return sgn (cross (a, b)) == 0 && dot (a, b) <= 0;\n    }\n} ps[N], num[N];\n///两线段的交点\npoint spp (point s1, point e1, point s, point e) {\n    if (s.dot (e, s1) > s.dot (e, e1)) swap (s1, e1);\n    point p = e - s;\n    double len = p.len ();\n    double a = fabs (s.cross (e, s1)) / len;\n    double b = fabs (s.cross (e, e1)) / len;\n    double a1 = s.dot (e, s1) / len;\n    double b1 = s.dot (e, e1) / len;\n    double k = a1 + fabs(a1 - b1) / (a + b) * a;\n    p = p / len, p = p * k, p = p + s;\n    return p;\n}\n///两线段是否相交\nbool seg (point a, point b, point c, point d) {\n    if (a.on_seg (c, d)) return true;\n    if (a.cross (b, d) * a.cross (b, c) < 0 && c.cross (d, b) * c.cross (d, a) < 0) return true;\n    return false;\n}\n/// 点的投影是否在线段ab上\n//bool check (point p, point a, point b) {\n//    point x = b - a;\n//    double k = x.len ();\n//    double u = a.dot (p, b) / k;\n//    x = (x / k) * u;\n//    x = x + a;\n//    if (x.on_seg (a, b)) return true;\n//    return false;\n//}\n//struct polygon {\n//    int n;\n//    point ps[N];\n//    void input () {\n//        cin >> n;\n//        for (int i = 0; i < n; i++) ps[i].input ();\n//    }\n//    ///排序规则\n//    struct cmp {\n//        point p;\n//        cmp (point _p) {\n//            p = _p;\n//        }\n//        bool operator () (const point &aa, const point &bb) {\n//            point a = aa, b = bb;\n//            int d = sgn (p.cross (a, b));\n//            if (d == 0) return point (a - p).len () < point (b - p).len ();\n//            else return d > 0;\n//        }\n//    };\n//    ///排序\n//    void norm () {\n//        point mi = ps[0];\n//        for (int i = 0; i < n; i++) mi = min (mi, ps[i]);\n//        sort (ps, ps + n, cmp (mi));\n//    }\n//    ///求凸包\n////    void getconvex (polygon &convex) {\n////        sort (ps, ps + n);\n////        int &top = convex.n;\n////        top = 0;\n////        convex.ps[top++] = ps[0];\n////        for (int i = 1; i < n; i++) {\n////            while (top >= 2 && convex.ps[top - 2].cross (convex.ps[top - 1], ps[i]) < 0) top--;\n////            convex.ps[top++] = ps[i];\n////        }\n////        int t = 0;\n////        for (int i = n - 2; i >= 0; i--) {\n////            while (t && convex.ps[top - 2].cross (convex.ps[top - 1], ps[i]) < 0) top--, t--;\n////            if (!i) break;\n////            convex.ps[top++] = ps[i];\n////            t++;\n////        }\n////    }\n//    ///几何面积\n//    double mianji () {\n//        if (n < 2) return 0;\n//        double ans = 0;\n//        ps[n] = ps[0];\n//        for (int i = 1; i <= n; i++) ans += point (0, 0).cross (ps[i - 1], ps[i]);\n//        return ans;\n//    }\n//} dd, ans;\nint cmp1 (point a, point b) {\n    return a.x < b.x;\n}\nint cmp2 (point a, point b) {\n    return a.y < b.y;\n}\ndouble dfs (int l, int r) {\n    if (r - l == 1)\n        return point (ps[l] - ps[r]).len ();\n    if (r - l == 2) {\n        double a = point (ps[l] - ps[l + 1]).len ();\n        double b = point (ps[l] - ps[l + 2]).len ();\n        double c = point (ps[l + 1] - ps[l + 2]).len ();\n        return min (a, min (b, c));\n    }\n    int mid = l + r >> 1, v = 0;\n    double ans = min (dfs (l, mid), dfs (mid, r));\n    for (int i = l; i <= r; i++) if (fabs (ps[i].x - ps[mid].x) < ans) num[v++] = ps[i];\n    sort (num, num + v, cmp2);\n    for (int i = 0; i < v; i++) {\n        for (int j = i + 1; j < v; j++) {\n            if (sgn (num[j].y - num[i].y - ans) >= 0) break;\n            ans = min (ans, point (num[j] - num[i]).len ());\n        }\n    }\n    return ans;\n}\nint main () {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++) ps[i].input ();\n    sort (ps + 1, ps + 1 + n, cmp1);\n    printf (\"%.12f\\n\", dfs (1, n));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ntypedef vector<P> G;\n\ndouble compare_x(const P &a, const P &b){\n  return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n}\n\ndouble compare_y(const P &a, const P &b){\n  return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;\n}\n\ndouble convex_radius(P *a, int n){\n    if(n<=1)return INF;\n    int m=n/2;\n    double x=a[m].X;\n    double d=min(convex_radius(a, m), convex_radius(a+m, n-m));\n    sort(a, a+n, compare_y);\n    vector<P> b;\n    for(int i=0; i<n; i++){\n        if(fabs(a[i].X-x)>=d)continue;\n        for(int j=0; j<b.size(); j++){\n            double dx=a[i].X-b[b.size()-j-1].X;\n            double dy=a[i].Y-b[b.size()-j-1].Y;\n            if(dy>=d)break;\n            d=min(d,sqrt(dx*dx+dy*dy));\n              \n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  sort(g.begin(), g.end(), compare_x);\n  printf(\"%.10lf\\n\", convex_radius(&g[0], N));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&min(memo,ans+0.0001) >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans =(min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&min(memo,ans) >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans = sqrt(min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << (ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://ir5.hatenablog.com/entry/20131221/1387557630\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <utility>\n#include <cmath>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\ntypedef pair<double, double> P;\ntypedef pair<int, int> IP;\ndouble norm(P a, P b) {\n  double x = a.first - b.first;\n  double y = a.second - b.second;\n  return sqrt(x*x + y*y);\n}\ntemplate <>\nclass hash<std::pair<int, int>> {\n  public:\n    size_t operator()(const std::pair<int, int>& x) const {\n      return hash<int>()(x.first) ^ hash<int>()(x.second);\n    }\n};\nint main() {\n  int N; cin >> N;\n  vector<P> p(N);\n  REP(i,N) {\n    double x, y; cin >> x >> y;\n    p[i] = make_pair(x, y);\n  }\n  double xmin = p[0].first, ymin = p[0].second;\n  REP(i,N) {\n    xmin = min(xmin, p[i].first);\n    ymin = min(ymin, p[i].second);\n  }\n  REP(i,N) {\n    p[i].first -= xmin;\n    p[i].second -= ymin;\n  }\n  // std::rand is often used.\n  random_shuffle(p.begin(), p.end());\n  double delta = norm(p[0], p[1]);\n  unordered_map<IP, vector<int>> S;\n  S[IP(p[0].first / delta, p[0].second / delta)].push_back(0);\n  S[IP(p[1].first / delta, p[1].second / delta)].push_back(1);\n  for(int i = 2; i < N; ++i) {\n    IP ip(p[i].first / delta, p[i].second / delta);\n    bool update = false;\n    for(int dx = -1; dx <= 1; ++dx) for(int dy = -1; dy <= 1; ++dy) {\n      for(int j : S[IP(ip.first + dx, ip.second + dy)]) {\n        double d2 = norm(p[i], p[j]);\n        if(delta > d2) {\n          delta = d2;\n          update = true;\n        }\n      }\n    }\n    if(update) {\n      S.clear();\n      for(int j = 0; j <= i; ++j) {\n        S[IP(p[j].first / delta, p[j].second / delta)].push_back(j);\n      }\n    }\n    else {\n      S[ip].push_back(i);\n    }\n  }\n  cout.setf(ios::fixed);\n  cout.precision(6);\n  cout << delta << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&min(memo,ans+0.0001) >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans =(min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nconst long double PI = acos(-1.0L);\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\nusing CP = complex<long double>;\n\nconst long double EPS = 1e-10;     // 許容する誤差ε\n#define EQ(a, b) (abs((a)-(b)) < EPS)   // 2つのスカラーが等しいかどうか\n#define EQV(a, b) (EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))    // 2つのベクトルが等しいかどうか\n\n// double length = abs(a);     // ベクトルaの絶対値\n// double distance = abs(a-b);     // 2点a,b間の距離\n// CP b = a/abs(a);    // ベクトルaの単位ベクトル\n// CP n1 = a*CP(0,+1); CP n2 = a*CP(0,-1);  // ベクトルaの法線ベクトル\n// CP un1 = (a*CP(0,+1)/abs(a)); CP un2 = (a*CP(0,-1)/abs(a));  // ベクトルaの単位法線ベクトル\n\n// 内積(dot product) : a・b = |a||b|cosΘ\nlong double dot(CP a, CP b) {\n    return (a.real()*b.real() + a.imag()*b.imag());\n}\n\n// 外積(cross product) : a×b = |a||b|sinΘ\nlong double cross(CP a, CP b) {\n    return (a.real()*b.imag() - a.imag()*b.real());\n}\n\n// 2直線の直交判定 : a⊥b ⇔ dot(a,b) = 0\nint is_orthogonal(CP a1, CP a2, CP b1, CP b2) {\n    return EQ(dot(a1-a2, b1-b2), 0.0);\n}\n\n// 2直線の平行判定 : a//b ⇔ cross(a,b) = 0\nint is_parallel(CP a1, CP a2, CP b1, CP b2) {\n    return EQ(cross(a1-a2, b1-b2), 0.0);\n}\n\n// 点cが直線a,b上にあるかないか\nint is_point_on_line(CP a, CP b, CP c) {\n    return EQ(cross(b-a, c-a), 0.0);\n}\n\n// 点cが線分a,b上にあるかないか\nint is_point_on_lines(CP a, CP b, CP c) {\n    // |a-c|+|c-b| <= |a-b|なら線分上\n    return (abs(a-c)+abs(c-b) < abs(a-b)+EPS);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_lines(CP a1, CP a2, CP b1, CP b2) {\n    if(is_parallel(a1, a2, b1, b2)) {\n        // 平行なので線分の重なり判定\n        return is_point_on_lines(a1, a2, b1) || is_point_on_lines(a1, a2, b2) ||\n               is_point_on_lines(b1, b2, a1) || is_point_on_lines(b1, b2, a2);\n    }\n    return (cross(a2-a1, b1-a1)*cross(a2-a1, b2-a1) < EPS) &&\n           (cross(b2-b1, a1-b1)*cross(b2-b1, a2-b1) < EPS);\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nCP intersection_lines(CP a1, CP a2, CP b1, CP b2) {\n    CP b = b2-b1;\n    long double d1 = abs(cross(b, a1-b1));\n    long double d2 = abs(cross(b, a2-b1));\n    long double t = d1/(d1+d2);\n    return a1+(a2-a1)*t;\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_line(CP a1, CP a2, CP b1, CP b2) {\n    return !EQ(cross(a1-a2, b1-b2), 0.0);\n}\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算(平行ではない前提)\nCP intersection_line(CP a1, CP a2, CP b1, CP b2) {\n    CP a = a2-a1; CP b = b2-b1;\n    return a1 + a*cross(b, b1-a1)/cross(b, a);\n}\n\n// 点a,bを通る直線と点cとの距離\nlong double distance_line_p(CP a, CP b, CP c) {\n    return abs(cross(b-a, c-a))/abs(b-a);\n}\n\n// 点a,bを端点とする線分と点cとの距離\nlong double distance_lines_p(CP a, CP b, CP c) {\n    if(dot(b-a, c-a) < EPS) return abs(c-a);\n    if(dot(a-b, c-b) < EPS) return abs(c-b);\n    return abs(cross(b-a, c-a))/abs(b-a);\n}\n\n// 点a1,a2を端点とする線分と点b1,b2を端点とする線分の最短距離\nlong double distance_lines_lines(CP a1, CP a2, CP b1, CP b2) {\n    long double res = 1e18;\n    if(is_intersected_lines(a1, a2, b1, b2)) return 0.0L;\n    res = min(res, distance_lines_p(a1, a2, b1));\n    res = min(res, distance_lines_p(a1, a2, b2));\n    res = min(res, distance_lines_p(b1, b2, a1));\n    res = min(res, distance_lines_p(b1, b2, a2));\n    return res;\n}\n\n// s,tを通る直線に対する点pの射影\nCP projection(CP s, CP t, CP p) {\n    if(EQV(s, t)) return s;\n    CP base = t-s;\n    return s + base*(dot(p-s, base)/norm(base));\n}\n\n// s,tを通る直線に対する点pの反射\nCP reflection(CP s, CP t, CP p) {\n    CP tmp = projection(s, t, p) - p;\n    return p + tmp*2.0L;\n}\n\n// n多角形の面積計算\nlong double polygon_area(const vector<CP> &v) {\n    int n = v.size();\n    long double res = 0;\n    for(int i = 0; i < n; ++i) {\n        res += cross(v[(i+n-1)%n], v[(i+n)%n]);\n    }\n    return fabsl(res)/2.0L;\n}\n\n// n多角形の凸性判定\nint is_convex(const vector<CP> &v) {\n    int n = v.size();\n    for(int i = 0; i < n; ++i) {\n        if(cross(v[(i+1)%n]-v[i], v[(i+2)%n]-v[(i+1)%n]) < -EPS) return 0;\n    }\n    return 1;\n}\n\n// 凸包\nvector<CP> convex_hull(vector<CP> &v) {\n    // x座標→y座標で頂点をソート\n    auto lmd = [&](const CP &l, const CP &r) {\n        if(l.imag() != r.imag()) return l.imag() < r.imag();\n        return l.real() < r.real();\n        return l.imag() < r.imag();\n    };\n    vector<CP> res;     // 凸包を構成する頂点\n    int n = v.size();\n    sort(v.begin(), v.end(), lmd);\n    int k = 0;\n    res.resize(n*2);\n    // 下側凸包\n    for(int i = 0; i < n; ++i) {\n        while(k > 1 && cross(res[k-1]-res[k-2], v[i]-res[k-1]) < 0) {\n            --k;\n        }\n        res[k++] = v[i];\n    }\n    // 上側凸包\n    for(int i = n-2, t = k; i >= 0; --i) {\n        while(k > t && cross(res[k-1]-res[k-2], v[i]-res[k-1]) < 0) {\n            --k;\n        }\n        res[k++] = v[i];\n    }\n    res.resize(k-1);\n    return res;\n}\n\n// 凸多角形の直径\nlong double convex_diameter(vector<CP> &v) {\n    vector<CP> cv = convex_hull(v);\n    int n = cv.size();\n    if(n == 2) return abs(cv[0]-cv[1]);     // 凸包が潰れている例外処理\n    int i = 0, j = 0;   // x軸方向に最も遠い点対\n    for(int k = 0; k < n; ++k) {\n        if(cv[k].real() < cv[i].real()) i = k;\n        if(cv[k].real() > cv[j].real()) j = k;\n    }\n    long double res = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si) {     // 180度回転で終了\n        res = max(res, abs(cv[i]-cv[j]));\n        if(cross(cv[(i+1)%n]-cv[i], cv[(j+1)%n]-cv[j]) < 0) {\n            (++i) %= n;\n        }else {\n            (++j) %= n;\n        }\n    }\n    return res;\n}\n\n// 凸多角形を点s,tを通る直線で切断(左側が取得できる)\nvector<CP> convex_cut(const vector<CP> &v, const CP &s, const CP &t) {\n    vector<CP> res;\n    int n = v.size();\n    for(int i = 0; i < n; ++i) {\n        CP nows = v[i], nowt = v[(i+1)%n];\n        if(cross(t-s, nows-s) >= -EPS) res.emplace_back(nows);\n        if(cross(t-s, nows-s)*cross(t-s, nowt-s) < 0) {\n            res.emplace_back(intersection_line(s, t, nows, nowt));\n        }\n    }\n    return res;\n}\n\n// n多角形に対する点pの包含関係(自己交差多角形は例外)\nint contain_polygon_point(const vector<CP> &v, CP p) {\n    int contain = 0, on_segment = 0;\n    int n = v.size();\n    for(int i = 0; i < n; ++i) {\n        on_segment |= is_point_on_lines(v[i], v[(i+1)%n], p);   // 辺上判定\n        CP s = v[i]-p, t = v[(i+1)%n]-p;\n        if(s.imag() > t.imag()) swap(s, t);     // 下側を基準にする\n        if(s.imag()*t.imag() <= 0 && t.imag() > 0 && cross(s, t) > 0) {\n            contain = !contain;     // 交差回数が奇数なら内側\n        }\n    }\n    if(on_segment) return 1;    // 辺上\n    if(contain) return 2;       // 内側\n    return 0;       // 外側\n}\n\n// 最近点対距離\nlong double closest_pair(vector<CP> &v, int l = -1, \n                         int r = -1, bool reqsqrt = 0) {\n    if(l == r && l == -1) {\n        l = 0; r = v.size(); reqsqrt = 1;\n        // x座標→y座標で昇順ソート\n        auto lmd = [&](const CP &l, const CP &r) {\n            if(l.real() != r.real()) return l.real() < r.real();\n            return l.imag() < r.imag();\n        };\n        sort(v.begin(), v.end(), lmd);\n    }\n    if(r-l < 2) return 1e18;\n    if(r-l == 2) {\n        if(v[l].imag() > v[l+1].imag()) swap(v[l], v[l+1]);\n        if(reqsqrt) return abs(v[l]-v[l+1]);\n        return norm(v[l]-v[l+1]);\n    }\n    int mid = (l+r)/2;\n    long double x = v[mid].real();\n    long double res = min(closest_pair(v, l, mid), closest_pair(v, mid, r));\n    auto f = [](CP pl, CP pr) { return pl.imag() < pr.imag(); };\n    inplace_merge(v.begin()+l, v.begin()+mid, v.begin()+r, f);\n    vector<CP> tmp;\n    for(int i = l; i < r; ++i) {\n        long double dx = abs(v[i].real()-x);\n        int tsize = tmp.size();\n        if(dx*dx >= res) continue;\n        for(int j = 0; j < tsize; ++j) {\n            CP delta = v[i]-tmp[tsize-1-j];\n            if(delta.imag()*delta.imag() >= res) break;\n            res = min(res, norm(delta));\n        }\n        tmp.emplace_back(v[i]);\n    }\n    if(reqsqrt) res = sqrtl(res);\n    return res;\n}\n\n// 3点の位置関係を判定\nint calc_clockwise(CP p0, CP p1, CP p2) {\n    CP x = p1-p0, y = p2-p0;\n    if(cross(x, y) > EPS) return 1;     // \"COUNTER_CLOCKWISE\"\n    if(cross(x, y) < -EPS) return -1;   // \"CLOCKWISE\"\n    if(dot(x, y) < 0) return 2;         // \"ONLINE_BACK\"\n    if(norm(x) < norm(y)) return -2;    // \"ONLINE_FRONT\"\n    return 0;                           // \"ON_SEGMENT\" \n}\n\nint main() {\n    int n; cin >> n;\n    vector<CP> point;\n    for(int i = 0; i < n; ++i) {\n        long double a, b; cin >> a >> b;\n        point.emplace_back(CP(a, b));\n    }\n    cout << fixed << setprecision(10);\n    cout << closest_pair(point) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<utility>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n\ntypedef pair<double, double> point;\ntypedef point* data;\n\ninline double dist(const point &a, const point &b)\n{\n    double dx = a.first - b.first, dy = a.second - b.second;\n    return sqrt(dx * dx + dy * dy);\n}\n\nbool sort_y(const point &P1, const point &P2){ return P1.second < P2.second; }\n\ndouble closest(data P, int n)\n{\n    if(n <= 1) return 1000;\n    if(n == 2) return dist(P[0], P[1]);\n    int m = n / 2;\n    sort(P, P + n, sort_y); // y_sort, down to up.\n    double d = min(closest(P, m), closest(P + m, n - m));\n    double median = P[m].second;\n\n    sort(P, P + m);\n    sort(P + m, P + n);\n    // x_sort, left to right.\n    int a, b, u, v, i, j;\n    a = u = i = 0, b = v = j = m;\n    while(i < m && j < n){\n        if(P[u].first < P[v].first){\n            for(i = a; i < m; i++){\n                if(P[i].first >= P[v].first){ u = i; break; }\n                if(P[v].first - P[i].first >= d){ a++; }\n                else{\n                    if(median - P[i].second >= d) continue;\n                    d = min(d, dist(P[v], P[i]));\n                }\n            }\n        }else{\n            for(j = b; j < n; j++){\n                if(P[j].first > P[u].first){ v = j; break; }\n                if(P[u].first - P[j].first >= d){ b++; }\n                else{\n                    if(P[j].second - median >= d) continue;\n                    d = min(d, dist(P[u], P[j]));\n                }\n            }\n        }\n    };\n    return d;\n}\n\nint main()\n{\n\tint i, n;\n\tdouble x, y;\n\tscanf(\"%d\", &n);\n\tdata P;\n\tP = new point [n];\n\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &x, &y);\n\t\tP[i] = make_pair(x, y);\n\t}\n\tprintf(\"%.12f\\n\", closest(P, n));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\ntypedef complex<double> P;\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n};\ntypedef vector<P> Polygon;\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\n// ??????\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\n// ????¬?????????????2??????\ndouble norm(const P& a) {\n    return real(conj(a)*a);\n}\n\n// ??????\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\n\n// ???p2?????????p0, p1???????????´???????°???±?????????\nP projection(const P& p0, const P& p1, const P& p2) {\n    // ???????????????????????´???\n    P vec1 = p1 - p0;\n    P vec2 = p2 - p0;\n    return p0 + vec1 * dot(vec1, vec2) / dot(vec1, vec1);\n}\n\n// projection?????\\??¨???\n// not verified\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\n// ???p0, p1???????????´??????????§°?????¨????????????p2??¨????§°??????\nP reflection(const P& p0, const P& p1, const P& p2) {\n    P proj = projection(p0, p1, p2);\n    return proj - (p2 - proj);\n}\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;                               // a--c--b on line\n}\n\n// 2??´?????????????????????\nbool is_parallel(const L& l1, const L& l2) {\n    P p1 = l1[1] - l1[0];\n    P p2 = l2[1] - l2[0];\n    auto res = ccw(p1, p2, P(0,0));\n    return (res == 2 || res == -2 || res == 0);\n}\n\n// 2??´???????????´?????????\nbool is_ortho(const L& l1, const L& l2) {\n    P p1 = l1[1] - l1[0];\n    P p2 = l2[1] - l2[0];\n    return dot(p1, p2) == 0;\n}\n\n// l: line(??´???)\n// s: segment(??????)\n// not verified\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\n// not verified\nbool intersectLS(const L &l, const L &s) {\n    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n        cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\n\n// not verified\nbool intersectLP(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool intersectSS(const L &s, const L &t) {\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\n// not verified\nbool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n// not verified\ndouble distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\n// not verified\ndouble distanceLL(const L &l, const L &m) {\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\n// not verified\ndouble distanceLS(const L &l, const L &s) {\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n\ndouble distanceSP(const L &s, const P &p) {\n    const P r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n               min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n// 2??´????????????\nP crosspoint(const L &l, const L &m) {\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    return m[0] + B / A * (m[1] - m[0]);\n}\n\n// ????§???¢?????¢???????±???????\n// P???????????¨???????????????\ndouble convexArea(const Polygon& poly) {\n    double area = 0.0;\n    REP(i, SIZE(poly))\n        area += cross(curr(poly, i), next(poly, i));\n    return abs(area) * 0.5;\n}\n\n// ??????????±??????????????????????????????????????????????\n// ????????????????¨?????????§????????????\n// not verified\nPolygon convexHull(const Polygon& poly) {\n    Polygon ps = poly;\n\n    int n = ps.size(), k = 0;\n    sort(ALL(ps));\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\n// ??????????±????????????????????????????????????????????????????\n// ????????????????¨?????????§????????????\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=jp\nPolygon convexHullInludingPointsOnEdge(const Polygon& poly) {\n    Polygon ps = poly;\n\n    int n = ps.size(), k = 0;\n    sort(ALL(ps));\n    Polygon ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\n// ?????§??????\n// poly?????????????¨???¨?????§?????????????´?????????????????????¨???????????????\n// ???????????´??????????????¶???????¨±???\nbool isConvex(const Polygon &poly) {\n    REP(i, SIZE(poly)) {\n        if (ccw(prev(poly, i), curr(poly, i), next(poly, i)) == -1)\n            return false;\n    }\n    return true;\n}\n\n// poly????????§???????????¨?????????\n// 0: OUT\n// 1: ON\n// 2: IN\n// not verified\nenum { OUT, ON, IN };\nint convexContains(const Polygon &poly, const P &p) {\n    const int n = poly.size();\n    P g = (poly[0] + poly[n/3] + poly[2*n/3]) / 3.0; // inner-P\n    int a = 0, b = n;\n    while (a+1 < b) { // invariant: c is in fan g-poly[a]-poly[b]\n        int c = (a + b) / 2;\n        if (cross(poly[a]-g, poly[c]-g) > 0) { // angle < 180 deg\n            if (cross(poly[a]-g, p-g) > 0 && cross(poly[c]-g, p-g) < 0) b = c;\n            else                                                  a = c;\n        } else {\n            if (cross(poly[a]-g, p-g) < 0 && cross(poly[c]-g, p-g) > 0) a = c;\n            else                                                  b = c;\n        }\n    }\n    b %= n;\n    if (cross(poly[a] - p, poly[b] - p) < 0) return OUT;\n    if (cross(poly[a] - p, poly[b] - p) > 0) return IN;\n    return ON;\n}\n\n// poly????????§???????????????\n// 0: OUT\n// 1: ON\n// 2: IN\nint contains(const Polygon& poly, const P& p) {\n    bool in = false;\n    REP(i, SIZE(poly)) {\n        P a = curr(poly,i) - p, b = next(poly,i) - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b))\n            if (cross(a, b) < 0) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\n\n// ????§???¢?????´?????????2???????????????\n// ??\\????????????????????§?????????????????????\ndouble convexDiameterSquared(const Polygon &poly) {\n    const int n = poly.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(poly[i]) > imag(poly[is])) is = i;\n        if (imag(poly[i]) < imag(poly[js])) js = i;\n    }\n    double maxd = norm(poly[is]-poly[js]);\n\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n        if (cross(diff(poly,i), diff(poly,j)) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (norm(poly[i]-poly[j]) > maxd) {\n            maxd = norm(poly[i]-poly[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd; /* farthest pair is (maxi, maxj). */\n}\n\n// ???????§???¢?????????\n// ???????§???¢???????????´?????§???????????????????????´????????????\nPolygon convexCut(const Polygon& p, const L& l) {\n    Polygon Q;\n    REP(i, SIZE(p)) {\n        P A = curr(p, i);\n        P B = next(p, i);\n        if (ccw(l[0], l[1], A) != -1)\n            Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspoint(L(A, B), l));\n    }\n    return Q;\n}\n\n// fail\npair<P,P> closestPairFail(vector<P> p) {\n    int n = p.size();\n    int s = 0;\n    int t = 1;\n    int m = 2;\n    int S[n];\n    S[0] = 0, S[1] = 1;\n    sort(ALL(p)); // \"p < q\" <=> \"p.x < q.x\"\n    double d = norm(p[s]-p[t]);\n    for (int i = 2; i < n; S[m++] = i++) REP(j, m) {\n            if (norm(p[S[j]]-p[i])<d) d = norm(p[s = S[j]]-p[t = i]);\n            if (real(p[S[j]]) < real(p[i]) - d) S[j--] = S[--m];\n        }\n    return make_pair( p[s], p[t] );\n}\n\npair<P,P> closestPair(vector<P> p) {\n    sort(ALL(p)); // \"p < q\" <=> \"p.x < q.x\"\n    double min_d = norm(p[0] - p[1]);\n    int size = p.size();\n\n    pair<int,int> ret{0,1};\n\n    REP(i, size-1) {\n        FOR(j, i+1, size) {\n            if ( pow(real(p[j]) - real(p[i]), 2) > min_d ) break;\n            double d = norm(p[i] - p[j]);\n            if (d < min_d) {\n                min_d = d;\n                ret = mp(i,j);\n            }\n        }\n    }\n\n    return mp(p[ret.first], p[ret.second]);\n}\n\nint main(){\n    int N;\n    cin >> N;\n    vector<P> points;\n    REP(n, N) {\n        double x, y;\n        cin >> x >> y;\n        points.pb( P(x,y) );\n    }\n\n    auto res = closestPair(points);\n    printf(\"%.10lf\\n\", sqrt(norm(res.first - res.second)));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct node{\n  int dim;\n  vector<double>v;\n};\n\ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n\ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n\n  vector<node>res;\n\n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n\n    double dist=d(p,S)/(4*p.dim);\n\n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n\n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    \n    S=nextS;    \n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n  \n  return ans;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n\n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n\n    two_dimensional_qsort(p_xy, n0, n-1, 1);\n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        \n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<< ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(__typeof((o).begin()) it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T> >& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){EACH(a,ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;EACH(p,m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\ntemplate<> long double INF<long double>(){return 1e16;};\n\ntemplate<typename T> T pmod(T v,T M){return (v%M+M)%M;}\n\nnamespace _double_tmpl{\n    typedef long double D;const D EPS = 1e-8;\n    \n    static constexpr D Ae=0;\n    D A(D a,D b){return a+b;}D Ainv(D a){return -a;}\n    D S(D a,D b){return A(a,Ainv(b));}\n    \n    static constexpr D Me=1;\n    D M(D a,D b){return a*b;}D Minv(D a){return 1.0/a;};\n\n    int sig(D a,D b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n    bool eq(D a,D b){ return sig(abs(a-b))==0;}\n\n}\nusing namespace _double_tmpl;\n\n\nnamespace Ps{\n    // using namespace _double_tmpl;\n    typedef complex<D> P,Vec;\n\n#define X real()\n#define Y imag()\n    istream& operator >> (istream& is,complex<D>& p){\n        D x,y;is >> x >> y;p=P(x,y);return is;\n    }\n\n    bool eq(P a,P b){return eq(a.X,b.X) and eq(a.Y,b.Y);}\n    // a×b\n    D cross(const Vec& a,const Vec& b){return imag(conj(a)*b);}\n    // a・b\n    D dot(const Vec&a,const Vec& b) {return real(conj(a)*b);}\n\n    int ccw(const P& a,P b,P c){\n        b -= a; c -= a;\n        if (cross(b,c) > EPS)   return +1;       // counter clockwise\n        if (cross(b,c) < -EPS)   return -1;       // clockwise\n        if (dot(b,c) < 0)     return +2;       // c--a--b on line\n        if (norm(b) < norm(c)) return -2;       // a--b--c on line\n        return 0;\n    }\n\n    D closestPair(vector<P>& ps,int l,int r){\n        if(r-l<2)return INF<D>();\n        D res=INF<D>();\n        res=min(res,closestPair(ps,l,(l+r)/2));\n        res=min(res,closestPair(ps,(l+r)/2,r));\n        vector<P> lps,rps;\n        FOR(i,l,(l+r)/2)if(abs(ps[i].X - ps[(l+r)/2].X)<res)lps.push_back(ps[i]);\n        FOR(i,(l+r)/2,r)if(abs(ps[i].X - ps[(l+r)/2].X)<res)rps.push_back(ps[i]);\n\n        REP(i,lps.size())REP(j,rps.size())res=min(res,abs(lps[i]-rps[j]));\n        return res;\n    }\n}\nusing namespace Ps;\n\nnamespace std{\n    bool operator < (const P& a,const P& b){\n            return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n    bool operator == (const P& a,const P& b){\n            return eq(a,b);\n    }\n};\n\nstringstream ss;\nclass Main{\n    public:\n    void run(){\n        int n;cin >> n;\n        vector<P> ps;\n        REP(i,n) {\n            P p;cin >> p;\n            ps.push_back(p);\n        }\n        sort(ALL(ps));\n        cout << closestPair(ps,0,n)<<endl;\n    }\n};\n\nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 1000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i+j<N&&memo >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8)<<sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct node{\n  int dim;\n  vector<double>v;\n};\n\ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n\ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n\n  vector<node>res;\n\n  while(S.size()>1){\n    res=S;\n    node p=S[rand()%S.size()];\n\n    double dist=d(p,S)/(4*p.dim);\n\n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n\n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    \n    S=nextS;    \n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n  \n  return ans;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n\n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\ntypedef pair<double, double> P;\n\nint n;\npair<double ,double> p[100000];\n\nint main() {\n\tint i, j;\n\t\n\tcin >> n;\n\tfor (i = 0; i < n; i++) cin >> p[i].first >> p[i].second;\n\t\n\t//random rotate\n\tdouble rad = 0.364364334 * 3.14159265358979;\n\tfor (i = 0; i < n; i++) {\n\t\tdouble x = p[i].first * cos(rad) - p[i].second * sin(rad);\n\t\tdouble y = p[i].first * sin(rad) + p[i].second * cos(rad);\n\t\tp[i].first = x;\n\t\tp[i].second = y;\n\t}\n\t\n\tsort(p, p + n);\n\t\n\tdouble minDist2 = 1145141919;\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i - 1; j >= 0; j--) {\n\t\t\tdouble dx = p[i].first - p[j].first;\n\t\t\tdouble dy = p[i].second - p[j].second;\n\t\t\tdouble dist = dx * dx + dy * dy;\n\t\t\t\n\t\t\tif (dx * dx >= minDist2) break;\n\t\t\t\n\t\t\tminDist2 = min(minDist2, dist);\n\t\t}\n\t}\n\t\n\tprintf(\"%.14f\\n\", sqrt(minDist2));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&ans >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\n\ntypedef long long ll;\n\nbool debug = false;\nconst double INF = 1000001;\nconst double eps = 1e-10;\nclock_t START, END;\n\n//basic defitition\nstruct Point {\n\tint i;\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0, int i = 0) :x(x), y(y), i(i) {}\n\tbool operator < (const Point& rhs) const {\n\t\treturn x < rhs.x;\n\t}\n};\nint dcmp(double x) {\n\tif (fabs(x) < eps) return 0; else return x < 0 ? -1 : 1;\n}\ndouble Distance(Point P, Point Q) {\n\tdouble _ans = sqrt(fabs(P.x - Q.x) * fabs(P.x - Q.x) + fabs(P.y - Q.y) * fabs(P.y - Q.y));\n\treturn _ans;\n}\n\ndouble shortestdistance = 0;\nvector<Point> S_X, S_Y;\n\ndouble divide(int L, int R) {\n\tif (R - L <= 2) {\n\t\tfor (int i = L; i < R; i++) {\n\t\t\tfor (int j = i + 1; j <= R; j++) {\n\t\t\t\tif (S_Y[i].y > S_Y[j].y) {\n\t\t\t\t\tswap(S_Y[i].x, S_Y[j].x);\n\t\t\t\t\tswap(S_Y[i].y, S_Y[j].y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch (R - L) {\n\t\tcase 2: return min(Distance(S_X[L + 1], S_X[R]), min(Distance(S_X[L], S_X[R]), Distance(S_X[L], S_X[L + 1]))); break;\n\t\tcase 1: return Distance(S_X[L], S_X[R]); break;\n\t\tdefault: return INF;\n\t\t}\n\t}\n\telse {\n\t\tint M = L + (R - L) / 2;\n\t\tdouble _min = min(divide(L, M), divide(M + 1, R));\n\t\tdouble l = (R - L) % 2 ? (S_X[M].x + S_X[M + 1].x) / 2 : S_X[M].x;\n\t\tvector<Point> Y, T;\n\t\tint i, j;\n\t\tfor (i = L, j = M + 1; i <= M && j <= R;) {\n\t\t\tif (S_Y[i].y <= S_Y[j].y) {\n\t\t\t\tif (dcmp(S_Y[i].x - l + _min) >= 0 && dcmp(l + _min - S_Y[i].x) >= 0)\n\t\t\t\t\tY.push_back(S_Y[i]);\n\t\t\t\tT.push_back(S_Y[i]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dcmp(S_Y[j].x - l + _min) >= 0 && dcmp(l + _min - S_Y[j].x) >= 0)\n\t\t\t\t\tY.push_back(S_Y[j]);\n\t\t\t\tT.push_back(S_Y[j]);\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\twhile (i <= M) {\n\t\t\tif (dcmp(S_Y[i].x - l + _min) >= 0 && dcmp(l + _min - S_Y[i].x) >= 0)\n\t\t\t\tY.push_back(S_Y[i]);\n\t\t\tT.push_back(S_Y[i++]);\n\t\t}\n\t\twhile (j <= R) {\n\t\t\tif (dcmp(S_Y[j].x - l + _min) >= 0 && dcmp(l + _min - S_Y[j].x) >= 0)\n\t\t\t\tY.push_back(S_Y[j]);\n\t\t\tT.push_back(S_Y[j++]);\n\t\t}\n\t\tfor (i = L, j = 0; i <= R; i++, j++)\n\t\t\tS_Y[i] = T[j];\n\t\tint N = Y.size();\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tfor (j = i + 1; j <= i + 6 && j < N; j++) {\n\t\t\t\t_min = min(_min, Distance(Y[i], Y[j]));\n\t\t\t}\n\t\t}\n\t\tY.clear();\n\t\t//printf(\"%.10lf\\n\", _min);\n\t\treturn _min;\n\t}\n}\n\nint main(void)\n{\n\tif (debug) {\n\t\tSTART = clock();\n\t\tfreopen(\"in19.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t}\n\tint n;\n\tdouble x, y;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t\tS_X.push_back(Point(x, y, i));\n\t\tS_Y.push_back(Point(x, y, i));\n\t}\n\tsort(S_X.begin(), S_X.end());\n\tsort(S_Y.begin(), S_Y.end());\n\tdouble ans = divide(0, n - 1);\n\tprintf(\"%.6lf\\n\", ans);\n\tif (debug) {\n\t\tEND = clock();\n\t\tdouble endtime = (double)(END - START) / 1000;\n\t\tprintf(\"total time = %lf s\", endtime);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @note   関連URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0585\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = limits::inf;\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta + limits::eps) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) >= delta + limits::eps) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\n\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  // if (r - l <= 3) {\n  //   PointPoint res(ps[l], ps[r - 1]);\n  //   for (int i = l; i < r; ++i) {\n  //     for (int j = i + 1; j < r; ++j) {\n  //       res = Closer(res, PointPoint(ps[i], ps[j]));\n  //     }\n  //   }\n  //   return res;\n  // }\n  if (r - l == 2) {\n    return PointPoint(ps[l], ps[l + 1]);\n  }\n  if (r - l == 3) {\n    PointPoint a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return Closer(a, Closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  // Points lp, rp;\n  // for (int i = l; i < mid; ++i) {\n  //   if (abs(ps[i].real() - midPoint.real()) < d) lp.push_back(ps[i]);\n  // }\n  // for (int i = mid; i < r; ++i) {\n  //   if (abs(ps[i].real() - midPoint.real()) < d) rp.push_back(ps[i]);\n  // }\n  // for (int i = 0; i < lp.size(); ++i) {\n  //   for (int j = 0; j < rp.size(); ++j) {\n  //     if (Distance(lp[i], rp[j]) < d) {\n  //       d = Distance(lp[i], rp[j]);\n  //       res = PointPoint(lp[i], rp[j]);\n  //     }\n  //   }\n  // }\n\n  Points pos[2];\n  for (int i = l; i < r; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) pos[i < mid].push_back(ps[i]);\n  }\n  for (int i = 0; i < pos[0].size(); ++i) {\n    for (int j = 0; j < pos[1].size(); ++j) {\n      if (Distance(pos[0][i], pos[1][j]) < d) {\n        d = Distance(pos[0][i], pos[1][j]);\n        res = PointPoint(pos[0][i], pos[1][j]);\n      }\n    }\n  }\n  // Points strip;\n  // for (int i = l; i < r; ++i) {\n  //   if (abs(ps[i].real() - midPoint.real()) < d) strip.push_back(ps[i]);\n  // }\n  // for (int i = 0; i < strip.size(); ++i) {\n  //   for (int j = i + 1; j < strip.size(); ++j) {\n  //     if (Distance(strip[i], strip[j]) < d) {\n  //       d = Distance(strip[i], strip[j]);\n  //       res = PointPoint(strip[i], strip[j]);\n  //     }\n  //   }\n  // }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  PointPoint res = ClosestPairUtil(ps, 0, ps.size());\n  res.first = rotate(-0.1, res.first);\n  res.second = rotate(-0.1, res.second);\n  return res;\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  sort(p.begin(), p.end());\n  PointPoint pp = ClosestPair(p);\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n  // cerr << pp.first << \" \" << pp.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/10))  \n #define Fun2(j,n) for(int j=i+(int)(n/10);j<n;j=j+(int)(n/10))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=100;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16??????????????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   //?°?16????????????????????????????????? \n   minx=minx-1;\n   miny=miny-1;\n   maxx=maxx+1;\n   maxy=maxy+1;\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=3;j>=0;j--)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*(3-j)+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n   /*\n   for(int i=0;i<16;i++)\n   {\n     for(int j=0;j<num_point[i];j++)\n     {\n       cout<<wu[i][j].x<<\" \"<<wu[i][j].y<<endl;        \n     }        \n   }\n   */\n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       //real_min=(point[0].x-point[1].x)*(point[0].x-point[1].x)+(point[0].y-point[1].y)*(point[0].y-point[1].y);\n       real_min=fun_min;\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A?????? \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main()\n{\n    int n; float x[100000], y[100000];\n    \n    scanf(\"%d\", &n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%f\", &x[i]);\n        scanf(\"%f\", &y[i]);\n    }\n    \n    float sqr_ans = 100000000.0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = i + 1; j < n; j++)\n        {\n            sqr_ans = min((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]), sqr_ans);\n        }\n    }\n    \n    printf(\"%.15f\\n\", sqrt(sqr_ans));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\n//typedef pair<ll, ll> P;\n//const double INF = 1e10;\n//const ll INF = LONG_LONG_MAX / 100;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\n//bool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\n\nvoid print_line(vector<string> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point {\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator+(Point p) { return Point(x + p.x, y + p.y); }\n\n    Point operator-(Point p) { return Point(x - p.x, y - p.y); }\n\n    Point operator*(double a) { return Point(a * x, a * y); }\n\n    Point operator/(double a) { return Point(x / a, y / a); }\n\n    double abs() { return sqrt(norm()); }\n\n    double norm() { return x * x + y * y; }\n\n    bool operator<(const Point &p) const {\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator==(const Point &p) const {\n        return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\n\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\ndouble dot(Vector a, Vector b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;   // p2->p0->p1\nstatic const int ONLINE_FRONT = -2; // p0->p1->p2\nstatic const int ON_SEGMENT = 0;    // p0->p2->p1\n\ndouble norm(Point a) {\n    return a.x * a.x + a.y * a.y;\n}\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS) return ONLINE_BACK;\n    if (norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nPolygon f(Polygon g) {\n    Polygon u, l;\n    if (g.size() < 3) return g;\n    sort(g.begin(), g.end());\n    u.push_back(g[0]);\n    u.push_back(g[1]);\n    l.push_back(g[g.size() - 1]);\n    l.push_back(g[g.size() - 2]);\n\n    // upper\n    for (int i = 2; i < g.size(); i++) {\n        for (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], g[i]) == COUNTER_CLOCKWISE; n--) {\n            u.pop_back();\n        }\n        u.push_back(g[i]);\n    }\n\n    // lower\n    for (int i = g.size() - 3; i >= 0; i--) {\n        for (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], g[i]) == COUNTER_CLOCKWISE; n--) {\n            l.pop_back();\n        }\n        l.push_back(g[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\n    return l;\n}\n\n\ndouble abs(Point a) {\n    return sqrt(norm(a));\n}\n\n\ndouble getDistance(Point a, Point b) {\n    return abs(a - b);\n}\n\n\ndouble convexDiameter(Polygon g) {\n    double d = 0.0;\n    int n = g.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; i++) {\n        if (g[i].y > g[is].y) is = i;\n        if (g[i].y < g[js].y) js = i;\n    }\n    d = getDistance(g[is], g[js]);\n\n    int i = is, j = js, maxi = is, maxj = js;\n    do {\n        if (cross(g[(i + 1) % n] - g[i], g[(j + 1) % n] - g[j]) >= 0.0) j = (j + 1) % n;\n        else i = (i + 1) % n;\n        if (getDistance(g[i], g[j]) > d) {\n            d = getDistance(g[i], g[j]);\n            maxi = i, maxj = j;\n        }\n    } while (i != is || j != js);\n\n    return d;\n}\n\nstruct Segment {\n    Point p1, p2;\n\n    Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\nbool isParallel(Vector a, Vector b) {\n    return equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return isParallel(a1 - a2, b1 - b2);\n}\n\nbool isParallel(Segment s1, Segment s2) {\n    return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n\nPolygon andrewScan(Polygon g) {\n    Polygon u, l;\n    if (g.size() < 3) return g;\n    sort(g.begin(), g.end());\n    u.push_back(g[0]);\n    u.push_back(g[1]);\n    l.push_back(g[g.size() - 1]);\n    l.push_back(g[g.size() - 2]);\n\n    // upper\n    for (int i = 2; i < g.size(); i++) {\n        for (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], g[i]) != CLOCKWISE; n--) {\n            u.pop_back();\n        }\n        u.push_back(g[i]);\n    }\n\n    // lower\n    for (int i = g.size() - 3; i >= 0; i--) {\n        for (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], g[i]) != CLOCKWISE; n--) {\n            l.pop_back();\n        }\n        l.push_back(g[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\n    return l;\n}\n\n\ndouble area(Polygon g) {\n    if (g.size() < 3) return 0;\n    int n = g.size();\n    Point o(0.0, 0.0);\n    double s = 0.0;\n    for (int i = 0; i < n; i++) s += cross(g[i] - o, g[(i + 1) % n] - o);\n    return abs(s) / 2.0;\n}\n\nconst double INF = 1e10;\n\ntypedef pair<double, double> p;\np v[100000];\n\nbool comp_y(p a, p b) {\n    return a.second < b.second;\n}\n\ndouble closest_pair(p *a, int n) {\n    if (n <= 1) return INF;\n\n    int m = n / 2;\n    double x = a[m].first;\n    double d = min(closest_pair(a, m), closest_pair(a + m, n - m)); // x軸で区切られた範囲内での頂点対のみ考慮\n    inplace_merge(a, a + m, a + n, comp_y); // ソート済みの[a, a+m)と[a+m, a+n)をy座標基準でマージ\n\n    vector<p> b; // 直線 x = a[m].firstから距離d未満の点を入れる\n    for (int i = 0; i < n; i++) {\n        if (fabs(a[i].first - x) >= d) continue; // そもそもx座標の差がd以上の点は論外\n\n        // bに入っている頂点を末尾から、y座標の差がd以上になるまで見ていく\n        // y座標降順で見ていき、d以上離れた時点で打ち切り\n        for (int j = 0; j < b.size(); j++) {\n            double dx = a[i].first - b[b.size() - 1 - j].first;\n            double dy = a[i].second - b[b.size() - 1 - j].second;\n            if (dy >= d) break;\n            d = min(d, sqrt(dx * dx + dy * dy));\n        }\n\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\n\nint main() {\n\n\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        double x, y;\n        cin >> x >> y;\n        v[i] = {x, y};\n    }\n    sort(v, v + n);\n    cout << fixed << setprecision(12) << closest_pair(v, n) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/50))  \n #define Fun2(j,n) for(int j=i+(int)(n/50);j<n;j=j+(int)(n/50))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=20;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16????????????????????¢???10??????????????§?????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n double dx,dy;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   //?°?16????????????????????????????????? \n   minx=minx-1;\n   miny=miny-1;\n   maxx=maxx+1;\n   maxy=maxy+1;\n   dx=1.0/4*(maxx-minx);\n   dy=1.0/4*(maxy-miny);\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=3;j>=0;j--)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*(3-j)+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n   /*\n   for(int i=0;i<16;i++)\n   {\n     for(int j=0;j<num_point[i];j++)\n     {\n       cout<<wu[i][j].x<<\" \"<<wu[i][j].y<<endl;        \n     }        \n   }\n   */\n }\n \n //??????????????????????????¬??????0.04%???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n //?????¢????????????????????????????§???????????????¢?????? \n void circle_optimize(double center)\n {\n      \n }\n \n void triangle_optimize()\n {\n      \n }\n \n void rectangle_optimize()\n {\n      \n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       \n       if(fun_min!=(40000.0*2)) real_min=fun_min;\n       else real_min=(point[0].x-point[1].x)*(point[0].x-point[1].x)+(point[0].y-point[1].y)*(point[0].y-point[1].y);\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         bool flag1,flag2,flag3,flag4,judge; \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {      \n             //???????????????????????¬???????????????????????¨?????????????????????????¬????????°????????????????????????????????????????????°???????????????°?????¨ \n             double theta=sqrt(real_min)/2;\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               flag1=flag2=flag3=flag4=false;\n               judge=false;\n               if(point[i].x>=(minx+(n+1)*dx-theta)) flag1=true;\n               if(point[i].x<=(minx+(n+1)*dx)) flag2=true;\n               if(point[i].y>=(miny+(3-m)*dy)) flag3=true;\n               if(point[i].y<=(miny+(4-m)*dy)) flag4=true;\n               judge=flag1&&flag2&&flag3&&flag4;\n               if(!judge) continue;\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 flag1=flag2=flag3=flag4=false;\n                 judge=false;\n                 if(point[j].x>=(minx+(n+1)*dx)) flag1=true;\n                 if(point[j].x<=(minx+(n+1)*dx+theta)) flag2=true;\n                 if(point[j].y>=(miny+(3-m)*dy)) flag3=true;\n                 if(point[j].y<=(miny+(4-m)*dy)) flag4=true;\n                 judge=flag1&&flag2&&flag3&&flag4;\n                 if(!judge) continue;\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             double theta=sqrt(real_min)/2;\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               flag1=flag2=flag3=flag4=false;\n               judge=false;\n               if(point[i].x>=(minx+n*dx)) flag1=true;\n               if(point[i].x<=(minx+(n+1)*dx)) flag2=true;\n               if(point[i].y>=(miny+(3-m)*dy)) flag3=true;\n               if(point[i].y<=(miny+(3-m)*dy+theta)) flag4=true;\n               judge=flag1&&flag2&&flag3&&flag4;\n               if(!judge) continue;\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 flag1=flag2=flag3=flag4=false;\n                 judge=false;\n                 if(point[j].x>=(minx+n*dx)) flag1=true;\n                 if(point[j].x<=(minx+(n+1)*dx)) flag2=true;\n                 if(point[j].y>=(miny+(3-m)*dy-theta)) flag3=true;\n                 if(point[j].y<=(miny+(3-m)*dy)) flag4=true;\n                 judge=flag1&&flag2&&flag3&&flag4;\n                 if(!judge) continue;\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <climits>\nusing namespace std;\n\ntypedef pair<double, double> P;\n\ndouble getClosestPairVirtical(vector<P> &v, int s, int t){\n    double d = INT_MAX;\n    for(int i=s+1; i<t; i++){\n        d = min(d, v[i].second-v[i-1].second);\n    }\n    return d;\n}\n\nbool inRange(double v, double l, double r){\n    return l<=v && v<=l;\n}\n\nbool compare_y(P a, P b){\n    return a.second < b.second;\n}\n\ndouble getClosestPair(vector<P> &v, int s, int t){\n    if(t-s==1) return INT_MAX;\n    if(v[s].first == v[t-1].first) return getClosestPairVirtical(v, s, t);\n    const double mid = (v[s].first+v[t-1].first)/2;\n    int midPos;\n    for(midPos=s; midPos<t && v[midPos].first<mid; midPos++);\n    const double d1 = getClosestPair(v, s, midPos);\n    const double d2 = getClosestPair(v, midPos, t);\n    double d = min(d1, d2);\n    inplace_merge(v.begin()+s, v.begin()+mid, v.begin()+t, compare_y);\n    vector<P> use;\n    for(int i=s; i<t; i++){\n        if(fabs(v[i].first-mid)>d) continue;\n        for(int j=use.size()-1; j>=0; j--){\n            if(fabs(v[i].second-use[j].second)>d) break;\n            double dx = v[i].first-use[j].first;\n            double dy = v[i].second-use[j].second;\n            d = min(d, sqrt(dx*dx + dy*dy));\n        }\n        use.push_back(v[i]);\n    }\n    return d;\n}\n\nint main(){\n    int n;\n    double x, y;\n    cin >> n;\n    vector<P> v;\n    for(int i=0; i<n; i++){\n        P p;\n        cin >> p.first >> p.second;\n        v.push_back(p);\n    }\n    sort(v.begin(), v.end());\n    cout << getClosestPair(v, 0, v.size()) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ntypedef vector<P> G;\n\ndouble compare_x(const P &a, const P &b){\n  return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n}\n\ndouble compare_y(const P &a, const P &b){\n  return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;\n}\n\ndouble convex_radius(P *a, int n){\n    if(n <= 1) return INF;\n    int m = n / 2;\n    double x = a[m].X;\n    double d = min(convex_radius(a, m), convex_radius(a + m, n - m));\n    sort(a, a + n, compare_y);\n    vector<P> b;\n    for(int i = 0; i < n; ++i){\n        if(fabs(a[i].X - x) >= d) continue;\n        for(int j = 0; j < b.size(); ++j){\n            double dx=a[i].X-b[b.size()-j-1].X;\n            double dy=a[i].Y-b[b.size()-j-1].Y;\n            if(dy >= d)break;\n            d=min(d,sqrt(dx*dx+dy*dy));\n              \n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n\nint main() {\n  int N; cin >>N;\n  G g(N);\n  REP(i, N){\n    double x, y; cin >>x >>y;\n    g[i] = P(x, y);\n  }\n  sort(g.begin(), g.end(), compare_x);\n  printf(\"%.10lf\\n\", convex_radius(&g[0], N));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nstruct P\n{\n\tlong double x, y;\n\tP(long double x, long double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tlong double length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tlong double length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nint ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}\n\npair<P, P> ClosestPair(vector<P>& points)\n{\n\tint n = points.size(), s = 0, t = 1, m = 2;\n\tvector<int> S(n);\n\tS[0] = 0, S[1] = 1;\n\tsort(points.begin(), points.end());\n\tlong double d = (points[s] - points[t]).length();\n\tfor (int i = 2; i < n; S[m++] = i++)for (int j = 0; j < m; j++)\n\t{\n\t\tif ((points[S[j]] - points[i]).length() < d)\n\t\t{\n\t\t\td = (points[s = S[j]] - points[t = i]).length();\n\t\t}\n\t\tif (points[S[j]].x < points[i].x - d)\n\t\t{\n\t\t\tS[j--] = S[--m];\n\t\t}\n\t}\n\treturn make_pair(points[s], points[t]);\n}\n\nvector<P> points;\n\nint main()\n{\n\tpoints.reserve(100000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlong double x, y;\n\t\tcin >> x >> y;\n\t\tpoints.push_back(P(x, y));\n\t}\n\n\tpair<P, P> closestPair = ClosestPair(points);\n\tprintf(\"%.10lf\\n\", (double)((closestPair.first - closestPair.second).length()));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define MAX 100010\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\n\nPoint A[MAX];\n\nbool compare_y(Point a,Point b){\n  return (a.y-b.y)<eps;\n}\n\ndouble closest_pair(Point *a,int n){\n  if(n<=1)return inf;\n  int m=n/2;\n  double x=a[m].x;\n  double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n\n  vector<Point> b;\n  for(int i=0;i<n;i++){\n    if(fabs(a[i].x-x)>=d)continue;\n\n    for(int j=0;j<b.size();j++){\n      double dx=a[i].x-b[b.size()-j-1].x;\n      double dy=a[i].y-b[b.size()-j-1].y;\n      if(dy>=d)continue;\n      d=min(d,abs(a[i]-b[j]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main()\n{\n  int x,y,n;\n  vector<Point> vp;\n\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y;\n\n  sort(A,A+n);\n\n  printf(\"%.10f\\n\",closest_pair(A,n));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nstruct P\n{\n\tdouble x, y;\n\tP(double x,double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tlong double length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nint ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}\n\nlong double ClosestPair(vector<P>& points,int l,int r)\n{\n\tif (r - l == 1)\n\t{\n\t\treturn INF;\n\t}\n\tif (r - l == 2)\n\t{\n\t\treturn (points[l] - points[l + 1]).length2();\n\t}\n\n\tint m = (l + r) / 2;\n\tlong double d = min(ClosestPair(points, l, m), ClosestPair(points, m, r));\n\n\tvector<P> tempP;\n\tfor (int i = l; i < r; i++)\n\t{\n\t\tif ((points[l].x - points[m].x)*(points[l].x - points[m].x) < d)\n\t\t{\n\t\t\ttempP.emplace_back(P(points[i].y, points[i].x));\n\t\t}\n\t}\n\tsort(tempP.begin(), tempP.end());\n\tfor (int i = 0; i != tempP.size(); i++)\n\t{\n\t\tfor (int j = i + 1; j != tempP.size(); j++)\n\t\t{\n\t\t\tif ((tempP[j].x - tempP[i].x)*(tempP[j].x - tempP[i].x) > d)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td = min(d, (tempP[i] - tempP[j]).length2());\n\t\t}\n\t}\n\n\treturn d;\n}\n\nvector<P> points;\n\nint main()\n{\n\tpoints.reserve(100000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpoints.push_back(P(x, y));\n\t}\n\n\tsort(points.begin(), points.end());\n\n\tprintf(\"%.10lf\\n\", (double)sqrt(ClosestPair(points, 0, n)));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nconst double inf=1e20;\n\ninline int sign(const double &x){\n    if(x>EPS) return 1;\n    else if(x<-EPS) return -1;\n    return 0;\n}\n\n/*   点  */\nstruct Point{\n    double x,y;\n\n    Point(double x=0,double y=0):x(x),y(y){}\n\n    Point operator + (Point p) { return Point(x+p.x,y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x,y-p.y); }\n    Point operator * (double k) { return Point(k*x,k*y); }\n    Point operator / (double k) { return Point(x/k,y/k); }\n\n    //向量的大小\n    double abs(){ return sqrt(norm()); }\n    double norm() { return x*x+y*y; }\n\n    bool operator < (const Point & p) const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n    bool operator == (const Point & p) const {\n        return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n    }\n};\n\n//两点间的距离\ndouble getDistance(Point a,Point b){\n    return (a-b).abs();\n}\n\n/*   向量  */\ntypedef Point Vector;\n\n//向量a和b的内积\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n//向量a和b的外积\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\n/*   线段  */\nstruct Segment{\n    Point p1,p2;\n};\n\n//点p在线段s上的投影\nPoint project(Segment s,Point p){\n    Vector base = s.p2-s.p1;\n    double r=dot(p-s.p1,base)/base.norm();\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n/*   直线  */\ntypedef Segment Line;\n\n//点到直线的距离\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/(l.p2-l.p1).abs());\n}\n\n//点到线段的距离\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return (p-s.p1).abs();\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return (p-s.p2).abs();\n    return getDistanceLP(s,p);\n}\n\n//判断p2与向量p1-p0的位置关系\n\nconst int COUNTER_CLOCKWISE = -1;   //逆时针\nconst int CLOCKWISE = 1;            //顺时针\nconst int ON_SEGMENT = 0;           //在线段上\nconst int ONLINE_BACK = 2;          //p2在向量p1-p0的反方向延长线上\nconst int ONLINE_FRONT = -2;        //p2在向量p1-p0的正方向延长线上\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CLOCKWISE;\n    if(dot(a,b)<-EPS) return ONLINE_BACK;\n    if(a.norm()<b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//判断线段p1p2与线段p3p4是否相交\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n             ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n//线段与线段的距离\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\n//两个线段的交点(对于直线跟线段也适用，但注意base是在直线上)\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n/* 直线正交\n * 判断向量a，b是否正交 =》a，b的内积为0\n */\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\n/* 直线平行\n * 判断向量a，b是否平行 =》a，b的内积为0\n */\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point() ,double r = 0.0 ):c(c),r(r){}\n};\n\n/* 圆与直线的交点\n * 交点为一个的时候返回两个相同的点\n * 没有交点则退出\n */\n\nbool intersect(Circle c,Line l){\n    return sign(getDistanceLP(l,c.c)-c.r)<=0;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n    assert(intersect(c,l));         //没有交点\n    Point pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n    double base=sqrt(c.r*c.r-(pr-c.c).norm());\n    return make_pair(pr+e*base,pr-e*base);\n}\n\n\n//圆与圆的交点\n\nbool intersect(Circle c1,Circle c2){\n    return sign(getDistance(c1.c,c2.c)-(c1.r+c2.r))<=0;\n}\n\ndouble arg(Vector p){\n    return atan2(p.y,p.x);// double atan2(double y,double x) 返回的是原点至点(x,y)的方位角，即与 x 轴的夹角。返回值的单位为弧度，取值范围为(-PI,PI]\n}\n\nVector polar(double r,double a){\n    return Point(cos(a)*r,sin(a)*r);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    assert(intersect(c1,c2));\n    double d=(c1.c-c2.c).abs();\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\n/*   多边形  */\ntypedef vector<Point> Polygon;\n\n//点的****内包*****(判断点与多边形的关系)\n//多边形内返回2\n//多边形上返回1\n//多边形外返回0\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return 1;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) x=!x;\n    }\n    return (x?2:0);\n}\n\n/* *******凸包*****(包含点集合p中所有点的最小凸多边形)\n * 输出凸多边形最下端最左侧的顶点为起点,按逆时针方向依次输出坐标。\n * 安德鲁算法 O(n*logn)\n */\n\ndouble Area(Point p0,Point p1,Point p2){\n    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\n}\n\nPolygon andrewscanf(Polygon s){\n    int n=s.size();\n    sort(s.begin(),s.end());    //x从小到大，x相同的y从小到大\n    Polygon u;\n    //构建凸包上部\n    for(int i=0;i<n;i++){\n        for(int j=u.size();j>=2&&Area(u[j-2],u[j-1],s[i]) <= EPS;j--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    //构建凸包下部\n    int tmp=u.size()+1;\n    for(int i=n-2;i>=0;i--){\n        for(int j=u.size();j>=tmp&&Area(u[j-2],u[j-1],s[i]) <= EPS;j--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    //按顺序生成凸包点的序列\n    if(n>1) u.pop_back();               //开始点多加入了一次\n    return u;\n}\n\n//旋转卡壳*-------》计算凸包直径\ndouble RC(Polygon v){\n    double res=0;\n    int n=v.size();\n    int k=1;\n    for(int i=0;i<n;i++){\n        while(sign(Area(v[i],v[(i+1)%n],v[(k+1)%n])-Area(v[i],v[(i+1)%n],v[k%n]))==1) k=(k+1)%n;\n//        printf(\"*** %d\\n\",k);\n        res=max(res,max((v[i]-v[k]).abs(),(v[(i+1)%n]-v[k]).abs()));\n    }\n    return res;\n}\n\n//  平面上最近点对。（分治  nlognlogn）\n\ninline bool Closest_Pair_CmpY(Point a,Point b){\n    return a.y<b.y;\n}\n\ndouble Closest_Pair_Divide_Conquer(int l,int r,Polygon g,int n){\n    if(l==r) return inf;\n    if(l+1==r) return getDistance(g[l],g[r]);\n    int mid=l+r>>1;\n    double ans=min(Closest_Pair_Divide_Conquer(l,mid,g,n),Closest_Pair_Divide_Conquer(mid+1,r,g,n));\n    Polygon temp(n);            //保存中点左右满足条件的点\n    int len=0;\n    for(int i=l;i<=r;i++){\n        if(fabs(g[mid].x-g[i].x)<=ans) temp[len++]=g[i];\n    }\n    sort(temp.begin(),temp.begin()+len,Closest_Pair_CmpY);\n    for(int i=0;i<len;i++){\n        for(int j=i+1;j<len&&(temp[j].y-temp[i].y<ans);j++){\n            ans=min(ans,getDistance(temp[i],temp[j]));\n        }\n    }\n    return ans;\n}\n\ninline void Closest_Pair_Solve(Polygon g,int n){\n    sort(g.begin(),g.end());\n    printf(\"%.10f\\n\",Closest_Pair_Divide_Conquer(0,n-1,g,n));\n}\n\nint main(){\n    int n;\n    Point a;\n    scanf(\"%d\",&n);\n    Polygon g(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lf%lf\",&g[i].x,&g[i].y);\n    }\n    Closest_Pair_Solve(g,n);\n    return 0;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\n\nint main(){\n\tint n;\n\tdouble *x,*y;\n\tdouble min = 80000;\n\tdouble dx,dy,l;\n\tint i,j;\n\t\n\tcin>>n;\n\tx = new double[n];\n\ty = new double[n];\n\tfor(int i=0;i<n;++i){\n\t\tcin>>x[i]>>y[i];\n\t}\n\t\n\tfor(i=0;i<n;++i){\n\t\tfor(j=i+1;j<n;++j){\n\t\t\tdx = x[i]-x[j],dy = y[i]-y[j];\n\t\t\t\n\t\t\t\n\t\t\tl = dx*dx+dy*dy;\n\t\t\tif(l<min)min=l;\n\t\t\t\n\t\t}\n\t}\n\tcout<<fixed<<setprecision(6)<<sqrt(min)<<endl;\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/50))  \n #define Fun2(j,n) for(int j=i+(int)(n/50);j<n;j=j+(int)(n/50))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n const int point_border=5000;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n //?°??????¢??????16??????????????????????????????????°????????????§??? \n double interval[10][2]={{0,2},{0,5},{0,8},{1,10},{1,13},{2,18},{4,17},{4,20},{5,25},{8,32}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int j=0;j<4;j++)\n     {\n       for(int k=0;k<4;k++)\n       {                           \n         if(point[i].x>=minx+1.0*k/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(k+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*j/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(j+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*j+k;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n }\n \n //??????????????????????????¬??????2500???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=point_border)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n void wuhao()\n {\n   if(n>=point_border)\n   {\n       real_min=fun_min;\n       ok=true;\n       int xx=0;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§? \n         for(int i=0;i<16;i++)\n         {\n           for(int j=0;j<num_point[i];j++)\n           {\n             for(int k=j+1;k<num_point[i];k++)\n             {\n               num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n               if(num<real_min) real_min=num;         \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A?????? \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         } \n         //?¬¬???????§???????B??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[(n+1)*4+m];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;\n               }        \n             }        \n           }        \n         }        \n       } \n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B?????? \n         for(int m=0;m<3;m++)\n         {\n           for(int n=1;n<4;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[m*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }\n         //?¬¬???????§???????B??????                                   \n         for(int m=0;m<4;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             for(int i=0;i<num_point[n*4+m];i++)\n             {\n               for(int j=0;j<num_point[n*4+m+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n           }        \n         }                     \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§???????A??????\n         for(int m=0;m<3;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //A????????????b?????? \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+1)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }     \n         //?¬¬???????§???????B??????                    \n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<3;n++)\n           {\n             //B????????????a?????? \n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+1];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }        \n             //B????????????b?????? \n             for(int i=0;i<num_point[m*4+n+1];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                                                               \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<2;m++)\n         {\n           for(int n=0;n<2;n++)\n           {\n             //A??????\n             for(int i=0;i<num_point[m*4+n];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n+2];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n             //B??????        \n             for(int i=0;i<num_point[m*4+n+2];i++)\n             {\n               for(int j=0;j<num_point[(m+2)*4+n];j++)\n               {\n                 num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n                 if(num<real_min) real_min=num;        \n               }        \n             }\n           }        \n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         for(int m=0;m<4;m++)\n         {\n           //a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           } \n           //b?????? \n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }          \n         }                                       \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<3;m++)\n         {\n           //A????????????a?????? \n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+1)*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }  \n           //A????????????b?????? \n           for(int i=0;i<num_point[(m+1)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;        \n             }        \n           }           \n         }      \n         //B??????\n         for(int n=0;n<3;n++)\n         {\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+n];i++)\n           {\n             for(int j=0;j<num_point[3*4+n+1];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????\n           for(int i=0;i<num_point[0*4+n+1];i++)\n           {\n             for(int j=0;j<num_point[3*4+n];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }        \n         }                                           \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§?????????????\n         //A?????? \n         for(int m=0;m<2;m++)\n         {\n           //A????????????a??????\n           for(int i=0;i<num_point[m*4+0];i++)\n           {\n             for(int j=0;j<num_point[(m+2)*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //A????????????b??????\n           for(int i=0;i<num_point[(m+2)*4+0];i++)\n           {\n             for(int j=0;j<num_point[m*4+0+3];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????a??????\n           for(int i=0;i<num_point[0*4+m];i++)\n           {\n             for(int j=0;j<num_point[3*4+m+2];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n           //B????????????b??????   \n           for(int i=0;i<num_point[0*4+m+2];i++)\n           {\n             for(int j=0;j<num_point[3*4+m];j++)\n             {\n               num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n               if(num<real_min) real_min=num;          \n             }        \n           }\n         }                                                        \n       }\n       xx++;\n       if(interval[xx][0]<=real_min&&real_min<=interval[xx][1])\n       {\n         //?¬¬???????§??????????\n         //A?????? \n         for(int i=0;i<num_point[0];i++)\n         {\n           for(int j=0;j<num_point[15];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         } \n         //B??????\n         for(int i=0;i<num_point[3];i++)\n         {\n           for(int j=0;j<num_point[12];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;         \n           }        \n         }                                                        \n       }  \n   }\n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<utility>\n \ntypedef pair<double, double> point;\ntypedef point* data;\n \ndouble dist(const point &p1, const point &p2)\n{\n    double dx = p1.first - p2.first;\n    double dy = p1.second - p2.second;\n    return sqrt(dx * dx + dy * dy);\n}\n \nbool sort_y(const point &p1, const point &p2){ return p1.second < p2.second; }\n \ndouble closest(data X, data Y, int n)\n{\n    if(n <= 3){\n        double d = dist(X[0], X[1]);\n        for(int i = 0; i < n; i++){ Y[i] = X[i]; }\n        sort(Y, Y + n, sort_y);\n \n        if(n < 3){ return d; }\n        else{ return min(d, min(dist(X[0], X[2]), dist(X[1], X[2]))); }\n    }\n    int m = (n >> 1);\n    double median = X[m].first;\n    double d = min(closest(X, Y, m), closest(X + m, Y + m, n - m));\n \n    data Z; int size = 0;\n    Z = new point [n];\n    int i = 0, j = m;\n    while(i < m || j < n){\n        if(i < m && j < n){\n            if(Y[i].second < Y[j].second){\n                Z[size] = Y[i]; size++; i++;\n            }else{\n                Z[size] = Y[j]; size++; j++;\n            }\n        }\n        if(i == m){ while(j < n){ Z[size] = Y[j]; size++; j++; }; }\n        if(j == n){ while(i < m){ Z[size] = Y[i]; size++; i++; }; }\n    };\n\n\tfor(i = 0; i < n; i++){ Y[i] = Z[i]; } // merge.\n\n    int resize = 0;\n    for(i = 0; i < size; i++){\n        if(fabs(Z[i].first - median) <= d){ Z[resize] = Z[i]; resize++; }\n    }\n \n    int a = 0;\n    for(i = 1; i < resize; i++){\n        for(j = a; j < i; j++){\n            if(Z[i].second - Z[j].second > d){ a++; }\n            else{\n                d = min(d, dist(Z[i], Z[j]));\n            }\n        }\n    }\n    delete [] Z;\n    return d;\n}\n \nint main()\n{\n    data X, Y;\n    int i, n;\n    scanf(\"%d\", &n);\n    X = new point [n];\n    Y = new point [n];\n \n    double co_x, co_y;\n    for(i = 0; i < n; i++){\n        scanf(\"%lf %lf\", &co_x, &co_y);\n        X[i] = make_pair(co_x, co_y);\n    }\n    sort(X, X + n);\n \n    double d = closest(X, Y, n);\n    printf(\"%.12f\\n\", d);\n \n    cin >> n;\n    delete [] X;\n    delete [] Y;\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//finds the pair with minimum distance between them\n// verified against CGL_5_A AOJ\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point {\n  double x, y;\n};\n\nPoint result1, result2;\ndouble bestDistance;\n\ndouble euclideanDistance(Point a, Point b)  {\n  double X = a.x - b.x, Y = a.y - b.y;\n  return sqrt(X * X + Y * Y);\n}\n\n// comparison first done by y coordinate, then by x coordinate\nbool lesser(Point a, Point b) {\n  if(a.y < b.y) {\n    return true;\n  }\n  if(a.y > b.y) {\n    return false;\n  }\n  return a.x < b.x;\n}\n\nvoid merge(Point* a, Point* aux, int lo, int mid, int hi)   {\n  int i, j, k;\n  for (k = lo; k <= hi; k++) {\n    aux[k] = a[k];\n  }\n\n  i = lo; j = mid + 1; k = lo;\n  while(i <= mid && j <= hi) {\n    a[k++] = lesser(aux[i], aux[j]) ? aux[i++] : aux[j++];      \n  }\n\n  // Copy the rest of the left side of the array into the target array\n  while (i <= mid) {\n    a[k++] = aux[i++];\n  }\n}\n\ndouble closestPair(Point* pointsByX, Point* pointsByY, Point* aux, int lo, int hi) {\n  if(hi <= lo) {\n    return numeric_limits<double>::infinity();\n  }\n\n  int mid = lo + (hi - lo) / 2;\n  double delta = closestPair(pointsByX, pointsByY, aux, lo, mid);\n  double dist = closestPair(pointsByX, pointsByY, aux, mid + 1, hi);\n  if (dist < delta) {\n    delta = dist;\n  }\n\n  merge(pointsByY, aux, lo, mid, hi);\n\n  int m = 0, i, j;\n  for (i = lo; i <= hi; i++) {\n    if (abs(pointsByY[i].x - pointsByX[mid].x) < delta) {\n      aux[m++] = pointsByY[i];\n    }\n  }\n  double distance;\n  for(i = 0; i < m; i++) {\n    for(j = i + 1; j < m && (aux[j].y - aux[i].y < delta); j++) {\n      distance = euclideanDistance(aux[i], aux[j]);\n      if (distance < delta) {\n        delta = distance;\n        if (delta < bestDistance) {\n          bestDistance = delta;\n          result1 = aux[i];\n          result2 = aux[j];\n        }\n      }\n    }\n  }\n  return delta;\n}\n\nbool comp(Point a, Point b)  {\n    return a.x < b.x;\n}\n\nint main()  {\n\n  int n, i;\n  Point *points, *pointsByY, *aux;\n\n  scanf(\"%d\", &n);    //Enter the number of points in the plane\n  points = new Point[n];\n  for (i = 0; i < n; i++) { // Enter n points (x, y)\n    scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n  }\n\n  if (n <= 1) return 0;\n\n  sort(points, points + n, comp);\n  pointsByY = new Point[n];\n  for (i = 0; i < n; i++) {\n    pointsByY[i] = points[i];\n  }\n  aux = new Point[n];\n\n  bestDistance = numeric_limits<double>::infinity();\n  closestPair(points, pointsByY, aux, 0, n - 1);\n  //printf(\"%lf %lf\\n\", result1.x, result1.y);\n  //printf(\"%lf %lf\\n\", result2.x, result2.y);\n  printf(\"%.12lf\\n\", bestDistance);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n using namespace std;\n \n  /*\n   \n */\n \n struct point\n {\n   double x;\n   double y;       \n }point[100002];\n \n int n;\n double result=40000.0*2;\n double num;\n \n //4.73?§? \n void general_way()\n {\n   for(int i=0;i<n;i++) \n     for(int j=i+1;j<n;j++)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n     }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n void wuhao()\n {\n      \n }\n \n int main() \n {\n   cin>>n;\n   for(int i=0;i<n;i++)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   } \n   general_way();\n   printf(\"%lf.7\\n\",1.0*sqrt(result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double Abs(Point a, Point b) { Point C; C.px = a.px - b.px; C.py = a.py - b.py; return sqrt(norm(C)); }\nint N; Point P[1000000];\nint main() {\n\tcin >> N; long double res = 10101010101010101010101010101010101010101.0101;\n\tfor (int i = 0; i < N; i++) { cin >> P[i].px >> P[i].py; }\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tres = min(res, Abs(P[i], P[j]));\n\t\t}\n\t}\n\tcout << fixed << setprecision(5141919) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\n#include <cmath>\nusing namespace std;\ntypedef pair < double , double > Pi;\n#define y first\n#define x second\n#define INF ( 1 << 30 )\n#define SQR(x) ((x)*(x))\nPi p[500000];\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for(int i = 0 ; i < n ; i++ ){\n        scanf(\"%lf %lf\", &p[i].x, &p[i].y);\n    }\n    sort( p, p + n);\n    double ret = INF;\n    for(int i = 0 ; i < n ; i++ ){\n        for(int j = i + 1 ; j < n ; j++ ){\n            if( SQR(p[i].y - p[j].y) >= ret) break;\n            ret = min( ret, SQR(p[i].x - p[j].x) + SQR(p[i].y - p[j].y));\n        }\n    }\n    printf(\"%f\\n\", sqrt(ret));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n\tint N;\n\tcin >> N;\n\tint i, j;\n\tdouble pt[100000][2], dst[100000], m, x, y, tmp;\n\tfor (i = 0; i < N; i++) {\n\t\tcin >> pt[i][0] >> pt[i][1];\n\t\tm = 10000;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tx = pt[i][0] - pt[j][0];\n\t\t\ty = pt[i][1] - pt[j][1];\n\t\t\ttmp = x * x + y * y;\n\t\t\tif (tmp < 0) {\n\t\t\t\ttmp = -tmp;\n\t\t\t}\n\t\t\tif (tmp < m) {\n\t\t\t\tm = tmp;\n\t\t\t}\n\t\t}\n\t\tdst[i] = m;\n\t}\n\tm = 10000;\n\tfor (i = 0; i < N; i++) {\n\t\tif (dst[i] < m) {\n\t\t\tm = dst[i];\n\t\t}\n\t}\n\tprintf(\"%f\\n\", sqrt(m));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<cstdlib>\n #include<cstdio>\n #include<string>\n #include<math.h>\n #include<time.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<fstream> \n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n #include<list>\n \n #define Rep(i,n) for(int i=0;i<n;i++)  \n #define For(j,n) for(int j=i+1;j<n;j++)\n #define Fun(i,n) for(int i=0;i<n;i=i+(int)(n/50))  \n #define Fun2(j,n) for(int j=i+(int)(n/50);j<n;j=j+(int)(n/50))\n using namespace std;\n \n  /*\n    You're here there's nothing I fear,\n    and I know that my heart will go on.  \n    We'll stay forever this way.\n    You are safe in my heart.\n    And my heart will go on and on.\n */\n \n const int maxn=100002;\n \n struct plane\n {\n   double x;\n   double y;       \n }point[maxn];\n \n int n;\n //block??¨?????????????????¨???????????? \n int block;\n double result=40000.0*2;\n double num;\n double minx=100,miny=100,maxx=-100,maxy=-100;\n double interval[9][2]={{0,2},{0,5},{0,8}};\n \n //?°??????¢??????16??? \n plane wu[16][maxn];\n int num_point[16]={0};\n double fun_min=40000.0*2;\n double real_min=40000.0*2;\n bool is_inside;\n bool flag1,flag2,flag3,flag4;\n bool ok=false;\n \n void find_the_border()\n {\n   Rep(i,n)\n   {\n     if(point[i].x<minx) minx=point[i].x;\n     if(point[i].x>maxx) maxx=point[i].x;\n     if(point[i].y<miny) miny=point[i].y;\n     if(point[i].y>maxy) maxy=point[i].y;\n   }     \n }\n \n void divide_the_plane()\n {\n   Rep(i,n)\n   {\n     is_inside=false;\n     flag1=flag2=flag3=flag4=false;\n     for(int i=0;i<4;i++)\n     {\n       for(int j=0;j<4;j++)\n       {\n         if(point[i].x>=minx+1.0*i/4*(maxx-minx)) flag1=true;  \n         if(point[i].x<=minx+1.0*(i+1)/4*(maxx-minx)) flag2=true;  \n         if(point[i].y>=miny+1.0*i/4*(maxy-miny)) flag3=true; \n         if(point[i].y<=miny+1.0*(i+1)/4*(maxy-miny)) flag4=true;   \n         is_inside=flag1&&flag2&&flag3&&flag4;\n         if(is_inside)\n         {\n           block=4*i+j;\n           wu[block][num_point[block]].x=point[i].x;\n           wu[block][num_point[block]].y=point[i].y;\n           num_point[block]++;\n           break;            \n         }\n       }\n       if(is_inside) break;\n     }        \n   }     \n }\n \n //??????????????????????????¬??????2500???????????£??¨??§???????????\\????????? \n void try_for_fun()\n {\n   if(n>=500)\n   {\n     Fun(i,n) Fun2(j,n)\n     {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<fun_min) fun_min=num;           \n     }\n   }\n }\n \n void wuhao_cut()\n {\n   if(fun_min<=(1.0*50*50))\n   {\n     ok=true;\n     //?¬¬????±??????? \n     for(int i=0;i<16;i++)\n     {\n       for(int j=0;j<num_point[i];j++)\n       {\n         for(int k=j+1;k<num_point[i];k++)\n         {\n           num=(point[j].x-point[k].x)*(point[j].x-point[k].x)+(point[j].y-point[k].y)*(point[j].y-point[k].y);\n           if(num<real_min) real_min=num;         \n         }        \n       }        \n     }\n     //?¬¬????±?????????????A?????? \n     for(int m=0;m<4;m++)\n     {\n       for(int n=0;n<3;n++)\n       {\n         for(int i=0;i<num_point[m*4+n];i++)\n         {\n           for(int j=0;j<num_point[m*4+n+1];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;        \n           }        \n         }        \n       }        \n     } \n     //?¬¬????±?????????????B??????\n     for(int m=0;m<4;m++)\n     {\n       for(int n=0;n<3;n++)\n       {\n         for(int i=0;i<num_point[n*4+m];i++)\n         {\n           for(int j=0;j<num_point[(n+1)*4+m];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;        \n           }        \n         }        \n       }        \n     } \n     //?¬¬????±???????A??????\n     for(int m=0;m<3;m++)\n     {\n       for(int n=0;n<3;n++)\n       {\n         for(int i=0;i<num_point[m*4+n];i++)\n         {\n           for(int j=0;j<num_point[(m+1)*4+n+1];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;        \n           }        \n         }        \n       }        \n     }  \n     //?¬¬????±???????B?????? \n     for(int m=0;m<3;m++)\n     {\n       for(int n=1;n<4;n++)\n       {\n         for(int i=0;i<num_point[m*4+n];i++)\n         {\n           for(int j=0;j<num_point[(m+1)*4+(n-1)];j++)\n           {\n             num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n             if(num<real_min) real_min=num;        \n           }        \n         }        \n       }        \n     } \n   }   \n } \n \n \n //1.36?§? \n void general_way()\n {\n   Rep(i,n) For(j,n)\n   {\n       num=(point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y);\n       if(num<result) result=num;        \n   }     \n }\n \n void recursive_divide_and_conquer()\n {\n      \n }\n \n int main() \n {\n   scanf(\"%d\",&n);\n   Rep(i,n)\n   { \n     scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n     //cin>>point[i].x>>point[i].y;\n   }\n   find_the_border();\n   divide_the_plane();\n   try_for_fun();\n   if(ok) wuhao_cut(); \n   else general_way();\n   double final_result=min(result,real_min);\n   printf(\"%.10lf\\n\",1.0*sqrt(final_result));\n   //while(1);\n   return 0;\n }\n \n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\n#define dump(x) cerr << __LINE__ << \":\\t\" #x \" = \" << x << endl\n\nusing ld = double;\nusing P = complex<ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\n\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ntemplate<class iter>\ntuple<ld, P, P> closest_pair(iter left, iter right) {\n    int n = distance(left, right);\n\n    if(n <= 1){\n        return make_tuple(numeric_limits<ld>::max(), *left, *left);\n    }\n\n    if(n == 2){\n        if(left[0].imag() > left[1].imag()) swap(left[0], left[1]);\n        return make_tuple(norm(left[0]-left[1]), left[0], left[1]);\n    }\n\n    iter middle = next(left, n/2);\n    ld x = middle->real();\n    auto d = min(closest_pair(left, middle), closest_pair(middle, right));\n    inplace_merge(left, middle, right, [](const P &a, const P &b){\n            return a.imag() < b.imag();\n        });\n\n    vector<iter> around;\n    for(iter i = left; i != right; ++i){\n        ld dx = fabs(i->real() - x);\n        ld &opt = get<0>(d);\n        if(dx*dx >= opt) continue;\n        for(auto j = around.rbegin(); j != around.rend(); ++j){\n            ld dx = i->real() - (**j).real();\n            ld dy = i->imag() - (**j).imag();\n            if(dy*dy >= opt) break;\n            ld norm = dx*dx + dy*dy;\n            if(get<0>(d) > norm){\n                d = make_tuple(norm, *i, **j);\n            }\n        }\n        around.push_back(i);\n    }\n    return d;\n};\n\n// http://www.spoj.com/problems/CLOPPAIR/\n// 18124516\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout << fixed << setprecision(10) << endl;\n    int n;\n    cin >> n;\n    vector<P> a;\n    rep(i,n){\n        ld x,y;\n        cin >> x >> y;\n        a.emplace_back(x,y);\n    }\n    ld z;\n    P x, y;\n    sort(all(a));\n    tie(z, x, y) = closest_pair(all(a));\n    cout << sqrt(z) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n\nusing namespace std;\n\nusing point = pair<float, float>;\n\ninline float distance(point &a, point &b) { return sqrt(pow(a.first - b.first, 2) + pow(a.second - b.second, 2)); }\n\nfloat closestSplit(point x[], int n, float sigma)\n{\n    float xbar = x[n/2].first, d = sigma;\n    point sy[n];\n    int j = 0;\n    for (int i = 0; i < n; ++i)\n        if (abs(xbar - x[i].first) <= sigma)\n            sy[j++] = x[i];\n    sort(sy, sy+j, [] (point &a, point &b)\n    {\n        return a.second < b.second;\n    });\n    for (int i = 0; i < j; ++i)\n        for (int k = 1; k < 8 && i+k < j; ++k)\n            d = min(d, distance(sy[i], sy[i+k]));\n    return d;\n}\n\nfloat closestPairDistance(point x[], int n)\n{\n    if (n < 4)\n    {\n        float d = numeric_limits<float>::max();\n        for (int i = 0; i < n; ++i)\n            for (int j = i+1; j < n; ++j)\n                d = min(d, distance(x[i], x[j]));\n        return d;\n    }\n    float sigma = min(closestPairDistance(x, n/2), closestPairDistance(x + n/2, n - n/2));\n    return closestSplit(x, n, sigma);\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    point x[n];\n    for (int i = 0; i < n; ++i)\n        scanf(\"%f %f\", &x[i].first, &x[i].second);\n    sort(x, x+n, [] (point &a, point &b)\n    {\n        return a.first < b.first;\n    });\n    cout << setprecision(8) << showpoint << fixed << closestPairDistance(x, n) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\t//sort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tfor (size_t j = 1; i+j < N; j++)\n\t\t{\n\t\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\t}\n\t\t/*memo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i+j<N&&memo >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\t\tj++;\n\t\t}*/\n\t}\n\tcout << fixed << setprecision(8)<<sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nconst double inf=1e20;\n\ninline int sign(const double &x){\n    if(x>EPS) return 1;\n    else if(x<-EPS) return -1;\n    return 0;\n}\n\n/*   点  */\nstruct Point{\n    double x,y;\n\n    Point(double x=0,double y=0):x(x),y(y){}\n\n    Point operator + (Point p) { return Point(x+p.x,y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x,y-p.y); }\n    Point operator * (double k) { return Point(k*x,k*y); }\n    Point operator / (double k) { return Point(x/k,y/k); }\n\n    //向量的大小\n    double abs(){ return sqrt(norm()); }\n    double norm() { return x*x+y*y; }\n\n    bool operator < (const Point & p) const{\n        return x!=p.x?x<p.x:y<p.y;\n    }\n\n    bool operator == (const Point & p) const {\n        return fabs(x-p.x)<EPS&&fabs(y-p.y)<EPS;\n    }\n};\n\n//两点间的距离\ndouble getDistance(Point a,Point b){\n    return (a-b).abs();\n}\n\n/*   向量  */\ntypedef Point Vector;\n\n//向量a和b的内积\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n//向量a和b的外积\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\n/*   线段  */\nstruct Segment{\n    Point p1,p2;\n};\n\n//点p在线段s上的投影\nPoint project(Segment s,Point p){\n    Vector base = s.p2-s.p1;\n    double r=dot(p-s.p1,base)/base.norm();\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n/*   直线  */\ntypedef Segment Line;\n\n//点到直线的距离\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/(l.p2-l.p1).abs());\n}\n\n//点到线段的距离\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return (p-s.p1).abs();\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return (p-s.p2).abs();\n    return getDistanceLP(s,p);\n}\n\n//判断p2与向量p1-p0的位置关系\n\nconst int COUNTER_CLOCKWISE = -1;   //逆时针\nconst int CLOCKWISE = 1;            //顺时针\nconst int ON_SEGMENT = 0;           //在线段上\nconst int ONLINE_BACK = 2;          //p2在向量p1-p0的反方向延长线上\nconst int ONLINE_FRONT = -2;        //p2在向量p1-p0的正方向延长线上\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CLOCKWISE;\n    if(dot(a,b)<-EPS) return ONLINE_BACK;\n    if(a.norm()<b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//判断线段p1p2与线段p3p4是否相交\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n             ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n//线段与线段的距离\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n               min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\n//两个线段的交点(对于直线跟线段也适用，但注意base是在直线上)\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n/* 直线正交\n * 判断向量a，b是否正交 =》a，b的内积为0\n */\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\n/* 直线平行\n * 判断向量a，b是否平行 =》a，b的内积为0\n */\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point() ,double r = 0.0 ):c(c),r(r){}\n};\n\n/* 圆与直线的交点\n * 交点为一个的时候返回两个相同的点\n * 没有交点则退出\n */\n\nbool intersect(Circle c,Line l){\n    return sign(getDistanceLP(l,c.c)-c.r)<=0;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n    assert(intersect(c,l));         //没有交点\n    Point pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/(l.p2-l.p1).abs();\n    double base=sqrt(c.r*c.r-(pr-c.c).norm());\n    return make_pair(pr+e*base,pr-e*base);\n}\n\n\n//圆与圆的交点\n\nbool intersect(Circle c1,Circle c2){\n    return sign(getDistance(c1.c,c2.c)-(c1.r+c2.r))<=0;\n}\n\ndouble arg(Vector p){\n    return atan2(p.y,p.x);// double atan2(double y,double x) 返回的是原点至点(x,y)的方位角，即与 x 轴的夹角。返回值的单位为弧度，取值范围为(-PI,PI]\n}\n\nVector polar(double r,double a){\n    return Point(cos(a)*r,sin(a)*r);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    assert(intersect(c1,c2));\n    double d=(c1.c-c2.c).abs();\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\n/*   多边形  */\ntypedef vector<Point> Polygon;\n\n//点的****内包*****(判断点与多边形的关系)\n//多边形内返回2\n//多边形上返回1\n//多边形外返回0\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS) return 1;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) x=!x;\n    }\n    return (x?2:0);\n}\n\n/* *******凸包*****(包含点集合p中所有点的最小凸多边形)\n * 输出凸多边形最下端最左侧的顶点为起点,按逆时针方向依次输出坐标。\n * 安德鲁算法 O(n*logn)\n */\n\ndouble Area(Point p0,Point p1,Point p2){\n    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\n}\n\nPolygon andrewscanf(Polygon s){\n    int n=s.size();\n    sort(s.begin(),s.end());    //x从小到大，x相同的y从小到大\n    Polygon u;\n    //构建凸包上部\n    for(int i=0;i<n;i++){\n        for(int j=u.size();j>=2&&Area(u[j-2],u[j-1],s[i]) <= EPS;j--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    //构建凸包下部\n    int tmp=u.size()+1;\n    for(int i=n-2;i>=0;i--){\n        for(int j=u.size();j>=tmp&&Area(u[j-2],u[j-1],s[i]) <= EPS;j--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n    //按顺序生成凸包点的序列\n    if(n>1) u.pop_back();               //开始点多加入了一次\n    return u;\n}\n\n//旋转卡壳*-------》计算凸包直径\ndouble RC(Polygon v){\n    double res=0;\n    int n=v.size();\n    int k=1;\n    for(int i=0;i<n;i++){\n        while(sign(Area(v[i],v[(i+1)%n],v[(k+1)%n])-Area(v[i],v[(i+1)%n],v[k%n]))==1) k=(k+1)%n;\n//        printf(\"*** %d\\n\",k);\n        res=max(res,max((v[i]-v[k]).abs(),(v[(i+1)%n]-v[k]).abs()));\n    }\n    return res;\n}\n\n//  平面上最近点对。（分治  nlognlogn）\n\ninline bool Closest_Pair_CmpY(Point a,Point b){\n    return a.y<b.y;\n}\n\ndouble Closest_Pair_Divide_Conquer(int l,int r,Polygon g){\n    if(l==r) return inf;\n    if(l+1==r) return getDistance(g[l],g[r]);\n    int mid=l+r>>1;\n    double ans=min(Closest_Pair_Divide_Conquer(l,mid,g),Closest_Pair_Divide_Conquer(mid+1,r,g));\n    Polygon temp;            //保存中点左右满足条件的点\n    for(int i=l;i<=r;i++){\n        if(fabs(g[mid].x-g[i].x)<=ans) temp.push_back(g[i]);\n    }\n    sort(temp.begin(),temp.end(),Closest_Pair_CmpY);\n    int len=temp.size();\n    for(int i=0;i<len;i++){\n        for(int j=i+1;j<len&&(temp[j].y-temp[i].y<ans);j++){\n            ans=min(ans,getDistance(temp[i],temp[j]));\n        }\n    }\n    return ans;\n}\n\ninline void Closest_Pair_Solve(Polygon g){\n    sort(g.begin(),g.end());\n    printf(\"%.10f\\n\",Closest_Pair_Divide_Conquer(0,g.size()-1,g));\n}\n\nint main(){\n    int n;\n    Polygon g;\n    Point a;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lf%lf\",&a.x,&a.y);\n        g.push_back(a);\n    }\n    Closest_Pair_Solve(g);\n    return 0;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct node{\n  int dim;\n  vector<double>v;\n};\n \ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n \ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n \n  vector<node>res;\n \n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n \n    double dist=d(p,S)/(4*p.dim);\n \n    map<vector<int> ,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      vector<int> key;\n      for(int j=0;j<p.dim;j++)key.push_back((int)(S[i].v[j]/dist));\n      grid[key].push_back(i);\n    }\n \n    vector<node>nextS;\n    map<vector<int>,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    if(S.size() == nextS.size())break;\n    S=nextS;    \n  }\n \n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n   \n  return ans;\n}\n \nint main(void){\n \n  int n;\n  cin >> n;\n \n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n \n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&min(memo,ans+0.00011) >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans =(min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return fabs(b - a) < EPS; }\n\nusing Point = complex< double >;\n\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble radian_to_degree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble degree_to_radian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() {}\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(double A, double B, double C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() {}\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle() {}\n\n  Circle(Point p, double r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\ndouble cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\nbool parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\ndouble distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\ndouble distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\ndouble distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\ndouble distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\ndouble distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point hp = projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return {hp - v, hp + v};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\nenum {\n  OUT, ON, IN\n};\n\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\nbool merge_if_able(Segment &s1, Segment s2) {\n  if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid merge_segments(vector< Segment > &segs) {\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon convex_cut(Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble area2(const Polygon &p) {\n  double A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble convex_diameter(Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\ndouble closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  \n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n\n  function< double(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return 1e18;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\n\nint main() {\n  int N;\n  cin >> N;\n  Points p(N);\n  for(auto &s : p) cin >> s;\n  cout << fixed << setprecision(10) << closest_pair(p) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n\tint N;\n\tcin >> N;\n\tint i, j;\n\tdouble pt[100000][2], m, x, y, tmp, n;\n\tn = 100000000;\n\tfor (i = 0; i < N; i++) {\n\t\tcin >> pt[i][0] >> pt[i][1];\n\t\tm = 100000000;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tx = pt[i][0] - pt[j][0];\n\t\t\ty = pt[i][1] - pt[j][1];\n\t\t\ttmp = x * x + y * y;\n\t\t\tif (tmp < m) {\n\t\t\t\tm = tmp;\n\t\t\t}\n\t\t}\n\t\tif (m < n) {\n\t\t\tn = m;\n\t\t}\n\t}\n\tprintf(\"%f\\n\", sqrt(n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://ir5.hatenablog.com/entry/20131221/1387557630\n#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\ntypedef pair<double, double> P;\ntypedef pair<int, int> IP;\ndouble norm(P a, P b) {\n  double x = a.first - b.first;\n  double y = a.second - b.second;\n  return sqrt(x*x + y*y);\n}\nint main() {\n  int N; cin >> N;\n  vector<P> p(N);\n  REP(i,N) {\n    double x, y; cin >> x >> y;\n    p[i] = make_pair(x, y);\n  }\n  double xmin = p[0].first, ymin = p[0].second;\n  REP(i,N) {\n    xmin = min(xmin, p[i].first);\n    ymin = min(ymin, p[i].second);\n  }\n  REP(i,N) {\n    p[i].first -= xmin;\n    p[i].second -= ymin;\n  }\n  // std::rand is often used.\n  random_shuffle(p.begin(), p.end());\n  double delta = norm(p[0], p[1]);\n  map<IP, vector<int>> S;\n  S[IP(p[0].first / delta, p[0].second / delta)].push_back(0);\n  S[IP(p[1].first / delta, p[1].second / delta)].push_back(1);\n  for(int i = 2; i < N; ++i) {\n    IP ip(p[i].first / delta, p[i].second / delta);\n    bool update = false;\n    for(int dx = -1; dx <= 1; ++dx) for(int dy = -1; dy <= 1; ++dy) {\n      for(int j : S[IP(ip.first + dx, ip.second + dy)]) {\n        double d2 = norm(p[i], p[j]);\n        if(delta > d2) {\n          delta = d2;\n          update = true;\n        }\n      }\n    }\n    if(update) {\n      S.clear();\n      for(int j = 0; j <= i; ++j) {\n        S[IP(p[j].first / delta, p[j].second / delta)].push_back(j);\n      }\n    }\n    else {\n      S[ip].push_back(i);\n    }\n  }\n  cout.setf(ios::fixed);\n  cout.precision(6);\n  cout << delta << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\nusing P = pair<double, double>;\n\nint main() {\n\n    int n;\n    cin >> n;\n\n    P p[n];\n\n    for (int i = 0; i < n; i++) {\n        double x, y;\n        cin >> x >> y;\n        p[i] = make_pair(x, y);\n    }\n\n    sort(p, p + n);\n\n    double ans = 100000;\n\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            P p1, p2;\n            p1 = p[i];\n            p2 = p[j];\n            double dx, dy;\n            dx = (p1.first - p2.first) * (p1.first - p2.first);\n            dy = (p1.second - p2.second) * (p1.second - p2.second);\n            if (dx > ans) break;\n            ans = min(ans, dx + dy);\n        }\n    }\n\n    cout << fixed << setprecision(7) << sqrt(ans) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\tGeometry Template\n\tdouble !!!\n\tTODO: test everything!!!\n*/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double INF = 1e17;\nconst double EPS = 1e-9;\nconst double PI = 2.0 * asin(1);\n\ninline bool is_in(double a, double b, double x) {\n\tif (a > b) {\n\t\tswap(a, b);\n\t}\n\treturn (a - EPS <= x && x <= b + EPS);\n}\n\nstruct point {\n\tdouble x, y;\n\tpoint() {}\n\tpoint(double _x, double _y) : x(_x), y(_y) {}\n};\n\nbool operator < (const point &P, const point &Q) {\n\tif (abs(P.y - Q.y) > EPS) {\n\t\treturn P.y < Q.y;\n\t}\n\tif (abs(P.x - Q.x) > EPS) {\n\t\treturn P.x < Q.x;\n\t}\n\treturn false;\n}\n\nstruct compare_by_x {\n\tbool operator () (const point &P, const point &Q) {\n\t\tif (abs(P.x - Q.x) > EPS) {\n\t\t\treturn P.x < Q.x;\n\t\t}\n\t\treturn P.y < Q.y;\n\t}\n};\n\nstruct compare_by_y {\n\tbool operator () (const point &P, const point &Q) {\n\t\tif (abs(P.y - Q.y) > EPS) {\n\t\t\treturn P.y < Q.y;\n\t\t}\n\t\treturn P.x < Q.x;\n\t}\n};\ninline void read(point &P) {\n\tcin >> P.x >> P.y;\n}\n\npoint operator + (const point &P, const point &Q) {\n\treturn point(P.x + Q.x, P.y + Q.y);\n}\n\npoint operator - (const point &P, const point &Q) {\n\treturn point(P.x - Q.x, P.y - Q.y);\n}\n\npoint operator * (const point &P, const double k) {\n\treturn point(P.x * k, P.y * k);\n}\n\npoint operator / (const point &P, const double k) {\n\tassert(fabs(k) > EPS);\n\treturn point(P.x / k, P.y / k);\n}\n\ninline double dot(const point &P, const point &Q) {\n\treturn P.x * Q.x + P.y * Q.y;\n}\n\ninline double cross(const point &P, const point &Q) {\n\treturn P.x * Q.y - P.y * Q.x;\n}\n\ninline double norm2(const point &P) {\n\treturn dot(P, P);\n}\n\ninline double norm(const point &P) {\n\treturn sqrt(dot(P, P));\n}\n\ninline double dist2(const point &P, const point &Q) {\n\treturn norm2(P - Q);\n}\n\ninline double dist(const point &P, const point &Q) {\n\treturn sqrt(dot(P - Q, P - Q));\n}\n\ninline bool is_in(point A, point B, point P) {\n\tif (abs(cross(B - A, P - A)) > EPS) {\n\t\treturn false;\n\t}\n\treturn (is_in(A.x, B.x, P.x) && is_in(A.y, B.y, P.y));\n}\n\n\ninline point project(const point &P, const point &P1, const point &P2) {\n\treturn P1 + (P2 - P1) * (dot(P2 - P1, P - P1) / norm2(P2 - P1));\n}\n\ninline point reflect(const point &P, const point &P1, const point &P2) {\n\treturn project(P, P1, P2) * 2.0 - P;\n}\n\ninline double point_to_line(const point &P, const point &A, const point &B) {\n\t// return abs(cross(B - A, C - A) / norm(B - A));\n\treturn dist(P, project(P, A, B));\n}\n\n// line to line intersection\n// A, B difine the first line\n// C, D define the second line\ninline point intersect(const point &A, const point &B, const point &C, const point &D) {\n\treturn A + (B - A) * (cross(C - A, C - D) / cross(B - A, C - D));\n}\n\ninline point rotate_point(const point &P, double angle) {\n\treturn point(P.x * cos(angle) - P.y * sin(angle), P.y * cos(angle) + P.x * sin(angle));\n}\n\ninline point circle_center(const point &A, const point &B, const point &C) {\n\tassert(abs(cross(B - A, C - A)) > EPS); // no colinear\n\treturn intersect((A + B) / 2.0, (A + B) / 2.0 + rotate_point(B - A, PI),\n\t\t\t\t\t\t\t\t\t (B + C) / 2.0, (B + C) / 2.0 + rotate_point(C - B, PI));\n}\n\ninline pair <point, point> point_circle_tangent(const point &P, const point &C, const double r) {\n\tdouble d = dist(P, C);\n\tdouble l = sqrt(d * d - r * r);\n\tdouble a = asin(r / d);\n\treturn make_pair(P + rotate_point((C - P) * (l / d), a), P + rotate_point((C - P) * (l / d), -a));\n}\n\ninline vector <point> line_circle_intersect(const point &A, const point &B, const point &C, const double r) {\n\tpoint PC = project(C, A, B);\n\tdouble d = dist(C, PC);\n\tif (d > r + EPS) {\n\t\treturn vector <point> ();\n\t}\n\tif (abs(d - r) < EPS) {\n\t\treturn vector <point> (1, PC);\n\t}\n\tdouble l = sqrt(r * r - d * d);\n\tvector <point> res(2);\n\tdouble dAB = dist(A, B);\n\tres[0] = PC + (B - A) * (l / dAB);\n\tres[1] = PC - (B - A) * (l / dAB);\n\treturn res;\n}\n\ninline double signed_area(const vector <point> &polygon) {\n\tdouble res = 0.0;\n\tint n = polygon.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tint j = (i + 1 == n) ? 0 : i + 1;\n\t\tres += cross(polygon[i], polygon[j]);\n\t}\n\treturn 0.5 * res;\n}\n\ninline double abs_area(const vector <point> &polygon) {\n\treturn abs(signed_area(polygon));\n}\n\ninline double closest_pair_of_points(vector <point> pts) {\n\tsort(pts.begin(), pts.end(), compare_by_x());\n\tmultiset <point> candidates;\n\tint n = pts.size();\n\tdouble res = INF;\n\tfor (int i = 0, last = 0; i < n; i++) {\n\t\twhile (last < i && pts[i].x - pts[last].x >= res + EPS) {\n\t\t\tcandidates.erase(candidates.find(pts[last]));\n\t\t\tlast++;\n\t\t}\n\t\tset <point> :: iterator lo = candidates.lower_bound(point(-INF, pts[i].y - res - EPS));\n\t\tset <point> :: iterator hi = candidates.upper_bound(point(INF, pts[i].y + res + EPS));\n\t\twhile (lo != hi) {\n\t\t\tres = min(res, dist(pts[i], *lo));\n\t\t\tlo++;\n\t\t}\n\t\tcandidates.insert(pts[i]);\n\t}\n\treturn res;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.precision(15);\n\n\tint n;\n\tcin >> n;\n\n\tvector <point> pts(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> pts[i].x >> pts[i].y;\n\t}\n\n\tdouble answer = closest_pair_of_points(pts);\n\tcout << fixed << answer << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return norm( B - A ); }\n\nint n;\nlf d;\npt Px[ MAXN ];\nvector< pt> Py;\n\nbool cmpX( const pt &A, const pt &B ) {\n  return B.x > A.x + EPS;\n}\n\nbool cmpY( const pt &A, const pt &B ) {\n  return B.y > A.y + EPS;\n}\n\nlf minimum( const lf &A, const lf &B ) {\n  if( A+EPS < B ) return A;\n  return B;\n}\n\nvoid merge( pt *P, int n ) {\n  for( int i = 0; i < n; ++i ) {\n    for( int j = i+1; j < n && (P[j].y - P[i].y)*(P[j].y - P[i].y) + EPS < d ; ++j ) {\n      d = minimum( d, dist( P[i], P[j]) );\n    }\n  }\n}\n\nvoid solve( pt *Px, vector<pt> &Py, int n ) {\n  if( n <= 3 ) {\n    for( int i = 0; i < n; ++i ) {\n      for( int j = i+1; j < n; ++j ) {\n        d = minimum( d, dist(Px[i], Px[j]) );\n      }\n    }\n    return;\n  }\n  int mi = n/2;\n  vector<pt> Pl, Pr;\n  for( int i = 0; i < n; ++i ) {\n    if( Py[i].x+EPS < Px[mi].x ) {\n      Pl.PB( Py[ i ] );\n    }\n    else {\n      Pr.PB( Py[ i ] );\n    }\n  }\n\n  solve( Px, Pl, SIZE( Pl ) );\n  solve( Px+SIZE( Pl ), Pr, SIZE( Pr ) );\n\n  pt extra[ n ];\n  int k = 0;\n  for( auto &p : Py ) {\n    if( ( p.x - Px[mi].x )*( p.x - Px[mi].x ) + EPS < d ) {\n      extra[ k++ ] = p;\n    }\n  }\n\n  merge( extra, n );\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 10 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> Px[i];\n    Py.PB( Px[ i ] );\n  }\n  sort( Px, Px+n, cmpX );\n  sort( Py.begin(), Py.end(), cmpY );\n  d = oo;\n  solve( Px, Py, n );\n  cout << double(sqrt(d)) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n; double bx, by; pair<double, double> p[100009];\nint main() {\n\tscanf(\"%d\", &n);\n\tdouble sq = sin(1.234), cq = cos(1.234);\n\tfor(int i = 0; i < n; i++) {\n\t\tscanf(\"%lf%lf\", &bx, &by);\n\t\tdouble ex = bx * cq - by * sq;\n\t\tdouble ey = bx * sq + by * cq;\n\t\tp[i] = make_pair(ex, ey);\n\t}\n\tsort(p, p + n);\n\tdouble ret = 1.0e+10;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\tdouble dx = p[i].first - p[j].first;\n\t\t\tif(dx * dx > ret) break;\n\t\t\tdouble dy = p[i].first - p[j].first;\n\t\t\tdouble dist = dx * dx + dy * dy;\n\t\t\tif(ret > dist) ret = dist;\n\t\t}\n\t}\n\tprintf(\"%.15lf\\n\", sqrt(ret));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define MAX 100010\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\n\nPoint A[MAX];\n\nbool compare_y(Point a,Point b){\n  return a.y<b.y;\n}\n\ndouble closest_pair(Point *a,int n){\n  if(n<=1)return inf;\n  int m=n/2;\n  double x=a[m].x;\n  double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n\n  vector<Point> b;\n  for(int i=0;i<n;i++){\n    if(fabs(a[i].x-x)>=d)continue;\n\n    for(int j=0;j<b.size();j++){\n      double dx=a[i].x-b[b.size()-j-1].x;\n      double dy=a[i].y-b[b.size()-j-1].y;\n      if(dy>=d)continue;\n      d=min(d,sqrt(dx*dx+dy*dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main()\n{\n  int x,y,n;\n  vector<Point> vp;\n\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y;\n\n  sort(A,A+n);\n\n  printf(\"%.10f\\n\",closest_pair(A,n));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pt pair<double,double>\n#define x first\n#define y second\nconst double INF=1e7;\npt p[100010];\ndouble dist(pt a,pt b)\n{return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}\nbool cmpy(pt a,pt b){return a.y<b.y;}\ndouble closest(int l,int r)\n{\n  if(l==r) return INF;\n  int mid=(l+r)/2,pp=l,qq=mid+1;\n  double midline=p[mid].x;\n  double ret=min(closest(l,mid),closest(mid+1,r));\n  vector<pt> slab;\n  inplace_merge(p+l,p+mid+1,p+r+1,cmp);\n  for(int i=l;i<=r;i++)\n    if(abs(p[i].x-midline)<ret)\n      slab.push_back(p[i]);\n  for(int i=0;i<slab.size();i++)\n    for(int j=i+1;j<slab.size() && abs(slab[i].y-slab[j].y)<ret;j++)\n      ret=min(ret,dist(slab[i],slab[j]));\n  return ret;\n}\nint main()\n{\n  int n;\n  cin>>n;\n  for(int i=1;i<=n;i++)\n    cin>>p[i].x>>p[i].y;\n  sort(p+1,p+n+1);\n  cout<<fixed<<closest(1,n)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n/* 基本要素 */\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> VP;\nconst double PI = acos(-1);\nconst double EPS = 1e-9; // 許容誤差^2\nconst double INF = 1e9;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) - (m) < EPS)\n#define GE(n,m) (EPS > (m) - (n))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nbool compX(const Point a, const Point b) {\n  return (a.X!=b.X ? a.X<b.X : a.Y<b.Y);\n}\n\nbool compY(const Point a, const Point b) {\n  return (a.Y!=b.Y ? a.Y<b.Y : a.X<b.X);\n}\n\ndouble closestPair(VP& a,int l,int r) {\n  if(r-l<=1) return INF;\n  int m = (l+r)/2;\n  double x = a[m].X;\n  double d = min(closestPair(a,l,m),closestPair(a,m,r));\n  inplace_merge(a.begin()+l, a.begin()+m, a.begin()+r, compY);\n  VP b;\n  for(int i=l;i<r;i++){\n    if(abs(a[i].X - x)>=d)continue;\n    for(int j=b.size()-1;j>=0;j--){\n      if((a[i]-b[j]).Y>=d)break;\n      d = min(d,abs(a[i]-b[j]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\ndouble closestPair(VP ps){\n  sort(ps.begin(),ps.end(),compX);\n  return closestPair(ps,0,ps.size());\n}\n\nint main(){\n    int n;\n    cin >>n;\n\n    VP p(n);\n    rep(i,n){\n        double x,y;\n        cin >>x >>y;\n        p[i] = Point(x,y);\n    }\n\n    printf(\"%.10f\\n\", closestPair(p));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n \nusing namespace std;\n \nstruct node{\n  int dim;\n  vector<double>v;\n};\n \ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n \ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n \n  vector<node>res;\n \n  while(!S.empty()){\n    res=S;\n    node p=S[rand()%S.size()];\n \n    double dist=3*d(p,S)/(4*p.dim);\n \n    map<vector<int> ,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      vector<int> key;\n      for(int j=0;j<p.dim;j++)key.push_back((int)(S[i].v[j]/dist));\n      grid[key].push_back(i);\n    }\n \n    vector<node>nextS;\n    map<vector<int>,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    if(S.size() == nextS.size())break;\n    S=nextS;    \n  }\n \n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n   \n  return ans;\n}\n \nint main(void){\n \n  int n;\n  cin >> n;\n \n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n \n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\nstruct point2d{\n  double x, y;\n  point2d(){}\n  point2d(double x, double y): x(x), y(y){}\n  point2d operator+(const point2d &r) const{\n    return point2d(x + r.x, y + r.y);\n  }\n  point2d operator-(const point2d &r) const{\n    return point2d(x - r.x, y - r.y);\n  }\n  point2d& operator+=(const point2d &r){\n    *this = *this + r;\n    return *this;\n  }\n  point2d& operator-=(const point2d &r){\n    *this = *this - r;\n    return *this;\n  }\n  bool operator==(const point2d &r) const{\n    return abs(x - r.x) < EPS && abs(y - r.y) < EPS;\n  }\n  bool operator!=(const point2d &r) const{\n    return !(*this == r);\n  }\n  bool operator<(const point2d &r) const{\n    if(abs(x - r.x) >= EPS)return x < r.x;\n    return y < r.y;\n  }\n};\n\npoint2d operator*(double x, const point2d &p){\n  return point2d(x * p.x, x * p.y);\n}\n\npoint2d operator/(const point2d &p, double x){\n  return point2d(p.x / x, p.y / x);\n}\n\ndouble norm(const point2d &a){\n  return sqrt(a.x * a.x + a.y * a.y);\n}\n\ndouble dis(const point2d &a, const point2d &b){\n  point2d c = a - b;\n  return norm(c);\n}\n\ndouble inner_product(const point2d &a, const point2d &b){\n  return a.x * b.x + a.y * b.y;\n}\n\ndouble outer_product(const point2d &a, const point2d &b){\n  return a.x * b.y - a.y * b.x;\n}\n\ndouble cosine(const point2d &a, const point2d &b){\n  return inner_product(a, b) / norm(a) / norm(b);\n}\n\ndouble closest_pair(vector<point2d> &a, int l, int r){\n  double d = numeric_limits<double>::max();\n  if(r - l == 1)return d;\n\n  int m = (l + r) / 2;\n  double x = a[m].x;\n  d = min(closest_pair(a, l, m), closest_pair(a, m, r));\n  inplace_merge(a.begin() + l, a.begin() + m, a.begin() + r);\n\n  vector<point2d> v;\n  for(int i = l; i < r; i++){\n    if(abs(x - a[i].x) >= d)continue;\n    for(int j = 0; j < v.size(); j++){\n      double dx = a[i].x - v[v.size()-j-1].x;\n      double dy = a[i].y - v[v.size()-j-1].y;\n      if(dy >= d)break;\n      d = min(d, sqrt(dx * dx + dy * dy));\n    }\n    v.push_back(a[i]);\n  }\n  return d;\n}\n\ndouble closest_pair(vector<point2d> &a){\n  sort(a.begin(), a.end(), [](const point2d &u, const point2d &v){\n      if(u.x != v.x)return u.x < v.x;\n      return u.y < v.y;\n      });\n  return closest_pair(a, 0, int(a.size()));\n}\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  INT(n);\n  vector<point2d> v(n);\n  rep(i, n)cin >> v[i].x >> v[i].y;\n  cout << setprecision(20);\n  cout << closest_pair(v) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<vector<double>>data;\n\tvector<pair<double,double>>data2;\n\tdata2.resize(N);\n\tdata.resize(N);\n\tdouble a, b;\n\tpair<int, double>d[4][2] = {};\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tfor (size_t j = 0; j <2; j++)\n\t\t{\n\t\t\td[i][j].second = 100000.0;\n\t\t}\n\t}\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tdata[i].resize(5);\n\t\tcin >> a >> b;\n\t\tdata2[i].first = a;\n\t\tdata2[i].second = b;\n\t\tdata[i][0] = (100.0 - a)*(100.0 - a) + (100.0 - b)*(100.0 - b);\n\t\tif (d[0][1].second > data[i][0])\n\t\t{\n\t\t\td[0][1].second = data[i][0];\n\t\t\td[0][1].first = i;\n\t\t\tif (d[0][0].second > d[0][1].second)\n\t\t\t{\n\t\t\t\tswap(d[0][0], d[0][1]);\n\t\t\t}\n\t\t}\n\t\tdata[i][1] = (100.0 + a)*(100.0 + a) + (100.0 - b)*(100.0 - b);\n\t\tif (d[1][1].second > data[i][1])\n\t\t{\n\t\t\td[1][1].second = data[i][1];\n\t\t\td[1][1].first = i;\n\t\t\tif (d[1][0].second > d[1][1].second)\n\t\t\t{\n\t\t\t\tswap(d[1][0], d[1][1]);\n\t\t\t}\n\t\t}\n\t\tdata[i][2] = (100.0 - a)*(100.0 - a) + (100.0 + b)*(100.0 + b);\n\t\tif (d[2][1].second > data[i][2])\n\t\t{\n\t\t\td[2][1].second = data[i][2];\n\t\t\td[2][1].first = i;\n\t\t\tif (d[2][0].second > d[2][1].second)\n\t\t\t{\n\t\t\t\tswap(d[2][0], d[2][1]);\n\t\t\t}\n\t\t}\n\t\tdata[i][3] = (100.0 + a)*(100.0 + a) + (100.0 + b)*(100.0 + b);\n\t\tif (d[3][1].second > data[i][3])\n\t\t{\n\t\t\td[3][1].second = data[i][3];\n\t\t\td[3][1].first = i;\n\t\t\tif (d[3][0].second > d[3][1].second)\n\t\t\t{\n\t\t\t\tswap(d[3][0], d[3][1]);\n\t\t\t}\n\t\t}\n\t\tdata[i][4] = a*a+b*b;\n\t\tif (d[4][1].second > data[i][4])\n\t\t{\n\t\t\td[4][1].second = data[i][4];\n\t\t\td[4][1].first = i;\n\t\t\tif (d[4][0].second > d[4][1].second)\n\t\t\t{\n\t\t\t\tswap(d[4][0], d[4][1]);\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans = 100000.0;\n\tfor (size_t i = 0; i < 5; i++)\n\t{\n\t\tint h = d[i][0].first;\n\t\tint g = d[i][1].first;\n\t\tans = min(ans, ((data2[h].first - data2[g].first)*(data2[h].first - data2[g].first) + (data2[h].second - data2[g].second)*(data2[h].second - data2[g].second)));\n\t}\n\n\tcout << fixed << setprecision(8)<<sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#include<complex>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\nstruct P\n{\n\tdouble x, y;\n\tP(double x, double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn x*x + y*y;\n\t}\n\t\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nint ccw(P a, P b, P c) \n{\n\tb = b - a; c = c - a;\n\tif (b.cross(c) > 0)   return +1;\t\t\t// counter clockwise\n\tif (b.cross(c) < 0)   return -1;\t\t\t// clockwise\n\tif (b.dot(c) < 0)     return +2;\t\t\t// c--a--b on line\n\tif (b.length2() < c.length2()) return -2;   // a--b--c on line\n\treturn 0;\n}\n\npair<P, P> ClosestPair(vector<P>& points)\n{\n\tint n = points.size(), s = 0, t = 1, m = 2;\n\tvector<int> S(n);\n\tS[0] = 0, S[1] = 1;\n\tsort(points.begin(), points.end());\n\tdouble d = (points[s] - points[t]).length2();\n\tfor (int i = 2; i < n; S[m++] = i++)for (int j = 0; j < m; j++)\n\t{\n\t\tif ((points[S[j]] - points[i]).length2() < d)\n\t\t{\n\t\t\td = (points[s = S[j]] - points[t = i]).length2();\n\t\t}\n\t\tif (points[S[j]].x < points[i].x - d)\n\t\t{\n\t\t\tS[j--] = S[--m];\n\t\t}\n\t}\n\treturn make_pair(points[s], points[t]);\n}\n\nvector<P> points;\n\nint main()\n{\n\tpoints.reserve(100000);\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tpoints.push_back(P(x, y));\n\t}\n\n\tpair<P, P> closestPair = ClosestPair(points);\n\tprintf(\"%.10lf\\n\", (closestPair.first - closestPair.second).length());\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<pair<double, double>>data;\n\tdata.resize(N);\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort(data.begin(), data.end(), [](const pair<double, double>a, const pair<double, double>b) {return a.first == b.first ? a.second < b.second : a.first < b.first; });\n\tdouble ans = 100000.0, memo;\n\tfor (size_t i = 0; i < N - 1; i++)\n\t{\n\t\tmemo = abs(data[i + 1].second - data[i].second);\n\t\tint j = 1;\n\t\tans = min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans);\n\t\twhile (i + j < N&&min(memo,ans) >= abs(data[i + j].first - data[i].first))\n\t\t{\n\t\t\tans = sqrt(min((data[i + j].first - data[i].first)*(data[i + j].first - data[i].first) + (data[i + j].second - data[i].second)*(data[i + j].second - data[i].second), ans));\n\t\t\tj++;\n\t\t}\n\t}\n\tcout << fixed << setprecision(8) << sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n  \ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n \ndouble distance_between(const point_t& a, const point_t& b) {\n\treturn std::sqrt(std::pow(b.first - a.first, 2)\n\t\t+ std::pow(b.second - a.second, 2));\n}\n \nstd::pair<double, points_t> find_closest_brute(const std::vector<point_t>& points) {\n\tif (points.size() < 2) {\n\t\treturn { -1, { { 0, 0 }, { 0, 0 } } };\n\t}\n\tauto minDistance = std::abs(distance_between(points.at(0), points.at(1)));\n\tpoints_t minPoints = { points.at(0), points.at(1) };\n\tfor (auto i = std::begin(points); i != (std::end(points) - 1); ++i) {\n\t\tfor (auto j = i + 1; j < std::end(points); ++j) {\n\t\t\tauto newDistance = std::abs(distance_between(*i, *j));\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t\tminPoints.first = *i;\n\t\t\t\tminPoints.second = *j;\n\t\t\t}\n\t\t}\n\t}\n\treturn { minDistance, minPoints };\n}\n \nstd::pair<double, points_t> find_closest_optimized(const std::vector<point_t>& xP,\n\tconst std::vector<point_t>& yP) {\n\tif (xP.size() <= 3) {\n\t\treturn find_closest_brute(xP);\n\t}\n\tauto N = xP.size();\n\tauto xL = std::vector<point_t>();\n\tauto xR = std::vector<point_t>();\n\tstd::copy(std::begin(xP), std::begin(xP) + (N / 2), std::back_inserter(xL));\n\tstd::copy(std::begin(xP) + (N / 2), std::end(xP), std::back_inserter(xR));\n\tauto xM = xP.at(N / 2).first;\n\tauto yL = std::vector<point_t>();\n\tauto yR = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {\n\t\treturn p.first <= xM;\n\t});\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {\n\t\treturn p.first > xM;\n\t});\n\tauto p1 = find_closest_optimized(xL, yL);\n\tauto p2 = find_closest_optimized(xR, yR);\n\tauto minPair = (p1.first <= p2.first) ? p1 : p2;\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minPair, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minPair.first;\n\t});\n\tauto result = minPair;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minPair.first); ++k) {\n\t\t\tauto newDistance = std::abs(distance_between(*k, *i));\n\t\t\tif (newDistance < result.first) {\n\t\t\t\tresult = { newDistance, { *k, *i } };\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n  \nint main(){\n\tstd::vector<point_t> points;\n\tint n;\n\tdouble x,y;\n\tfor(scanf(\"%d\",&n);n--;points.emplace_back(x,y))scanf(\"%lf%lf\",&x,&y);\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tauto r = find_closest_optimized(xP, yP);\n\tprintf(\"%.9f\\n\",r.first);\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<vector<double>>data;\n\tvector<pair<double,double>>data2;\n\tdata2.resize(N);\n\tdata.resize(N);\n\tdouble a, b;\n\tpair<int, double>d[4][2] = {};\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tfor (size_t j = 0; j <2; j++)\n\t\t{\n\t\t\td[i][j].second = 100000.0;\n\t\t}\n\t}\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tdata[i].resize(4);\n\t\tcin >> a >> b;\n\t\tdata2[i].first = a;\n\t\tdata2[i].second = b;\n\t\tdata[i][0] = (100.0 - a)*(100.0 - a) + (100.0 - b)*(100.0 - b);\n\t\tif (d[0][1].second > data[i][0])\n\t\t{\n\t\t\td[0][1].second = data[i][0];\n\t\t\td[0][1].first = i;\n\t\t\tif (d[0][0].second > d[0][1].second)\n\t\t\t{\n\t\t\t\tswap(d[0][0], d[0][1]);\n\t\t\t}\n\t\t}\n\t\tdata[i][1] = (100.0 + a)*(100.0 + a) + (100.0 - b)*(100.0 - b);\n\t\tif (d[1][1].second > data[i][1])\n\t\t{\n\t\t\td[1][1].second = data[i][1];\n\t\t\td[1][1].first = i;\n\t\t\tif (d[1][0].second > d[1][1].second)\n\t\t\t{\n\t\t\t\tswap(d[1][0], d[1][1]);\n\t\t\t}\n\t\t}\n\t\tdata[i][2] = (100.0 - a)*(100.0 - a) + (100.0 + b)*(100.0 + b);\n\t\tif (d[2][1].second > data[i][2])\n\t\t{\n\t\t\td[2][1].second = data[i][2];\n\t\t\td[2][1].first = i;\n\t\t\tif (d[2][0].second > d[2][1].second)\n\t\t\t{\n\t\t\t\tswap(d[2][0], d[2][1]);\n\t\t\t}\n\t\t}\n\t\tdata[i][3] = (100.0 + a)*(100.0 + a) + (100.0 + b)*(100.0 + b);\n\t\tif (d[3][1].second > data[i][3])\n\t\t{\n\t\t\td[3][1].second = data[i][3];\n\t\t\td[3][1].first = i;\n\t\t\tif (d[3][0].second > d[3][1].second)\n\t\t\t{\n\t\t\t\tswap(d[3][0], d[3][1]);\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans = 100000.0;\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tint h = d[i][0].first;\n\t\tint g = d[i][1].first;\n\t\tans = min(ans, ((data2[h].first - data2[g].first)*(data2[h].first - data2[g].first) + (data2[h].second - data2[g].second)*(data2[h].second - data2[g].second)));\n\t}\n\n\tcout << fixed << setprecision(8)<<sqrt(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// A divide and conquer program in C/C++ to find the smallest distance from a\n// given set of points.\n\n#include <stdio.h>\n#include <float.h>\n#include <stdlib.h>\n#include <math.h>\n\n// A structure to represent a Point in 2D plane\nstruct Point\n{\n    float x, y;\n};\n\n/* Following two functions are needed for library function qsort().\n   Refer: http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/ */\n\n// Needed to sort array of points according to X coordinate\nint compareX(const void* a, const void* b)\n{\n    Point *p1 = (Point *)a,  *p2 = (Point *)b;\n    return (p1->x - p2->x);\n}\n// Needed to sort array of points according to Y coordinate\nint compareY(const void* a, const void* b)\n{\n    Point *p1 = (Point *)a,   *p2 = (Point *)b;\n    return (p1->y - p2->y);\n}\n\n// A utility function to find the distance between two points\nfloat dist(Point p1, Point p2)\n{\n    return sqrt( (p1.x - p2.x)*(p1.x - p2.x) +\n                 (p1.y - p2.y)*(p1.y - p2.y)\n               );\n}\n\n// A Brute Force method to return the smallest distance between two points\n// in P[] of size n\nfloat bruteForce(Point P[], int n)\n{\n    float min = FLT_MAX;\n    for (int i = 0; i < n; ++i)\n        for (int j = i+1; j < n; ++j)\n            if (dist(P[i], P[j]) < min)\n                min = dist(P[i], P[j]);\n    return min;\n}\n\n// A utility function to find minimum of two float values\nfloat min(float x, float y)\n{\n    return (x < y)? x : y;\n}\n\n\n// A utility function to find the distance beween the closest points of\n// strip of given size. All points in strip[] are sorted accordint to\n// y coordinate. They all have an upper bound on minimum distance as d.\n// Note that this method seems to be a O(n^2) method, but it's a O(n)\n// method as the inner loop runs at most 6 times\nfloat stripClosest(Point strip[], int size, float d)\n{\n    float min = d;  // Initialize the minimum distance as d\n\n    qsort(strip, size, sizeof(Point), compareY);\n\n    // Pick all points one by one and try the next points till the difference\n    // between y coordinates is smaller than d.\n    // This is a proven fact that this loop runs at most 6 times\n    for (int i = 0; i < size; ++i)\n        for (int j = i+1; j < size && (strip[j].y - strip[i].y) < min; ++j)\n            if (dist(strip[i],strip[j]) < min)\n                min = dist(strip[i], strip[j]);\n\n    return min;\n}\n\n// A recursive function to find the smallest distance. The array P contains\n// all points sorted according to x coordinate\nfloat closestUtil(Point P[], int n)\n{\n    // If there are 2 or 3 points, then use brute force\n    if (n <= 3)\n        return bruteForce(P, n);\n\n    // Find the middle point\n    int mid = n/2;\n    Point midPoint = P[mid];\n\n    // Consider the vertical line passing through the middle point\n    // calculate the smallest distance dl on left of middle point and\n    // dr on right side\n    float dl = closestUtil(P, mid);\n    float dr = closestUtil(P + mid, n-mid);\n\n    // Find the smaller of two distances\n    float d = min(dl, dr);\n\n    // Build an array strip[] that contains points close (closer than d)\n    // to the line passing through the middle point\n    Point strip[n];\n    int j = 0;\n    for (int i = 0; i < n; i++)\n        if (abs(P[i].x - midPoint.x) < d)\n            strip[j] = P[i], j++;\n\n    // Find the closest points in strip.  Return the minimum of d and closest\n    // distance is strip[]\n    return min(d, stripClosest(strip, j, d) );\n}\n\n// The main functin that finds the smallest distance\n// This method mainly uses closestUtil()\nfloat closest(Point P[], int n)\n{\n    qsort(P, n, sizeof(Point), compareX);\n\n    // Use recursive function closestUtil() to find the smallest distance\n    return closestUtil(P, n);\n}\n\n// Driver program to test above functions\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    Point P[n];\n    for (int i = 0; i < n; i++)\n        scanf(\"%f %f\", &P[i].x, &P[i].y);\n    printf(\"%f\\n\", closest(P, n));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(__typeof((o).begin()) it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T> >& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){EACH(a,ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;EACH(p,m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\ntemplate<> long double INF<long double>(){return 1e16;};\n\ntemplate<typename T> T pmod(T v,T M){return (v%M+M)%M;}\n\nnamespace _double_tmpl{\n    typedef long double D;const D EPS = 1e-8;\n    \n    static constexpr D Ae=0;\n    D A(D a,D b){return a+b;}D Ainv(D a){return -a;}\n    D S(D a,D b){return A(a,Ainv(b));}\n    \n    static constexpr D Me=1;\n    D M(D a,D b){return a*b;}D Minv(D a){return 1.0/a;};\n\n    int sig(D a,D b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n    template<typename T> bool eq(const T& a,const T& b){return sig(abs(a-b))==0;}\n}\nusing namespace _double_tmpl;\n\n\nnamespace Ps{\n    // using namespace _double_tmpl;\n    typedef complex<D> P,Vec;\n\n#define X real()\n#define Y imag()\n    istream& operator >> (istream& is,complex<D>& p){\n        D x,y;is >> x >> y;p=P(x,y);return is;\n    }\n\n    bool compX (const P& a,const P& b){return !eq(a.X,b.X)?sig(a.X,b.X)<0:sig(a.Y,b.Y)<0;}\n    bool compY (const P& a,const P& b){return !eq(a.Y,b.Y)?sig(a.Y,b.Y)<0:sig(a.X,b.X)<0;}\n\n    // a×b\n    D cross(const Vec& a,const Vec& b){return imag(conj(a)*b);}\n    // a・b\n    D dot(const Vec&a,const Vec& b) {return real(conj(a)*b);}\n\n    int ccw(const P& a,P b,P c){\n        b -= a; c -= a;\n        if (cross(b,c) > EPS)   return +1;       // counter clockwise\n        if (cross(b,c) < -EPS)   return -1;       // clockwise\n        if (dot(b,c) < 0)     return +2;       // c--a--b on line\n        if (norm(b) < norm(c)) return -2;       // a--b--c on line\n        return 0;\n    }\n\n    D closestPair(vector<P>& ps,int l,int r){\n        if(r-l<2)return INF<D>();\n        D res=min(closestPair(ps,l,(l+r)/2),closestPair(ps,(l+r)/2,r));\n        \n        vector<P> ips;\n        FOR(i,l,r)if(abs(ps[i].X - ps[(l+r)/2].X)<res)ips.push_back(ps[i]);\n        sort(ALL(ips),compY);\n        \n        REP(i,ips.size())for(int j=i-10;j<i;j++)if(j>=0)\n            res=min(res,abs(ips[i]-ips[j]));\n\n        return res;\n    }\n}\nusing namespace Ps;\n\nnamespace std{\n    bool operator < (const P& a,const P& b){return Ps::compX(a,b);}\n    bool operator == (const P& a,const P& b){return eq(a,b);}\n};\n\nstringstream ss;\nclass Main{\n    public:\n    void run(){\n        int n;cin >> n;\n        vector<P> ps;\n        REP(i,n) {\n            P p;cin >> p;\n            ps.push_back(p);\n        }\n        sort(ALL(ps));\n        cout << closestPair(ps,0,n)<<endl;\n    }\n};\n\nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\ndouble length_of_the_nearest_point_to(int n, double p_xy[100000][2]){\n    two_dimensional_qsort(p_xy, 0, n-1, 0);\n    if(n==1)return 999999999.9;\n    int m=n/2;\n    double x = p_xy[m][0];\n    double d = min(length_of_the_nearest_point_to(m, p_xy), length_of_the_nearest_point_to(n-m, p_xy+m));\n    \n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        \n        ans = length_of_the_nearest_point_to(n, p_xy);\n\n        cout<<fixed<<setprecision(12)<< ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\n\nint main(void)\n{\n    double dis=1000.0,temp=1000.0;\n    double temp_x,temp_y;\n    int n;\n    double x[100000],y[100000];\n\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>x[i]>>y[i];\n    \n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            if(i!=j)\n            {\n                temp = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n                if(dis>temp)\n                {\n                    dis=temp;\n                }\n            }\n        }\n    }\n    \n\n    printf(\"%lf\\n\",dis);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef pair<int, int> PI;\nconst double EPS=1e-9;\n\nconst int N = 1e5 + 10;\ndouble x[N], y[N];\n\nstruct x_cmp {\n  bool operator() (int i, int j) {\n    return x[i] < x[j];\n  }\n};\nstruct y_cmp {\n  bool operator() (int i, int j) {\n    return y[i] < y[j];\n  }\n};\n\ndouble dist2(int i, int j) {\n  return pow(x[i] - x[j], 2) + pow(y[i] - y[j], 2);\n}\n\ndouble min_brute_force(const std::vector<int> & v) {\n  double mi = 1.0 / 0.0;\n  int n = v.size();\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      if (i == j) {\n\tcontinue;\n      }\n      mi = min(mi, dist2(v[i], v[j]));\n    }\n  }\n  return mi;\n}\n\n\ndouble min_strip(const vector<int> &v, double d) {\n  double mi = d;\n  int n = v.size();\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j < n && y[v[j]] - y[v[i]] < mi; ++j) {\n      mi = min(mi, dist2(v[i], v[j]));\n    }\n  }\n  return mi;\n}\n\n/*\n */\ndouble min_pair_util(const vector<int> &vx) {\n  int n = vx.size();\n  if (n <= 1) {\n    return 0.0;\n  }\n  if (n <= 4) {\n    return min_brute_force(vx);\n  }\n  // divide at middle\n  int mid = n / 2;\n  double mid_x = x[vx[mid]];\n  double ml = min_pair_util(vector<int>(vx.begin(), vx.begin() + mid));\n  double mr = min_pair_util(vector<int>(vx.begin() + mid, vx.end()));\n  double dist = min(ml, mr);\n  vector<int> strip;\n  for(int i = 0; i < n; ++i) {\n    if (abs(x[vx[i]] - mid_x) < dist) {\n      strip.push_back(i);\n    }\n  }\n  sort(strip.begin(), strip.end(), y_cmp());\n  return min(dist, min_strip(strip, dist));\n}\n\nint main(void){\n  int n;\n  cin >> n;\n  REP(i, 0, n) {\n    cin >> x[i] >> y[i];\n  }\n  double mi = 1e10;\n  vector<int> v(n);\n  REP(i, 0, n) {\n    v[i] = i;\n  }\n  sort(v.begin(), v.end(), x_cmp());\n  mi = min_pair_util(v);\n  printf(\"%.9f\\n\", sqrt(mi));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\ndouble x[1000000],y[1000000],z=100000;\nint main(){\n\tlong long int n,i,j;\n\tcin>>n;\n\tfor(i=0;i<n;i++)\n\t\tcin>>x[i]>>y[i];\n\tfor(i=0;i<(n-1);i++)\n\tfor(i=0;i<n;i++)\n\t\tfor(j=i+1;j<n;j++){\n\t\t\tdouble s;\n\t\t\ts=sqrt(pow((x[i]-x[j]),2)+pow((y[i]-y[j]),2));\n\t\t\tif(z>s) z=s;\n\t\t}\n\tcout<<z;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// オブジェクト形式マクロの定義\n//****************************************\n\n//#define GEOMETRY_BEGIN namespace geom {\n//#define GEOMETRY_END }\n\n\n\n//****************************************\n// 型シノニム\n//****************************************\n\nusing elem_t     = long double;\nusing index_t    = std::int32_t;\nusing indices_t  = std::vector<index_t>;\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct point {\n    elem_t x, y;\n    point() : x(0), y(0) {}\n    point(elem_t x, elem_t y) : x(x), y(y) {}\n\n    point& operator+=(const point& p) { x += p.x; y += p.y; return *this; }\n    point& operator-=(const point& p) { x -= p.x; y -= p.y; return *this; }\n    point& operator*=(const elem_t d) { x *= d; y *= d; return *this;}\n\n    point operator+(const point& p)  const { return point(*this) += p; }\n    point operator-(const point& p)  const { return point(*this) -= p; }\n    point operator*(const elem_t& d) const { return point(*this) *= d; }\n};\n\n\nstruct segment {\n    point ps;  // 線分の始点\n    point pd;  // 線分の終点\n};\n\n\n\nnamespace limits {\n    constexpr auto pi  = 3.141592653589793238;\n    constexpr auto eps = 1e-10;\n    constexpr auto inf = 1e12;\n}\n\n\n/**\n * @brief   与えられた3点a, b, cをa -> b -> cと進むとき、\n * @details a -> bで時計方向に折れてb -> c(cw)\n *          a -> bで反時計方向に折れてb -> c(ccw)\n *          a -> bで逆を向いてaを通り越してb -> c (back)\n *          a -> bでそのままb -> c(front)\n *          a -> bで逆を向いてb -> cまたは、b == c(on)\n */\nenum struct orient {\n    cw    = +1,\n    ccw   = -1,\n    back  = -2,\n    front = +2,\n    on    = 0,\n};\n\n\n\n//****************************************\n// 型シノニムその2\n//****************************************\n\nusing vector_t   = point;\nusing polygon_t  = std::vector<point>;\nusing segments_t = std::vector<segment>;\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief  2つのベクトルa, bからなる行列A = (a, b)の行列式(determinant)を返します\n * @param  const vector_t& a ベクトルa\n * @param  const vector_t& b ベクトルb\n * @return elem_t det(A)    行列式|(a, b)|\n */\nstatic constexpr elem_t det(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n\n/**\n * @brief  2つのベクトルa, bのクロス積(cross product)a x bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a x b      クロス積a x b\n */\nstatic constexpr elem_t cross(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.y - a.y * b.x;\n    //return det(a, b);\n}\n\n\n/**\n * @brief  2つのベクトルa, bのドット積(dot product)a・bを返します\n * @param  const vector_t& a  ベクトルa\n * @param  const vector_t& b  ベクトルb\n * @return elem_t a・b       ドット積a・b\n */\nstatic constexpr elem_t dot(const vector_t& a, const vector_t& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n\n/**\n * @brief  ベクトルvのノルム(norm・大きさの2乗)を返します\n * @param  const vector_t& v\n * @return elem_t norm(v);\n */\nstatic constexpr elem_t norm(const vector_t& v)\n{\n    return v.x * v.x + v.y * v.y;\n    // return dot(v, v);\n}\n\n\n/**\n * @brief  ベクトルvの大きさ|v|(原点からの距離)を返します\n * @param  const vector_t& v\n * @return elem_t sqrt(norm(v))\n */\nstatic inline elem_t abs(const vector_t& v)\n{\n    return std::sqrt(norm(v));\n}\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\n/**\n * @brief (n 2) = Θ(n^2)通りの点対を調べ、最近点対間距離を返す\n *\n * @param const point*P 点集合P\n * @param index_t n     Pの要素数\n */\nstatic elem_t brute_force_closest_pair(const point*P, index_t n)\n{\n    elem_t minimum = std::numeric_limits<elem_t>::max();\n    for (index_t i = 0; i < n; i++) {\n        for (index_t j = i + 1; j < n; j++) {\n            elem_t dist = abs(P[i] - P[j]);\n            minimum = std::min(minimum, dist);\n        }\n    }\n    return minimum;\n}\n\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {  // |P| <= 3か否かを判定する\n        return brute_force_closest_pair(P, n);  // |P| <= 3ならば、虱潰で問題を解く\n    }\n\n    // |P| > 3ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = std::numeric_limits<elem_t>::max();\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) + limits::eps >= delta) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) - limits::eps >= delta) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\n\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\n\n\n//****************************************\n// エントリポイント\n//****************************************\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << setprecision(500) << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4,sse4.1,sse4.2,avx,avx2,tune=native\")\n#include <bits/stdc++.h>\n\n#define rep2(x,fr,to) for(int (x)=(fr);(x)<(to);(x)++)\n#define rep(x,to) for(int (x)=0;(x)<(to);(x)++)\n#define repr(x,fr,to) for(int (x)=(fr);(x)>=(to);(x)--)\n#define all(c) (c).begin(),(c).end()\n#define sz(v) (int)(v).size()\n\nusing namespace std;\ntypedef long long ll; typedef vector<int> VI; typedef pair<int,int> pii;\nconst int MD = (int)1e9 + 7; typedef vector<ll> VL;\nvoid dbg(){ cerr << \"\\n\"; }  template <class T, class ...T2>\nvoid dbg(const T& fst, const T2&...rst){ cerr << fst << \": \"; dbg(rst...); }\ntemplate <class T> void amax(T& a,T b){ if(a>b) a=b;}\n\nusing Pt = pair<double, double>;\nbool compare_y(Pt a, Pt b){return a.second < b.second;};\ndouble closest_pair(vector<Pt>& pos, int l, int r){\n\tif(r-l <=1) return 1e111;\n\tint mid = (l+r) /2 ;\n\tdouble x = pos[mid].first;\n\tdouble d = min(closest_pair(pos, l, mid), closest_pair(pos, mid, r));\n\tauto it = pos.begin(), itl = it+l, itm = it+mid, itr= it+r;\n\tinplace_merge(itl, itm, itr, compare_y);\n\t\n\tvector<Pt> near_line;\n\trep2(i, l, r){\n\t\tif(abs(pos[i].first - x) >= d) continue;\n\t\tint m = sz(near_line);\n\t\trepr(j, m-1, 0){\n\t\t\tdouble px = pos[i].first  - near_line[j].first;\n\t\t\tdouble py = pos[i].second - near_line[j].second;\n\t\t\tif(py >= d) break;\n\t\t\td = min(d, sqrt(px*px + py*py));\n\t\t}\n\t\tnear_line.emplace_back(pos[i]);\n\t}\n\treturn d;\n}\n\nint main(){\n\t//cin.tie(0); ios_base::sync_with_stdio(false);\n\tint n;\n\tcin >>n;\n\tvector<Pt> v(n);\n\trep(i, n) cin >>v[i].first >>v[i].second;\n\tsort(all(v));\n\tauto ans = closest_pair(v, 0, n);\n\tprintf(\"%.14f\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*******************??????********************/\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n#define X real()\n#define Y imag()\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn abs(a-b) < EPS;\n\t}\n}\ndouble cross(const P& a, const P& b) {//??????\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {//??????\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\nstruct C {//???\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {//??????????????????\n\tb -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L& l,const L& m){\n\t//non-parallel || sameline\n\treturn abs(cross(l[1]-l[0],m[1]-m[0])) > EPS || abs(cross(l[1]-l[0],m[0]-l[0])) < EPS;\n}\nbool intersectLS(const L& l,const L& s){\n\t// s[0] is left of l,s[1] is right of l\n\treturn cross(l[1]-l[0],s[0]-l[0]) * cross(l[1]-l[0],s[1]-l[0]) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectLP(const L& l,const P& p){\n\treturn abs(cross(l[1]-p,l[0]-p)) < EPS;\n}\nbool intersectSP(const L& s,const P& p){\n\treturn abs(s[0]-p)+abs(s[1]-p) - abs(s[1]-s[0]) < EPS;// triangle inequality\n}\n// ??´???????????????\nbool orthogonalLL(const L &l1, const L &l2){\n\treturn (dot(l1[0]-l1[1], l2[0]-l2[1]) <= EPS && dot(l1[0]-l1[1], l2[0]-l2[1]) >= -EPS);\n}\n// ??????????????????\nbool parallelLL(const L &l1, const L &l2){\n\treturn (cross(l1[0]-l1[1], l2[0]-l2[1]) <= EPS && cross(l1[0]-l1[1], l2[0]-l2[1]) >= -EPS);\n}\n// p??????l?????????????????????????????????\nP projection(const L& l,const P& p){\n\tdouble t = dot(p-l[0],l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\n// l???????§°?????¨????????????p??¨???????§°?????????????????????\nP reflection(const L& l,const P& p){\n\treturn p + 2. * (projection(l,p) - p);\n}\ndouble distancePP(const P &a, const P &b){\n\treturn abs(a - b);\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceLP(const L& l,const P& p){\n\treturn abs(p - projection(l,p));\n}\ndouble distanceLL(const L& l,const L& m){\n\treturn intersectLL(l,m) ? 0 : distanceLP(l,m[0]);\n}\ndouble distanceLS(const L& l,const L& s){\n\tif(intersectLS(l,s)) return 0;\n\treturn min(distanceLP(l, s[0]),distanceLP(l, s[1]));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n// ??????\nP crosspointLL(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n// ????§???¢?????¢???\ndouble area(const G &g){\n\tdouble A = 0.0;\n\tfor(int i=0;i<g.size();i++)\n\t\tA += cross(g[i],g[(i+1)%g.size()]);\n\treturn A / 2.0;\n}\n// ?????????\nbool isconvex(const G &g){\n\tfor(int i=0;i<g.size();i++){\n\t\tif(ccw(g[(i-1+g.size())%g.size()], g[i], g[(i+1)%g.size()]) == -1)return false;\n\t}\n\treturn true;\n}\n// convex full\nG convex_full(G &ps){\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k-1);\n\treturn ch;\n}\n// ????§???¢?????´??????????????????????????¢\ndouble convex_diameter(const G &pt){\n\tconst int n = pt.size();\n\tint is = 0, js = 0;\n\tfor(int i=1;i<n;i++){\n\t\tif(imag(pt[i]) > imag(pt[is])) is = i;\n\t\tif(imag(pt[i]) < imag(pt[js])) js = i;\n\t}\n\tdouble maxd = norm(pt[is]-pt[js]);\n\tint i, maxi, j, maxj;\n\ti = maxi = is;\n\tj = maxj = js;\n\tdo {\n\t\tif (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n\t\telse i = (i+1) % n;\n\t\tif (norm(pt[i]-pt[j]) > maxd) {\n\t\t\tmaxd = norm(pt[i]-pt[j]);\n\t\t\tmaxi = i; maxj = j;\n\t    }\n\t} while (i != is || j != js);\n\treturn sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n// ???????§???¢?????????\n// ???????§???¢?????´?????§???????????????????????´???????????????\nG convex_cut(const G &g, const L &l){\n\tG Q;\n\tfor(int i=0;i<g.size();i++){\n\t\tP A = curr(g, i), B = next(g, i);\n\t\tif(ccw(l[0], l[1], A) != -1) Q.push_back(A);\n\tif(ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0) Q.push_back(crosspointLL(L(A, B), l));\n\t}\n\treturn Q;\n}\n// ??????????????§??????\nbool is_convex(G &g){\n\tG cf = convex_full(g);\n\tif(cf.size() == g.size())return true;\n\treturn false;\n}\n// ??????????§???¢????????????\nenum{ OUT, ON, IN};\nint contains(const G &g, const P &p){\n\tbool in = false;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a = g[i] - p, b = g[(i+1)%g.size()] - p;\n\t\tif( imag(a) > imag(b) )swap(a, b);\n\t\tif( imag(a) <= 0 && 0 < imag(b) )\n\t\t\tif( cross(a, b) < 0) in = !in;\n\t\tif( cross(a, b) == 0 && dot(a, b) <= 0 )return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n// ????????????\ndouble compare_x(const P &a, const P &b){\n\treturn a.X != b.X ? a.X < b.X : a.Y < b.Y;\n}\ndouble compare_y(const P &a, const P &b){\n\treturn a.Y != b.Y ? a.Y < b.Y : a.X < b.X;\n}\ndouble convex_radius(P *a, int n){\n\tif(n <= 1) return INF;\n\tint m = n / 2;\n\tdouble x = a[m].X;\n\tdouble d = min(convex_radius(a, m), convex_radius(a + m, n - m));\n\tsort(a, a + n, compare_y);\n\tvector<P> b;\n\tfor(int i = 0; i < n; ++i){\n\t\tif(fabs(a[i].X - x) >= d) continue;\n\t\tfor(int j = 0; j < (int)b.size(); ++j){\n\t\t\tP p0 = a[i], p1 = b[(int)(b.size()) - j - 1];\n\t\t\tif(p0.Y - p1.Y >= d) break;\n\t\t\td = min(d, abs(p0 - p1));\n\t\t}\n\t\tb.push_back(a[i]);\n\t}\n\treturn d;\n}\nint main(void){\n\tint n;\n\tcin >> n;\n\tG g(n);\n\tfor(int i=0;i<n;i++){\n\t\tdouble x,y;\n\t\tcin >> x >> y;\n\t\tg[i] = P(x,y);\n\t}\n\tsort(g.begin(),g.end(),compare_x);\n\tcout << fixed << setprecision(20) << convex_radius(&g[0],n) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<vector>\n#include<cmath>\n#include<algorithm>\n\nstruct Point {\n    double x, y;\n    Point(double x, double y) :x(x), y(y){}\n};\nbool operator<(const Point& lhs, const Point& rhs) {return lhs.x != rhs.x ? lhs.x < rhs.x : lhs.y < rhs.y;}\ndouble distance(const Point& lhs, const Point& rhs) {return std::hypot(lhs.x - rhs.x, lhs.y - rhs.y);}\n\nstd::vector<Point> closest_pair(std::vector<Point> point) {\n    std::sort(point.begin(), point.end());\n    int i1 = 0, i2 = 1;\n    int candidate[point.size()], candidate_size = 0;\n    candidate[candidate_size++] = i1;\n    candidate[candidate_size++] = i2;\n    double d = distance(point[i1], point[i2]);\n    for(int i = 2; i < point.size(); candidate[candidate_size++] = i++) for(int j = 0; j < candidate_size; ++j) {\n        if(distance(point[i], point[candidate[j]]) < d) d = distance(point[i1 = i], point[i2 = candidate[j]]);\n        if(point[i].x - point[candidate[j]].x >= d) candidate[j--] = candidate[--candidate_size];\n    }\n    return {point[i1], point[i2]};\n}\n////////////////////////////////////////////////////////////////////////////////\n#include<iostream>\n#include<iomanip>\nusing namespace std;\n\nint main() {\n    int n;\n    vector<Point> v;\n    for(cin >> n; n > 0; --n) {\n        double x, y;\n        cin >> x >> y;\n        v.push_back(Point(x, y));\n    }\n    auto res = closest_pair(v);\n    cout <<setprecision(12) << fixed << distance(res[0], res[1]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / PI);\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * PI / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ninline double Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\n\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  if (r - l == 2) {\n    return PointPoint(ps[l], ps[l + 1]);\n  }\n  if (r - l == 3) {\n    PointPoint a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return Closer(a, Closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  Points pos[2];\n  for (int i = l; i < r; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) pos[i < mid].push_back(ps[i]);\n  }\n  for (const auto &i : pos[0]) {\n    for (const auto &j : pos[1]) {\n      if (Distance(i, j) < d) {\n        d = Distance(i, j);\n        res = PointPoint(i, j);\n      }\n    }\n  }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  PointPoint res = ClosestPairUtil(ps, 0, ps.size());\n  res.first = rotate(-0.1, res.first);\n  res.second = rotate(-0.1, res.second);\n  return res;\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  sort(p.begin(), p.end());\n  PointPoint pp = ClosestPair(p);\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n  // cerr << pp.first << \" \" << pp.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n#include <queue>\n#include <vector>\n\n\nusing namespace std;\n\n//-------------------------------------------------------------------------------------\n/*2点[(x1,y1),(x2,y2)]を入力し二点を通る直線ax+by+cの(a,b,c)を返す,  */\n/*x1==x2ならfalseを返す*/\n/*falseならばx=cの形の直線*/\nvoid straight_line_passing_through_the_two_points(double x1, double y1, double x2, double y2, double *a, double *b, double *c){\n    *a=(y2-y1);\n    *b=-(x2-x1);\n    *c=y2*(x2-x1)-x2*(y2-y1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x,y)を通るa1x+b1y+c1=0に垂直な直線a2x+b2y+c2=0を返す*/\nbool vertical_straight_line(double x, double y, double a1, double b1, double c1, double *a2, double *b2, double *c2){\n    if(a1*x+b1*y+c1==0)return false;\n    *a2 = -b1;\n    *b2 = a1;\n    *c2 = b1*x - a1*y;\n    return true;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*2直線 a1x+b1y+c1=0 a2x+b2y+c2=0 の交点 (x,y)を返す*/\n/*2直線が平行であるならば0を返す*/\nint intersection_and_parallel(double a1, double b1, double c1, double a2, double b2, double c2, double *x, double *y){\n    if(a1*b2==a2*b1)return false;//平行の判定\n    \n    *x = (b1*c2-b2*c1)/(a1*b2-a2*b1);\n    *y = (a2*c1-a1*c2)/(a1*b2-a2*b1);\n    \n    return true;\n}\n\n//-------------------------------------------------------------------------------------\n/* \n a1x+b1y+c1=0 と　a2x+b2y+c2=0 が\n 平行なら2\n 直交なら1\n それ以外は0\n を返す\n */\nint judges_whether_parallel_or_perpendicular(double a1, double b1, double c1, double a2, double b2, double c2){\n    if(a1*b2 == a2*b1)return 2;\n    if(a1*a2 + b1*b2 == 0)return 1;\n    return 0;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*直線ax+by+c=0に対し　(x1,y1)と線対称な位置(x2,y2)を出力*/\n/*vertical_straight_lineを使用*/\n/*intersection_and_parallelを使用*/\nvoid line_symmetry(double a, double b, double c, double x1, double y1, double *x2, double *y2){\n    //垂直な直線を求める\n    double a2,b2,c2;\n    vertical_straight_line(x1, y1, a, b, c, &a2, &b2, &c2);\n    \n    //垂直な直線との交点を求める\n    double c_x, c_y;\n    intersection_and_parallel(a, b, c, a2, b2, c2, &c_x, &c_y);\n    *x2 = x1 + 2*(c_x-x1);\n    *y2 = y1 + 2*(c_y-y1);\n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*2点(x1,y1), (x2,y2) の距離*/\ndouble distance_between_the_two_pointss(double x1,double y1, double x2, double y2){\n    return  sqrt(fabs((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));\n}\n\n\n//-------------------------------------------------------------------------------------\n/* (x1,y1)から(x2,y2)へ伸ばした直線の角度を求める  */\n/*-π　〜　+π　まで*/\ndouble angle_of_the_line(double x1, double y1, double x2, double y2){\n    return atan2(y2-y1, x2-x1);\n}\n\n//-------------------------------------------------------------------------------------\n/*(x1,y1)と(x2,y2)を両端に持つ線分と*/\n/*(x3,y3)と(x4,y4)を両端に持つ線分が*/\n/*交差するなら1 交差しないなら0を出力する*/\n/* straight_line_passing_through_the_two_pointsを使用 */\n/* intersection_and_parallelを使用 */\nint line_segment_cross_decision(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    double a1,b1,c1, a2,b2,c2;\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a1, &b1, &c1);\n    straight_line_passing_through_the_two_points(x3, y3, x4, y4, &a2, &b2, &c2);\n    double c_x,c_y;\n    bool is_parallel = intersection_and_parallel(a1, b1, c1, a2, b2, c2, &c_x, &c_y);\n    if(is_parallel==false){\n        if( (a1==a2&&b1==b2&&c1==c2) || (a1==0 && (b1/b2)==(c1/c2)) || (b1==0 && (a1/a2)==(c1/c2)) ){//一直線上にある.\n            //cout<<1111;\n            if(min(x1,x2)<=x3&&x3<=max(x1,x2)&&min(y1,y2)<=y3&&y3<=max(y1,y2))return 1;\n            if(min(x1,x2)<=x4&&x4<=max(x1,x2)&&min(y1,y2)<=y4&&y4<=max(y1,y2))return 1;\n            if(min(x3,x4)<=x1&&x1<=max(x3,x4)&&min(y3,y4)<=y1&&y1<=max(y3,y4))return 1;\n            if(min(x3,x4)<=x2&&x2<=max(x3,x4)&&min(y3,y4)<=y2&&y2<=max(y3,y4))return 1;\n            \n\n\n        }\n        return 0;\n    }\n    if(x1>x2)swap(x1, x2);\n    if(x3>x4)swap(x3, x4);\n    if(y1>y2)swap(y1, y2);\n    if(y3>y4)swap(y3, y4);\n\n    if(x1<=c_x&&c_x<=x2&&x3<=c_x&&c_x<=x4){\n        if(y1<=c_y&&c_y<=y2&&y3<=c_y&&c_y<=y4)return 1;\n    }\n    return 0;\n    \n}\n\n\n\n//-------------------------------------------------------------------------------------\n/*点(p_x,p_y)と線分(x1,y1)(x2,y2)の距離*/\n/* straight_line_passing_through_the_two_points */\n/* vertical_straight_line */\n/* intersection_and_parallel */\ndouble distance_between_the_line_segment_and_point(double p_x, double p_y, double x1, double y1, double x2, double y2){\n    double a,b,c;//(x1,y1)(x2,y2)を通る直線\n    straight_line_passing_through_the_two_points(x1, y1, x2, y2, &a, &b, &c);\n    double a2,b2,c2;//直線ax+by+c=0に垂直な直線\n    double v_x, v_y;//二つの直線の交点\n    bool is_not_parallel = vertical_straight_line(p_x, p_y, a, b, c, &a2, &b2, &c2);\n    intersection_and_parallel(a, b, c, a2, b2, c2, &v_x, &v_y);\n    \n    if(is_not_parallel){\n        if(min(x1,x2)<=v_x&&v_x<=max(x1,x2)&&min(y1,y2)<=v_y&&v_y<=max(y1,y2)){//(v_x,v_y)は線分の中にある\n            //cout<<\"a \";\n            return distance_between_the_two_pointss(p_x, p_y, v_x, v_y);\n        }else{//(v_x,v_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"b \";\n            return min(l1,l2);\n        }\n    }else{\n        if(min(x1,x2)<=p_x&&p_x<=max(x1,x2)&&min(y1,y2)<=p_y&&p_y<=max(y1,y2)){//(p_x,p_y)は線分の中にある\n            //cout<<\"c \";\n            return 0.0;\n        }else{//(p_x,p_y)は線分の外にある\n            double l1 = distance_between_the_two_pointss(p_x, p_y, x1, y1);\n            double l2 = distance_between_the_two_pointss(p_x, p_y, x2, y2);\n            //cout<<\"d \";\n            return min(l1,l2);\n        }\n    }\n    \n}\n\n\n//-------------------------------------------------------------------------------------\n/*線分(x1,y1)(x2,y2)と線分(x3,y3)(x4,y4)の距離*/\n\ndouble distance_between_two_line_segment(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4){\n    //同一直線上にある場合\n    \n    //ぶつかる場合\n    if(line_segment_cross_decision(x1, y1, x2, y2, x3, y3, x4, y4)){\n        return 0.0;\n    }\n    \n    //ぶつからない場合\n    double l1,l2,l3,l4;\n    l1=distance_between_the_line_segment_and_point(x1, y1, x3, y3, x4, y4);\n    //cout<<l1<<endl;\n    l2=distance_between_the_line_segment_and_point(x2, y2, x3, y3, x4, y4);\n    //cout<<l2<<endl;\n\n    l3=distance_between_the_line_segment_and_point(x3, y3, x1, y1, x2, y2);\n    //cout<<l3<<endl;\n    l4=distance_between_the_line_segment_and_point(x4, y4, x1, y1, x2, y2);\n    \n        \n    //cout<<l4<<endl;\n    \n    return min(l1,min(l2,min(l3,l4)));\n}\n\n//-------------------------------------------------------------------------------------\n/*多角形の面積*/\n/*頂点数n　頂点の集合 */\ndouble area_of_the_polygon(int n, double p_xy[10000][2]){\n    double s=0.0;\n    for(int i=0; i<n; i++){\n        s+=(p_xy[i][0]-p_xy[(i+1)%n][0])*(p_xy[i][1]+p_xy[(i+1)%n][1])/2;\n    }\n    return s;\n}\n\n\n//-------------------------------------------------------------------------------------\n/*角abcの角度　a(xa,ya), b(xb,yb), c(xc,yc),*/\n/*2辺の角度*/\n/*aとb　またはbとcが重なっていればPIを返す*/\ndouble angle_of_the_two_edges(double ax, double ay, double bx, double by, double cx, double cy){\n    if(ax==bx&&ay==by)return M_PI;\n    if(cx==bx&&cy==by)return M_PI;\n    \n    double angle1 = angle_of_the_line(ax, ay, bx, by);\n    double angle2 = angle_of_the_line(bx, by, cx, cy);\n    \n    double ret = angle1+(M_PI-angle2);\n    if(ret>M_PI * 2)ret -= M_PI * 2;\n    if(ret<0)ret += M_PI * 2;\n    return ret;\n    \n}\n\n//-------------------------------------------------------------------------------------\n/*多角形に対する点の内外判定*/\n/* n頂点の多角形p_xy[n]に対して点(x,y)の内外判定を行う*/\n/* 内なら2 線上なら1 外なら0*/\nint inside_and_outside_the_determination_of_the_polygon_and_point(int n, double p_xy[10000][2], double x, double y){\n    //点が線分上にあるか\n    for(int i=0; i<n; i++){\n        double l = distance_between_the_line_segment_and_point(x, y, p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1]);\n        if(l==0.0)return 1;\n    }\n    \n    //点が中にあるか外にあるか\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        if(p_xy[i][0]!=p_xy[(i+1)%n][0]){\n            ans += line_segment_cross_decision(p_xy[i][0], p_xy[i][1], p_xy[(i+1)%n][0], p_xy[(i+1)%n][1], x, y, x, y+1000000.0);\n            \n            if(distance_between_the_line_segment_and_point(p_xy[i][0], p_xy[i][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]>p_xy[(i+1)%n][0])ans--;\n            }\n            if(distance_between_the_line_segment_and_point(p_xy[(i+1)%n][0], p_xy[(i+1)%n][1],x, y, x, y+1000000.0)==0.0){\n                if(p_xy[i][0]<p_xy[(i+1)%n][0])ans--;\n            }\n        }\n        \n    }\n    //cout<<\" \"<<ans<<\" \";\n    if(ans%2==0)return 0;\n    else return 2;\n}\n//-------------------------------------------------------------------------------------\n/*二点の角度*/\n/*0~2π*/\ndouble angle_line_0_359(double x1, double y1, double x2, double y2){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    return angle;\n}\n\n//-------------------------------------------------------------------------------------\n/*二辺の角度*/\n/*反時計回りの内側*/\n/*0~2π*/\ndouble angle_two_line_0_359(double x1, double y1, double x2, double y2, double x3, double y3){\n    double angle = atan2(y2-y1, x2-x1);\n    if(angle<0)angle = 2*M_PI+angle;\n    if(angle==2*M_PI)angle=0.0;\n    \n    double angle2 = atan2(y3-y2, x3-x2);\n    if(angle2<0)angle2 = 2*M_PI+angle2;\n    if(angle2==2*M_PI)angle2=0.0;\n    \n    return angle+(M_PI-angle2);\n}\n\n//-------------------------------------------------------------------------------------\n/*二次元配列のクイックソート*/\n/*xoryが0ならx座標　1なら座標でソート*/\nvoid two_dimensional_qsort(double xy[100000][2], int left, int right, int xory)\n{\n    int i, j;\n    double pivot,pivot2;\n    \n    i = left;                      /* ソートする配列の一番小さい要素の添字 */\n    j = right;                     /* ソートする配列の一番大きい要素の添字 */\n    \n    pivot = xy[(left + right) / 2][xory]; /* 基準値を配列の中央付近にとる */\n    pivot2 = xy[(left + right) / 2][(xory+1)%2];\n    \n    \n    while (1) {                    /* 無限ループ */\n        \n        while (xy[i][xory] < pivot || (xy[i][xory] == pivot && xy[i][(xory+1)%2] < pivot2))       /* pivot より大きい値が */\n            i++;                   /* 出るまで i を増加させる */\n        \n        while (pivot < xy[j][xory] || (xy[j][xory] == pivot &&  pivot2 < xy[j][(xory+1)%2]))       /* pivot より小さい値が */\n            j--;                   /*  出るまで j を減少させる */\n        if (i >= j)                /* i >= j なら */\n            break;                 /* 無限ループから抜ける */\n        \n        swap(xy[i][xory], xy[j][xory]);            /* x[i] と x[j]を交換 */\n        swap(xy[i][(xory+1)%2], xy[j][(xory+1)%2]);            /* x[i] と x[j]を交換 */\n        i++;                       /* 次のデータ */\n        j--;\n    }\n    \n    if (left < i - 1)              /* 基準値の左に 2 以上要素があれば */\n        two_dimensional_qsort(xy, left, i - 1, xory);     /* 左の配列を Q ソートする */\n    if (j + 1 <  right)            /* 基準値の右に 2 以上要素があれば */\n        two_dimensional_qsort(xy, j + 1, right, xory);    /* 右の配列を Q ソートする */\n}\n\n\n//-------------------------------------------------------------------------------------\n/*凸包*/\n/*２次元平面における点の集合Pに対する凸包（convex hull）を求めて下さい。凸包とは点集合Pの全ての点を含む最小の凸多角形です。*/\n/*集合の要素数 n*/\n/*集合 p_xy[1000000][2]*/\n/*解答の要素数 q*/\n/*解答 ans[1000000][2]　最も下の最も左から反時計回り*/\n\nvoid convex_hull(int n, double p_xy[100000][2], int *q, double ans[100000][2]){\n\n    two_dimensional_qsort(p_xy, 0, n-1, 1);\n    /*\n    for(int i=0; i<n; i++){\n        cout<<p_xy[i][0]<<\" \"<<p_xy[i][1]<<endl;\n    }\n     */\n    \n    \n    int k=0;\n    for(int i=0; i<n; i++){\n        while(k > 1 && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    \n    \n    int t=k;\n    for(int i=n-2; i>=0; i--){\n        while(k > t && (angle_two_line_0_359(ans[k-2][0], ans[k-2][1], ans[k-1][0], ans[k-1][1], p_xy[i][0], p_xy[i][1])>M_PI))k--;\n        ans[k][0]=p_xy[i][0];\n        ans[k][1]=p_xy[i][1];\n        k++;\n    }\n    *q=k-1;\n}\n//-------------------------------------------------------------------------------------\n/*点の集合(凸多角形)の最遠点距離*/\ndouble diameter_of_the_polygon(int n, double p_xy[100000][2]){\n    double ch[100000][2];\n    int q;\n    convex_hull(n, p_xy, &q, ch);\n    \n    \n    int i=0;\n    int j=0;\n    for(int k=0; k<q; k++){\n        if(ch[j][1]<ch[k][1]){\n            j=k;\n        }\n    }\n    \n    int si=i;\n    int sj=j;\n    double res =  distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]);\n    while(1){\n        if(i==sj||j==si)break;\n        \n        double cross = (ch[(si+1)%n][0]-ch[si][0])*(ch[(sj+1)%n][1]-ch[sj][1]) - (ch[(si+1)%n][1]-ch[si][1])*(ch[(sj+1)%n][0]-ch[sj][0]);\n        //cout<<cross<<endl;\n        \n        if(cross<0){\n            si=(si+1)%n;\n            //res = max(res,a);\n        }else{\n            sj=(sj+1)%n;\n            //res = max(res,b);\n        }\n        \n        res =  max(res,distance_between_the_two_pointss(ch[si][0], ch[si][1], ch[sj][0], ch[sj][1]));\n                                                    \n        \n    }\n    \n    return res;\n}\n\n//-------------------------------------------------------------------------------------\n/*点の集合の最近点距離*/\ndouble length_of_the_nearest_point_to(int n0, int n, double p_xy[100000][2]){\n    two_dimensional_qsort(p_xy, n0, n-1, 0);\n    if(n-n0<=1)return 999999999.9;\n    int m=(n-n0)/2;\n    double x = p_xy[n0+m][0];\n    double d = min(length_of_the_nearest_point_to(n0,m, p_xy), length_of_the_nearest_point_to(n0+m, n, p_xy));\n    \n\n    two_dimensional_qsort(p_xy+n0, 0, n-1-n0, 1);\n    ////////////////\n    vector<double>b_x;\n    vector<double>b_y;\n    for(int i=n0; i<n; i++){\n        if(fabs(p_xy[i][0]-x)>=d)continue;\n        \n        for(int j=0; j<b_x.size(); j++){\n            double dx = p_xy[i][0]-b_x[b_x.size()-j-1];\n            double dy = p_xy[i][1]-b_y[b_y.size()-j-1];\n            if(dy >= d)break;\n            d=min(d, sqrt(dx*dx+dy*dy));\n        }\n        b_x.push_back(p_xy[i][0]);\n        b_y.push_back(p_xy[i][1]);\n    }\n    \n    return d;\n    \n}\n\n\n\nint main(int argc, const char * argv[]){\n    \n    int n;\n    while(cin>>n){\n        double p_xy[100000][2]={0};\n        for(int i=0; i<n; i++){\n            cin>>p_xy[i][0]>>p_xy[i][1];\n        }\n        \n\n        double ans;\n        \n        ans = length_of_the_nearest_point_to(0,n, p_xy);\n\n        cout<<fixed<<setprecision(12)<< ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) {\n  return fabs(b - a) < EPS;\n}\n\nusing Point = complex<double>;\nistream &operator>>(istream &is, Point &p) {\n  double a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\nbool operator<(const Point &a, const Point &b) {\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nPoint rotate(double theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\ndouble cross(const Point &a, const Point &b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dot(const Point &a, const Point &b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble RadianToDegree(double r) {\n  return (r * 180.0 / acos(-1));\n}\n\ndouble DegreeToRadian(double d) {\n  return (d * acos(-1) / 180.0);\n}\n\ndouble GetAngle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  double alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta) swap(alpha, beta);\n  double theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nstruct Line {\n  Point a, b;\n\n  Line(){};\n  Line(Point a, Point b) : a(a), b(b){};\n\n  // Ax + By = C\n  Line(double A, double B, double C) {\n    if (eq(A, 0)) {\n      a = Point(0, C / B);\n      b = Point(1, C / B);\n    } else if (eq(B, 0)) {\n      a = Point(C / A, 0);\n      b = Point(C / A, 1);\n    } else {\n      a = Point(0, C / B);\n      b = Point(C / A, 0);\n    }\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment {\n  Point a, b;\n\n  Segment(){};\n  Segment(Point a, Point b) : a(a), b(b){};\n\n  friend ostream &operator<<(ostream &os, Segment &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Segment &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Circle {\n  Point p;\n  double r;\n\n  Circle(){};\n\n  Circle(Point p, double r) : p(p), r(r){};\n};\n\nusing Polygon = vector<Point>;\nusing Points = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\nusing PointPoint = pair<Point, Point>;\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                          // \"ON_SEGMENT\"\n}\n\nbool Parallel(const Line &a, const Line &b) {\n  return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n}\n\nbool Orthogonal(const Line &a, const Line &b) {\n  return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n}\n\nPoint Projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\nPoint Projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint Reflection(const Line &l, const Point &p) {\n  return p + (Projection(l, p) - p) * 2.0;\n}\n\ndouble Distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\ndouble Distance(const Line &l, const Point &p) {\n  return abs(p - Projection(l, p));\n}\n\nbool Intersect(const Line &l, const Line &m);\ndouble Distance(const Line &l, const Line &m) {\n  return Intersect(l, m) ? 0 : Distance(l, m.a);\n}\n\nbool Intersect(const Segment &s, const Point &p);\ndouble Distance(const Segment &s, const Point &p) {\n  Point r = Projection(s, p);\n  if (Intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nbool Intersect(const Segment &s, const Segment &t);\ndouble Distance(const Segment &a, const Segment &b) {\n  if (Intersect(a, b)) return 0;\n  return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n}\n\nbool Intersect(const Line &l, const Segment &s);\ndouble Distance(const Line &l, const Segment &s) {\n  if (Intersect(l, s)) return 0;\n  return min(Distance(l, s.a), Distance(l, s.b));\n}\n\nbool Intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool Intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool Intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool Intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\ndouble Distance(const Line &l, const Point &p);\nbool Intersect(const Circle &c, const Line &l) {\n  return Distance(l, c.p) <= c.r + EPS;\n}\n\nbool Intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\nint Intersect(const Circle &c, const Segment &l) {\n  if (norm(Projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = Projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\nPoint Crosspoint(const Line &l, const Line &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m) {\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if (abs(A) < EPS && abs(B) < EPS) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPointPoint Crosspoint(const Circle &c, const Line l) {\n  Point hp = Projection(l, c.p), h = hp - c.p;\n  const double d2 = norm(h);\n  Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / abs(l.b - l.a);\n  return PointPoint(hp - v, hp + v);\n}\n\nPointPoint Crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if (Intersect(c, l) == 2) return Crosspoint(c, aa);\n  PointPoint ret = Crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\nPointPoint Crosspoint(const Circle &c1, const Circle &c2) {\n  double d = abs(c1.p - c2.p);\n  double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  double t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return (PointPoint(p1, p2));\n}\n\nbool IsConvex(const Polygon &p) {\n  int n = p.size();\n  for (int i = 0; i < n; i++) {\n    if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\nPolygon Convex_Hull(Polygon &p) {\n  int n = p.size(), k = 0;\n  if (n >= 3) {\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n      while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n      while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n  } else {\n    return p;\n  }\n}\n\nenum { OUT, ON, IN };\nint Contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for (int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool MergeIfAble(Segment &s1, Segment s2) {\n  if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n  if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n  if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n  s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n  return true;\n}\n\nvoid MergeSegments(vector<Segment> &segs) {\n  for (int i = 0; i < segs.size(); i++) {\n    if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for (int i = 0; i < segs.size(); i++) {\n    for (int j = i + 1; j < segs.size(); j++) {\n      if (MergeIfAble(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\nvector<vector<int>> SegmentArrangement(vector<Segment> &segs, vector<Point> &ps) {\n  vector<vector<int>> g;\n  const int N = (int)segs.size();\n  for (int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for (int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if (cross(p1, p2) == 0) continue;\n      if (Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int)ps.size();\n  g.resize(M);\n  for (int i = 0; i < N; i++) {\n    vector<int> vec;\n    for (int j = 0; j < M; j++) {\n      if (Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for (int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nPolygon ConvexCut(Polygon &U, Line l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(Crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\ndouble Area2(const Polygon &p) {\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\ndouble Convex_Diameter(Polygon &p) {\n  int n = p.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; i++) {\n    if (p[i].imag() > p[is].imag()) is = i;\n    if (p[i].imag() < p[js].imag()) js = i;\n  }\n  double maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {\n      j = (j + 1) % n;\n    } else {\n      i = (i + 1) % n;\n    }\n    if (norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxdis);\n}\n\nPointPoint Closer(PointPoint a, PointPoint b) {\n  return Distance(a.first, a.second) < Distance(b.first, b.second) ? a : b;\n}\n\nPointPoint ClosestPairUtil(Points &ps, int l, int r) {\n  // if (r - l <= 3) {\n  //   PointPoint res(ps[l], ps[r - 1]);\n  //   for (int i = l; i < r; ++i) {\n  //     for (int j = i + 1; j < r; ++j) {\n  //       res = Closer(res, PointPoint(ps[i], ps[j]));\n  //     }\n  //   }\n  //   return res;\n  // }\n  if (r - l == 2) {\n    return PointPoint(ps[l], ps[l + 1]);\n  }\n  if (r - l == 3) {\n    PointPoint a(ps[l], ps[l + 1]), b(ps[l + 1], ps[l + 2]), c(ps[l], ps[l + 2]);\n    return Closer(a, Closer(b, c));\n  }\n\n  int mid = (l + r) / 2;\n  Point midPoint = ps[mid];\n  PointPoint res = Closer(ClosestPairUtil(ps, l, mid), ClosestPairUtil(ps, mid, r));\n  double d = Distance(res.first, res.second);\n\n  Points strip;\n  for (int i = l; i < r; ++i) {\n    if (abs(ps[i].real() - midPoint.real()) < d) strip.push_back(ps[i]);\n  }\n\n  for (int i = 0; i < strip.size(); ++i) {\n    for (int j = i + 1; j < strip.size(); ++j) {\n      if (Distance(strip[i], strip[j]) < d) {\n        d = Distance(strip[i], strip[j]);\n        res = PointPoint(strip[i], strip[j]);\n      }\n    }\n  }\n\n  return res;\n}\n\nPointPoint ClosestPair(Points ps) {\n  if (ps.size() <= 1) exit(-1);\n  for (int i = 0; i < ps.size(); ++i) {\n    ps[i] = rotate(0.1, ps[i]);\n  }\n  sort(ps.begin(), ps.end());\n\n  if (ps.size() == 2) return PointPoint(ps[0], ps[1]);\n  return ClosestPairUtil(ps, 0, ps.size());\n}\n\n// int main() {}\n\n// Projection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_A\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Projection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// Reflection\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_B\n// int main() {\n//   Line l;\n//   cin >> l;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p;\n//     cin >> p;\n//     Point ans = Reflection(l, p);\n//     cout << ans << endl;\n//   }\n// }\n\n// ccw\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/1/CGL_1_C\n// int main() {\n//   const vector<string> ans{\"ONLINE_FRONT\", \"CLOCKWISE\", \"ON_SEGMENT\", \"COUNTER_CLOCKWISE\", \"ONLINE_BACK\"};\n//   Point p0, p1;\n//   cin >> p0 >> p1;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point p2;\n//     cin >> p2;\n//     cout << ans[ccw(p0, p1, p2) + 2] << endl;\n//   }\n// }\n\n// Parallel and Orthogonal\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   while (n--) {\n//     Line a, b;\n//     cin >> a >> b;\n//     if (Parallel(a, b))\n//       puts(\"2\");\n//     else if (Orthogonal(a, b))\n//       puts(\"1\");\n//     else\n//       puts(\"0\");\n//   }\n// }\n\n// Intersect(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_B\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << Intersect(a, b) << endl;\n//   }\n// }\n\n// Crosspoint(S, S)\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_C\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     Point ans = Crosspoint(a, b);\n//     cout << ans << endl;\n//   }\n// }\n\n// Distance(S, S);\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/2/CGL_2_D\n// int main() {\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Segment a, b;\n//     cin >> a >> b;\n//     cout << fixed << setprecision(10) << Distance(a, b) << endl;\n//   }\n// }\n\n// Area2\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(1) << Area2(p) / 2.0 << endl;\n// }\n\n// IsConvex\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_B\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << IsConvex(p) << endl;\n// }\n\n// Contains\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/3/CGL_3_C\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Point a;\n//     cin >> a;\n//\n//     cout << Contains(p, a) << endl;\n//   }\n// }\n\n// Convex_Hull\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_A\n// int main() {\n//   int n;\n//   cin >> n;\n//   Polygon p;\n//   for (int i = 0; i < n; ++i) {\n//     int a, b;\n//     cin >> a >> b;\n//     p.push_back(Point(a, b));\n//   }\n//\n//   p = Convex_Hull(p);\n//   cout << p.size() << endl;\n//\n//   // 最悪\n//   Point minp = p[0];\n//   int idx = 0;\n//   for (int i = 0; i < p.size(); ++i) {\n//     if (p[i].imag() < minp.imag() ? true : p[i].imag() == minp.imag() && p[i].real() < minp.real()) {\n//       minp = p[i];\n//       idx = i;\n//     }\n//   }\n//\n//   for (int i = 0; i < p.size(); ++i) {\n//     Point latte = p[(i + idx) % p.size()];\n//     cout << latte.real() << \" \" << latte.imag() << endl;\n//   }\n// }\n\n// Convex_Diameter\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_B\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   cout << fixed << setprecision(10) << Convex_Diameter(p) << endl;\n// }\n\n// ConvexCut\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/4/CGL_4_C\n// int main() {\n//   int n;\n//   cin >> n;\n//\n//   Polygon p(n);\n//   for (auto &i : p) cin >> i;\n//\n//   int q;\n//   cin >> q;\n//   while (q--) {\n//     Line l;\n//     cin >> l;\n//\n//     cout << fixed << setprecision(10) << Area2(ConvexCut(p, l)) / 2 << endl;\n//   }\n// }\n\n// ClosestPair\n// verified https://onlinejudge.u-aizu.ac.jp/#/courses/library/4/CGL/5/CGL_5_A\nint main() {\n  int n;\n  cin >> n;\n\n  Points p(n);\n  for (auto &i : p) cin >> i;\n  sort(p.begin(), p.end());\n  PointPoint pp = ClosestPair(p);\n  cout << fixed << setprecision(10) << Distance(pp.first, pp.second) << endl;\n  // cerr << pp.first << \" \" << pp.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\n\nint main(){\n\tint n;\n\tdouble *x,*y;\n\tdouble min = 80000;\n\t\n\tcin>>n;\n\tx = new double[n];\n\ty = new double[n];\n\tfor(int i=0;i<n;++i){\n\t\tcin>>x[i]>>y[i];\n\t}\n\t\n\tfor(int i=0;i<n;++i){\n\t\tfor(int j=i+1;j<n;++j){\n\t\t\tdouble l = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);\n\t\t\tif(l<min)min=l;\n\t\t}\n\t}\n\tcout<<fixed<<setprecision(6)<<sqrt(min)<<endl;\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  最近点対の発見について扱います\n * @date   2016/03/22\n */\n\n\n\n//****************************************\n// 必要なヘッダファイルのインクルード\n//****************************************\n\n#include \"closest_pair.hpp\"\n#include <iostream>\n#include <iomanip>\n\n\n\n//****************************************\n// 構造体の定義\n//****************************************\n\nstruct cmp_x { bool operator()(const point& pi, const point& pj) { return pi.x < pj.x; } };\nstruct cmp_y { bool operator()(const point& pi, const point& pj) { return pi.y < pj.y; } };\n\n\n\n//****************************************\n// 関数の定義\n//****************************************\n\nelem_t closest_pair(point*P, index_t n)\n{\n    if (n <= 1) {            // |P| <= 1か否かを判定する\n        return limits::inf;  // |P| <= 1ならば、再帰の基底\n    }\n\n    // |P| > 1ならば、再帰呼び出しによって、以下のように分割統治法を実行する\n\n    // 分割: 以下の条件を満たすように、点集合Pを2つの集合PLとPRに分割する垂直線lを求める\n    //      |PL|=ceil(|P|/2), |PR|=floor(|P|/2)であり、PLの点はすべてlの上または左に、\n    //      PRの点はすべてlの上または右にある\n    index_t m = n / 2;\n    elem_t lx = P[m].x;  // NOTE: このとき、PRおよびPLはxを昇順に含む(presortingによって保証済み)\n\n    // 統治: PをPLとPRに分割した後、1回はPLにおける最近点対を求めるために、\n    //      もう1回はPRにおける最近点対を求めるために、2回の再帰呼び出しを行う\n    //      PLとPRに対して求めた最近点対間距離をδLとδRとし、δ = min(δL, δR)と置く\n    elem_t delta = std::min(closest_pair(P, m),\n                            closest_pair(P + m, n - m));\n\n    // 結合: 最近点対は、上の再帰呼び出しの一方で見つかった距離がδの点対か、1点がPLに属し、\n    //      もう1点がPRに属する点対のどちらかである. アルゴリズムは、一方がPLに属し、\n    //      他方がPRに属する点対で、距離がδ未満のものが存在するか否かを判定する\n    //      距離がδ未満の点対を構成する2つの点は、それぞれ、直線lからδ単位距離以内に存在する\n    //      したがって、このような2点は直線lを中心とする、幅2δの垂直帯領域に存在する\n    //      このような点対を、存在するならば、以下の要領で発見する\n    //\n    //      1. 配列Y(P)から、2δ幅の垂直帯領域を除く領域に属するすべての点を除去してできる、\n    //         配列Y'を生成する. 配列Y'はYと同様、y座標に関してソートされている\n    //\n    //      2. 配列Y'の各点pについて、pからδ単位未満の距離にあるY'の点を発見しようと努める\n    //         このとき、Y'においてpに続く5個の点だけに候補対象を限定できる\n    //         pからこれら7個の点までの距離を計算し、Y'のすべての点対について発見できた\n    //         最近点対の距離δ'を記憶する\n    //\n    //      3. δ' < δならば、この垂直帯領域は再帰呼び出しが発見したものより近い点対を確かに含む\n    //         そこで、この点対と距離δ'を返す. そうでなければ、再帰呼び出しが発見した最近点対と距離δを返す\n\n\n    // NOTE: 配列Yと配列Yのプレソーティングを避けるため、ソート済み配列PLとPRをマージしてソート済み配列Yを構成する(Pの再構成)\n    std::inplace_merge(P, P + m, P + n, cmp_y());\n\n    polygon_t Y_;  // 直線lから距離がδ未満の点を入れていく\n    elem_t delta_ = limits::inf;\n    for (index_t i = 0; i < n; i++) {\n\n        // 直線lよりδ以上離れている(幅2δの垂直帯領域に存在しない)点は考慮から外す\n        if (std::fabs(P[i].x - lx) >= delta + limits::eps) { continue; }\n\n        index_t limit = Y_.size();  // NOTE: Y'の要素数は高々5個である\n        for (index_t j = 0; j < limit; j++) {\n\n            // Y'に入っている点を、末尾からy座標の差がδ以上になるまで確認する\n            point p = Y_[limit - j - 1];\n            if ((P[i].y - p.y) >= delta + limits::eps) { break; }\n\n            delta_ = std::min(delta_, abs(P[i] - p));\n        }\n        Y_.push_back(P[i]);\n    }\n\n    return std::min(delta, delta_);\n}\n\nelem_t closest_pair(polygon_t& P)\n{\n    std::sort(P.begin(), P.end(), cmp_x());   // xに関して、あらかじめソートしておく(presorting)\n    return closest_pair(P.data(), P.size());  // 最初の再帰呼び出し\n}\n\nint main()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n    polygon_t P(n);\n    for (int i = 0; i < n; i++) {\n        elem_t x, y;\n        cin >> x >> y;\n        P[i].x = x, P[i].y = y;\n    }\n\n    cout << closest_pair(P) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nstatic const double EPS=1e-12;\nstatic const double INF=1e24;\n\nusing Point=complex<double>;\nusing Plane=vector<Point>;\nusing Polygon=vector<Point>;\n\nbool operator<(const Point &a, const Point &b) {\n    return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n}\n\ndouble cross_prod(const Point &a, const Point &b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot_prod(const Point &a, const Point &b) {\n    return real(conj(a)*b);\n}\n\nenum {\n    ONLINE_FRONT=-2,\n    CLOCKWISE,\n    ON_SEGMENT,\n    COUNTER_CLOCKWISE,\n    ONLINE_BACK,\n};\n\nint ccwise(Point a, Point b, Point c) {\n    b -= a; c -= a;\n\n    if (cross_prod(b, c) > 0) {\n        return COUNTER_CLOCKWISE;\n    } else if (cross_prod(b, c) < 0) {\n        return CLOCKWISE;\n    } else if (dot_prod(b, c) < 0) {\n        return ONLINE_BACK;\n    } else if (norm(b) < norm(c)) {\n        return ONLINE_FRONT;\n    } else {\n        return ON_SEGMENT;\n    }\n}\n\ntemplate <class LineType>\nint ccwise(LineType l, Point p) {\n    return ccwise(l.first, l.second, p);\n}\n\nstruct Line: public pair<Point, Point> {\n    Line() {}\n    Line(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\nstruct LineSeg: public pair<Point, Point> {\n    LineSeg() {}\n    LineSeg(const Point &a, const Point &b) {\n        first = a;\n        second = b;\n    }\n};\n\npair<Point, Point> closest_pair(Polygon g) {\n    size_t V=g.size(), s=0, t=1, m=2;\n    vector<size_t> S(V);\n    sort(g.begin(), g.end(), [](const Point &a, const Point &b) {\n        return real(a)!=real(b)? real(a)<real(b) : imag(a)<imag(b);\n    });\n\n    double res=abs(g[s]-g[t]);\n    for (size_t i=2; i<V; S[m++]=i++)\n        for (size_t j=0; j<m; ++j) {\n            if (res > abs(g[S[j]]-g[i]))\n                res = abs(g[s=S[j]]-g[t=i]);\n\n            if (real(g[S[j]]) < real(g[i]-res))\n                S[j--] = S[--m];\n        }\n\n    return make_pair(g[s], g[t]);\n}\n\nint main() {\n    size_t n;\n    scanf(\"%zu\", &n);\n\n    Polygon g(n);\n    for (size_t i=0; i<n; ++i) {\n        double x, y;\n        scanf(\"%lf %lf\", &x, &y);\n        g[i] = Point(x, y);\n    }\n\n    pair<Point, Point> p=closest_pair(g);\n    printf(\"%.16f\\n\", abs(p.first-p.second));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nconst int INF = INT_MAX / 3;\n\n#define REP(i,n) for(int i=0;i<(int)n;i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b) {\n\tif (abs(a + b) < EPS * (abs(a) + abs(b))) return 0;\n\treturn a + b;\n}\n\nstruct P {\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y) : x(x), y(y) {\n\t}\n\tP operator +(P p) {\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\tP operator -(P p) {\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\tP operator *(double d) {\n\t\treturn P(d*x, d*y);\n\t}\n\tdouble dot(P p) {\n\t\treturn add(x*p.x, y*p.y);\n\t}\n\tdouble det(P p) {\n\t\treturn add(x*p.y, -y*p.x);\n\t}\n\tvoid print() {\n\t\tprintf(\"%.10lf %.10lf \\n\", x, y);\n\t\treturn;\n\t}\n};\n\ndouble dist(P p1, P p2) {\n\tdouble dx = p1.x - p2.x;\n\tdouble dy = p1.y - p2.y;\n\treturn sqrt(dx*dx + dy*dy);\n}\n\nbool x_asc(const P& left, const P& right) {\n\treturn left.x < right.x;\n}\n\nbool y_asc(const P& left, const P& right) {\n\treturn left.y < right.y;\n}\n\nvoid merger(vector<P> &pointList, int start, int m, int end) {\n\tvector<P> tmp(end - start + 1);\n\tint i = start;\n\tint j = m + 1;\n\tfor (int k = 0; k<end - start + 1; k++) {\n\n\t\tif (i == m + 1) {\n\t\t\ttmp[k] = pointList[j];\n\t\t\tj++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (j == end + 1) {\n\t\t\ttmp[k] = pointList[i];\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pointList[i].y >= pointList[j].y) {\n\t\t\ttmp[k] = pointList[j];\n\t\t\tj++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pointList[i].y < pointList[j].y) {\n\t\t\ttmp[k] = pointList[i];\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tfor (int i = start; i<end + 1; i++) {\n\t\tpointList[i] = tmp[i-start];\n\t}\n}\n\ndouble closestPoint(vector<P> &pointList, int start, int end) {\n\tint n = end - start + 1;\n\tint m = (start+end) / 2;\n\tdouble center = pointList[m].x;\n\tdouble d;\n\tif (start == end) return INF;\n\td = min(closestPoint(pointList, start, m), closestPoint(pointList, m + 1, end));\n\tmerger(pointList, start, m, end);\n\n\tvector<P> rangeList;\n\tfor (int i = start; i<end + 1; i++) {\n\t\tif (fabs(pointList[i].x - center) >= d) continue;\n\n\t\tfor (int j = rangeList.size() - 1; j>-1; j--) {\n\t\t\tdouble dd = dist(rangeList[j], pointList[i]);\n\t\t\tif (pointList[i].y - rangeList[j].y > d) break;\n\t\t\td = min(d, dd);\n\t\t}\n\t\trangeList.push_back(pointList[i]);\n\n\t}\n\treturn d;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n    \tstd::cin.tie(0);\n\tint n;\n\tcin >> n;\n\tvector<P> pointList(n);\n\tREP(i, n) {\n\t\tcin >> pointList[i].x >> pointList[i].y;\n\t}\n\n\tsort(ALL(pointList), x_asc);\n\n\tprintf(\"%.10lf \\n\", closestPoint(pointList, 0, pointList.size() - 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n// Tはintのほうがdoubleより早い\n// ！！！注意！！！！　　　　　得られるのは最近点対の距離の二乗！！！！！！！！！！！！！！\n#define INF inf\nusing T = double;\nstruct ClosestPair{\n    vector<pair<T,T>> a, b, c;\n\n    void add(T x, T y) { a.push_back({ x, y }); }\n    inline T sqr(T x) { return x * x; }\n    T dis(pair<T,T>& a, pair<T,T>& b) { return sqr(a.first - b.first) + sqr(a.second - b.second); }\n\n    T calc(int l, int r)\n    {\n        if (l == r) return INF;\n        int mid = (l + r) >> 1;\n        T d = min(calc(l, mid), calc(mid + 1, r));\n        double d0 = sqrt(double(d));\n        int cnt1 = 0, cnt2 = 0;\n        T ma = a[l].first, mi = a[r].first;\n        for (int i = l; i <= mid; i++) ma = max(a[i].first, ma);\n        for (int i = mid + 1; i <= r; i++) mi = min(a[i].first, mi);\n        for (int i = l; i <= mid; i++) if (a[i].first>mi - d0) b[++cnt1] = a[i];\n        for (int i = mid + 1; i <= r; i++) if (a[i].first<ma + d0) c[++cnt2] = a[i];\n        int k = 1;\n        for (int i = 1; i <= cnt1; i++)\n        {\n            while (k <= cnt2 && c[k].second<b[i].second - d0) k++;\n            for (int j = k; j <= cnt2 && c[j].second<b[i].second + d0; j++) d = min(d, dis(b[i], c[j]));\n        }\n        int k1 = l, k2 = mid + 1;\n        for (int i = l; i <= r; i++)\n            if (k1 <= mid && (k2>r || a[k1].second<a[k2].second)) b[i] = a[k1++]; else b[i] = a[k2++];\n        for (int i = l; i <= r; i++) a[i] = b[i];\n        return d;\n    }\n\n    T solve() {\n        int n = a.size();\n        assert(2 <= n);\n        sort(all(a));\n        b.resize(n);\n        c.resize(n);\n        return calc(0, n - 1);\n    }\n};\n//---------------------------------------------------------------------------------------------------\n\n\n\n\n\nint N;\nClosestPair cp;\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N;\n    rep(i, 0, N) {\n        double x, y; cin >> x >> y;\n        cp.add(x, y);\n    }\n    double ans = sqrt(cp.solve());\n    printf(\"%.10f\\n\", ans);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lb long double\n#define N 100010\n#define eps 1e-11\n#define INF 1e18\nusing namespace std;\nstruct Po{lb x,y;}x;\nvector<Po> no;\nint n;\nPo operator -(Po x,Po y){return (Po){x.x-y.x,x.y-y.y};}\nvoid get(Po &x){scanf(\"%Lf %Lf\",&x.x,&x.y);}\nbool c1(const Po &x,const Po &y){if (fabs(x.x-y.x)<eps)return x.y<y.y;return x.x<y.x;}\nbool c2(const Po &x,const Po &y){return x.y<y.y;}\nlb dis(Po x){return sqrtl(x.x*x.x+x.y*x.y);}\nlb que(vector<Po> x){\n\tif (x.size()==1) return INF;\n\tif (x.size()==2) return dis(x[0]-x[1]);\n\tint mid=x.size()/2;\n\tvector<Po> s1,s2;\n\ts1.clear();s2.clear();\n\tfor (int i=0;i<x.size();i++)if (i<mid) s1.push_back(x[i]);else s2.push_back(x[i]);\n\tlb an=min(que(s1),que(s2));\n\treverse(s1.begin(),s1.end());\n\twhile (s1.size()&&x[mid].x-s1[s1.size()-1].x>an-eps)s1.pop_back();\n\twhile (s2.size()&&s2[s2.size()-1].x-x[mid-1].x>an-eps)s2.pop_back();\n\tsort(s1.begin(),s1.end(),c2);\n\tsort(s2.begin(),s2.end(),c2);\n\tint l=0,r=-1;\n\tfor (int i=0;i<s1.size();i++){\n\t\twhile (r+1<s2.size()&&fabs(s1[i].y-s2[r+1].y)<an+eps) r++;\n\t\twhile (l+1<=s2.size()&&fabs(s1[i].y-s2[l].y)>an+eps)l++;\n\t\tfor (int j=l;j<=r;j++) an=min(an,dis(s2[j]-s1[i]));\n\t}\n\treturn an;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\twhile(n--){get(x);no.push_back(x);}\n\tsort(no.begin(),no.end(),c1);\n\tprintf(\"%.10Lf\",que(no));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<double,double> P;\n\nbool pariCompare (const P& FElof, const P& SElof) {\n    if (FElof.first == SElof.first) return FElof.second < SElof.second;\n    return FElof.first < SElof.first;\n}\n\nint main ()\n{\n    int n;\n    cin >> n;\n    vector<P> p(n);\n    for (int i = 0; i < n; i++) {\n\tcin >> p[i].first >> p[i].second;\n    }\n\n    sort(p.begin(), p.end(), pariCompare);\n\n    double dis = 100000.0;\n    for (int i = 0; i < n-1; i++) {\n\tfor (int j = i + 1; j < n && p[i].first - p[j].first < ans; j++) {\n            double tmp = pow(p[i].first - p[j].first, 2.0) + pow(p[i].second - p[j].second, 2.0);\n\t    dis = min(dis, tmp);\n\t}\n    }\n\n    printf(\"%.7f\\n\", sqrt(dis));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\nusing namespace std;\nstruct Point { long double px, py; };\nlong double norm(Point a) { return a.px*a.px + a.py*a.py; }\nlong double Abs(Point a, Point b) { Point C; C.px = a.px - b.px; C.py = a.py - b.py; return sqrt(norm(C)); }\nint N; Point P[1000000];\nint main() {\n\tcin >> N; long double res = 10101010101010101010101010101010101010101.0101;\n\tfor (int i = 0; i < N; i++) { cin >> P[i].px >> P[i].py; }\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tres = min(res, Abs(P[i], P[j]));\n\t\t}\n\t}\n\tcout << fixed << setprecision(5141919) << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(__typeof((o).begin()) it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T> >& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){EACH(a,ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;EACH(p,m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\ntemplate<> long double INF<long double>(){return 1e16;};\n\ntemplate<typename T> T pmod(T v,T M){return (v%M+M)%M;}\n\nnamespace _double_tmpl{\n    typedef long double D;const D EPS = 1e-8;\n    \n    static constexpr D Ae=0;\n    D A(D a,D b){return a+b;}D Ainv(D a){return -a;}\n    D S(D a,D b){return A(a,Ainv(b));}\n    \n    static constexpr D Me=1;\n    D M(D a,D b){return a*b;}D Minv(D a){return 1.0/a;};\n\n    int sig(D a,D b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n    bool eq(D a,D b){ return sig(abs(a-b))==0;}\n\n}\nusing namespace _double_tmpl;\n\n\nnamespace Ps{\n    // using namespace _double_tmpl;\n    typedef complex<D> P,Vec;\n\n#define X real()\n#define Y imag()\n    istream& operator >> (istream& is,complex<D>& p){\n        D x,y;is >> x >> y;p=P(x,y);return is;\n    }\n\n    bool eq(P a,P b){return eq(a.X,b.X) and eq(a.Y,b.Y);}\n    // a×b\n    D cross(const Vec& a,const Vec& b){return imag(conj(a)*b);}\n    // a・b\n    D dot(const Vec&a,const Vec& b) {return real(conj(a)*b);}\n\n    int ccw(const P& a,P b,P c){\n        b -= a; c -= a;\n        if (cross(b,c) > EPS)   return +1;       // counter clockwise\n        if (cross(b,c) < -EPS)   return -1;       // clockwise\n        if (dot(b,c) < 0)     return +2;       // c--a--b on line\n        if (norm(b) < norm(c)) return -2;       // a--b--c on line\n        return 0;\n    }\n\n    D closestPair(vector<P>& ps,int l,int r){\n        if(r-l<2)return INF<D>();\n        D res=INF<D>();\n        res=min(res,closestPair(ps,l,(l+r)/2));\n        res=min(res,closestPair(ps,(l+r)/2,r));\n        vector<P> lps,rps;\n        FOR(i,l,(l+r)/2)if(abs(ps[i].X - ps[(l+r)/2].X)<res && abs(ps[i].Y - ps[(l+r)/2].Y)<2*res)lps.push_back(ps[i]);\n        FOR(i,(l+r)/2,r)if(abs(ps[i].X - ps[(l+r)/2].X)<res && abs(ps[i].Y - ps[(l+r)/2].Y)<2*res)rps.push_back(ps[i]);\n\n        REP(i,lps.size())REP(j,rps.size())res=min(res,abs(lps[i]-rps[j]));\n        return res;\n    }\n}\nusing namespace Ps;\n\nnamespace std{\n    bool operator < (const P& a,const P& b){\n            return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n    bool operator == (const P& a,const P& b){\n            return eq(a,b);\n    }\n};\n\nstringstream ss;\nclass Main{\n    public:\n    void run(){\n        int n;cin >> n;\n        vector<P> ps;\n        REP(i,n) {\n            P p;cin >> p;\n            ps.push_back(p);\n        }\n        sort(ALL(ps));\n        cout << closestPair(ps,0,n)<<endl;\n    }\n};\n\nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct node{\n  int dim;\n  vector<double>v;\n};\n\ndouble d(node a,node b){\n  assert(a.dim==b.dim);\n  double res=0;\n  for(int i=0;i<a.dim;i++)res+=(a.v[i]-b.v[i])*(a.v[i]-b.v[i]);\n  return sqrt(res);\n}\n\ndouble d(node p,vector<node> S){\n  double res=1000000000;\n  for(int i=0;i<S.size();i++){\n    if(p.v!=S[i].v)res=min(res,d(p,S[i]));\n  }\n  return res;\n}\n\nstring toStr(int num){\n  string res = \"\";\n  while(num){\n    res += (num%10)+'0';\n    num /= 10;\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\ndouble closestPair(vector<node> S){\n  srand((unsigned int)time(NULL));\n\n  vector<node>res;\n\n  while(S.size()>1){\n    res=S;\n    node p=S[rand()%S.size()];\n\n    double dist=d(p,S)/(4*p.dim);\n\n    map<string,vector<int> >grid;\n    for(int i=0;i<S.size();i++){\n      string index=\"\";\n      for(int j=0;j<p.dim;j++)index+=toStr((int)(S[i].v[j]/dist));\n      grid[index].push_back(i);\n    }\n\n    vector<node>nextS;\n    map<string,vector<int> >::iterator it = grid.begin();\n    for(;it!=grid.end();it++){\n      if((*it).second.size()>1){\n\tfor(int j=0;j<(*it).second.size();j++)nextS.push_back(S[j]);\n      }\n    }\n    \n    S=nextS;    \n  }\n\n  double ans=100000000;\n  for(int i=0;i<res.size();i++){\n    for(int j=i+1;j<res.size();j++){\n      ans=min(ans,d(res[i],res[j]));\n    }\n  }\n  \n  return ans;\n}\n\nint main(void){\n\n  int n;\n  cin >> n;\n\n  vector<node>p(n);\n  double x,y;\n  for(int i=0;i<n;i++){\n    p[i].dim=2;\n    cin >> x >> y;\n    p[i].v.push_back(x);\n    p[i].v.push_back(y);\n  }\n\n  printf(\"%.8f\",closestPair(p));\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n\tint N;\n\tcin >> N;\n\tint i, j;\n\tdouble pt[100000][2], dst[100000], m, x, y, tmp;\n\tfor (i = 0; i < N; i++) {\n\t\tcin >> pt[i][0] >> pt[i][1];\n\t\tm = 100000000;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tx = pt[i][0] - pt[j][0];\n\t\t\ty = pt[i][1] - pt[j][1];\n\t\t\ttmp = x * x + y * y;\n\t\t\tif (tmp < m) {\n\t\t\t\tm = tmp;\n\t\t\t}\n\t\t}\n\t\tdst[i] = m;\n\t}\n\tm = 100000000;\n\tfor (i = 0; i < N; i++) {\n\t\tif (dst[i] < m) {\n\t\t\tm = dst[i];\n\t\t}\n\t}\n\tprintf(\"%f\\n\", sqrt(m));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PB          push_back\n#define PF          push_front\n#define MP          make_pair\n#define FI          first\n#define SE          second\n#define SIZE( A )   int( ( A ).size( ) )\n#define ALL( A )    ( A ).begin( ), ( A ).end( )\n#define ALLR( A )   ( A ).rbegin( ), ( A ).rend( )\n\nusing namespace std;\n\ntypedef long long           ll;\ntypedef unsigned long long  ull;\ntypedef long double         lf;\ntypedef pair< int, int >    pii;\ntypedef pair< ll, ll >      pll;\ntypedef vector< bool >      vb;\ntypedef vector< lf >        vd;\ntypedef vector< ll >        vll;\ntypedef vector< int >       vi;\ntypedef vector< pii >       vpii;\n\nconst int MAXN = int( 1e5 )+10;\nconst int MOD  = int( 360 );\nconst int oo   = INT_MAX;\nconst lf EPS = 1e-9;\n\nstruct pt {\n  lf x, y;\n  pt( ) { }\n  pt( lf x, lf y ) : x( x ), y ( y ) { }\n};\n\ninline lf x( pt P ) { return P.x; }\ninline lf y( pt P ) { return P.y; }\n\nistream& operator >> ( istream& in, pt& p ) {\n  lf x,y; in >> x >> y;\n  p = pt(x,y); return in;\n}\n\nostream& operator << ( ostream& out, const pt& p ) {\n  out << double(p.x) << \" \" << double(p.y);\n  return out;\n}\n\npt operator + ( const pt& A, const pt& B ) {\n  return pt( x(A)+x(B), y(A)+y(B) );\n}\n\npt operator - ( const pt& A, const pt& B ) {\n  return pt( x(A)-x(B), y(A)-y(B) );\n}\n\npt operator * ( const lf& B, const pt& A ) {\n  return pt( x(A)*B, y(A)*B );\n}\n\npt operator * ( const pt& A, const lf& B ) {\n  return pt( x(A)*B, y(A)*B  );\n}\n\ninline lf norm( pt A ) {\n  return x(A)*x(A) + y(A)*y(A);\n}\n\ninline lf abs( pt A ) {\n  return sqrt( norm(A) );\n}\n\ninline lf dist ( pt A, pt B ) { return norm( B - A ); }\n\nint n;\nlf d;\npt Px[ MAXN ];\nvector< pt> Py;\n\nbool cmpX( const pt &A, const pt &B ) {\n  return B.x > A.x + EPS;\n}\n\nbool cmpY( const pt &A, const pt &B ) {\n  return B.y > A.y + EPS;\n}\n\nvoid merge( pt *P, int n, lf &d ) {\n  for( int i = 0; i < n; ++i ) {\n    for( int j = i+1; j < n && (P[j].y - P[i].y)*(P[j].y - P[i].y) + EPS < d ; ++j ) {\n      d = min( d, dist( P[i], P[j]) );\n    }\n  }\n}\n\nvoid solve( pt *Px, vector<pt> &Py, int n, lf &d ) {\n  if( n <= 3 ) {\n    for( int i = 0; i < n; ++i ) {\n      for( int j = i+1; j < n; ++j ) {\n        d = min( d, dist(Px[i], Px[j]) );\n      }\n    }\n    return;\n  }\n  int mi = n/2;\n  vector<pt> Pl, Pr;\n  for( int i = 0; i < n; ++i ) {\n    if( Py[i].x <= Px[mi].x ) {\n      Pl.PB( Py[ i ] );\n    }\n    else {\n      Pr.PB( Py[ i ] );\n    }\n  }\n\n  solve( Px, Pl, SIZE( Pl ), d );\n  solve( Px+SIZE( Pl ), Pr, SIZE( Pr ), d );\n\n  pt extra[ n ];\n  int k = 0;\n  for( auto &p : Py ) {\n    if( abs( p.x - Px[mi].x ) + EPS < d ) {\n      extra[ k++ ] = p;\n    }\n  }\n\n  merge( extra, n, d );\n}\n\nint main( ) {\n\n  #ifdef LOCAL\n    freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n  #else\n    //freopen( \"input\", \"r\", stdin );\n    //freopen( \"output\", \"w\", stdout );\n    ios_base::sync_with_stdio( 0 );\n    cin.tie( 0 );\n  #endif\n  cout << fixed << setprecision( 8 );\n  cin >> n;\n  for( int i = 0; i < n; ++i ) {\n    cin >> Px[i];\n    Py.PB( Px[ i ] );\n  }\n  sort( Px, Px+n, cmpX );\n  sort( Py.begin(), Py.end(), cmpY );\n  d = oo;\n  solve( Px, Py, n, d );\n  cout << double(sqrt(d)) << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>// c\n#include <iostream>// io\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <vector>// container\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <algorithm>// other\n#include <complex>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\ntypedef int32_t i32;typedef int64_t i64;typedef i64 ll;typedef uint32_t uint;typedef uint64_t ull;\n\n#define ALL(c) (begin(c)),(end(c))\n#define REP(i,n) FOR(i,0,n)\n#define REPr(i,n) FORr(i,0,n)\n#define FOR(i,l,r) for(int i=(int)(l);i<(int)(r);++i)\n#define FORr(i,l,r) for(int i=(int)(r)-1;i>=(int)(l);--i)\n#define EACH(it,o) for(__typeof((o).begin()) it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n\nclass range {\nprivate:\n    struct Iter{\n        int v;\n        int operator*(){return v;}\n        bool operator!=(Iter& itr) {return v < itr.v;}\n        void operator++() {++v;}\n    };\n    Iter i, n;\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    Iter& begin() {return i;}\n    Iter& end() {return n;}\n};\n\n//output\ntemplate<typename T> ostream& operator << (ostream& os, const vector<T>& as){REP(i,as.size()){if(i!=0)os<<\" \"; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const vector<vector<T> >& as){REP(i,as.size()){if(i!=0)os<<endl; os<<as[i];}return os;}\ntemplate<typename T> ostream& operator << (ostream& os, const set<T>& ss){EACH(a,ss){if(a!=ss.begin())os<<\" \"; os<<a;}return os;}\ntemplate<typename T1,typename T2> ostream& operator << (ostream& os, const pair<T1,T2>& p){os<<p.first<<\" \"<<p.second;return os;}\ntemplate<typename K,typename V> ostream& operator << (ostream& os, const map<K,V>& m){bool isF=true;EACH(p,m){if(!isF)os<<endl;os<<p;isF=false;}return os;}\n\n//input\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n) //I64d\n#define nextDouble(n) scanf(\"%lf\",&n) \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\n// values\ntemplate<class T> T INF(){assert(false);};\ntemplate<> int INF<int>(){return 1<<28;};\ntemplate<> ll INF<ll>(){return 1LL<<58;};\ntemplate<> double INF<double>(){return 1e16;};\ntemplate<> long double INF<long double>(){return 1e16;};\n\ntemplate<typename T> T pmod(T v,T M){return (v%M+M)%M;}\n\nnamespace _double_tmpl{\n    typedef long double D;const D EPS = 1e-8;\n    \n    static constexpr D Ae=0;\n    D A(D a,D b){return a+b;}D Ainv(D a){return -a;}\n    D S(D a,D b){return A(a,Ainv(b));}\n    \n    static constexpr D Me=1;\n    D M(D a,D b){return a*b;}D Minv(D a){return 1.0/a;};\n\n    int sig(D a,D b=0){return a<b-EPS?-1:a>b+EPS?1:0;}\n    bool eq(D a,D b){ return sig(abs(a-b))==0;}\n\n}\nusing namespace _double_tmpl;\n\n\nnamespace Ps{\n    // using namespace _double_tmpl;\n    typedef complex<D> P,Vec;\n\n#define X real()\n#define Y imag()\n    istream& operator >> (istream& is,complex<D>& p){\n        D x,y;is >> x >> y;p=P(x,y);return is;\n    }\n\n    bool eq(P a,P b){return eq(a.X,b.X) and eq(a.Y,b.Y);}\n    // a×b\n    D cross(const Vec& a,const Vec& b){return imag(conj(a)*b);}\n    // a・b\n    D dot(const Vec&a,const Vec& b) {return real(conj(a)*b);}\n\n    int ccw(const P& a,P b,P c){\n        b -= a; c -= a;\n        if (cross(b,c) > EPS)   return +1;       // counter clockwise\n        if (cross(b,c) < -EPS)   return -1;       // clockwise\n        if (dot(b,c) < 0)     return +2;       // c--a--b on line\n        if (norm(b) < norm(c)) return -2;       // a--b--c on line\n        return 0;\n    }\n\n    bool compX (const P& a,const P& b);bool compY (const P& a,const P& b);\n    D closestPair(vector<P>& ps,int l,int r){\n        if(r-l<2)return INF<D>();\n        D res=INF<D>();\n        res=min(res,closestPair(ps,l,(l+r)/2));\n        res=min(res,closestPair(ps,(l+r)/2,r));\n        \n        vector<P> lps,rps;\n        D lym=INF<D>(),lyM=-INF<D>(),rym=INF<D>(),ryM=-INF<D>();\n        FOR(i,l,(l+r)/2)if(abs(ps[i].X - ps[(l+r)/2].X)<res)lps.push_back(ps[i]),lym=min(lym,lps[i].Y),lyM=max(lyM,lps[i].Y);\n        FOR(i,(l+r)/2,r)if(abs(ps[i].X - ps[(l+r)/2].X)<res)rps.push_back(ps[i]),rym=min(rym,rps[i].Y),ryM=max(ryM,rps[i].Y);\n        vector<P> lps2,rps2;\n        REP(i,lps.size())if(rym<=lps[i].Y && lps[i].Y<=ryM)lps2.push_back(lps[i]);\n        REP(i,rps.size())if(lym<=rps[i].Y && rps[i].Y<=lyM)rps2.push_back(rps[i]);\n\n        REP(i,lps.size())REP(j,rps.size())res=min(res,abs(lps[i]-rps[j]));\n        return res;\n    }\n}\nusing namespace Ps;\n\nnamespace std{\n\n    bool compX (const P& a,const P& b){return a.X != b.X ? a.X < b.X : a.Y < b.Y;}\n    bool compY (const P& a,const P& b){return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;}\n    bool operator < (const P& a,const P& b){return compX(a,b);}\n    bool operator == (const P& a,const P& b){return eq(a,b);}\n};\n\nstringstream ss;\nclass Main{\n    public:\n    void run(){\n        int n;cin >> n;\n        vector<P> ps;\n        REP(i,n) {\n            P p;cin >> p;\n            ps.push_back(p);\n        }\n        sort(ALL(ps));\n        cout << closestPair(ps,0,n)<<endl;\n    }\n};\n\nint main(){\n    cout <<fixed<<setprecision(20);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Main().run();\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#include<math.h>\n\nstruct Point {\n  double x;\n  double y;\n};\nstruct Point *p;\nvoid qsort1(int left, int right);\nvoid msort(int left, int right);\ndouble closest_pair(int left, int right);\nint main(void)\n{\n  int i, n;\n  scanf(\"%d\", &n);\n  p = (struct Point*)malloc(sizeof(struct Point) * n);\n  for (i = 0; i < n; i++) scanf(\"%lf %lf\", &p[i].x, &p[i].y);\n  qsort1(0, n - 1);\n  printf(\"%.6f\\n\", closest_pair(0, n - 1));\n  free(p);\n}\nvoid qsort1(int left, int right)\n{\n  int i, j;\n  struct Point pivot;\n  if (left >= right) return;\n  i = left;\n  j = right;\n  pivot = p[(i + j) / 2];\n  do {\n    while (p[i].x < pivot.x) i++;\n    while (p[j].x > pivot.x) j--;\n    if (i <= j) {\n      struct Point temp = p[i];\n      p[i] = p[j];\n      p[j] = temp;\n      i++;\n      j--;\n    }\n  } while(i <= j);\n  qsort1(left, j);\n  qsort1(i, right);\n}\nvoid msort(int left, int right)\n{\n  int middle, num, base, i, j;\n  struct Point *work;\n  middle = (left + right) / 2;\n  work = (struct Point*)malloc(sizeof(struct Point) * (middle - left + 1));\n  for (num = 0, i = left; i <= middle; i++) work[num++] = p[i];\n  j = 0;\n  base = left;\n  while (i <= right && j < num) {\n    if (p[i].y < work[j].y) p[base++] = p[i++];\n    else p[base++] = work[j++];\n  }\n  while (j < num) p[base++] = work[j++];\n  free(work);\n}\ndouble closest_pair(int left , int right)\n{\n  int middle, num, i, j;\n  double x, d, dtemp;\n  struct Point *work;\n  if (left >= right) return INT_MAX;\n  middle = (left + right) / 2;\n  x = p[middle].x;\n  d = closest_pair(left, middle);\n  dtemp = closest_pair(middle + 1, right);\n  msort(left, right);\n  if (d > dtemp) d = dtemp;\n  work = (struct Point*)malloc(sizeof(struct Point) * (right - left + 1));\n  num = 0;\n  for (i = left; i <= right; i++) {\n    if (fabs(p[i].x - x) >= d) continue;\n    for (j = 0; j < num; j++) {\n      double dx = p[i].x - work[num - 1 - j].x, dy = p[i].y - work[num - 1 - j].y;\n      if (dy >= d) break;\n      dtemp = sqrt(dx * dx + dy * dy);\n      if (d > dtemp) d = dtemp;\n    }\n    work[num++] = p[i];\n  }\n  free(work);\n  return d;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdint.h>\n#include <time.h>\n#include <limits.h>\n#include <string.h>\n\nint n;\nfloat *x,*y;\nfloat getdist(int i,int j){\n  float dx,dy;\n  dx = x[i]-x[j];\n  dy = y[i]-y[j];\n  return sqrtf(dx*dx+dy*dy);\n}\n\n/* xorshift */\n/* https://ja.wikipedia.org/wiki/Xorshift */\nuint32_t xor128(){ \n  static uint32_t x = 123456789;\n  static uint32_t y = 362436069;\n  static uint32_t z = 521288629;\n  static uint32_t w = 88675123; \n  uint32_t t;\n \n  t = x ^ (x << 11);\n  x = y; y = z; z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)); \n}\n\n/* resizable int array */\ntypedef struct vector {\n  int limit,size;\n  int *a;\n} vector;\nvector *new_vector(){\n  vector *ret;\n  ret = (vector*)malloc(sizeof(vector));\n  ret->limit = 4;\n  ret->size = 0;\n  ret->a = (int*)malloc(ret->limit * sizeof(int));\n  return ret;\n}\nvector *copy_vector(vector *v){\n  int i;\n  vector *ret;\n  ret = (vector*)malloc(sizeof(vector));\n  ret->limit = v->limit;\n  ret->size = v->size;\n  ret->a = (int*)malloc(ret->limit * sizeof(int));\n  for(i=0;i<v->size;++i){\n    ret->a[i] = v->a[i];\n  }\n  return ret;\n}\nvoid v_push_back(vector *v,int val){\n  if(v->size >= v->limit){\n    v->limit <<= 1;\n    v->a = (int*)realloc(v->a,v->limit * sizeof(int));\n  }\n  v->a[v->size++] = val;\n}\nvoid free_vector(vector *v){\n  if(!v)return;\n  free(v->a);\n  free(v);\n}\n/* end of resizable int array */\n\n/* resizable int array array */\ntypedef struct vector_vector {\n  int limit,size;\n  vector **a;\n} vector_vector;\nvector_vector *new_vector_vector(){\n  vector_vector *ret;\n  ret = (vector_vector*)malloc(sizeof(vector_vector));\n  ret->limit = 4;\n  ret->size = 0;\n  ret->a = (vector**)malloc(ret->limit * sizeof(vector*));\n  return ret;\n}\nvoid vv_push_back(vector_vector *v,vector *val){\n  if(v->size >= v->limit){\n    v->limit <<= 1;\n    v->a = (vector**)realloc(v->a,v->limit * sizeof(vector*));\n  }\n  v->a[v->size++] = val;\n}\nvoid free_vector_vector(vector_vector *v){\n  int i;\n  if(!v)return;\n  for(i=0;i<v->size;++i){\n    free_vector(v->a[i]);\n  }\n  free(v->a);\n  free(v);\n}\n/* end of resizable int array array */\n\n/* hash map for pair<int,int> */\n/* hash max value = 2^16 = 65535 */\n#define HASH_MAX 65536\nint hash_int(int x){\n  uint32_t y;\n  y = *(uint32_t*)(&x);\n  y = y ^ (y << 13);\n  y = y ^ (y >> 17);\n  return (int)(y&(HASH_MAX-1));\n}\nint hash_int2(int x){\n  uint32_t y;\n  y = *(uint32_t*)(&x);\n  y = y ^ (y << 13);\n  y = y ^ (y >> 17);\n  return (int)(y>>16);\n}\nint hash_pii(int a,int b){\n  return hash_int(a)^hash_int2(b);\n}\ntypedef struct HashMap_pii {\n  vector_vector **bucket;\n  vector **bucket_x, **bucket_y;\n} HashMap_pii;\nHashMap_pii *new_HashMap_pii(){\n  int i;\n  HashMap_pii *ret;\n  ret = (HashMap_pii*)malloc(sizeof(HashMap_pii));\n  ret->bucket = (vector_vector**)calloc(HASH_MAX,sizeof(vector_vector*));\n  ret->bucket_x = (vector**)calloc(HASH_MAX,sizeof(vector*));\n  ret->bucket_y = (vector**)calloc(HASH_MAX,sizeof(vector*));\n  for(i=0;i<HASH_MAX;++i){\n    ret->bucket[i] = new_vector_vector();\n    ret->bucket_x[i] = new_vector();\n    ret->bucket_y[i] = new_vector();\n  }\n  return ret;\n}\nvector *hmpii_get(HashMap_pii *map,int x,int y){\n  int i;\n  int hsh;\n  hsh = hash_pii(x,y);\n  for(i=0;i<map->bucket[hsh]->size;++i){\n    if(map->bucket_x[hsh]->a[i] == x && map->bucket_y[hsh]->a[i] == y){\n      return map->bucket[hsh]->a[i];\n    }\n  }\n  return NULL;\n}\nvoid hmpii_add(HashMap_pii *map,int x,int y,int val){\n  int i;\n  int id;\n  int hsh;\n  vector *set;\n  hsh = hash_pii(x,y);\n  set = hmpii_get(map,x,y);\n  if(!set){\n    set = new_vector();\n    vv_push_back(map->bucket[hsh],set);\n    v_push_back(map->bucket_x[hsh],x);\n    v_push_back(map->bucket_y[hsh],y);\n  }\n  v_push_back(set,val);\n}\nvoid free_HashMap_pii(HashMap_pii *map){\n  int i;\n  if(!map)return;\n  for(i=0;i<HASH_MAX;++i){\n    free_vector_vector(map->bucket[i]);\n    free_vector(map->bucket_x[i]);\n    free_vector(map->bucket_y[i]);\n  }\n  free(map->bucket);\n  free(map->bucket_x);\n  free(map->bucket_y);\n  free(map);\n}\n\n/* nearest pair from two group in two dimensional map */\nvoid find_nearest_pair_from_two_group(vector *a,int *ret_a,int *ret_b){\n  int i,j,k;\n  vector *a_bef, *a_nxt;\n  float dist;\n  a_bef = copy_vector(a);\n  a_nxt = NULL;\n  dist = 1e25f;\n  while(a_bef->size > 0){\n    int ai;\n    float delta;\n    HashMap_pii *amap;\n    ai = a_bef->a[xor128()%a_bef->size];\n    dist = 1e25f;\n    for(i=0;i<a_bef->size;++i){\n      if(ai==a_bef->a[i])continue;\n      if(getdist(ai,a_bef->a[i]) < dist)\n        dist = getdist(ai,a_bef->a[i]);\n    }\n    delta = dist/8;\n    /* grid */\n    amap = new_HashMap_pii();\n    for(i=0;i<a_bef->size;++i){\n      int xx,yy,id;\n      id = a_bef->a[i];\n      xx = (int)(x[id]/delta);\n      yy = (int)(y[id]/delta);\n      hmpii_add(amap,xx,yy,id);\n    }\n    /* search */\n    a_nxt = new_vector();\n    for(i=0;i<a_bef->size;++i){\n      int xx,yy,id;\n      int flag;\n      id = a_bef->a[i];\n      xx = (int)(x[id]/delta);\n      yy = (int)(y[id]/delta);\n      flag = 0;\n      for(j=-1;j<=1&&!flag;++j)for(k=-1;k<=1&&!flag;++k){\n        vector *vec = hmpii_get(amap,xx+j,yy+k);\n        if(vec!=NULL && vec->size!=0){\n          int l;\n          for(l=0;l<vec->size;++l){\n            if(vec->a[l]!=id){\n              flag = 1;\n              break;\n            }\n          }\n        }\n      }\n      if(flag)\n        v_push_back(a_nxt,id);\n    }\n    /* step */\n    free_vector(a_bef);\n    free_HashMap_pii(amap);\n    a_bef = a_nxt;\n    a_nxt = NULL;\n  }\n  free_vector(a_bef);\n  /* create grid with dist */\n  {\n    float mindist;\n    int pa,pb;\n    HashMap_pii *map;\n    mindist = 1e25f;\n    pa = pb = -1;\n    map = new_HashMap_pii();\n    for(i=0;i<a->size;++i){\n      int xx,yy,id;\n      vector *vec;\n      id = a->a[i];\n      xx = (int)(x[id]/dist);\n      yy = (int)(y[id]/dist);\n      for(j=-1;j<=1;++j)for(k=-1;k<=1;++k){\n        int l;\n        vec = hmpii_get(map,xx+j,yy+k);\n        if(vec==NULL)continue;\n        for(l=0;l<vec->size;++l){\n          int to;\n          to = vec->a[l];\n          if(getdist(to,id)<mindist){\n            mindist = getdist(to,id);\n            pa = to;\n            pb = id;\n          }\n        }\n      }\n      hmpii_add(map,xx,yy,id);\n    }\n    *ret_a = pa;\n    *ret_b = pb;\n  }\n}\n\nint main(){\n  int i;\n  int ansa,ansb;\n  vector *a;\n  a = new_vector();\n  scanf(\"%d\",&n);\n  x = (float*)calloc(n,sizeof(float));\n  y = (float*)calloc(n,sizeof(float));\n  for(i=0;i<n;++i){\n    scanf(\"%f%f\",x+i,y+i);\n    v_push_back(a,i);\n  }\n  find_nearest_pair_from_two_group(a,&ansa,&ansb);\n  printf(\"%.10f\\n\",getdist(ansa,ansb));\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define min(p,q)((p)<(q)?(p):(q))\n#define zahyoutype double\ntypedef struct Point{zahyoutype x,y;}P;\nint jisho(const void*p,const void*q){\n\tP *pp=(P*)p,*qq=(P*)q;\n\tif(pp->y<qq->y)return -1;\n\tif(pp->y>qq->y)return  1;\n\treturn pp->x>qq->x;\n}\ndouble distPP(P p,P q){return hypot(p.x-q.x,p.y-q.y);}\nvoid readpoint(P*p){zahyoutype x=1;scanf(x/2?\"%lf%lf\":\"%ld%ld\",&p->x,&p->y);}\nvoid printpoint(P p){zahyoutype x=1;printf(x/2?\"%.9lf %.9lf\\n\":\"%ld %ld\\n\",p.x,p.y);}\n\nP p[100010];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tdouble r=rand();\n\tfor(int i=0;i<n;i++){\n\t\tP t;\n\t\treadpoint(&t);\n\t\tp[i].x=t.x*cos(r)-t.y*sin(r);\n\t\tp[i].y=t.x*sin(r)+t.y*cos(r);\n\t}\n\tqsort(p,n,sizeof(P),jisho);\n\tdouble ans=1e10;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n&&p[j].y-p[i].y<ans;j++){\n\t\t\tans=min(ans,distPP(p[i],p[j]));\n\t\t}\n\t}\n\tprintf(\"%.9f\\n\",ans);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <string.h>\n\n#define INF 9999999\n#define BASE 2\n\nint N;\n\ntypedef struct {//頂点情報格納用\n    double x, y;\n    int v;//頂点番号を持っておくと、Divide and Conquerで散り散りになっても値を追える\n} Vertex;\n\nVertex V_INF = {INF, INF, INF};\n\ntypedef struct {//最近点対（距離と頂点番号）格納用\n    int i, j;\n    double length;\n} Result;\n\n\nvoid init(Vertex *);\nResult n2_search(Vertex *, int);//力任せな解法\ndouble Get_Distance(Vertex, Vertex);//距離を求める（力任せ用）\nResult DC(Vertex *, int, int);//分割統治法による解法\nvoid mergesort(Vertex *, Vertex *);\n\n\nint main() {\n    scanf(\"%d\", &N);\n\n    Vertex *V;\n    Result res;\n\n    V = (Vertex *) malloc(sizeof(Vertex) * N);\n\n    int i;\n    for (i = 0 ;i < N; ++i) {\n      scanf(\"%lf%lf\", &V[i].x, &V[i].y);\n    }\n\n    // x座標でソート\n    mergesort(V, V + N);\n\n    res = DC(V, 0, N);//Divide and Conquer\n    if (res.j < res.i) {\n        int tmp = res.i;\n        res.i = res.j;\n        res.j = tmp;\n    }\n    printf(\"%.7f\\n\", res.length);\n\n    free(V);\n\n    return 0;\n}\n\n\nvoid init(Vertex *V) {//乱数でデータ生成\n    int i;\n\n    srand(time(NULL));\n    for (i = 0; i < N; i++) {\n        V[i].x = 100 * (double) rand() / RAND_MAX;\n        V[i].y = 100 * (double) rand() / RAND_MAX;\n        V[i].v = i;\n        printf(\"%d) %f, %f \\n\", V[i].v, V[i].x, V[i].y);\n    }\n\n    printf(\"****************************************\\n\");\n}\n\n\nResult n2_search(Vertex *V, int n) {//力任せ\n    int i, j;\n    double min_dist = INF, dist;\n    Result res;\n\n    for (i = 0; i < n - 1; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (i == j)continue;\n            dist = Get_Distance(V[i], V[j]);\n            if (dist < min_dist) {\n                min_dist = dist;\n                res.i = V[i].v;\n                res.j = V[j].v;\n            }\n        }\n    }\n\n    res.length = min_dist;\n    return res;\n}\n\n\ndouble Get_Distance(Vertex V1, Vertex V2) {\n    double dist;\n\n    dist = sqrt((V2.x - V1.x) * (V2.x - V1.x) + (V2.y - V1.y) * (V2.y - V1.y));\n\n    return dist;\n}\n\nvoid merge(Vertex *first, Vertex *mid, Vertex *last) {\n    const int N1 = (int) (mid - first);\n    const int N2 = (int) (last - mid);\n    Vertex *left = malloc(sizeof(Vertex) * (N1 + 1));\n    Vertex *right = malloc(sizeof(Vertex) * (N2 + 1));\n    memcpy(left, first, sizeof(Vertex) * (N1 + 1));\n    memcpy(right, mid, sizeof(Vertex) * (N2 + 1));\n    left[N1] = right[N2] = V_INF;\n    Vertex *it;\n    int i, j;\n    for (it = first, i = 0, j = 0; it != last; ++it) {\n        *it = left[i].x <= right[j].x ? left[i++] : right[j++];\n    }\n    free(left);\n    free(right);\n}\n\nvoid mergesort(Vertex *first, Vertex *last) {\n    const int n = (int) (last - first);\n    if (n < 2) return;\n    Vertex *mid = first + n / 2;\n    mergesort(first, mid);\n    mergesort(mid, last);\n    merge(first, mid, last);\n}\n\nvoid merge_y(Vertex *first, Vertex *mid, Vertex *last) {\n    const int N1 = (int) (mid - first);\n    const int N2 = (int) (last - mid);\n    Vertex *left = malloc(sizeof(Vertex) * (N1 + 1));\n    Vertex *right = malloc(sizeof(Vertex) * (N2 + 1));\n    memcpy(left, first, sizeof(Vertex) * (N1 + 1));\n    memcpy(right, mid, sizeof(Vertex) * (N2 + 1));\n    left[N1] = right[N2] = V_INF;\n    Vertex *it;\n    int i, j;\n    for (it = first, i = 0, j = 0; it != last; ++it) {\n        *it = left[i].y <= right[j].y ? left[i++] : right[j++];\n    }\n    free(left);\n    free(right);\n}\n\nResult DC(Vertex *v, int first, int last) {\n    const int n = last - first;\n    int mid = first + n / 2;\n    double x = v[mid].x;\n\n    // BASE以下のサイズで全探索\n    if (n <= BASE) {\n        Result res = n2_search(v + first, n);\n        // y座標でソート\n        merge_y(v + first, v + mid, v + last);\n        return res;\n    }\n\n    Result d1 = DC(v, first, mid);\n    Result d2 = DC(v, mid, last);\n    Result d = d1.length <= d2.length ? d1 : d2;\n\n    // y座標でソート\n    merge_y(v + first, v + mid, v + last);\n\n    // 左右にまたがる頂点対を探索\n    Vertex *over = malloc(n * sizeof(Vertex));\n    int t = 0;\n    int i, j;\n    for (i = first; i < last; ++i) {\n        if (fabs(v[i].x - x) >= d.length) continue;\n\n        for (j = t - 1; j >= 0; --j) {\n            double dy = v[i].y - over[j].y;\n            if (dy >= d.length) break;\n\n            Result d3 = {v[i].v, over[j].v, Get_Distance(v[i], over[j])};\n            d = d3.length <= d.length ? d3 : d;\n        }\n        over[t++] = v[i];\n    }\n\n    free(over);\n\n    return d;\n}\n\n"
  },
  {
    "language": "C",
    "code": "int n,i,j;\ndouble m,z,x[100001],y[100001];\nmain(){scanf(\"%d\",&n);for(i=0;i<n;i++)scanf(\"%lf%lf\",x+i,y+i);m=99999999;for(i=0;i<n;i++)for(j=i+1;j<n;j++)if(m>(z=(x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i])))m=z;printf(\"%.9f\\n\",sqrt(m));}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#include<math.h>\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\nstruct Point {\n  double x;\n  double y;\n};\nstruct Point *p;\nvoid qsort1(int left, int right);\nvoid msort(int left, int right);\ndouble closest_pair(int left, int right);\nint main(void)\n{\n  int i, n;\n  scanf(\"%d\", &n);\n  p = (struct Point*)malloc(sizeof(struct Point) * n);\n  for (i = 0; i < n; i++) scanf(\"%lf %lf\", &p[i].x, &p[i].y);\n  qsort1(0, n - 1);\n  printf(\"%.6f\\n\", closest_pair(0, n - 1));\n  free(p);\n}\nvoid qsort1(int left, int right)\n{\n  int i, j;\n  struct Point pivot;\n  if (left >= right) return;\n  i = left;\n  j = right;\n  pivot = p[(i + j) / 2];\n  do {\n    while (p[i].x < pivot.x) i++;\n    while (p[j].x > pivot.x) j--;\n    if (i <= j) {\n      struct Point temp = p[i];\n      p[i] = p[j];\n      p[j] = temp;\n      i++;\n      j--;\n    }\n  } while(i <= j);\n  qsort1(left, j);\n  qsort1(i, right);\n}\nvoid msort(int left, int right)\n{\n  int middle, num, base, i, j;\n  struct Point *work;\n  middle = (left + right) / 2;\n  work = (struct Point*)malloc(sizeof(struct Point) * (middle - left + 1));\n  for (num = 0, i = left; i <= middle; i++) work[num++] = p[i];\n  j = 0;\n  base = left;\n  while (i <= right && j < num) {\n    if (p[i].y < work[j].y) p[base++] = p[i++];\n    else p[base++] = work[j++];\n  }\n  while (j < num) p[base++] = work[j++];\n  free(work);\n}\ndouble closest_pair(int left , int right)\n{\n  int middle, num, i, j;\n  double x, d, dtemp;\n  struct Point *work;\n  if (left >= right) return INT_MAX;\n  middle = (left + right) / 2;\n  x = p[middle].x;\n  d = closest_pair(left, middle);\n  dtemp = closest_pair(middle + 1, right);\n  msort(left, right);\n  if (d > dtemp) d = dtemp;\n  work = (struct Point*)malloc(sizeof(struct Point) * (right - left + 1));\n  num = 0;\n  for (i = 0; i < (right - left + 1); i++) {\n    if (fabs(p[i].x - x) >= d) continue;\n    for (j = 0; j < num; j++) {\n      double dx = p[i].x - work[num - 1 - j].x, dy = p[i].y - work[num - 1 - j].y;\n      if (dy >= d) break;\n      d = MIN(d, sqrt(dx * dx + dy * dy));\n    }\n    work[num++] = p[i];\n  }\n  free(work);\n  return d;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#include<math.h>\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\nstruct Point {\n  double x;\n  double y;\n};\nstruct Point *p;\nvoid qsort1(int left, int right);\nvoid msort(int left, int right);\ndouble closest_pair(int left, int right);\nint main(void)\n{\n  int i, n;\n  scanf(\"%d\", &n);\n  p = (struct Point*)malloc(sizeof(struct Point) * n);\n  for (i = 0; i < n; i++) scanf(\"%lf %lf\", &p[i].x, &p[i].y);\n  qsort1(0, n - 1);\n  printf(\"%.6f\\n\", closest_pair(0, n - 1));\n  free(p);\n}\nvoid qsort1(int left, int right)\n{\n  int i, j;\n  struct Point pivot;\n  if (left >= right) return;\n  i = left;\n  j = right;\n  pivot = p[(i + j) / 2];\n  do {\n    while (p[i].x < pivot.x) i++;\n    while (p[j].x > pivot.x) j--;\n    if (i <= j) {\n      struct Point temp = p[i];\n      p[i] = p[j];\n      p[j] = temp;\n      i++;\n      j--;\n    }\n  } while(i <= j);\n  qsort1(left, j);\n  qsort1(i, right);\n}\nvoid msort(int left, int right)\n{\n  int middle, num, base, i, j;\n  struct Point *work;\n  middle = (left + right) / 2;\n  work = (struct Point*)malloc(sizeof(struct Point) * (middle - left + 1));\n  for (num = 0, i = left; i <= middle; i++) work[num++] = p[i];\n  j = 0;\n  base = left;\n  while (i <= right && j < num) {\n    if (p[i].y < work[j].y) p[base++] = p[i++];\n    else p[base++] = work[j++];\n  }\n  while (j < num) p[base++] = work[j++];\n  free(work);\n}\ndouble closest_pair(int left , int right)\n{\n  int middle, num, i, j;\n  double x, d, dtemp;\n  struct Point *work;\n  if (left >= right) return INT_MAX;\n  middle = (left + right) / 2;\n  x = p[middle].x;\n  d = closest_pair(left, middle);\n  dtemp = closest_pair(middle + 1, right);\n  msort(left, right);\n  if (d > dtemp) d = dtemp;\n  work = (struct Point*)malloc(sizeof(struct Point) * (right - left + 1));\n  num = 0;\n  for (i = 0; i < (right - left + 1); i++) {\n    if (abs(p[i].x - x) >= d) continue;\n    for (j = 0; j < num; j++) {\n      double dx = p[i].x - work[num - 1 - j].x, dy = p[i].y - work[num - 1 - j].y;\n      if (dy >= d) break;\n      d = MIN(d, sqrt(dx * dx + dy * dy));\n    }\n    work[num++] = p[i];\n  }\n  free(work);\n  return d;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ CGL_5_A Closest Pair\n// 2018.5.3 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\ntypedef struct { double x, y; } PP;\n\n#define INF     1e8\n#define EPS     1e-8\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\ndouble dbl()\n{\n\tint minus = 0;\n\tdouble x, y;\n\tint n = 0, c = gc();\n\tif (c == '-') minus = 1, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\n\tif (c == '.') {\n\t\tx = 0;\n\t\ty = 1, c = gc();\n\t\tdo y *= 0.1, x += y * (c & 0xf), c = gc(); while (c >= '0');\n\t\tx += n;\n\t} else x = n;\n\tif (minus) x = -x;\n\treturn x;\n}\n\nPP L[100002], R[100002];\n\nint dcmp(double x) { if (fabs(x) < EPS) return 0; return x <= 0 ? -1 : 1; }\nint cmp(PP *a, PP *b) { return dcmp(a->x - b->x); }\n\nvoid merge(PP *p, int low, int mid, int high)\n{\n\tint n1, n2, i, j, k;\n\n\tn1 = mid-low, n2 = high-mid;\n\tmemcpy(L, p+low, sizeof(PP)*n1);\n\tmemcpy(R, p+mid, sizeof(PP)*n2);\n\tL[n1].y = R[n2].y = INF;\n\n\ti = 0, j = 0;\n\tfor (k = low; k < high; k++) {\n\t\tif (L[i].y <= R[j].y) p[k] = L[i++];\n\t\telse                  p[k] = R[j++];\n\t}\n}\n\ndouble closest_pair(int n, PP *p)\n{\n\tint m, i, j, t;\n\tdouble ans, d, x;\n\n\tif(n <= 1) return INF;\n\tm = n >> 1;\n\tx = p[m].x;\n\tans = closest_pair(m, p);\n\td   = closest_pair(n-m, p+m);\n\tif (d < ans) ans = d;\n\tmerge(p, 0, m, n);\n\n\tt = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (fabs(p[i].x - x) >= ans) continue;\n\n\t\tfor (j = 0; j < t; j++) {\n\t\t\tdouble dx = p[i].x - L[t-1-j].x;\n\t\t\tdouble dy = p[i].y - L[t-1-j].y;\n\t\t\tif (dy >= ans) break;\n\t\t\td = hypot(dx, dy);\n\t\t\tif (d < ans) ans = d;\n\t\t}\n\t\tL[t++] = p[i];\n\t}\n\treturn ans;\n}\n\nPP p[100002];\n\nint main()\n{\n\tint n, i;\n\n\tn = in();\n\tfor (i = 0; i < n; i++) p[i].x = dbl(), p[i].y = dbl();\n\tqsort(p, n, sizeof(PP), cmp);\n\tprintf(\"%.10lf\\n\", closest_pair(n, p));\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#include<math.h>\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\nstruct Point {\n  double x;\n  double y;\n};\nstruct Point *p;\nvoid qsort1(int left, int right);\nvoid msort(int left, int right);\ndouble closest_pair(int left, int right);\nint main(void)\n{\n  int i, n;\n  scanf(\"%d\", &n);\n  p = (struct Point*)malloc(sizeof(struct Point) * n);\n  for (i = 0; i < n; i++) scanf(\"%lf %lf\", &p[i].x, &p[i].y);\n  qsort1(0, n - 1);\n  printf(\"%.6f\\n\", closest_pair(0, n - 1));\n  free(p);\n}\nvoid qsort1(int left, int right)\n{\n  int i, j;\n  struct Point pivot;\n  if (left >= right) return;\n  i = left;\n  j = right;\n  pivot = p[(i + j) / 2];\n  do {\n    while (p[i].x < pivot.x) i++;\n    while (p[j].x > pivot.x) j--;\n    if (i <= j) {\n      struct Point temp = p[i];\n      p[i] = p[j];\n      p[j] = temp;\n      i++;\n      j--;\n    }\n  } while(i <= j);\n  qsort1(left, j);\n  qsort1(i, right);\n}\nvoid msort(int left, int right)\n{\n  int middle, num, base, i, j;\n  struct Point center, *work;\n  if (left >= right) return;\n  middle = (left + right) / 2;\n  center = p[middle];\n  msort(left, middle);\n  msort(middle + 1, right);\n  work = (struct Point*)malloc(sizeof(struct Point) * (middle - left + 1));\n  for (num = 0, i = left; i <= middle; i++) work[num++] = p[i];\n  j = 0;\n  base = left;\n  while (i <= right && j < num) {\n    if (p[i].y < work[j].y) p[base++] = p[i++];\n    else p[base++] = work[j++];\n  }\n  while (j < num) p[base++] = work[j++];\n  free(work);\n}\ndouble closest_pair(int left , int right)\n{\n  int middle, num, i, j;\n  double x, d;\n  struct Point *work;\n  if (left >= right) return INT_MAX;\n  middle = (left + right) / 2;\n  x = p[middle].x;\n  d = MIN(closest_pair(left, middle), closest_pair(middle + 1, right));\n  msort(left, right);\n  work = (struct Point*)malloc(sizeof(struct Point) * (right - left + 1));\n  num = 0;\n  for (i = 0; i < (right - left + 1); i++) {\n    if (abs(p[i].x - x) >= d) continue;\n    for (j = 0; j < num; j++) {\n      double dx = p[i].x - work[num - 1 - j].x, dy = p[i].y - work[num - 1 - j].y;\n      if (dy >= d) break;\n      d = MIN(d, sqrt(dx * dx + dy * dy));\n    }\n    work[num++] = p[i];\n  }\n  free(work);\n  return d;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<time.h>\n\ntypedef long long int int64;\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define ABS(a) ((a)>(0)?(a):-(a))\n\ntypedef struct point2dfloat{\n  double x,y;\n} point;\n\nint cmp(const void *a,const void *b){\n  const point *p=(point *)a;\n  const point *q=(point *)b;\n  if(p->x!=q->x) return p->x>q->x?1:-1;\n  if(p->y!=q->y) return p->y>q->y?1:-1;\n  return 0;\n}\n\ndouble distance(const point *a,const point *b){\n  double dx=a->x-b->x;\n  double dy=a->y-b->y;\n  return sqrt(dx*dx+dy*dy);\n}\n\ndouble closestPairDistance(const point *p,int n){\n  if(n<=3){\n    double min=400;\n    int i,j;\n    for(i=0;i<n;i++){\n      for(j=i+1;j<n;j++){\n\tmin=MIN(min,distance(p+i,p+j));\n      }\n    }\n    return min;\n  }\n  int m=n/2;\n  double l=closestPairDistance(p,m);\n  double r=closestPairDistance(p+m,n-m);\n  double g=MIN(l,r);\n  double mid=(p[m-1].x+p[m].x)/2;\n  int ll=m-1;\n  while(ll>=0 && mid-p[ll].x<g) ll--;\n  int rr=m;\n  while(rr<n && p[rr].x-mid<g) rr++;\n\n  double min=g;\n  int i,j;\n  for(i=m-1;i>ll;i--){\n    for(j=m;j<rr;j++){\n      min=MIN(min,distance(p+i,p+j));\n    }\n  }\n  return min;\n}\n\nvoid run(void){\n  int n;\n  scanf(\"%d\",&n);\n  point a[100000];\n  int i;\n  for(i=0;i<n;i++){\n    scanf(\"%lf%lf\",&(a[i].x),&(a[i].y));\n  }\n  srand((unsigned)time(NULL));\n  double theta=(M_PI/2)*((double)rand()/RAND_MAX);\n  double c=cos(theta);\n  double s=sin(theta);\n  point b[100000];\n  for(i=0;i<n;i++){\n    b[i].x=c*a[i].x-s*a[i].y;\n    b[i].y=s*a[i].x+c*a[i].y;\n  }\n  qsort(b,n,sizeof(point),cmp);\n  double ans=closestPairDistance(b,n);\n  printf(\"%.9lf\\n\",ans);\n  return;\n}\n\nint main(void){\n  run();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#include<math.h>\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\nstruct Point {\n  double x;\n  double y;\n};\nstruct Point *p;\nvoid qsort1(int left, int right);\nvoid msort(int left, int right);\ndouble closest_pair(int left, int right);\nint main(void)\n{\n  int i, n;\n  scanf(\"%d\", &n);\n  p = (struct Point*)malloc(sizeof(struct Point) * n);\n  for (i = 0; i < n; i++) scanf(\"%lf %lf\", &p[i].x, &p[i].y);\n  qsort1(0, n - 1);\n  printf(\"%.6f\\n\", closest_pair(0, n - 1));\n  free(p);\n}\nvoid qsort1(int left, int right)\n{\n  int i, j;\n  struct Point pivot;\n  if (left >= right) return;\n  i = left;\n  j = right;\n  pivot = p[(i + j) / 2];\n  do {\n    while (p[i].x < pivot.x) i++;\n    while (p[j].x > pivot.x) j--;\n    if (i <= j) {\n      struct Point temp = p[i];\n      p[i] = p[j];\n      p[j] = temp;\n      i++;\n      j--;\n    }\n  } while(i <= j);\n  qsort1(left, j);\n  qsort1(i, right);\n}\nvoid msort(int left, int right)\n{\n  int middle, num, base, i, j;\n  struct Point *work;\n  if (left >= right) return;\n  middle = (left + right) / 2;\n  work = (struct Point*)malloc(sizeof(struct Point) * (middle - left + 1));\n  for (num = 0, i = left; i <= middle; i++) work[num++] = p[i];\n  j = 0;\n  base = left;\n  while (i <= right && j < num) {\n    if (p[i].y < work[j].y) p[base++] = p[i++];\n    else p[base++] = work[j++];\n  }\n  while (j < num) p[base++] = work[j++];\n  free(work);\n}\ndouble closest_pair(int left , int right)\n{\n  int middle, num, i, j;\n  double x, d;\n  struct Point *work;\n  if (left >= right) return INT_MAX;\n  middle = (left + right) / 2;\n  x = p[middle].x;\n  d = MIN(closest_pair(left, middle), closest_pair(middle + 1, right));\n  msort(left, right);\n  work = (struct Point*)malloc(sizeof(struct Point) * (right - left + 1));\n  num = 0;\n  for (i = 0; i < (right - left + 1); i++) {\n    if (abs(p[i].x - x) >= d) continue;\n    for (j = 0; j < num; j++) {\n      double dx = p[i].x - work[num - 1 - j].x, dy = p[i].y - work[num - 1 - j].y;\n      if (dy >= d) break;\n      d = MIN(d, sqrt(dx * dx + dy * dy));\n    }\n    work[num++] = p[i];\n  }\n  free(work);\n  return d;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ CGL_5_A Closest Pair\n// 2018.5.3 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct { double x, y; } PP;\n\n#define INF     1e12\n#define EPS     1e-7\n#define RANGE\t4\n#define SIN     0.70710678118654752440084436210485    // Sin(45)\n#define COS     0.70710678118654752440084436210485    // Cos(45)\n#define SINCOS  SIN\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\ndouble dbl()\n{\n\tint minus = 0;\n\tdouble x, y;\n\tint n = 0, c = gc();\n\tif (c == '-') minus = 1, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\n\tif (c == '.') {\n\t\tx = 0;\n\t\ty = 1, c = gc();\n\t\tdo y *= 0.1, x += y * (c & 0xf), c = gc(); while (c >= '0');\n\t\tx += n;\n\t} else x = n;\n\tif (minus) x = -x;\n\treturn x;\n}\n\nint cmp(PP *a, PP *b)\n{\n\tif (fabs(a->x - b->x) < EPS) {\n\t\tif (fabs(a->y - b->y) < EPS) return 0;\n\t\tif (a->y < b->y) return -1; return 1;\n\t}\n\tif (a->x < b->x) return -1;\treturn 1;\n}\n\nPP p[100010];\n\nint main()\n{\n\tint n, i, j, lim;\n\tdouble x, y, t, ans;\n\n\tn = in();\n\tfor (i = 0; i < n; i++) {\n\t\tx = dbl(), y = dbl();\n\t\tp[i].x = (x - y) * SINCOS;\n\t\tp[i].y = (x + y) * SINCOS;\n\t}\n\n\tqsort(p, n, sizeof(PP), cmp);\n\n\tans = INF;\n\tfor (i = n; i < n+RANGE; i++) p[i].x = INF, p[i].y = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tlim = i+RANGE; for (j = i+1; j < lim; j++) {\n\t\t\tt = hypot(p[i].x-p[j].x, p[i].y-p[j].y);\n\t\t\tif (t < ans) ans = t;\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "int n,i,j;\ndouble m,z,x[100001],y[100001];\nmain(){scanf(\"%d\",&n);for(i=0;i<n;i++)scanf(\"%lf%lf\",x+i,y+i);m=99999999;for(i=0;i<n;i++)for(j=i+1;j<n;j++)if(m>(z=(x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i])))m=z;printf(\"%.9f\\n\",sqrt(m));exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<time.h>\n\ntypedef long long int int64;\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define ABS(a) ((a)>(0)?(a):-(a))\n\ntypedef struct point2dfloat{\n  double x,y;\n} point;\n\nint cmp(const void *a,const void *b){\n  const point *p=(point *)a;\n  const point *q=(point *)b;\n  if(p->x!=q->x) return p->x>q->x?1:-1;\n  if(p->y!=q->y) return p->y>q->y?1:-1;\n  return 0;\n}\n\ndouble distance(const point *a,const point *b){\n  double dx=a->x-b->x;\n  double dy=a->y-b->y;\n  return sqrt(dx*dx+dy*dy);\n}\n\ndouble closestPairDistance(const point *p,int n){\n  if(n<=3){\n    double min=400;\n    int i,j;\n    for(i=0;i<n;i++){\n      for(j=i+1;j<n;j++){\n\tmin=MIN(min,distance(p+i,p+j));\n      }\n    }\n    return min;\n  }\n  int m=n/2;\n  double l=closestPairDistance(p,m);\n  double r=closestPairDistance(p+m,n-m);\n  double g=MIN(l,r);\n  double mid=(p[m-1].x+p[m].x)/2;\n  int ll=m-1;\n  while(ll>=0 && mid-p[ll].x<g) ll--;\n  int rr=m;\n  while(rr<n && p[rr].x-mid<g) rr++;\n\n  double min=g;\n  int i,j;\n  for(i=m-1;i>ll;i--){\n    for(j=m;j<rr;j++){\n      min=MIN(min,distance(p+i,p+j));\n    }\n  }\n  return min;\n}\n\nvoid run(void){\n  int n;\n  scanf(\"%d\",&n);\n  point a[100000];\n  int i;\n  for(i=0;i<n;i++){\n    scanf(\"%lf%lf\",&(a[i].x),&(a[i].y));\n  }\n  srand((unsigned)time(NULL));\n  double theta=(M_PI/2)*((double)rand()/RAND_MAX);\n  double c=cos(theta);\n  double s=sin(theta);\n  point b[100000];\n  for(i=0;i<n;i++){\n    b[i].x=c*a[i].x-s*a[i].y;\n    b[i].y=s*a[i].x+c*a[i].y;\n  }\n  double ans=closestPairDistance(b,n);\n  printf(\"%.9lf\\n\",ans);\n  return;\n}\n\nint main(void){\n  run();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdint.h>\n#include <time.h>\n#include <limits.h>\n#include <string.h>\n\nint n;\nfloat *x,*y;\nfloat getdist(int i,int j){\n  float dx,dy;\n  dx = x[i]-x[j];\n  dy = y[i]-y[j];\n  return sqrtf(dx*dx+dy*dy);\n}\n\n/* xorshift */\n/* https://ja.wikipedia.org/wiki/Xorshift */\nuint32_t xor128(){ \n  static uint32_t x = 123456789;\n  static uint32_t y = 362436069;\n  static uint32_t z = 521288629;\n  static uint32_t w = 88675123; \n  uint32_t t;\n \n  t = x ^ (x << 11);\n  x = y; y = z; z = w;\n  return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)); \n}\n\n/* resizable int array */\ntypedef struct vector {\n  int limit,size;\n  int *a;\n} vector;\nvector *new_vector(){\n  vector *ret;\n  ret = (vector*)malloc(sizeof(vector));\n  ret->limit = 1;\n  ret->size = 0;\n  ret->a = (int*)malloc(ret->limit * sizeof(int));\n  return ret;\n}\nvector *copy_vector(vector *v){\n  int i;\n  vector *ret;\n  ret = (vector*)malloc(sizeof(vector));\n  ret->limit = v->limit;\n  ret->size = v->size;\n  ret->a = (int*)malloc(ret->limit * sizeof(int));\n  for(i=0;i<v->size;++i){\n    ret->a[i] = v->a[i];\n  }\n  return ret;\n}\nvoid v_push_back(vector *v,int val){\n  if(v->size >= v->limit){\n    v->limit <<= 1;\n    v->a = (int*)realloc(v->a,v->limit * sizeof(int));\n  }\n  v->a[v->size++] = val;\n}\nvoid free_vector(vector *v){\n  if(!v)return;\n  free(v->a);\n  free(v);\n}\n/* end of resizable int array */\n\n/* resizable int array array */\ntypedef struct vector_vector {\n  int limit,size;\n  vector **a;\n} vector_vector;\nvector_vector *new_vector_vector(){\n  vector_vector *ret;\n  ret = (vector_vector*)malloc(sizeof(vector_vector));\n  ret->limit = 1;\n  ret->size = 0;\n  ret->a = (vector**)malloc(ret->limit * sizeof(vector*));\n  return ret;\n}\nvoid vv_push_back(vector_vector *v,vector *val){\n  if(v->size >= v->limit){\n    v->limit <<= 1;\n    v->a = (vector**)realloc(v->a,v->limit * sizeof(vector*));\n  }\n  v->a[v->size++] = val;\n}\nvoid free_vector_vector(vector_vector *v){\n  int i;\n  if(!v)return;\n  for(i=0;i<v->size;++i){\n    free_vector(v->a[i]);\n  }\n  free(v->a);\n  free(v);\n}\n/* end of resizable int array array */\n\n/* hash map for pair<int,int> */\n/* hash max value = 2^16 = 65535 */\n#define HASH_MAX 65536\nint hash_int(int x){\n  uint32_t y;\n  y = *(uint32_t*)(&x);\n  y = y ^ (y << 13);\n  y = y ^ (y >> 17);\n  return (int)(y&(HASH_MAX-1));\n}\nint hash_int2(int x){\n  uint32_t y;\n  y = *(uint32_t*)(&x);\n  y = y ^ (y << 13);\n  y = y ^ (y >> 17);\n  return (int)(y>>16);\n}\nint hash_pii(int a,int b){\n  return hash_int(a)^hash_int2(b);\n}\ntypedef struct HashMap_pii {\n  vector_vector **bucket;\n  vector **bucket_x, **bucket_y;\n} HashMap_pii;\nHashMap_pii *new_HashMap_pii(){\n  int i;\n  HashMap_pii *ret;\n  ret = (HashMap_pii*)malloc(sizeof(HashMap_pii));\n  ret->bucket = (vector_vector**)calloc(HASH_MAX,sizeof(vector_vector*));\n  ret->bucket_x = (vector**)calloc(HASH_MAX,sizeof(vector*));\n  ret->bucket_y = (vector**)calloc(HASH_MAX,sizeof(vector*));\n  for(i=0;i<HASH_MAX;++i){\n    ret->bucket[i] = new_vector_vector();\n    ret->bucket_x[i] = new_vector();\n    ret->bucket_y[i] = new_vector();\n  }\n  return ret;\n}\nvector *hmpii_get(HashMap_pii *map,int x,int y){\n  int i;\n  int hsh;\n  hsh = hash_pii(x,y);\n  for(i=0;i<map->bucket[hsh]->size;++i){\n    if(map->bucket_x[hsh]->a[i] == x && map->bucket_y[hsh]->a[i] == y){\n      return map->bucket[hsh]->a[i];\n    }\n  }\n  return NULL;\n}\nvoid hmpii_add(HashMap_pii *map,int x,int y,int val){\n  int i;\n  int id;\n  int hsh;\n  vector *set;\n  hsh = hash_pii(x,y);\n  set = hmpii_get(map,x,y);\n  if(!set){\n    set = new_vector();\n    vv_push_back(map->bucket[hsh],set);\n    v_push_back(map->bucket_x[hsh],x);\n    v_push_back(map->bucket_y[hsh],y);\n  }\n  v_push_back(set,val);\n}\nvoid free_HashMap_pii(HashMap_pii *map){\n  int i;\n  if(!map)return;\n  for(i=0;i<HASH_MAX;++i){\n    free_vector_vector(map->bucket[i]);\n    free_vector(map->bucket_x[i]);\n    free_vector(map->bucket_y[i]);\n  }\n  free(map->bucket);\n  free(map->bucket_x);\n  free(map->bucket_y);\n  free(map);\n}\n\n/* nearest pair from two group in two dimensional map */\nvoid find_nearest_pair_from_two_group(vector *a,int *ret_a,int *ret_b){\n  int i,j,k;\n  vector *a_bef, *a_nxt;\n  float dist;\n  a_bef = copy_vector(a);\n  a_nxt = NULL;\n  dist = 1e25f;\n  while(a_bef->size > 0){\n    int ai;\n    float delta;\n    HashMap_pii *amap;\n    ai = a_bef->a[xor128()%a_bef->size];\n    dist = 1e25f;\n    for(i=0;i<a_bef->size;++i){\n      if(ai==a_bef->a[i])continue;\n      if(getdist(ai,a_bef->a[i]) < dist)\n        dist = getdist(ai,a_bef->a[i]);\n    }\n    delta = dist/8;\n    /* grid */\n    amap = new_HashMap_pii();\n    for(i=0;i<a_bef->size;++i){\n      int xx,yy,id;\n      id = a_bef->a[i];\n      xx = (int)(x[id]/delta);\n      yy = (int)(y[id]/delta);\n      hmpii_add(amap,xx,yy,id);\n    }\n    /* search */\n    a_nxt = new_vector();\n    for(i=0;i<a_bef->size;++i){\n      int xx,yy,id;\n      int flag;\n      id = a_bef->a[i];\n      xx = (int)(x[id]/delta);\n      yy = (int)(y[id]/delta);\n      flag = 0;\n      for(j=-1;j<=1&&!flag;++j)for(k=-1;k<=1&&!flag;++k){\n        vector *vec = hmpii_get(amap,xx+j,yy+k);\n        if(vec!=NULL && vec->size!=0){\n          int l;\n          for(l=0;l<vec->size;++l){\n            if(vec->a[l]!=id){\n              flag = 1;\n              break;\n            }\n          }\n        }\n      }\n      if(flag)\n        v_push_back(a_nxt,id);\n    }\n    /* step */\n    free_vector(a_bef);\n    free_HashMap_pii(amap);\n    a_bef = a_nxt;\n    a_nxt = NULL;\n  }\n  free_vector(a_bef);\n  /* create grid with dist */\n  {\n    float mindist;\n    int pa,pb;\n    HashMap_pii *map;\n    mindist = 1e25f;\n    pa = pb = -1;\n    map = new_HashMap_pii();\n    for(i=0;i<a->size;++i){\n      int xx,yy,id;\n      vector *vec;\n      id = a->a[i];\n      xx = (int)(x[id]/dist);\n      yy = (int)(y[id]/dist);\n      for(j=-1;j<=1;++j)for(k=-1;k<=1;++k){\n        int l;\n        vec = hmpii_get(map,xx+j,yy+k);\n        if(vec==NULL)continue;\n        for(l=0;l<vec->size;++l){\n          int to;\n          to = vec->a[l];\n          if(getdist(to,id)<mindist){\n            mindist = getdist(to,id);\n            pa = to;\n            pb = id;\n          }\n        }\n      }\n      hmpii_add(map,xx,yy,id);\n    }\n    *ret_a = pa;\n    *ret_b = pb;\n  }\n}\n\nint main(){\n  int i;\n  int ansa,ansb;\n  vector *a;\n  a = new_vector();\n  scanf(\"%d\",&n);\n  x = (float*)calloc(n,sizeof(float));\n  y = (float*)calloc(n,sizeof(float));\n  for(i=0;i<n;++i){\n    scanf(\"%f%f\",x+i,y+i);\n    v_push_back(a,i);\n  }\n  find_nearest_pair_from_two_group(a,&ansa,&ansb);\n  printf(\"%.10f\\n\",getdist(ansa,ansb));\n  return 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigDecimal\nimport java.util.*\n\nclass Point(val x: Double, val y: Double) {\n    operator fun minus(other: Point): Double {\n        return Math.sqrt(Math.pow(this.x-other.x, 2.0)+Math.pow(this.y-other.y, 2.0))\n    }\n    operator fun get(i: Int): Double = if (i == 0) x else y\n}\nfun solve(a: Array<Point>, sortedAxis: Int = -1): Double {\n    if (a.size <= 3) {\n        var dist = 1000000000000.0\n        for (i in 0 until a.size-1) {\n            for (j in i+1 until a.size) dist = Math.min(dist, a[i]-a[j])\n        }\n        return dist\n    }\n\n    val mid = a.size/2\n    val xSetLen = a.map { it -> it.x }.toHashSet().size\n    val (axis1, axis2) = if (xSetLen >= mid) Pair(0, 1) else Pair(1, 0)\n    if (axis1 != sortedAxis) a.sortBy { it[axis1] }\n\n    val leftArray = a.sliceArray(0 until mid)\n    val rightArray = a.sliceArray(mid until a.size)\n    var delta = Math.min(solve(leftArray, axis1), solve(rightArray, axis1))\n    val median = a[mid][axis1]\n    //val mid_a = a.filter { it[axis1] in median-delta..median+delta }.sortedBy { it[axis2] }\n    val mid_a = leftArray.takeLastWhile { median-delta < it[axis1] }.plus(\n            rightArray.takeWhile { it[axis1] < median+delta }\n    ).sortedBy { it[axis2] }\n\n    for (i in 0 until mid_a.size-1) {\n        val ub = mid_a[i][axis2] + delta\n        for (j in i+1 until mid_a.size) {\n            if (mid_a[i][axis2] >= ub) break\n            delta = Math.min(delta, mid_a[i]-mid_a[j])\n        }\n    }\n\n    return delta\n}\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val N = sc.nextInt()\n    val a = Array(N, { Point(sc.nextDouble(), sc.nextDouble()) })\n    val ans = solve(a)\n    println(BigDecimal.valueOf(ans).toPlainString())\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigDecimal\nimport java.util.*\nimport kotlin.system.measureTimeMillis\nvar time = 0L\n\nfun solve(a: Array<Array<Double>>, sortedAxis: Int = -1): Double {\n    if (a.size <= 3) {\n        var dist = 1000000000000.0\n        for ((i, p1) in a.withIndex()) {\n            for (p2 in a.takeLast(a.size-i-1)) {\n                dist = Math.min(dist, Math.sqrt(Math.pow(p1[0]-p2[0], 2.0)+Math.pow(p1[1]-p2[1], 2.0)))\n            }\n        }\n        return dist\n    }\n\n    val mid = a.size/2\n    //val startt = System.nanoTime()\n    val xSetLen = HashSet(a.map { it -> it[0] }).size\n    val (axis1, axis2) = if (xSetLen >= mid) Pair(0, 1) else Pair(1, 0)\n    if (axis1 != sortedAxis) a.sortBy { it[axis1] }\n    //time += System.nanoTime() - startt\n\n    val leftArray = a.sliceArray(0 until mid)\n    val rightArray = a.sliceArray(mid until a.size)\n    var delta = Math.min(\n            solve(leftArray, axis1),\n            solve(rightArray, axis1)\n    )\n    val median = a[mid][axis1]\n    val mid_a = a.filter { it[axis1] in median-delta..median+delta }.sortedBy { it[axis2] }\n\n    for (i in 0 until mid_a.size-1) {\n        val ub = mid_a[i][axis2] + delta\n        for (j in i+1 until mid_a.size) {\n            if (mid_a[i][axis2] >= ub) break\n            delta = Math.min(delta,\n                    Math.sqrt(Math.pow(mid_a[i][0]-mid_a[j][0], 2.0)+Math.pow(mid_a[i][1]-mid_a[j][1], 2.0)))\n        }\n    }\n\n    return delta\n}\n\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val N = sc.nextInt()\n    val a = Array(N, { arrayOf(java.lang.Double.parseDouble(sc.next()), java.lang.Double.parseDouble(sc.next())) })\n    val tt = measureTimeMillis {\n        val ans = solve(a)\n        println(BigDecimal.valueOf(ans).toPlainString())\n    }\n    //println(tt)\n    //print(time/1000000)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigDecimal\nimport java.util.*\nimport java.io.IOException\n\ninternal class FastScanner {\n    private val `in` = System.`in`\n    private val buffer = ByteArray(1024)\n    private var ptr = 0\n    private var buflen = 0\n    private fun hasNextByte(): Boolean {\n        if (ptr < buflen) {\n            return true\n        } else {\n            ptr = 0\n            try {\n                buflen = `in`.read(buffer)\n            } catch (e: IOException) {\n                e.printStackTrace()\n            }\n\n            if (buflen <= 0) {\n                return false\n            }\n        }\n        return true\n    }\n\n    private fun readByte(): Int {\n        return if (hasNextByte()) buffer[ptr++].toInt() else -1\n    }\n\n    private fun isPrintableChar(c: Int): Boolean {\n        return 33 <= c && c <= 126\n    }\n\n    operator fun hasNext(): Boolean {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr].toInt())) ptr++\n        return hasNextByte()\n    }\n\n    operator fun next(): String {\n        if (!hasNext()) throw NoSuchElementException()\n        val sb = StringBuilder()\n        var b = readByte()\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b)\n            b = readByte()\n        }\n        return sb.toString()\n    }\n\n    fun nextLong(): Long {\n        if (!hasNext()) throw NoSuchElementException()\n        var n: Long = 0\n        var minus = false\n        var b = readByte()\n        if (b == '-'.toInt()) {\n            minus = true\n            b = readByte()\n        }\n        if (b < '0'.toInt() || '9'.toInt() < b) {\n            throw NumberFormatException()\n        }\n        while (true) {\n            if ('0'.toInt() <= b && b <= '9'.toInt()) {\n                n *= 10\n                n += (b - '0'.toInt()).toLong()\n            } else return if (b == -1 || !isPrintableChar(b)) {\n                if (minus) -n else n\n            } else {\n                throw NumberFormatException()\n            }\n            b = readByte()\n        }\n    }\n\n    fun nextInt(): Int {\n        val nl = nextLong()\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw NumberFormatException()\n        return nl.toInt()\n    }\n\n    fun nextDouble(): Double {\n        return java.lang.Double.parseDouble(next())\n    }\n}\nfun solve(a: Array<Array<Double>>, sortedAxis: Int = -1): Double {\n    if (a.size <= 3) {\n        var dist = 1000000000000.0\n        for ((i, p1) in a.withIndex()) {\n            for (p2 in a.takeLast(a.size-i-1)) {\n                dist = Math.min(dist, Math.sqrt(Math.pow(p1[0]-p2[0], 2.0)+Math.pow(p1[1]-p2[1], 2.0)))\n            }\n        }\n        return dist\n    }\n\n    val mid = a.size/2\n    val xSetLen = HashSet(a.map { it -> it[0] }).size\n    val (axis1, axis2) = if (xSetLen >= mid) Pair(0, 1) else Pair(1, 0)\n    if (axis1 != sortedAxis) a.sortBy { it[axis1] }\n\n    val leftArray = a.sliceArray(0 until mid)\n    val rightArray = a.sliceArray(mid until a.size)\n    var delta = Math.min(\n            solve(leftArray, axis1),\n            solve(rightArray, axis1)\n    )\n    val median = a[mid][axis1]\n    val mid_a = a.filter { it[axis1] in median-delta..median+delta }.sortedBy { it[axis2] }\n\n    for (i in 0 until mid_a.size-1) {\n        val ub = mid_a[i][axis2] + delta\n        for (j in i+1 until mid_a.size) {\n            if (mid_a[i][axis2] >= ub) break\n            delta = Math.min(delta,\n                    Math.sqrt(Math.pow(mid_a[i][0]-mid_a[j][0], 2.0)+Math.pow(mid_a[i][1]-mid_a[j][1], 2.0)))\n        }\n    }\n\n    return delta\n}\n\nfun main(args: Array<String>) {\n    val sc = FastScanner()\n    val N = sc.nextInt()\n    val a = Array(N, { arrayOf(sc.nextDouble(), sc.nextDouble()) })\n    val ans = solve(a)\n    println(BigDecimal.valueOf(ans).toPlainString())\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigDecimal\nimport java.util.*\n\nclass Point(val x: Double, val y: Double) {\n    operator fun minus(other: Point): Double {\n        return Math.sqrt(Math.pow(this.x-other.x, 2.0)+Math.pow(this.y-other.y, 2.0))\n    }\n    operator fun get(i: Int): Double = if (i == 0) x else y\n}\nfun solve(a: Array<Point>): Double {\n    if (a.size <= 3) {\n        var dist = 1000000000000.0\n        for (i in 0 until a.size-1) {\n            for (j in i+1 until a.size) dist = Math.min(dist, a[i]-a[j])\n        }\n        return dist\n    }\n\n    val mid = a.size/2\n    val xSetLen = a.map { it -> it.x }.toHashSet().size\n    val (axis1, axis2) = if (xSetLen >= mid) Pair(0, 1) else Pair(1, 0)\n    a.sortBy { it[axis1] }\n    var delta = Math.min(\n            solve(a.sliceArray(0 until mid)),\n            solve(a.sliceArray(mid until a.size))\n    )\n    val median = a[mid][axis1]\n    val mid_a = a.filter { it[axis1] in median-delta..median+delta }.sortedBy { it[axis2] }\n    for (i in 0 until mid_a.size-1) {\n        val ub = mid_a[i][axis2]\n        for (j in i+1..mid_a.size) {\n            if (mid_a[i][axis2] >= ub) break\n            delta = Math.min(delta, mid_a[i]-mid_a[j])\n        }\n    }\n\n    return delta\n}\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val N = sc.nextInt()\n    val a = Array(N, { Point(sc.nextDouble(), sc.nextDouble()) })\n    val ans = solve(a)\n    println(BigDecimal.valueOf(ans).toPlainString())\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigDecimal\nimport java.util.*\nimport kotlin.system.measureTimeMillis\n//var time = 0L\n\nfun solve(a: Array<Array<Double>>, sortedAxis: Int = -1): Double {\n    if (a.size <= 3) {\n        var dist = 1000000000000.0\n        for ((i, p1) in a.withIndex()) {\n            for (p2 in a.takeLast(a.size-i-1)) {\n                dist = Math.min(dist, Math.sqrt(Math.pow(p1[0]-p2[0], 2.0)+Math.pow(p1[1]-p2[1], 2.0)))\n            }\n        }\n        return dist\n    }\n\n    val mid = a.size/2\n    //val startt = System.nanoTime()\n    val xSetLen = HashSet(a.map { it -> it[0] }).size\n    val (axis1, axis2) = if (xSetLen >= mid) Pair(0, 1) else Pair(1, 0)\n    if (axis1 != sortedAxis) a.sortBy { it[axis1] }\n    //time += System.nanoTime() - startt\n\n    val leftArray = a.sliceArray(0 until mid)\n    val rightArray = a.sliceArray(mid until a.size)\n    var delta = Math.min(\n            solve(leftArray, axis1),\n            solve(rightArray, axis1)\n    )\n    val median = a[mid][axis1]\n    val mid_a = a.filter { it[axis1] in median-delta..median+delta }.sortedBy { it[axis2] }\n\n    for (i in 0 until mid_a.size-1) {\n        val ub = mid_a[i][axis2] + delta\n        for (j in i+1 until mid_a.size) {\n            if (mid_a[i][axis2] >= ub) break\n            delta = Math.min(delta,\n                    Math.sqrt(Math.pow(mid_a[i][0]-mid_a[j][0], 2.0)+Math.pow(mid_a[i][1]-mid_a[j][1], 2.0)))\n        }\n    }\n\n    return delta\n}\n\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val N = sc.nextInt()\n    val a = Array(N, { arrayOf(java.lang.Double.parseDouble(sc.next()), java.lang.Double.parseDouble(sc.next())) })\n    //val tt = measureTimeMillis {\n        val ans = solve(a)\n        println(BigDecimal.valueOf(ans).toPlainString())\n    //}\n    //println(tt)\n    //print(time/1000000)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigDecimal\nimport java.util.*\nimport kotlin.system.measureTimeMillis\n//var time = 0L\n\nfun solve(a: Array<Array<Double>>, sortedAxis: Int = -1): Double {\n    if (a.size <= 3) {\n        var dist = 1000000000000.0\n        for ((i, p1) in a.withIndex()) {\n            for (p2 in a.takeLast(a.size-i-1)) {\n                dist = Math.min(dist, Math.sqrt(Math.pow(p1[0]-p2[0], 2.0)+Math.pow(p1[1]-p2[1], 2.0)))\n            }\n        }\n        return dist\n    }\n\n    val mid = a.size/2\n    //val startt = System.nanoTime()\n    val xSetLen = HashSet(a.map { it -> it[0] }).size\n    val (axis1, axis2) = if (xSetLen >= mid) Pair(0, 1) else Pair(1, 0)\n    if (axis1 != sortedAxis) a.sortBy { it[axis1] }\n    //time += System.nanoTime() - startt\n\n    val leftArray = a.sliceArray(0 until mid)\n    val rightArray = a.sliceArray(mid until a.size)\n    var delta = Math.min(\n            solve(leftArray, axis1),\n            solve(rightArray, axis1)\n    )\n    val median = a[mid][axis1]\n    val mid_a = a.filter { it[axis1] in median-delta..median+delta }.sortedBy { it[axis2] }\n\n    for (i in 0 until mid_a.size-1) {\n        val ub = mid_a[i][axis2] + delta\n        for (j in i+1 until mid_a.size) {\n            if (mid_a[i][axis2] >= ub) break\n            delta = Math.min(delta,\n                    Math.sqrt(Math.pow(mid_a[i][0]-mid_a[j][0], 2.0)+Math.pow(mid_a[i][1]-mid_a[j][1], 2.0)))\n        }\n    }\n\n    return delta\n}\n\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val N = sc.nextInt()\n    val a = Array(N, { arrayOf(java.lang.Double.parseDouble(sc.next()), java.lang.Double.parseDouble(sc.next())) })\n    //val tt = measureTimeMillis {\n        val ans = solve(a)\n        println(BigDecimal.valueOf(ans).toPlainString())\n    //}\n    //println(tt)\n    //print(time/1000000)\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigDecimal\nimport java.util.*\n\n\nfun solve(a: Array<DoubleArray>, sortedAxis: Int = -1): Double {\n    if (a.size <= 3) {\n        var dist = 1000000000000.0\n        for ((i, p1) in a.withIndex()) {\n            for (p2 in a.takeLast(a.size-i-1)) {\n                dist = Math.min(dist, Math.sqrt(Math.pow(p1[0]-p2[0], 2.0)+Math.pow(p1[1]-p2[1], 2.0)))\n            }\n        }\n        return dist\n    }\n\n    val mid = a.size/2\n    val xSetLen = a.map { it -> it[0] }.toHashSet().size\n    val (axis1, axis2) = if (xSetLen >= mid) Pair(0, 1) else Pair(1, 0)\n    if (axis1 != sortedAxis) a.sortBy { it[axis1] }\n\n    val leftArray = a.sliceArray(0 until mid)\n    val rightArray = a.sliceArray(mid until a.size)\n    var delta = Math.min(solve(leftArray, axis1), solve(rightArray, axis1))\n    val median = a[mid][axis1]\n    val mid_a = a.filter { it[axis1] in median-delta..median+delta }.sortedBy { it[axis2] }\n\n    for (i in 0 until mid_a.size-1) {\n        val ub = mid_a[i][axis2] + delta\n        for (j in i+1 until mid_a.size) {\n            if (mid_a[i][axis2] >= ub) break\n            delta = Math.min(delta,\n                    Math.sqrt(Math.pow(mid_a[i][0]-mid_a[j][0], 2.0)+Math.pow(mid_a[i][1]-mid_a[j][1], 2.0)))\n        }\n    }\n\n    return delta\n}\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val N = sc.nextInt()\n    val a = Array(N, { doubleArrayOf(sc.nextDouble(), sc.nextDouble()) })\n    val ans = solve(a)\n    println(BigDecimal.valueOf(ans).toPlainString())\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigDecimal\nimport java.util.*\n\n\nfun solve(a: Array<Array<Double>>, sortedAxis: Int = -1): Double {\n    if (a.size <= 3) {\n        var dist = 1000000000000.0\n        for ((i, p1) in a.withIndex()) {\n            for (p2 in a.takeLast(a.size-i-1)) {\n                dist = Math.min(dist, Math.sqrt(Math.pow(p1[0]-p2[0], 2.0)+Math.pow(p1[1]-p2[1], 2.0)))\n            }\n        }\n        return dist\n    }\n\n    val mid = a.size/2\n    val xSetLen = a.map { it -> it[0] }.toHashSet().size\n    val (axis1, axis2) = if (xSetLen >= mid) Pair(0, 1) else Pair(1, 0)\n    if (axis1 != sortedAxis) a.sortBy { it[axis1] }\n\n    val leftArray = a.sliceArray(0 until mid)\n    val rightArray = a.sliceArray(mid until a.size)\n    var delta = Math.min(\n            solve(leftArray, axis1),\n            solve(rightArray, axis1)\n    )\n    val median = a[mid][axis1]\n\n    for (i in 0 until a.size-1) {\n        if (a[i][axis2] < median-delta) continue\n        else if (a[i][axis2] > median+delta) break\n        val ub = a[i][axis2] + delta\n        for (j in i+1 until a.size) {\n            if (a[j][axis2] >= ub) break\n            delta = Math.min(delta,\n                    Math.sqrt(Math.pow(a[i][0]-a[j][0], 2.0)+Math.pow(a[i][1]-a[j][1], 2.0)))\n        }\n    }\n    return delta\n}\n\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val N = sc.nextInt()\n    val a = Array(N, { arrayOf(java.lang.Double.parseDouble(sc.next()), java.lang.Double.parseDouble(sc.next())) })\n    val ans = solve(a)\n    println(BigDecimal.valueOf(ans).toPlainString())\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigDecimal\nimport java.util.*\n\n\nfun solve(a: Array<Array<Double>>, sortedAxis: Int = -1): Double {\n    if (a.size <= 3) {\n        var dist = 1000000000000.0\n        for ((i, p1) in a.withIndex()) {\n            for (p2 in a.takeLast(a.size-i-1)) {\n                dist = Math.min(dist, Math.sqrt(Math.pow(p1[0]-p2[0], 2.0)+Math.pow(p1[1]-p2[1], 2.0)))\n            }\n        }\n        return dist\n    }\n\n    val mid = a.size/2\n    val xSetLen = a.map { it -> it[0] }.toHashSet().size\n    val (axis1, axis2) = if (xSetLen >= mid) Pair(0, 1) else Pair(1, 0)\n    if (axis1 != sortedAxis) a.sortBy { it[axis1] }\n\n    val leftArray = a.sliceArray(0 until mid)\n    val rightArray = a.sliceArray(mid until a.size)\n    var delta = Math.min(solve(leftArray, axis1), solve(rightArray, axis1))\n    val median = a[mid][axis1]\n    val mid_a = a.filter { it[axis1] in median-delta..median+delta }.sortedBy { it[axis2] }\n\n    for (i in 0 until mid_a.size-1) {\n        val ub = mid_a[i][axis2] + delta\n        for (j in i+1 until mid_a.size) {\n            if (mid_a[i][axis2] >= ub) break\n            delta = Math.min(delta,\n                    Math.sqrt(Math.pow(mid_a[i][0]-mid_a[j][0], 2.0)+Math.pow(mid_a[i][1]-mid_a[j][1], 2.0)))\n        }\n    }\n\n    return delta\n}\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val N = sc.nextInt()\n    val a = Array(N, { arrayOf(sc.nextDouble(), sc.nextDouble()) })\n    val ans = solve(a)\n    println(BigDecimal.valueOf(ans).toPlainString())\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigDecimal\nimport java.util.*\n\n\nfun solve(a: Array<Array<Double>>, sortedAxis: Int = -1): Double {\n    if (a.size <= 3) {\n        var dist = 1000000000000.0\n        for ((i, p1) in a.withIndex()) {\n            for (p2 in a.takeLast(a.size-i-1)) {\n                dist = Math.min(dist, Math.sqrt(Math.pow(p1[0]-p2[0], 2.0)+Math.pow(p1[1]-p2[1], 2.0)))\n            }\n        }\n        return dist\n    }\n\n    val mid = a.size/2\n    val xSetLen = a.map { it -> it[0] }.toHashSet().size\n    val (axis1, axis2) = if (xSetLen >= mid) Pair(0, 1) else Pair(1, 0)\n    if (axis1 != sortedAxis) a.sortBy { it[axis1] }\n\n    val leftArray = a.sliceArray(0 until mid)\n    val rightArray = a.sliceArray(mid until a.size)\n    var delta = Math.min(\n            solve(leftArray, axis1),\n            solve(rightArray, axis1)\n    )\n    val median = a[mid][axis1]\n\n    for (i in 0 until a.size-1) {\n        if (a[i][axis2] < median-delta) continue\n        else if (a[i][axis2] > median+delta) break\n        val ub = a[i][axis2] + delta\n        for (j in i+1 until a.size) {\n            if (a[i][axis2] >= ub) break\n            delta = Math.min(delta,\n                    Math.sqrt(Math.pow(a[i][0]-a[j][0], 2.0)+Math.pow(a[i][1]-a[j][1], 2.0)))\n        }\n    }\n    return delta\n}\n\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val N = sc.nextInt()\n    val a = Array(N, { arrayOf(java.lang.Double.parseDouble(sc.next()), java.lang.Double.parseDouble(sc.next())) })\n    val ans = solve(a)\n    println(BigDecimal.valueOf(ans).toPlainString())\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigDecimal\nimport java.util.*\n\nclass Point(val x: Double, val y: Double) {\n    operator fun minus(other: Point): Double {\n        return Math.sqrt(Math.pow(this.x-other.x, 2.0)+Math.pow(this.y-other.y, 2.0))\n    }\n    operator fun get(i: Int): Double = if (i == 0) x else y\n}\nfun solve(a: Array<Point>): Double {\n    if (a.size <= 3) {\n        var dist = 1000000000000.0\n        for (i in 0 until a.size-1) {\n            for (j in i+1 until a.size) dist = Math.min(dist, a[i]-a[j])\n        }\n        return dist\n    }\n\n    val mid = a.size/2\n    val xSetLen = a.map { it -> it.x }.toHashSet().size\n    val (axis1, axis2) = if (xSetLen >= mid) Pair(0, 1) else Pair(1, 0)\n    a.sortBy { it[axis1] }\n    var delta = Math.min(\n            solve(a.sliceArray(0 until mid)),\n            solve(a.sliceArray(mid until a.size))\n    )\n    val median = a[mid][axis1]\n    val mid_a = a.filter { it[axis1] in median-delta..median+delta }.sortedBy { it[axis2] }\n    for (i in 0 until mid_a.size-1) {\n        val ub = mid_a[i][axis2] + delta\n        for (j in i+1 until mid_a.size) {\n            if (mid_a[i][axis2] >= ub) break\n            delta = Math.min(delta, mid_a[i]-mid_a[j])\n        }\n    }\n\n    return delta\n}\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val N = sc.nextInt()\n    val a = Array(N, { Point(sc.nextDouble(), sc.nextDouble()) })\n    val ans = solve(a)\n    println(BigDecimal.valueOf(ans).toPlainString())\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.math.BigDecimal\nimport java.util.*\n\n\nfun solve(a: Array<Array<Double>>, sortedAxis: Int = -1): Double {\n    if (a.size <= 3) {\n        var dist = 1000000000000.0\n        for ((i, p1) in a.withIndex()) {\n            for (p2 in a.takeLast(a.size-i-1)) {\n                dist = Math.min(dist, Math.sqrt(Math.pow(p1[0]-p2[0], 2.0)+Math.pow(p1[1]-p2[1], 2.0)))\n            }\n        }\n        return dist\n    }\n\n    val mid = a.size/2\n    val xSetLen = a.map { it -> it[0] }.toHashSet().size\n    val (axis1, axis2) = if (xSetLen >= mid) Pair(0, 1) else Pair(1, 0)\n    if (axis1 != sortedAxis) a.sortBy { it[axis1] }\n\n    val leftArray = a.sliceArray(0 until mid)\n    val rightArray = a.sliceArray(mid until a.size)\n    var delta = Math.min(solve(leftArray, axis1), solve(rightArray, axis1))\n    val median = a[mid][axis1]\n    val mid_a = a.filter { it[axis1] in median-delta..median+delta }.sortedBy { it[axis2] }\n\n    for (i in 0 until mid_a.size-1) {\n        val ub = mid_a[i][axis2] + delta\n        for (j in i+1 until mid_a.size) {\n            if (mid_a[i][axis2] >= ub) break\n            delta = Math.min(delta,\n                    Math.sqrt(Math.pow(mid_a[i][0]-mid_a[j][0], 2.0)+Math.pow(mid_a[i][1]-mid_a[j][1], 2.0)))\n        }\n    }\n\n    return delta\n}\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val N = sc.nextInt()\n    val a = Array(N, { arrayOf(java.lang.Double.parseDouble(sc.next()), java.lang.Double.parseDouble(sc.next())) })\n    val ans = solve(a)\n    println(BigDecimal.valueOf(ans).toPlainString())\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.math.BigInteger;\n \npublic class Main implements Runnable {\n\t\n\tstatic int mod = 1000000007;\n\tstatic double dp[][][][][][];\n\t\n    public static void main(String[] args) {\n    \tnew Thread(null, new Main(), \"\", 1024 * 1024 * 1024).start();\n    }\n    \n    public void run() {\n        PrintWriter out = new PrintWriter(System.out);\n        FastScanner sc = new FastScanner();\n         \n        int n = sc.nextInt();\n         \n        Point[] list = new Point[n];\n         \n        for(int i=0;i<n;i++){\n            list[i] = new Point(sc.nextDouble(),sc.nextDouble());\n        }\n         \n        out.printf(\"%.10f\",closestPair(list));\n         \n        out.flush();\n    }\n     \n    double closestPair(Point[] list){\n        Arrays.sort(list);\n        return closestPair(list,0,list.length);\n    }\n    double closestPair(Point[] list, int l, int r){\n        int n = r-l;\n        if(n<=1){\n            return Double.POSITIVE_INFINITY;    //1点しかない\n        }\n        if(n==2){\n            return list[l].dist(list[l+1]);\n        }\n          \n        int m = (l+r)/2;\n          \n        //左半分と右半分の最近点対の距離のうち小さい方\n        double d = Math.min(closestPair(list,l,m), closestPair(list,m,r));\n         \n        //左半分と右半分にまたがる点対のチェック\n        int centersize = 0;\n        double lmedX = list[m-1].x;\n        double rmedX = list[m].x;\n        \n        for(int i=l;i<m;i++){\n            if(rmedX - list[i].x <= d){\n                centersize++;\n            }\n        }\n        for(int i=m;i<r;i++){\n            if(list[i].x - lmedX <= d){\n                centersize++;\n            }\n        }\n        Point[] center = new Point[centersize];\n        int nowid = 0;\n        \n        for(int i=l;i<m;i++){\n            if(rmedX - list[i].x <= d){\n                center[nowid] = list[i];\n                nowid++;\n            }\n        }\n        for(int i=m;i<r;i++){\n            if(list[i].x - lmedX <= d){\n                center[nowid] = list[i];\n                nowid++;\n            }\n        }\n         \n        Arrays.sort(center, (i,j) -> Double.compare(i.y, j.y)); //y座標でソート\n         \n        for(int i=0;i<center.length;i++){\n            for(int j=i+1;j<center.length;j++){\n                Point pi = center[i];\n                Point pj = center[j];\n                double xdif = Math.abs(pi.x - pj.x);\n                if(xdif>=d){\n                    continue;\n                }\n                double ydif = pj.y - pi.y;\n                if(ydif>=d){\n                    break;\n                }\n                //ここに到達する点が各iに対し定数個で抑えられる\n                double nowd = Math.sqrt(xdif*xdif + ydif*ydif);\n                  \n                if(nowd < d){\n                    d = nowd;\n                }\n            }\n        }\n          \n        return d;\n    }\n}\n\nclass Point implements Comparable<Point>{\n    double x,y;\n    static final double eps = 0.00000001;\n     \n    public Point(double a, double b){\n        this.x = a;\n        this.y = b;\n    }\n     \n    //距離の2乗\n    public double d2(Point b){\n        return (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y);\n    }\n     \n    //通常のユークリッド距離\n    public double dist(Point b){\n        return Math.sqrt((x-b.x)*(x-b.x) + (y-b.y)*(y-b.y));\n    }\n     \n    //p1へのベクトルからみてp2へのベクトルが反時計回りなら1、時計回りなら2\n    //↑が同一直線状にあるとき、→p2が→p1と反対側なら3、→p2が→p1の延長線上なら4、→p2が→p1上にあれば5を返す\n    int direction(Point p1, Point p2){\n         \n        //p0 != p1は仮定、p2は分からない\n        if(p2.x == x && p2.y == y){\n            return 5;\n        }\n         \n        //外積の第三成分 = |→p1||→p2|sinθ\n        double det = (p1.x -x)*(p2.y-y) - (p2.x -x)*(p1.y - y);\n         \n        if(det>eps){\n            return 1;\n        }\n        else if(det<-eps){\n            return 2;\n        }\n        else{   //同一直線状\n            if((p1.x-x >0 == p2.x-x <0) && p1.x-x != 0){  //反対側\n                return 3;\n            }\n            else if((p1.y-y >0 == p2.y-y <0) && p1.y-y != 0){ //反対側\n                return 3;\n            }\n            else{\n                double d10 = d2(p1);    //p1とp0の距離^2\n                double d20 = d2(p2);    //p2とp0の距離^2\n                if(d10 < d20){   //p2のほうが遠い\n                    return 4;\n                }\n                else{\n                    return 5;\n                }\n            }\n        }\n         \n    }\n \n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        long temp;\n        temp = Double.doubleToLongBits(x);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        temp = Double.doubleToLongBits(y);\n        result = prime * result + (int) (temp ^ (temp >>> 32));\n        return result;\n    }\n \n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        Point other = (Point) obj;\n        if (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x))\n            return false;\n        if (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y))\n            return false;\n        return true;\n    }\n     \n    @Override\n    public int compareTo(Point o){\n        if(x!=o.x){\n            return Double.compare(x,o.x);\n        }\n        return Double.compare(y, o.y);\n    }\n \n}\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic int[] nextintArray(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic long[] nextlongArray(int n){\n\t\tlong[] a = new long[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic Integer[] nextIntegerArray(int n){\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic int[][] nextintMatrix(int h, int w){\n\t\tint[][] mat = new int[h][w];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tmat[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn mat;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static ArrayList<ArrayList<Double[]>> splitpair(ArrayList<Double[]> px, ArrayList<Double[]> py, double d) {  \n            double xBar = px.get(px.size()/2)[0]; // largest x-coordinate of the left half of px\n            ArrayList<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.size(); i++) {\n                if (xBar - d <= py.get(i)[0] && py.get(i)[0]<= xBar + d) { //only consider a 'strip' \n                    // around xBar that is 2*d wide\n                    Sy.add(py.get(i)); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            ArrayList<ArrayList<Double[]>> bestpair = new ArrayList<ArrayList<Double[]>>(); // the coords of the best pair of points so far\n            bestpair = null;\n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair = convertToForm(p,q);\n                        bestD = dist(p, q);\n                    }\n                }\n            }\n            \n            return bestpair;\n        }\n   \n        public static ArrayList<ArrayList<Double[]>> convertToForm(Double[] x, Double[] y) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> pysByY = new ArrayList<Double[]>();\n            ptsByX.add(x); ptsByX.add(y); pysByY.add(x); pysByY.add(y);\n            // to get sorted by x-coord then sorted by y-coord, first sort by y-coord\n            // then sort by x-coord (since Arrays.sort is stable)\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res.add(ptsByX); res.add(pysByY);\n            return res;\n        }\n\n        public static ArrayList<ArrayList<Double[]>> solve(ArrayList<ArrayList<Double[]>> P) { \n            ArrayList<Double[]> Px = new ArrayList<Double[]>();\n            ArrayList<Double[]> Py = new ArrayList<Double[]>();\n            Px = P.get(0); Py = P.get(1);            \n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.size() == 2) {\n                return P;\n            } else if (Px.size() == 3) {\n                Double[] p1 = Px.get(0); Double[] p2 = Px.get(1); Double[] p3 = Px.get(2);\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (d12 - Math.pow(10, -8) <= minD && minD <= d12 + Math.pow(10, -8)) {\n                    return convertToForm(p1, p2);\n                } else if (d13 - Math.pow(10, -8) <= minD && minD <= d13 + Math.pow(10, -8)) {\n                    return convertToForm(p1, p3);\n                } else if (d23 - Math.pow(10, -8) <= minD && minD <= d23 + Math.pow(10, -8)) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3);\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.size();\n                assert L > 1;\n                ArrayList<Double[]> Qx = new ArrayList<Double[]>();\n                ArrayList<Double[]> Rx = new ArrayList<Double[]>();\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx.add(Px.get(i));\n                    } else {\n                        Rx.add(Px.get(i));\n                    }\n                }\n                ArrayList<Double[]> Qy = new ArrayList<Double[]>();\n                ArrayList<Double[]> Ry = new ArrayList<Double[]>();\n                Double k = Qx.get(Qx.size()-1)[0]; \n                Double l = Qx.get(Qx.size()-1)[1];\n                for (int i=0; i < Py.size(); i++) {\n                    Double[] pt = Py.get(i);\n                    if (pt[0] < k) {\n                        Qy.add(pt);\n                    } else if (pt[0] == k) {\n                        if (pt[1] <= l) {\n                            Qy.add(pt);\n                        } else {\n                           Ry.add(pt);\n                        }\n                    } else {\n                        Ry.add(pt);\n                    }\n                }\n                assert Qy.size() == Qx.size();\n                assert Ry.size() == Rx.size();\n                assert Qx.size() >= 2;\n                \n                // now use recursion\n                ArrayList<ArrayList<Double[]>> Q = new ArrayList<ArrayList<Double[]>>();\n                ArrayList<ArrayList<Double[]>> R = new ArrayList<ArrayList<Double[]>>();\n                Q.add(Qx); Q.add(Qy); R.add(Rx); R.add(Ry);\n                assert Q.size() >= 2;\n                ArrayList<ArrayList<Double[]>> c1 = solve(Q);\n                ArrayList<ArrayList<Double[]>> c2 = solve(R);\n                Double Dc1 = dist(c1.get(0).get(0), c1.get(0).get(1)); // returns SQUARED distance\n                Double Dc2 = dist(c2.get(0).get(0), c2.get(0).get(1)); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                ArrayList<ArrayList<Double[]>> bestpair = new ArrayList<ArrayList<Double[]>>();\n                \n                if (Dc1 - Math.pow(10, -8) <= D && D <= Dc1 + Math.pow(10, -8)) {\n                    bestpair = c1;\n                } else if (Dc2 - Math.pow(10, -8) <= D && D <= Dc2 + Math.pow(10, -8)) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                ArrayList<ArrayList<Double[]>> c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return bestpair;\n            }\n        }\n\n        public static void main(String[] args) {   \n            Scanner scan = new Scanner(System.in);\n            int N = scan.nextInt();\n            \n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> ptsByY = new ArrayList<Double[]>();\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {scan.nextDouble()*1000, scan.nextDouble()*1000};\n                ptsByX.add(coords); ptsByY.add(coords);\n            }\n            scan.close();\n            \n            // now sort by x coord\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> P = new ArrayList<ArrayList<Double[]>>();\n            P.add(ptsByX); P.add(ptsByY);\n            assert P.size() == 2;\n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res = solve(P);\n            \n            System.out.println(Math.pow(dist(res.get(0).get(0), res.get(0).get(1)), 0.5)/1000.0);\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// 入力\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tList<Vector2d> p = new ArrayList<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x = sc.nextDouble();\n\t\t\tdouble y = sc.nextDouble();\n\t\t\tp.add(new Vector2d(x, y));\n\t\t}\n\t\tsc.close();\n\t\tp.sort(new Vector2dComparator());\n\t\tSystem.out.println(solve(p));\n\t}\n\n\tstatic class Vector2d {\n\t\tVector2d(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"%1$.6f %2$.6f\", x, y);\n\t\t}\n\n\t\tpublic static double norm(Vector2d v1, Vector2d v2) {\n\t\t\treturn Math.sqrt(Math.pow(v2.x - v1.x, 2) + Math.pow(v2.y - v1.y, 2));\n\t\t}\n\n\t}\n\n\tstatic class Vector2dComparator implements Comparator<Vector2d> {\n\t\t@Override\n\t\tpublic int compare(Vector2d v1, Vector2d v2) {\n\t\t\tdouble x = v1.x - v2.x;\n\t\t\tdouble y = v1.y - v2.y;\n\t\t\tif (x == 0) {\n\t\t\t\tif (y < 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else if (x < 0) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static double solve(List<Vector2d> p) {\n\n\t\tdouble d;\n\t\tif (p.size() == 1) {\n\t\t\t// 点が1個の場合は距離∞\n\t\t\td = Double.MAX_VALUE;\n\t\t} else if (p.size() == 2) {\n\t\t\t// 点が2個の場合は普通に計算\n\t\t\td = Vector2d.norm(p.get(0), p.get(1));\n\t\t} else {\n\t\t\t// 3個以上の場合は、まず左半分と右半分の最小距離の小さい方\n\t\t\tdouble dTemp = Math.min(solve(p.subList(0, p.size() / 2)), solve(p.subList(p.size() / 2, p.size())));\n\t\t\t// そのあと、左と右の間でdを更新できるペアを探す\n\t\t\t// 左右間ペア候補を絞る\n\t\t\tdouble midX = p.get(p.size() / 2).x;\n\t\t\tList<Vector2d> yl = p.stream().filter(v -> 0 < midX - v.x && midX - v.x <= dTemp).collect(Collectors.toList());\n\t\t\tList<Vector2d> yr = p.stream().filter(v -> 0 <= v.x - midX && v.x - midX <= dTemp).collect(Collectors.toList());\n\t\t\t// 左右間ペアでdを更新\n\t\t\td = updateByLRPair(yl, yr, dTemp);\n\t\t}\n\t\treturn d;\n\t}\n\n\t// 左右間ペアでdを更新\n\tpublic static double updateByLRPair(List<Vector2d> yl, List<Vector2d> yr, double d) {\n\t\tdouble ans = d;\n\t\tfor(Vector2d vl: yl) {\n\t\t\tfor(Vector2d vr: yr.stream().filter(v -> Math.abs(v.y - vl.y) <= d).collect(Collectors.toList())) {\n\t\t\t\tif(ans > Vector2d.norm(vl, vr)) {\n\t\t\t\t\tans = Vector2d.norm(vl, vr);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// 入力\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tList<Vector2d> p = new ArrayList<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x = sc.nextDouble();\n\t\t\tdouble y = sc.nextDouble();\n\t\t\tp.add(new Vector2d(x, y));\n\t\t}\n\t\tsc.close();\n\t\tp.sort(new Vector2dComparator());\n\t\tSystem.out.println(String.format(\"%1$.6f\", solve(p)));\n\t}\n\n\tstatic class Vector2d {\n\t\tVector2d(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"%1$.6f %2$.6f\", x, y);\n\t\t}\n\n\t\tpublic static double norm(Vector2d v1, Vector2d v2) {\n\t\t\treturn Math.sqrt(Math.pow(v2.x - v1.x, 2) + Math.pow(v2.y - v1.y, 2));\n\t\t}\n\n\t}\n\n\tstatic class Vector2dComparator implements Comparator<Vector2d> {\n\t\t@Override\n\t\tpublic int compare(Vector2d v1, Vector2d v2) {\n\t\t\tdouble x = v1.x - v2.x;\n\t\t\tdouble y = v1.y - v2.y;\n\t\t\tif (x == 0) {\n\t\t\t\tif (y < 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else if (x < 0) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static double solve(List<Vector2d> p) {\n\n\t\tdouble d;\n\t\tif (p.size() == 1) {\n\t\t\t// 点が1個の場合は距離∞\n\t\t\td = Double.MAX_VALUE;\n\t\t} else if (p.size() == 2) {\n\t\t\t// 点が2個の場合は普通に計算\n\t\t\td = Vector2d.norm(p.get(0), p.get(1));\n\t\t} else {\n\t\t\t// 3個以上の場合は、まず左半分と右半分の最小距離の小さい方\n\t\t\tdouble dTemp = Math.min(solve(p.subList(0, p.size() / 2)), solve(p.subList(p.size() / 2, p.size())));\n\t\t\t// そのあと、左と右の間でdを更新できるペアを探す\n\t\t\t// 左右間ペア候補を絞る\n\t\t\tdouble midX = p.get(p.size() / 2).x;\n\t\t\tList<Vector2d> yl = p.stream().filter(v -> 0 < midX - v.x && midX - v.x <= dTemp).collect(Collectors.toList());\n\t\t\tList<Vector2d> yr = p.stream().filter(v -> 0 <= v.x - midX && v.x - midX <= dTemp).collect(Collectors.toList());\n\t\t\t// 左右間ペアでdを更新\n\t\t\td = updateByLRPair(yl, yr, dTemp);\n\t\t}\n\t\treturn d;\n\t}\n\n\t// 左右間ペアでdを更新\n\tpublic static double updateByLRPair(List<Vector2d> yl, List<Vector2d> yr, double d) {\n\t\tdouble ans = d;\n\t\tfor(Vector2d vl: yl) {\n\t\t\tfor(Vector2d vr: yr.stream().filter(v -> Math.abs(v.y - vl.y) <= d).collect(Collectors.toList())) {\n\t\t\t\tif(ans > Vector2d.norm(vl, vr)) {\n\t\t\t\t\tans = Vector2d.norm(vl, vr);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.text.DecimalFormat;\n\nclass Main {\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static Double[][][] splitpair(Double[][] px, Double[][] py, double d) {  \n            double xBar = px[(px.length+1)/2][0]; // largest x-coordinate of the left half of px\n            List<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.length; i++) {\n                if (Math.abs(py[i][0] - xBar) < d + Math.pow(10,-10)) { //only consider a 'strip' \n     // around xBar that is 2*d wide\n                    Sy.add(py[i]); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            Double[][] bestpair = new Double[2][2]; // the coords of the best pair of points so far\n            int foundBetter = 0;\n   \n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair[0] = p; bestpair[1] = q;\n                        bestD = dist(p, q);\n                        foundBetter = 1;\n                    }\n                }\n            }\n            \n            if (foundBetter == 0) {\n                return null;\n            }\n            \n            Double[][][] res = new Double[2][2][2];\n            res = convertToForm(bestpair[0], bestpair[1]);\n            return res;\n        }\n   \n        public static Double[][][] convertToForm(Double[] a, Double[] b) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            Double[][] byX = {a, b};\n            Double[][] byY = {a, b};\n            // now sort by x coord\n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Double[][][] res = {byX, byY};\n            return res;\n        }\n\n        public static Double[][][] solve(Double[][][] P) { \n            Double[][] Px = P[0];\n            Double[][] Py = P[1];\n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.length == 2) {\n                return P;\n            } else if (Px.length == 3) {\n                Double[] p1 = Px[0]; Double[] p2 = Px[1]; Double[] p3 = Px[2];\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (Math.abs(d12 - minD) < Math.pow(10, -10)) {\n                    return convertToForm(p1, p2);\n                } else if (Math.abs(d13 - minD) < Math.pow(10, -10)) {\n                    return convertToForm(p1, p3);\n                } else if (Math.abs(d23 - minD)  < Math.pow(10, -10)) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3); // it fails here, this is just to return the right data struct\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.length;\n                assert L > 1;\n                Double[][] Qx = new Double[L/2][2];\n                Double[][] Rx = new Double[L-L/2][2];\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx[i] = Px[i];\n                    } else {\n                        Rx[i-L/2] = Px[i];\n                    }\n                }\n                Double[][] Qy = new Double[L/2][2];\n                Double[][] Ry = new Double[L-L/2][2];\n                Double k = Qx[Qx.length-1][0]; \n                Double l = Qx[Qx.length-1][1];\n                int cntQy = 0; int cntRy = 0; \n                for (int i=0; i < Py.length; i++) {\n                    Double[] pt = Py[i];\n                    if (pt[0] < k) {\n                        Qy[cntQy++] = pt;\n                    } else if (Math.abs(pt[0] - k) < Math.pow(10, -10)) {\n                        if (pt[1] <= l) {\n                            Qy[cntQy++] = pt;\n                        } else {\n                            Ry[cntRy++] = pt;\n                        }\n                    } else {\n                        Ry[cntRy++] = pt;\n                    }\n                }\n                \n                // now use recursion\n                Double[][][] Q = {Qx, Qy};\n                Double[][][] R = {Rx, Ry};\n                assert Q.length >= 2;\n                Double[][][] c1 = solve(Q);\n                Double[][][] c2 = solve(R);\n                Double Dc1 = dist(c1[0][0], c1[0][1]); // returns SQUARED distance\n                Double Dc2 = dist(c2[0][0], c2[0][1]); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                Double[][][] bestpair = new Double[2][2][2];\n                \n                if (Math.abs(Dc1 - D) < Math.pow(10, -10)) {\n                    bestpair = c1;\n                } else if (Math.abs(Dc2 - D) < Math.pow(10, -10)) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                Double[][][] c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return c3;\n            }\n        }\n        \n        public static void main(String[] args) {   \n            \n            // timer stuffs\n            long startTime = System.nanoTime();\n            \n            Scanner scan = new Scanner(System.in);\n            int N = scan.nextInt();\n            \n            Double[][] ptsByX = new Double[N][2];\n            Double[][] ptsByY = new Double[N][2];\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {scan.nextDouble(), scan.nextDouble()};\n                ptsByX[i] = coords; ptsByY[i] = coords;\n            }\n            scan.close();\n            \n            // sort by x coord\n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    if (Math.abs(doubles[0] - otherDoubles[0]) < Math.pow(10, -8)) {\n                        return doubles[1].compareTo(otherDoubles[1]); \n                    }\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            \n            // sort by y-coord\n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    if (Math.abs(doubles[1] - otherDoubles[1]) < Math.pow(10, -8)) {\n                        return doubles[0].compareTo(otherDoubles[0]); \n                    }\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            });\n            \n            Double[][][] P = new Double[2][N][2];\n            P[0] = ptsByX; P[1] = ptsByY;\n            assert P.length == 2;\n            \n            long endTime = System.nanoTime();\n            long duration = (endTime - startTime)/1000000;\n            //System.out.println(duration);\n            \n            Double[][][] res = new Double[2][2][2];\n            res = solve(P);\n           \n            DecimalFormat df = new DecimalFormat();\n            df.setMaximumFractionDigits(10);\n            System.out.println(df.format(Math.pow(dist(res[0][0], res[0][1]), 0.5)));\n            \n            endTime = System.nanoTime();\n            duration = (endTime - startTime)/1000000;\n           \n            //System.out.println(N);\n            //System.out.println(duration);\n            \n        }\n}import java.util.*;\nimport java.text.DecimalFormat;\n\nclass ClosestPair2 {\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static Double[][][] splitpair(Double[][] px, Double[][] py, double d) {  \n            double xBar = px[(px.length+1)/2][0]; // largest x-coordinate of the left half of px\n            List<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.length; i++) {\n                if (Math.abs(py[i][0] - xBar) < d + Math.pow(10,-10)) { //only consider a 'strip' \n     // around xBar that is 2*d wide\n                    Sy.add(py[i]); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            Double[][] bestpair = new Double[2][2]; // the coords of the best pair of points so far\n            int foundBetter = 0;\n   \n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair[0] = p; bestpair[1] = q;\n                        bestD = dist(p, q);\n                        foundBetter = 1;\n                    }\n                }\n            }\n            \n            if (foundBetter == 0) {\n                return null;\n            }\n            \n            Double[][][] res = new Double[2][2][2];\n            res = convertToForm(bestpair[0], bestpair[1]);\n            return res;\n        }\n   \n        public static Double[][][] convertToForm(Double[] a, Double[] b) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            Double[][] byX = {a, b};\n            Double[][] byY = {a, b};\n            // now sort by x coord\n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Double[][][] res = {byX, byY};\n            return res;\n        }\n\n        public static Double[][][] solve(Double[][][] P) { \n            Double[][] Px = P[0];\n            Double[][] Py = P[1];\n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.length == 2) {\n                return P;\n            } else if (Px.length == 3) {\n                Double[] p1 = Px[0]; Double[] p2 = Px[1]; Double[] p3 = Px[2];\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (Math.abs(d12 - minD) < Math.pow(10, -10)) {\n                    return convertToForm(p1, p2);\n                } else if (Math.abs(d13 - minD) < Math.pow(10, -10)) {\n                    return convertToForm(p1, p3);\n                } else if (Math.abs(d23 - minD)  < Math.pow(10, -10)) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3); // it fails here, this is just to return the right data struct\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.length;\n                assert L > 1;\n                Double[][] Qx = new Double[L/2][2];\n                Double[][] Rx = new Double[L-L/2][2];\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx[i] = Px[i];\n                    } else {\n                        Rx[i-L/2] = Px[i];\n                    }\n                }\n                Double[][] Qy = new Double[L/2][2];\n                Double[][] Ry = new Double[L-L/2][2];\n                Double k = Qx[Qx.length-1][0]; \n                Double l = Qx[Qx.length-1][1];\n                int cntQy = 0; int cntRy = 0; \n                for (int i=0; i < Py.length; i++) {\n                    Double[] pt = Py[i];\n                    if (pt[0] < k) {\n                        Qy[cntQy++] = pt;\n                    } else if (Math.abs(pt[0] - k) < Math.pow(10, -10)) {\n                        if (pt[1] <= l) {\n                            Qy[cntQy++] = pt;\n                        } else {\n                            Ry[cntRy++] = pt;\n                        }\n                    } else {\n                        Ry[cntRy++] = pt;\n                    }\n                }\n                \n                // now use recursion\n                Double[][][] Q = {Qx, Qy};\n                Double[][][] R = {Rx, Ry};\n                assert Q.length >= 2;\n                Double[][][] c1 = solve(Q);\n                Double[][][] c2 = solve(R);\n                Double Dc1 = dist(c1[0][0], c1[0][1]); // returns SQUARED distance\n                Double Dc2 = dist(c2[0][0], c2[0][1]); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                Double[][][] bestpair = new Double[2][2][2];\n                \n                if (Math.abs(Dc1 - D) < Math.pow(10, -10)) {\n                    bestpair = c1;\n                } else if (Math.abs(Dc2 - D) < Math.pow(10, -10)) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                Double[][][] c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return c3;\n            }\n        }\n        \n        public static void main(String[] args) {   \n            \n            // timer stuffs\n            long startTime = System.nanoTime();\n            \n            Scanner scan = new Scanner(System.in);\n            int N = scan.nextInt();\n            \n            Double[][] ptsByX = new Double[N][2];\n            Double[][] ptsByY = new Double[N][2];\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {scan.nextDouble(), scan.nextDouble()};\n                ptsByX[i] = coords; ptsByY[i] = coords;\n            }\n            scan.close();\n            \n            // sort by x coord\n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    if (Math.abs(doubles[0] - otherDoubles[0]) < Math.pow(10, -8)) {\n                        return doubles[1].compareTo(otherDoubles[1]); \n                    }\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            \n            // sort by y-coord\n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    if (Math.abs(doubles[1] - otherDoubles[1]) < Math.pow(10, -8)) {\n                        return doubles[0].compareTo(otherDoubles[0]); \n                    }\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            });\n            \n            Double[][][] P = new Double[2][N][2];\n            P[0] = ptsByX; P[1] = ptsByY;\n            assert P.length == 2;\n            \n            long endTime = System.nanoTime();\n            long duration = (endTime - startTime)/1000000;\n            //System.out.println(duration);\n            \n            Double[][][] res = new Double[2][2][2];\n            res = solve(P);\n           \n            DecimalFormat df = new DecimalFormat();\n            df.setMaximumFractionDigits(10);\n            System.out.println(df.format(Math.pow(dist(res[0][0], res[0][1]), 0.5)));\n            \n            endTime = System.nanoTime();\n            duration = (endTime - startTime)/1000000;\n           \n            //System.out.println(N);\n            //System.out.println(duration);\n            \n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.text.DecimalFormat;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n \nclass Main {\n \n  static final double EPS = 1e-12;\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n       public static Double dist(Double[] x, Double[] y) {     \n         return (x[0]-y[0])*(x[0]-y[0]) + (x[1]-y[1])*(x[1]-y[1]);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static Double[][][] splitpair(Double[][] px, Double[][] py, double d) {  \n            double xBar = px[(px.length+1)/2][0]; // largest x-coordinate of the left half of px\n            List<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.length; i++) {\n                if (xBar - d - EPS <= py[i][0] && py[i][0]<= xBar + d + EPS) { //only consider a 'strip' \n                    // around xBar that is 2*d wide\n                    Sy.add(py[i]); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            Double[][][] bestpair = new Double[2][2][2]; // the coords of the best pair of points so far\n            bestpair = null;\n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair = convertToForm(p,q);\n                        bestD = dist(p, q);\n                    }\n                }\n            }\n            return bestpair;\n        }\n   \n        public static Double[][][] convertToForm(Double[] a, Double[] b) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            Double[][] byX = {a, b};\n            Double[][] byY = {a, b};\n            // now sort by x coord\n            if (byX[0][0] > byX[1][0] || \n                (byX[0][0] == byX[1][0] && byX[0][1] > byX[1][1])) {\n              Double[] tmp = byX[0];\n              byX[0] = byX[1];\n              byX[1] = tmp;\n            }\n            \n            // sort by y-coord\n            if (byX[0][1] > byX[1][1] || \n                (byX[0][1] == byX[1][1] && byX[0][0] > byX[1][0])) {\n              Double[] tmp = byX[0];\n              byX[0] = byX[1];\n              byX[1] = tmp;\n            }\n            \n            Double[][][] res = {byX, byY};\n            return res;\n        }\n \n        public static Double[][][] solve(Double[][][] P) { \n            Double[][] Px = P[0];\n            Double[][] Py = P[1];\n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.length == 2) {\n                return P;\n            } else if (Px.length == 3) {\n                Double[] p1 = Px[0]; Double[] p2 = Px[1]; Double[] p3 = Px[2];\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (Math.abs(d12 - minD) < EPS) {\n                    return convertToForm(p1, p2);\n                } else if (Math.abs(d13 - minD) < EPS) {\n                    return convertToForm(p1, p3);\n                } else if (Math.abs(d23 - minD) < EPS) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3); // it fails here, this is just to return the right data struct\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.length;\n                assert L > 1;\n                Double[][] Qx = new Double[L/2][2];\n                Double[][] Rx = new Double[L-L/2][2];\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx[i] = Px[i];\n                    } else {\n                        Rx[i-L/2] = Px[i];\n                    }\n                }\n                Double[][] Qy = new Double[L/2][2];\n                Double[][] Ry = new Double[L-L/2][2];\n                Double k = Qx[Qx.length-1][0]; \n                Double l = Qx[Qx.length-1][1];\n                int cntQy = 0; int cntRy = 0; \n                for (int i=0; i < Py.length; i++) {\n                    Double[] pt = Py[i];\n                    if (pt[0] < k) {\n                        Qy[cntQy++] = pt;\n                    } else if (Math.abs(pt[0] - k) < EPS) {\n                        if (pt[1] - l <= EPS) {\n                            Qy[cntQy++] = pt;\n                        } else {\n                            Ry[cntRy++] = pt;\n                        }\n                    } else {\n                        Ry[cntRy++] = pt;\n                    }\n                }\n                \n                // now use recursion\n                Double[][][] Q = {Qx, Qy};\n                Double[][][] R = {Rx, Ry};\n                assert Q.length >= 2;\n                Double[][][] c1 = solve(Q);\n                Double[][][] c2 = solve(R);\n                Double Dc1 = dist(c1[0][0], c1[0][1]); // returns SQUARED distance\n                Double Dc2 = dist(c2[0][0], c2[0][1]); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                Double[][][] bestpair = new Double[2][2][2];\n                \n                if (Math.abs(Dc1 - D) < EPS) {\n                    bestpair = c1;\n                } else if (Math.abs(Dc2 - D) < EPS) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                Double[][][] c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return c3;\n            }\n        }\n        \n        public static void main(String[] args) {   \n \n            InputStream inputStream = System.in;\n            InputReader in = new InputReader(inputStream);\n            \n            // timer stuffs\n            long startTime = System.nanoTime();\n            \n            int N = in.nextInt();\n            \n            Double[][] ptsByX = new Double[N][2];\n            Double[][] ptsByY = new Double[N][2];\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {in.nextDouble(), in.nextDouble()};\n                ptsByX[i] = coords; ptsByY[i] = coords;\n            }\n            \n            // sort by x coord\n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            \n            // sort by y-coord\n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            \n            Double[][][] P = new Double[2][N][2];\n            P[0] = ptsByX; P[1] = ptsByY;\n            \n            //long endTime = System.nanoTime();\n            //long duration = (endTime - startTime)/1000000;\n            //System.out.printf(\"%d ms\\n\", duration);\n            \n            Double[][][] res = new Double[2][2][2];\n            res = solve(P);\n           \n            DecimalFormat df = new DecimalFormat();\n            df.setMaximumFractionDigits(10);\n            System.out.println(df.format(Math.pow(dist(res[0][0], res[0][1]), 0.5)));\n            \n            long endTime = System.nanoTime();\n            long duration = (endTime - startTime)/1000000;\n           \n            //System.out.printf(\"Num points: %d\\n\", N);\n            //System.out.printf(\"%d ms\\n\", duration);\n            \n        }\n}\n \nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n \n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n \n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n \n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n \n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.text.DecimalFormat;\nimport java.io.*;\n\nclass Main {\n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static Double[][][] splitpair(Double[][] px, Double[][] py, double d) {  \n            double xBar = px[(px.length+1)/2][0]; // largest x-coordinate of the left half of px\n            List<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.length; i++) {\n                if (Math.abs(py[i][0] - xBar) < d + Math.pow(10,-10)) { //only consider a 'strip' \n     // around xBar that is 2*d wide\n                    Sy.add(py[i]); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            Double[][] bestpair = new Double[2][2]; // the coords of the best pair of points so far\n            int foundBetter = 0;\n   \n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair[0] = p; bestpair[1] = q;\n                        bestD = dist(p, q);\n                        foundBetter = 1;\n                    }\n                }\n            }\n            \n            if (foundBetter == 0) {\n                return null;\n            }\n            \n            Double[][][] res = new Double[2][2][2];\n            res = convertToForm(bestpair[0], bestpair[1]);\n            return res;\n        }\n   \n        public static Double[][][] convertToForm(Double[] a, Double[] b) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            Double[][] byX = {a, b};\n            Double[][] byY = {a, b};\n            // now sort by x coord\n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Double[][][] res = {byX, byY};\n            return res;\n        }\n\n        public static Double[][][] solve(Double[][][] P) { \n            Double[][] Px = P[0];\n            Double[][] Py = P[1];\n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.length == 2) {\n                return P;\n            } else if (Px.length == 3) {\n                Double[] p1 = Px[0]; Double[] p2 = Px[1]; Double[] p3 = Px[2];\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (Math.abs(d12 - minD) < Math.pow(10, -10)) {\n                    return convertToForm(p1, p2);\n                } else if (Math.abs(d13 - minD) < Math.pow(10, -10)) {\n                    return convertToForm(p1, p3);\n                } else if (Math.abs(d23 - minD)  < Math.pow(10, -10)) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3); // it fails here, this is just to return the right data struct\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.length;\n                assert L > 1;\n                Double[][] Qx = new Double[L/2][2];\n                Double[][] Rx = new Double[L-L/2][2];\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx[i] = Px[i];\n                    } else {\n                        Rx[i-L/2] = Px[i];\n                    }\n                }\n                Double[][] Qy = new Double[L/2][2];\n                Double[][] Ry = new Double[L-L/2][2];\n                Double k = Qx[Qx.length-1][0]; \n                Double l = Qx[Qx.length-1][1];\n                int cntQy = 0; int cntRy = 0; \n                for (int i=0; i < Py.length; i++) {\n                    Double[] pt = Py[i];\n                    if (pt[0] < k) {\n                        Qy[cntQy++] = pt;\n                    } else if (Math.abs(pt[0] - k) < Math.pow(10, -10)) {\n                        if (pt[1] <= l) {\n                            Qy[cntQy++] = pt;\n                        } else {\n                            Ry[cntRy++] = pt;\n                        }\n                    } else {\n                        Ry[cntRy++] = pt;\n                    }\n                }\n                \n                // now use recursion\n                Double[][][] Q = {Qx, Qy};\n                Double[][][] R = {Rx, Ry};\n                assert Q.length >= 2;\n                Double[][][] c1 = solve(Q);\n                Double[][][] c2 = solve(R);\n                Double Dc1 = dist(c1[0][0], c1[0][1]); // returns SQUARED distance\n                Double Dc2 = dist(c2[0][0], c2[0][1]); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                Double[][][] bestpair = new Double[2][2][2];\n                \n                if (Math.abs(Dc1 - D) < Math.pow(10, -10)) {\n                    bestpair = c1;\n                } else if (Math.abs(Dc2 - D) < Math.pow(10, -10)) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                Double[][][] c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return c3;\n            }\n        }\n        \n        public static void main(String[] args) throws IOException  {   \n            \n            // timer stuffs\n            long startTime = System.nanoTime();\n            \n            //Scanner scan = new Scanner(System.in);\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            \n            int N = Integer.parseInt(br.readLine()); // read first line as int\n            \n            Double[][] ptsByX = new Double[N][2];\n            Double[][] ptsByY = new Double[N][2];\n            \n            String line;\n            for (int n = 0; n < N; n++) {\n                line = br.readLine();\n                Double[] coords = new Double[2];\n                coords[0] = Double.parseDouble(line.split(\" \")[0]);\n                coords[1] = Double.parseDouble(line.split(\" \")[1]);\n                ptsByX[n] = coords; ptsByY[n] = coords;\n            }\n            \n            br.close();\n            \n            long endTime = System.nanoTime();\n            long duration = (endTime - startTime)/1000000;\n            //System.out.println(duration);\n            \n            // sort by x coord\n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            \n            // sort by y-coord\n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            Double[][][] P = new Double[2][N][2];\n            P[0] = ptsByX; P[1] = ptsByY;\n            assert P.length == 2;\n            \n            endTime = System.nanoTime();\n            duration = (endTime - startTime)/1000000;\n            //System.out.println(duration);\n            \n            Double[][][] res = new Double[2][2][2];\n            res = solve(P);\n           \n            DecimalFormat df = new DecimalFormat();\n            df.setMaximumFractionDigits(10);\n            System.out.println(df.format(Math.pow(dist(res[0][0], res[0][1]), 0.5)));\n            \n            endTime = System.nanoTime();\n            duration = (endTime - startTime)/1000000;\n           \n            //System.out.println(N);\n            //System.out.println(duration);\n            \n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static ArrayList<ArrayList<Double[]>> splitpair(ArrayList<Double[]> px, ArrayList<Double[]> py, double d) {  \n            double xBar = px.get(px.size()/2)[0]; // largest x-coordinate of the left half of px\n            ArrayList<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.size(); i++) {\n                if (xBar - d <= py.get(i)[0] && py.get(i)[0]<= xBar + d) { //only consider a 'strip' \n                    // around xBar that is 2*d wide\n                    Sy.add(py.get(i)); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            ArrayList<ArrayList<Double[]>> bestpair = new ArrayList<ArrayList<Double[]>>(); // the coords of the best pair of points so far\n            bestpair = null;\n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair = convertToForm(p,q);\n                        bestD = dist(p, q);\n                    }\n                }\n            }\n            \n            return bestpair;\n        }\n   \n        public static ArrayList<ArrayList<Double[]>> convertToForm(Double[] x, Double[] y) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> pysByY = new ArrayList<Double[]>();\n            ptsByX.add(x); ptsByX.add(y); pysByY.add(x); pysByY.add(y);\n            // to get sorted by x-coord then sorted by y-coord, first sort by y-coord\n            // then sort by x-coord (since Arrays.sort is stable)\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res.add(ptsByX); res.add(pysByY);\n            return res;\n        }\n\n        public static ArrayList<ArrayList<Double[]>> solve(ArrayList<ArrayList<Double[]>> P) { \n            ArrayList<Double[]> Px = new ArrayList<Double[]>();\n            ArrayList<Double[]> Py = new ArrayList<Double[]>();\n            Px = P.get(0); Py = P.get(1);            \n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.size() == 2) {\n                return P;\n            } else if (Px.size() == 3) {\n                Double[] p1 = Px.get(0); Double[] p2 = Px.get(1); Double[] p3 = Px.get(2);\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (d12 - Math.pow(10, -8) <= minD && minD <= d12 + Math.pow(10, -8)) {\n                    return convertToForm(p1, p2);\n                } else if (d13 - Math.pow(10, -8) <= minD && minD <= d13 + Math.pow(10, -8)) {\n                    return convertToForm(p1, p3);\n                } else if (d23 - Math.pow(10, -8) <= minD && minD <= d23 + Math.pow(10, -8)) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3);\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.size();\n                assert L > 1;\n                ArrayList<Double[]> Qx = new ArrayList<Double[]>();\n                ArrayList<Double[]> Rx = new ArrayList<Double[]>();\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx.add(Px.get(i));\n                    } else {\n                        Rx.add(Px.get(i));\n                    }\n                }\n                ArrayList<Double[]> Qy = new ArrayList<Double[]>();\n                ArrayList<Double[]> Ry = new ArrayList<Double[]>();\n                Double k = Qx.get(Qx.size()-1)[0]; \n                Double l = Qx.get(Qx.size()-1)[1];\n                for (int i=0; i < Py.size(); i++) {\n                    Double[] pt = Py.get(i);\n                    if (pt[0] < k) {\n                        Qy.add(pt);\n                    } else if (pt[0] == k) {\n                        if (pt[1] <= l) {\n                            Qy.add(pt);\n                        } else {\n                           Ry.add(pt);\n                        }\n                    } else {\n                        Ry.add(pt);\n                    }\n                }\n                assert Qy.size() == Qx.size();\n                assert Ry.size() == Rx.size();\n                assert Qx.size() >= 2;\n                \n                // now use recursion\n                ArrayList<ArrayList<Double[]>> Q = new ArrayList<ArrayList<Double[]>>();\n                ArrayList<ArrayList<Double[]>> R = new ArrayList<ArrayList<Double[]>>();\n                Q.add(Qx); Q.add(Qy); R.add(Rx); R.add(Ry);\n                assert Q.size() >= 2;\n                ArrayList<ArrayList<Double[]>> c1 = solve(Q);\n                ArrayList<ArrayList<Double[]>> c2 = solve(R);\n                Double Dc1 = dist(c1.get(0).get(0), c1.get(0).get(1)); // returns SQUARED distance\n                Double Dc2 = dist(c2.get(0).get(0), c2.get(0).get(1)); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                ArrayList<ArrayList<Double[]>> bestpair = new ArrayList<ArrayList<Double[]>>();\n                \n                if (Dc1 - Math.pow(10, -8) <= D && D <= Dc1 + Math.pow(10, -8)) {\n                    bestpair = c1;\n                } else if (Dc2 - Math.pow(10, -8) <= D && D <= Dc2 + Math.pow(10, -8)) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                ArrayList<ArrayList<Double[]>> c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return bestpair;\n            }\n        }\n\n        public static void main(String[] args) {   \n            Scanner scan = new Scanner(System.in);\n            int N = scan.nextInt();\n            \n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> ptsByY = new ArrayList<Double[]>();\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {scan.nextDouble()*1000, scan.nextDouble()*1000};\n                ptsByX.add(coords); ptsByY.add(coords);\n            }\n            scan.close();\n            \n            // now sort by x coord\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> P = new ArrayList<ArrayList<Double[]>>();\n            P.add(ptsByX); P.add(ptsByY);\n            assert P.size() == 2;\n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res = solve(P);\n            \n            System.out.printf(\"%.10f\", Math.pow(dist(res.get(0).get(0), res.get(0).get(1)), 0.5)/1000.0);\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.text.DecimalFormat;\n\nclass Main {\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static Double[][][] splitpair(Double[][] px, Double[][] py, double d) {  \n            double xBar = px[(px.length+1)/2][0]; // largest x-coordinate of the left half of px\n            List<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.length; i++) {\n                if (Math.abs(py[i][0] - xBar) < d + Math.pow(10,-10)) { //only consider a 'strip' \n     // around xBar that is 2*d wide\n                    Sy.add(py[i]); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            Double[][] bestpair = new Double[2][2]; // the coords of the best pair of points so far\n            int foundBetter = 0;\n   \n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair[0] = p; bestpair[1] = q;\n                        bestD = dist(p, q);\n                        foundBetter = 1;\n                    }\n                }\n            }\n            \n            if (foundBetter == 0) {\n                return null;\n            }\n            \n            Double[][][] res = new Double[2][2][2];\n            res = convertToForm(bestpair[0], bestpair[1]);\n            return res;\n        }\n   \n        public static Double[][][] convertToForm(Double[] a, Double[] b) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            Double[][] byX = {a, b};\n            Double[][] byY = {a, b};\n            // now sort by x coord\n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Double[][][] res = {byX, byY};\n            return res;\n        }\n\n        public static Double[][][] solve(Double[][][] P) { \n            Double[][] Px = P[0];\n            Double[][] Py = P[1];\n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.length == 2) {\n                return P;\n            } else if (Px.length == 3) {\n                Double[] p1 = Px[0]; Double[] p2 = Px[1]; Double[] p3 = Px[2];\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (Math.abs(d12 - minD) < Math.pow(10, -10)) {\n                    return convertToForm(p1, p2);\n                } else if (Math.abs(d13 - minD) < Math.pow(10, -10)) {\n                    return convertToForm(p1, p3);\n                } else if (Math.abs(d23 - minD)  < Math.pow(10, -10)) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3); // it fails here, this is just to return the right data struct\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.length;\n                assert L > 1;\n                Double[][] Qx = new Double[L/2][2];\n                Double[][] Rx = new Double[L-L/2][2];\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx[i] = Px[i];\n                    } else {\n                        Rx[i-L/2] = Px[i];\n                    }\n                }\n                Double[][] Qy = new Double[L/2][2];\n                Double[][] Ry = new Double[L-L/2][2];\n                Double k = Qx[Qx.length-1][0]; \n                Double l = Qx[Qx.length-1][1];\n                int cntQy = 0; int cntRy = 0; \n                for (int i=0; i < Py.length; i++) {\n                    Double[] pt = Py[i];\n                    if (pt[0] < k) {\n                        Qy[cntQy++] = pt;\n                    } else if (Math.abs(pt[0] - k) < Math.pow(10, -10)) {\n                        if (pt[1] <= l) {\n                            Qy[cntQy++] = pt;\n                        } else {\n                            Ry[cntRy++] = pt;\n                        }\n                    } else {\n                        Ry[cntRy++] = pt;\n                    }\n                }\n                \n                // now use recursion\n                Double[][][] Q = {Qx, Qy};\n                Double[][][] R = {Rx, Ry};\n                assert Q.length >= 2;\n                Double[][][] c1 = solve(Q);\n                Double[][][] c2 = solve(R);\n                Double Dc1 = dist(c1[0][0], c1[0][1]); // returns SQUARED distance\n                Double Dc2 = dist(c2[0][0], c2[0][1]); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                Double[][][] bestpair = new Double[2][2][2];\n                \n                if (Math.abs(Dc1 - D) < Math.pow(10, -10)) {\n                    bestpair = c1;\n                } else if (Math.abs(Dc2 - D) < Math.pow(10, -10)) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                Double[][][] c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return c3;\n            }\n        }\n        \n        public static void main(String[] args) {   \n            \n            // timer stuffs\n            long startTime = System.nanoTime();\n            \n            Scanner scan = new Scanner(System.in);\n            int N = scan.nextInt();\n            \n            Double[][] ptsByX = new Double[N][2];\n            Double[][] ptsByY = new Double[N][2];\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {scan.nextDouble(), scan.nextDouble()};\n                ptsByX[i] = coords; ptsByY[i] = coords;\n            }\n            scan.close();\n            \n            // sort by x coord\n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    if (Math.abs(doubles[0] - otherDoubles[0]) < Math.pow(10, -8)) {\n                        return doubles[1].compareTo(otherDoubles[1]); \n                    }\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            \n            // sort by y-coord\n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    if (Math.abs(doubles[1] - otherDoubles[1]) < Math.pow(10, -8)) {\n                        return doubles[0].compareTo(otherDoubles[0]); \n                    }\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            });\n            \n            Double[][][] P = new Double[2][N][2];\n            P[0] = ptsByX; P[1] = ptsByY;\n            assert P.length == 2;\n            \n            long endTime = System.nanoTime();\n            long duration = (endTime - startTime)/1000000;\n            System.out.println(duration);\n            \n            Double[][][] res = new Double[2][2][2];\n            res = solve(P);\n           \n            DecimalFormat df = new DecimalFormat();\n            df.setMaximumFractionDigits(10);\n            System.out.println(df.format(Math.pow(dist(res[0][0], res[0][1]), 0.5)));\n            \n            endTime = System.nanoTime();\n            duration = (endTime - startTime)/1000000;\n           \n            System.out.println(N);\n            System.out.println(duration);\n            \n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.text.DecimalFormat;\n\nclass Main {\n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static Double[][][] splitpair(Double[][] px, Double[][] py, double d) {  \n            double xBar = px[(px.length+1)/2][0]; // largest x-coordinate of the left half of px\n            List<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.length; i++) {\n                if (Math.abs(py[i][0] - xBar) < d + Math.pow(10,-10)) { //only consider a 'strip' \n     // around xBar that is 2*d wide\n                    Sy.add(py[i]); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            Double[][] bestpair = new Double[2][2]; // the coords of the best pair of points so far\n            int foundBetter = 0;\n   \n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair[0] = p; bestpair[1] = q;\n                        bestD = dist(p, q);\n                        foundBetter = 1;\n                    }\n                }\n            }\n            \n            if (foundBetter == 0) {\n                return null;\n            }\n            \n            Double[][][] res = new Double[2][2][2];\n            res = convertToForm(bestpair[0], bestpair[1]);\n            return res;\n        }\n   \n        public static Double[][][] convertToForm(Double[] a, Double[] b) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            Double[][] byX = {a, b};\n            Double[][] byY = {a, b};\n            // now sort by x coord\n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Double[][][] res = {byX, byY};\n            return res;\n        }\n\n        public static Double[][][] solve(Double[][][] P) { \n            Double[][] Px = P[0];\n            Double[][] Py = P[1];\n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.length == 2) {\n                return P;\n            } else if (Px.length == 3) {\n                Double[] p1 = Px[0]; Double[] p2 = Px[1]; Double[] p3 = Px[2];\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (Math.abs(d12 - minD) < Math.pow(10, -10)) {\n                    return convertToForm(p1, p2);\n                } else if (Math.abs(d13 - minD) < Math.pow(10, -10)) {\n                    return convertToForm(p1, p3);\n                } else if (Math.abs(d23 - minD)  < Math.pow(10, -10)) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3); // it fails here, this is just to return the right data struct\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.length;\n                assert L > 1;\n                Double[][] Qx = new Double[L/2][2];\n                Double[][] Rx = new Double[L-L/2][2];\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx[i] = Px[i];\n                    } else {\n                        Rx[i-L/2] = Px[i];\n                    }\n                }\n                Double[][] Qy = new Double[L/2][2];\n                Double[][] Ry = new Double[L-L/2][2];\n                Double k = Qx[Qx.length-1][0]; \n                Double l = Qx[Qx.length-1][1];\n                int cntQy = 0; int cntRy = 0; \n                for (int i=0; i < Py.length; i++) {\n                    Double[] pt = Py[i];\n                    if (pt[0] < k) {\n                        Qy[cntQy++] = pt;\n                    } else if (Math.abs(pt[0] - k) < Math.pow(10, -10)) {\n                        if (pt[1] <= l) {\n                            Qy[cntQy++] = pt;\n                        } else {\n                            Ry[cntRy++] = pt;\n                        }\n                    } else {\n                        Ry[cntRy++] = pt;\n                    }\n                }\n                \n                // now use recursion\n                Double[][][] Q = {Qx, Qy};\n                Double[][][] R = {Rx, Ry};\n                assert Q.length >= 2;\n                Double[][][] c1 = solve(Q);\n                Double[][][] c2 = solve(R);\n                Double Dc1 = dist(c1[0][0], c1[0][1]); // returns SQUARED distance\n                Double Dc2 = dist(c2[0][0], c2[0][1]); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                Double[][][] bestpair = new Double[2][2][2];\n                \n                if (Math.abs(Dc1 - D) < Math.pow(10, -10)) {\n                    bestpair = c1;\n                } else if (Math.abs(Dc2 - D) < Math.pow(10, -10)) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                Double[][][] c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return c3;\n            }\n        }\n        \n        public static void main(String[] args) {   \n            \n            // timer stuffs\n            long startTime = System.nanoTime();\n            \n            Scanner scan = new Scanner(System.in);\n            int N = scan.nextInt();\n            \n            Double[][] ptsByX = new Double[N][2];\n            Double[][] ptsByY = new Double[N][2];\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {scan.nextDouble(), scan.nextDouble()};\n                ptsByX[i] = coords; ptsByY[i] = coords;\n            }\n            scan.close();\n            \n            // sort by x coord\n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    if (Math.abs(doubles[0] - otherDoubles[0]) < Math.pow(10, -8)) {\n                        return doubles[1].compareTo(otherDoubles[1]); \n                    }\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            \n            // sort by y-coord\n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    if (Math.abs(doubles[1] - otherDoubles[1]) < Math.pow(10, -8)) {\n                        return doubles[0].compareTo(otherDoubles[0]); \n                    }\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            });\n            \n            Double[][][] P = new Double[2][N][2];\n            P[0] = ptsByX; P[1] = ptsByY;\n            assert P.length == 2;\n            \n            long endTime = System.nanoTime();\n            long duration = (endTime - startTime)/1000000;\n            //System.out.println(duration);\n            \n            Double[][][] res = new Double[2][2][2];\n            res = solve(P);\n           \n            DecimalFormat df = new DecimalFormat();\n            df.setMaximumFractionDigits(10);\n            System.out.println(df.format(Math.pow(dist(res[0][0], res[0][1]), 0.5)));\n            \n            endTime = System.nanoTime();\n            duration = (endTime - startTime)/1000000;\n           \n            //System.out.println(N);\n            //System.out.println(duration);\n            \n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.text.DecimalFormat;\n\nclass Main {\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static ArrayList<ArrayList<Double[]>> splitpair(ArrayList<Double[]> px, ArrayList<Double[]> py, double d) {  \n            double xBar = px.get(px.size()/2)[0]; // largest x-coordinate of the left half of px\n            ArrayList<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.size(); i++) {\n                if (xBar - d <= py.get(i)[0] && py.get(i)[0]<= xBar + d) { //only consider a 'strip' \n                    // around xBar that is 2*d wide\n                    Sy.add(py.get(i)); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            ArrayList<ArrayList<Double[]>> bestpair = new ArrayList<ArrayList<Double[]>>(); // the coords of the best pair of points so far\n            bestpair = null;\n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair = convertToForm(p,q);\n                        bestD = dist(p, q);\n                    }\n                }\n            }\n            \n            return bestpair;\n        }\n   \n        public static ArrayList<ArrayList<Double[]>> convertToForm(Double[] x, Double[] y) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> pysByY = new ArrayList<Double[]>();\n            ptsByX.add(x); ptsByX.add(y); pysByY.add(x); pysByY.add(y);\n            // to get sorted by x-coord then sorted by y-coord, first sort by y-coord\n            // then sort by x-coord (since Arrays.sort is stable)\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res.add(ptsByX); res.add(pysByY);\n            return res;\n        }\n\n        public static ArrayList<ArrayList<Double[]>> solve(ArrayList<ArrayList<Double[]>> P) { \n            ArrayList<Double[]> Px = new ArrayList<Double[]>();\n            ArrayList<Double[]> Py = new ArrayList<Double[]>();\n            Px = P.get(0); Py = P.get(1);            \n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.size() == 2) {\n                return P;\n            } else if (Px.size() == 3) {\n                Double[] p1 = Px.get(0); Double[] p2 = Px.get(1); Double[] p3 = Px.get(2);\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (d12 - Math.pow(10, -8) <= minD && minD <= d12 + Math.pow(10, -8)) {\n                    return convertToForm(p1, p2);\n                } else if (d13 - Math.pow(10, -8) <= minD && minD <= d13 + Math.pow(10, -8)) {\n                    return convertToForm(p1, p3);\n                } else if (d23 - Math.pow(10, -8) <= minD && minD <= d23 + Math.pow(10, -8)) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3);\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.size();\n                assert L > 1;\n                ArrayList<Double[]> Qx = new ArrayList<Double[]>();\n                ArrayList<Double[]> Rx = new ArrayList<Double[]>();\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx.add(Px.get(i));\n                    } else {\n                        Rx.add(Px.get(i));\n                    }\n                }\n                ArrayList<Double[]> Qy = new ArrayList<Double[]>();\n                ArrayList<Double[]> Ry = new ArrayList<Double[]>();\n                Double k = Qx.get(Qx.size()-1)[0]; \n                Double l = Qx.get(Qx.size()-1)[1];\n                for (int i=0; i < Py.size(); i++) {\n                    Double[] pt = Py.get(i);\n                    if (pt[0] < k) {\n                        Qy.add(pt);\n                    } else if (pt[0] == k) {\n                        if (pt[1] <= l) {\n                            Qy.add(pt);\n                        } else {\n                           Ry.add(pt);\n                        }\n                    } else {\n                        Ry.add(pt);\n                    }\n                }\n                assert Qy.size() == Qx.size();\n                assert Ry.size() == Rx.size();\n                assert Qx.size() >= 2;\n                \n                // now use recursion\n                ArrayList<ArrayList<Double[]>> Q = new ArrayList<ArrayList<Double[]>>();\n                ArrayList<ArrayList<Double[]>> R = new ArrayList<ArrayList<Double[]>>();\n                Q.add(Qx); Q.add(Qy); R.add(Rx); R.add(Ry);\n                assert Q.size() >= 2;\n                ArrayList<ArrayList<Double[]>> c1 = solve(Q);\n                ArrayList<ArrayList<Double[]>> c2 = solve(R);\n                Double Dc1 = dist(c1.get(0).get(0), c1.get(0).get(1)); // returns SQUARED distance\n                Double Dc2 = dist(c2.get(0).get(0), c2.get(0).get(1)); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                ArrayList<ArrayList<Double[]>> bestpair = new ArrayList<ArrayList<Double[]>>();\n                \n                if (Dc1 - Math.pow(10, -8) <= D && D <= Dc1 + Math.pow(10, -8)) {\n                    bestpair = c1;\n                } else if (Dc2 - Math.pow(10, -8) <= D && D <= Dc2 + Math.pow(10, -8)) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                ArrayList<ArrayList<Double[]>> c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return bestpair;\n            }\n        }\n\n        public static void main(String[] args) {   \n            Scanner scan = new Scanner(System.in);\n            int N = scan.nextInt();\n            \n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> ptsByY = new ArrayList<Double[]>();\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {scan.nextDouble()*1000, scan.nextDouble()*1000};\n                ptsByX.add(coords); ptsByY.add(coords);\n            }\n            scan.close();\n            \n            // now sort by x coord\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> P = new ArrayList<ArrayList<Double[]>>();\n            P.add(ptsByX); P.add(ptsByY);\n            assert P.size() == 2;\n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res = solve(P);\n            \n            DecimalFormat df = new DecimalFormat();\n            df.setMaximumFractionDigits(10);\n            System.out.println(df.format(Math.pow(dist(res.get(0).get(0), res.get(0).get(1)), 0.5)/1000.0));\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.text.DecimalFormat;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n \nclass Main {\n \n  static final double EPS = 1e-10;\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n       public static Double dist(Double[] x, Double[] y) {     \n         return (x[0]-y[0])*(x[0]-y[0]) + (x[1]-y[1])*(x[1]-y[1]);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static Double[][][] splitpair(Double[][] px, Double[][] py, double d) {  \n            double xBar = px[(px.length+1)/2][0]; // largest x-coordinate of the left half of px\n            List<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.length; i++) {\n                if (xBar - d - EPS <= py[i][0] && py[i][0]<= xBar + d + EPS) { //only consider a 'strip' \n                    // around xBar that is 2*d wide\n                    Sy.add(py[i]); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            Double[][][] bestpair = new Double[2][2][2]; // the coords of the best pair of points so far\n            bestpair = null;\n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair = convertToForm(p,q);\n                        bestD = dist(p, q);\n                    }\n                }\n            }\n            return bestpair;\n        }\n   \n        public static Double[][][] convertToForm(Double[] a, Double[] b) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            Double[][] byX = {a, b};\n            Double[][] byY = {a, b};\n            // now sort by x coord\n            if (byX[0][0] > byX[1][0] || \n                (byX[0][0] == byX[1][0] && byX[0][1] > byX[1][1])) {\n              Double[] tmp = byX[0];\n              byX[0] = byX[1];\n              byX[1] = tmp;\n            }\n            /*\n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] a, Double[] b) {\n                  return a[0] != b[0] ? a[0] - b[0] : a[1] - b[1];\n                }\n            }); \n            */\n            // sort by y-coord\n            if (byX[0][1] > byX[1][1] || \n                (byX[0][1] == byX[1][1] && byX[0][0] > byX[1][0])) {\n              Double[] tmp = byX[0];\n              byX[0] = byX[1];\n              byX[1] = tmp;\n            }\n            /*\n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] a, Double[] b) {\n                  return a[1] != b[1] ? a[1] - b[1] : a[0] - b[0];\n                }\n            }); \n            */\n            Double[][][] res = {byX, byY};\n            return res;\n        }\n \n        public static Double[][][] solve(Double[][][] P) { \n            Double[][] Px = P[0];\n            Double[][] Py = P[1];\n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.length == 2) {\n                return P;\n            } else if (Px.length == 3) {\n                Double[] p1 = Px[0]; Double[] p2 = Px[1]; Double[] p3 = Px[2];\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (Math.abs(d12 - minD) < EPS) {\n                    return convertToForm(p1, p2);\n                } else if (Math.abs(d13 - minD) < EPS) {\n                    return convertToForm(p1, p3);\n                } else if (Math.abs(d23 - minD) < EPS) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3); // it fails here, this is just to return the right data struct\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.length;\n                assert L > 1;\n                Double[][] Qx = new Double[L/2][2];\n                Double[][] Rx = new Double[L-L/2][2];\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx[i] = Px[i];\n                    } else {\n                        Rx[i-L/2] = Px[i];\n                    }\n                }\n                Double[][] Qy = new Double[L/2][2];\n                Double[][] Ry = new Double[L-L/2][2];\n                Double k = Qx[Qx.length-1][0]; \n                Double l = Qx[Qx.length-1][1];\n                int cntQy = 0; int cntRy = 0; \n                for (int i=0; i < Py.length; i++) {\n                    Double[] pt = Py[i];\n                    if (pt[0] < k) {\n                        Qy[cntQy++] = pt;\n                    } else if (Math.abs(pt[0] - k) < EPS) {\n                        if (pt[1] <= l) {\n                            Qy[cntQy++] = pt;\n                        } else {\n                            Ry[cntRy++] = pt;\n                        }\n                    } else {\n                        Ry[cntRy++] = pt;\n                    }\n                }\n                \n                // now use recursion\n                Double[][][] Q = {Qx, Qy};\n                Double[][][] R = {Rx, Ry};\n                assert Q.length >= 2;\n                Double[][][] c1 = solve(Q);\n                Double[][][] c2 = solve(R);\n                Double Dc1 = dist(c1[0][0], c1[0][1]); // returns SQUARED distance\n                Double Dc2 = dist(c2[0][0], c2[0][1]); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                Double[][][] bestpair = new Double[2][2][2];\n                \n                if (Math.abs(Dc1 - D) < EPS) {\n                    bestpair = c1;\n                } else if (Math.abs(Dc2 - D) < EPS) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                Double[][][] c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return c3;\n            }\n        }\n        \n        public static void main(String[] args) {   \n \n            InputStream inputStream = System.in;\n            // OutputStream outputStream = System.out;\n            InputReader in = new InputReader(inputStream);\n            // PrintWriter out = new PrintWriter(outputStream);\n            \n            // timer stuffs\n            long startTime = System.nanoTime();\n            \n            int N = in.nextInt();\n            \n            Double[][] ptsByX = new Double[N][2];\n            Double[][] ptsByY = new Double[N][2];\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {in.nextDouble(), in.nextDouble()};\n                ptsByX[i] = coords; ptsByY[i] = coords;\n            }\n            \n            // sort by x coord\n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            \n            // sort by y-coord\n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            \n            Double[][][] P = new Double[2][N][2];\n            P[0] = ptsByX; P[1] = ptsByY;\n            assert P.length == 2;\n            \n            long endTime = System.nanoTime();\n            long duration = (endTime - startTime)/1000000;\n            System.out.printf(\"%d ms\\n\", duration);\n            \n            Double[][][] res = new Double[2][2][2];\n            res = solve(P);\n           \n            DecimalFormat df = new DecimalFormat();\n            df.setMaximumFractionDigits(10);\n            System.out.println(df.format(Math.pow(dist(res[0][0], res[0][1]), 0.5)));\n            \n            endTime = System.nanoTime();\n            duration = (endTime - startTime)/1000000;\n           \n            System.out.printf(\"Num points: %d\\n\", N);\n            System.out.printf(\"%d ms\\n\", duration);\n            \n        }\n}\n \nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n \n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n \n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n \n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n \n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\tstatic Point[] p;\n\tstatic int n;\n\t\n\tpublic static void main(String[] args) {\n\t\tn = sc.nextInt();\n\t\tp = new Point[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tp[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t}\n\t\t\n\t\tArrays.sort(p, new Comparator<Point>() {\n\t\t\tpublic int compare(Point p1, Point p2) {\n\t\t\t\tif(p1.x < p2.x) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tdouble d = closestPair(0, n);\n\t\tDecimalFormat df = new DecimalFormat(\"#######0.0########\");\n\t\tSystem.out.println(df.format(Math.sqrt(d)));\n\t}\n\t\n\tstatic double closestPair(int l, int r) {\n\t\tif(r - l <= 1) {\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}\n\t\tif(r - l <= 2) {\n\t\t\tdouble dx = Math.abs(p[l].x - p[l+1].x);\n\t\t\tdouble dy = Math.abs(p[l].y - p[l+1].y);\n\t\t\treturn dx*dx + dy*dy;\n\t\t}\n\t\t\n\t\tint m = (l + r) / 2;\n\t\tdouble x = p[m].x;\n\t\tdouble d = Math.min(closestPair(l, m), closestPair(m, r));\n\t\tmerge(l, m, r);\n\t\t\n\t\tArrayList<Point> pa = new ArrayList<>();\n\t\tfor(int i=l; i<r; i++) {\n\t\t\tif(Math.abs(p[i].x - x) >= d) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=pa.size()-1; j>=0; j--) {\n\t\t\t\tdouble dx = Math.abs(p[i].x - p[j].x);\n\t\t\t\tdouble dy = Math.abs(p[i].y - p[j].y);\n\t\t\t\tif(dy >= d) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td = Math.min(d, dx*dx + dy*dy);\n\t\t\t}\n\t\t\tpa.add(p[i]);\n\t\t}\n\t\t\n\t\treturn d;\n\t}\n\t\n\tstatic class Point {\n\t\tdouble x;\n\t\tdouble y;\n\t\tPoint(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tstatic void merge(int l, int m, int r) {\n\t\tPoint[] ptemp = Arrays.copyOf(p, n);\n\t\tint i = l;\n\t\tint j = m;\n\t\tint k = l;\n\t\twhile(i != m || j != r) {\n\t\t\tif(j == r || i != m && p[i].y < p[j].y) {\n\t\t\t\tptemp[k] = p[i];\n\t\t\t\ti++;\n\t\t\t\tk++;\n\t\t\t} else {\n\t\t\t\tptemp[k] = p[j];\n\t\t\t\tj++;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tp = ptemp;\n\t}\n\t\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.text.DecimalFormat;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n \nclass Main {\n \n  static final double EPS = 1e-10;\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n       public static Double dist(Double[] x, Double[] y) {     \n         return (x[0]-y[0])*(x[0]-y[0]) + (x[1]-y[1])*(x[1]-y[1]);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static Double[][][] splitpair(Double[][] px, Double[][] py, double d) {  \n            double xBar = px[(px.length+1)/2][0]; // largest x-coordinate of the left half of px\n            List<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.length; i++) {\n                if (xBar - d - EPS <= py[i][0] && py[i][0]<= xBar + d + EPS) { //only consider a 'strip' \n                    // around xBar that is 2*d wide\n                    Sy.add(py[i]); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            Double[][][] bestpair = new Double[2][2][2]; // the coords of the best pair of points so far\n            bestpair = null;\n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair = convertToForm(p,q);\n                        bestD = dist(p, q);\n                    }\n                }\n            }\n            return bestpair;\n        }\n   \n        public static Double[][][] convertToForm(Double[] a, Double[] b) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            Double[][] byX = {a, b};\n            Double[][] byY = {a, b};\n            // now sort by x coord\n            if (byX[0][0] > byX[1][0] || \n                (byX[0][0] == byX[1][0] && byX[0][1] > byX[1][1])) {\n              Double[] tmp = byX[0];\n              byX[0] = byX[1];\n              byX[1] = tmp;\n            }\n            /*\n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] a, Double[] b) {\n                  return a[0] != b[0] ? a[0] - b[0] : a[1] - b[1];\n                }\n            }); \n            */\n            // sort by y-coord\n            if (byX[0][1] > byX[1][1] || \n                (byX[0][1] == byX[1][1] && byX[0][0] > byX[1][0])) {\n              Double[] tmp = byX[0];\n              byX[0] = byX[1];\n              byX[1] = tmp;\n            }\n            /*\n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] a, Double[] b) {\n                  return a[1] != b[1] ? a[1] - b[1] : a[0] - b[0];\n                }\n            }); \n            */\n            Double[][][] res = {byX, byY};\n            return res;\n        }\n \n        public static Double[][][] solve(Double[][][] P) { \n            Double[][] Px = P[0];\n            Double[][] Py = P[1];\n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.length == 2) {\n                return P;\n            } else if (Px.length == 3) {\n                Double[] p1 = Px[0]; Double[] p2 = Px[1]; Double[] p3 = Px[2];\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (Math.abs(d12 - minD) < EPS) {\n                    return convertToForm(p1, p2);\n                } else if (Math.abs(d13 - minD) < EPS) {\n                    return convertToForm(p1, p3);\n                } else if (Math.abs(d23 - minD) < EPS) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3); // it fails here, this is just to return the right data struct\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.length;\n                assert L > 1;\n                Double[][] Qx = new Double[L/2][2];\n                Double[][] Rx = new Double[L-L/2][2];\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx[i] = Px[i];\n                    } else {\n                        Rx[i-L/2] = Px[i];\n                    }\n                }\n                Double[][] Qy = new Double[L/2][2];\n                Double[][] Ry = new Double[L-L/2][2];\n                Double k = Qx[Qx.length-1][0]; \n                Double l = Qx[Qx.length-1][1];\n                int cntQy = 0; int cntRy = 0; \n                for (int i=0; i < Py.length; i++) {\n                    Double[] pt = Py[i];\n                    if (pt[0] < k) {\n                        Qy[cntQy++] = pt;\n                    } else if (Math.abs(pt[0] - k) < EPS) {\n                        if (pt[1] <= l) {\n                            Qy[cntQy++] = pt;\n                        } else {\n                            Ry[cntRy++] = pt;\n                        }\n                    } else {\n                        Ry[cntRy++] = pt;\n                    }\n                }\n                \n                // now use recursion\n                Double[][][] Q = {Qx, Qy};\n                Double[][][] R = {Rx, Ry};\n                assert Q.length >= 2;\n                Double[][][] c1 = solve(Q);\n                Double[][][] c2 = solve(R);\n                Double Dc1 = dist(c1[0][0], c1[0][1]); // returns SQUARED distance\n                Double Dc2 = dist(c2[0][0], c2[0][1]); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                Double[][][] bestpair = new Double[2][2][2];\n                \n                if (Math.abs(Dc1 - D) < EPS) {\n                    bestpair = c1;\n                } else if (Math.abs(Dc2 - D) < EPS) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                Double[][][] c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return c3;\n            }\n        }\n        \n        public static void main(String[] args) {   \n \n            InputStream inputStream = System.in;\n            // OutputStream outputStream = System.out;\n            InputReader in = new InputReader(inputStream);\n            // PrintWriter out = new PrintWriter(outputStream);\n            \n            // timer stuffs\n            long startTime = System.nanoTime();\n            \n            int N = in.nextInt();\n            \n            Double[][] ptsByX = new Double[N][2];\n            Double[][] ptsByY = new Double[N][2];\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {in.nextDouble(), in.nextDouble()};\n                ptsByX[i] = coords; ptsByY[i] = coords;\n            }\n            \n            // sort by x coord\n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            \n            // sort by y-coord\n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            \n            Double[][][] P = new Double[2][N][2];\n            P[0] = ptsByX; P[1] = ptsByY;\n            \n            //long endTime = System.nanoTime();\n            //long duration = (endTime - startTime)/1000000;\n            //System.out.printf(\"%d ms\\n\", duration);\n            \n            Double[][][] res = new Double[2][2][2];\n            res = solve(P);\n           \n            DecimalFormat df = new DecimalFormat();\n            df.setMaximumFractionDigits(10);\n            System.out.println(df.format(Math.pow(dist(res[0][0], res[0][1]), 0.5)));\n            \n            //endTime = System.nanoTime();\n            //duration = (endTime - startTime)/1000000;\n           \n            //System.out.printf(\"Num points: %d\\n\", N);\n            //System.out.printf(\"%d ms\\n\", duration);\n            \n        }\n}\n \nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n \n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n \n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n \n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n \n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static ArrayList<ArrayList<Double[]>> splitpair(ArrayList<Double[]> px, ArrayList<Double[]> py, double d) {  \n            double xBar = px.get(px.size()/2)[0]; // largest x-coordinate of the left half of px\n            ArrayList<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.size(); i++) {\n                if (xBar - d <= py.get(i)[0] && py.get(i)[0]<= xBar + d) { //only consider a 'strip' \n                    // around xBar that is 2*d wide\n                    Sy.add(py.get(i)); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            ArrayList<ArrayList<Double[]>> bestpair = new ArrayList<ArrayList<Double[]>>(); // the coords of the best pair of points so far\n            bestpair = null;\n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair = convertToForm(p,q);\n                        bestD = dist(p, q);\n                    }\n                }\n            }\n            \n            return bestpair;\n        }\n   \n        public static ArrayList<ArrayList<Double[]>> convertToForm(Double[] x, Double[] y) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> pysByY = new ArrayList<Double[]>();\n            ptsByX.add(x); ptsByX.add(y); pysByY.add(x); pysByY.add(y);\n            // to get sorted by x-coord then sorted by y-coord, first sort by y-coord\n            // then sort by x-coord (since Arrays.sort is stable)\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res.add(ptsByX); res.add(pysByY);\n            return res;\n        }\n\n        public static ArrayList<ArrayList<Double[]>> solve(ArrayList<ArrayList<Double[]>> P) { \n            ArrayList<Double[]> Px = new ArrayList<Double[]>();\n            ArrayList<Double[]> Py = new ArrayList<Double[]>();\n            Px = P.get(0); Py = P.get(1);            \n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.size() == 2) {\n                return P;\n            } else if (Px.size() == 3) {\n                Double[] p1 = Px.get(0); Double[] p2 = Px.get(1); Double[] p3 = Px.get(2);\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (d12 - Math.pow(10, -8) <= minD && minD <= d12 + Math.pow(10, -8)) {\n                    return convertToForm(p1, p2);\n                } else if (d13 - Math.pow(10, -8) <= minD && minD <= d13 + Math.pow(10, -8)) {\n                    return convertToForm(p1, p3);\n                } else if (d23 - Math.pow(10, -8) <= minD && minD <= d23 + Math.pow(10, -8)) {\n                    return convertToForm(p2, p3);\n                } else {\n                    StdOut.println(\"HUNG!\");\n                    return convertToForm(p2, p3);\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.size();\n                assert L > 1;\n                ArrayList<Double[]> Qx = new ArrayList<Double[]>();\n                ArrayList<Double[]> Rx = new ArrayList<Double[]>();\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx.add(Px.get(i));\n                    } else {\n                        Rx.add(Px.get(i));\n                    }\n                }\n                ArrayList<Double[]> Qy = new ArrayList<Double[]>();\n                ArrayList<Double[]> Ry = new ArrayList<Double[]>();\n                Double k = Qx.get(Qx.size()-1)[0]; \n                Double l = Qx.get(Qx.size()-1)[1];\n                for (int i=0; i < Py.size(); i++) {\n                    Double[] pt = Py.get(i);\n                    if (pt[0] < k) {\n                        Qy.add(pt);\n                    } else if (pt[0] == k) {\n                        if (pt[1] <= l) {\n                            Qy.add(pt);\n                        } else {\n                           Ry.add(pt);\n                        }\n                    } else {\n                        Ry.add(pt);\n                    }\n                }\n                assert Qy.size() == Qx.size();\n                assert Ry.size() == Rx.size();\n                assert Qx.size() >= 2;\n                \n                // now use recursion\n                ArrayList<ArrayList<Double[]>> Q = new ArrayList<ArrayList<Double[]>>();\n                ArrayList<ArrayList<Double[]>> R = new ArrayList<ArrayList<Double[]>>();\n                Q.add(Qx); Q.add(Qy); R.add(Rx); R.add(Ry);\n                assert Q.size() >= 2;\n                ArrayList<ArrayList<Double[]>> c1 = solve(Q);\n                ArrayList<ArrayList<Double[]>> c2 = solve(R);\n                Double Dc1 = dist(c1.get(0).get(0), c1.get(0).get(1)); // returns SQUARED distance\n                Double Dc2 = dist(c2.get(0).get(0), c2.get(0).get(1)); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                ArrayList<ArrayList<Double[]>> bestpair = new ArrayList<ArrayList<Double[]>>();\n                \n                if (Dc1 - Math.pow(10, -8) <= D && D <= Dc1 + Math.pow(10, -8)) {\n                    bestpair = c1;\n                } else if (Dc2 - Math.pow(10, -8) <= D && D <= Dc2 + Math.pow(10, -8)) {\n                    bestpair = c2;\n                } else {\n                    StdOut.println(\"FUCK!\");\n                }\n                        \n                ArrayList<ArrayList<Double[]>> c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return bestpair;\n            }\n        }\n\n        public static void main(String[] args) {   \n            Scanner scan = new Scanner(System.in);\n            int N = scan.nextInt();\n            \n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> ptsByY = new ArrayList<Double[]>();\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {scan.nextDouble()*1000, scan.nextDouble()*1000};\n                ptsByX.add(coords); ptsByY.add(coords);\n            }\n            scan.close();\n            \n            // now sort by x coord\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> P = new ArrayList<ArrayList<Double[]>>();\n            P.add(ptsByX); P.add(ptsByY);\n            assert P.size() == 2;\n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res = solve(P);\n            \n            System.out.println(Math.pow(dist(res.get(0).get(0), res.get(0).get(1)), 0.5)/1000.0);\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.text.DecimalFormat;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n \nclass Main {\n \n  static final double EPS = 1e-12;\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n       public static Double dist(Double[] x, Double[] y) {     \n         return (x[0]-y[0])*(x[0]-y[0]) + (x[1]-y[1])*(x[1]-y[1]);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static Double[][][] splitpair(Double[][] px, Double[][] py, double d) {  \n            double xBar = px[(px.length+1)/2][0]; // largest x-coordinate of the left half of px\n            List<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.length; i++) {\n                if (xBar - d - EPS <= py[i][0] && py[i][0]<= xBar + d + EPS) { //only consider a 'strip' \n                    // around xBar that is 2*d wide\n                    Sy.add(py[i]); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            Double[][][] bestpair = new Double[2][2][2]; // the coords of the best pair of points so far\n            bestpair = null;\n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair = convertToForm(p,q);\n                        bestD = dist(p, q);\n                    }\n                }\n            }\n            return bestpair;\n        }\n   \n        public static Double[][][] convertToForm(Double[] a, Double[] b) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            Double[][] byX = {a, b};\n            Double[][] byY = {a, b};\n            // now sort by x coord\n            if (byX[0][0] > byX[1][0] || \n                (byX[0][0] == byX[1][0] && byX[0][1] > byX[1][1])) {\n              Double[] tmp = byX[0];\n              byX[0] = byX[1];\n              byX[1] = tmp;\n            }\n            \n            // sort by y-coord\n            if (byX[0][1] > byX[1][1] || \n                (byX[0][1] == byX[1][1] && byX[0][0] > byX[1][0])) {\n              Double[] tmp = byX[0];\n              byX[0] = byX[1];\n              byX[1] = tmp;\n            }\n            \n            Double[][][] res = {byX, byY};\n            return res;\n        }\n \n        public static Double[][][] solve(Double[][][] P) { \n            Double[][] Px = P[0];\n            Double[][] Py = P[1];\n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.length == 2) {\n                return P;\n            } else if (Px.length == 3) {\n                Double[] p1 = Px[0]; Double[] p2 = Px[1]; Double[] p3 = Px[2];\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (Math.abs(d12 - minD) < EPS) {\n                    return convertToForm(p1, p2);\n                } else if (Math.abs(d13 - minD) < EPS) {\n                    return convertToForm(p1, p3);\n                } else if (Math.abs(d23 - minD) < EPS) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3); // it fails here, this is just to return the right data struct\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.length;\n                assert L > 1;\n                Double[][] Qx = new Double[L/2][2];\n                Double[][] Rx = new Double[L-L/2][2];\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx[i] = Px[i];\n                    } else {\n                        Rx[i-L/2] = Px[i];\n                    }\n                }\n                Double[][] Qy = new Double[L/2][2];\n                Double[][] Ry = new Double[L-L/2][2];\n                Double k = Qx[Qx.length-1][0]; \n                Double l = Qx[Qx.length-1][1];\n                int cntQy = 0; int cntRy = 0; \n                for (int i=0; i < Py.length; i++) {\n                    Double[] pt = Py[i];\n                    if (pt[0] < k) {\n                        Qy[cntQy++] = pt;\n                    } else if (Math.abs(pt[0] - k) < EPS) {\n                        if (pt[1] - l <= EPS) {\n                            Qy[cntQy++] = pt;\n                        } else {\n                            Ry[cntRy++] = pt;\n                        }\n                    } else {\n                        Ry[cntRy++] = pt;\n                    }\n                }\n                \n                // now use recursion\n                Double[][][] Q = {Qx, Qy};\n                Double[][][] R = {Rx, Ry};\n                assert Q.length >= 2;\n                Double[][][] c1 = solve(Q);\n                Double[][][] c2 = solve(R);\n                Double Dc1 = dist(c1[0][0], c1[0][1]); // returns SQUARED distance\n                Double Dc2 = dist(c2[0][0], c2[0][1]); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                Double[][][] bestpair = new Double[2][2][2];\n                \n                if (Math.abs(Dc1 - D) < EPS) {\n                    bestpair = c1;\n                } else if (Math.abs(Dc2 - D) < EPS) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                Double[][][] c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return c3;\n            }\n        }\n        \n        public static void main(String[] args) {   \n \n            InputStream inputStream = System.in;\n            InputReader in = new InputReader(inputStream);\n            \n            // timer stuffs\n            long startTime = System.nanoTime();\n            \n            int N = in.nextInt();\n            \n            Double[][] ptsByX = new Double[N][2];\n            Double[][] ptsByY = new Double[N][2];\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {in.nextDouble(), in.nextDouble()};\n                ptsByX[i] = coords; ptsByY[i] = coords;\n            }\n            \n            // sort by x coord\n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            \n            // sort by y-coord\n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            \n            Double[][][] P = new Double[2][N][2];\n            P[0] = ptsByX; P[1] = ptsByY;\n            \n            //long endTime = System.nanoTime();\n            //long duration = (endTime - startTime)/1000000;\n            //System.out.printf(\"%d ms\\n\", duration);\n            \n            Double[][][] res = new Double[2][2][2];\n            res = solve(P);\n           \n            DecimalFormat df = new DecimalFormat();\n            df.setMaximumFractionDigits(10);\n            System.out.println(df.format(Math.pow(dist(res[0][0], res[0][1]), 0.5)));\n            \n            long endTime = System.nanoTime();\n            long duration = (endTime - startTime)/1000000;\n           \n            //System.out.printf(\"Num points: %d\\n\", N);\n            //System.out.printf(\"%d ms\\n\", duration);\n            \n        }\n}\n \nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n \n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n \n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n \n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n \n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\tstatic Point[] p;\n\tstatic int n;\n\t\n\tpublic static void main(String[] args) {\n\t\tn = sc.nextInt();\n\t\tp = new Point[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tp[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t}\n\t\t\n\t\tArrays.sort(p, new Comparator<Point>() {\n\t\t\tpublic int compare(Point p1, Point p2) {\n\t\t\t\tif(p1.x < p2.x) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if(p1.x > p2.x) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\tif(p1.y < p2.y) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tdouble d = closestPair(0, n);\n\t\tDecimalFormat df = new DecimalFormat(\"#######0.0########\");\n\t\tSystem.out.println(df.format(Math.sqrt(d)));\n\t}\n\t\n\tstatic double closestPair(int l, int r) {\n\t\tif(r - l <= 1) {\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}\n//\t\tif(r - l <= 2) {\n//\t\t\tdouble dx = Math.abs(p[l].x - p[l+1].x);\n//\t\t\tdouble dy = Math.abs(p[l].y - p[l+1].y);\n//\t\t\treturn dx*dx + dy*dy;\n//\t\t}\n\t\t\n\t\tint m = (l + r) / 2;\n\t\tdouble x = p[m].x;\n\t\tdouble d = Math.min(closestPair(l, m), closestPair(m, r));\n\t\tmerge(l, m, r);\n\t\t\n\t\tArrayList<Point> pa = new ArrayList<>();\n\t\tfor(int i=l; i<r; i++) {\n//\t\t\tif(Math.abs(p[i].x - x) >= d) {\n//\t\t\t\tcontinue;\n//\t\t\t}\n\t\t\tfor(int j=pa.size()-1; j>=0; j--) {\n//\t\t\t\tSystem.out.println(l + \" \" + r + \" j=\" + j);\n\t\t\t\tdouble dx = p[i].x - pa.get(j).x;\n\t\t\t\tdouble dy = p[i].y - pa.get(j).y;\n//\t\t\t\tif(dy >= d) {\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n\t\t\t\td = Math.min(d, dx*dx + dy*dy);\n\t\t\t}\n\t\t\tpa.add(p[i]);\n\t\t}\n\t\t\n//\t\tSystem.out.println(l + \" \" + r + \" \" + d );\n\t\treturn d;\n\t}\n\t\n\tstatic class Point {\n\t\tdouble x;\n\t\tdouble y;\n\t\tPoint(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tstatic void merge(int l, int m, int r) {\n\t\tPoint[] ptemp = Arrays.copyOf(p, n);\n\t\tint i = l;\n\t\tint j = m;\n\t\tint k = l;\n\t\twhile(i != m || j != r) {\n\t\t\tif(j == r || i != m && p[i].y < p[j].y) {\n\t\t\t\tptemp[k] = p[i];\n\t\t\t\ti++;\n\t\t\t\tk++;\n\t\t\t} else {\n\t\t\t\tptemp[k] = p[j];\n\t\t\t\tj++;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tp = ptemp;\n\t}\n\t\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static ArrayList<Double[]> splitpair(ArrayList<Double[]> px, ArrayList<Double[]> py, double d) {        \n            double xBar = px.get(px.size()/2)[0]; // largest x-coordinate of the left half of px\n            ArrayList<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.size(); i++) {\n                if (xBar - d <= py.get(i)[0] && py.get(i)[0]<= xBar + d) { //only consider a 'strip' \n                    // around xBar that is 2*d wide\n                    Sy.add(py.get(i)); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            \n            ArrayList<Double[]> bestpair = new ArrayList<Double[]>(); // the coords of the best pair of points so far\n            Double[] x = {0.0, 0.0}; Double[] y = {0.0, 0.0};\n            bestpair.add(x); bestpair.add(y);\n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair.clear(); bestpair.add(p); bestpair.add(q);\n                        bestD = dist(p, q);\n                    }\n                }\n            }\n            return bestpair;\n        }\n   \n        public static ArrayList<ArrayList<Double[]>> convertToForm(Double[] x, Double[] y) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> pysByY = new ArrayList<Double[]>();\n            ptsByX.add(x); ptsByX.add(y); pysByY.add(x); pysByY.add(y);\n            // to get sorted by x-coord then sorted by y-coord, first sort by y-coord\n            // then sort by x-coord (since Arrays.sort is stable)\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res.add(ptsByX); res.add(pysByY);\n            return res;\n        }\n\n        public static ArrayList<ArrayList<Double[]>> solve(ArrayList<ArrayList<Double[]>> P) { \n            ArrayList<Double[]> Px = new ArrayList<Double[]>();\n            ArrayList<Double[]> Py = new ArrayList<Double[]>();\n            Px = P.get(0); Py = P.get(1);\n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.size() == 2) {\n                return P;\n            } else if (Px.size() == 3) {\n                Double[] p1 = Px.get(0); Double[] p2 = Px.get(1); Double[] p3 = Px.get(2);\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (minD == d12) {\n                    return convertToForm(p1, p2);\n                } else if (minD == d13) {\n                    return convertToForm(p1, p3);\n                } else {\n                    return convertToForm(p2, p3);\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.size();\n                StdOut.println(L);\n                assert L > 1;\n                ArrayList<Double[]> Qx = new ArrayList<Double[]>();\n                ArrayList<Double[]> Rx = new ArrayList<Double[]>();\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx.add(Px.get(i));\n                    } else {\n                        Rx.add(Px.get(i));\n                    }\n                }\n                ArrayList<Double[]> Qy = new ArrayList<Double[]>();\n                ArrayList<Double[]> Ry = new ArrayList<Double[]>();\n                Double k = Qx.get(Qx.size()-1)[0]; \n                Double l = Qx.get(Qx.size()-1)[1];\n                for (int i=0; i < Py.size(); i++) {\n                    Double[] pt = Py.get(i);\n                    if (pt[0] < k) {\n                        Qy.add(pt);\n                    } else if (pt[0] == k) {\n                        if (pt[1] <= l) {\n                            Qy.add(pt);\n                        } else {\n                           Ry.add(pt);\n                        }\n                    } else {\n                        Ry.add(pt);\n                    }\n                }\n                assert Qy.size() == Qx.size();\n                assert Ry.size() == Rx.size();\n                \n                // now use recursion\n                ArrayList<ArrayList<Double[]>> Q = new ArrayList<ArrayList<Double[]>>();\n                ArrayList<ArrayList<Double[]>> R = new ArrayList<ArrayList<Double[]>>();\n                Q.add(Qx); Q.add(Qy); R.add(Rx); R.add(Ry);\n                ArrayList<ArrayList<Double[]>> c1 = solve(Q);\n                ArrayList<ArrayList<Double[]>> c2 = solve(R);\n                \n                Double Dc1 = dist(c1.get(0).get(0), c1.get(0).get(1)); // returns SQUARED distance\n                Double Dc2 = dist(c2.get(0).get(0), c2.get(0).get(1)); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                ArrayList<ArrayList<Double[]>> bestpair = new ArrayList<ArrayList<Double[]>>();\n                \n                if (D == Dc1) {\n                    bestpair = c1;\n                } else if (D == Dc2) {\n                    bestpair = c2;\n                }\n                \n                ArrayList<Double[]> c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                ArrayList<Double[]> nobestpair = new ArrayList<Double[]>();\n                Double[] x = {0.0, 0.0}; Double[] y = {0.0, 0.0};\n                nobestpair.add(x); nobestpair.add(y);\n                \n                if (c3 != nobestpair) {\n                    bestpair = convertToForm(c3.get(0), c3.get(1));\n                }\n                \n                return bestpair;\n            }\n        }\n\n        public static void main(String[] args) {   \n            Scanner scan = new Scanner(System.in);\n            int N = scan.nextInt();\n            \n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> ptsByY = new ArrayList<Double[]>();\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {scan.nextDouble(), scan.nextDouble()};\n                ptsByX.add(coords); ptsByY.add(coords);\n            }\n            scan.close();\n            \n            // now sort by x coord\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> P = new ArrayList<ArrayList<Double[]>>();\n            P.add(ptsByX); P.add(ptsByY);\n            assert P.size() == 2;\n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res = solve(P);\n            \n            System.out.println(Math.pow(dist(res.get(0).get(0), res.get(0).get(1)), 0.5));\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\tstatic Point[] p;\n\tstatic int n;\n\t\n\tpublic static void main(String[] args) {\n\t\tn = sc.nextInt();\n\t\tp = new Point[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tp[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t}\n\t\t\n\t\tArrays.sort(p, new Comparator<Point>() {\n\t\t\tpublic int compare(Point p1, Point p2) {\n\t\t\t\tif(p1.x < p2.x) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if(p1.x > p2.x) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\tif(p1.y < p2.y) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tdouble d = closestPair(0, n);\n\t\tDecimalFormat df = new DecimalFormat(\"#######0.0########\");\n\t\tSystem.out.println(df.format(d));\n\t}\n\t\n\tstatic double closestPair(int l, int r) {\n\t\tif(r - l <= 1) {\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}\n\t\t\n\t\tint m = (l + r) / 2;\n\t\tdouble x = p[m].x;\n\t\tdouble d = Math.min(closestPair(l, m), closestPair(m, r));\n\t\tmerge(l, m, r);\n\t\t\n\t\tArrayList<Point> pa = new ArrayList<>();\n//\t\tSystem.out.println(l + \" \" + r + \" \" + d + \" \" + x);\n\t\tfor(int i=l; i<r; i++) {\n\t\t\tif(Math.abs(p[i].x - x) >= d) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=pa.size()-1; j>=0; j--) {\n\t\t\t\tdouble dx = p[i].x - pa.get(j).x;\n\t\t\t\tdouble dy = p[i].y - pa.get(j).y;\n\t\t\t\tif(dy >= d) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td = Math.min(d, Math.sqrt(dx*dx + dy*dy));\n//\t\t\t\tSystem.out.println(\"i=\" + i + \" j=\" + j + \" \" + d);\n\t\t\t}\n\t\t\tpa.add(p[i]);\n\t\t}\n\t\t\n\t\t\n\t\treturn d;\n\t}\n\t\n\tstatic class Point {\n\t\tdouble x;\n\t\tdouble y;\n\t\tPoint(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tstatic void merge(int l, int m, int r) {\n\t\tPoint[] ptemp = Arrays.copyOf(p, n);\n\t\tint i = l;\n\t\tint j = m;\n\t\tint k = l;\n\t\twhile(k != r) {\n\t\t\tif(j == r || i != m && p[i].y < p[j].y) {\n\t\t\t\tptemp[k] = p[i];\n\t\t\t\ti++;\n\t\t\t\tk++;\n\t\t\t} else {\n\t\t\t\tptemp[k] = p[j];\n\t\t\t\tj++;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tp = ptemp;\n\t}\n\t\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\tstatic Point[] p;\n\tstatic int n;\n\t\n\tpublic static void main(String[] args) {\n\t\tn = sc.nextInt();\n\t\tp = new Point[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tp[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t}\n\t\t\n\t\tArrays.sort(p, new Comparator<Point>() {\n\t\t\tpublic int compare(Point p1, Point p2) {\n\t\t\t\tif(p1.x < p2.x) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if(p1.x > p2.x) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\tif(p1.y < p2.y) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tdouble d = closestPair(0, n);\n\t\tDecimalFormat df = new DecimalFormat(\"#######0.0########\");\n\t\tSystem.out.println(df.format(d));\n\t}\n\t\n\tstatic double closestPair(int l, int r) {\n\t\tif(r - l <= 1) {\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}\n\t\t\n\t\tint m = (l + r) / 2;\n\t\tdouble x = p[m].x;\n\t\tdouble d = Math.min(closestPair(l, m), closestPair(m, r));\n\t\tmerge(l, m, r);\n\t\t\n\t\tArrayList<Point> pa = new ArrayList<>();\n//\t\tSystem.out.println(l + \" \" + r + \" \" + d + \" \" + x);\n\t\tfor(int i=l; i<r; i++) {\n\t\t\tif(Math.abs(p[i].x - x) >= d/2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=pa.size()-1; j>=0; j--) {\n\t\t\t\tdouble dx = p[i].x - pa.get(j).x;\n\t\t\t\tdouble dy = p[i].y - pa.get(j).y;\n\t\t\t\tif(dy >= d) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td = Math.min(d, Math.sqrt(dx*dx + dy*dy));\n//\t\t\t\tSystem.out.println(\"i=\" + i + \" j=\" + j + \" \" + d);\n\t\t\t}\n\t\t\tpa.add(p[i]);\n\t\t}\n\t\t\n\t\t\n\t\treturn d;\n\t}\n\t\n\tstatic class Point {\n\t\tdouble x;\n\t\tdouble y;\n\t\tPoint(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tstatic void merge(int l, int m, int r) {\n\t\tPoint[] ptemp = Arrays.copyOf(p, n);\n\t\tint i = l;\n\t\tint j = m;\n\t\tint k = l;\n\t\twhile(k != r) {\n\t\t\tif(j == r || i != m && p[i].y < p[j].y) {\n\t\t\t\tptemp[k] = p[i];\n\t\t\t\ti++;\n\t\t\t\tk++;\n\t\t\t} else {\n\t\t\t\tptemp[k] = p[j];\n\t\t\t\tj++;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tp = ptemp;\n\t}\n\t\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.text.DecimalFormat;\n\nclass Main {\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static ArrayList<ArrayList<Double[]>> splitpair(ArrayList<Double[]> px, ArrayList<Double[]> py, double d) {  \n            double xBar = px.get(px.size()/2)[0]; // largest x-coordinate of the left half of px\n            ArrayList<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.size(); i++) {\n                if (xBar - d - Math.pow(10, -10) <= py.get(i)[0] && py.get(i)[0]<= xBar + d + Math.pow(10, -10)) { //only consider a 'strip' \n                    // around xBar that is 2*d wide\n                    Sy.add(py.get(i)); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            ArrayList<ArrayList<Double[]>> bestpair = new ArrayList<ArrayList<Double[]>>(); // the coords of the best pair of points so far\n            bestpair = null;\n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair = convertToForm(p,q);\n                        bestD = dist(p, q);\n                    }\n                }\n            }\n            return bestpair;\n        }\n   \n        public static ArrayList<ArrayList<Double[]>> convertToForm(Double[] x, Double[] y) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> pysByY = new ArrayList<Double[]>();\n            ptsByX.add(x); ptsByX.add(y); pysByY.add(x); pysByY.add(y);\n            // to get sorted by x-coord then sorted by y-coord, first sort by y-coord\n            // then sort by x-coord (since Arrays.sort is stable)\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res.add(ptsByX); res.add(pysByY);\n            return res;\n        }\n\n        public static ArrayList<ArrayList<Double[]>> solve(ArrayList<ArrayList<Double[]>> P) { \n            ArrayList<Double[]> Px = new ArrayList<Double[]>();\n            ArrayList<Double[]> Py = new ArrayList<Double[]>();\n            Px = P.get(0); Py = P.get(1);            \n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.size() == 2) {\n                return P;\n            } else if (Px.size() == 3) {\n                Double[] p1 = Px.get(0); Double[] p2 = Px.get(1); Double[] p3 = Px.get(2);\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (d12 - Math.pow(10, -10) <= minD && minD <= d12 + Math.pow(10, -10)) {\n                    return convertToForm(p1, p2);\n                } else if (d13 - Math.pow(10, -10) <= minD && minD <= d13 + Math.pow(10, -10)) {\n                    return convertToForm(p1, p3);\n                } else if (d23 - Math.pow(10, -10) <= minD && minD <= d23 + Math.pow(10, -10)) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3); // it fails here, this is just to return the right data struct\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.size();\n                assert L > 1;\n                ArrayList<Double[]> Qx = new ArrayList<Double[]>();\n                ArrayList<Double[]> Rx = new ArrayList<Double[]>();\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx.add(Px.get(i));\n                    } else {\n                        Rx.add(Px.get(i));\n                    }\n                }\n                ArrayList<Double[]> Qy = new ArrayList<Double[]>();\n                ArrayList<Double[]> Ry = new ArrayList<Double[]>();\n                Double k = Qx.get(Qx.size()-1)[0]; \n                Double l = Qx.get(Qx.size()-1)[1];\n                for (int i=0; i < Py.size(); i++) {\n                    Double[] pt = Py.get(i);\n                    if (pt[0] < k) {\n                        Qy.add(pt);\n                    } else if (pt[0] == k) {\n                        if (pt[1] <= l) {\n                            Qy.add(pt);\n                        } else {\n                           Ry.add(pt);\n                        }\n                    } else {\n                        Ry.add(pt);\n                    }\n                }\n                assert Qy.size() == Qx.size();\n                assert Ry.size() == Rx.size();\n                assert Qx.size() >= 2;\n                \n                // now use recursion\n                ArrayList<ArrayList<Double[]>> Q = new ArrayList<ArrayList<Double[]>>();\n                ArrayList<ArrayList<Double[]>> R = new ArrayList<ArrayList<Double[]>>();\n                Q.add(Qx); Q.add(Qy); R.add(Rx); R.add(Ry);\n                assert Q.size() >= 2;\n                ArrayList<ArrayList<Double[]>> c1 = solve(Q);\n                ArrayList<ArrayList<Double[]>> c2 = solve(R);\n                Double Dc1 = dist(c1.get(0).get(0), c1.get(0).get(1)); // returns SQUARED distance\n                Double Dc2 = dist(c2.get(0).get(0), c2.get(0).get(1)); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                ArrayList<ArrayList<Double[]>> bestpair = new ArrayList<ArrayList<Double[]>>();\n                \n                if (Dc1 - Math.pow(10, -10) <= D && D <= Dc1 + Math.pow(10, -10)) {\n                    bestpair = c1;\n                } else if (Dc2 - Math.pow(10, -10) <= D && D <= Dc2 + Math.pow(10, -10)) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                ArrayList<ArrayList<Double[]>> c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return c3;\n            }\n        }\n\n        public static void main(String[] args) {   \n            Scanner scan = new Scanner(System.in);\n            int N = scan.nextInt();\n            \n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> ptsByY = new ArrayList<Double[]>();\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {scan.nextDouble(), scan.nextDouble()};\n                ptsByX.add(coords); ptsByY.add(coords);\n            }\n            scan.close();\n            \n            // now sort by x coord\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> P = new ArrayList<ArrayList<Double[]>>();\n            P.add(ptsByX); P.add(ptsByY);\n            assert P.size() == 2;\n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res = solve(P);\n            \n            DecimalFormat df = new DecimalFormat();\n            df.setMaximumFractionDigits(10);\n            System.out.println(df.format(Math.pow(dist(res.get(0).get(0), res.get(0).get(1)), 0.5)));\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.text.DecimalFormat;\n\nclass Main {\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static Double[][][] splitpair(Double[][] px, Double[][] py, double d) {  \n            double xBar = px[(px.length+1)/2][0]; // largest x-coordinate of the left half of px\n            List<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.length; i++) {\n                if (Math.abs(py[i][0] - xBar) < d + Math.pow(10,-10)) { //only consider a 'strip' \n     // around xBar that is 2*d wide\n                    Sy.add(py[i]); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            Double[][] bestpair = new Double[2][2]; // the coords of the best pair of points so far\n            int foundBetter = 0;\n   \n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair[0] = p; bestpair[1] = q;\n                        bestD = dist(p, q);\n                        foundBetter = 1;\n                    }\n                }\n            }\n            \n            if (foundBetter == 0) {\n                return null;\n            }\n            \n            Double[][][] res = new Double[2][2][2];\n            res = convertToForm(bestpair[0], bestpair[1]);\n            return res;\n        }\n   \n        public static Double[][][] convertToForm(Double[] a, Double[] b) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            Double[][] byX = {a, b};\n            Double[][] byY = {a, b};\n            // now sort by x coord\n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Double[][][] res = {byX, byY};\n            return res;\n        }\n\n        public static Double[][][] solve(Double[][][] P) { \n            Double[][] Px = P[0];\n            Double[][] Py = P[1];\n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.length == 2) {\n                return P;\n            } else if (Px.length == 3) {\n                Double[] p1 = Px[0]; Double[] p2 = Px[1]; Double[] p3 = Px[2];\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (Math.abs(d12 - minD) < Math.pow(10, -10)) {\n                    return convertToForm(p1, p2);\n                } else if (Math.abs(d13 - minD) < Math.pow(10, -10)) {\n                    return convertToForm(p1, p3);\n                } else if (Math.abs(d23 - minD)  < Math.pow(10, -10)) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3); // it fails here, this is just to return the right data struct\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.length;\n                assert L > 1;\n                Double[][] Qx = new Double[L/2][2];\n                Double[][] Rx = new Double[L-L/2][2];\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx[i] = Px[i];\n                    } else {\n                        Rx[i-L/2] = Px[i];\n                    }\n                }\n                Double[][] Qy = new Double[L/2][2];\n                Double[][] Ry = new Double[L-L/2][2];\n                Double k = Qx[Qx.length-1][0]; \n                Double l = Qx[Qx.length-1][1];\n                int cntQy = 0; int cntRy = 0; \n                for (int i=0; i < Py.length; i++) {\n                    Double[] pt = Py[i];\n                    if (pt[0] < k) {\n                        Qy[cntQy++] = pt;\n                    } else if (Math.abs(pt[0] - k) < Math.pow(10, -10)) {\n                        if (pt[1] <= l) {\n                            Qy[cntQy++] = pt;\n                        } else {\n                            Ry[cntRy++] = pt;\n                        }\n                    } else {\n                        Ry[cntRy++] = pt;\n                    }\n                }\n                \n                // now use recursion\n                Double[][][] Q = {Qx, Qy};\n                Double[][][] R = {Rx, Ry};\n                assert Q.length >= 2;\n                Double[][][] c1 = solve(Q);\n                Double[][][] c2 = solve(R);\n                Double Dc1 = dist(c1[0][0], c1[0][1]); // returns SQUARED distance\n                Double Dc2 = dist(c2[0][0], c2[0][1]); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                Double[][][] bestpair = new Double[2][2][2];\n                \n                if (Math.abs(Dc1 - D) < Math.pow(10, -10)) {\n                    bestpair = c1;\n                } else if (Math.abs(Dc2 - D) < Math.pow(10, -10)) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                Double[][][] c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return c3;\n            }\n        }\n        \n        public static void main(String[] args) {   \n            \n            // timer stuffs\n            long startTime = System.nanoTime();\n            \n            Scanner scan = new Scanner(System.in);\n            int N = scan.nextInt();\n            \n            Double[][] ptsByX = new Double[N][2];\n            Double[][] ptsByY = new Double[N][2];\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {scan.nextDouble(), scan.nextDouble()};\n                ptsByX[i] = coords; ptsByY[i] = coords;\n            }\n            scan.close();\n            \n            // sort by x coord\n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    if (Math.abs(doubles[0] - otherDoubles[0]) < Math.pow(10, -8)) {\n                        return doubles[1].compareTo(otherDoubles[1]); \n                    }\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            \n            // sort by y-coord\n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    if (Math.abs(doubles[1] - otherDoubles[1]) < Math.pow(10, -8)) {\n                        return doubles[0].compareTo(otherDoubles[0]); \n                    }\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            });\n            \n            Double[][][] P = new Double[2][N][2];\n            P[0] = ptsByX; P[1] = ptsByY;\n            assert P.length == 2;\n            \n            long endTime = System.nanoTime();\n            long duration = (endTime - startTime)/1000000;\n            //System.out.println(duration);\n            \n            Double[][][] res = new Double[2][2][2];\n            res = solve(P);\n           \n            DecimalFormat df = new DecimalFormat();\n            df.setMaximumFractionDigits(10);\n            System.out.println(df.format(Math.pow(dist(res[0][0], res[0][1]), 0.5)));\n            \n            endTime = System.nanoTime();\n            duration = (endTime - startTime)/1000000;\n           \n            //System.out.println(N);\n            //System.out.println(duration);\n            \n        }\n}import java.util.*;\nimport java.text.DecimalFormat;\n\nclass ClosestPair2 {\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static Double[][][] splitpair(Double[][] px, Double[][] py, double d) {  \n            double xBar = px[(px.length+1)/2][0]; // largest x-coordinate of the left half of px\n            List<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.length; i++) {\n                if (Math.abs(py[i][0] - xBar) < d + Math.pow(10,-10)) { //only consider a 'strip' \n     // around xBar that is 2*d wide\n                    Sy.add(py[i]); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            Double[][] bestpair = new Double[2][2]; // the coords of the best pair of points so far\n            int foundBetter = 0;\n   \n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair[0] = p; bestpair[1] = q;\n                        bestD = dist(p, q);\n                        foundBetter = 1;\n                    }\n                }\n            }\n            \n            if (foundBetter == 0) {\n                return null;\n            }\n            \n            Double[][][] res = new Double[2][2][2];\n            res = convertToForm(bestpair[0], bestpair[1]);\n            return res;\n        }\n   \n        public static Double[][][] convertToForm(Double[] a, Double[] b) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            Double[][] byX = {a, b};\n            Double[][] byY = {a, b};\n            // now sort by x coord\n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Double[][][] res = {byX, byY};\n            return res;\n        }\n\n        public static Double[][][] solve(Double[][][] P) { \n            Double[][] Px = P[0];\n            Double[][] Py = P[1];\n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.length == 2) {\n                return P;\n            } else if (Px.length == 3) {\n                Double[] p1 = Px[0]; Double[] p2 = Px[1]; Double[] p3 = Px[2];\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (Math.abs(d12 - minD) < Math.pow(10, -10)) {\n                    return convertToForm(p1, p2);\n                } else if (Math.abs(d13 - minD) < Math.pow(10, -10)) {\n                    return convertToForm(p1, p3);\n                } else if (Math.abs(d23 - minD)  < Math.pow(10, -10)) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3); // it fails here, this is just to return the right data struct\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.length;\n                assert L > 1;\n                Double[][] Qx = new Double[L/2][2];\n                Double[][] Rx = new Double[L-L/2][2];\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx[i] = Px[i];\n                    } else {\n                        Rx[i-L/2] = Px[i];\n                    }\n                }\n                Double[][] Qy = new Double[L/2][2];\n                Double[][] Ry = new Double[L-L/2][2];\n                Double k = Qx[Qx.length-1][0]; \n                Double l = Qx[Qx.length-1][1];\n                int cntQy = 0; int cntRy = 0; \n                for (int i=0; i < Py.length; i++) {\n                    Double[] pt = Py[i];\n                    if (pt[0] < k) {\n                        Qy[cntQy++] = pt;\n                    } else if (Math.abs(pt[0] - k) < Math.pow(10, -10)) {\n                        if (pt[1] <= l) {\n                            Qy[cntQy++] = pt;\n                        } else {\n                            Ry[cntRy++] = pt;\n                        }\n                    } else {\n                        Ry[cntRy++] = pt;\n                    }\n                }\n                \n                // now use recursion\n                Double[][][] Q = {Qx, Qy};\n                Double[][][] R = {Rx, Ry};\n                assert Q.length >= 2;\n                Double[][][] c1 = solve(Q);\n                Double[][][] c2 = solve(R);\n                Double Dc1 = dist(c1[0][0], c1[0][1]); // returns SQUARED distance\n                Double Dc2 = dist(c2[0][0], c2[0][1]); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                Double[][][] bestpair = new Double[2][2][2];\n                \n                if (Math.abs(Dc1 - D) < Math.pow(10, -10)) {\n                    bestpair = c1;\n                } else if (Math.abs(Dc2 - D) < Math.pow(10, -10)) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                Double[][][] c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return c3;\n            }\n        }\n        \n        public static void main(String[] args) {   \n            \n            // timer stuffs\n            long startTime = System.nanoTime();\n            \n            Scanner scan = new Scanner(System.in);\n            int N = scan.nextInt();\n            \n            Double[][] ptsByX = new Double[N][2];\n            Double[][] ptsByY = new Double[N][2];\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {scan.nextDouble(), scan.nextDouble()};\n                ptsByX[i] = coords; ptsByY[i] = coords;\n            }\n            scan.close();\n            \n            // sort by x coord\n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    if (Math.abs(doubles[0] - otherDoubles[0]) < Math.pow(10, -8)) {\n                        return doubles[1].compareTo(otherDoubles[1]); \n                    }\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            \n            // sort by y-coord\n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    if (Math.abs(doubles[1] - otherDoubles[1]) < Math.pow(10, -8)) {\n                        return doubles[0].compareTo(otherDoubles[0]); \n                    }\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            });\n            \n            Double[][][] P = new Double[2][N][2];\n            P[0] = ptsByX; P[1] = ptsByY;\n            assert P.length == 2;\n            \n            long endTime = System.nanoTime();\n            long duration = (endTime - startTime)/1000000;\n            //System.out.println(duration);\n            \n            Double[][][] res = new Double[2][2][2];\n            res = solve(P);\n           \n            DecimalFormat df = new DecimalFormat();\n            df.setMaximumFractionDigits(10);\n            System.out.println(df.format(Math.pow(dist(res[0][0], res[0][1]), 0.5)));\n            \n            endTime = System.nanoTime();\n            duration = (endTime - startTime)/1000000;\n           \n            //System.out.println(N);\n            //System.out.println(duration);\n            \n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\tstatic Point[] p;\n\tstatic int n;\n\t\n\tpublic static void main(String[] args) {\n\t\tn = sc.nextInt();\n\t\tp = new Point[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tp[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t}\n\t\t\n\t\tArrays.sort(p, new Comparator<Point>() {\n\t\t\tpublic int compare(Point p1, Point p2) {\n\t\t\t\tif(p1.x < p2.x) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tdouble d = closestPair(0, n);\n\t\tDecimalFormat df = new DecimalFormat(\"#######0.0########\");\n\t\tSystem.out.println(df.format(Math.sqrt(d)));\n\t}\n\t\n\tstatic double closestPair(int l, int r) {\n\t\tif(r - l <= 1) {\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}\n\t\tif(r - l <= 2) {\n\t\t\tdouble dx = Math.abs(p[l].x - p[l+1].x);\n\t\t\tdouble dy = Math.abs(p[l].y - p[l+1].y);\n\t\t\treturn dx*dx + dy*dy;\n\t\t}\n\t\t\n\t\tint m = (l + r) / 2;\n\t\tdouble x = p[m].x;\n\t\tdouble d = Math.min(closestPair(l, m-1), closestPair(m, r));\n\t\tmerge(l, m, r);\n\t\t\n\t\tArrayList<Point> pa = new ArrayList<>();\n\t\tfor(int i=l; i<r; i++) {\n\t\t\tif(Math.abs(p[i].x - x) >= d) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=pa.size()-1; j>=0; j--) {\n\t\t\t\tdouble dx = Math.abs(p[i].x - p[j].x);\n\t\t\t\tdouble dy = Math.abs(p[i].y - p[j].y);\n\t\t\t\tif(dy >= d) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td = Math.min(d, dx*dx + dy*dy);\n\t\t\t}\n\t\t\tpa.add(p[i]);\n\t\t}\n\t\t\n\t\treturn d;\n\t}\n\t\n\tstatic class Point {\n\t\tdouble x;\n\t\tdouble y;\n\t\tPoint(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tstatic void merge(int l, int m, int r) {\n\t\tPoint[] ptemp = Arrays.copyOf(p, n);\n\t\tint i = l;\n\t\tint j = m;\n\t\tint k = l;\n\t\twhile(i != m || j != r) {\n\t\t\tif(j == r || i != m && p[i].y < p[j].y) {\n\t\t\t\tptemp[k] = p[i];\n\t\t\t\ti++;\n\t\t\t\tk++;\n\t\t\t} else {\n\t\t\t\tptemp[k] = p[j];\n\t\t\t\tj++;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tp = ptemp;\n\t}\n\t\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static ArrayList<Double[]> splitpair(ArrayList<Double[]> px, ArrayList<Double[]> py, double d) {        \n            double xBar = px.get(px.size()/2)[0]; // largest x-coordinate of the left half of px\n            ArrayList<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.size(); i++) {\n                if (xBar - d <= py.get(i)[0] && py.get(i)[0]<= xBar + d) { //only consider a 'strip' \n                    // around xBar that is 2*d wide\n                    Sy.add(py.get(i)); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            \n            ArrayList<Double[]> bestpair = new ArrayList<Double[]>(); // the coords of the best pair of points so far\n            Double[] x = {0.0, 0.0}; Double[] y = {0.0, 0.0};\n            bestpair.add(x); bestpair.add(y);\n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair.clear(); bestpair.add(p); bestpair.add(q);\n                        bestD = dist(p, q);\n                    }\n                }\n            }\n            return bestpair;\n        }\n   \n        public static ArrayList<ArrayList<Double[]>> convertToForm(Double[] x, Double[] y) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> pysByY = new ArrayList<Double[]>();\n            ptsByX.add(x); ptsByX.add(y); pysByY.add(x); pysByY.add(y);\n            // to get sorted by x-coord then sorted by y-coord, first sort by y-coord\n            // then sort by x-coord (since Arrays.sort is stable)\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res.add(ptsByX); res.add(pysByY);\n            return res;\n        }\n\n        public static ArrayList<ArrayList<Double[]>> solve(ArrayList<ArrayList<Double[]>> P) { \n            ArrayList<Double[]> Px = new ArrayList<Double[]>();\n            ArrayList<Double[]> Py = new ArrayList<Double[]>();\n            Px = P.get(0); Py = P.get(1);\n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.size() == 2) {\n                ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n                res.add(Px); res.add(Py);\n                return res;\n            } else if (Px.size() == 3) {\n                Double[] p1 = Px.get(0); Double[] p2 = Px.get(1); Double[] p3 = Px.get(2);\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (minD == d12) {\n                    return convertToForm(p1, p2);\n                } else if (minD == d13) {\n                    return convertToForm(p1, p3);\n                } else {\n                    return convertToForm(p2, p3);\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.size();\n                ArrayList<Double[]> Qx = new ArrayList<Double[]>();\n                ArrayList<Double[]> Rx = new ArrayList<Double[]>();\n                for (int i = 0; i < L; i++) {\n                    if (i <= L/2) {\n                        Qx.add(Px.get(i));\n                    } else {\n                        Rx.add(Px.get(i));\n                    }\n                }\n                ArrayList<Double[]> Qy = new ArrayList<Double[]>();\n                ArrayList<Double[]> Ry = new ArrayList<Double[]>();\n                Double k = Qx.get(Qx.size()-1)[0]; Double l = Qx.get(Qx.size()-1)[1];\n                \n                for (int i=0; i < Py.size(); i++) {\n                    if (Py.get(i)[0] < k) {\n                        Qy.add(Py.get(i));\n                    } else if (Py.get(i)[0] == k) {\n                        if (Py.get(i)[1] <= l) {\n                            Qy.add(Py.get(i));\n                        } else {\n                           Ry.add(Py.get(i));\n                        }\n                    } else {\n                        Qy.add(Py.get(i));\n                    }\n                }\n            \n                // now use recursion\n                ArrayList<ArrayList<Double[]>> Q = new ArrayList<ArrayList<Double[]>>();\n                ArrayList<ArrayList<Double[]>> R = new ArrayList<ArrayList<Double[]>>();\n                Q.add(Qx); Q.add(Qy); R.add(Rx); R.add(Ry);\n                ArrayList<ArrayList<Double[]>> c1 = solve(Q);\n                ArrayList<ArrayList<Double[]>> c2 = solve(R);\n                \n                Double Dc1 = dist(c1.get(0).get(0), c1.get(0).get(1)); // returns SQUARED distance\n                Double Dc2 = dist(c2.get(0).get(0), c2.get(0).get(1)); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                ArrayList<ArrayList<Double[]>> bestpair = new ArrayList<ArrayList<Double[]>>();\n                \n                if (D == Dc1) {\n                    bestpair = c1;\n                } else if (D == Dc2) {\n                    bestpair = c2;\n                }\n                \n                ArrayList<Double[]> c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                ArrayList<Double[]> nobestpair = new ArrayList<Double[]>();\n                Double[] x = {0.0, 0.0}; Double[] y = {0.0, 0.0};\n                nobestpair.add(x); nobestpair.add(y);\n                \n                if (c3 != nobestpair) {\n                    bestpair = convertToForm(c3.get(0), c3.get(1));\n                }\n                \n                return bestpair;\n            }\n        }\n\n        public static void main(String[] args) {   \n            Scanner scan = new Scanner(System.in);\n            int N = scan.nextInt();\n            \n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> ptsByY = new ArrayList<Double[]>();\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {scan.nextDouble(), scan.nextDouble()};\n                ptsByX.add(coords); ptsByY.add(coords);\n            }\n            scan.close();\n            \n            // now sort by x coord\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> P = new ArrayList<ArrayList<Double[]>>();\n            P.add(ptsByX); P.add(ptsByY);\n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res = solve(P);\n            \n            System.out.println(Math.pow(dist(res.get(0).get(0), res.get(0).get(1)), 0.5));\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\tstatic Point[] p;\n\tstatic int n;\n\t\n\tpublic static void main(String[] args) {\n\t\tn = sc.nextInt();\n\t\tp = new Point[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tp[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t}\n\t\t\n\t\tArrays.sort(p, new Comparator<Point>() {\n\t\t\tpublic int compare(Point p1, Point p2) {\n\t\t\t\tif(p1.x < p2.x) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tdouble d = closestPair(0, n);\n\t\tSystem.out.println(Math.sqrt(d));\n\t}\n\t\n\tstatic double closestPair(int l, int r) {\n\t\tif(r - l <= 1) {\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}\n\t\tint m = (l + r) / 2;\n\t\tdouble x = p[m].x;\n\t\tdouble d = Math.min(closestPair(l, m), closestPair(m, r));\n\t\t\n\t\tArrayList<Point> pa = new ArrayList<>();\n\t\tfor(int i=l; i<r; i++) {\n\t\t\tif(Math.abs(p[i].x - x) >= d) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=pa.size()-1; j>=0; j--) {\n\t\t\t\tdouble dx = Math.abs(p[i].x - p[j].x);\n\t\t\t\tdouble dy = Math.abs(p[i].y - p[j].y);\n\t\t\t\tif(dy >= d) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td = Math.min(d, dx*dx + dy*dy);\n\t\t\t}\n\t\t\tpa.add(p[i]);\n\t\t}\n\t\t\n\t\treturn d;\n\t}\n\t\n\tstatic class Point {\n\t\tdouble x;\n\t\tdouble y;\n\t\tPoint(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tstatic void merge(int l, int m, int r) {\n\t\tPoint[] ptemp = Arrays.copyOf(p, n);\n\t\tint i = l;\n\t\tint j = m;\n\t\twhile(i != m || j != r) {\n\t\t\tif(j == r || i != m && p[i].y < p[j].y) {\n\t\t\t\tptemp[i+j] = p[i];\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tptemp[i+j] = p[j];\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tp = ptemp;\n\t}\n\t\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "# #### CLOSEST PAIR O(N LOG N) ALGORITHM #### #\n# points should be unique, otherwise the closest pair would be the repeated points\n# also this will only find 1 pair with the smallest distance, in case there are multiple pairs with this same minimum distance\n\n#import time\n#start = time.time()\n\n\ndef dist(x, y): # for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n\treturn (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\n\t\ndef splitpair(px, py, d): # only need to return a value if closest pair is split between left and right halves\n\txBar = px[(len(px)+1)/2][0] # large x-coordinate of the left half of px\n\tSy = [] # Sy will be the set of points (sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n\tfor i in xrange(len(py)):\n\t\tif xBar-d**0.5 <= py[i][0] <= xBar+d**0.5: # only consider a 'strip' around xBar that is 2*sqrt(d) wide\n\t\t\tSy.append(py[i]) # if exists a pair with dist less than d, it must be in this strip (obvious)\t\n\t\n\tbestpair = None # the coords of the best pair of points so far\n\tbestD = d # the squared distance of the best pair of points\n\t# now iterate through Sy for points that aren't more than 7 apart\n\t# if a pair exists that is closer than dist d, it must be within 7 of each other\n\t# ask me for proof if you haven't seen this observation before it's pretty cool\n\tfor i in xrange(len(Sy)-2):\n\t\tfor j in xrange(1, min(8, len(Sy)-i-1)):  # 7 next points\n\t\t\tp, q = Sy[i], Sy[i+j]\n\t\t\t\n\t\t\tif dist(p, q) < bestD:\n\t\t\t\tbestpair = [p, q]\n\t\t\t\tbestD = dist(p, q)\n\t\t\t\t\n\treturn bestpair\n\t\ndef convert(p1, p2): # convert 2 points into two pairs of pairs, first sorted by x, other sorted by y\n\treturn [sorted([p1, p2]), sorted([p1, p2], key=lambda x: x[1])]\n\t\ndef solve(Px, Py): # where Px and Py are the points sorted by x and y coordinate respectively\n\t# this function returns two closest points\n\tif len(Px) == 2:\n\t\treturn (Px, Py)\n\telif len(Px) == 3: # 3 points, brute force\n\t\tp1, p2, p3 = [x for x in Px]\n\t\td12, d13, d23 = dist(p1, p2), dist(p1, p3), dist(p2, p3)\n\t\tif min(d12, d13, d23) == d12: \n\t\t\treturn convert(p1, p2)\n\t\telif min(d12, d13, d23) == d13: \n\t\t\treturn convert(p1, p3)\n\t\telse: \n\t\t\treturn convert(p2, p3)\n\telse:\n\t\t# split the left and right halves of all points (by x coord)\n\t\tL = len(Px)\n\t\tQx, Rx = Px[:L/2], Px[L/2:]\n\t\tQy, Ry = [], []\n\t\tk, l = Qx[-1][0], Qx[-1][1] # x and y coords of the rightmost element in Qx\n\t\tfor pt in Py: # this is linear time, you loop through Py exactly once.\n\t\t\t# need this in order \n\t\t\tif pt[0] < k:\n\t\t\t\tQy.append(pt)\n\t\t\telif pt[0] == k:\n\t\t\t\tif pt[1] <= l:\n\t\t\t\t\tQy.append(pt)\n\t\t\t\telse:\n\t\t\t\t\tRy.append(pt)\n\t\t\telse:\n\t\t\t\tRy.append(pt)\n\t\t\n\t\t# now use recursion. note ci is of the form [[x1,x2], [y1,y2]]\n\t\tc1 = solve(Qx, Qy) # find the closest pair in left half\n\t\tc2 = solve(Rx, Ry) # find the closest pair in the right half\n\t\t\n\t\tD = min(dist(c1[0][0], c1[0][1]), dist(c2[0][0], c2[0][1])) # get the min distance of both of these to solve split case\n\t\tif D == dist(c1[0][0], c1[0][1]):\n\t\t\tbestpair = c1\n\t\telif D == dist(c2[0][0], c2[0][1]):\n\t\t\tbestpair = c2\n\t\t\n\t\tc3 = splitpair(Px, Py, D) # find the closest split pair. this needs to be O(n) to get O(n log n) for entire algo\n\t\t\n\t\tif c3 is not None: \n\t\t\treturn convert(c3[0], c3[1])\n\t\telse:\n\t\t\treturn [bestpair[0], bestpair[1]] # else it's one of the c1 or c2\n\t\t\n\t\t\ndef main():\n\tN = int(raw_input().split()[0]) # N is number of points\n\tpts = [] # pairs of points, i.e pts = [[x1,y1], [x2,y2], ... , [xn,yn]]\n\t\n\t# get all pairs of points into our list\n\tfor i in xrange(N):\n\t\tpts.append([float(x) for x in raw_input().split()])\n\t\t\n\tPx = sorted(pts) # sort the pts by x coordinate\n\tPy = sorted(pts, key=lambda x: x[1]) # sort the pts by y coordinate\n\t\n\tres = solve(Px, Py) # keep one copy sorted by x coord, the other sorted by y coord to keep the split in half in linear time\n\t\n\tprint \"%.10f\" % (dist(res[0][0], res[0][1]) ** 0.5)\n\nif __name__ == '__main__':\n\tmain()\n\n\n#print \"%.2f %s\" % (((time.time() - start) * 1000), \"ms\")"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.text.DecimalFormat;\n\nclass ClosestPair {\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static ArrayList<ArrayList<Double[]>> splitpair(ArrayList<Double[]> px, ArrayList<Double[]> py, double d) {  \n            double xBar = px.get(px.size()/2)[0]; // largest x-coordinate of the left half of px\n            ArrayList<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.size(); i++) {\n                if (xBar - d <= py.get(i)[0] && py.get(i)[0]<= xBar + d) { //only consider a 'strip' \n                    // around xBar that is 2*d wide\n                    Sy.add(py.get(i)); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            ArrayList<ArrayList<Double[]>> bestpair = new ArrayList<ArrayList<Double[]>>(); // the coords of the best pair of points so far\n            bestpair = null;\n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair = convertToForm(p,q);\n                        bestD = dist(p, q);\n                    }\n                }\n            }\n            \n            return bestpair;\n        }\n   \n        public static ArrayList<ArrayList<Double[]>> convertToForm(Double[] x, Double[] y) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> pysByY = new ArrayList<Double[]>();\n            ptsByX.add(x); ptsByX.add(y); pysByY.add(x); pysByY.add(y);\n            // to get sorted by x-coord then sorted by y-coord, first sort by y-coord\n            // then sort by x-coord (since Arrays.sort is stable)\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res.add(ptsByX); res.add(pysByY);\n            return res;\n        }\n\n        public static ArrayList<ArrayList<Double[]>> solve(ArrayList<ArrayList<Double[]>> P) { \n            ArrayList<Double[]> Px = new ArrayList<Double[]>();\n            ArrayList<Double[]> Py = new ArrayList<Double[]>();\n            Px = P.get(0); Py = P.get(1);            \n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.size() == 2) {\n                return P;\n            } else if (Px.size() == 3) {\n                Double[] p1 = Px.get(0); Double[] p2 = Px.get(1); Double[] p3 = Px.get(2);\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (d12 - Math.pow(10, -8) <= minD && minD <= d12 + Math.pow(10, -8)) {\n                    return convertToForm(p1, p2);\n                } else if (d13 - Math.pow(10, -8) <= minD && minD <= d13 + Math.pow(10, -8)) {\n                    return convertToForm(p1, p3);\n                } else if (d23 - Math.pow(10, -8) <= minD && minD <= d23 + Math.pow(10, -8)) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3);\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.size();\n                assert L > 1;\n                ArrayList<Double[]> Qx = new ArrayList<Double[]>();\n                ArrayList<Double[]> Rx = new ArrayList<Double[]>();\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx.add(Px.get(i));\n                    } else {\n                        Rx.add(Px.get(i));\n                    }\n                }\n                ArrayList<Double[]> Qy = new ArrayList<Double[]>();\n                ArrayList<Double[]> Ry = new ArrayList<Double[]>();\n                Double k = Qx.get(Qx.size()-1)[0]; \n                Double l = Qx.get(Qx.size()-1)[1];\n                for (int i=0; i < Py.size(); i++) {\n                    Double[] pt = Py.get(i);\n                    if (pt[0] < k) {\n                        Qy.add(pt);\n                    } else if (pt[0] == k) {\n                        if (pt[1] <= l) {\n                            Qy.add(pt);\n                        } else {\n                           Ry.add(pt);\n                        }\n                    } else {\n                        Ry.add(pt);\n                    }\n                }\n                assert Qy.size() == Qx.size();\n                assert Ry.size() == Rx.size();\n                assert Qx.size() >= 2;\n                \n                // now use recursion\n                ArrayList<ArrayList<Double[]>> Q = new ArrayList<ArrayList<Double[]>>();\n                ArrayList<ArrayList<Double[]>> R = new ArrayList<ArrayList<Double[]>>();\n                Q.add(Qx); Q.add(Qy); R.add(Rx); R.add(Ry);\n                assert Q.size() >= 2;\n                ArrayList<ArrayList<Double[]>> c1 = solve(Q);\n                ArrayList<ArrayList<Double[]>> c2 = solve(R);\n                Double Dc1 = dist(c1.get(0).get(0), c1.get(0).get(1)); // returns SQUARED distance\n                Double Dc2 = dist(c2.get(0).get(0), c2.get(0).get(1)); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                ArrayList<ArrayList<Double[]>> bestpair = new ArrayList<ArrayList<Double[]>>();\n                \n                if (Dc1 - Math.pow(10, -8) <= D && D <= Dc1 + Math.pow(10, -8)) {\n                    bestpair = c1;\n                } else if (Dc2 - Math.pow(10, -8) <= D && D <= Dc2 + Math.pow(10, -8)) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                ArrayList<ArrayList<Double[]>> c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return bestpair;\n            }\n        }\n\n        public static void main(String[] args) {   \n            Scanner scan = new Scanner(System.in);\n            int N = scan.nextInt();\n            \n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> ptsByY = new ArrayList<Double[]>();\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {scan.nextDouble()*1000, scan.nextDouble()*1000};\n                ptsByX.add(coords); ptsByY.add(coords);\n            }\n            scan.close();\n            \n            // now sort by x coord\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> P = new ArrayList<ArrayList<Double[]>>();\n            P.add(ptsByX); P.add(ptsByY);\n            assert P.size() == 2;\n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res = solve(P);\n            \n            DecimalFormat df = new DecimalFormat();\n            df.setMaximumFractionDigits(10);\n            System.out.println(df.format(Math.pow(dist(res.get(0).get(0), res.get(0).get(1)), 0.5)/1000.0));\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// 入力\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tList<Vector2d> p = new ArrayList<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble x = sc.nextDouble();\n\t\t\tdouble y = sc.nextDouble();\n\t\t\tp.add(new Vector2d(x, y));\n\t\t}\n\t\tsc.close();\n\t\tp.sort(new Vector2dComparator());\n\t\tSystem.out.println(String.format(\"%1$.7f\", solve(p)));\n\t}\n\n\tstatic class Vector2d {\n\t\tVector2d(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"%1$.6f %2$.6f\", x, y);\n\t\t}\n\n\t\tpublic static double norm(Vector2d v1, Vector2d v2) {\n\t\t\treturn Math.sqrt(Math.pow(v2.x - v1.x, 2) + Math.pow(v2.y - v1.y, 2));\n\t\t}\n\n\t}\n\n\tstatic class Vector2dComparator implements Comparator<Vector2d> {\n\t\t@Override\n\t\tpublic int compare(Vector2d v1, Vector2d v2) {\n\t\t\tdouble x = v1.x - v2.x;\n\t\t\tdouble y = v1.y - v2.y;\n\t\t\tif (x == 0) {\n\t\t\t\tif (y < 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else if (x < 0) {\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static double solve(List<Vector2d> p) {\n\n\t\tdouble d;\n\t\tif (p.size() == 1) {\n\t\t\t// 点が1個の場合は距離∞\n\t\t\td = Double.MAX_VALUE;\n\t\t} else if (p.size() == 2) {\n\t\t\t// 点が2個の場合は普通に計算\n\t\t\td = Vector2d.norm(p.get(0), p.get(1));\n\t\t} else {\n\t\t\t// 3個以上の場合は、まず左半分と右半分の最小距離の小さい方\n\t\t\tdouble dTemp = Math.min(solve(p.subList(0, p.size() / 2)), solve(p.subList(p.size() / 2, p.size())));\n\t\t\t// そのあと、左と右の間でdを更新できるペアを探す\n\t\t\t// 左右間ペア候補を絞る\n\t\t\tdouble midX = p.get(p.size() / 2).x;\n\t\t\tList<Vector2d> yl = p.stream().filter(v -> 0 < midX - v.x && midX - v.x <= dTemp).collect(Collectors.toList());\n\t\t\tList<Vector2d> yr = p.stream().filter(v -> 0 <= v.x - midX && v.x - midX <= dTemp).collect(Collectors.toList());\n\t\t\t// 左右間ペアでdを更新\n\t\t\td = updateByLRPair(yl, yr, dTemp);\n\t\t}\n\t\treturn d;\n\t}\n\n\t// 左右間ペアでdを更新\n\tpublic static double updateByLRPair(List<Vector2d> yl, List<Vector2d> yr, double d) {\n\t\tdouble ans = d;\n\t\tfor(Vector2d vl: yl) {\n\t\t\tfor(Vector2d vr: yr.stream().filter(v -> Math.abs(v.y - vl.y) <= d).collect(Collectors.toList())) {\n\t\t\t\tif(ans > Vector2d.norm(vl, vr)) {\n\t\t\t\t\tans = Vector2d.norm(vl, vr);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static ArrayList<Double[]> splitpair(ArrayList<Double[]> px, ArrayList<Double[]> py, double d) {        \n            double xBar = px.get(px.size()/2)[0]; // largest x-coordinate of the left half of px\n            ArrayList<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.size(); i++) {\n                if (xBar - d <= py.get(i)[0] && py.get(i)[0]<= xBar + d) { //only consider a 'strip' \n                    // around xBar that is 2*d wide\n                    Sy.add(py.get(i)); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            \n            ArrayList<Double[]> bestpair = new ArrayList<Double[]>(); // the coords of the best pair of points so far\n            Double[] x = {0.0, 0.0}; Double[] y = {0.0, 0.0};\n            bestpair.add(x); bestpair.add(y);\n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair.clear(); bestpair.add(p); bestpair.add(q);\n                        bestD = dist(p, q);\n                    }\n                }\n            }\n            return bestpair;\n        }\n   \n        public static ArrayList<ArrayList<Double[]>> convertToForm(Double[] x, Double[] y) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> pysByY = new ArrayList<Double[]>();\n            ptsByX.add(x); ptsByX.add(y); pysByY.add(x); pysByY.add(y);\n            // to get sorted by x-coord then sorted by y-coord, first sort by y-coord\n            // then sort by x-coord (since Arrays.sort is stable)\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res.add(ptsByX); res.add(pysByY);\n            return res;\n        }\n\n        public static ArrayList<ArrayList<Double[]>> solve(ArrayList<ArrayList<Double[]>> P) { \n            ArrayList<Double[]> Px = new ArrayList<Double[]>();\n            ArrayList<Double[]> Py = new ArrayList<Double[]>();\n            Px = P.get(0); Py = P.get(1);\n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.size() == 2) {\n                return P;\n            } else if (Px.size() == 3) {\n                Double[] p1 = Px.get(0); Double[] p2 = Px.get(1); Double[] p3 = Px.get(2);\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (minD == d12) {\n                    return convertToForm(p1, p2);\n                } else if (minD == d13) {\n                    return convertToForm(p1, p3);\n                } else {\n                    return convertToForm(p2, p3);\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.size();\n                assert L > 1;\n                ArrayList<Double[]> Qx = new ArrayList<Double[]>();\n                ArrayList<Double[]> Rx = new ArrayList<Double[]>();\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx.add(Px.get(i));\n                    } else {\n                        Rx.add(Px.get(i));\n                    }\n                }\n                ArrayList<Double[]> Qy = new ArrayList<Double[]>();\n                ArrayList<Double[]> Ry = new ArrayList<Double[]>();\n                Double k = Qx.get(Qx.size()-1)[0]; \n                Double l = Qx.get(Qx.size()-1)[1];\n                for (int i=0; i < Py.size(); i++) {\n                    Double[] pt = Py.get(i);\n                    if (pt[0] < k) {\n                        Qy.add(pt);\n                    } else if (pt[0] == k) {\n                        if (pt[1] <= l) {\n                            Qy.add(pt);\n                        } else {\n                           Ry.add(pt);\n                        }\n                    } else {\n                        Ry.add(pt);\n                    }\n                }\n                assert Qy.size() == Qx.size();\n                assert Ry.size() == Rx.size();\n                \n                // now use recursion\n                ArrayList<ArrayList<Double[]>> Q = new ArrayList<ArrayList<Double[]>>();\n                ArrayList<ArrayList<Double[]>> R = new ArrayList<ArrayList<Double[]>>();\n                Q.add(Qx); Q.add(Qy); R.add(Rx); R.add(Ry);\n                ArrayList<ArrayList<Double[]>> c1 = solve(Q);\n                ArrayList<ArrayList<Double[]>> c2 = solve(R);\n                \n                Double Dc1 = dist(c1.get(0).get(0), c1.get(0).get(1)); // returns SQUARED distance\n                Double Dc2 = dist(c2.get(0).get(0), c2.get(0).get(1)); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                ArrayList<ArrayList<Double[]>> bestpair = new ArrayList<ArrayList<Double[]>>();\n                \n                if (D == Dc1) {\n                    bestpair = c1;\n                } else if (D == Dc2) {\n                    bestpair = c2;\n                }\n                \n                ArrayList<Double[]> c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                ArrayList<Double[]> nobestpair = new ArrayList<Double[]>();\n                Double[] x = {0.0, 0.0}; Double[] y = {0.0, 0.0};\n                nobestpair.add(x); nobestpair.add(y);\n                \n                if (c3 != nobestpair) {\n                    bestpair = convertToForm(c3.get(0), c3.get(1));\n                }\n                \n                return bestpair;\n            }\n        }\n\n        public static void main(String[] args) {   \n            Scanner scan = new Scanner(System.in);\n            int N = scan.nextInt();\n            \n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> ptsByY = new ArrayList<Double[]>();\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {scan.nextDouble(), scan.nextDouble()};\n                ptsByX.add(coords); ptsByY.add(coords);\n            }\n            scan.close();\n            \n            // now sort by x coord\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> P = new ArrayList<ArrayList<Double[]>>();\n            P.add(ptsByX); P.add(ptsByY);\n            assert P.size() == 2;\n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res = solve(P);\n            \n            System.out.println(Math.pow(dist(res.get(0).get(0), res.get(0).get(1)), 0.5));\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.text.DecimalFormat;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n \nclass ClosestPair3 {\n \n  static final double EPS = 1e-10;\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n       public static Double dist(Double[] x, Double[] y) {     \n         return (x[0]-y[0])*(x[0]-y[0]) + (x[1]-y[1])*(x[1]-y[1]);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static Double[][][] splitpair(Double[][] px, Double[][] py, double d) {  \n            double xBar = px[(px.length+1)/2][0]; // largest x-coordinate of the left half of px\n            List<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.length; i++) {\n                if (xBar - d - EPS <= py[i][0] && py[i][0]<= xBar + d + EPS) { //only consider a 'strip' \n                    // around xBar that is 2*d wide\n                    Sy.add(py[i]); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            Double[][][] bestpair = new Double[2][2][2]; // the coords of the best pair of points so far\n            bestpair = null;\n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair = convertToForm(p,q);\n                        bestD = dist(p, q);\n                    }\n                }\n            }\n            return bestpair;\n        }\n   \n        public static Double[][][] convertToForm(Double[] a, Double[] b) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            Double[][] byX = {a, b};\n            Double[][] byY = {a, b};\n            // now sort by x coord\n            if (byX[0][0] > byX[1][0] || \n                (byX[0][0] == byX[1][0] && byX[0][1] > byX[1][1])) {\n              Double[] tmp = byX[0];\n              byX[0] = byX[1];\n              byX[1] = tmp;\n            }\n            /*\n            Arrays.sort(byX, new Comparator<Double[]>(){\n                public int compare(Double[] a, Double[] b) {\n                  return a[0] != b[0] ? a[0] - b[0] : a[1] - b[1];\n                }\n            }); \n            */\n            // sort by y-coord\n            if (byX[0][1] > byX[1][1] || \n                (byX[0][1] == byX[1][1] && byX[0][0] > byX[1][0])) {\n              Double[] tmp = byX[0];\n              byX[0] = byX[1];\n              byX[1] = tmp;\n            }\n            /*\n            Arrays.sort(byY, new Comparator<Double[]>(){\n                public int compare(Double[] a, Double[] b) {\n                  return a[1] != b[1] ? a[1] - b[1] : a[0] - b[0];\n                }\n            }); \n            */\n            Double[][][] res = {byX, byY};\n            return res;\n        }\n \n        public static Double[][][] solve(Double[][][] P) { \n            Double[][] Px = P[0];\n            Double[][] Py = P[1];\n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.length == 2) {\n                return P;\n            } else if (Px.length == 3) {\n                Double[] p1 = Px[0]; Double[] p2 = Px[1]; Double[] p3 = Px[2];\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (Math.abs(d12 - minD) < EPS) {\n                    return convertToForm(p1, p2);\n                } else if (Math.abs(d13 - minD) < EPS) {\n                    return convertToForm(p1, p3);\n                } else if (Math.abs(d23 - minD) < EPS) {\n                    return convertToForm(p2, p3);\n                } else {\n                    System.out.println(\"HUNG!\");\n                    return convertToForm(p2, p3); // it fails here, this is just to return the right data struct\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.length;\n                assert L > 1;\n                Double[][] Qx = new Double[L/2][2];\n                Double[][] Rx = new Double[L-L/2][2];\n                for (int i = 0; i < L; i++) {\n                    if (i < L/2) {\n                        Qx[i] = Px[i];\n                    } else {\n                        Rx[i-L/2] = Px[i];\n                    }\n                }\n                Double[][] Qy = new Double[L/2][2];\n                Double[][] Ry = new Double[L-L/2][2];\n                Double k = Qx[Qx.length-1][0]; \n                Double l = Qx[Qx.length-1][1];\n                int cntQy = 0; int cntRy = 0; \n                for (int i=0; i < Py.length; i++) {\n                    Double[] pt = Py[i];\n                    if (pt[0] < k) {\n                        Qy[cntQy++] = pt;\n                    } else if (Math.abs(pt[0] - k) < EPS) {\n                        if (pt[1] <= l) {\n                            Qy[cntQy++] = pt;\n                        } else {\n                            Ry[cntRy++] = pt;\n                        }\n                    } else {\n                        Ry[cntRy++] = pt;\n                    }\n                }\n                \n                // now use recursion\n                Double[][][] Q = {Qx, Qy};\n                Double[][][] R = {Rx, Ry};\n                assert Q.length >= 2;\n                Double[][][] c1 = solve(Q);\n                Double[][][] c2 = solve(R);\n                Double Dc1 = dist(c1[0][0], c1[0][1]); // returns SQUARED distance\n                Double Dc2 = dist(c2[0][0], c2[0][1]); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                Double[][][] bestpair = new Double[2][2][2];\n                \n                if (Math.abs(Dc1 - D) < EPS) {\n                    bestpair = c1;\n                } else if (Math.abs(Dc2 - D) < EPS) {\n                    bestpair = c2;\n                } else {\n                    System.out.println(\"FUCK!\");\n                }\n                        \n                Double[][][] c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                if (c3 == null) {\n                    return bestpair;\n                }\n                return c3;\n            }\n        }\n        \n        public static void main(String[] args) {   \n \n            InputStream inputStream = System.in;\n            // OutputStream outputStream = System.out;\n            InputReader in = new InputReader(inputStream);\n            // PrintWriter out = new PrintWriter(outputStream);\n            \n            // timer stuffs\n            long startTime = System.nanoTime();\n            \n            int N = in.nextInt();\n            \n            Double[][] ptsByX = new Double[N][2];\n            Double[][] ptsByY = new Double[N][2];\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {in.nextDouble(), in.nextDouble()};\n                ptsByX[i] = coords; ptsByY[i] = coords;\n            }\n            \n            // sort by x coord\n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Arrays.sort(ptsByX, new Comparator<Double[]>(){\n                @Override\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            \n            // sort by y-coord\n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Arrays.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            \n            Double[][][] P = new Double[2][N][2];\n            P[0] = ptsByX; P[1] = ptsByY;\n            assert P.length == 2;\n            \n            long endTime = System.nanoTime();\n            long duration = (endTime - startTime)/1000000;\n            System.out.printf(\"%d ms\\n\", duration);\n            \n            Double[][][] res = new Double[2][2][2];\n            res = solve(P);\n           \n            DecimalFormat df = new DecimalFormat();\n            df.setMaximumFractionDigits(10);\n            System.out.println(df.format(Math.pow(dist(res[0][0], res[0][1]), 0.5)));\n            \n            endTime = System.nanoTime();\n            duration = (endTime - startTime)/1000000;\n           \n            System.out.printf(\"Num points: %d\\n\", N);\n            System.out.printf(\"%d ms\\n\", duration);\n            \n        }\n}\n \nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n \n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n \n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n \n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n \n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ClosestPair {\n        \n        //  for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n        public static Double dist(Double[] x, Double[] y) {     \n            return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2);\n       }\n        \n        // only need to return a value if closest pair is split between left and right halves\n        public static ArrayList<Double[]> splitpair(ArrayList<Double[]> px, ArrayList<Double[]> py, double d) {        \n            double xBar = px.get(px.size()/2)[0]; // largest x-coordinate of the left half of px\n            ArrayList<Double[]> Sy = new ArrayList<Double[]>(); // Sy will be the set of points \n            //(sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n            for (int i = 0; i < py.size(); i++) {\n                if (xBar - d <= py.get(i)[0] && py.get(i)[0]<= xBar + d) { //only consider a 'strip' \n                    // around xBar that is 2*d wide\n                    Sy.add(py.get(i)); // if exists a pair with dist less than d\n                    // it must be in this strip (obvious) \n                }\n            }\n            \n            ArrayList<Double[]> bestpair = new ArrayList<Double[]>(); // the coords of the best pair of points so far\n            Double[] x = {0.0, 0.0}; Double[] y = {0.0, 0.0};\n            bestpair.add(x); bestpair.add(y);\n            double bestD = d * d; // the squared distance of the best pair of points\n            \n            // now iterate through Sy for points that aren't more than 7 apart\n            // if a pair exists that is closer than dist d, it must be within 7 of each other\n            for (int i = 0; i < Sy.size() - 2; i++) {\n                for (int j = 1; j < Math.min(8, Sy.size()-i-1); j++) { // the next 7 points\n                    Double[] p = Sy.get(i); Double[] q = Sy.get(i+j);\n                    \n                    if (dist(p, q) < bestD) {\n                        bestpair.clear(); bestpair.add(p); bestpair.add(q);\n                        bestD = dist(p, q);\n                    }\n                }\n            }\n            return bestpair;\n        }\n   \n        public static ArrayList<ArrayList<Double[]>> convertToForm(Double[] x, Double[] y) { \n            //convert 2 points into two pairs of pairs, first sorted by x, other sorted by y (so Px, Py style)\n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> pysByY = new ArrayList<Double[]>();\n            ptsByX.add(x); ptsByX.add(y); pysByY.add(x); pysByY.add(y);\n            // to get sorted by x-coord then sorted by y-coord, first sort by y-coord\n            // then sort by x-coord (since Arrays.sort is stable)\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(pysByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res.add(ptsByX); res.add(pysByY);\n            return res;\n        }\n\n        public static ArrayList<ArrayList<Double[]>> solve(ArrayList<ArrayList<Double[]>> P) { \n            ArrayList<Double[]> Px = new ArrayList<Double[]>();\n            ArrayList<Double[]> Py = new ArrayList<Double[]>();\n            Px = P.get(0); Py = P.get(1);\n            // where Px and Py are the points sorted by x and y coordinate respectively\n            // this function returns the 2 closest points\n            if (Px.size() == 2) {\n                ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n                res.add(Px); res.add(Py);\n                return res;\n            } else if (Px.size() == 3) {\n                Double[] p1 = Px.get(0); Double[] p2 = Px.get(1); Double[] p3 = Px.get(2);\n                Double d12 = dist(p1, p2); Double d13 = dist(p1, p3); Double d23 = dist(p2, p3);\n                Double minD = Math.min(d23, Math.min(d12, d13));\n                if (minD == d12) {\n                    return convertToForm(p1, p2);\n                } else if (minD == d13) {\n                    return convertToForm(p1, p3);\n                } else {\n                    return convertToForm(p2, p3);\n                }\n            } else {\n                // split the left and right halves of all points (by x coord)\n                int L = Px.size();\n                ArrayList<Double[]> Qx = new ArrayList<Double[]>();\n                ArrayList<Double[]> Rx = new ArrayList<Double[]>();\n                for (int i = 0; i < L; i++) {\n                    if (i <= L/2) {\n                        Qx.add(Px.get(i));\n                    } else {\n                        Rx.add(Px.get(i));\n                    }\n                }\n                ArrayList<Double[]> Qy = new ArrayList<Double[]>();\n                ArrayList<Double[]> Ry = new ArrayList<Double[]>();\n                Double k = Qx.get(Qx.size()-1)[0]; Double l = Qx.get(Qx.size()-1)[1];\n                \n                for (int i=0; i < Py.size(); i++) {\n                    if (Py.get(i)[0] < k) {\n                        Qy.add(Py.get(i));\n                    } else if (Py.get(i)[0] == k) {\n                        if (Py.get(i)[1] <= l) {\n                            Qy.add(Py.get(i));\n                        } else {\n                           Ry.add(Py.get(i));\n                        }\n                    } else {\n                        Qy.add(Py.get(i));\n                    }\n                }\n            \n                // now use recursion\n                ArrayList<ArrayList<Double[]>> Q = new ArrayList<ArrayList<Double[]>>();\n                ArrayList<ArrayList<Double[]>> R = new ArrayList<ArrayList<Double[]>>();\n                Q.add(Qx); Q.add(Qy); R.add(Rx); R.add(Ry);\n                ArrayList<ArrayList<Double[]>> c1 = solve(Q);\n                ArrayList<ArrayList<Double[]>> c2 = solve(R);\n                \n                Double Dc1 = dist(c1.get(0).get(0), c1.get(0).get(1)); // returns SQUARED distance\n                Double Dc2 = dist(c2.get(0).get(0), c2.get(0).get(1)); // returns SQUARED distance\n                \n                Double D = Math.min(Dc1, Dc2);\n                ArrayList<ArrayList<Double[]>> bestpair = new ArrayList<ArrayList<Double[]>>();\n                \n                if (D == Dc1) {\n                    bestpair = c1;\n                } else if (D == Dc2) {\n                    bestpair = c2;\n                }\n                \n                ArrayList<Double[]> c3 = splitpair(Px, Py, Math.pow(D, 0.5));\n                \n                ArrayList<Double[]> nobestpair = new ArrayList<Double[]>();\n                Double[] x = {0.0, 0.0}; Double[] y = {0.0, 0.0};\n                nobestpair.add(x); nobestpair.add(y);\n                \n                if (c3 != nobestpair) {\n                    bestpair = convertToForm(c3.get(0), c3.get(1));\n                }\n                \n                return bestpair;\n            }\n        }\n\n        public static void main(String[] args) {   \n            Scanner scan = new Scanner(System.in);\n            int N = scan.nextInt();\n            \n            ArrayList<Double[]> ptsByX = new ArrayList<Double[]>();\n            ArrayList<Double[]> ptsByY = new ArrayList<Double[]>();\n            for (int i = 0; i < N; i++) {\n                Double[] coords = {scan.nextDouble(), scan.nextDouble()};\n                ptsByX.add(coords); ptsByY.add(coords);\n            }\n            scan.close();\n            \n            // now sort by x coord\n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            Collections.sort(ptsByX, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            // sort by y-coord\n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[0].compareTo(otherDoubles[0]); \n                }\n            }); \n            Collections.sort(ptsByY, new Comparator<Double[]>(){\n                public int compare(Double[] doubles, Double[] otherDoubles) {\n                    return doubles[1].compareTo(otherDoubles[1]); \n                }\n            }); \n            \n            ArrayList<ArrayList<Double[]>> P = new ArrayList<ArrayList<Double[]>>();\n            P.add(ptsByX); P.add(ptsByY);\n            \n            ArrayList<ArrayList<Double[]>> res = new ArrayList<ArrayList<Double[]>>();\n            res = solve(P);\n            \n            System.out.println(Math.pow(dist(res.get(0).get(0), res.get(0).get(1)), 0.5));\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\tstatic Point[] p;\n\tstatic int n;\n\t\n\tpublic static void main(String[] args) {\n\t\tn = sc.nextInt();\n\t\tp = new Point[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tp[i] = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t}\n\t\t\n\t\tArrays.sort(p, new Comparator<Point>() {\n\t\t\tpublic int compare(Point p1, Point p2) {\n\t\t\t\tif(p1.x < p2.x) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if(p1.x > p2.x) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\tif(p1.y < p2.y) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tdouble d = closestPair(0, n);\n\t\tDecimalFormat df = new DecimalFormat(\"#######0.0########\");\n\t\tSystem.out.println(df.format(Math.sqrt(d)));\n\t}\n\t\n\tstatic double closestPair(int l, int r) {\n\t\tif(r - l <= 1) {\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}\n\t\tif(r - l <= 2) {\n\t\t\tdouble dx = Math.abs(p[l].x - p[l+1].x);\n\t\t\tdouble dy = Math.abs(p[l].y - p[l+1].y);\n\t\t\treturn dx*dx + dy*dy;\n\t\t}\n\t\t\n\t\tint m = (l + r) / 2;\n\t\tdouble x = p[m].x;\n\t\tdouble d = Math.min(closestPair(l, m), closestPair(m, r));\n\t\tmerge(l, m, r);\n\t\t\n\t\tArrayList<Point> pa = new ArrayList<>();\n\t\tfor(int i=l; i<r; i++) {\n\t\t\tif(Math.abs(p[i].x - x) >= d) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=pa.size()-1; j>=0; j--) {\n\t\t\t\tdouble dx = p[i].x - pa.get(j).x;\n\t\t\t\tdouble dy = p[i].y - pa.get(j).y;\n\t\t\t\tif(dy >= d) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td = Math.min(d, dx*dx + dy*dy);\n\t\t\t}\n\t\t\tpa.add(p[i]);\n\t\t}\n\t\t\n\t\treturn d;\n\t}\n\t\n\tstatic class Point {\n\t\tdouble x;\n\t\tdouble y;\n\t\tPoint(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tstatic void merge(int l, int m, int r) {\n\t\tPoint[] ptemp = Arrays.copyOf(p, n);\n\t\tint i = l;\n\t\tint j = m;\n\t\tint k = l;\n\t\twhile(i != m || j != r) {\n\t\t\tif(j == r || i != m && p[i].y < p[j].y) {\n\t\t\t\tptemp[k] = p[i];\n\t\t\t\ti++;\n\t\t\t\tk++;\n\t\t\t} else {\n\t\t\t\tptemp[k] = p[j];\n\t\t\t\tj++;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tp = ptemp;\n\t}\n\t\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic int n;\n\tstatic double d=double.MaxValue;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tn=sc.I;\n\t\tvar px=new Pair[n];\n\t\tvar py=new Pair[n];\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tvar e=sc.Da;\n\t\t\tpx[i]=new Pair(e[0],e[1]);\n\t\t\tpy[i]=new Pair(e[0],e[1]);\n\t\t}\n\t\tArray.Sort(px,(u,v)=>{var c=u.x.CompareTo(v.x);return c==0?u.y.CompareTo(v.y):c;});\n\t\tArray.Sort(py,(u,v)=>{var c=u.y.CompareTo(v.y);return c==0?u.x.CompareTo(v.x):c;});\n\t\tFu(px,py);\n\t\tConsole.WriteLine(\"{0:n10}\",d);\n\t}\n\tstatic void Fu(Pair[] px,Pair[] py){\n\t\tint l=px.Length>>1;\n\t\tif(px.Length<=3){\n\t\t\td=Min(d,Fdc(px[0],px[1]));\n\t\t\tif(px.Length==3){d=Min(d,Min(Fdc(px[0],px[2]),Fdc(px[1],px[2])));}\n\t\t\treturn;\n\t\t}\n\t\tvar kx1=new Pair[l];\n\t\tvar ky1=new Pair[l];\n\t\tvar kx2=new Pair[px.Length-l];\n\t\tvar ky2=new Pair[px.Length-l];\n\t\tfor(int i = 0,j1=0,j2=0;i<px.Length;i++) {\n\t\t\tif(i<kx1.Length){kx1[i]=px[i];}\n\t\t\telse{kx2[i-kx1.Length]=px[i];}\n\t\t\tif(py[i].x<px[l].x||(py[i].x==px[l].x&&py[i].y<px[l].y)){ky1[j1]=py[i];j1++;}\n\t\t\telse{ky2[j2]=py[i];j2++;}\n\t\t}\n\t\tFu(kx1,ky1);\n\t\tFu(kx2,ky2);\n\t\tvar li=new List<Pair>();\n\t\tfor(int i = 0;i<py.Length;i++) {\n\t\t\tif(Abs(py[i].x-px[l].x)<=d){li.Add(py[i]);}\n\t\t}\n\t\tfor(int i = 0;i<li.Count;i++) {\n\t\t\tfor(int j = i+1;j<i+8&&j<li.Count;j++) {d=Min(d,Fdc(li[i],li[j]));}\n\t\t}\n\t}\n\tstatic double Fdc(Pair a,Pair b){return Sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}\n}\npublic struct Pair{\n\tpublic double x,y;\n\tpublic Pair(double x,double y){this.x=x;this.y=y;}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static bool sorted;\n\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n\n            sorted = false;\n\n            Array.Sort(P);\n            Console.WriteLine(\"{0:f10}\", ClosestPair(P, 0, n));\n        }\n\n        static double ClosestPair(Point[] P, int begin, int end)\n        {\n            if (end - begin <= 1) return double.MaxValue;\n\n            int middle = begin + (end - begin) / 2;\n\n            double x = P[middle].x;\n\n            double d = Math.Min(ClosestPair(P, begin, middle), ClosestPair(P, middle, end));\n\n            if (!sorted)\n            {\n                P = P.OrderBy(p => p.y).ToArray();\n                sorted = true;\n            }\n\n            List<Point> temp = new List<Point>();\n\n            for (int i = begin; i < end; i++)\n            {\n                if (Math.Abs(P[i].x - x) >= d) continue;\n\n                for (int j = temp.Count - 1; j >= 0; j--)\n                {\n                    double dx = P[i].x - temp[j].x;\n                    double dy = P[i].y - temp[j].y;\n\n                    if (dy >= d) break;\n\n                    d = Math.Min(d, Math.Sqrt(dx * dx + dy * dy));\n                }\n                temp.Add(P[i]);\n            }\n            return d;\n        }\n    }\n\n    class Point : IComparable<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(Point other)\n        {\n            return Math.Abs(x - other.x) < EPS ? Math.Sign(y - other.y) : Math.Sign(x - other.x);\n        }\n\n        public override bool Equals(object obj)\n        {\n            Point other = obj as Point;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n\n        public Segment(double ax, double ay, double bx, double by)\n        {\n            p1 = new Point(ax, ay);\n            p2 = new Point(bx, by);\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n\n            Console.WriteLine(ClosestPair(P, 0, n));\n        }\n\n        static double ClosestPair(Point[] P,int begin,int end)\n        {\n            int n = P.Length;\n\n            if (end - begin <= 1) return double.MaxValue;\n\n            int middle = begin + (end - begin) / 2;\n\n            double x = P[middle].x;\n            double d = Math.Min(ClosestPair(P, begin, middle), ClosestPair(P, middle, end));\n\n            Array.Sort(P, (a, b) => (int)(a.y - b.y));\n\n            List<Point> temp = new List<Point>();\n\n            for(int i = 0; i < n; i++)\n            {\n                if (Math.Abs(P[i].x - x) >= d) continue;\n\n                for(int j = 0; j<temp.Count; j++)\n                {\n                    double dx = P[i].x - temp[temp.Count - j - 1].x;\n                    double dy = P[i].y - temp[temp.Count - j - 1].y;\n\n                    if (dy >= d) break;\n\n                    d = Math.Min(d, Math.Sqrt(dx * dx + dy * dy));\n                }\n                temp.Add(P[i]);\n            }\n\n            return d;\n        }\n    }\n\n    class Point : IComparable<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point() { }\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(Point other)\n        {\n            return Math.Abs(x - other.x) < EPS ? (int)(x - other.x) : (int)(y - other.y);\n        }\n\n        public override bool Equals(object obj)\n        {\n            Point other = obj as Point;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n\n        public Segment(double ax, double ay, double bx, double by)\n        {\n            p1 = new Point(ax, ay);\n            p2 = new Point(bx, by);\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n\n            Array.Sort(P, new ComparerX());\n\n            Console.WriteLine(\"{0:f10}\", ClosestPair(P, 0, n));\n        }\n\n        static double ClosestPair(Point[] points, int begin, int end)\n        {\n            double minDist = double.MaxValue;\n\n            if (end - begin < 4)\n            {\n                for (int i = begin; i < end - 1; i++)\n                {\n                    for (int j = i + 1; j < end; j++)\n                    {\n                        minDist = Math.Min(minDist, points[i].Distance(points[j]));\n                    }\n                }\n                return minDist;\n            }\n\n            int middle = (begin + end) / 2;\n            double middleX = points[middle].x;\n\n            minDist = Math.Min(ClosestPair(points, begin, middle), ClosestPair(points, middle, end));\n\n            List<Point> candidates = new List<Point>();\n\n            for (int i = begin; i < end; i++)\n            {\n                if (Math.Abs(middleX - points[i].x) < minDist)\n                {\n                    candidates.Add(points[i]);\n                }\n            }\n\n            int k = candidates.Count;\n\n            if (k <= 1) return minDist;\n\n            candidates.Sort(new ComparerY());\n\n            for (int i = 0; i < k - 1; i++)\n            {\n                for (int j = i + 1; j < k && (candidates[j].y - candidates[i].y < minDist); j++)\n                {\n                    minDist = Math.Min(minDist, candidates[j].Distance(candidates[i]));\n                }\n            }\n            return minDist;\n        }\n    }\n\n    class Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(object obj)\n        {\n            var other = obj as Point;\n            if (other == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = obj as Point;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static bool sorted;\n\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n\n            sorted = false;\n\n            Array.Sort(P, (a, b) => (int)(a.x - b.x));\n            Console.WriteLine(\"{0:f10}\", ClosestPair(ref P, 0, n));\n        }\n\n        static double ClosestPair(ref Point[] P, int begin, int end)\n        {\n            int n = P.Length;\n\n            if (end - begin <= 1) return double.MaxValue;\n\n            int middle = begin + (end - begin) / 2;\n\n            double x = P[middle].x;\n\n            double leftD = ClosestPair(ref P, begin, middle);\n            double rightD = ClosestPair(ref P, middle, end);\n            double d = Math.Min(leftD, rightD);\n\n            if (!sorted)\n            {\n                P = P.OrderBy(p => p.y).ToArray();\n                sorted = true;\n            }\n\n            List<Point> temp = new List<Point>();\n\n            for (int i = 0; i < n; i++)\n            {\n                if (Math.Abs(P[i].x - x) >= d) continue;\n\n                for (int j = temp.Count - 1; j >= 0; j--)\n                {\n                    double dx = P[i].x - temp[j].x;\n                    double dy = P[i].y - temp[j].y;\n\n                    if (dy >= d) break;\n\n                    d = Math.Min(d, Math.Sqrt(dx * dx + dy * dy));\n                }\n                temp.Add(P[i]);\n            }\n            return d;\n        }\n    }\n\n    class Point\n    {\n        internal double x, y;\n\n        public Point() { }\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n            Point[] res = ClosestPair(P);\n\n            Console.WriteLine(\"{0:f10}\", res[0].Distance(res[1]));\n        }\n\n        static Point[] ClosestPair(IEnumerable<Point> points)\n        {\n            double crtMinDist = double.MaxValue / 2;\n\n            var closestPair = new Point[2];\n            var sorted = new List<Point>();\n            sorted.AddRange(points);\n            sorted.Sort(new ComparerX());\n\n            int leftIndex = 0;\n            var candidates = new HashSet<Point>();\n\n            foreach (var current in sorted)\n            {\n                while (current.x - sorted[leftIndex].x > crtMinDist)\n                {\n                    candidates.Remove(sorted[leftIndex]);\n                    leftIndex++;\n                }\n\n                // var head = new Point(current.x, checked(current.y - crtMinDist));\n                // var tail = new Point(current.x, checked(current.y + crtMinDist));\n\n                foreach (var point in candidates)\n                {\n                    var distance = current.Distance(point);\n\n                    if (distance < crtMinDist)\n                    {\n                        crtMinDist = distance;\n                        closestPair[0] = current;\n                        closestPair[1] = point;\n                    }\n                }\n                candidates.Add(current);\n            }\n            return closestPair;\n        }\n    }\n\n    class Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n        static int _counter;\n\n        internal int Id;\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            Id = ++_counter;\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n\n        public int CompareTo(object obj)\n        {\n            var other = obj as Point;\n            if (other == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = obj as Point;\n\n            return Id == other.Id;\n        }\n\n        public override int GetHashCode()\n        {\n            return Id.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n            Point[] res = ClosestPair(P);\n\n            Console.WriteLine(\"{0:f10}\", res[0].Distance(res[1]));\n        }\n\n        static Point[] ClosestPair(IEnumerable<Point> points)\n        {\n            var closestPair = new Point[2];\n\n            var sortedX = new List<Point>();\n            sortedX.AddRange(points);\n            sortedX.Sort(new ComparerX());\n\n            var sortedY = new List<Point>();\n            sortedY.AddRange(points);\n            sortedY.Sort(new ComparerX());\n\n            double crtMinDist = double.MaxValue / 2;\n\n            int xIndex = 0;\n            int yIndex = 0;\n            var candidates = new HashSet<Point>();\n\n            foreach (var current in sortedX)\n            {\n                while (Math.Abs(current.x - sortedX[xIndex].x) > crtMinDist)\n                {\n                    candidates.Remove(sortedX[xIndex]);\n                    xIndex++;\n                }\n                \n                while (Math.Abs(current.y - sortedY[yIndex].y) > crtMinDist)\n                {\n                    candidates.Remove(sortedY[yIndex]);\n                    yIndex++;\n                }\n                \n                var subset = candidates.Where(p => p.y > checked(current.y - crtMinDist) && p.y < checked(current.y + crtMinDist)).ToArray();\n                \n                foreach (var point in subset)\n                {\n                    var distance = current.Distance(point);\n                    \n                    if (distance < crtMinDist)\n                    {\n                        crtMinDist = distance;\n                        closestPair[0] = current;\n                        closestPair[1] = point;\n                    }\n                }\n                candidates.Add(current);\n            }\n            return closestPair;\n        }\n    }\n\n    class Point : IComparable\n    {\n        static readonly double EPS = 1E-16;\n        static int _counter;\n\n        internal int Id;\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            Id = ++_counter;\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n\n        public int CompareTo(object obj)\n        {\n            var other = obj as Point;\n            if (other == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = obj as Point;\n\n            return Id == other.Id;\n        }\n\n        public override int GetHashCode()\n        {\n            return Id.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n//using System.Numerics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    public void Solve()\n    {\n        int N = Reader.Int();\n        var P = new Point[N];\n        for (int i = 0; i < N; i++)\n            P[i] = new Point(Reader.Double(), Reader.Double());\n        Console.WriteLine(ClosestPair(P).ToString(\"f9\"));\n        Console.ReadLine();\n    }\n\n    public double ClosestPair(Point[] P)\n    {\n        Array.Sort(P);\n        return ClosestPairRec(P, 0, P.Length);\n    }\n    private double ClosestPairRec(Point[] P, int L, int R)\n    {\n        if (R - L <= 1) return double.MaxValue;\n        int mid = L + (R - L) / 2;\n        double midX = P[mid].X;\n        double minDist = ClosestPairRec(P, L, mid);\n        minDist = Math.Min(minDist, ClosestPairRec(P, mid, R));\n        InplaceMerge(P, L, mid, R);\n\n        var B = new Point[R - L];\n        var Bnum = 0;\n        for (int ai = L; ai < R; ai++)\n        {\n            if (Math.Abs(P[ai].X - midX) >= minDist) continue;\n            for (int bi = Bnum - 1; bi >= 0; bi--)\n            {\n                double dy = P[ai].Y - B[bi].Y;\n                if (dy >= minDist) break;\n                double dx = P[ai].X - B[bi].X;\n                minDist = Math.Min(minDist, Math.Sqrt(dx * dx + dy * dy));\n            }\n            B[Bnum++] = P[ai];\n        }\n\n        return minDist;\n    }\n    private void InplaceMerge(Point[] P, int L, int mid, int R)\n    {\n        Point[] res = new Point[R - L];\n        int ai = L, bi = mid;\n        for (int ni = 0; ni < res.Length; ni++)\n            if (ai < mid && (bi == R || P[ai].Y < P[bi].Y)) res[ni] = P[ai++];\n            else res[ni] = P[bi++];\n        Array.Copy(res, 0, P, L, res.Length);\n    }\n    public struct Point : IEquatable<Point>, IComparable<Point>\n    {\n        public static readonly double Eps = 1e-10;\n        public double X, Y;\n\n        public Point(double x, double y) { X = x; Y = y; ; }\n\n        public static Point operator +(Point a, Point b)\n        {\n            return new Point(Add(a.X, b.X), Add(a.Y, b.Y));\n        }\n        public static Point operator -(Point a, Point b)\n        {\n            return new Point(Add(a.X, -b.X), Add(a.Y, -b.Y));\n        }\n        public static Point operator *(double d, Point p)\n        {\n            return new Point(p.X * d, p.Y * d);\n        }\n        public static Point operator *(Point p, double d) { return d * p; }\n        public double Norm { get { return Math.Sqrt(Add(X * X, Y * Y)); } }\n        public double Distance(Point b) { return (b - this).Norm; }\n        public double Dot(Point b) { return Add(X * b.X, Y * b.Y); }\n        public double Det(Point b) { return Add(X * b.Y, -Y * b.X); }\n        public bool Equals(Point b) { return X == b.X && Y == b.Y; }\n        public override bool Equals(object obj) { return Equals((Point)obj); }\n        public static bool operator ==(Point a, Point b) { return a.Equals(b); }\n        public static bool operator !=(Point a, Point b) { return !a.Equals(b); }\n        public int CompareTo(Point b)\n        {\n            if (Add(X, -b.X) == 0) return Math.Sign(Y - b.Y);\n            return Math.Sign(X - b.X);\n        }\n        public override int GetHashCode() { return (int)(X * 100000 + Y); }\n        public override string ToString() { return X + \" \" + Y; }\n\n        private static double Add(double a, double b)\n        {\n            if (Math.Abs(a + b) < Eps * (Math.Abs(a) + Math.Abs(b))) return 0;\n            return a + b;\n        }\n    }\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    private static TextReader reader = Console.In;\n    private static readonly char[] separator = { ' ' };\n    private static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    private static string[] A = new string[0];\n    private static int i;\n    private static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Enu.Range(0, N).Select(i => Int()).ToArray(); }\n    public static int[][] IntTable(int H) { return Enu.Range(0, H).Select(i => IntLine()).ToArray(); }\n    public static string[] StringArray(int N) { return Enu.Range(0, N).Select(i => Next()).ToArray(); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    private static string[] Split(string s) { return s.Split(separator, op); }\n    private static string Next() { CheckNext(); return A[i++]; }\n    private static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n\n            Array.Sort(P, new ComparerX());\n\n            Console.WriteLine(\"{0:f10}\", ClosestPair(P, 0, n));\n        }\n\n        static double ClosestPair(Point[] points, int begin, int end)\n        {\n            double minDist = double.MaxValue;\n\n            if (end - begin < 4)\n            {\n                for (int i = begin; i < end; i++)\n                {\n                    for (int j = i + 1; j < end; j++)\n                    {\n                        minDist = Math.Min(minDist, points[i].Distance(points[j]));\n                    }\n                }\n                return minDist;\n            }\n\n            int middle = (begin + end) / 2;\n            double middleX = points[middle].x;\n\n            minDist = Math.Min(ClosestPair(points, begin, middle), ClosestPair(points, middle, end));\n\n            List<Point> candidates = new List<Point>();\n\n            for (int i = begin; i < end; i++)\n            {\n                if (Math.Abs(middleX - points[i].x) < minDist)\n                {\n                    candidates.Add(points[i]);\n                }\n            }\n\n            int k = candidates.Count;\n\n            if (k <= 1) return minDist;\n\n            candidates.Sort(new ComparerY());\n\n            for (int i = 0; i < k; i++)\n            {\n                for (int j = i + 1; j < k && (candidates[j].y - candidates[i].y < minDist); j++)\n                {\n                    minDist = Math.Min(minDist, candidates[j].Distance(candidates[i]));\n                }\n            }\n            return minDist;\n        }\n    }\n\n    class Point : IComparable\n    {\n        static readonly double EPS = 1E-16;\n        static int _counter;\n\n        internal int Id;\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            Id = ++_counter;\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n\n        public int CompareTo(object obj)\n        {\n            var other = obj as Point;\n            if (other == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = obj as Point;\n\n            return Id == other.Id;\n        }\n\n        public override int GetHashCode()\n        {\n            return Id.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static bool sorted;\n        static Point[] P;\n\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n            Point[] res = ClosestPair(P);\n\n            Console.WriteLine(\"{0:f10}\", res[0].Distance(res[1]));\n        }\n\n        static Point[] ClosestPair(IEnumerable<Point> points)\n        {\n            double crtMinDist = double.MaxValue / 2;\n\n            var closestPair = new Point[2];\n            var sorted = new List<Point>();\n            sorted.AddRange(points);\n            sorted.Sort(new ComparerX());\n\n            int leftIndex = 0;\n            var candidates = new HashSet<Point>();\n\n            foreach (var current in sorted)\n            {\n                while (current.x - sorted[leftIndex].x > crtMinDist)\n                {\n                    candidates.Remove(sorted[leftIndex]);\n                    leftIndex++;\n                }\n\n                var head = new Point(current.x, checked(current.y - crtMinDist));\n                var tail = new Point(current.x, checked(current.y + crtMinDist));\n\n                foreach (var point in candidates)\n                {\n                    var distance = current.Distance(point);\n\n                    if (distance < crtMinDist)\n                    {\n                        crtMinDist = distance;\n                        closestPair[0] = current;\n                        closestPair[1] = point;\n                    }\n                }\n                candidates.Add(current);\n            }\n            return closestPair;\n        }\n    }\n\n    class Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n        static int _counter;\n\n        internal int Id;\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            Id = ++_counter;\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n\n        public int CompareTo(object obj)\n        {\n            var other = obj as Point;\n            if (other == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = obj as Point;\n\n            return Id == other.Id;\n        }\n\n        public override int GetHashCode()\n        {\n            return Id.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n            Point[] res = ClosestPair(P);\n\n            Console.WriteLine(\"{0:f10}\", res[0].Distance(res[1]));\n        }\n\n        static Point[] ClosestPair(IEnumerable<Point> points)\n        {\n            var closestPair = new Point[2];\n\n            var sortedX = new List<Point>();\n            sortedX.AddRange(points);\n            sortedX.Sort(new ComparerX());\n\n            var sortedY = new List<Point>();\n            sortedY.AddRange(points);\n            sortedY.Sort(new ComparerX());\n\n            double crtMinDist = double.MaxValue / 2;\n\n            int xIndex = 0;\n            int yIndex = 0;\n            var candidates = new HashSet<Point>();\n\n            foreach (var current in sortedX)\n            {\n                while (current.x - sortedX[xIndex].x > crtMinDist)\n                {\n                    candidates.Remove(sortedX[xIndex]);\n                    xIndex++;\n                }\n\n                while (current.y - sortedY[yIndex].y > crtMinDist)\n                {\n                    candidates.Remove(sortedY[yIndex]);\n                    yIndex++;\n                }\n\n                var subset = candidates.Where(p => p.y > checked(current.y - crtMinDist) && p.y < checked(current.y + crtMinDist)).ToArray();\n                \n                foreach (var point in subset)\n                {\n                    var distance = current.Distance(point);\n\n                    if (distance < crtMinDist)\n                    {\n                        crtMinDist = distance;\n                        closestPair[0] = current;\n                        closestPair[1] = point;\n                    }\n                }\n                candidates.Add(current);\n            }\n            return closestPair;\n        }\n    }\n\n    class Point : IComparable\n    {\n        static readonly double EPS = 1E-16;\n        static int _counter;\n\n        internal int Id;\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            Id = ++_counter;\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n\n        public int CompareTo(object obj)\n        {\n            var other = obj as Point;\n            if (other == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = obj as Point;\n\n            return Id == other.Id;\n        }\n\n        public override int GetHashCode()\n        {\n            return Id.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n\n            Array.Sort(P, new ComparerX());\n\n            Console.WriteLine(\"{0:f10}\", ClosestPair(P, 0, n));\n        }\n\n        static double ClosestPair(Point[] points, int begin, int end)\n        {\n            double minDist = double.MaxValue;\n\n            if (end - begin < 4)\n            {\n                for (int i = begin; i < end; i++)\n                {\n                    for (int j = i + 1; j < end; j++)\n                    {\n                        minDist = Math.Min(minDist, points[i].Distance(points[j]));\n                    }\n                }\n                return minDist;\n            }\n\n            int middle = (begin + end) / 2;\n            double middleX = points[middle].x;\n\n            minDist = Math.Min(ClosestPair(points, begin, middle), ClosestPair(points, middle, end));\n\n            List<Point> candidates = new List<Point>();\n\n            for (int i = begin; i < end; i++)\n            {\n                if (middleX - points[i].x < minDist)\n                {\n                    candidates.Add(points[i]);\n                }\n            }\n\n            int k = candidates.Count;\n\n            if (k <= 1) return minDist;\n\n            candidates.Sort(new ComparerY());\n\n            for (int i = 0; i < k; i++)\n            {\n                for (int j = i + 1; j < k && (candidates[j].y - candidates[i].y < minDist); j++)\n                {\n                    minDist = Math.Min(minDist, candidates[j].Distance(candidates[i]));\n                }\n            }\n            return minDist;\n        }\n    }\n\n    class Point : IComparable\n    {\n        static readonly double EPS = 1E-16;\n        static int _counter;\n\n        internal int Id;\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            Id = ++_counter;\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n\n        public int CompareTo(object obj)\n        {\n            var other = obj as Point;\n            if (other == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = obj as Point;\n\n            return Id == other.Id;\n        }\n\n        public override int GetHashCode()\n        {\n            return Id.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n\n            Array.Sort(P, new ComparerX());\n\n            Console.WriteLine(\"{0:f10}\", ClosestPair(P, 0, n));\n        }\n\n        static double ClosestPair(Point[] points, int begin, int end)\n        {\n            double minDist = double.MaxValue;\n\n            if (end - begin < 4)\n            {\n                for (int i = begin; i < end - 1; i++)\n                {\n                    for (int j = i + 1; j < end; j++)\n                    {\n                        minDist = Math.Min(minDist, points[i].Distance(points[j]));\n                    }\n                }\n                return minDist;\n            }\n\n            int middle = (begin + end) / 2;\n            double middleX = points[middle].x;\n\n            minDist = Math.Min(ClosestPair(points, begin, middle), ClosestPair(points, middle, end));\n\n            List<Point> candidates = new List<Point>();\n\n            for (int i = begin; i < end; i++)\n            {\n                if (Math.Abs(middleX - points[i].x) < minDist)\n                {\n                    candidates.Add(points[i]);\n                }\n            }\n\n            int k = candidates.Count;\n\n            if (k <= 1) return minDist;\n\n            candidates.Sort(new ComparerY());\n\n            for (int i = 0; i < k - 1; i++)\n            {\n                for (int j = i + 1; j < k && (candidates[j].y - candidates[i].y < minDist); j++)\n                {\n                    minDist = Math.Min(minDist, candidates[j].Distance(candidates[i]));\n                }\n            }\n            return minDist;\n        }\n    }\n\n    class Point : IComparable\n    {\n        static readonly double EPS = 1E-16;\n        static int _counter;\n\n        internal int Id;\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            Id = ++_counter;\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n\n        public int CompareTo(object obj)\n        {\n            var other = obj as Point;\n            if (other == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = obj as Point;\n\n            return Id == other.Id;\n        }\n\n        public override int GetHashCode()\n        {\n            return Id.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n\n            KeyValuePair<Point, Point> cp = ClosestPair(P);\n\n            Console.WriteLine((cp.Key - cp.Value).Abs);\n        }\n\n        static KeyValuePair<Point, Point> ClosestPair(Point[] P)\n        {\n            int n = P.Length;\n            int s = 0, t = 1, m = 2;\n\n            int[] S = new int[n];\n            S[0] = 0; S[1] = 1;\n\n            Array.Sort(P);\n\n            double d = (P[s] - P[t]).Norm;\n\n            for (int i = 2; i < n; S[m++] = i++)\n            {\n                for (int j = 0; j < m; j++)\n                {\n                    if ((P[S[j]] - P[i]).Norm < d)\n                    {\n                        s = S[j]; t = i;\n                        d = (P[s] - P[t]).Norm;\n                    }\n\n                    if (P[S[j]].x < P[i].x - d) S[j--] = S[--m];\n                }\n            }\n            return new KeyValuePair<Point, Point>(P[s], P[t]);\n        }\n    }\n\n    class Point : IComparable<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(Point other)\n        {\n            return Math.Abs(x - other.x) < EPS ? (int)(x - other.x) : (int)(y - other.y);\n        }\n\n        public override bool Equals(object obj)\n        {\n            Point other = obj as Point;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n\n        public Segment(double ax, double ay, double bx, double by)\n        {\n            p1 = new Point(ax, ay);\n            p2 = new Point(bx, by);\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static bool sorted;\n\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n\n            sorted = false;\n\n            Array.Sort(P, (a, b) => (int)(a.x - b.x));\n            Console.WriteLine(ClosestPair(ref P, 0, n));\n        }\n\n        static double ClosestPair(ref Point[] P, int begin, int end)\n        {\n            int n = P.Length;\n\n            if (end - begin <= 1) return double.MaxValue;\n\n            int middle = begin + (end - begin) / 2;\n\n            double x = P[middle].x;\n\n            double leftD = ClosestPair(ref P, begin, middle);\n            double rightD = ClosestPair(ref P, middle, end);\n            double d = Math.Min(leftD, rightD);\n\n            if (!sorted)\n            {\n                P = P.OrderBy(p => p.y).ToArray();\n                sorted = true;\n            }\n\n            List<Point> temp = new List<Point>();\n\n            for (int i = 0; i < n; i++)\n            {\n                if (Math.Abs(P[i].x - x) >= d) continue;\n\n                for (int j = temp.Count - 1; j >= 0; j--)\n                {\n                    double dx = P[i].x - temp[j].x;\n                    double dy = P[i].y - temp[j].y;\n\n                    if (dy >= d) break;\n\n                    d = Math.Min(d, Math.Sqrt(dx * dx + dy * dy));\n                }\n                temp.Add(P[i]);\n            }\n            return d;\n        }\n    }\n\n    class Point\n    {\n        internal double x, y;\n\n        public Point() { }\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n            Point[] res = ClosestPair(P);\n\n            Console.WriteLine(\"{0:f10}\", res[0].Distance(res[1]));\n        }\n\n        static Point[] ClosestPair(IEnumerable<Point> points)\n        {\n            double crtMinDist = double.MaxValue / 2;\n\n            var closestPair = new Point[2];\n            var sorted = new List<Point>();\n            sorted.AddRange(points);\n            sorted.Sort(new ComparerX());\n\n            int leftIndex = 0;\n            var candidates = new HashSet<Point>();\n\n            foreach (var current in sorted)\n            {\n                while (current.x - sorted[leftIndex].x > crtMinDist || current.y - sorted[leftIndex].y > crtMinDist)\n                {\n                    candidates.Remove(sorted[leftIndex]);\n                    leftIndex++;\n                }\n\n                // var head = new Point(current.x, checked(current.y - crtMinDist));\n                // var tail = new Point(current.x, checked(current.y + crtMinDist));\n\n                foreach (var point in candidates)\n                {\n                    var distance = current.Distance(point);\n\n                    if (distance < crtMinDist)\n                    {\n                        crtMinDist = distance;\n                        closestPair[0] = current;\n                        closestPair[1] = point;\n                    }\n                }\n                candidates.Add(current);\n            }\n            return closestPair;\n        }\n    }\n\n    class Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n        static int _counter;\n\n        internal int Id;\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            Id = ++_counter;\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n\n        public int CompareTo(object obj)\n        {\n            var other = obj as Point;\n            if (other == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = obj as Point;\n\n            return Id == other.Id;\n        }\n\n        public override int GetHashCode()\n        {\n            return Id.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n\n            Array.Sort(P, (a, b) => (int)(a.x - b.x));\n            Console.WriteLine(ClosestPair(P, 0, n));\n        }\n\n        static double ClosestPair(Point[] P, int begin, int end)\n        {\n            int n = P.Length;\n\n            if (end - begin <= 1) return double.MaxValue;\n\n            int middle = begin + (end - begin) / 2;\n\n            double x = P[middle].x;\n            double d = Math.Min(ClosestPair(P, begin, middle), ClosestPair(P, middle, end));\n\n            P = P.OrderBy(a => a.y).ToArray();\n\n            List<Point> temp = new List<Point>();\n\n            for (int i = 0; i < n; i++)\n            {\n                if (Math.Abs(P[i].x - x) >= d) continue;\n\n                for (int j = 0; j < temp.Count; j++)\n                {\n                    double dx = P[i].x - temp[temp.Count - j - 1].x;\n                    double dy = P[i].y - temp[temp.Count - j - 1].y;\n\n                    if (dy >= d) break;\n\n                    d = Math.Min(d, Math.Sqrt(dx * dx + dy * dy));\n                }\n                temp.Add(P[i]);\n            }\n            return d;\n        }\n    }\n\n    class Point : IComparable<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point() { }\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(Point other)\n        {\n            return Math.Abs(x - other.x) < EPS ? (int)(x - other.x) : (int)(y - other.y);\n        }\n\n        public override bool Equals(object obj)\n        {\n            Point other = obj as Point;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n\n        public Segment(double ax, double ay, double bx, double by)\n        {\n            p1 = new Point(ax, ay);\n            p2 = new Point(bx, by);\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n            Point[] res = ClosestPair(P);\n\n            Console.WriteLine(\"{0:f10}\", res[0].Distance(res[1]));\n        }\n\n        static Point[] ClosestPair(IEnumerable<Point> points)\n        {\n            double crtMinDist = double.MaxValue / 2;\n\n            var closestPair = new Point[2];\n\n            var sortedX = new List<Point>();\n            sortedX.AddRange(points);\n            sortedX.Sort(new ComparerX());\n\n            var sortedY = new List<Point>();\n            sortedY.AddRange(points);\n            sortedY.Sort(new ComparerX());\n\n            int xIndex = 0;\n            int yIndex = 0;\n            var candidates = new HashSet<Point>();\n\n            foreach (var current in sortedX)\n            {\n                while (current.x - sortedX[xIndex].x > crtMinDist)\n                {\n                    candidates.Remove(sortedX[xIndex]);\n                    xIndex++;\n                }\n\n                while (current.y - sortedY[yIndex].y > crtMinDist)\n                {\n                    candidates.Remove(sortedY[yIndex]);\n                    yIndex++;\n                }\n\n                foreach (var point in candidates)\n                {\n                    var distance = current.Distance(point);\n\n                    if (distance < crtMinDist)\n                    {\n                        crtMinDist = distance;\n                        closestPair[0] = current;\n                        closestPair[1] = point;\n                    }\n                }\n                candidates.Add(current);\n            }\n            return closestPair;\n        }\n    }\n\n    class Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n        static int _counter;\n\n        internal int Id;\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            Id = ++_counter;\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n\n        public int CompareTo(object obj)\n        {\n            var other = obj as Point;\n            if (other == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = obj as Point;\n\n            return Id == other.Id;\n        }\n\n        public override int GetHashCode()\n        {\n            return Id.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n\n            Array.Sort(P);\n            Console.WriteLine(ClosestPair(P, 0, n));\n        }\n\n        static double ClosestPair(Point[] P, int begin, int end)\n        {\n            int n = P.Length;\n\n            if (end - begin <= 1) return double.MaxValue;\n\n            int middle = begin + (end - begin) / 2;\n\n            double x = P[middle].x;\n            double d = Math.Min(ClosestPair(P, begin, middle), ClosestPair(P, middle, end));\n\n            Array.Sort(P, (a, b) => (int)(a.y - b.y));\n\n            List<Point> temp = new List<Point>();\n\n            for (int i = 0; i < n; i++)\n            {\n                if (Math.Abs(P[i].x - x) >= d) continue;\n\n                for (int j = 0; j < temp.Count; j++)\n                {\n                    double dx = P[i].x - temp[temp.Count - j - 1].x;\n                    double dy = P[i].y - temp[temp.Count - j - 1].y;\n\n                    if (dy >= d) break;\n\n                    d = Math.Min(d, Math.Sqrt(dx * dx + dy * dy));\n                }\n                temp.Add(P[i]);\n            }\n\n            return d;\n        }\n    }\n\n    class Point : IComparable<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point() { }\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(Point other)\n        {\n            return Math.Abs(x - other.x) < EPS ? (int)(x - other.x) : (int)(y - other.y);\n        }\n\n        public override bool Equals(object obj)\n        {\n            Point other = obj as Point;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n\n        public Segment(double ax, double ay, double bx, double by)\n        {\n            p1 = new Point(ax, ay);\n            p2 = new Point(bx, by);\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Point[] P = new Point[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                P[i] = new Point(input[0], input[1]);\n            }\n\n            Array.Sort(P, new ComparerX());\n\n            Console.WriteLine(\"{0:f10}\", ClosestPair(P, 0, n));\n        }\n\n        static double ClosestPair(Point[] points, int begin, int end)\n        {\n            double minDist = double.MaxValue;\n\n            if (end - begin < 4)\n            {\n                for (int i = begin; i < end - 1; i++)\n                {\n                    for (int j = i + 1; j < end; j++)\n                    {\n                        minDist = Math.Min(minDist, points[i].Distance(points[j]));\n                    }\n                }\n                return minDist;\n            }\n\n            int middle = (begin + end) / 2;\n            double middleX = points[middle].x;\n\n            double distL = ClosestPair(points, begin, middle);\n            double distR = ClosestPair(points, middle, end);\n            minDist = Math.Min(distL, distR);\n\n            List<Point> candidates = new List<Point>();\n\n            for (int i = begin; i < end; i++)\n            {\n                if (Math.Abs(middleX - points[i].x) < minDist)\n                {\n                    candidates.Add(points[i]);\n                }\n            }\n\n            int k = candidates.Count;\n\n            if (k <= 1) return minDist;\n\n            candidates.Sort(new ComparerY());\n\n            for (int i = 0; i < k - 1; i++)\n            {\n                for (int j = i + 1; j < k && (candidates[j].y - candidates[i].y < minDist); j++)\n                {\n                    minDist = Math.Min(minDist, candidates[j].Distance(candidates[i]));\n                }\n            }\n            return minDist;\n        }\n    }\n\n    class Point : IComparable\n    {\n        static readonly double EPS = 1E-16;\n        static int _counter;\n\n        internal int Id;\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            Id = ++_counter;\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n\n        public int CompareTo(object obj)\n        {\n            var other = obj as Point;\n            if (other == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = obj as Point;\n\n            return Id == other.Id;\n        }\n\n        public override int GetHashCode()\n        {\n            return Id.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} {1}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    class Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "INF = 1.0 / 0.0\n\ndef length(a, b)\n  return Math.sqrt((b[0] - a[0])**2 + (b[1] - a[1])**2)\nend\n\ndef closest_pair(pt)\n  n = pt.size\n  return INF if n == 1\n  return length(pt[0], pt[1]) if n == 2\n  m = n / 2\n  x = pt[m][0]\n  d = [closest_pair(pt[0..m]), closest_pair(pt[m..-1])].min\n\n  sorted = []\n  n.times{|i|\n    sorted << i if (pt[i][0] - x).abs < d\n  }\n  m = sorted.size\n  m.times{|i|\n    (i+1).upto(m-1){|j|\n      if (pt[sorted[i]][0] - x) * (pt[sorted[j]][0] - x) < 0\n        it = length(pt[sorted[i]], pt[sorted[j]])\n        break if it > d\n        d = it\n      end\n    }\n  }\n  return d\nend\n\nn = gets.to_i\npt = []\nn.times{|i|\n  pt[i] = gets.split.map(&:to_f)\n}\n\npt.sort!\n\nputs closest_pair(pt)"
  },
  {
    "language": "Ruby",
    "code": "INF = 1.0 / 0.0\n\ndef length(a, b)\n  return Math.sqrt((b[0] - a[0])**2 + (b[1] - a[1])**2)\nend\ndef closest_pair(pt, s, e)\n  return INF if e - s < 1\n  return length(pt[s], pt[e]) if e - s == 1\n  m = (e + s) / 2\n  x = pt[m][0]\n  d = [closest_pair(pt, s, m), closest_pair(pt, m, s)].min\n  sorted = pt[s..e].sort{|a, b| a[1] <=> b[1]}\n  tmp = []\n  sorted.size.times{|it|\n    next if ((sorted[it][0] - x).abs >= d)\n    (tmp.size-1).downto(0){|i|\n      dx = sorted[it][0] - tmp[i][0]\n      dy = sorted[it][1] - tmp[i][1]\n      break if dy >= d\n      d = [d, Math.sqrt(dx*dx+dy*dy)].min\n    }\n    tmp << sorted[it]\n  }\n  return d\nend\n\nn = gets.to_i\npt = []\nn.times{|i|\n  pt[i] = gets.split.map(&:to_f)\n}\n\npt.sort!\n\nputs closest_pair(pt, 0, n-1)"
  },
  {
    "language": "Ruby",
    "code": "INF = 1.0 / 0.0\n\ndef dist(p1, p2)\n  return Math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\nend\n\ndef bruteForce(px, n)\n  min = INF\n  n.times{|i|\n    (i+1).upto(n-1){|j|\n      d = dist(px[i], px[j])\n      min = d if d < min\n    }\n  }\n  return min\nend\n\ndef strip_closest(strip, size, d)\n  min = d\n\n  size.times{|i|\n    (i+1).upto(size-1){|j|\n      break if strip[j][1] - strip[i][1] >= min\n      dd = dist(strip[i], strip[j])\n      min = dd if dd < min\n    }\n  }\n  return min\nend\n\ndef closest_util(px, py, n)\n#  p [px, py, n]\n  return bruteForce(px, n) if n <= 3\n\n  mid = n/2\n  midpoint = px[mid]\n\n  pyl = []\n  pyr = []\n  n.times{|i|\n    if py[i][0] <= midpoint[0]\n      pyl << py[i]\n    else\n      pyr << py[i]\n    end\n  }\n\n  d = INF\n  if pyl.size == n\n    d = bruteForce(px, n)\n  else\n    pxl = px[0,pyl.size].clone\n    pxr = px[pyl.size, pyr.size].clone\n\n    dl = closest_util(pxl, pyl, pyl.size)\n    dr = closest_util(pxr, pyr, pyr.size)\n\n    d = [dl, dr].min\n  end\n\n  strip = []\n  n.times{|i|\n    if (py[i][0] - midpoint[0]).abs < d\n      strip << py[i]\n    end\n  }\n\n  return [d, strip_closest(strip, strip.size, d)].min\n\nend\n\nn = gets.to_i\npx = []\nn.times{|i|\n  px[i] = gets.split.map(&:to_f)\n}\n\npx.sort!\npy = px.map(&:clone)\npy.sort! {|a, b| a[1] <=> b[1]}\n\nputs \"%.10f\" % closest_util(px, py, px.size)"
  },
  {
    "language": "Ruby",
    "code": "INF = 1.0 / 0.0\n\ndef dist(p1, p2)\n  return Math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\nend\n\ndef bruteForce(px, n)\n  min = INF\n  n.times{|i|\n    (i+1).upto(n-1){|j|\n      d = dist(px[i], px[j])\n      min = d if d < min\n    }\n  }\n  return min\nend\n\ndef strip_closest(strip, size, d)\n  min = d\n\n  size.times{|i|\n    (i+1).upto(size-1){|j|\n      break if strip[j][1] - strip[i][1] >= min\n      dd = dist(strip[i], strip[j])\n      min = dd if dd < min\n    }\n  }\n  return min\nend\n\ndef closest_util(px, py, n)\n#  p [px, py, n]\n  return bruteForce(px, n) if n <= 3\n\n  mid = n/2 - 1\n  midpoint = px[mid]\n\n  pyl = []\n  pyr = []\n  n.times{|i|\n    if py[i][0] <= midpoint[0]\n      pyl << py[i]\n    else\n      pyr << py[i]\n    end\n  }\n\n  d = INF\n  if pyl.size == n\n    d = bruteForce(px, n)\n  else\n    pxl = px[0,pyl.size].clone\n    pxr = px[pyl.size, pyr.size].clone\n\n    dl = closest_util(pxl, pyl, pyl.size)\n    dr = closest_util(pxr, pyr, pyr.size)\n\n    d = [dl, dr].min\n  end\n\n  strip = []\n  n.times{|i|\n    if (py[i][0] - midpoint[0]).abs < d\n      strip << py[i]\n    end\n  }\n\n  return [d, strip_closest(strip, strip.size, d)].min\n\nend\n\nn = gets.to_i\npx = []\nxra = [INF, -INF]\nyra = [INF, -INF]\nn.times{|i|\n  px[i] = gets.split.map(&:to_f)\n  xra[0] = px[i][0] if xra[0] > px[i][0]\n  yra[0] = px[i][1] if yra[0] > px[i][1]\n  xra[1] = px[i][0] if xra[1] < px[i][0]\n  yra[1] = px[i][1] if yra[1] < px[i][1]\n}\n\nif xra[0] == xra[1] || yra[0] == yra[1]\n  theta = Math.atan2(1, 1);\n  ct = Math.cos(theta)\n  st = Math.sin(theta)\n  n.times{|i|\n    x, y = px[i]\n    px[i] = [x*ct-y*st, x*st+y*ct]\n  }\nend\n\npx.sort!\npy = px.map(&:clone)\npy.sort! {|a, b| a[1] <=> b[1]}\n\nputs \"%.10f\" % closest_util(px, py, px.size)"
  },
  {
    "language": "Ruby",
    "code": "INF = 1.0 / 0.0\n\ndef dist(p1, p2)\n  return Math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\nend\n\ndef bruteForce(px, n)\n  min = INF\n  n.times{|i|\n    (i+1).upto(n-1){|j|\n      d = dist(px[i], px[j])\n      min = d if d < min\n    }\n  }\n  return min\nend\n\ndef strip_closest(strip, size, d)\n  min = d\n\n  size.times{|i|\n    (i+1).upto(size-1){|j|\n      break if strip[j][1] - strip[i][1] >= min\n      dd = dist(strip[i], strip[j])\n      min = dd if dd < min\n    }\n  }\n  return min\nend\n\ndef closest_util(px, py, n)\n#  p [\"cl:\", px, py, n]\n  return bruteForce(px, n) if n <= 3\n\n  mid = n/2\n  midpoint = px[mid]\n\n#  p midpoint\n\n  pyl = []\n  pyr = []\n  n.times{|i|\n    if py[i][0] <= midpoint[0]\n      pyl << py[i]\n    else\n      pyr << py[i]\n    end\n  }\n\n#  p [\"mid\", mid]\n\n  pxl = px[0,pyl.size].clone\n  pxr = px[pyl.size, pyr.size].clone\n\n  # p [\"pxl:\", pxl]\n  # p [\"pyl:\", pyl]\n  # p [\"pxr:\", pxr]\n  # p [\"pyr:\", pyr]\n\n  dl = closest_util(pxl, pyl, pyl.size)\n  dr = closest_util(pxr, pyr, pyr.size)\n\n  d = [dl, dr].min\n\n  strip = []\n  n.times{|i|\n    if (py[i][0] - midpoint[0]).abs < d\n      strip << py[i]\n    end\n  }\n\n  # p strip\n\n  return [d, strip_closest(strip, strip.size, d)].min\n\nend\n\nn = gets.to_i\npx = []\nn.times{|i|\n  px[i] = gets.split.map(&:to_f)\n}\n\npx.sort!\npy = px.map(&:clone)\npy.sort! {|a, b| a[1] <=> b[1]}\n\nputs closest_util(px, py, px.size)"
  },
  {
    "language": "Ruby",
    "code": "INF = 1.0 / 0.0\n\ndef dist(p1, p2)\n  return Math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\nend\n\ndef bruteForce(px, n)\n  min = INF\n  n.times{|i|\n    (i+1).upto(n-1){|j|\n      d = dist(px[i], px[j])\n      min = d if d < min\n    }\n  }\n  return min\nend\n\ndef strip_closest(strip, size, d)\n  min = d\n\n  size.times{|i|\n    (i+1).upto(size-1){|j|\n      break if strip[j][1] - strip[i][1] >= min\n      dd = dist(strip[i], strip[j])\n      min = dd if dd < min\n    }\n  }\n  return min\nend\n\ndef closest_util(px, py, n)\n#  p [px, py, n]\n  return bruteForce(px, n) if n <= 3\n\n  mid = n/2 - 1\n  midpoint = px[mid]\n\n  pyl = []\n  pyr = []\n  n.times{|i|\n    if py[i][0] <= midpoint[0]\n      pyl << py[i]\n    else\n      pyr << py[i]\n    end\n  }\n\n  if pyl.size == n || pyr.size == n\n    pyl = py[0,mid].clone\n    pyr = py[mid,n-mid].clone\n  end\n  \n  pxl = px[0,pyl.size].clone\n  pxr = px[pyl.size, pyr.size].clone\n\n  dl = closest_util(pxl, pyl, pyl.size)\n  dr = closest_util(pxr, pyr, pyr.size)\n\n  d = [dl, dr].min\n\n  strip = []\n  n.times{|i|\n    if (py[i][0] - midpoint[0]).abs < d\n      strip << py[i]\n    end\n  }\n\n  return [d, strip_closest(strip, strip.size, d)].min\n\nend\n\nn = gets.to_i\npx = []\nn.times{|i|\n  px[i] = gets.split.map(&:to_f)\n}\n\npx.sort!\npy = px.map(&:clone)\npy.sort! {|a, b| a[1] <=> b[1]}\n\nputs \"%.10f\" % closest_util(px, py, px.size)"
  },
  {
    "language": "Ruby",
    "code": "INF = 1.0 / 0.0\n\ndef length(a, b)\n  return Math.sqrt((b[0] - a[0])**2 + (b[1] - a[1])**2)\nend\ndef closest_pair(pt, s, e)\n  return INF if e - s < 1\n  return length(pt[s], pt[e]) if e - s == 1\n  m = (e + s) / 2\n  x = pt[m][0]\n  d = [closest_pair(pt, s, m), closest_pair(pt, m, s)].min\n  sorted = pt[s..e].sort{|a, b| a[1] <=> b[1]}\n#  p sorted\n  tmp = []\n  sorted.size.times{|it|\n    (tmp.size-1).downto(0){|i|\n      dx = sorted[it][0] - tmp[i][0]\n      dy = sorted[it][1] - tmp[i][1]\n#      break if dy >= d\n      d = [d, Math.sqrt(dx*dx+dy*dy)].min\n    }\n    tmp << sorted[it]\n  }\n#  p [\"sed\", s, e, d]\n  return d\nend\n\nn = gets.to_i\npt = []\nn.times{|i|\n  pt[i] = gets.split.map(&:to_f)\n}\n\npt.sort!\n\nputs closest_pair(pt, 0, n-1)"
  },
  {
    "language": "Ruby",
    "code": "INF = 1.0 / 0.0\n\ndef length(a, b)\n  return Math.sqrt((b[0] - a[0])**2 + (b[1] - a[1])**2)\nend\ndef closest_pair(pt, s, e)\n  return INF if e - s < 1\n  return length(pt[s], pt[e]) if e - s == 1\n  m = (e + s) / 2\n  x = pt[m][0]\n  d = [closest_pair(pt, s, m), closest_pair(pt, m, s)].min\n  sorted = pt[s..e].sort{|a, b| a[1] <=> b[1]}\n  p sorted\n  tmp = []\n  sorted.size.times{|it|\n    (tmp.size-1).downto(0){|i|\n      dx = sorted[it][0] - tmp[i][0]\n      dy = sorted[it][1] - tmp[i][1]\n#      break if dy >= d\n      d = [d, Math.sqrt(dx*dx+dy*dy)].min\n    }\n    tmp << sorted[it]\n  }\n  p [\"sed\", s, e, d]\n  return d\nend\n\nn = gets.to_i\npt = []\nn.times{|i|\n  pt[i] = gets.split.map(&:to_f)\n}\n\npt.sort!\n\nputs closest_pair(pt, 0, n-1)"
  },
  {
    "language": "Ruby",
    "code": "INF = 1.0 / 0.0\n\ndef dist(p1, p2)\n  return Math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\nend\n\ndef bruteForce(px, n)\n  min = INF\n  n.times{|i|\n    (i+1).upto(n-1){|j|\n      d = dist(px[i], px[j])\n      min = d if d < min\n    }\n  }\n  return min\nend\n\ndef strip_closest(strip, size, d)\n  min = d\n\n  size.times{|i|\n    (i+1).upto(size-1){|j|\n      break if strip[j][1] - strip[i][1] >= min\n      dd = dist(strip[i], strip[j])\n      min = dd if dd < min\n    }\n  }\n  return min\nend\n\ndef closest_util(px, py, n)\n#  p [\"cl:\", px, py, n]\n  return bruteForce(px, n) if n <= 3\n\n  mid = n/2 - 1\n  midpoint = px[mid]\n\n#  p midpoint\n\n  pyl = []\n  pyr = []\n  n.times{|i|\n    if py[i][0] <= midpoint[0]\n      pyl << py[i]\n    else\n      pyr << py[i]\n    end\n  }\n\n#  p [\"mid\", mid]\n\n  pxl = px[0,pyl.size].clone\n  pxr = px[pyl.size, pyr.size].clone\n\n  # p [\"pxl:\", pxl]\n  # p [\"pyl:\", pyl]\n  # p [\"pxr:\", pxr]\n  # p [\"pyr:\", pyr]\n\n  dl = closest_util(pxl, pyl, pyl.size)\n  dr = closest_util(pxr, pyr, pyr.size)\n\n  d = [dl, dr].min\n\n  strip = []\n  n.times{|i|\n    if (py[i][0] - midpoint[0]).abs < d\n      strip << py[i]\n    end\n  }\n\n  # p strip\n\n  return [d, strip_closest(strip, strip.size, d)].min\n\nend\n\nn = gets.to_i\npx = []\nn.times{|i|\n  px[i] = gets.split.map(&:to_f)\n}\n\npx.sort!\npy = px.map(&:clone)\npy.sort! {|a, b| a[1] <=> b[1]}\n\nputs closest_util(px, py, px.size)"
  },
  {
    "language": "Ruby",
    "code": "INF = 1.0 / 0.0\n\ndef length(a, b)\n  return Math.sqrt((b[0] - a[0])**2 + (b[1] - a[1])**2)\nend\n\ndef closest_pair(pt)\n  n = pt.size\n  return INF if n == 1\n  return length(pt[0], pt[1]) if n == 2\n  m = n / 2\n  x = pt[m][0]\n  d = [closest_pair(pt[0..m]), closest_pair(pt[m..-1])].min\n\n  sorted = []\n  n.times{|i|\n    sorted << i if (pt[i][0] - x).abs < d\n  }\n  m = sorted.size\n  m.times{|i|\n    (i+1).upto(m-1){|j|\n      if (pt[sorted[i]][0] - x) * (pt[sorted[j]][0] - x) < 0\n        it = length(pt[sorted[i]], pt[sorted[j]])\n        break if it > d\n        d = it\n      end\n    }\n  }\n  return d\nend\n\nn = gets.to_i\npt = []\nn.times{|i|\n  pt[i] = gets.split.map(&:to_f)\n}\n\npt.sort!\n\nputs \"%.8f\" % closest_pair(pt)"
  },
  {
    "language": "Ruby",
    "code": "INF = 1.0 / 0.0\n\ndef dist(p1, p2)\n  return Math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\nend\n\ndef bruteForce(px, n)\n  min = INF\n  n.times{|i|\n    (i+1).upto(n-1){|j|\n      d = dist(px[i], px[j])\n      min = d if d < min\n    }\n  }\n  return min\nend\n\ndef strip_closest(strip, size, d)\n  min = d\n\n  size.times{|i|\n    (i+1).upto(size-1){|j|\n      break if strip[j][1] - strip[i][1] >= min\n      dd = dist(strip[i], strip[j])\n      min = dd if dd < min\n    }\n  }\n  return min\nend\n\ndef closest_util(px, py, n)\n#  p [\"cl:\", px, py, n]\n  return bruteForce(px, n) if n <= 3\n\n  mid = n/2 - 1\n  midpoint = px[mid]\n\n#  p midpoint\n\n  pyl = []\n  pyr = []\n  n.times{|i|\n    if py[i][0] <= midpoint[0]\n      pyl << py[i]\n    else\n      pyr << py[i]\n    end\n  }\n\n#  p [\"mid\", mid]\n\n  pxl = px[0,pyl.size].clone\n  pxr = px[pyl.size, pyr.size].clone\n\n  # p [\"pxl:\", pxl]\n  # p [\"pyl:\", pyl]\n  # p [\"pxr:\", pxr]\n  # p [\"pyr:\", pyr]\n\n  dl = closest_util(pxl, pyl, pyl.size)\n  dr = closest_util(pxr, pyr, pyr.size)\n\n  d = [dl, dr].min\n\n  strip = []\n  n.times{|i|\n    if (py[i][0] - midpoint[0]).abs < d\n      strip << py[i]\n    end\n  }\n\n  # p strip\n\n  return [d, strip_closest(strip, strip.size, d)].min\n\nend\n\nn = gets.to_i\npx = []\nn.times{|i|\n  px[i] = gets.split.map(&:to_f)\n}\n\npx.sort!\npy = px.map(&:clone)\npy.sort! {|a, b| a[1] <=> b[1]}\n\nputs \"%.10f\" % closest_util(px, py, px.size)"
  },
  {
    "language": "Ruby",
    "code": "INF = 1.0 / 0.0\n\ndef dist(p1, p2)\n  return Math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\nend\n\ndef bruteForce(px, n)\n  min = INF\n  n.times{|i|\n    (i+1).upto(n-1){|j|\n      d = dist(px[i], px[j])\n      min = d if d < min\n    }\n  }\n  return min\nend\n\ndef strip_closest(strip, size, d)\n  min = d\n\n  size.times{|i|\n    (i+1).upto(size-1){|j|\n      break if strip[j][1] - strip[i][1] >= min\n      dd = dist(strip[i], strip[j])\n      min = dd if dd < min\n    }\n  }\n  return min\nend\n\ndef closest_util(px, py, n)\n#  p [px, py, n]\n  return bruteForce(px, n) if n <= 3\n\n  mid = n/2 - 1\n  midpoint = px[mid]\n\n  pyl = []\n  pyr = []\n  n.times{|i|\n    if py[i][0] <= midpoint[0]\n      pyl << py[i]\n    else\n      pyr << py[i]\n    end\n  }\n\n  if pyl.size == n\n    pyl = py[0,mid].clone\n    pyr = py[mid,n-mid].clone\n  end\n  \n  pxl = px[0,pyl.size].clone\n  pxr = px[pyl.size, pyr.size].clone\n\n  dl = closest_util(pxl, pyl, pyl.size)\n  dr = closest_util(pxr, pyr, pyr.size)\n\n  d = [dl, dr].min\n\n  strip = []\n  n.times{|i|\n    if (py[i][0] - midpoint[0]).abs < d\n      strip << py[i]\n    end\n  }\n\n  return [d, strip_closest(strip, strip.size, d)].min\n\nend\n\nn = gets.to_i\npx = []\nn.times{|i|\n  px[i] = gets.split.map(&:to_f)\n}\n\npx.sort!\npy = px.map(&:clone)\npy.sort! {|a, b| a[1] <=> b[1]}\n\nputs \"%.10f\" % closest_util(px, py, px.size)"
  },
  {
    "language": "Ruby",
    "code": "INF = 1.0 / 0.0\n\ndef dist(p1, p2)\n  return Math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\nend\n\ndef bruteForce(px)\n  n = px.size\n  min = INF\n  n.times{|i|\n    (i+1).upto(n-1){|j|\n      d = dist(px[i], px[j])\n      if d < min\n        min = d\n      end\n    }\n  }\n  return min\nend\n\ndef strip_closest(strip, size, d)\n  min = d\n\n  size.times{|i|\n    (i+1).upto(size-1){|j|\n      break if strip[j][1] - strip[i][1] >= min\n      dd = dist(strip[i], strip[j])\n      min = dd if dd < min\n    }\n  }\n  return min\nend\n\ndef closest_util(px, py, n)\n  # p [px, py]\n  return bruteForce(px) if n <= 3\n\n  mid = n/2\n  midpoint = px[mid]\n\n  pyl = []\n  pyr = []\n  n.times{|i|\n    if py[i][0] <= midpoint[0]\n      pyl << py[i]\n    else\n      pyr << py[i]\n    end\n  }\n\n  pxl = px[0,mid]\n  pxr = px[mid, n-mid]\n\n  dl = closest_util(pxr, pxl, mid)\n  dr = closest_util(pxr, pyl, n-mid)\n\n  d = [dl, dr].min\n\n  strip = []\n  n.times{|i|\n    if (py[i][0] - midpoint[0]).abs < d\n      strip << py[i]\n    end\n  }\n\n  return [d, strip_closest(strip, strip.size, d)].min\n\nend\n\nn = gets.to_i\npx = []\nn.times{|i|\n  px[i] = gets.split.map(&:to_f)\n}\n\npx.sort!\npy = px.map(&:clone)\npy.sort! {|a, b| a[1] <=> b[1]}\n\nputs closest_util(px, py, px.size)"
  },
  {
    "language": "Python",
    "code": "import itertools\n\ndef _get_min_distance(points):\n    min_d = 400\n    for p1, p2 in itertools.combinations(points, 2):\n        min_d = min(min_d, abs(p1 - p2))\n    return min_d\n\n# Search based on x axis\ndef closest_pair_distance_x(points):\n    n = len(points)\n    if n <= 3:\n        return _get_min_distance(points)\n    else:\n        mid = n // 2\n        left_points = points[:mid]\n        right_points = points[mid:]\n        d_Lmin = closest_pair_distance_x(left_points)\n        d_Rmin = closest_pair_distance_x(right_points)\n        dist = min(d_Lmin, d_Rmin)\n        min_d = dist\n        for lp in left_points[::-1]:\n            if right_points[0].real - lp.real >= dist:\n                break\n            for rp in right_points:\n                if rp.real -lp.real >= dist:\n                    break\n                if lp.imag - dist < rp.imag < lp.imag + dist:\n                    min_d = min(min_d, abs(lp - rp))\n        return min_d\n\n# Search based on y axis\ndef closest_pair_distance_y(points):\n    n = len(points)\n    if n <= 3:\n        return _get_min_distance(points)\n    else:\n        mid = n // 2\n        lower_points = points[:mid]\n        upper_points = points[mid:]\n        d_Lmin = closest_pair_distance_y(lower_points)\n        d_Umin = closest_pair_distance_y(upper_points)\n        dist = min(d_Lmin, d_Umin)\n        min_d = dist\n        for lp in lower_points[::-1]:\n            if upper_points[0].imag - lp.imag >= dist:\n                break\n            for up in upper_points:\n                if up.imag -lp.imag >= dist:\n                    break\n                if lp.real - dist < up.real < lp.real + dist:\n                    min_d = min(min_d, abs(lp - up))\n        return min_d\n\n# Acceptance of input\ndef string_to_complex(s):\n    x, y = map(float, s.split())\n    return x + y * 1j\n\nimport sys\n\nfile_input = sys.stdin\n\nn = int(file_input.readline())\n\nP = [string_to_complex(line) for line in file_input]\n\n# Solve\nP.sort(key = lambda c: c.imag)\nans = closest_pair_distance_y(P)\nprint('{:f}'.format(ans))"
  },
  {
    "language": "Python",
    "code": "import math\nfrom itertools import combinations\nfrom operator import itemgetter\n\npts = []\nline = input()\nn = int(line)\nfor _ in range(0, n):\n    line = input()\n    x, y = list(map(float, line.split()))\n    pts += [[x, y]]\n\ndef dist(p, q):\n    x1, y1 = p\n    x2, y2 = q\n    return (x1 - x2)**2 + (y1 - y2)**2\n\ndef solve(p, axis):\n    n = len(p)\n    if n <= 3:\n        d = 100000\n        q1 = q2 = []\n        for p1, p2 in list(combinations(p, 2)):\n            d = min(d, dist(p1, p2))\n        return d\n\n    mid = n // 2\n    px, py = zip(*p)\n    axis1 = 2 * len(set(px)) <= n\n    axis2 = not axis1\n    if axis1 != axis:\n        p.sort(key = itemgetter(axis1))\n    \n    xy0 = p[mid][axis1]\n    left = p[:mid]\n    right = p[mid:]\n    d = min(solve(left, axis1), solve(right, axis1))\n    rd = math.sqrt(d)\n    \n    Q = []\n    for pp in left[::-1]:\n        if pp[axis1] < xy0 - rd:\n            break\n        Q.append(pp)\n    for pp in right:\n        if pp[axis1] > xy0 + rd:\n            break\n        Q.append(pp)\n    Q.sort(key = itemgetter(axis2))\n    for i, p1 in enumerate(Q):\n        dd = p1[axis2] + rd\n        for p2 in Q[i + 1:]:\n            if p2[axis2] > dd:\n                break\n            norm = dist(p1, p2)\n            if d > norm:\n                d = norm\n    return d\n\npts.sort(key = itemgetter(0))\nans = solve(pts, 0)\nprint('%.16f' % math.sqrt(ans))\n\n"
  },
  {
    "language": "Python",
    "code": "# #### CLOSEST PAIR O(N LOG N) ALGORITHM #### #\n# points should be unique, otherwise the closest pair would be the repeated points\n# also this will only find 1 pair with the smallest distance, in case there are multiple pairs with this same minimum distance\n\n#import time\n#start = time.time()\n\n\t\ndef halve(coord): # split into two halves by x-coordinate\n\tL = len(coord) # luckily pts are already sorted\n\treturn [coord[:L/2], coord[L/2:]]\n\ndef dist(x, y): # for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n\treturn (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\n\t\ndef splitpair(px, py, d): # only need to return a correct value if closest pair is split\n\txBar = px[(len(px)+1)/2][0]\n\tSy = [] # Sy will be the set of points (sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n\tfor i in xrange(len(py)):\n\t\tif xBar-d**0.5 <= py[i][0] <= xBar+d**0.5: # only consider a 'strip' around xBar that is 2*sqrt(d) wide\n\t\t\tSy.append(py[i])\t\n\t\n\tbestpair = None # the coords of the best pair of points so far\n\tbestD = d # the squared distance of the best pair of points\n\t# now iterate through Sy for points that aren't more than 7 apart\n\tfor i in xrange(len(Sy)-2):\n\t\tfor j in xrange(1, min(8, len(Sy)-i-1)):  # 7 next points\n\t\t\tp, q = Sy[i], Sy[i+j]\n\t\t\t\n\t\t\tif dist(p, q) < bestD:\n\t\t\t\tbestpair = [p, q]\n\t\t\t\tbestD = dist(p, q)\n\t\t\t\t\n\treturn bestpair\n\t\ndef convert(p1, p2): # convert 2 points into two pairs of pairs, first sorted by x, other sorted by y1\n\treturn [sorted([p1, p2]), sorted([p1, p2], key=lambda x: x[1])]\n\t\ndef solve(Px, Py): # where Px and Py are the points sorted by x and y coordinate respectively\n\t# this function returns two closest points\n\tassert len(Px) == len(Py) # make sure you have the same number of x and y coords\n\tif len(Px) == 2:\n\t\treturn (Px, Py)\n\telif len(Px) == 3: # 3 points, brute force\n\t\tp1, p2, p3 = [x for x in Px]\n\t\td12, d13, d23 = dist(p1, p2), dist(p1, p3), dist(p2, p3)\n\t\tif min(d12, d13, d23) == d12: \n\t\t\treturn convert(p1, p2)\n\t\telif min(d12, d13, d23) == d13: \n\t\t\treturn convert(p1, p3)\n\t\telse: \n\t\t\treturn convert(p2, p3)\n\telse:\n\t\tQx, Rx = [x for x in halve(Px)]\n\t\tQy, Ry = [], []\n\t\tk = Qx[-1][0]\n\t\tfor pt in Py: # this is linear time, you loop through Py exactly once\n\t\t\tif pt[0] <= k and len(Qy) < len(Qx):\n\t\t\t\tQy.append(pt)\n\t\t\telse:\n\t\t\t\tRy.append(pt)\n\t\t\n\t\tassert len(Qx) == len(Qy)\n\t\tassert len(Rx) == len(Ry)\n\t\t\n\t\t# now use recursion. note ci is of the form [[x1,x2], [y1,y2]]\n\t\tc1 = solve(Qx, Qy) # find the closest pair in left half\n\t\tc2 = solve(Rx, Ry) # find the closest pair in the right half\n\t\t\n\t\tD = min(dist(c1[0][0], c1[0][1]), dist(c2[0][0], c2[0][1]))\n\t\tif D == dist(c1[0][0], c1[0][1]):\n\t\t\tbestpair = c1\n\t\telif D == dist(c2[0][0], c2[0][1]):\n\t\t\tbestpair = c2\n\t\t\n\t\tc3 = splitpair(Px, Py, D) # find the closest split pair. this needs to be O(n) to get O(n log n) for entire algo\n\t\t\n\t\tif c3 is not None: \n\t\t\treturn convert(c3[0], c3[1])\n\t\telse:\n\t\t\treturn bestpair # else it's one of the c1 or c2\n\t\t\n\t\t\ndef main():\n\tN = int(raw_input().split()[0]) # N is number of points\n\tassert  N >= 2\n\tpts = [] # pairs of points, i.e pts = [[x1,y1], [x2,y2], ... , [xn,yn]]\n\t\n\t# get all pairs of points into our list\n\tfor i in xrange(N):\n\t\tpts.append([float(x) for x in raw_input().split()])\n\t\t\n\t\n\tPx = sorted(pts) # sort the pts by x coordinate\n\tPy = sorted(pts, key=lambda x: x[1]) # sort the pts by y coordinate\n\t\n\tres = solve(Px, Py)\n\t\n\t'''\n\t# find the index of the points in pts\n\tfor i in xrange(len(pts)):\n\t\tif pts[i] == res[0][0]:\n\t\t\tind1 = i\n\t\telif pts[i] == res[0][1]:\n\t\t\tind2 = i\n\t\t\t\n\td = dist(pts[ind1], pts[ind2]) ** 0.5\n\t'''\n\t\n\tprint dist(res[0][0], res[0][1]) ** 0.5\n\nif __name__ == '__main__':\n\tmain()\n\n\n#print \"%.2f %s\" % (((time.time() - start) * 1000), \"ms\")"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nimport operator\nreadline = stdin.readline\n\n\ndef norm(self):\n    return abs(self)\n\n\ndef closest_pair(p):\n    m = 0\n    p.sort(key=operator.attrgetter('real'))\n    d = float('inf')\n    for i in range(1, len(p)):\n        for j in reversed(range(m, i)):\n            tmp = p[i] - p[j]\n            if d < tmp.real:\n                m = j + 1\n                break\n            tmp = abs(tmp)\n            if d > tmp:\n                d = tmp\n    return d\n\n\nfrom itertools import combinations\n\n\ndef brute_force(p):\n    return min(abs(p[i] - p[j]) for i, j in combinations(range(len(p)), 2))\n\n\ndef main():\n    n = int(readline())\n    p = [map(float, readline().split()) for _ in range(n)]\n    p = [x + y * 1j for x, y in p]\n\n    # print('{:.6f}'.format(brute_force(p)))\n    print('{:.6f}'.format(closest_pair(p)))\nmain()"
  },
  {
    "language": "Python",
    "code": "import statistics\n\ndef func_x(point_list_in):\n    min_sum_square = float(\"inf\")\n    point_list = sorted(point_list_in, key=lambda point: point[0])\n    for i in range(num_point):\n        for j in range(i + 1, num_point):\n            x_dif = point_list[i][0] - point_list[j][0]\n            y_dif = point_list[i][1] - point_list[j][1]\n            x_dif_square = x_dif**2\n            y_dif_square = y_dif**2\n            if x_dif <=0 and x_dif_square >= min_sum_square:\n                break\n            else:\n                sum_square = x_dif_square + y_dif_square\n                min_sum_square = min(sum_square, min_sum_square)\n    return min_sum_square**0.5\n\ndef func_y(point_list_in):\n    min_sum_square = float(\"inf\")\n    point_list = sorted(point_list_in, key=lambda point: point[1])\n    for i in range(num_point):\n        for j in range(i + 1, num_point):\n            x_dif = point_list[i][0] - point_list[j][0]\n            y_dif = point_list[i][1] - point_list[j][1]\n            x_dif_square = x_dif**2\n            y_dif_square = y_dif**2\n            if y_dif <=0 and y_dif_square >= min_sum_square:\n                break\n            else:\n                sum_square = x_dif_square + y_dif_square\n                min_sum_square = min(sum_square, min_sum_square)\n    return min_sum_square**0.5\n\nnum_point = int(input())\npoint_list = [0] * num_point\nfor i in range(num_point):\n    line_split = input().split(\" \")\n    point_list[i] = [float(line_split[0]), float(line_split[1])]\nx_list = [point[0] for point in point_list]\ny_list = [point[1] for point in point_list]\nx_var = statistics.pvariance(x_list)\ny_var = statistics.pvariance(y_list)\n\nif x_var > y_var:\n    min_distance = func_x(point_list)\nelse:\n    min_distance = func_y(point_list)\nprint(\"{0:.6f}\".format(min_distance))"
  },
  {
    "language": "Python",
    "code": "import itertools\n\ndef _get_min_distance(points):\n    min_d = 400\n    for p1, p2 in itertools.combinations(points, 2):\n        min_d = min(min_d, abs(p1 - p2))\n    return min_d\n\n# Search based on x axis\ndef closest_pair_distance_x(points):\n    n = len(points)\n    if n <= 3:\n        return _get_min_distance(points)\n    else:\n        mid = n // 2\n        left_points = points[:mid]\n        right_points = points[mid:]\n        d_Lmin = closest_pair_distance_x(left_points)\n        d_Rmin = closest_pair_distance_x(right_points)\n        dist = min(d_Lmin, d_Rmin)\n        min_d = dist\n        for lp in left_points[::-1]:\n            if right_points[0].real - lp.real >= dist:\n                break\n            for rp in right_points:\n                if rp.real -lp.real >= dist:\n                    break\n                if lp.imag - dist < rp.imag < lp.imag + dist:\n                    min_d = min(min_d, abs(lp - rp))\n        return min_d\n\n# Search based on y axis\ndef closest_pair_distance_y(points):\n    n = len(points)\n    if n <= 3:\n        return _get_min_distance(points)\n    else:\n        mid = n // 2\n        lower_points = points[:mid]\n        upper_points = points[mid:]\n        d_Lmin = closest_pair_distance_y(lower_points)\n        d_Umin = closest_pair_distance_y(upper_points)\n        dist = min(d_Lmin, d_Umin)\n        min_d = dist\n        for lp in lower_points[::-1]:\n            if upper_points[0].imag - lp.imag >= dist:\n                break\n            for up in upper_points:\n                if up.imag -lp.imag >= dist:\n                    break\n                if lp.real - dist < up.real < lp.real + dist:\n                    min_d = min(min_d, abs(lp - up))\n        return min_d\n\n# Acceptance of input\ndef string_to_complex(s):\n    x, y = map(float, s.split())\n    return x + y * 1j\n\nimport sys\n\nfile_input = sys.stdin\n\nn = int(file_input.readline())\n\nP = [string_to_complex(line) for line in file_input]\n\n# Solve\nP.sort(key = lambda c: (c.real, c.imag))\n\nif P[-1].real - P[0].real >= P[-1].imag - P[0].imag:\n    ans = closest_pair_distance_x(P)\n    print('{:f}'.format(ans))\nelse:\n    P.sort(key = lambda c: c.imag)\n    ans = closest_pair_distance_y(P)\n    print('{:f}'.format(ans))"
  },
  {
    "language": "Python",
    "code": "from operator import itemgetter\nfrom math import sqrt\nfrom typing import List, Tuple\n\n\ndef distance(p: Tuple[float, float], q: Tuple[float, float]) -> float:\n    return sqrt((p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2)\n\n\ndef closest_distance(points: List[Tuple[float, float]]) -> float:\n    def split(i: int, j: int) -> float:\n        if j - i < 2:\n            return float('INF')\n        mid = (i + j) // 2\n        d = min(split(i, mid), split(mid, j))\n        lv, rv = points[mid][0] - d, points[mid][0] + d\n        return merge(sorted([p for p in points[i:j]\n                             if lv <= p[0] <= rv], key=itemgetter(1)), d)\n\n    def merge(_points: List[Tuple[float, float]], d: float) -> float:\n        n = len(_points)\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if d < _points[j][1] - _points[i][1]:\n                    break\n                d = min(d, distance(_points[i], _points[j]))\n        return d\n\n    points.sort(key=itemgetter(0, 1))\n    return split(0, len(points))\n\n\nif __name__ == '__main__':\n    n = int(input())\n    points = [tuple(map(float, input().split())) for _ in range(n)]\n    print(\"{:.6f}\".format(closest_distance(points)))  # type: ignore\n\n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nn = input()\nps = [map(float, raw_input().split()) for i in xrange(n)]\nps.sort()\nINF = 10**9\n\ndef cp_rec(ps, i, n):\n    if n <= 1:\n        return INF, [ps[i]]\n    m = n/2\n    x = ps[i+m][0]\n    d1, qs1 = cp_rec(ps, i, m)\n    d2, qs2 = cp_rec(ps, i+m, n-m)\n    d = min(d1, d2)\n    # merge\n    qs = [None]*n\n    s = t = idx = 0\n    while s < m and t < n-m:\n        if qs1[s][1] < qs2[t][1]:\n            qs[idx] = qs1[s]; s += 1\n        else:\n            qs[idx] = qs2[t]; t += 1\n        idx += 1\n    while s < m:\n        qs[idx] = qs1[s]; s += 1\n        idx += 1\n    while t < n-m:\n        qs[idx] = qs2[t]; t += 1\n        idx += 1\n    b = []\n    for i in xrange(n):\n        ax, ay = q = qs[i]\n        if abs(ax - x) >= d:\n            continue\n        for j in xrange(len(b)-1, -1, -1):\n            dx = ax - b[j][0]\n            dy = ay - b[j][1]\n            if dy >= d: break\n            d = min(d, sqrt(dx**2 + dy**2))\n        b.append(q)\n    return d, qs\ndef closest_pair(ps):\n    n = len(ps)\n    return cp_rec(ps, 0, n)[0]\nprint \"%.09f\" % closest_pair(ps)"
  },
  {
    "language": "Python",
    "code": "num_point = int(input())\npoint_list = [0] * num_point\nfor i in range(num_point):\n    line_split = input().split(\" \")\n    point_list[i] = [float(line_split[0]), float(line_split[1])]\npoint_list.sort(key=lambda point: point[0])\n\nmin_sum_square = float(\"inf\")\nfor i in range(num_point):\n    for j in range(i + 1, num_point):\n        x_dif = point_list[i][0] - point_list[j][0]\n        y_dif = point_list[i][1] - point_list[j][1]\n        x_dif_square = x_dif**2\n        y_dif_square = y_dif**2\n        if x_dif <=0 and x_dif_square >= min_sum_square:\n            break\n        else:\n            sum_square = x_dif_square + y_dif_square\n            min_sum_square = min(sum_square, min_sum_square)\n\nmin_distance = min_sum_square**0.5\nprint(min_distance)"
  },
  {
    "language": "Python",
    "code": "# #### CLOSEST PAIR O(N LOG N) ALGORITHM #### #\n# points should be unique, otherwise the closest pair would be the repeated points\n# also this will only find 1 pair with the smallest distance, in case there are multiple pairs with this same minimum distance\n\n#import time\n#start = time.time()\n\n\ndef dist(x, y): # for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n\treturn (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\n\t\ndef splitpair(px, py, d): # only need to return a value if closest pair is split between left and right halves\n\txBar = px[(len(px)+1)/2][0] # large x-coordinate of the left half of px\n\tSy = [] # Sy will be the set of points (sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n\tfor i in xrange(len(py)):\n\t\tif xBar-d**0.5 <= py[i][0] <= xBar+d**0.5: # only consider a 'strip' around xBar that is 2*sqrt(d) wide\n\t\t\tSy.append(py[i]) # if exists a pair with dist less than d, it must be in this strip (obvious)\t\n\t\n\tbestpair = None # the coords of the best pair of points so far\n\tbestD = d # the squared distance of the best pair of points\n\t# now iterate through Sy for points that aren't more than 7 apart\n\t# if a pair exists that is closer than dist d, it must be within 7 of each other\n\t# ask me for proof if you haven't seen this observation before it's pretty cool\n\tfor i in xrange(len(Sy)-2):\n\t\tfor j in xrange(1, min(8, len(Sy)-i-1)):  # 7 next points\n\t\t\tp, q = Sy[i], Sy[i+j]\n\t\t\t\n\t\t\tif dist(p, q) < bestD:\n\t\t\t\tbestpair = [p, q]\n\t\t\t\tbestD = dist(p, q)\n\t\t\t\t\n\treturn bestpair\n\t\ndef convert(p1, p2): # convert 2 points into two pairs of pairs, first sorted by x, other sorted by y\n\treturn [sorted([p1, p2]), sorted([p1, p2], key=lambda x: x[1])]\n\t\ndef solve(Px, Py): # where Px and Py are the points sorted by x and y coordinate respectively\n\t# this function returns two closest points\n\tif len(Px) == 2:\n\t\treturn (Px, Py)\n\telif len(Px) == 3: # 3 points, brute force\n\t\tp1, p2, p3 = [x for x in Px]\n\t\td12, d13, d23 = dist(p1, p2), dist(p1, p3), dist(p2, p3)\n\t\tif min(d12, d13, d23) == d12: \n\t\t\treturn convert(p1, p2)\n\t\telif min(d12, d13, d23) == d13: \n\t\t\treturn convert(p1, p3)\n\t\telse: \n\t\t\treturn convert(p2, p3)\n\telse:\n\t\t# split the left and right halves of all points (by x coord)\n\t\tL = len(Px)\n\t\tQx, Rx = Px[:L/2], Px[L/2:]\n\t\tQy, Ry = [], []\n\t\tk, l = Qx[-1][0], Qx[-1][1] # x and y coords of the rightmost element in Qx\n\t\tfor pt in Py: # this is linear time, you loop through Py exactly once.\n\t\t\t# need this in order \n\t\t\tif pt[0] < k:\n\t\t\t\tQy.append(pt)\n\t\t\telif pt[0] == k:\n\t\t\t\tif pt[1] <= l:\n\t\t\t\t\tQy.append(pt)\n\t\t\t\telse:\n\t\t\t\t\tRy.append(pt)\n\t\t\telse:\n\t\t\t\tRy.append(pt)\n\t\t\n\t\t# now use recursion. note ci is of the form [[x1,x2], [y1,y2]]\n\t\tc1 = solve(Qx, Qy) # find the closest pair in left half\n\t\tc2 = solve(Rx, Ry) # find the closest pair in the right half\n\t\t\n\t\tD = min(dist(c1[0][0], c1[0][1]), dist(c2[0][0], c2[0][1])) # get the min distance of both of these to solve split case\n\t\tif D == dist(c1[0][0], c1[0][1]):\n\t\t\tbestpair = c1\n\t\telif D == dist(c2[0][0], c2[0][1]):\n\t\t\tbestpair = c2\n\t\t\n\t\tc3 = splitpair(Px, Py, D) # find the closest split pair. this needs to be O(n) to get O(n log n) for entire algo\n\t\t\n\t\tif c3 is not None: \n\t\t\treturn convert(c3[0], c3[1])\n\t\telse:\n\t\t\treturn [bestpair[0], bestpair[1]] # else it's one of the c1 or c2\n\t\t\n\t\t\ndef main():\n\tN = int(raw_input().split()[0]) # N is number of points\n\tpts = [] # pairs of points, i.e pts = [[x1,y1], [x2,y2], ... , [xn,yn]]\n\t\n\t# get all pairs of points into our list\n\tfor i in xrange(N):\n\t\tpts.append([float(x) for x in raw_input().split()])\n\t\t\n\tPx = sorted(pts) # sort the pts by x coordinate\n\tPy = sorted(pts, key=lambda x: x[1]) # sort the pts by y coordinate\n\t\n\tres = solve(Px, Py) # keep one copy sorted by x coord, the other sorted by y coord to keep the split in half in linear time\n\t\n\tprint \"%.10f\" % (dist(res[0][0], res[0][1]) ** 0.5)\n\nif __name__ == '__main__':\n\tmain()\n\n\n#print \"%.2f %s\" % (((time.time() - start) * 1000), \"ms\")"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\nfrom itertools import combinations\ndef brute_force(p):\n    return min(abs(p[i] - p[j]) for i, j in combinations(range(len(p)), 2))\n\ndef main():\n    n = int(readline())\n    p = [map(float, readline().split()) for _ in range(n)]\n    p = [x + y * 1j for x, y in p]\n\n    print('{:.6f}'.format(brute_force(p)))\nmain()"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\n\ndef solve(a: list):\n    length = len(a)\n    if length <= 3:\n        return min((p1[0]-p2[0])**2+(p1[1]-p2[1])**2 for p1, p2 in zip(a, a[1:]))\n\n    med = length//2\n    x_l, x_r = a[:med], a[med:]\n    delta = min(solve(x_l), solve(x_r))\n    median_x = a[med][0]\n    m_a = []\n        \n    for p in x_l[::-1]:\n        if p[0] < median_x-delta:\n            break\n        m_a.append(p)\n    m_a.reverse()\n    for p in x_r:\n        if p[0] > median_x+delta:\n            break\n        m_a.append(p)\n\n    for i, (x1, y1) in enumerate(m_a):\n        to_y = y1 + delta\n        for j, (x2, y2) in enumerate(m_a[i+1:]):\n            if y2 > to_y:\n                break\n            delta = min(delta, (x1-x2)**2+(y1-y2)**2)\n\n    return delta\n\nif __name__ == \"__main__\":\n    N = int(input())\n    m = 1000000\n    a = sorted([tuple(map(lambda s: int(float(s)*m), l.split())) for l in sys.stdin.readlines()])\n    print(\"{:.10f}\".format(math.sqrt(solve(a)/(m**2))))\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\nimport operator\n\n\ndef norm(self):\n    return abs(self)\n\ndef closest_pair(p):\n    m = 0\n    p.sort(key=operator.attrgetter('real'))\n    d = float('inf')\n    for i in range(1, len(p)):\n        for j in reversed(range(m, i)):\n            tmp = abs(p[j] - p[i])\n            if d < tmp.real:\n                m += 1\n                break\n            elif d > tmp:\n                d = tmp\n    return d\n\n\n\nfrom itertools import combinations\ndef brute_force(p):\n    return min(abs(p[i] - p[j]) for i, j in combinations(range(len(p)), 2))\n\n@profile\ndef main():\n    n = int(readline())\n    p = [map(float, readline().split()) for _ in range(n)]\n    p = [x + y * 1j for x, y in p]\n\n    \n    #print('{:.6f}'.format(brute_force(p)))\n    print('{:.6f}'.format(closest_pair(p)))\nmain()"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\n\ndef solve(a: list):\n    length = len(a)\n    if length <= 3:\n        return min((p1[0]-p2[0])**2+(p1[1]-p2[1])**2 for p1, p2 in zip(a, a[1:]))\n\n    med = length//2\n    x_l, x_r = a[:med], a[med:]\n    delta = min(solve(x_l), solve(x_r))\n    median_x = a[med][0]\n    m_a = []\n        \n    for p in x_l[::-1]:\n        if p[0] < median_x-delta:\n            break\n        m_a.append(p)\n    m_a.reverse()\n    for p in x_r:\n        if p[0] > median_x+delta:\n            break\n        m_a.append(p)\n\n    for i, (x1, y1) in enumerate(m_a):\n        to_y = y1 + delta\n        for j, (x2, y2) in enumerate(m_a[i+1:]):\n            if y2 > to_y:\n                break\n            delta = min(delta, (x1-x2)**2+(y1-y2)**2)\n\n    return delta\n\nif __name__ == \"__main__\":\n    N = int(input())\n    m = 1000000\n    a = sorted([tuple(map(lambda s: int(float(s)*m), l.split())) for l in sys.stdin.readlines()])\n    print(math.sqrt(solve(a)/(m**2)))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom operator import itemgetter\nfrom itertools import permutations\nfrom math import sqrt\n\ndef solve(a: list, axis: int = 0):\n    length = len(a)\n    if length <= 3:\n        return min(sqrt((p1[axis]-p2[axis])**2+(p1[not axis]-p2[not axis])**2) for p1, p2 in permutations(a, 2))\n\n    med = length//2\n    left, right = a[:med], a[med:]\n    delta = min(solve(left, axis), solve(right, axis))\n    median_x = a[med][axis]\n    m_a = []\n        \n    for p in left[::-1]:\n        if p[axis] < median_x-delta:\n            break\n        m_a.append(p)\n    for p in right:\n        if p[axis] > median_x+delta:\n            break\n        m_a.append(p)\n    m_a.sort(key=itemgetter(not axis))\n\n    for i, p1 in enumerate(m_a):\n        ub = p1[not axis] + delta\n        for j, p2 in enumerate(m_a[i+1:]):\n            if p2[not axis] > ub:\n                break\n            delta = min(delta, sqrt((p1[0]-p2[0])**2+(p1[1]-p2[1])**2))\n\n    return delta\n\nif __name__ == \"__main__\":\n    N = int(input())\n    a = sorted([tuple(map(float, l.split())) for l in sys.stdin.readlines()])\n    axis = 0 if len(set(p[0] for p in a)) > len(set(p[1] for p in a)) else 1\n    print(\"{:.10f}\".format(solve(a, axis)))\n"
  },
  {
    "language": "Python",
    "code": "import itertools\n\ndef _get_distance(p1, p2):\n    return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\ndef _get_min_distance(points):\n    min_d = 400\n    for p1, p2 in itertools.combinations(points, 2):\n        min_d = min(min_d, _get_distance(p1, p2))\n    return min_d\n\ndef closest_pair_distance(points, axis):\n    # axis: x; 0, y; 1\n    n = len(points)\n    if n <= 3:\n        return _get_min_distance(points)\n    else:\n        mid = n // 2\n        px, py = zip(*points)\n        if len(set(px)) > len(set(py)):\n            if axis:\n                points.sort(key = lambda p: p[0])\n                axis = 0\n        elif not axis:\n            points.sort(key = lambda p: p[1])\n            axis = 1\n        A_points = points[:mid]\n        B_points = points[mid:]\n        d_Amin = closest_pair_distance(A_points, axis)\n        d_Bmin = closest_pair_distance(B_points, axis)\n        dist = min(d_Amin, d_Bmin)\n        min_d = dist\n        for ap in A_points[::-1]:\n            if B_points[0][axis] - ap[axis] >= dist:\n                break\n            for bp in B_points:\n                if bp[axis] - ap[axis] >= dist:\n                    break\n                if ap[not axis] - dist < bp[not axis] < ap[not axis] + dist:\n                    min_d = min(min_d, _get_distance(ap, bp))\n        return min_d\n\n\n# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = int(file_input.readline())\n\nP = [tuple(map(float, line.split())) for line in file_input]\n\n# Solve\nP.sort(key = lambda p: p[0])\nans = closest_pair_distance(P, 0)\n\nprint('{:f}'.format(ans))"
  },
  {
    "language": "Python",
    "code": "import sys\n\nfile_input = sys.stdin\n\nn = file_input.readline()\n\ndef distance(s_p1, s_p2):\n    x1, y1 = map(float, s_p1.split())\n    x2, y2 = map(float, s_p2.split())\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\nimport itertools\n\nmin_d = 400\n\nfor p1, p2 in itertools.combinations(file_input, 2):\n    min_d = min(min_d, distance(p1, p2))\n\nprint('{:f}'.format(min_d))"
  },
  {
    "language": "Python",
    "code": "import itertools\n\ndef _get_distance(p1, p2):\n    return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\ndef _get_min_distance(points):\n    min_d = 400\n    for p1, p2 in itertools.combinations(points, 2):\n        min_d = min(min_d, _get_distance(p1, p2))\n    return min_d\n\ndef closest_pair_distance(points):\n    n = len(points)\n    if n <= 3:\n        return _get_min_distance(points)\n    else:\n        mid = n // 2\n        px, py = zip(*points)\n        if len(set(px)) > len(set(py)):\n            points.sort(key = lambda p: p[0])\n            # axis: x; 0, y; 1\n            axis1 = 0\n            axis2 = 1\n        else:\n            points.sort(key = lambda p: p[1])\n            axis1 = 1\n            axis2 = 0\n        A_points = points[:mid]\n        B_points = points[mid:]\n        d_Amin = closest_pair_distance(A_points.copy())\n        d_Bmin = closest_pair_distance(B_points.copy())\n        dist = min(d_Amin, d_Bmin)\n        min_d = dist\n        for ap in A_points[::-1]:\n            if B_points[0][axis1] - ap[axis1] >= dist:\n                break\n            for bp in B_points:\n                if bp[axis1] - ap[axis1] >= dist:\n                    break\n                if ap[axis2] - dist < bp[axis2] < ap[axis2] + dist:\n                    min_d = min(min_d, _get_distance(ap, bp))\n        return min_d\n\n# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = int(file_input.readline())\n\nP = [tuple(map(float, line.split())) for line in file_input]\n\n# Solve\nans = closest_pair_distance(P)\n\nprint('{:f}'.format(ans))"
  },
  {
    "language": "Python",
    "code": "import cmath\nimport itertools\nimport math\nimport os\nimport sys\nfrom collections import defaultdict\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n# MOD = 998244353\nPI = cmath.pi\nTAU = cmath.pi * 2\nEPS = 1e-10\n\n\nclass Point:\n    \"\"\"\n    2次元空間上の点\n    \"\"\"\n\n    # 反時計回り側にある\n    CCW_COUNTER_CLOCKWISE = 1\n    # 時計回り側にある\n    CCW_CLOCKWISE = -1\n    # 線分の後ろにある\n    CCW_ONLINE_BACK = 2\n    # 線分の前にある\n    CCW_ONLINE_FRONT = -2\n    # 線分上にある\n    CCW_ON_SEGMENT = 0\n\n    def __init__(self, c: complex):\n        self.c = c\n\n    @property\n    def x(self):\n        return self.c.real\n\n    @property\n    def y(self):\n        return self.c.imag\n\n    @staticmethod\n    def from_rect(x: float, y: float):\n        return Point(complex(x, y))\n\n    @staticmethod\n    def from_polar(r: float, phi: float):\n        return Point(cmath.rect(r, phi))\n\n    def __add__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        return Point(self.c + p.c)\n\n    def __iadd__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        self.c += p.c\n        return self\n\n    def __sub__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        return Point(self.c - p.c)\n\n    def __isub__(self, p):\n        \"\"\"\n        :param Point p:\n        \"\"\"\n        self.c -= p.c\n        return self\n\n    def __mul__(self, f: float):\n        return Point(self.c * f)\n\n    def __imul__(self, f: float):\n        self.c *= f\n        return self\n\n    def __truediv__(self, f: float):\n        return Point(self.c / f)\n\n    def __itruediv__(self, f: float):\n        self.c /= f\n        return self\n\n    def __repr__(self):\n        return \"({}, {})\".format(round(self.x, 10), round(self.y, 10))\n\n    def __neg__(self):\n        return Point(-self.c)\n\n    def __eq__(self, p):\n        return abs(self.c - p.c) < EPS\n\n    def __abs__(self):\n        return abs(self.c)\n\n    @staticmethod\n    def ccw(a, b, c):\n        \"\"\"\n        線分 ab に対する c の位置\n        線分上にあるか判定するだけなら on_segment とかのが速い\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\n        :param Point a:\n        :param Point b:\n        :param Point c:\n        \"\"\"\n        b = b - a\n        c = c - a\n        det = b.det(c)\n        if det > EPS:\n            return Point.CCW_COUNTER_CLOCKWISE\n        if det < -EPS:\n            return Point.CCW_CLOCKWISE\n        if b.dot(c) < -EPS:\n            return Point.CCW_ONLINE_BACK\n        if c.norm() - b.norm() > EPS:\n            return Point.CCW_ONLINE_FRONT\n        return Point.CCW_ON_SEGMENT\n\n    def dot(self, p):\n        \"\"\"\n        内積\n        :param Point p:\n        :rtype: float\n        \"\"\"\n        return self.x * p.x + self.y * p.y\n\n    def det(self, p):\n        \"\"\"\n        外積\n        :param Point p:\n        :rtype: float\n        \"\"\"\n        return self.x * p.y - self.y * p.x\n\n    def dist(self, p):\n        \"\"\"\n        距離\n        :param Point p:\n        :rtype: float\n        \"\"\"\n        return abs(self.c - p.c)\n\n    def norm(self):\n        \"\"\"\n        原点からの距離\n        :rtype: float\n        \"\"\"\n        return abs(self.c)\n\n    def phase(self):\n        \"\"\"\n        原点からの角度\n        :rtype: float\n        \"\"\"\n        return cmath.phase(self.c)\n\n    def angle(self, p, q):\n        \"\"\"\n        p に向いてる状態から q まで反時計回りに回転するときの角度\n        -pi <= ret <= pi\n        :param Point p:\n        :param Point q:\n        :rtype: float\n        \"\"\"\n        return (cmath.phase(q.c - self.c) - cmath.phase(p.c - self.c) + PI) % TAU - PI\n\n    def area(self, p, q):\n        \"\"\"\n        p, q となす三角形の面積\n        :param Point p:\n        :param Point q:\n        :rtype: float\n        \"\"\"\n        return abs((p - self).det(q - self) / 2)\n\n    def projection_point(self, p, q, allow_outer=False):\n        \"\"\"\n        線分 pq を通る直線上に垂線をおろしたときの足の座標\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=ja\n        :param Point p:\n        :param Point q:\n        :param allow_outer: 答えが線分の間になくても OK\n        :rtype: Point|None\n        \"\"\"\n        diff_q = q - p\n        # 答えの p からの距離\n        r = (self - p).dot(diff_q) / abs(diff_q)\n        # 線分の角度\n        phase = diff_q.phase()\n\n        ret = Point.from_polar(r, phase) + p\n        if allow_outer or (p - ret).dot(q - ret) < EPS:\n            return ret\n        return None\n\n    def reflection_point(self, p, q):\n        \"\"\"\n        直線 pq を挟んで反対にある点\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=ja\n        :param Point p:\n        :param Point q:\n        :rtype: Point\n        \"\"\"\n        # 距離\n        r = abs(self - p)\n        # pq と p-self の角度\n        angle = p.angle(q, self)\n        # 直線を挟んで角度を反対にする\n        angle = (q - p).phase() - angle\n        return Point.from_polar(r, angle) + p\n\n    def on_segment(self, p, q, allow_side=True):\n        \"\"\"\n        点が線分 pq の上に乗っているか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=ja\n        :param Point p:\n        :param Point q:\n        :param allow_side: 端っこでギリギリ触れているのを許容するか\n        :rtype: bool\n        \"\"\"\n        if not allow_side and (self == p or self == q):\n            return False\n        # 外積がゼロ: 面積がゼロ == 一直線\n        # 内積がマイナス: p - self - q の順に並んでる\n        return abs((p - self).det(q - self)) < EPS and (p - self).dot(q - self) < EPS\n\n\nclass Line:\n    \"\"\"\n    2次元空間上の直線\n    \"\"\"\n\n    def __init__(self, a: float, b: float, c: float):\n        \"\"\"\n        直線 ax + by + c = 0\n        \"\"\"\n        self.a = a\n        self.b = b\n        self.c = c\n\n    @staticmethod\n    def from_gradient(grad: float, intercept: float):\n        \"\"\"\n        直線 y = ax + b\n        :param grad: 傾き\n        :param intercept: 切片\n        :return:\n        \"\"\"\n        return Line(grad, -1, intercept)\n\n    @staticmethod\n    def from_segment(p1, p2):\n        \"\"\"\n        :param Point p1:\n        :param Point p2:\n        \"\"\"\n        a = p2.y - p1.y\n        b = p1.x - p2.x\n        c = p2.y * (p2.x - p1.x) - p2.x * (p2.y - p1.y)\n        return Line(a, b, c)\n\n    @property\n    def gradient(self):\n        \"\"\"\n        傾き\n        \"\"\"\n        return INF if self.b == 0 else -self.a / self.b\n\n    @property\n    def intercept(self):\n        \"\"\"\n        切片\n        \"\"\"\n        return INF if self.b == 0 else -self.c / self.b\n\n    def is_parallel_to(self, l):\n        \"\"\"\n        平行かどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Line l:\n        \"\"\"\n        # 法線ベクトル同士の外積がゼロ\n        return abs(Point.from_rect(self.a, self.b).det(Point.from_rect(l.a, l.b))) < EPS\n\n    def is_orthogonal_to(self, l):\n        \"\"\"\n        直行しているかどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Line l:\n        \"\"\"\n        # 法線ベクトル同士の内積がゼロ\n        return abs(Point.from_rect(self.a, self.b).dot(Point.from_rect(l.a, l.b))) < EPS\n\n    def intersection_point(self, l):\n        \"\"\"\n        交差する点\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=ja\n        :param Line l:\n        :rtype: Point|None\n        \"\"\"\n        a1, b1, c1 = self.a, self.b, self.c\n        a2, b2, c2 = l.a, l.b, l.c\n        det = a1 * b2 - a2 * b1\n        if abs(det) < EPS:\n            # 並行\n            return None\n        x = (b1 * c2 - b2 * c1) / det\n        y = (a2 * c1 - a1 * c2) / det\n        return Point.from_rect(x, y)\n\n    def dist(self, p):\n        \"\"\"\n        他の点との最短距離\n        :param Point p:\n        \"\"\"\n        raise NotImplementedError()\n\n    def has_point(self, p):\n        \"\"\"\n        p が直線上に乗っているかどうか\n        :param Point p:\n        \"\"\"\n        return abs(self.a * p.x + self.b * p.y + self.c) < EPS\n\n\nclass Segment:\n    \"\"\"\n    2次元空間上の線分\n    \"\"\"\n\n    def __init__(self, p1, p2):\n        \"\"\"\n        :param Point p1:\n        :param Point p2:\n        \"\"\"\n        self.p1 = p1\n        self.p2 = p2\n\n    def norm(self):\n        \"\"\"\n        線分の長さ\n        \"\"\"\n        return abs(self.p1 - self.p2)\n\n    def phase(self):\n        \"\"\"\n        p1 を原点としたときの p2 の角度\n        \"\"\"\n        return cmath.phase(self.p2 - self.p1)\n\n    def is_parallel_to(self, s):\n        \"\"\"\n        平行かどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Segment s:\n        :return:\n        \"\"\"\n        # 外積がゼロ\n        return abs((self.p1 - self.p2).det(s.p1 - s.p2)) < EPS\n\n    def is_orthogonal_to(self, s):\n        \"\"\"\n        直行しているかどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=ja\n        :param Segment s:\n        :return:\n        \"\"\"\n        # 内積がゼロ\n        return abs((self.p1 - self.p2).dot(s.p1 - s.p2)) < EPS\n\n    def intersects_with(self, s, allow_side=True):\n        \"\"\"\n        交差するかどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=ja\n        :param Segment s:\n        :param allow_side: 端っこでギリギリ触れているのを許容するか\n        \"\"\"\n        if self.is_parallel_to(s):\n            # 並行なら線分の端点がもう片方の線分の上にあるかどうか\n            return (s.p1.on_segment(self.p1, self.p2, allow_side) or\n                    s.p2.on_segment(self.p1, self.p2, allow_side) or\n                    self.p1.on_segment(s.p1, s.p2, allow_side) or\n                    self.p2.on_segment(s.p1, s.p2, allow_side))\n        else:\n            # allow_side ならゼロを許容する\n            det_upper = EPS if allow_side else -EPS\n            ok = True\n            # self の両側に s.p1 と s.p2 があるか\n            ok &= (self.p2 - self.p1).det(s.p1 - self.p1) * (self.p2 - self.p1).det(s.p2 - self.p1) < det_upper\n            # s の両側に self.p1 と self.p2 があるか\n            ok &= (s.p2 - s.p1).det(self.p1 - s.p1) * (s.p2 - s.p1).det(self.p2 - s.p1) < det_upper\n            return ok\n\n    def closest_point(self, p):\n        \"\"\"\n        線分上の、p に最も近い点\n        :param Point p:\n        \"\"\"\n        # p からおろした垂線までの距離\n        d = (p - self.p1).dot(self.p2 - self.p1) / self.norm()\n        # p1 より前\n        if d < EPS:\n            return self.p1\n        # p2 より後\n        if -EPS < d - self.norm():\n            return self.p2\n        # 線分上\n        return Point.from_polar(d, (self.p2 - self.p1).phase()) + self.p1\n\n    def dist(self, p):\n        \"\"\"\n        他の点との最短距離\n        :param Point p:\n        \"\"\"\n        return abs(p - self.closest_point(p))\n\n    def dist_segment(self, s):\n        \"\"\"\n        他の線分との最短距離\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=ja\n        :param Segment s:\n        \"\"\"\n        if self.intersects_with(s):\n            return 0.0\n        return min(\n            self.dist(s.p1),\n            self.dist(s.p2),\n            s.dist(self.p1),\n            s.dist(self.p2),\n        )\n\n    def has_point(self, p, allow_side=True):\n        \"\"\"\n        p が線分上に乗っているかどうか\n        :param Point p:\n        :param allow_side: 端っこでギリギリ触れているのを許容するか\n        \"\"\"\n        return p.on_segment(self.p1, self.p2, allow_side=allow_side)\n\n\nclass Polygon:\n    \"\"\"\n    2次元空間上の多角形\n    \"\"\"\n\n    def __init__(self, points):\n        \"\"\"\n        :param list of Point points:\n        \"\"\"\n        self.points = points\n\n    def iter2(self):\n        \"\"\"\n        隣り合う2点を順に返すイテレータ\n        :rtype: typing.Iterator[(Point, Point)]\n        \"\"\"\n        return zip(self.points, self.points[1:] + self.points[:1])\n\n    def iter3(self):\n        \"\"\"\n        隣り合う3点を順に返すイテレータ\n        :rtype: typing.Iterator[(Point, Point, Point)]\n        \"\"\"\n        return zip(self.points,\n                   self.points[1:] + self.points[:1],\n                   self.points[2:] + self.points[:2])\n\n    def area(self):\n        \"\"\"\n        面積\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A&lang=ja\n        \"\"\"\n        # 外積の和 / 2\n        dets = []\n        for p, q in self.iter2():\n            dets.append(p.det(q))\n        return abs(math.fsum(dets)) / 2\n\n    def is_convex(self, allow_straight=False, allow_collapsed=False):\n        \"\"\"\n        凸多角形かどうか\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B&lang=ja\n        :param allow_straight: 3点がまっすぐ並んでるのを許容するかどうか\n        :param allow_collapsed: 面積がゼロの場合を許容するか\n        \"\"\"\n        ccw = []\n        for a, b, c in self.iter3():\n            ccw.append(Point.ccw(a, b, c))\n        ccw = set(ccw)\n        if len(ccw) == 1:\n            if ccw == {Point.CCW_CLOCKWISE}:\n                return True\n            if ccw == {Point.CCW_COUNTER_CLOCKWISE}:\n                return True\n        if allow_straight and len(ccw) == 2:\n            if ccw == {Point.CCW_ONLINE_FRONT, Point.CCW_CLOCKWISE}:\n                return True\n            if ccw == {Point.CCW_ONLINE_FRONT, Point.CCW_COUNTER_CLOCKWISE}:\n                return True\n        if allow_collapsed and len(ccw) == 3:\n            return ccw == {Point.CCW_ONLINE_FRONT, Point.CCW_ONLINE_BACK, Point.CCW_ON_SEGMENT}\n        return False\n\n    def has_point_on_edge(self, p):\n        \"\"\"\n        指定した点が辺上にあるか\n        :param Point p:\n        :rtype: bool\n        \"\"\"\n        for a, b in self.iter2():\n            if p.on_segment(a, b):\n                return True\n        return False\n\n    def contains(self, p, allow_on_edge=True):\n        \"\"\"\n        指定した点を含むか\n        Winding Number Algorithm\n        https://www.nttpc.co.jp/technology/number_algorithm.html\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C&lang=ja\n        :param Point p:\n        :param bool allow_on_edge: 辺上の点を許容するか\n        \"\"\"\n        angles = []\n        for a, b in self.iter2():\n            if p.on_segment(a, b):\n                return allow_on_edge\n            angles.append(p.angle(a, b))\n        # 一周以上するなら含む\n        return abs(math.fsum(angles)) > EPS\n\n    @staticmethod\n    def convex_hull(points, allow_straight=False):\n        \"\"\"\n        凸包。x が最も小さい点のうち y が最も小さい点から反時計回り。\n        Graham Scan O(N log N)\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=ja\n        :param list of Point points:\n        :param allow_straight: 3点がまっすぐ並んでるのを許容するかどうか\n        :rtype: list of Point\n        \"\"\"\n        points = points[:]\n        points.sort(key=lambda p: (p.x, p.y))\n\n        # allow_straight なら 0 を許容する\n        det_lower = -EPS if allow_straight else EPS\n\n        sz = 0\n        #: :type: list of (Point|None)\n        ret = [None] * (len(points) * 2)\n        for p in points:\n            while sz > 1 and (ret[sz - 1] - ret[sz - 2]).det(p - ret[sz - 1]) < det_lower:\n                sz -= 1\n            ret[sz] = p\n            sz += 1\n        floor = sz\n        for p in reversed(points[:-1]):\n            while sz > floor and (ret[sz - 1] - ret[sz - 2]).det(p - ret[sz - 1]) < det_lower:\n                sz -= 1\n            ret[sz] = p\n            sz += 1\n        ret = ret[:sz - 1]\n\n        if allow_straight and len(ret) > len(points):\n            # allow_straight かつ全部一直線のときに二重にカウントしちゃう\n            ret = points\n        return ret\n\n    @staticmethod\n    def diameter(points):\n        \"\"\"\n        直径\n        凸包構築 O(N log N) + カリパー法 O(N)\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B&lang=ja\n        :param list of Point points:\n        \"\"\"\n        # 反時計回り\n        points = Polygon.convex_hull(points, allow_straight=False)\n        if len(points) == 1:\n            return 0.0\n        if len(points) == 2:\n            return abs(points[0] - points[1])\n\n        # x軸方向に最も遠い点対\n        si = points.index(min(points, key=lambda p: (p.x, p.y)))\n        sj = points.index(max(points, key=lambda p: (p.x, p.y)))\n        n = len(points)\n\n        ret = 0.0\n        # 半周回転\n        i, j = si, sj\n        while i != sj or j != si:\n            ret = max(ret, abs(points[i] - points[j]))\n            ni = (i + 1) % n\n            nj = (j + 1) % n\n            # 2つの辺が並行になる方向にずらす\n            if (points[ni] - points[i]).det(points[nj] - points[j]) > 0:\n                j = nj\n            else:\n                i = ni\n        return ret\n\n    def convex_cut_by_line(self, line_p1, line_p2):\n        \"\"\"\n        凸多角形を直線 line_p1-line_p2 でカットする。\n        凸じゃないといけません\n        Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C&lang=ja\n        :param line_p1:\n        :param line_p2:\n        :return: (line_p1-line_p2 の左側の多角形, line_p1-line_p2 の右側の多角形)\n        :rtype: (Polygon|None, Polygon|None)\n        \"\"\"\n        n = len(self.points)\n        line = Line.from_segment(line_p1, line_p2)\n        # 直線と重なる点\n        on_line_points = []\n        for i, p in enumerate(self.points):\n            if line.has_point(p):\n                on_line_points.append(i)\n\n        # 辺が直線上にある\n        has_on_line_edge = False\n        if len(on_line_points) >= 3:\n            has_on_line_edge = True\n        elif len(on_line_points) == 2:\n            # 直線上にある点が隣り合ってる\n            has_on_line_edge = abs(on_line_points[0] - on_line_points[1]) in [1, n - 1]\n        # 辺が直線上にある場合、どっちか片方に全部ある\n        if has_on_line_edge:\n            for p in self.points:\n                ccw = Point.ccw(line_p1, line_p2, p)\n                if ccw == Point.CCW_COUNTER_CLOCKWISE:\n                    return Polygon(self.points[:]), None\n                if ccw == Point.CCW_CLOCKWISE:\n                    return None, Polygon(self.points[:])\n\n        ret_lefts = []\n        ret_rights = []\n        d = line_p2 - line_p1\n        for p, q in self.iter2():\n            det_p = d.det(p - line_p1)\n            det_q = d.det(q - line_p1)\n            if det_p > -EPS:\n                ret_lefts.append(p)\n            if det_p < EPS:\n                ret_rights.append(p)\n            # 外積の符号が違う == 直線の反対側にある場合は交点を追加\n            if det_p * det_q < -EPS:\n                intersection = line.intersection_point(Line.from_segment(p, q))\n                ret_lefts.append(intersection)\n                ret_rights.append(intersection)\n\n        # 点のみの場合を除いて返す\n        l = Polygon(ret_lefts) if len(ret_lefts) > 1 else None\n        r = Polygon(ret_rights) if len(ret_rights) > 1 else None\n        return l, r\n\n\ndef closest_pair(points):\n    \"\"\"\n    最近点対 O(N log N)\n    Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=ja\n    :param list of Point points:\n    :rtype: (float, (Point, Point))\n    :return: (距離, 点対)\n    \"\"\"\n    assert len(points) >= 2\n\n    def _rec(xsorted):\n        \"\"\"\n        :param list of Point xsorted:\n        :rtype: (float, (Point, Point))\n        \"\"\"\n        n = len(xsorted)\n        if n <= 2:\n            return xsorted[0].dist(xsorted[1]), (xsorted[0], xsorted[1])\n        if n <= 3:\n            # 全探索\n            d = INF\n            pair = None\n            for p, q in itertools.combinations(xsorted, r=2):\n                if p.dist(q) < d:\n                    d = p.dist(q)\n                    pair = p, q\n            return d, pair\n\n        # 分割統治\n        # 両側の最近点対\n        ld, lp = _rec(xsorted[:n // 2])\n        rd, rp = _rec(xsorted[n // 2:])\n        if ld <= rd:\n            d = ld\n            ret_pair = lp\n        else:\n            d = rd\n            ret_pair = rp\n\n        mid_x = xsorted[n // 2].x\n        # 中央から d 以内のやつを集める\n        mid_points = []\n        for p in xsorted:\n            # if abs(p.x - mid_x) < d:\n            if abs(p.x - mid_x) - d < -EPS:\n                mid_points.append(p)\n\n        # この中で距離が d 以内のペアがあれば更新\n        mid_points.sort(key=lambda p: p.y)\n        mid_n = len(mid_points)\n        for i in range(mid_n - 1):\n            j = i + 1\n            p = mid_points[i]\n            q = mid_points[j]\n            # while q.y - p.y < d\n            while (q.y - p.y) - d < -EPS:\n                pq_d = p.dist(q)\n                if pq_d < d:\n                    d = pq_d\n                    ret_pair = p, q\n                j += 1\n                if j >= mid_n:\n                    break\n                q = mid_points[j]\n        return d, ret_pair\n\n    return _rec(list(sorted(points, key=lambda p: p.x)))\n\n\ndef closest_pair_randomized(points):\n    \"\"\"\n    最近点対 乱択版 O(N)\n    グリッドの管理が dict だから定数倍気になる\n    http://ir5.hatenablog.com/entry/20131221/1387557630\n    Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=ja\n    :param list of Point points:\n    :rtype: (float, (Point, Point))\n    :return: (距離, 点対)\n    \"\"\"\n    n = len(points)\n    assert n >= 2\n    if n == 2:\n        return points[0].dist(points[1]), (points[0], points[1])\n\n    # 逐次構成法\n    import random\n    points = points[:]\n    random.shuffle(points)\n\n    DELTA_XY = list(itertools.product([-1, 0, 1], repeat=2))\n    grid = defaultdict(list)\n    delta = INF\n    dist = points[0].dist(points[1])\n    ret_pair = points[0], points[1]\n    for i in range(2, n):\n        if delta < EPS:\n            return 0.0, ret_pair\n        # i 番目より前までを含む grid を構築\n        # if dist < delta:\n        if dist - delta < -EPS:\n            delta = dist\n            grid = defaultdict(list)\n            for a in points[:i]:\n                grid[a.x // delta, a.y // delta].append(a)\n        else:\n            p = points[i - 1]\n            grid[p.x // delta, p.y // delta].append(p)\n\n        p = points[i]\n        dist = delta\n        grid_x = p.x // delta\n        grid_y = p.y // delta\n        # 周り 9 箇所だけ調べれば OK\n        for dx, dy in DELTA_XY:\n            for q in grid[grid_x + dx, grid_y + dy]:\n                d = p.dist(q)\n                # if d < dist:\n                if d - dist < -EPS:\n                    dist = d\n                    ret_pair = p, q\n    return min(delta, dist), ret_pair\n\n\ndef closest_pair_randomized2(points):\n    \"\"\"\n    最近点対 乱択版 O(N)\n    グリッドの管理が dict だから定数倍気になる\n    http://ir5.hatenablog.com/entry/20131221/1387557630\n    Verify: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=ja\n    :param list of Point points:\n    :rtype: (float, (Point, Point))\n    :return: (距離, 点対)\n    \"\"\"\n    n = len(points)\n    assert n >= 2\n    if n == 2:\n        return points[0].dist(points[1]), (points[0], points[1])\n\n    # ふるい法\n    import random\n\n    # いったん2次元だけ実装\n    DIM = 2\n    DELTA_XY = list(itertools.product([-1, 0, 1], repeat=2))\n\n    all_points = points\n    dist = points[0].dist(points[1])\n    while points:\n        next_points = []\n        pi = random.choice(range(len(points)))\n        p = points[pi]\n        d = INF\n        for qi, q in enumerate(points):\n            if pi == qi:\n                continue\n            d = min(d, p.dist(q))\n        # TODO: d == 0 のケース\n        width = d / (4 * DIM)\n        grid = defaultdict(list)\n        for p in points:\n            grid[p.x // width, p.y // width].append(p)\n        for p in points:\n            grid_x = p.x // width\n            grid_y = p.y // width\n            cnt = 0\n            for dx, dy in DELTA_XY:\n                cnt += len(grid[grid_x + dx, grid_y + y])\n            if cnt >= 2:\n                next_points.append(p)\n\n        dist = d\n        points = next_points\n\n    width = dist\n    grid = defaultdict(list)\n    for p in all_points:\n        grid[p.x // width, p.y // width].append(p)\n    ret = INF\n    for p in all_points:\n        grid_x = p.x // width\n        grid_y = p.y // width\n        # 周り 9 箇所だけ調べれば OK\n        for dx, dy in DELTA_XY:\n            for q in grid[grid_x + dx, grid_y + dy]:\n                if p == q:\n                    # 距離が 0 のときは上で return してるので無視していい\n                    continue\n                d = p.dist(q)\n                # if d < ret:\n                if d - ret < -EPS:\n                    ret = d\n                    ret_pair = p, q\n    return ret, ret_pair\n\n\nN = int(sys.stdin.buffer.readline())\nXY = [list(map(float, sys.stdin.buffer.readline().split())) for _ in range(N)]\n\npoints = []\nfor x, y in XY:\n    points.append(Point(complex(x, y)))\nd, (p, q) = closest_pair_randomized2(points)\nprint('{:.10f}'.format(d))\n\n# pi = -1\n# qi = -1\n# for i, a in enumerate(points):\n#     if a == p:\n#         pi = i\n#     if a == q:\n#         qi = i\n# print(pi, qi)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom operator import itemgetter\nfrom math import hypot\nfrom itertools import takewhile, chain, combinations\n\ndef ntp(A: list, axis: int = -1):\n    length = len(A)\n    if length <= 4:\n        return min([hypot(x1 - x2, y1 - y2) for (x1, y1), (x2, y2) in combinations(A, 2)])\n    \n    x_types = len(set(x for x, _ in A))\n    axis1 = 2*x_types <= length\n    axis2 = not axis1\n    mid_idx = length//2\n    \n    if axis1 != axis:\n        A.sort(key = itemgetter(axis1))\n    Al, Ar = A[:mid_idx], A[mid_idx:]\n    median = A[mid_idx][axis1]\n    \n    tmd = min(ntp(Al, axis1), ntp(Ar, axis1))\n    \n    midA = [p for p in chain(takewhile(lambda t: median - tmd < t[axis1], Al[::-1]),\\\n                             takewhile(lambda t: median + tmd > t[axis1], Ar))]\n    midA.sort(key = itemgetter(axis2))\n    for i, (x1, y1) in enumerate(midA):\n        ub = (x1, y1)[axis2] + tmd\n        for x2, y2 in takewhile(lambda t: t[axis2] < ub, midA[i+1:]):\n            tmd = min(tmd, hypot(x1 - x2, y1 - y2))\n    \n    return tmd\nn = int(sys.stdin.readline())\nPoints = [tuple(map(float, sys.stdin.readline().split())) for _ in [0]*n] \nprint('{:.10f}'.format(ntp(Points)))\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\nimport operator\n\n\ndef norm(self):\n    return abs(self)\n\ndef closest_pair(p):\n    m = 0\n    p.sort(key=operator.attrgetter('real'))\n    d = float('inf')\n    for i in range(1, len(p)):\n        for j in reversed(range(m, i)):\n            tmp = abs(p[j] - p[i])\n            if d < tmp.real:\n                m += 1\n                break\n            elif d > tmp:\n                d = tmp\n    return d\n\n\n\nfrom itertools import combinations\ndef brute_force(p):\n    return min(abs(p[i] - p[j]) for i, j in combinations(range(len(p)), 2))\n\n\ndef main():\n    n = int(readline())\n    p = [map(float, readline().split()) for _ in range(n)]\n    p = [x + y * 1j for x, y in p]\n\n    \n    #print('{:.6f}'.format(brute_force(p)))\n    print('{:.6f}'.format(closest_pair(p)))\nmain()"
  },
  {
    "language": "Python",
    "code": "import itertools\n\ndef _get_min_distance(points):\n    min_d = 400\n    for p1, p2 in itertools.combinations(points, 2):\n        min_d = min(min_d, abs(p1 - p2))\n    return min_d\n\ndef closest_pair_distance(points):\n    n = len(points)\n    if n <= 3:\n        return _get_min_distance(points)\n    else:\n        mid = n // 2\n        left_points = points[:mid]\n        right_points = points[mid:]\n        d_Lmin = closest_pair_distance(left_points)\n        d_Rmin = closest_pair_distance(right_points)\n        dist = min(d_Lmin, d_Rmin)\n        min_d = dist\n        for lp in left_points[::-1]:\n            if right_points[0].real - lp.real >= dist:\n                break\n            for rp in right_points:\n                if rp.real -lp.real >= dist:\n                    break\n                if lp.imag - dist < rp.imag < lp.imag + dist:\n                    min_d = min(min_d, abs(lp - rp))\n        return min_d\n\n# Acceptance of input\ndef string_to_complex(s):\n    x, y = map(float, s.split())\n    return x + y * 1j\n\nimport sys\n\nfile_input = sys.stdin\n\nn = int(file_input.readline())\n\nP = [string_to_complex(line) for line in file_input]\n\nP.sort(key = lambda c: (c.imag, c.real))\n\n# Output\nans = closest_pair_distance(P)\nprint('{:f}'.format(ans))"
  },
  {
    "language": "Python",
    "code": "num_point = int(input())\npoint_list = [0] * num_point\nfor i in range(num_point):\n    line_split = input().split(\" \")\n    point_list[i] = [float(line_split[0]), float(line_split[1])]\npoint_list.sort(key=lambda point: point[0])\n\nmin_sum_square = float(\"inf\")\nfor i in range(num_point):\n    for j in range(i + 1, num_point):\n        x_dif = point_list[i][0] - point_list[j][0]\n        y_dif = point_list[i][1] - point_list[j][1]\n        x_dif_square = x_dif**2\n        y_dif_square = y_dif**2\n        if x_dif <=0 and x_dif_square >= min_sum_square:\n            break\n        else:\n            sum_square = x_dif_square + y_dif_square\n            min_sum_square = min(sum_square, min_sum_square)\n\nmin_distance = min_sum_square**0.5\nprint(\"{0:.6f}\".format(min_distance))"
  },
  {
    "language": "Python",
    "code": "# #### CLOSEST PAIR O(N LOG N) ALGORITHM #### #\n# points should be unique, otherwise the closest pair would be the repeated points\n# also this will only find 1 pair with the smallest distance, in case there are multiple pairs with this same minimum distance\n\n#import time\n#start = time.time()\n\n\t\ndef halve(coord): # split into two halves by x-coordinate\n\tL = len(coord) # luckily pts are already sorted\n\treturn [coord[:L/2], coord[L/2:]]\n\ndef dist(x, y): # for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n\treturn (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\n\t\ndef splitpair(px, py, d): # only need to return a correct value if closest pair is split\n\txBar = px[(len(px)+1)/2][0]\n\tSy = [] # Sy will be the set of points (sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n\tfor i in xrange(len(py)):\n\t\tif xBar-d**0.5 <= py[i][0] <= xBar+d**0.5: # only consider a 'strip' around xBar that is 2*sqrt(d) wide\n\t\t\tSy.append(py[i])\t\n\t\n\tbestpair = None # the coords of the best pair of points so far\n\tbestD = d # the squared distance of the best pair of points\n\t# now iterate through Sy for points that aren't more than 7 apart\n\tfor i in xrange(len(Sy)-2):\n\t\tfor j in xrange(1, min(8, len(Sy)-i-1)):  # 7 next points\n\t\t\tp, q = Sy[i], Sy[i+j]\n\t\t\t\n\t\t\tif dist(p, q) < bestD:\n\t\t\t\tbestpair = [p, q]\n\t\t\t\tbestD = dist(p, q)\n\t\t\t\t\n\treturn bestpair\n\t\ndef convert(p1, p2): # convert 2 points into two pairs of pairs, first sorted by x, other sorted by y1\n\treturn [sorted([p1, p2]), sorted([p1, p2], key=lambda x: x[1])]\n\t\ndef solve(Px, Py): # where Px and Py are the points sorted by x and y coordinate respectively\n\t# this function returns two closest points\n\tassert len(Px) == len(Py) # make sure you have the same number of x and y coords\n\tif len(Px) == 2:\n\t\treturn (Px, Py)\n\telif len(Px) == 3: # 3 points, brute force\n\t\tp1, p2, p3 = [x for x in Px]\n\t\td12, d13, d23 = dist(p1, p2), dist(p1, p3), dist(p2, p3)\n\t\tif min(d12, d13, d23) == d12: \n\t\t\treturn convert(p1, p2)\n\t\telif min(d12, d13, d23) == d13: \n\t\t\treturn convert(p1, p3)\n\t\telse: \n\t\t\treturn convert(p2, p3)\n\telse:\n\t\tQx, Rx = [x for x in halve(Px)]\n\t\tQy, Ry = [], []\n\t\tfor pt in Py:\n\t\t\tif pt in Qx:\n\t\t\t\tQy.append(pt)\n\t\t\tif pt in Rx:\n\t\t\t\tRy.append(pt)\n\t\tassert len(Qx) == len(Qy)\n\t\tassert len(Rx) == len(Ry)\n\t\t\n\t\t# now use recursion. note ci is of the form [[x1,x2], [y1,y2]]\n\t\tc1 = solve(Qx, Qy) # find the closest pair in left half\n\t\tc2 = solve(Rx, Ry) # find the closest pair in the right half\n\t\t\n\t\tD = min(dist(c1[0][0], c1[0][1]), dist(c2[0][0], c2[0][1]))\n\t\tif D == dist(c1[0][0], c1[0][1]):\n\t\t\tbestpair = c1\n\t\telif D == dist(c2[0][0], c2[0][1]):\n\t\t\tbestpair = c2\n\t\t\n\t\tc3 = splitpair(Px, Py, D) # find the closest split pair. this needs to be O(n) to get O(n log n) for entire algo\n\t\t\n\t\tif c3 is not None: \n\t\t\treturn convert(c3[0], c3[1])\n\t\telse:\n\t\t\treturn bestpair # else it's one of the c1 or c2\n\t\t\n\t\t\ndef main():\n\tN = int(raw_input().split()[0]) # N is number of points\n\tassert  N >= 2\n\tpts = [] # pairs of points, i.e pts = [[x1,y1], [x2,y2], ... , [xn,yn]]\n\t\n\t# get all pairs of points into our list\n\tfor i in xrange(N):\n\t\tpts.append([float(x) for x in raw_input().split()])\n\t\t\n\t\n\tPx = sorted(pts) # sort the pts by x coordinate\n\tPy = sorted(pts, key=lambda x: x[1]) # sort the pts by y coordinate\n\t\n\tres = solve(Px, Py)\n\t\n\t'''\n\t# find the index of the points in pts\n\tfor i in xrange(len(pts)):\n\t\tif pts[i] == res[0][0]:\n\t\t\tind1 = i\n\t\telif pts[i] == res[0][1]:\n\t\t\tind2 = i\n\t\t\t\n\td = dist(pts[ind1], pts[ind2]) ** 0.5\n\t'''\n\t\n\tprint dist(res[0][0], res[0][1]) ** 0.5\n\nif __name__ == '__main__':\n\tmain()\n\n\n#print \"%.2f %s\" % (((time.time() - start) * 1000), \"ms\")"
  },
  {
    "language": "Python",
    "code": "import itertools\n\ndef _get_min_distance(points):\n    min_d = 400\n    for p1, p2 in itertools.combinations(points, 2):\n        min_d = min(min_d, abs(p1 - p2))\n    return min_d\n\n# Search based on x axis\ndef closest_pair_distance_x(points):\n    n = len(points)\n    if n <= 3:\n        return _get_min_distance(points)\n    else:\n        mid = n // 2\n        left_points = points[:mid]\n        right_points = points[mid:]\n        d_Lmin = closest_pair_distance(left_points)\n        d_Rmin = closest_pair_distance(right_points)\n        dist = min(d_Lmin, d_Rmin)\n        min_d = dist\n        for lp in left_points[::-1]:\n            if right_points[0].real - lp.real >= dist:\n                break\n            for rp in right_points:\n                if rp.real -lp.real >= dist:\n                    break\n                if lp.imag - dist < rp.imag < lp.imag + dist:\n                    min_d = min(min_d, abs(lp - rp))\n        return min_d\n\n# Search based on y axis\ndef closest_pair_distance_y(points):\n    n = len(points)\n    if n <= 3:\n        return _get_min_distance(points)\n    else:\n        mid = n // 2\n        lower_points = points[:mid]\n        upper_points = points[mid:]\n        d_Lmin = closest_pair_distance(lower_points)\n        d_Umin = closest_pair_distance(upper_points)\n        dist = min(d_Lmin, d_Umin)\n        min_d = dist\n        for lp in lower_points[::-1]:\n            if upper_points[0].imag - lp.imag >= dist:\n                break\n            for up in upper_points:\n                if up.imag -lp.imag >= dist:\n                    break\n                if lp.real - dist < up.real < lp.real + dist:\n                    min_d = min(min_d, abs(lp - up))\n        return min_d\n\n# Acceptance of input\ndef string_to_complex(s):\n    x, y = map(float, s.split())\n    return x + y * 1j\n\nimport sys\n\nfile_input = sys.stdin\n\nn = int(file_input.readline())\n\nP = [string_to_complex(line) for line in file_input]\n\n# Solve\nP.sort(key = lambda c: (c.real, c.imag))\n\nif P[-1].real - P[0].real >= P[-1].imag - P[0].imag:\n    ans = closest_pair_distance_x(P)\n    print('{:f}'.format(ans))\nelse:\n    P.sort(key = lambda c: c.imag)\n    ans = closest_pair_distance_y(P)\n    print('{:f}'.format(ans))"
  },
  {
    "language": "Python",
    "code": "# #### CLOSEST PAIR O(N LOG N) ALGORITHM #### #\n# points should be unique, otherwise the closest pair would be the repeated points\n# also this will only find 1 pair with the smallest distance, in case there are multiple pairs with this same minimum distance\n\n#import time\n#start = time.time()\n\n\ndef dist(x, y): # for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n\treturn (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\n\t\ndef splitpair(px, py, d): # only need to return a correct value if closest pair is split\n\txBar = px[(len(px)+1)/2][0] #x-coordinate of the leftmost element of px\n\tSy = [] # Sy will be the set of points (sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n\tfor i in xrange(len(py)):\n\t\tif xBar-d**0.5 <= py[i][0] <= xBar+d**0.5: # only consider a 'strip' around xBar that is 2*sqrt(d) wide\n\t\t\tSy.append(py[i])\t\n\t\n\tbestpair = None # the coords of the best pair of points so far\n\tbestD = d # the squared distance of the best pair of points\n\t# now iterate through Sy for points that aren't more than 7 apart\n\tfor i in xrange(len(Sy)-2):\n\t\tfor j in xrange(1, min(8, len(Sy)-i-1)):  # 7 next points\n\t\t\tp, q = Sy[i], Sy[i+j]\n\t\t\t\n\t\t\tif dist(p, q) < bestD:\n\t\t\t\tbestpair = [p, q]\n\t\t\t\tbestD = dist(p, q)\n\t\t\t\t\n\treturn bestpair\n\t\ndef convert(p1, p2): # convert 2 points into two pairs of pairs, first sorted by x, other sorted by y1\n\treturn [sorted([p1, p2]), sorted([p1, p2], key=lambda x: x[1])]\n\t\ndef solve(Px, Py): # where Px and Py are the points sorted by x and y coordinate respectively\n\t# this function returns two closest points\n\tassert len(Px) == len(Py) # make sure you have the same number of x and y coords\n\tif len(Px) == 2:\n\t\treturn (Px, Py)\n\telif len(Px) == 3: # 3 points, brute force\n\t\tp1, p2, p3 = [x for x in Px]\n\t\td12, d13, d23 = dist(p1, p2), dist(p1, p3), dist(p2, p3)\n\t\tif min(d12, d13, d23) == d12: \n\t\t\treturn convert(p1, p2)\n\t\telif min(d12, d13, d23) == d13: \n\t\t\treturn convert(p1, p3)\n\t\telse: \n\t\t\treturn convert(p2, p3)\n\telse:\n\t\tL = len(Px)\n\t\tQx, Rx = Px[:(L+1)/2], Px[(L+1)/2:]\n\t\tassert abs(len(Qx) - len(Rx)) <= 1\n\t\tQy, Ry = [], []\n\t\tk = Qx[-1][0] # x-coordinate of the rightmost element in Qx\n\t\tdump = []\n\t\tfor pt in Py: # this is linear time, you loop through Py exactly once\n\t\t\tif pt[0] < k and len(Qy) < len(Qx):\n\t\t\t\tQy.append(pt)\n\t\t\telif pt[0] == k: # if it's equal, keep track of these, then add back the correct number\n\t\t\t\tdump.append(pt)\n\t\t\telse:\n\t\t\t\tRy.append(pt)\n\t\t# now add back enough of the 'dump' list\n\t\tdiff = len(Qx) - len(Qy)\n\t\tfor d in dump[:diff]:\n\t\t\tQy.append(d)\n\t\tfor d in dump[diff:]:\n\t\t\tRy.append(d)\n\t\t\n\t\t# now use recursion. note ci is of the form [[x1,x2], [y1,y2]]\n\t\tif not sorted(Qx) == sorted(Qy):\n\t\t\tprint Qx\n\t\t\tprint Qy\n\t\tassert sorted(Rx) == sorted(Ry)\n\t\tc1 = solve(Qx, Qy) # find the closest pair in left half\n\t\tc2 = solve(Rx, Ry) # find the closest pair in the right half\n\t\t\n\t\tD = min(dist(c1[0][0], c1[0][1]), dist(c2[0][0], c2[0][1]))\n\t\tif D == dist(c1[0][0], c1[0][1]):\n\t\t\tbestpair = c1\n\t\telif D == dist(c2[0][0], c2[0][1]):\n\t\t\tbestpair = c2\n\t\t\n\t\tc3 = splitpair(Px, Py, D) # find the closest split pair. this needs to be O(n) to get O(n log n) for entire algo\n\t\t\n\t\tif c3 is not None: \n\t\t\treturn convert(c3[0], c3[1])\n\t\telse:\n\t\t\tassert sorted(bestpair[0]) == sorted(bestpair[1])\n\t\t\treturn [bestpair[0], bestpair[1]] # else it's one of the c1 or c2\n\t\t\n\t\t\ndef main():\n\tN = int(raw_input().split()[0]) # N is number of points\n\tassert  N >= 2\n\tpts = [] # pairs of points, i.e pts = [[x1,y1], [x2,y2], ... , [xn,yn]]\n\t\n\t# get all pairs of points into our list\n\tfor i in xrange(N):\n\t\tpts.append([float(x) for x in raw_input().split()])\n\t\t\n\t\n\tPx = sorted(pts) # sort the pts by x coordinate\n\tPy = sorted(pts, key=lambda x: x[1]) # sort the pts by y coordinate\n\t\n\tres = solve(Px, Py)\n\t\n\t'''\n\t# find the index of the points in pts\n\tfor i in xrange(len(pts)):\n\t\tif pts[i] == res[0][0]:\n\t\t\tind1 = i\n\t\telif pts[i] == res[0][1]:\n\t\t\tind2 = i\n\t\t\t\n\td = dist(pts[ind1], pts[ind2]) ** 0.5\n\t'''\n\t\n\tprint dist(res[0][0], res[0][1]) ** 0.5\n\nif __name__ == '__main__':\n\tmain()\n\n\n#print \"%.2f %s\" % (((time.time() - start) * 1000), \"ms\")"
  },
  {
    "language": "Python",
    "code": "from operator import attrgetter\nfrom itertools import combinations\n\nkeys = [attrgetter('real'), attrgetter('imag')]\n\n\ndef bound(points):\n    xmx = max(p.real for p in points)\n    xmn = min(p.real for p in points)\n    ymx = max(p.imag for p in points)\n    ymn = min(p.imag for p in points)\n    return xmx - xmn < ymx - ymn\n\n\ndef solve(points, prev_sort):\n    l = len(points)\n    if l < 20:\n        return min(abs(p2 - p1) for p1, p2 in combinations(points, 2))\n    m = l // 2\n    pl, pr = points[:m], points[m:]\n    key, rkey = keys[prev_sort], keys[not prev_sort]\n    pl_next_sort, pr_next_sort = bound(pl), bound(pr)\n    pl_next_points = pl.copy() if prev_sort == pl_next_sort else sorted(pl, key=keys[pl_next_sort])\n    pr_next_points = pr.copy() if prev_sort == pr_next_sort else sorted(pr, key=keys[pr_next_sort])\n    ans = min(solve(pl_next_points, pl_next_sort), solve(pr_next_points, pr_next_sort))\n    pm = key(pr[0])\n    for p in reversed(pl):\n        if key(p) <= pm - ans:\n            break\n        for q in pr:\n            if key(q) >= pm + ans:\n                break\n            rp = rkey(p)\n            if rp - ans < rkey(q) < rp + ans:\n                ans = min(ans, abs(q - p))\n    return ans\n\n\nn = int(input())\npoints = [complex(*map(float, input().split())) for _ in range(n)]\nprint('{:.10f}'.format(solve(sorted(points, key=keys[0]), 0)))"
  },
  {
    "language": "Python",
    "code": "import itertools\n\ndef _get_min_distance(points):\n    min_d = 400\n    for p1, p2 in itertools.combinations(points, 2):\n        min_d = min(min_d, abs(p1 - p2))\n    return min_d\n\n# Search based on x axis\ndef closest_pair_distance_x(points):\n    n = len(points)\n    if n <= 3:\n        return _get_min_distance(points)\n    else:\n        mid = n // 2\n        left_points = points[:mid]\n        right_points = points[mid:]\n        d_Lmin = closest_pair_distance_x(left_points)\n        d_Rmin = closest_pair_distance_x(right_points)\n        dist = min(d_Lmin, d_Rmin)\n        min_d = dist\n        for lp in left_points[::-1]:\n            if right_points[0].real - lp.real >= dist:\n                break\n            for rp in right_points:\n                if rp.real -lp.real >= dist:\n                    break\n                if lp.imag - dist < rp.imag < lp.imag + dist:\n                    min_d = min(min_d, abs(lp - rp))\n        return min_d\n\n# Search based on y axis\ndef closest_pair_distance_y(points):\n    n = len(points)\n    if n <= 3:\n        return _get_min_distance(points)\n    else:\n        mid = n // 2\n        lower_points = points[:mid]\n        upper_points = points[mid:]\n        d_Lmin = closest_pair_distance_y(lower_points)\n        d_Umin = closest_pair_distance_y(upper_points)\n        dist = min(d_Lmin, d_Umin)\n        min_d = dist\n        for lp in lower_points[::-1]:\n            if upper_points[0].imag - lp.imag >= dist:\n                break\n            for up in upper_points:\n                if up.imag -lp.imag >= dist:\n                    break\n                if lp.real - dist < up.real < lp.real + dist:\n                    min_d = min(min_d, abs(lp - up))\n        return min_d\n\n# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = int(file_input.readline())\n\nP = []\npX = []\npY = []\n\nfor line in file_input:\n    x, y = map(float, line.split())\n    P.append(x + y * 1j)\n    pX.append(x)\n    pY.append(y)\n\n# Solve\nif len(set(pX)) > len(set(pY)):\n    P.sort(key = lambda c: c.real)\n    ans = closest_pair_distance_x(P)\nelse:\n    P.sort(key = lambda c: c.imag)\n    ans = closest_pair_distance_y(P)\n\nprint('{:f}'.format(ans))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3\n0.0 0.0\n2.0 0.0\n1.0 1.0\n\noutput:\n1.41421356237\n\"\"\"\n\nimport math\nimport sys\nfrom operator import attrgetter\n\n\nclass ClosestPair(object):\n    def __init__(self, ):\n        \"\"\"\n        Init closest pairs points set.\n        \"\"\"\n        _input = sys.stdin.readlines()\n        p_num = int(_input[0])\n        points = map(lambda x: x.split(), _input[1:])\n        p_list = [complex(float(x), float(y)) for x, y in points]\n        p_list.sort(key=attrgetter('real'))\n        # assert len(p_list) == p_num\n        # print(p_list)\n        ans = self.closest_pair(array=p_list, array_length=p_num)\n        print(('{:.6f}'.format(ans)))\n\n    def closest_pair(self, array, array_length):\n        if array_length <= 1:\n            return float('inf')\n        mid = array_length // 2\n        mid_real = array[mid].real\n        d = min(self.closest_pair(array[:mid], mid).real,\n                self.closest_pair(array[mid:], array_length - mid).real)\n\n        return self.brute_force(array, mid_real, d)\n\n    @staticmethod\n    def brute_force(array, mid_real, d=float('inf')):\n        array.sort(key=attrgetter('imag'))\n        min_stack = list()\n        for ele in array:\n            size = len(min_stack)\n            if abs(ele.real - mid_real) >= d:\n                continue\n\n            for j in range(size):\n                dx = ele.real - min_stack[size - j - 1].real\n                dy = ele.imag - min_stack[size - j - 1].imag\n                if dy >= d:\n                    break\n                d = min(d, math.sqrt(dx ** 2 + dy ** 2))\n\n            min_stack.append(ele)\n\n        return d\n\n\nif __name__ == '__main__':\n    case = ClosestPair()"
  },
  {
    "language": "Python",
    "code": "import itertools\n\ndef _get_min_distance(points):\n    min_d = 400\n    for p1, p2 in itertools.combinations(points, 2):\n        min_d = min(min_d, abs(p1 - p2))\n    return min_d\n\n# Search based on x axis\ndef closest_pair_distance_x(points):\n    n = len(points)\n    if n <= 3:\n        return _get_min_distance(points)\n    else:\n        mid = n // 2\n        left_points = points[:mid]\n        right_points = points[mid:]\n        d_Lmin = closest_pair_distance_x(left_points)\n        d_Rmin = closest_pair_distance_x(right_points)\n        dist = min(d_Lmin, d_Rmin)\n        min_d = dist\n        for lp in left_points[::-1]:\n            if right_points[0].real - lp.real >= dist:\n                break\n            for rp in right_points:\n                if rp.real -lp.real >= dist:\n                    break\n                if lp.imag - dist < rp.imag < lp.imag + dist:\n                    min_d = min(min_d, abs(lp - rp))\n        return min_d\n\n# Search based on y axis\ndef closest_pair_distance_y(points):\n    n = len(points)\n    if n <= 3:\n        return _get_min_distance(points)\n    else:\n        mid = n // 2\n        lower_points = points[:mid]\n        upper_points = points[mid:]\n        d_Lmin = closest_pair_distance_y(lower_points)\n        d_Umin = closest_pair_distance_y(upper_points)\n        dist = min(d_Lmin, d_Umin)\n        min_d = dist\n        for lp in lower_points[::-1]:\n            if upper_points[0].imag - lp.imag >= dist:\n                break\n            for up in upper_points:\n                if up.imag -lp.imag >= dist:\n                    break\n                if lp.real - dist < up.real < lp.real + dist:\n                    min_d = min(min_d, abs(lp - up))\n        return min_d\n\n# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = int(file_input.readline())\n\nP = []\npX = []\npY = []\n\nfor line in file_input:\n    x, y = map(float, line.split())\n    P.append(x + y * 1j)\n    pX.append(x)\n    pY.append(y)\n\n# Solve\nif len(set(pX)) > len(set(pY)):\n    P.sort(key = lambda c: c.real)\n    ans = closest_pair_distance_x(P)\nelse:\n    P.sort(key = lambda c: c.imag)\n    ans = closest_pair_distance_y(P)\n\nprint('{:f}'.format(ans))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3\n0.0 0.0\n2.0 0.0\n1.0 1.0\n\noutput:\n1.41421356237\n\"\"\"\n\nimport sys\nfrom operator import attrgetter\n\n\nclass ClosestPair(object):\n    def __init__(self, ):\n        \"\"\"\n        Init closest pairs points set.\n        \"\"\"\n        _input = sys.stdin.readlines()\n        p_num = int(_input[0])\n        points = map(lambda x: x.split(), _input[1:])\n        p_list = [complex(float(x), float(y)) for x, y in points]\n        # pre_sort by axis_X\n        p_list.sort(key=attrgetter('real'))\n\n        ans = self.closest_pair(array=p_list, array_length=p_num)\n        print(('{:.6f}'.format(ans)))\n\n    def closest_pair(self, array, array_length):\n        if array_length <= 1:\n            return float('inf')\n        mid_idx = array_length // 2\n        div_line = array[mid_idx].real\n        d_min = min(self.closest_pair(array[:mid_idx], mid_idx),\n                self.closest_pair(array[mid_idx:], array_length - mid_idx))\n\n        # sort array_part by axis_Y while recursively comparing\n        array.sort(key=attrgetter('imag'))\n\n        min_stack = list()\n        for ele in array:\n            size = len(min_stack)\n\n            if abs(ele.real - div_line) >= d_min:\n                continue\n\n            for j in range(size):\n                alt = ele - min_stack[size - j - 1]\n                if alt.imag >= d_min:\n                    break\n                d_min = min(d_min, abs(alt))\n\n            min_stack.append(ele)\n\n        return d_min\n\n\nif __name__ == '__main__':\n    case = ClosestPair()"
  },
  {
    "language": "Python",
    "code": "# #### CLOSEST PAIR O(N LOG N) ALGORITHM #### #\n# points should be unique, otherwise the closest pair would be the repeated points\n# also this will only find 1 pair with the smallest distance, in case there are multiple pairs with this same minimum distance\n\n#import time\n#start = time.time()\n\n\ndef dist(x, y): # for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n\treturn (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\n\t\ndef splitpair(px, py, d): # only need to return a correct value if closest pair is split\n\txBar = px[(len(px)+1)/2][0] #x-coordinate of the leftmost element of px\n\tSy = [] # Sy will be the set of points (sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n\tfor i in xrange(len(py)):\n\t\tif xBar-d**0.5 <= py[i][0] <= xBar+d**0.5: # only consider a 'strip' around xBar that is 2*sqrt(d) wide\n\t\t\tSy.append(py[i])\t\n\t\n\tbestpair = None # the coords of the best pair of points so far\n\tbestD = d # the squared distance of the best pair of points\n\t# now iterate through Sy for points that aren't more than 7 apart\n\tfor i in xrange(len(Sy)-2):\n\t\tfor j in xrange(1, min(8, len(Sy)-i-1)):  # 7 next points\n\t\t\tp, q = Sy[i], Sy[i+j]\n\t\t\t\n\t\t\tif dist(p, q) < bestD:\n\t\t\t\tbestpair = [p, q]\n\t\t\t\tbestD = dist(p, q)\n\t\t\t\t\n\treturn bestpair\n\t\ndef convert(p1, p2): # convert 2 points into two pairs of pairs, first sorted by x, other sorted by y1\n\treturn [sorted([p1, p2]), sorted([p1, p2], key=lambda x: x[1])]\n\t\ndef solve(Px, Py): # where Px and Py are the points sorted by x and y coordinate respectively\n\t# this function returns two closest points\n\tassert len(Px) == len(Py) # make sure you have the same number of x and y coords\n\tif len(Px) == 2:\n\t\treturn (Px, Py)\n\telif len(Px) == 3: # 3 points, brute force\n\t\tp1, p2, p3 = [x for x in Px]\n\t\td12, d13, d23 = dist(p1, p2), dist(p1, p3), dist(p2, p3)\n\t\tif min(d12, d13, d23) == d12: \n\t\t\treturn convert(p1, p2)\n\t\telif min(d12, d13, d23) == d13: \n\t\t\treturn convert(p1, p3)\n\t\telse: \n\t\t\treturn convert(p2, p3)\n\telse:\n\t\tL = len(Px)\n\t\tQx, Rx = Px[:L/2], Px[L/2:]\n\t\tassert abs(len(Qx) - len(Rx)) <= 1\n\t\tQy, Ry = [], []\n\t\tk = Qx[-1][0] # x-coordinate of the rightmost element in Qx\n\t\tdump = []\n\t\tfor pt in Py: # this is linear time, you loop through Py exactly once\n\t\t\tif pt[0] < k and len(Qy) < len(Qx):\n\t\t\t\tQy.append(pt)\n\t\t\telif pt[0] == k: # if it's equal, keep track of these, then add back the correct number\n\t\t\t\tdump.append(pt)\n\t\t\telse:\n\t\t\t\tRy.append(pt)\n\t\t# now add back enough of the 'dump' list\n\t\tdiff = len(Qx) - len(Qy)\n\t\tfor d in dump[:diff]:\n\t\t\tQy.append(d)\n\t\tfor d in dump[diff:]:\n\t\t\tRy.append(d)\n\t\t\n\t\t# now use recursion. note ci is of the form [[x1,x2], [y1,y2]]\n\t\tif not sorted(Qx) == sorted(Qy):\n\t\t\tprint Qx\n\t\t\tprint Qy\n\t\tassert sorted(Rx) == sorted(Ry)\n\t\tc1 = solve(Qx, Qy) # find the closest pair in left half\n\t\tc2 = solve(Rx, Ry) # find the closest pair in the right half\n\t\t\n\t\tD = min(dist(c1[0][0], c1[0][1]), dist(c2[0][0], c2[0][1]))\n\t\tif D == dist(c1[0][0], c1[0][1]):\n\t\t\tbestpair = c1\n\t\telif D == dist(c2[0][0], c2[0][1]):\n\t\t\tbestpair = c2\n\t\t\n\t\tc3 = splitpair(Px, Py, D) # find the closest split pair. this needs to be O(n) to get O(n log n) for entire algo\n\t\t\n\t\tif c3 is not None: \n\t\t\treturn convert(c3[0], c3[1])\n\t\telse:\n\t\t\tassert sorted(bestpair[0]) == sorted(bestpair[1])\n\t\t\treturn [bestpair[0], bestpair[1]] # else it's one of the c1 or c2\n\t\t\n\t\t\ndef main():\n\tN = int(raw_input().split()[0]) # N is number of points\n\tassert  N >= 2\n\tpts = [] # pairs of points, i.e pts = [[x1,y1], [x2,y2], ... , [xn,yn]]\n\t\n\t# get all pairs of points into our list\n\tfor i in xrange(N):\n\t\tpts.append([float(x) for x in raw_input().split()])\n\t\t\n\t\n\tPx = sorted(pts) # sort the pts by x coordinate\n\tPy = sorted(pts, key=lambda x: x[1]) # sort the pts by y coordinate\n\t\n\tres = solve(Px, Py)\n\t\n\t'''\n\t# find the index of the points in pts\n\tfor i in xrange(len(pts)):\n\t\tif pts[i] == res[0][0]:\n\t\t\tind1 = i\n\t\telif pts[i] == res[0][1]:\n\t\t\tind2 = i\n\t\t\t\n\td = dist(pts[ind1], pts[ind2]) ** 0.5\n\t'''\n\t\n\tprint dist(res[0][0], res[0][1]) ** 0.5\n\nif __name__ == '__main__':\n\tmain()\n\n\n#print \"%.2f %s\" % (((time.time() - start) * 1000), \"ms\")"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom operator import attrgetter\nreadline = stdin.readline\n\n\ndef norm(a):\n    return a.real * a.real + a.imag * a.imag\n\n\ndef closest_pair(p):\n    if len(p) <= 1:\n        return float('inf')\n    m = len(p) // 2\n    d = min(closest_pair(p[:m]), closest_pair(p[m:]))\n    p = [pi for pi in p if p[m].imag - d < pi.imag < p[m].imag + d]\n    return brute_force(p, d)\n\ndef brute_force(p, d=float('inf')):\n    p.sort(key=attrgetter('real'))\n    for i in range(1, len(p)):\n        for j in reversed(range(i)):\n            tmp = p[i] - p[j]\n            if d < tmp.real:\n                break\n            tmp = abs(tmp)\n            if d > tmp:\n                d = tmp\n    return d\n\n\ndef main():\n    n = int(readline())\n    p = [map(float, readline().split()) for _ in range(n)]\n    p = [x + y * 1j for x, y in p]\n\n    p.sort(key=attrgetter('imag'))\n    print('{:.6f}'.format(closest_pair(p)))\nmain()"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom operator import itemgetter\nfrom itertools import permutations\nfrom math import sqrt\n\ndef solve(a: list):\n    length = len(a)\n    if length <= 3:\n        return min(sqrt((p1[0]-p2[0])**2+(p1[1]-p2[1])**2) for p1, p2 in permutations(a, 2))\n\n    med = length//2\n    x_l, x_r = a[:med], a[med:]\n    delta = min(solve(x_l), solve(x_r))\n    median_x = a[med][0]\n    m_a = []\n        \n    for p in x_l[::-1]:\n        if p[0] < median_x-delta:\n            break\n        m_a.append(p)\n    for p in x_r:\n        if p[0] > median_x+delta:\n            break\n        m_a.append(p)\n    m_a.sort(key=itemgetter(1))\n\n    for i, (x1, y1) in enumerate(m_a):\n        to_y = y1 + delta\n        for j, (x2, y2) in enumerate(m_a[i+1:]):\n            if y2 > to_y:\n                break\n            delta = min(delta, sqrt((x1-x2)**2+(y1-y2)**2))\n\n    return delta\n\nif __name__ == \"__main__\":\n    N = int(input())\n    a = sorted([tuple(map(float, l.split())) for l in sys.stdin.readlines()])\n    print(\"{:.10f}\".format(solve(a)))\n"
  },
  {
    "language": "Python",
    "code": "# 最近点対を分割統治法で求める\nfrom math import sqrt\nn = int(input())\nps = [list(map(float, input().strip().split())) for i in range(n)]\n# print(ps)\n# Q: なぜ、最初にx座標についてソートされている必要があるのか？\n# A: 二つの区間が統合されるとき、dには2つの区間における最小２点間距離が入っており、\n#    統合された区間における最小値は、それ以下を探索するようになっている。\n#    この時、各区間A:[i, i+m), B:[i+m, n)での最小値は、\n#    [Aの任意の点]と[Bの任意の点]の距離は、境界(i+m-1とi+m)を除いてこの最小値以上であるという前提が成り立つ。\n#    そのため、統合された区間において探索するのはabs(dx - x) <= dのみを探索すれば良い。\n#    仮にxでソートされていない場合、上の前提が成り立たないため、統合しても結局全ての点で\n#    距離を計算しなくてはいけない。\nps.sort()\n# print(ps)\nINF = 10**9\n\n# cp_rec - 再帰用関数\n# 入力: 配列と区間\n# 出力: 距離と区間内の要素をY座標でソートした配列\ndef cp_rec(ps, i, n):\n    if n <= 1:\n        return INF, [ps[i]]\n    m = int(n/2)\n    x = ps[i+m][0] # 半分に分割した境界のX座標\n    # 配列を半分に分割して計算\n    d1, qs1 = cp_rec(ps, i, m)\n    d2, qs2 = cp_rec(ps, i+m, n-m)\n    d = min(d1, d2)\n    # Y座標が小さい順にmergeする\n    qs = [None]*n\n    s = t = idx = 0\n    while s < m and t < n-m:\n        if qs1[s][1] < qs2[t][1]:\n            qs[idx] = qs1[s]; s += 1\n        else:\n            qs[idx] = qs2[t]; t += 1\n        idx += 1\n    while s < m:\n        qs[idx] = qs1[s]; s += 1\n        idx += 1\n    while t < n-m:\n        qs[idx] = qs2[t]; t += 1\n        idx += 1\n    # 境界のX座標x(=ps[i+m][0])から距離がd以下のものについて距離を計算していく\n    # bは境界のX座標から距離d以下のものを集めたものが、Y座標の昇順に入っている。\n    b = []\n    for i in range(n):\n        ax, ay = q = qs[i]\n        if abs(ax - x) >= d:\n            continue\n        # Y座標について、qs[i]から距離がd以下のj(<i)について計算していく\n        for j in range(len(b)-1, -1, -1):\n            dx = ax - b[j][0]\n            dy = ay - b[j][1]\n            # このループは, ayとb[j][1]が近い順に取り出していいるため、\n            # 一度 dy >= 0となれば、あとは探索する必要はない。\n            if dy >= d: break\n            d = min(d, sqrt(dx**2 + dy**2))\n        b.append(q)\n    # dは、区間[i, i+n)における最小区間距離を指している。\n    # qsは[i, i+n)でY座標についてソートされている。\n    return d, qs\n\n# ps: ソートした二次元座標のlist\ndef closest_pair(ps):\n    n = len(ps)\n    return cp_rec(ps, 0, n)[0]\n\nprint(\"{:.09f}\".format(closest_pair(ps)))\n"
  },
  {
    "language": "Python",
    "code": "# #### CLOSEST PAIR O(N LOG N) ALGORITHM #### #\n# points should be unique, otherwise the closest pair would be the repeated points\n# also this will only find 1 pair with the smallest distance, in case there are multiple pairs with this same minimum distance\n\n#import time\n#start = time.time()\n\n\ndef dist(x, y): # for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n\treturn (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\n\t\ndef splitpair(px, py, d): # only need to return a value if closest pair is split between left and right halves\n\txBar = px[len(px)/2][0] # large x-coordinate of the left half of px\n\tSy = [] # Sy will be the set of points (sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n\tfor i in xrange(len(py)):\n\t\tif xBar-d**0.5 <= py[i][0] <= xBar+d**0.5: # only consider a 'strip' around xBar that is 2*sqrt(d) wide\n\t\t\tSy.append(py[i]) # if exists a pair with dist less than d, it must be in this strip (obvious)\t\n\t\n\tbestpair = None # the coords of the best pair of points so far\n\tbestD = d # the squared distance of the best pair of points\n\t# now iterate through Sy for points that aren't more than 7 apart\n\t# if a pair exists that is closer than dist d, it must be within 7 of each other\n\t# ask me for proof if you haven't seen this observation before it's pretty cool\n\tfor i in xrange(len(Sy)-2):\n\t\tfor j in xrange(1, min(8, len(Sy)-i-1)):  # 7 next points\n\t\t\tp, q = Sy[i], Sy[i+j]\n\t\t\t\n\t\t\tif dist(p, q) < bestD:\n\t\t\t\tbestpair = [p, q]\n\t\t\t\tbestD = dist(p, q)\n\t\t\t\t\n\treturn bestpair\n\t\ndef convert(p1, p2): # convert 2 points into two pairs of pairs, first sorted by x, other sorted by y\n\treturn [sorted([p1, p2]), sorted([p1, p2], key=lambda x: x[1])]\n\t\ndef solve(Px, Py): # where Px and Py are the points sorted by x and y coordinate respectively\n\t# this function returns two closest points\n\tif len(Px) == 2:\n\t\treturn (Px, Py)\n\telif len(Px) == 3: # 3 points, brute force\n\t\tp1, p2, p3 = [x for x in Px]\n\t\td12, d13, d23 = dist(p1, p2), dist(p1, p3), dist(p2, p3)\n\t\tif min(d12, d13, d23) == d12: \n\t\t\treturn convert(p1, p2)\n\t\telif min(d12, d13, d23) == d13: \n\t\t\treturn convert(p1, p3)\n\t\telse: \n\t\t\treturn convert(p2, p3)\n\telse:\n\t\t# split the left and right halves of all points (by x coord)\n\t\tL = len(Px)\n\t\tQx, Rx = Px[:L/2], Px[L/2:]\n\t\tQy, Ry = [], []\n\t\tk, l = Qx[-1][0], Qx[-1][1] # x and y coords of the rightmost element in Qx\n\t\tfor pt in Py: # this is linear time, you loop through Py exactly once.\n\t\t\t# need this in order \n\t\t\tif pt[0] < k:\n\t\t\t\tQy.append(pt)\n\t\t\telif pt[0] == k:\n\t\t\t\tif pt[1] <= l:\n\t\t\t\t\tQy.append(pt)\n\t\t\t\telse:\n\t\t\t\t\tRy.append(pt)\n\t\t\telse:\n\t\t\t\tRy.append(pt)\n\t\t\n\t\t# now use recursion. note ci is of the form [[x1,x2], [y1,y2]]\n\t\tc1 = solve(Qx, Qy) # find the closest pair in left half\n\t\tc2 = solve(Rx, Ry) # find the closest pair in the right half\n\t\t\n\t\tD = min(dist(c1[0][0], c1[0][1]), dist(c2[0][0], c2[0][1])) # get the min distance of both of these to solve split case\n\t\tif D == dist(c1[0][0], c1[0][1]):\n\t\t\tbestpair = c1\n\t\telif D == dist(c2[0][0], c2[0][1]):\n\t\t\tbestpair = c2\n\t\t\n\t\tc3 = splitpair(Px, Py, D) # find the closest split pair. this needs to be O(n) to get O(n log n) for entire algo\n\t\t\n\t\tif c3 is not None: \n\t\t\treturn convert(c3[0], c3[1])\n\t\telse:\n\t\t\treturn [bestpair[0], bestpair[1]] # else it's one of the c1 or c2\n\t\t\n\t\t\ndef main():\n\tN = int(raw_input().split()[0]) # N is number of points\n\tpts = [] # pairs of points, i.e pts = [[x1,y1], [x2,y2], ... , [xn,yn]]\n\t\n\t# get all pairs of points into our list\n\tfor i in xrange(N):\n\t\tpts.append([float(x) for x in raw_input().split()])\n\t\n\tPx = sorted(pts) # sort the pts by x coordinate\n\tPy = sorted(pts, key=lambda x: x[1]) # sort the pts by y coordinate\n\t\n\tres = solve(Px, Py) # keep one copy sorted by x coord, the other sorted by y coord to keep the split in half in linear time\n\t\n\tprint \"%.10f\" % (dist(res[0][0], res[0][1]) ** 0.5)\n\t\nif __name__ == '__main__':\n\tmain()\n\n\n#print \"%.2f %s\" % (((time.time() - start) * 1000), \"ms\")"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nClosest Pair\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=ja\nTLE\n\"\"\"\nimport sys\n\n\nfrom collections import deque\ndef closest_pair(points):\n    return find_closest(sorted(points)) ** 0.5\n\ndef find_closest(points):\n    n = len(points)\n    if n <= 1:\n        return float('inf')\n    m = n // 2\n    x = points[m][0]\n    d = min(find_closest(points[:m]),  find_closest(points[m:]))\n    points.sort(key=lambda p:p[1])\n    b = deque()\n    for p in points:\n        if (p[0] - x)**2 < d:\n            for q in b:\n                dx = p[0] - q[0]\n                dy = p[1] - q[1]\n                if dy**2 >= d:\n                    break\n                if (dx**2 + dy**2) < d:\n                    d = (dx**2 + dy**2)\n            b.appendleft(p)\n    return d\n\n\ndef main(args):\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(float, input().split())\n        points.append((x, y))\n    ans = closest_pair(sorted(points))\n    print('{:.10f}'.format(ans))\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nimport operator\nreadline = stdin.readline\n\n\ndef norm(self):\n    return abs(self)\n\n\ndef closest_pair(p):\n    m = 0\n    p.sort(key=operator.attrgetter('real'))\n    d = float('inf')\n    for i in range(1, len(p)):\n        for j in reversed(range(m, i)):\n            tmp = p[i] - p[j]\n            if d < tmp.real:\n                m = j + 1\n                break\n            tmp = abs(tmp)\n            if d > tmp:\n                d = tmp\n    return d\n\n\nfrom itertools import combinations\n\n\ndef brute_force(p):\n    return min(abs(p[i] - p[j]) for i, j in combinations(range(len(p)), 2))\n\n\n@profile\ndef main():\n    n = int(readline())\n    p = [map(float, readline().split()) for _ in range(n)]\n    p = [x + y * 1j for x, y in p]\n\n    # print('{:.6f}'.format(brute_force(p)))\n    print('{:.6f}'.format(closest_pair(p)))\nmain()"
  },
  {
    "language": "Python",
    "code": "import itertools\n\ndef _get_distance(p1, p2):\n    return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\ndef _get_min_distance(points):\n    min_d = 400\n    for p1, p2 in itertools.combinations(points, 2):\n        min_d = min(min_d, _get_distance(p1, p2))\n    return min_d\n\ndef closest_pair_distance(points):\n    n = len(points)\n    if n <= 3:\n        return _get_min_distance(points)\n    else:\n        mid = n // 2\n        px, py = zip(*points)\n        if len(set(px)) > len(set(py)):\n            points.sort(key = lambda p: p[0])\n            # axis: x; 0, y; 1\n            axis1 = 0\n            axis2 = 1\n        else:\n            points.sort(key = lambda p: p[1])\n            axis1 = 1\n            axis2 = 0\n        A_points = points[:mid]\n        B_points = points[mid:]\n        d_Amin = closest_pair_distance(A_points)\n        d_Bmin = closest_pair_distance(B_points)\n        dist = min(d_Amin, d_Bmin)\n        min_d = dist\n        for ap in A_points[::-1]:\n            if B_points[0][axis1] - ap[axis1] >= dist:\n                break\n            for bp in B_points:\n                if bp[axis1] - ap[axis1] >= dist:\n                    break\n                if ap[axis2] - dist < bp[axis2] < ap[axis2] + dist:\n                    min_d = min(min_d, _get_distance(ap, bp))\n        return min_d\n\n# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = int(file_input.readline())\n\nP = [tuple(map(float, line.split())) for line in file_input]\n\n# Solve\nans = closest_pair_distance(P)\n\nprint('{:f}'.format(ans))"
  },
  {
    "language": "Python",
    "code": "num_point = int(input())\npoint_list = [0] * num_point\nfor i in range(num_point):\n    line_split = input().split(\" \")\n    point_list[i] = [float(line_split[0]), float(line_split[1])]\n\nmin_sum_square = float(\"inf\")\nfor i in range(num_point):\n    for j in range(i + 1, num_point):\n        x_dif = point_list[i][0] - point_list[j][0]\n        y_dif = point_list[i][1] - point_list[j][1]\n        if x_dif < min_sum_square and y_dif < min_sum_square:\n            sum_square = x_dif**2 + y_dif**2\n            if sum_square < min_sum_square:\n                min_sum_square = sum_square\n        else:\n            continue\n\nmin_distance = min_sum_square**0.5\nprint(min_distance)"
  },
  {
    "language": "Python",
    "code": "# #### CLOSEST PAIR O(N LOG N) ALGORITHM #### #\n# points should be unique, otherwise the closest pair would be the repeated points\n# also this will only find 1 pair with the smallest distance, in case there are multiple pairs with this same minimum distance\n\n#import time\n#start = time.time()\n\n\t\ndef halve(coord): # split into two halves by x-coordinate\n\tL = len(coord) # luckily pts are already sorted\n\treturn [coord[:L/2], coord[L/2:]]\n\ndef dist(x, y): # for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n\treturn (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\n\t\ndef splitpair(px, py, d): # only need to return a correct value if closest pair is split\n\txBar = px[(len(px)+1)/2][0]\n\tSy = [] # Sy will be the set of points (sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n\tfor i in xrange(len(py)):\n\t\tif xBar-d**0.5 <= py[i][0] <= xBar+d**0.5: # only consider a 'strip' around xBar that is 2*sqrt(d) wide\n\t\t\tSy.append(py[i])\t\n\t\n\tbestpair = None # the coords of the best pair of points so far\n\tbestD = d # the squared distance of the best pair of points\n\t# now iterate through Sy for points that aren't more than 7 apart\n\tfor i in xrange(len(Sy)-2):\n\t\tfor j in xrange(1, min(8, len(Sy)-i-1)):  # 7 next points\n\t\t\tp, q = Sy[i], Sy[i+j]\n\t\t\tif isinstance(p[0], int) == False: print \"1\"\n\t\t\tif dist(p, q) < bestD:\n\t\t\t\tbestpair = [p, q]\n\t\t\t\tbestD = dist(p, q)\n\t\t\t\t\n\treturn bestpair\n\t\ndef convert(p1, p2): # convert 2 points into two pairs of pairs, first sorted by x, other sorted by y1\n\treturn [sorted([p1, p2]), sorted([p1, p2], key=lambda x: x[1])]\n\t\ndef solve(Px, Py): # where Px and Py are the points sorted by x and y coordinate respectively\n\t# this function returns two closest points\n\tassert len(Px) == len(Py) # make sure you have the same number of x and y coords\n\tif len(Px) == 2:\n\t\treturn (Px, Py)\n\telif len(Px) == 3: # 3 points, brute force\n\t\tp1, p2, p3 = [x for x in Px]\n\t\td12, d13, d23 = dist(p1, p2), dist(p1, p3), dist(p2, p3)\n\t\tif min(d12, d13, d23) == d12: \n\t\t\treturn convert(p1, p2)\n\t\telif min(d12, d13, d23) == d13: \n\t\t\treturn convert(p1, p3)\n\t\telse: \n\t\t\treturn convert(p2, p3)\n\telse:\n\t\tQx, Rx = [x for x in halve(Px)]\n\t\tQy, Ry = [], []\n\t\tfor pt in Py:\n\t\t\tif pt in Qx:\n\t\t\t\tQy.append(pt)\n\t\t\tif pt in Rx:\n\t\t\t\tRy.append(pt)\n\t\tassert len(Qx) == len(Qy)\n\t\tassert len(Rx) == len(Ry)\n\t\t\n\t\t# now use recursion. note ci is of the form [[x1,x2], [y1,y2]]\n\t\tc1 = solve(Qx, Qy) # find the closest pair in left half\n\t\tc2 = solve(Rx, Ry) # find the closest pair in the right half\n\t\t\n\t\tD = min(dist(c1[0][0], c1[0][1]), dist(c2[0][0], c2[0][1]))\n\t\tif D == dist(c1[0][0], c1[0][1]):\n\t\t\tbestpair = c1\n\t\telif D == dist(c2[0][0], c2[0][1]):\n\t\t\tbestpair = c2\n\t\t\n\t\tc3 = splitpair(Px, Py, D) # find the closest split pair. this needs to be O(n) to get O(n log n) for entire algo\n\t\t\n\t\tif c3 is not None: \n\t\t\treturn convert(c3[0], c3[1])\n\t\telse:\n\t\t\treturn bestpair # else it's one of the c1 or c2\n\t\t\n\t\t\ndef main():\n\tN = int(raw_input().split()[0]) # N is number of points\n\tassert  N >= 2\n\tpts = [] # pairs of points, i.e pts = [[x1,y1], [x2,y2], ... , [xn,yn]]\n\t\n\t# get all pairs of points into our list\n\tfor i in xrange(N):\n\t\tpts.append([float(x) for x in raw_input().split()])\n\t\t\n\t\n\tPx = sorted(pts) # sort the pts by x coordinate\n\tPy = sorted(pts, key=lambda x: x[1]) # sort the pts by y coordinate\n\t\n\tres = solve(Px, Py)\n\t\n\t'''\n\t# find the index of the points in pts\n\tfor i in xrange(len(pts)):\n\t\tif pts[i] == res[0][0]:\n\t\t\tind1 = i\n\t\telif pts[i] == res[0][1]:\n\t\t\tind2 = i\n\t\t\t\n\td = dist(pts[ind1], pts[ind2]) ** 0.5\n\t'''\n\t\n\tprint dist(res[0][0], res[0][1]) ** 0.5\n\nif __name__ == '__main__':\n\tmain()\n\n\n#print \"%.2f %s\" % (((time.time() - start) * 1000), \"ms\")"
  },
  {
    "language": "Python",
    "code": "# #### CLOSEST PAIR O(N LOG N) ALGORITHM #### #\n# points should be unique, otherwise the closest pair would be the repeated points\n# also this will only find 1 pair with the smallest distance, in case there are multiple pairs with this same minimum distance\n\n#import time\n#start = time.time()\n\n\ndef dist(x, y): # for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n\treturn (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\n\t\ndef splitpair(px, py, d): # only need to return a correct value if closest pair is split\n\txBar = px[(len(px)+1)/2][0] #x-coordinate of the leftmost element of px\n\tSy = [] # Sy will be the set of points (sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n\tfor i in xrange(len(py)):\n\t\tif xBar-d**0.5 <= py[i][0] <= xBar+d**0.5: # only consider a 'strip' around xBar that is 2*sqrt(d) wide\n\t\t\tSy.append(py[i])\t\n\t\n\tbestpair = None # the coords of the best pair of points so far\n\tbestD = d # the squared distance of the best pair of points\n\t# now iterate through Sy for points that aren't more than 7 apart\n\tfor i in xrange(len(Sy)-2):\n\t\tfor j in xrange(1, min(8, len(Sy)-i-1)):  # 7 next points\n\t\t\tp, q = Sy[i], Sy[i+j]\n\t\t\t\n\t\t\tif dist(p, q) < bestD:\n\t\t\t\tbestpair = [p, q]\n\t\t\t\tbestD = dist(p, q)\n\t\t\t\t\n\treturn bestpair\n\t\ndef convert(p1, p2): # convert 2 points into two pairs of pairs, first sorted by x, other sorted by y1\n\treturn [sorted([p1, p2]), sorted([p1, p2], key=lambda x: x[1])]\n\t\ndef solve(Px, Py): # where Px and Py are the points sorted by x and y coordinate respectively\n\t# this function returns two closest points\n\tassert len(Px) == len(Py) # make sure you have the same number of x and y coords\n\tif len(Px) == 2:\n\t\treturn (Px, Py)\n\telif len(Px) == 3: # 3 points, brute force\n\t\tp1, p2, p3 = [x for x in Px]\n\t\td12, d13, d23 = dist(p1, p2), dist(p1, p3), dist(p2, p3)\n\t\tif min(d12, d13, d23) == d12: \n\t\t\treturn convert(p1, p2)\n\t\telif min(d12, d13, d23) == d13: \n\t\t\treturn convert(p1, p3)\n\t\telse: \n\t\t\treturn convert(p2, p3)\n\telse:\n\t\tL = len(Px)\n\t\tQx, Rx = Px[:L/2], Px[L/2:]\n\t\tassert abs(len(Qx) - len(Rx)) <= 1\n\t\tQy, Ry = [], []\n\t\tk = Qx[-1][0] # x-coordinate of the rightmost element in Qx\n\t\tdump = []\n\t\tfor pt in Py: # this is linear time, you loop through Py exactly once\n\t\t\tif pt[0] < k and len(Qy) < len(Qx):\n\t\t\t\tQy.append(pt)\n\t\t\telif pt[0] == k: # if it's equal, keep track of these, then add back the correct number\n\t\t\t\tdump.append(pt)\n\t\t\telse:\n\t\t\t\tRy.append(pt)\n\t\t# now add back enough of the 'dump' list\n\t\tdiff = len(Qx) - len(Qy)\n\t\tfor d in dump[:diff]:\n\t\t\tQy.append(d)\n\t\tfor d in dump[diff:]:\n\t\t\tRy.append(d)\n\t\t\n\t\t# now use recursion. note ci is of the form [[x1,x2], [y1,y2]]\n\t\tif not sorted(Qx) == sorted(Qy):\n\t\t\tprint Qx\n\t\t\tprint Qy\n\t\tassert sorted(Rx) == sorted(Ry)\n\t\tc1 = solve(Qx, Qy) # find the closest pair in left half\n\t\tc2 = solve(Rx, Ry) # find the closest pair in the right half\n\t\t\n\t\tD = min(dist(c1[0][0], c1[0][1]), dist(c2[0][0], c2[0][1]))\n\t\tif D == dist(c1[0][0], c1[0][1]):\n\t\t\tbestpair = c1\n\t\telif D == dist(c2[0][0], c2[0][1]):\n\t\t\tbestpair = c2\n\t\t\n\t\tc3 = splitpair(Px, Py, D) # find the closest split pair. this needs to be O(n) to get O(n log n) for entire algo\n\t\t\n\t\tif c3 is not None: \n\t\t\treturn convert(c3[0], c3[1])\n\t\telse:\n\t\t\tassert sorted(bestpair[0]) == sorted(bestpair[1])\n\t\t\treturn [bestpair[0], bestpair[1]] # else it's one of the c1 or c2\n\t\t\n\t\t\ndef main():\n\tN = int(raw_input().split()[0]) # N is number of points\n\tassert  N >= 2\n\tpts = [] # pairs of points, i.e pts = [[x1,y1], [x2,y2], ... , [xn,yn]]\n\t\n\t# get all pairs of points into our list\n\tfor i in xrange(N):\n\t\tpts.append([float(x) for x in raw_input().split()])\n\t\t\n\t\n\tPx = sorted(pts) # sort the pts by x coordinate\n\tPy = sorted(pts, key=lambda x: x[1]) # sort the pts by y coordinate\n\t\n\tres = solve(Px, Py)\n\t\n\t'''\n\t# find the index of the points in pts\n\tfor i in xrange(len(pts)):\n\t\tif pts[i] == res[0][0]:\n\t\t\tind1 = i\n\t\telif pts[i] == res[0][1]:\n\t\t\tind2 = i\n\t\t\t\n\td = dist(pts[ind1], pts[ind2]) ** 0.5\n\t'''\n\t\n\tprint \"%.10f\" % (dist(res[0][0], res[0][1]) ** 0.5)\n\nif __name__ == '__main__':\n\tmain()\n\n\n#print \"%.2f %s\" % (((time.time() - start) * 1000), \"ms\")"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom operator import itemgetter\nfrom itertools import permutations\nfrom math import sqrt\n\ndef solve(a: list):\n    length = len(a)\n    if length <= 3:\n        return min(sqrt((p1[0]-p2[0])**2+(p1[1]-p2[1])**2) for p1, p2 in permutations(a, 2))\n\n    x_set_len = len(set(x for (x, _) in a))\n    axis = 0 if x_set_len > length/2 else 1\n    a.sort(key=itemgetter(axis))\n    mid_index = length//2\n    left, right = a[:mid_index], a[mid_index:]\n    delta = min(solve(left), solve(right))\n    median = a[mid_index][axis]\n    m_a = []\n        \n    for p in left[::-1]:\n        if p[axis] < median-delta:\n            break\n        m_a.append(p)\n    for p in right:\n        if p[axis] > median+delta:\n            break\n        m_a.append(p)\n    m_a.sort(key=itemgetter(not axis))\n\n    for i, p1 in enumerate(m_a):\n        ub = p1[not axis] + delta\n        for j, p2 in enumerate(m_a[i+1:]):\n            if p2[not axis] > ub:\n                break\n            delta = min(delta, sqrt((p1[0]-p2[0])**2+(p1[1]-p2[1])**2))\n\n    return delta\n\nif __name__ == \"__main__\":\n    N = int(input())\n    a = [tuple(map(float, l.split())) for l in sys.stdin.readlines()]\n    print(\"{:.10f}\".format(solve(a)))\n"
  },
  {
    "language": "Python",
    "code": "import math\nn = int(input())\np = []\nfor i in range(n):\n    p.append(tuple(map(float,input().split())))\nd = []\nmin = 999999999\nfor i in range(n-1):\n    for j in range(i+1,n):\n        if (math.sqrt((p[j][0]-p[i][0])**2+(p[j][1]-p[i][1])**2)) < min:\n            min = math.sqrt((p[j][0]-p[i][0])**2+(p[j][1]-p[i][1])**2)\n\nprint(round(min,11))"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\n\ndef solve(a: list):\n    length = len(a)\n    if length <= 3:\n        return min((p1[0]-p2[0])**2+(p1[1]-p2[1])**2 for p1, p2 in zip(a, a[1:]))\n\n    med = length//2\n    x_l, x_r = a[:med], a[med:]\n    delta = min(solve(x_l), solve(x_r))\n    median_x = a[med][0]\n    m_a = []\n        \n    for p in x_l[::-1]:\n        if p[0] < median_x-delta:\n            break\n        m_a.append(p)\n    m_a.reverse()\n    for p in x_r:\n        if p[0] > median_x+delta:\n            break\n        m_a.append(p)\n\n    for i, (x1, y1) in enumerate(m_a):\n        to_y = y1 + delta\n        for j, (x2, y2) in enumerate(m_a[i+1:]):\n            if y2 > to_y:\n                break\n            delta = min(delta, (x1-x2)**2+(y1-y2)**2)\n\n    return delta\n\nif __name__ == \"__main__\":\n    N = int(input())\n    m = 1000000\n    a = sorted([tuple(map(lambda s: int(float(s)*m), l.split())) for l in sys.stdin.readlines()])\n    print(\"{:f}\".format(math.sqrt(solve(a)/(m**2))))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nfile_input = sys.stdin\n\nn = file_input.readline()\n\ndef distance(s_p1, s_p2):\n    x1, y1 = map(float, s_p1.split())\n    x2, y2 = map(float, s_p2.split())\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\nimport itertools\n\nmin_d = 200\n\nfor p1, p2 in itertools.combinations(file_input, 2):\n    min_d = min(min_d, distance(p1, p2))\n\nprint('{:f}'.format(min_d))"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10000)\n\nfrom operator import attrgetter\nfrom itertools import combinations\n\nkeys = [attrgetter('real'), attrgetter('imag')]\n\n\ndef solve(points, axis):\n    l = len(points)\n    if l < 20:\n        return min(abs(p2 - p1) for p1, p2 in combinations(points, 2))\n    m = n // 2\n    pl, pr = points[:m], points[m:]\n    key, rkey = keys[axis], keys[not axis]\n    ans = min(solve(sorted(pl, key=rkey), not axis),\n              solve(sorted(pr, key=rkey), not axis))\n    pm = key(pr[0])\n    for p in reversed(pl):\n        if key(p) <= pm - ans:\n            break\n        for q in pr:\n            if key(q) >= pm + ans:\n                break\n            rp = rkey(p)\n            if rp - ans < rkey(q) < rp + ans:\n                ans = min(ans, abs(q - p))\n    return ans\n\n\nn = int(input())\npoints = [complex(*map(float, input().split())) for _ in range(n)]\nprint(solve(sorted(points, key=keys[0]), 0))"
  },
  {
    "language": "Python",
    "code": "import itertools\n\ndef _get_min_distance(points):\n    min_d = 400\n    for p1, p2 in itertools.combinations(points, 2):\n        min_d = min(min_d, abs(p1 - p2))\n    return min_d\n\ndef closest_pair_distance(points):\n    n = len(points)\n    if n <= 3:\n        return _get_min_distance(points)\n    else:\n        mid = n // 2\n        left_points = points[:mid]\n        right_points = points[mid:]\n        d_Lmin = closest_pair_distance(left_points)\n        d_Rmin = closest_pair_distance(right_points)\n        dist = min(d_Lmin, d_Rmin)\n        min_d = dist\n        for lp in left_points[::-1]:\n            if right_points[0].real - lp.real >= dist:\n                break\n            for rp in right_points:\n                if rp.real -lp.real >= dist:\n                    break\n                if lp.imag - dist < rp.imag < lp.imag + dist:\n                    min_d = min(min_d, abs(lp - rp))\n        return min_d\n\n# Acceptance of input\ndef string_to_complex(s):\n    x, y = map(float, s.split())\n    return x + y * 1j\n\nimport sys\n\nfile_input = sys.stdin\n\nn = int(file_input.readline())\n\nP = [string_to_complex(line) for line in file_input]\n\nP.sort(key = lambda c: c.real)\n\n# Output\nans = closest_pair_distance(P)\nprint('{:f}'.format(ans))"
  },
  {
    "language": "Python",
    "code": "from operator import attrgetter\nfrom itertools import combinations\n\nkeys = [attrgetter('real'), attrgetter('imag')]\n\n\ndef solve(points, axis):\n    l = len(points)\n    if l < 20:\n        return min(abs(p2 - p1) for p1, p2 in combinations(points, 2))\n    m = n // 2\n    pl, pr = points[:m], points[m:]\n    key, rkey = keys[axis], keys[not axis]\n    ans = min(solve(sorted(pl, key=rkey), not axis),\n              solve(sorted(pr, key=rkey), not axis))\n    pm = key(pr[0])\n    for p in reversed(pl):\n        if key(p) <= pm - ans:\n            break\n        for q in pr:\n            if key(q) >= pm + ans:\n                break\n            rp = rkey(p)\n            if rp - ans < rkey(q) < rp + ans:\n                ans = min(ans, abs(q - p))\n    return ans\n\n\nn = int(input())\npoints = [complex(*map(float, input().split())) for _ in range(n)]\nprint(solve(sorted(points, key=keys[0]), 0))"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nn = input()\nps = [map(float, raw_input().split()) for i in xrange(n)]\nps.sort()\nINF = 10**9\n\ndef cp_rec(ps, i, n):\n    if n <= 1:\n        return INF, [ps[i]]\n    m = n/2\n    x = ps[i+m][0]\n    d1, qs1 = cp_rec(ps, i, m)\n    d2, qs2 = cp_rec(ps, i+m, n-m)\n    d = min(d1, d2)\n    # merge\n    qs = [None]*n\n    s = t = idx = 0\n    while s < m and t < n-m:\n        if qs1[s][1] < qs2[t][1]:\n            qs[idx] = qs1[s]; s += 1\n        else:\n            qs[idx] = qs2[t]; t += 1\n        idx += 1\n    while s < m:\n        qs[idx] = qs1[s]; s += 1\n        idx += 1\n    while t < n-m:\n        qs[idx] = qs2[t]; t += 1\n        idx += 1\n    b = []\n    for i in xrange(n):\n        ax, ay = ps[i]\n        if abs(ax - x) >= d:\n            continue\n        for j in xrange(len(b)-1, -1, -1):\n            dx = ax - b[j][0]\n            dy = ay - b[j][1]\n            if dy >= d:\n                break\n            d = min(d, sqrt(dx**2 + dy**2))\n        b.append(ps[i])\n    return d, qs\ndef closest_pair(ps):\n    n = len(ps)\n    return cp_rec(ps, 0, n)[0]\nprint closest_pair(ps)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3\n0.0 0.0\n2.0 0.0\n1.0 1.0\n\noutput:\n1.41421356237\n\"\"\"\n\nimport sys\nfrom operator import attrgetter\n\n\nclass ClosestPair(object):\n    def __init__(self, ):\n        \"\"\"\n        Init closest pairs points set.\n        \"\"\"\n        _input = sys.stdin.readlines()\n        p_num = int(_input[0])\n        points = map(lambda x: x.split(), _input[1:])\n        p_list = [complex(float(x), float(y)) for x, y in points]\n        # pre_sort by axis_X\n        p_list.sort(key=attrgetter('real'))\n\n        ans = self.closest_pair(array=p_list, array_length=p_num)\n        print(('{:.6f}'.format(ans)))\n\n    def closest_pair(self, array, array_length):\n        if array_length <= 1:\n            return float('inf')\n        mid = array_length // 2\n        mid_real = array[mid].real\n        d = min(self.closest_pair(array[:mid], mid),\n                self.closest_pair(array[mid:], array_length - mid))\n\n        # sort by axis_Y while recursively solve d\n        array.sort(key=attrgetter('imag'))\n\n        min_stack = list()\n        for ele in array:\n            size = len(min_stack)\n\n            if abs(ele.real - mid_real) >= d:\n                continue\n\n            for j in range(size):\n                alt = ele - min_stack[size - j - 1]\n                if alt.imag >= d:\n                    break\n                d = min(d, abs(alt))\n\n            min_stack.append(ele)\n\n        return d\n\n\nif __name__ == '__main__':\n    case = ClosestPair()"
  },
  {
    "language": "Python",
    "code": "import math as m\nn = int(input())\np = []\nfor i in range(n):\n    p.append(tuple(map(float,input().split())))\nd = []\nmin = 999999999999\nfor i in range(n-1):\n    for j in range(i+1,n):\n        a = ((p[j][0]-p[i][0])**2+(p[j][1]-p[i][1])**2)\n        if a < min:\n            min = a\n\nprint(round(m.sqrt(min),11))"
  },
  {
    "language": "Python",
    "code": "from operator import attrgetter\nfrom itertools import combinations\n\nkeys = [attrgetter('real'), attrgetter('imag')]\n\n\ndef bound(points):\n    # xmx = max(p.real for p in points)\n    # xmn = min(p.real for p in points)\n    # ymx = max(p.imag for p in points)\n    # ymn = min(p.imag for p in points)\n    # return xmx - xmn < ymx - ymn\n    xs, ys = {p.real for p in points}, {p.imag for p in points}\n    return len(xs) < len(ys)\n\n\ndef solve(points, prev_sort):\n    l = len(points)\n    if l < 20:\n        return min(abs(p2 - p1) for p1, p2 in combinations(points, 2))\n    m = l // 2\n    pl, pr = points[:m], points[m:]\n    key, rkey = keys[prev_sort], keys[not prev_sort]\n    pl_next_sort, pr_next_sort = bound(pl), bound(pr)\n    pl_next_points = pl.copy() if prev_sort == pl_next_sort else sorted(pl, key=keys[pl_next_sort])\n    pr_next_points = pr.copy() if prev_sort == pr_next_sort else sorted(pr, key=keys[pr_next_sort])\n    ans = min(solve(pl_next_points, pl_next_sort), solve(pr_next_points, pr_next_sort))\n    pm = key(pr[0])\n    for p in reversed(pl):\n        if key(p) <= pm - ans:\n            break\n        for q in pr:\n            if key(q) >= pm + ans:\n                break\n            rp = rkey(p)\n            if rp - ans < rkey(q) < rp + ans:\n                ans = min(ans, abs(q - p))\n    return ans\n\n\nn = int(input())\npoints = [complex(*map(float, input().split())) for _ in range(n)]\nprint('{:.10f}'.format(solve(sorted(points, key=keys[0]), 0)))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nfrom operator import itemgetter\nfrom math import hypot\nfrom bisect import bisect_left, bisect_right\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nN=INT()\nA=[]\nfor i in range(N):\n    x,y=map(float, input().split())\n    A.append((i, x, y))\n\n# xでソート済とyでソート済を準備しておく\nAx=sorted(A, key=itemgetter(1))\nAy=sorted(A, key=itemgetter(2))\n\ndef find_min(li):\n    n=len(li)\n    mn=INF\n    for i in range(n):\n        for j in range(i+1, n):\n            _,x1,y1=li[i]\n            _,x2,y2=li[j]\n            mn=min(mn, hypot(x1-x2, y1-y2))\n    return mn\n\n# x方向のマージ用\ndef find_min2(mn, li1, li2):\n    # 二分探索用にy部分だけのリストを作っておく\n    li2b=[y for i, x, y in li2]\n    mn=INF\n    for i1, x1, y1 in li1:\n        s=bisect_left(li2b, y1-mn)\n        t=bisect_right(li2b, y1+mn)\n        # yが近い組だけやる\n        for i in range(s, t):\n            i2,x2,y2=li2[i]\n            # 同じ点はスキップする\n            if i1==i2: continue\n            mn=min(mn, hypot(x1-x2, y1-y2))\n    return mn\n\n# y方向のマージ用\ndef find_min3(mn, li1, li2):\n    li2b=[x for i, x, y in li2]\n    mn=INF\n    for i1, x1, y1 in li1:\n        s=bisect_left(li2b, x1-mn)\n        t=bisect_right(li2b, x1+mn)\n        for i in range(s, t):\n            i2,x2,y2=li2[i]\n            if i1==i2: continue\n            mn=min(mn, hypot(x1-x2, y1-y2))\n    return mn\n\ndef rec(lix, liy, d):\n    # 3つ以下になったら直接調べて返却\n    if len(lix)<=3:\n        return find_min(lix)\n    # x方向に半分にする\n    if d%2==0:\n        lix2=lix[:len(lix)//2]\n        lix3=lix[len(lix)//2:]\n        xset={x[0] for x in lix2}\n        liy2=[]\n        liy3=[]\n        # xに合わせてyも振り分ける\n        for i, x, y in liy:\n            if i in xset:\n                liy2.append((i, x, y))\n            else:\n                liy3.append((i, x, y))\n        # 前半分と後ろ半分の小さい方\n        mn=min(rec(lix2, liy2, d^1), rec(lix3, liy3, d^1))\n        # 境界線近くはまとめて直接調べる\n        midx=(lix2[-1][1]+lix3[0][1])/2\n        borders1=[]\n        borders2=[]\n        for i in range(len(lix)):\n            if midx-mn<=lix[i][1]<=midx+mn:\n                borders1.append(lix[i])\n            if midx-mn<=liy[i][1]<=midx+mn:\n                borders2.append(liy[i]) \n        mn=min(mn, find_min2(mn, borders1, borders2))\n        return mn\n    # y方向に半分にする(内容はほぼ同じ)\n    else:\n        liy2=liy[:len(liy)//2]\n        liy3=liy[len(liy)//2:]\n        yset={y[0] for y in liy2}\n        lix2=[]\n        lix3=[]\n        for i, x, y in lix:\n            if i in yset:\n                lix2.append((i, x, y))\n            else:\n                lix3.append((i, x, y))\n        mn=min(rec(lix2, liy2, d^1), rec(lix3, liy3, d^1))\n        midy=(liy2[-1][2]+liy3[0][2])/2\n        borders1=[]\n        borders2=[]\n        for i in range(len(liy)):\n            if midy-mn<=liy[i][1]<=midy+mn:\n                borders1.append(liy[i])\n            if midy-mn<=lix[i][1]<=midy+mn:\n                borders2.append(lix[i])\n        mn=min(mn, find_min3(mn, borders1, borders2))\n        return mn\n\nprint('{:.10f}'.format(rec(Ax, Ay, 0)))\n\n"
  },
  {
    "language": "Python",
    "code": "from operator import attrgetter\nfrom itertools import combinations\n\nkeys = [attrgetter('real'), attrgetter('imag')]\n\n\ndef solve(points, axis):\n    l = len(points)\n    if l < 20:\n        return min(abs(p2 - p1) for p1, p2 in combinations(points, 2))\n    m = l // 2\n    pl, pr = points[:m], points[m:]\n    key, rkey = keys[axis], keys[not axis]\n    ans = min(solve(sorted(pl, key=rkey), not axis),\n              solve(sorted(pr, key=rkey), not axis))\n    pm = key(pr[0])\n    for p in reversed(pl):\n        if key(p) <= pm - ans:\n            break\n        for q in pr:\n            if key(q) >= pm + ans:\n                break\n            rp = rkey(p)\n            if rp - ans < rkey(q) < rp + ans:\n                ans = min(ans, abs(q - p))\n    return ans\n\n\nn = int(input())\npoints = [complex(*map(float, input().split())) for _ in range(n)]\nprint('{:.10f}'.format(solve(sorted(points, key=keys[0]), 0)))"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom math import sqrt\n\ndef solve(a: list):\n    length = len(a)\n    if length <= 3:\n        return min(sqrt((p1[0]-p2[0])**2+(p1[1]-p2[1])**2) for p1, p2 in zip(a, a[1:]))\n\n    med = length//2\n    x_l, x_r = a[:med], a[med:]\n    delta = min(solve(x_l), solve(x_r))\n    median_x = a[med][0]\n    m_a = []\n        \n    for p in x_l[::-1]:\n        if p[0] < median_x-delta:\n            break\n        m_a.append(p)\n    m_a.reverse()\n    for p in x_r:\n        if p[0] > median_x+delta:\n            break\n        m_a.append(p)\n\n    for i, (x1, y1) in enumerate(m_a):\n        to_y = y1 + delta\n        for j, (x2, y2) in enumerate(m_a[i+1:]):\n            if y2 > to_y:\n                break\n            delta = min(delta, sqrt((x1-x2)**2+(y1-y2)**2))\n\n    return delta\n\nif __name__ == \"__main__\":\n    N = int(input())\n    a = sorted([tuple(map(float, l.split())) for l in sys.stdin.readlines()])\n    print(\"{:.10f}\".format(solve(a)))\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3\n0.0 0.0\n2.0 0.0\n1.0 1.0\n\noutput:\n1.41421356237\n\"\"\"\n\nimport sys\nfrom operator import attrgetter\n\n\nclass ClosestPair(object):\n    def __init__(self, in_data):\n        \"\"\"\n        Init closest pairs points set.\n        \"\"\"\n        self.p_num = int(in_data[0])\n        points = map(lambda x: x.split(), in_data[1:])\n        p_list = [complex(float(x), float(y)) for x, y in points]\n        # pre_sort by axis_X\n        self.p_list = sorted(p_list, key=attrgetter('real'))\n\n    def closest_pair(self, array, array_length):\n        if array_length <= 1:\n            return float('inf')\n        mid_idx = array_length // 2\n        div_line = array[mid_idx].real\n        d_min = min(self.closest_pair(array[:mid_idx], mid_idx),\n                    self.closest_pair(array[mid_idx:], array_length - mid_idx))\n\n        # sort array_part by axis_Y while recursively comparing\n        array.sort(key=attrgetter('imag'))\n\n        min_stack = list()\n        for ele in array:\n            size = len(min_stack)\n\n            # eliminate p which distance(p,div_line) >= d\n            if abs(ele.real - div_line) >= d_min:\n                continue\n\n            for j in range(size):\n                alt = ele - min_stack[size - j - 1]\n                if alt.imag >= d_min:\n                    break\n                d_min = min(d_min, abs(alt))\n\n            min_stack.append(ele)\n\n        return d_min\n\n    def solve(self):\n        return self.closest_pair(array=self.p_list, array_length=self.p_num)\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    case = ClosestPair(in_data=_input)\n    print('{:.6f}'.format(case.solve()))"
  },
  {
    "language": "Python",
    "code": "from operator import attrgetter\nfrom itertools import combinations\n\nkeys = [attrgetter('real'), attrgetter('imag')]\n\n\ndef solve(points, axis):\n    l = len(points)\n    if l < 20:\n        return min(abs(p2 - p1) for p1, p2 in combinations(points, 2))\n    m = l // 2\n    pl, pr = points[:m], points[m:]\n    key, rkey = keys[axis], keys[not axis]\n    ans = min(solve(sorted(pl, key=rkey), not axis),\n              solve(sorted(pr, key=rkey), not axis))\n    pm = key(pr[0])\n    for p in reversed(pl):\n        if key(p) <= pm - ans:\n            break\n        for q in pr:\n            if key(q) >= pm + ans:\n                break\n            rp = rkey(p)\n            if rp - ans < rkey(q) < rp + ans:\n                ans = min(ans, abs(q - p))\n    return ans\n\n\nn = int(input())\npoints = [complex(*map(float, input().split())) for _ in range(n)]\nprint(solve(sorted(points, key=keys[0]), 0))"
  },
  {
    "language": "Python",
    "code": "INF = 10**16\n\n# ソートしてから入れる\ndef ClosestDFS(Points):\n    l = len(Points)\n    if l <= 1: return INF, Points\n    d1, nearPoints1 = ClosestDFS(Points[:l//2])\n    d2, nearPoints2 = ClosestDFS(Points[l//2:])\n    retPoints = []\n    ind = 0\n    for p1x, p1y in nearPoints1:\n        while ind != len(nearPoints2) and nearPoints2[ind][1] < p1y:\n            retPoints.append(nearPoints2[ind])\n            ind += 1\n        retPoints.append((p1x, p1y))\n    while ind != len(nearPoints2):\n        retPoints.append(nearPoints2[ind])\n        ind += 1\n    \n    d = min(d1, d2)\n    B = []\n    border_x = Points[l//2][0]\n    for px, py in retPoints:\n        if abs(border_x-px) > d: continue\n        for bx, by in reversed(B):\n            if py - by > d: break\n            d = min(d, ((px-bx)**2+(py-by)**2)**0.5)\n        B.append((px, py))\n    return d, retPoints\n\ndef ClosestPair(Points):\n    Points.sort()\n    d, _ = ClosestDFS(Points)\n    return d\n\nimport sys\ninput = sys.stdin.readline\n\ndef main():\n    N = int(input())\n    Points = [list(map(float, input().split())) for _ in range(N)]\n    print(\"{:.8f}\".format(ClosestPair(Points)))\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nn = int(input())\np = []\nfor i in range(n):\n    p.append(tuple(map(float,input().split())))\nd = []\nmin = 999999999999\nfor i in range(n-1):\n    for j in range(i+1,n):\n        a = ((p[j][0]-p[i][0])**2+(p[j][1]-p[i][1])**2)\n        if a < min:\n            min = a\n\nprint(round(np.sqrt(min),11))"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\n\ndef solve(a: list):\n    length = len(a)\n    if length <= 3:\n        return min((p1[0]-p2[0])**2+(p1[1]-p2[1])**2 for p1, p2 in zip(a, a[1:]))\n\n    med = length//2\n    x_l, x_r = a[:med], a[med:]\n    delta = min(solve(x_l), solve(x_r))\n    median_x = a[med][0]\n    m_a = []\n        \n    for p in x_l[::-1]:\n        if p[0] < median_x-delta:\n            break\n        m_a.append(p)\n    m_a.reverse()\n    for p in x_r:\n        if p[0] > median_x+delta:\n            break\n        m_a.append(p)\n\n    for i, (x1, y1) in enumerate(m_a):\n        to_y = y1 + delta\n        for j, (x2, y2) in enumerate(m_a[i+1:]):\n            if y2 > to_y:\n                break\n            delta = min(delta, (x1-x2)**2+(y1-y2)**2)\n\n    return delta\n\nif __name__ == \"__main__\":\n    N = int(input())\n    a = sorted([tuple(map(float, l.split())) for l in sys.stdin.readlines()])\n    print(math.sqrt(solve(a)))\n"
  },
  {
    "language": "Python",
    "code": "# #### CLOSEST PAIR O(N LOG N) ALGORITHM #### #\n# points should be unique, otherwise the closest pair would be the repeated points\n# also this will only find 1 pair with the smallest distance, in case there are multiple pairs with this same minimum distance\n\n#import time\n#start = time.time()\n\n\t\ndef halve(coord): # split into two halves by x-coordinate\n\tL = len(coord) # luckily pts are already sorted\n\treturn [coord[:L/2], coord[L/2:]]\n\ndef dist(x, y): # for two points x(x0,x1) and y(y0,y1), what is the squared distance? \n\treturn (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\n\t\ndef splitpair(px, py, d): # only need to return a correct value if closest pair is split\n\txBar = px[(len(px)+1)/2][0]\n\tSy = [] # Sy will be the set of points (sorted by Y-coordinate) where the x-coord xi satisfies xBar-d <= xi <= xBar -d\n\tfor i in xrange(len(py)):\n\t\tif xBar-d**0.5 <= py[i][0] <= xBar+d**0.5: # only consider a 'strip' around xBar that is 2*sqrt(d) wide\n\t\t\tSy.append(py[i])\t\n\t\n\tbestpair = None # the coords of the best pair of points so far\n\tbestD = d # the squared distance of the best pair of points\n\t# now iterate through Sy for points that aren't more than 7 apart\n\tfor i in xrange(len(Sy)-2):\n\t\tfor j in xrange(1, min(8, len(Sy)-i-1)):  # 7 next points\n\t\t\tp, q = Sy[i], Sy[i+j]\n\t\t\t\n\t\t\tif dist(p, q) < bestD:\n\t\t\t\tbestpair = [p, q]\n\t\t\t\tbestD = dist(p, q)\n\t\t\t\t\n\treturn bestpair\n\t\ndef convert(p1, p2): # convert 2 points into two pairs of pairs, first sorted by x, other sorted by y1\n\treturn [sorted([p1, p2]), sorted([p1, p2], key=lambda x: x[1])]\n\t\ndef solve(Px, Py): # where Px and Py are the points sorted by x and y coordinate respectively\n\t# this function returns two closest points\n\tassert len(Px) == len(Py) # make sure you have the same number of x and y coords\n\tif len(Px) == 2:\n\t\treturn (Px, Py)\n\telif len(Px) == 3: # 3 points, brute force\n\t\tp1, p2, p3 = [x for x in Px]\n\t\td12, d13, d23 = dist(p1, p2), dist(p1, p3), dist(p2, p3)\n\t\tif min(d12, d13, d23) == d12: \n\t\t\treturn convert(p1, p2)\n\t\telif min(d12, d13, d23) == d13: \n\t\t\treturn convert(p1, p3)\n\t\telse: \n\t\t\treturn convert(p2, p3)\n\telse:\n\t\tQx, Rx = [x for x in halve(Px)]\n\t\tQy, Ry = [], []\n\t\tk = Qx[-1][0]\n\t\tfor pt in Py:\n\t\t\tif pt[0] <= k:\n\t\t\t\tQy.append(pt)\n\t\t\telse:\n\t\t\t\tRy.append(pt)\n\t\t\n\t\tassert len(Qx) == len(Qy)\n\t\tassert len(Rx) == len(Ry)\n\t\t\n\t\t# now use recursion. note ci is of the form [[x1,x2], [y1,y2]]\n\t\tc1 = solve(Qx, Qy) # find the closest pair in left half\n\t\tc2 = solve(Rx, Ry) # find the closest pair in the right half\n\t\t\n\t\tD = min(dist(c1[0][0], c1[0][1]), dist(c2[0][0], c2[0][1]))\n\t\tif D == dist(c1[0][0], c1[0][1]):\n\t\t\tbestpair = c1\n\t\telif D == dist(c2[0][0], c2[0][1]):\n\t\t\tbestpair = c2\n\t\t\n\t\tc3 = splitpair(Px, Py, D) # find the closest split pair. this needs to be O(n) to get O(n log n) for entire algo\n\t\t\n\t\tif c3 is not None: \n\t\t\treturn convert(c3[0], c3[1])\n\t\telse:\n\t\t\treturn bestpair # else it's one of the c1 or c2\n\t\t\n\t\t\ndef main():\n\tN = int(raw_input().split()[0]) # N is number of points\n\tassert  N >= 2\n\tpts = [] # pairs of points, i.e pts = [[x1,y1], [x2,y2], ... , [xn,yn]]\n\t\n\t# get all pairs of points into our list\n\tfor i in xrange(N):\n\t\tpts.append([float(x) for x in raw_input().split()])\n\t\t\n\t\n\tPx = sorted(pts) # sort the pts by x coordinate\n\tPy = sorted(pts, key=lambda x: x[1]) # sort the pts by y coordinate\n\t\n\tres = solve(Px, Py)\n\t\n\t'''\n\t# find the index of the points in pts\n\tfor i in xrange(len(pts)):\n\t\tif pts[i] == res[0][0]:\n\t\t\tind1 = i\n\t\telif pts[i] == res[0][1]:\n\t\t\tind2 = i\n\t\t\t\n\td = dist(pts[ind1], pts[ind2]) ** 0.5\n\t'''\n\t\n\tprint dist(res[0][0], res[0][1]) ** 0.5\n\nif __name__ == '__main__':\n\tmain()\n\n\n#print \"%.2f %s\" % (((time.time() - start) * 1000), \"ms\")"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom operator import itemgetter\nfrom itertools import permutations\nfrom math import sqrt\n\ndef solve(a: list):\n    length = len(a)\n    if length <= 3:\n        return min(sqrt((p1[0]-p2[0])**2+(p1[1]-p2[1])**2) for p1, p2 in permutations(a, 2))\n\n    x_set_len = len(set(x for (x, _) in a))\n    axis = 0 if x_set_len > length/2 else 1\n    a.sort(key=itemgetter(axis))\n    mid_index = length//2\n    left, right = a[:mid_index], a[mid_index:]\n    delta = min(solve(left), solve(right))\n    median = a[mid_index][axis]\n    m_a = []\n    append = m_a.append\n        \n    for p in left[::-1]:\n        if p[axis] < median-delta:\n            break\n        append(p)\n    for p in right:\n        if p[axis] > median+delta:\n            break\n        append(p)\n    m_a.sort(key=itemgetter(not axis))\n\n    for i, p1 in enumerate(m_a):\n        ub = p1[not axis] + delta\n        for j, p2 in enumerate(m_a[i+1:]):\n            if p2[not axis] > ub:\n                break\n            dist = sqrt((p1[0]-p2[0])**2+(p1[1]-p2[1])**2)\n            if dist < delta:\n                delta = dist\n\n    return delta\n\nif __name__ == \"__main__\":\n    N = int(input())\n    a = [tuple(map(float, l.split())) for l in sys.stdin.readlines()]\n    print(\"{:.10f}\".format(solve(a)))\n"
  },
  {
    "language": "Python",
    "code": "# CGL_5_A: Point Set - Closest Pair\n\nfrom operator import itemgetter\nfrom math import sqrt\n\n\ndef closest_distance(ps):\n    def split(i, j):\n        if j - i < 2:\n            return float('INF')\n        mid = (i + j) // 2\n        d = min(split(i, mid), split(mid, j))\n        lv, rv = ps[mid][0]-d, ps[mid][0]+d\n        return merge(sorted([p for p in ps[i:j] if lv <= p[0] <= rv],\n                            key=itemgetter(1)), d)\n\n    def merge(_ps, d):\n        n = len(_ps)\n        for i in range(n-1):\n            for j in range(i+1, n):\n                if d < _ps[j][1] - _ps[i][1]:\n                    break\n                d = min(d, distance(_ps[i], _ps[j]))\n\n        return d\n\n    ps.sort(key=itemgetter(0, 1))\n    return split(0, len(ps))\n\n\ndef dot(p0, p1):\n    x0, y0 = p0\n    x1, y1 = p1\n    return x0*x1 + y0*y1\n\n\ndef distance(p0, p1):\n    x0, y0 = p0\n    x1, y1 = p1\n    return sqrt((x1-x0)**2 + (y1-y0)**2)\n\n\ndef run():\n    n = int(input())\n    ps = []\n\n    for _ in range(n):\n        x, y = [float(i) for i in input().split()]\n        ps.append((x, y))\n\n    print(\"{:.10f}\".format(closest_distance(ps)))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom operator import itemgetter\nfrom itertools import combinations, takewhile\nfrom math import sqrt\n\ndef solve(a: list, sorted_axis: int = -1):\n    length = len(a)\n    if length <= 3:\n        return sqrt(min((x1-x2)**2+(y1-y2)**2 for (x1, y1), (x2, y2) in combinations(a, 2)))\n\n    x_set_len = len(set(x for x, _ in a))\n    axis1 = 0 if x_set_len > length/2 else 1\n\n    if sorted_axis != axis1:\n        a.sort(key=itemgetter(axis1))\n\n    mid_index = length//2\n    left, right = a[:mid_index], a[mid_index:]\n    delta = min(solve(left, axis1), solve(right, axis1))\n\n    axis2 = not axis1\n    median = a[mid_index][axis1]\n    mid_a = sorted([p for _iter in (\n        (takewhile(lambda p: median-delta < p[axis1], left[::-1])),\n        (takewhile(lambda p: p[axis1] < median+delta, right))\n    ) for p in _iter], key=itemgetter(axis2))\n\n    for i, (x1, y1) in enumerate(mid_a):\n        ub = (x1 if axis1 else y1) + delta\n        for x2, y2 in takewhile(lambda p: p[axis2] < ub, mid_a[i+1:]):\n            delta = min(delta, sqrt((x1-x2)**2+(y1-y2)**2))\n\n    return delta\n\nif __name__ == \"__main__\":\n    N = int(input())\n    a = [tuple(map(float, l.split())) for l in sys.stdin.readlines()]\n    print(\"{:.10f}\".format(solve(a)))\n"
  },
  {
    "language": "Python",
    "code": "import itertools\n\ndef _get_distance(p1, p2):\n    return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\ndef _get_min_distance(points):\n    min_d = 400\n    for p1, p2 in itertools.combinations(points, 2):\n        min_d = min(min_d, _get_distance(p1, p2))\n    return min_d\n\ndef closest_pair_distance(points, axis):\n    # axis: x; 0, y; 1\n    n = len(points)\n    if n <= 3:\n        return _get_min_distance(points)\n    else:\n        mid = n // 2\n        px, py = zip(*points)\n        if len(set(px)) > len(set(py)):\n            if axis:\n                points.sort(key = lambda p: p[0])\n            axis1 = 0\n            axis2 = 1\n        else:\n            if not axis:\n                points.sort(key = lambda p: p[1])\n            axis1 = 1\n            axis2 = 0\n        A_points = points[:mid]\n        B_points = points[mid:]\n        d_Amin = closest_pair_distance(A_points.copy(), axis1)\n        d_Bmin = closest_pair_distance(B_points.copy(), axis1)\n        dist = min(d_Amin, d_Bmin)\n        min_d = dist\n        for ap in A_points[::-1]:\n            if B_points[0][axis1] - ap[axis1] >= dist:\n                break\n            for bp in B_points:\n                if bp[axis1] - ap[axis1] >= dist:\n                    break\n                if ap[axis2] - dist < bp[axis2] < ap[axis2] + dist:\n                    min_d = min(min_d, _get_distance(ap, bp))\n        return min_d\n\n# Acceptance of input\nimport sys\n\nfile_input = sys.stdin\n\nn = int(file_input.readline())\n\nP = [tuple(map(float, line.split())) for line in file_input]\n\n# Solve\nP.sort(key = lambda p: p[0])\nans = closest_pair_distance(P, 0)\n\nprint('{:f}'.format(ans))"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = false;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\n#[derive(PartialEq, PartialOrd)]\n/// Implement Eq and Ord for a type which has only PartialEq and PartialOrd.\n/// It is useful when sorting a Vec of f64\npub struct Total<T>(pub T);\nimpl<T: PartialEq> Eq for Total<T> {}\nimpl<T: PartialOrd> Ord for Total<T> {\n    fn cmp(&self, other: &Total<T>) -> Ordering {\n        self.0.partial_cmp(&other.0).unwrap()\n    }\n}\n\nfn closest_pair(ps: &[(f64, f64)]) -> ((f64, f64), (f64, f64)) {\n    fn d(p1: (f64, f64), p2: (f64, f64)) -> f64 {\n        ((p1.0 - p2.0).powi(2) + (p1.1 - p2.1).powi(2)).sqrt()\n    }\n\n    fn rec(x_sort: &[(f64, f64)], y_sort: &[(f64, f64)]) -> ((f64, f64), (f64, f64)) {\n        if x_sort.len() <= 3 {\n            let mut min_d = std::f64::MAX;\n            let mut pair = ((0.0, 0.0), (0.0, 0.0));\n            for (i, &p1) in x_sort.iter().enumerate() {\n                for (j, &p2) in x_sort.iter().enumerate() {\n                    if i != j {\n                        let dist = d(p1, p2);\n                        if dist < min_d {\n                            min_d = dist;\n                            pair = (p1, p2);\n                        }\n                    }\n                }\n            }\n\n            return pair;\n        }\n\n        let mid = x_sort.len() / 2;\n        let pivot = x_sort[mid].0;\n\n        let q_x = &x_sort[..mid];\n        let r_x = &x_sort[mid..];\n\n        let mut q_y = Vec::with_capacity(mid);\n        let mut r_y = Vec::with_capacity(x_sort.len() - mid);\n\n        for &(x, y) in y_sort {\n            if x < pivot {\n                q_y.push((x, y));\n            } else {\n                r_y.push((x, y));\n            }\n        }\n\n        let pair1 = rec(q_x, &q_y);\n        let pair2 = rec(r_x, &r_y);\n\n        let w = d(pair1.0, pair1.1).min(d(pair2.0, pair2.1));\n        let s: Vec<(f64, f64)> = y_sort\n            .iter()\n            .filter(|&&(x, _)| (pivot - x).abs() <= w)\n            .cloned()\n            .collect();\n\n        let mut min_d = w;\n        let mut pair = if d(pair1.0, pair1.1) < d(pair2.0, pair2.1) {\n            pair1\n        } else {\n            pair2\n        };\n\n        for (i, &p1) in s.iter().enumerate() {\n            for &p2 in s[i + 1..].iter().take_while(|p2| p2.1 < p1.1 + w) {\n                let dist = d(p1, p2);\n                if dist < min_d {\n                    min_d = dist;\n                    pair = (p1, p2);\n                }\n            }\n        }\n        pair\n    }\n\n    let mut x_sort = ps.to_vec();\n    let mut y_sort = ps.to_vec();\n\n    x_sort.sort_by_key(|p| Total(p.0));\n    y_sort.sort_by_key(|p| Total(p.1));\n    rec(&x_sort, &y_sort)\n}\n\nfn solve() {\n    let n = get!(usize);\n    let ps = get!(f64, f64; n);\n\n    let ((a, b), (c, d)) = closest_pair(&ps);\n\n    println!(\"{}\", ((a - c).powi(2) + (b - d).powi(2)).sqrt());\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = false;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\n#[derive(PartialEq, PartialOrd)]\n/// Implement Eq and Ord for a type which has only PartialEq and PartialOrd.\n/// It is useful when sorting a Vec of f64\npub struct Total<T>(pub T);\nimpl<T: PartialEq> Eq for Total<T> {}\nimpl<T: PartialOrd> Ord for Total<T> {\n    fn cmp(&self, other: &Total<T>) -> Ordering {\n        self.0.partial_cmp(&other.0).unwrap()\n    }\n}\n\nfn closest_pair(ps: &[(f64, f64)]) -> ((f64, f64), (f64, f64)) {\n    fn d(p1: (f64, f64), p2: (f64, f64)) -> f64 {\n        ((p1.0 - p2.0).powi(2) + (p1.1 - p2.1).powi(2)).sqrt()\n    }\n\n    fn rec(x_sort: &[(f64, f64)], y_sort: &[(f64, f64)]) -> ((f64, f64), (f64, f64)) {\n        if x_sort.len() <= 3 {\n            let mut min_d = std::f64::MAX;\n            let mut pair = ((0.0, 0.0), (0.0, 0.0));\n            for (i, &p1) in x_sort.iter().enumerate() {\n                for (j, &p2) in x_sort.iter().enumerate() {\n                    if i != j {\n                        let dist = d(p1, p2);\n                        if dist < min_d {\n                            min_d = dist;\n                            pair = (p1, p2);\n                        }\n                    }\n                }\n            }\n\n            return pair;\n        }\n\n        let mid = x_sort.len() / 2;\n        let pivot = x_sort[mid].0;\n\n        let q_x = &x_sort[..mid];\n        let r_x = &x_sort[mid..];\n\n        let mut q_y = Vec::with_capacity(mid);\n        let mut r_y = Vec::with_capacity(x_sort.len() - mid);\n\n        for &(x, y) in y_sort {\n            if x < pivot {\n                q_y.push((x, y));\n            } else {\n                r_y.push((x, y));\n            }\n        }\n\n        let pair1 = rec(q_x, &q_y);\n        let pair2 = rec(r_x, &r_y);\n\n        let w = d(pair1.0, pair1.1).min(d(pair2.0, pair2.1));\n        let s: Vec<(f64, f64)> = y_sort\n            .iter()\n            .filter(|&&(x, _)| (pivot - x).abs() <= w)\n            .cloned()\n            .collect();\n\n        let mut min_d = w;\n        let mut pair = if d(pair1.0, pair1.1) < d(pair2.0, pair2.1) {\n            pair1\n        } else {\n            pair2\n        };\n\n        for (i, &p1) in s.iter().enumerate() {\n            for &p2 in s[i + 1..].iter().take(15) {\n                let dist = d(p1, p2);\n                if dist < min_d {\n                    min_d = dist;\n                    pair = (p1, p2);\n                }\n            }\n        }\n        pair\n    }\n\n    let mut x_sort = ps.to_vec();\n    let mut y_sort = ps.to_vec();\n\n    x_sort.sort_by_key(|p| Total(p.0));\n    y_sort.sort_by_key(|p| Total(p.1));\n    rec(&x_sort, &y_sort)\n}\n\nfn solve() {\n    let n = get!(usize);\n    let ps = get!(f64, f64; n);\n\n    let ((a, b), (c, d)) = closest_pair(&ps);\n\n    println!(\"{}\", ((a - c).powi(2) + (b - d).powi(2)).sqrt());\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = false;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\n#[derive(PartialEq, PartialOrd)]\n/// Implement Eq and Ord for a type which has only PartialEq and PartialOrd.\n/// It is useful when sorting a Vec of f64\npub struct Total<T>(pub T);\nimpl<T: PartialEq> Eq for Total<T> {}\nimpl<T: PartialOrd> Ord for Total<T> {\n    fn cmp(&self, other: &Total<T>) -> Ordering {\n        self.0.partial_cmp(&other.0).unwrap()\n    }\n}\n\nfn closest_pair(ps: &[(f64, f64)]) -> ((f64, f64), (f64, f64)) {\n    fn d(p1: (f64, f64), p2: (f64, f64)) -> f64 {\n        ((p1.0 - p2.0).powi(2) + (p1.1 - p2.1).powi(2)).sqrt()\n    }\n\n    fn rec(x_sort: &[(f64, f64)], y_sort: &[(f64, f64)]) -> ((f64, f64), (f64, f64)) {\n        if x_sort.len() <= 3 {\n            let mut min_d = std::f64::MAX;\n            let mut pair = ((0.0, 0.0), (0.0, 0.0));\n            for (i, &p1) in x_sort.iter().enumerate() {\n                for (j, &p2) in x_sort.iter().enumerate() {\n                    if i != j {\n                        let dist = d(p1, p2);\n                        if dist < min_d {\n                            min_d = dist;\n                            pair = (p1, p2);\n                        }\n                    }\n                }\n            }\n\n            return pair;\n        }\n\n        let mid = x_sort.len() / 2;\n        let pivot = x_sort[mid].0;\n\n        let q_x = &x_sort[..mid];\n        let r_x = &x_sort[mid..];\n\n        let mut q_y = Vec::with_capacity(mid);\n        let mut r_y = Vec::with_capacity(x_sort.len() - mid);\n\n        for &(x, y) in y_sort {\n            if x < pivot {\n                q_y.push((x, y));\n            } else {\n                r_y.push((x, y));\n            }\n        }\n\n        let pair1 = rec(q_x, &q_y);\n        let pair2 = rec(r_x, &r_y);\n\n        let w = d(pair1.0, pair1.1).min(d(pair2.0, pair2.1));\n        let s: Vec<(f64, f64)> = y_sort\n            .iter()\n            .filter(|&&(x, _)| (pivot - x).abs() <= w)\n            .cloned()\n            .collect();\n\n        let mut min_d = w;\n        let mut pair = if d(pair1.0, pair1.1) < d(pair2.0, pair2.1) {\n            pair1\n        } else {\n            pair2\n        };\n\n        for (i, &p1) in s.iter().enumerate() {\n            for &p2 in s[i + 1..].iter().take(15) {\n                let dist = d(p1, p2);\n                if dist < min_d {\n                    min_d = dist;\n                    pair = (p1, p2);\n                }\n            }\n        }\n        pair\n    }\n\n    let mut x_sort = ps.to_vec();\n    let mut y_sort = ps.to_vec();\n\n    x_sort.sort_by_key(|p| Total(p.0));\n    y_sort.sort_by_key(|p| Total(p.1));\n    rec(&x_sort, &y_sort)\n}\n\nfn solve() {\n    let n = get!(usize);\n    let ps = get!(f64, f64; n);\n\n    let ((a, b), (c, d)) = closest_pair(&ps);\n\n    println!(\"{}\", ((a - c).powi(2) + (b - d).powi(2)).sqrt());\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = false;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\n\n#[derive(PartialEq, PartialOrd)]\n/// Implement Eq and Ord for a type which has only PartialEq and PartialOrd.\n/// It is useful when sorting a Vec of f64\npub struct Total<T>(pub T);\nimpl<T: PartialEq> Eq for Total<T> {}\nimpl<T: PartialOrd> Ord for Total<T> {\n    fn cmp(&self, other: &Total<T>) -> Ordering {\n        self.0.partial_cmp(&other.0).unwrap()\n    }\n}\n\nfn closest_pair(ps: &[(f64, f64)]) -> ((f64, f64), (f64, f64)) {\n    fn d(p1: (f64, f64), p2: (f64, f64)) -> f64 {\n        ((p1.0 - p2.0).powi(2) + (p1.1 - p2.1).powi(2)).sqrt()\n    }\n\n    fn rec(x_sort: &[(f64, f64)], y_sort: &[(f64, f64)]) -> ((f64, f64), (f64, f64)) {\n        if x_sort.len() <= 3 {\n            let mut min_d = std::f64::MAX;\n            let mut pair = ((0.0, 0.0), (0.0, 0.0));\n            for (i, &p1) in x_sort.iter().enumerate() {\n                for (j, &p2) in x_sort.iter().enumerate() {\n                    if i != j {\n                        let dist = d(p1, p2);\n                        if dist < min_d {\n                            min_d = dist;\n                            pair = (p1, p2);\n                        }\n                    }\n                }\n            }\n\n            return pair;\n        }\n\n        let mid = x_sort.len() / 2;\n        let pivot = x_sort[mid].0;\n\n        let q_x = &x_sort[..mid];\n        let r_x = &x_sort[mid..];\n\n        let mut q_y = Vec::with_capacity(mid);\n        let mut r_y = Vec::with_capacity(x_sort.len() - mid);\n\n        for &(x, y) in y_sort {\n            if x < pivot {\n                q_y.push((x, y));\n            } else {\n                r_y.push((x, y));\n            }\n        }\n\n        let pair1 = rec(q_x, &q_y);\n        let pair2 = rec(r_x, &r_y);\n\n        let w = d(pair1.0, pair1.1).min(d(pair2.0, pair2.1));\n        let s: Vec<(f64, f64)> = y_sort\n            .iter()\n            .filter(|&&(x, _)| (pivot - x).abs() <= w)\n            .cloned()\n            .collect();\n\n        let mut min_d = w;\n        let mut pair = if d(pair1.0, pair1.1) < d(pair2.0, pair2.1) {\n            pair1\n        } else {\n            pair2\n        };\n\n        for (i, &p1) in s.iter().enumerate() {\n            for &p2 in s[i + 1..].iter().take_while(|p2| p2.1 < p1.1 + w) {\n                let dist = d(p1, p2);\n                if dist < min_d {\n                    min_d = dist;\n                    pair = (p1, p2);\n                }\n            }\n        }\n        pair\n    }\n\n    let mut x_sort = ps.to_vec();\n    let mut y_sort = ps.to_vec();\n\n    x_sort.sort_by_key(|p| Total(p.0));\n    y_sort.sort_by_key(|p| Total(p.1));\n    rec(&x_sort, &y_sort)\n}\n\nfn solve() {\n    let n = get!(usize);\n    let ps = get!(f64, f64; n);\n\n    let ((a, b), (c, d)) = closest_pair(&ps);\n\n    println!(\"{}\", ((a - c).powi(2) + (b - d).powi(2)).sqrt());\n}\n\n"
  }
]