[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int *stack;\n    int top;\n    int capacity;\n} Stack;\n\nStack* createStack(int capacity) {\n    Stack* stack = (Stack*)malloc(sizeof(Stack));\n    stack->capacity = capacity;\n    stack->top = -1;\n    stack->stack = (int*)malloc(capacity * sizeof(int));\n    return stack;\n}\n\nint isEmpty(Stack* stack) {\n    return stack->top == -1;\n}\n\nint isFull(Stack* stack) {\n    return stack->top == stack->capacity - 1;\n}\n\nvoid push(Stack* stack, int item) {\n    if (isFull(stack)) {\n        return;\n    }\n    stack->stack[++stack->top] = item;\n}\n\nint pop(Stack* stack) {\n    if (isEmpty(stack)) {\n        return -1;\n    }\n    return stack->stack[stack->top--];\n}\n\nint peek(Stack* stack) {\n    if (isEmpty(stack)) {\n        return -1;\n    }\n    return stack->stack[stack->top];\n}\n\nvoid freeStack(Stack* stack) {\n    free(stack->stack);\n    free(stack);\n}\n\nint minMovesToTarget(Stack* A, Stack* B, Stack* C, int n, int target) {\n    if (target != 0 && target != 2) {\n        return -1;\n    }\n    \n    Stack* trays[3] = {A, B, C};\n    int moves = 0;\n    int currentPos = 0; // 0: A, 1: B, 2: C\n    int direction = (target == 0) ? -1 : 1;\n    int expected = n;\n    \n    while (expected > 0) {\n        if (!isEmpty(trays[currentPos]) && peek(trays[currentPos]) == expected) {\n            pop(trays[currentPos]);\n            expected--;\n            moves++;\n        } else {\n            int nextPos = (currentPos + direction + 3) % 3;\n            if (isEmpty(trays[nextPos]) || (!isEmpty(trays[nextPos]) && peek(trays[nextPos]) < expected)) {\n                if (!isEmpty(trays[currentPos]) && (isEmpty(trays[nextPos]) || peek(trays[currentPos]) < peek(trays[nextPos]))) {\n                    int cup = pop(trays[currentPos]);\n                    push(trays[nextPos], cup);\n                    moves++;\n                } else {\n                    return -1;\n                }\n            }\n            currentPos = nextPos;\n        }\n    }\n    \n    return moves;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    \n    Stack* A = createStack(n);\n    Stack* B = createStack(n);\n    Stack* C = createStack(n);\n    \n    for (int i = n; i >= 1; i--) {\n        int tray;\n        scanf(\"%d\", &tray);\n        if (tray == 0) {\n            push(A, i);\n        } else if (tray == 1) {\n            push(B, i);\n        } else if (tray == 2) {\n            push(C, i);\n        }\n    }\n    \n    int movesA = minMovesToTarget(A, B, C, n, 0);\n    int movesC = minMovesToTarget(A, B, C, n, 2);\n    \n    int minMoves = INT_MAX;\n    if (movesA != -1 && movesA <= m) {\n        if (movesA < minMoves) {\n            minMoves = movesA;\n        }\n    }\n    if (movesC != -1 && movesC <= m) {\n        if (movesC < minMoves) {\n            minMoves = movesC;\n        }\n    }\n    \n    if (minMoves != INT_MAX) {\n        printf(\"%d\\n\", minMoves);\n    } else {\n        printf(\"-1\\n\");\n    }\n    \n    freeStack(A);\n    freeStack(B);\n    freeStack(C);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:46:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CupStacking {\n    public static int minimumMoves(int[] cups, int m) {\n        int n = cups.length;\n        List<Integer> A = new ArrayList<>();\n        List<Integer> B = new ArrayList<>();\n        List<Integer> C = new ArrayList<>();\n        \n        // Initial setup - all cups start on tray A\n        for (int cup : cups) {\n            A.add(cup);\n        }\n        \n        // Sort descending for tracking top cups\n        Collections.sort(A, Collections.reverseOrder());\n        \n        int moves = 0;\n        \n        while (moves <= m) {\n            // Check if all cups are on A or C\n            if (A.size() == n || C.size() == n) {\n                return moves;\n            }\n            \n            // Find the largest cup that can be moved\n            int largestA = A.isEmpty() ? -1 : A.get(0);\n            int largestB = B.isEmpty() ? -1 : B.get(0);\n            int largestC = C.isEmpty() ? -1 : C.get(0);\n            \n            // Try moving between A and B\n            if (!A.isEmpty() && (B.isEmpty() || largestA < largestB)) {\n                int cup = A.remove(0);\n                B.add(0, cup);\n                moves++;\n                continue;\n            }\n            \n            // Try moving between B and C\n            if (!B.isEmpty() && (C.isEmpty() || largestB < largestC)) {\n                int cup = B.remove(0);\n                C.add(0, cup);\n                moves++;\n                continue;\n            }\n            \n            // Try moving from C to B\n            if (!C.isEmpty() && (B.isEmpty() || largestC < largestB)) {\n                int cup = C.remove(0);\n                B.add(0, cup);\n                moves++;\n                continue;\n            }\n            \n            // Try moving from B to A\n            if (!B.isEmpty() && (A.isEmpty() || largestB < largestA)) {\n                int cup = B.remove(0);\n                A.add(0, cup);\n                moves++;\n                continue;\n            }\n            \n            // No valid move found\n            break;\n        }\n        \n        // Check final state\n        if (A.size() == n || C.size() == n) {\n            return moves;\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        int[] cups = {5, 3, 1, 4, 2};\n        int m = 10;\n        System.out.println(minimumMoves(cups, m));\n    }\n}",
    "timestamp": "2025-08-05 18:46:46"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct State {\n    vector<vector<int>> trays;\n    int moves;\n};\n\nstring stateToString(const State& state) {\n    string s;\n    for (const auto& tray : state.trays) {\n        for (int cup : tray) {\n            s += to_string(cup) + \",\";\n        }\n        s += \";\";\n    }\n    return s;\n}\n\nbool isGoal(const State& state, int n, int targetTray) {\n    return state.trays[targetTray].size() == n;\n}\n\nint solve(int n, int m) {\n    queue<State> q;\n    unordered_set<string> visited;\n\n    State initial;\n    initial.trays.resize(3);\n    for (int i = 1; i <= n; ++i) {\n        initial.trays[0].push_back(i);\n    }\n    initial.moves = 0;\n\n    q.push(initial);\n    visited.insert(stateToString(initial));\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        if (isGoal(current, n, 0) || isGoal(current, n, 2)) {\n            return current.moves;\n        }\n\n        if (current.moves >= m) {\n            continue;\n        }\n\n        for (int from = 0; from < 3; ++from) {\n            if (current.trays[from].empty()) continue;\n\n            for (int to = 0; to < 3; ++to) {\n                if (from == to) continue;\n                if (abs(from - to) != 1) continue; // Only adjacent trays\n\n                int cup = current.trays[from].back();\n                if (!current.trays[to].empty() && current.trays[to].back() < cup) continue; // Larger cup can't be placed on smaller\n\n                State next = current;\n                next.trays[from].pop_back();\n                next.trays[to].push_back(cup);\n                next.moves++;\n\n                string nextStr = stateToString(next);\n                if (visited.find(nextStr) == visited.end()) {\n                    visited.insert(nextStr);\n                    q.push(next);\n                }\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int result = solve(n, m);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:47:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CUPS 20\n\ntypedef struct {\n    int cups[MAX_CUPS];\n    int top;\n} Tray;\n\nbool is_valid_move(Tray *src, Tray *dest) {\n    if (src->top == -1) return false;\n    if (dest->top == -1) return true;\n    return src->cups[src->top] < dest->cups[dest->top];\n}\n\nint solve(int n, int m) {\n    Tray A = {.top = -1}, B = {.top = -1}, C = {.top = -1};\n    \n    for (int i = n - 1; i >= 0; i--) {\n        A.cups[++A.top] = i;\n    }\n    \n    int moves = 0;\n    while (moves < m) {\n        bool moved = false;\n        \n        // A to B\n        if (is_valid_move(&A, &B)) {\n            B.cups[++B.top] = A.cups[A.top--];\n            moves++;\n            moved = true;\n        }\n        // B to A\n        else if (is_valid_move(&B, &A)) {\n            A.cups[++A.top] = B.cups[B.top--];\n            moves++;\n            moved = true;\n        }\n        // B to C\n        else if (is_valid_move(&B, &C)) {\n            C.cups[++C.top] = B.cups[B.top--];\n            moves++;\n            moved = true;\n        }\n        // C to B\n        else if (is_valid_move(&C, &B)) {\n            B.cups[++B.top] = C.cups[C.top--];\n            moves++;\n            moved = true;\n        }\n        \n        if (!moved) break;\n        \n        // Check if all cups are on A or C\n        if ((A.top == n - 1 && A.top >= 0) || (C.top == n - 1 && C.top >= 0)) {\n            return moves;\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    printf(\"%d\\n\", solve(n, m));\n    return 0;\n}",
    "timestamp": "2025-08-05 18:47:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint solve(int n, int m) {\n    // If n cups, the minimum moves is always 2^n - 1\n    int minMoves = (1 << n) - 1;\n    \n    // If minimum moves exceeds allowed moves, return -1\n    if (minMoves > m) return -1;\n    \n    // If minimum moves is even and m is odd, or vice versa, return -1\n    if ((minMoves % 2 == 0 && m % 2 == 1) || \n        (minMoves % 2 == 1 && m % 2 == 0)) return -1;\n    \n    return minMoves;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    cout << solve(n, m) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:47:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CupStacking {\n    static class State {\n        Stack<Integer> A, B, C;\n        int moves;\n        boolean targetA;\n\n        State(Stack<Integer> A, Stack<Integer> B, Stack<Integer> C, int moves, boolean targetA) {\n            this.A = new Stack<>();\n            this.A.addAll(A);\n            this.B = new Stack<>();\n            this.B.addAll(B);\n            this.C = new Stack<>();\n            this.C.addAll(C);\n            this.moves = moves;\n            this.targetA = targetA;\n        }\n\n        boolean isGoal() {\n            if (targetA) {\n                return B.isEmpty() && C.isEmpty();\n            } else {\n                return A.isEmpty() && B.isEmpty();\n            }\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            State other = (State) obj;\n            return A.equals(other.A) && B.equals(other.B) && C.equals(other.C) && targetA == other.targetA;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(A, B, C, targetA);\n        }\n    }\n\n    public static int solve(int n, int[] initialA, int[] initialB, int[] initialC, int m) {\n        Stack<Integer> A = new Stack<>();\n        for (int i = initialA.length - 1; i >= 0; i--) {\n            A.push(initialA[i]);\n        }\n        Stack<Integer> B = new Stack<>();\n        for (int i = initialB.length - 1; i >= 0; i--) {\n            B.push(initialB[i]);\n        }\n        Stack<Integer> C = new Stack<>();\n        for (int i = initialC.length - 1; i >= 0; i--) {\n            C.push(initialC[i]);\n        }\n\n        Queue<State> queue = new LinkedList<>();\n        Set<State> visited = new HashSet<>();\n\n        State initialStateA = new State(A, B, C, 0, true);\n        State initialStateC = new State(A, B, C, 0, false);\n\n        queue.add(initialStateA);\n        queue.add(initialStateC);\n        visited.add(initialStateA);\n        visited.add(initialStateC);\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (current.isGoal()) {\n                return current.moves;\n            }\n\n            if (current.moves >= m) {\n                continue;\n            }\n\n            // Move from A to B\n            if (!current.A.isEmpty()) {\n                Stack<Integer> newA = new Stack<>();\n                newA.addAll(current.A);\n                Stack<Integer> newB = new Stack<>();\n                newB.addAll(current.B);\n                Stack<Integer> newC = new Stack<>();\n                newC.addAll(current.C);\n\n                int cup = newA.pop();\n                if (newB.isEmpty() || cup < newB.peek()) {\n                    newB.push(cup);\n                    State newState = new State(newA, newB, newC, current.moves + 1, current.targetA);\n                    if (!visited.contains(newState)) {\n                        visited.add(newState);\n                        queue.add(newState);\n                    }\n                }\n            }\n\n            // Move from B to A\n            if (!current.B.isEmpty()) {\n                Stack<Integer> newA = new Stack<>();\n                newA.addAll(current.A);\n                Stack<Integer> newB = new Stack<>();\n                newB.addAll(current.B);\n                Stack<Integer> newC = new Stack<>();\n                newC.addAll(current.C);\n\n                int cup = newB.pop();\n                if (newA.isEmpty() || cup < newA.peek()) {\n                    newA.push(cup);\n                    State newState = new State(newA, newB, newC, current.moves + 1, current.targetA);\n                    if (!visited.contains(newState)) {\n                        visited.add(newState);\n                        queue.add(newState);\n                    }\n                }\n            }\n\n            // Move from B to C\n            if (!current.B.isEmpty()) {\n                Stack<Integer> newA = new Stack<>();\n                newA.addAll(current.A);\n                Stack<Integer> newB = new Stack<>();\n                newB.addAll(current.B);\n                Stack<Integer> newC = new Stack<>();\n                newC.addAll(current.C);\n\n                int cup = newB.pop();\n                if (newC.isEmpty() || cup < newC.peek()) {\n                    newC.push(cup);\n                    State newState = new State(newA, newB, newC, current.moves + 1, current.targetA);\n                    if (!visited.contains(newState)) {\n                        visited.add(newState);\n                        queue.add(newState);\n                    }\n                }\n            }\n\n            // Move from C to B\n            if (!current.C.isEmpty()) {\n                Stack<Integer> newA = new Stack<>();\n                newA.addAll(current.A);\n                Stack<Integer> newB = new Stack<>();\n                newB.addAll(current.B);\n                Stack<Integer> newC = new Stack<>();\n                newC.addAll(current.C);\n\n                int cup = newC.pop();\n                if (newB.isEmpty() || cup < newB.peek()) {\n                    newB.push(cup);\n                    State newState = new State(newA, newB, newC, current.moves + 1, current.targetA);\n                    if (!visited.contains(newState)) {\n                        visited.add(newState);\n                        queue.add(newState);\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] initialA = new int[scanner.nextInt()];\n        for (int i = 0; i < initialA.length; i++) {\n            initialA[i] = scanner.nextInt();\n        }\n        int[] initialB = new int[scanner.nextInt()];\n        for (int i = 0; i < initialB.length; i++) {\n            initialB[i] = scanner.nextInt();\n        }\n        int[] initialC = new int[scanner.nextInt()];\n        for (int i = 0; i < initialC.length; i++) {\n            initialC[i] = scanner.nextInt();\n        }\n        int m = scanner.nextInt();\n        System.out.println(solve(n, initialA, initialB, initialC, m));\n    }\n}",
    "timestamp": "2025-08-05 18:48:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def move_cups(n, m):\n    # Calculate the theoretical minimum moves required using Tower of Hanoi concept\n    # Total moves to transfer all cups to A or C is 2^n - 1\n    required_moves = (2 ** n) - 1\n    \n    # Check if it's possible within m moves\n    if m < required_moves:\n        return -1\n    else:\n        return required_moves\n\n# Example usage\nn = 5  # Number of cups\nm = 31  # Maximum allowed moves\nprint(move_cups(n, m))  # Output: 31",
    "timestamp": "2025-08-13 00:52:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "public class CupStacking {\n\n    public static void main(String[] args) {\n        int n = 3; // number of cups\n        int m = 7; // maximum number of moves allowed\n        int result = minMoves(n, m);\n        System.out.println(result);\n    }\n    \n    public static int minMoves(int n, int maxMoves) {\n        int totalMoves = (int) Math.pow(2, n) - 1;\n        if (totalMoves <= maxMoves) {\n            return totalMoves;\n        } else {\n            return -1;\n        }\n    }\n}",
    "timestamp": "2025-08-13 00:53:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nint hanoi(int n, char from_rod, char to_rod, char aux_rod) {\n    if (n == 1) return 1;\n    return hanoi(n-1, from_rod, aux_rod, to_rod) + 1 + hanoi(n-1, aux_rod, to_rod, from_rod);\n}\n\nint minimumMoves(int n, int m) {\n    if (n <= 0) return -1;\n    int total_moves_to_B = hanoi(n, 'A', 'B', 'C');\n    int total_moves_to_C = hanoi(n, 'B', 'C', 'A');\n    int total_moves_A_to_C = total_moves_to_B + total_moves_to_C;\n\n    if (total_moves_A_to_C > m) return -1;\n    return total_moves_A_to_C;\n}\n\nint main() {\n    int n, m;\n    printf(\"Enter number of cups (n): \");\n    scanf(\"%d\", &n);\n    printf(\"Enter maximum number of moves allowed (m): \");\n    scanf(\"%d\", &m);\n\n    int result = minimumMoves(n, m);\n    printf(\"Minimum number of moves required: %d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 00:53:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_cup_stacking(n, m):\n    def is_valid_move(source, target, cups):\n        return (not target or source[-1] < target[-1])\n\n    def dfs(a, b, c, moves_left):\n        if moves_left < 0:\n            return float('inf')\n        \n        if len(a) == n or len(c) == n:\n            return m - moves_left\n        \n        best = float('inf')\n        \n        # A to B\n        if a and is_valid_move(a, b, b):\n            new_a, new_b, new_c = a.copy(), b.copy(), c.copy()\n            cup = new_a.pop()\n            new_b.append(cup)\n            best = min(best, dfs(new_a, new_b, new_c, moves_left - 1))\n        \n        # B to A\n        if b and is_valid_move(b, a, a):\n            new_a, new_b, new_c = a.copy(), b.copy(), c.copy()\n            cup = new_b.pop()\n            new_a.append(cup)\n            best = min(best, dfs(new_a, new_b, new_c, moves_left - 1))\n        \n        # B to C\n        if b and is_valid_move(b, c, c):\n            new_a, new_b, new_c = a.copy(), b.copy(), c.copy()\n            cup = new_b.pop()\n            new_c.append(cup)\n            best = min(best, dfs(new_a, new_b, new_c, moves_left - 1))\n        \n        # C to B\n        if c and is_valid_move(c, b, b):\n            new_a, new_b, new_c = a.copy(), b.copy(), c.copy()\n            cup = new_c.pop()\n            new_b.append(cup)\n            best = min(best, dfs(new_a, new_b, new_c, moves_left - 1))\n        \n        return best\n    \n    initial_stack = list(range(1, n+1))\n    result = dfs(initial_stack, [], [], m)\n    \n    return result if result != float('inf') else -1\n\n# Example usage\nn, m = map(int, input().split())\nprint(solve_cup_stacking(n, m))",
    "timestamp": "2025-08-13 00:53:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    from collections import deque\n\n    n, m = map(int, sys.stdin.readline().split())\n    trays = [ [], [], [] ]\n    for i in range(3):\n        parts = list(map(int, sys.stdin.readline().split()))\n        k = parts[0]\n        if k > 0:\n            trays[i] = parts[1:]\n    \n    target_A = list(range(1, n+1))\n    target_C = list(range(1, n+1))\n    \n    visited = set()\n    queue = deque()\n    initial_state = (tuple(tuple(cup) for cup in trays), 0)\n    queue.append(initial_state)\n    visited.add(initial_state[0])\n    \n    found = -1\n    while queue:\n        current_trays, moves = queue.popleft()\n        if list(current_trays[0]) == target_A or list(current_trays[2]) == target_C:\n            found = moves\n            break\n        if moves >= m:\n            continue\n        \n        for src in range(3):\n            for dest in range(3):\n                if src == dest:\n                    continue\n                if (src == 0 and dest == 2) or (src == 2 and dest == 0):\n                    continue\n                if not current_trays[src]:\n                    continue\n                src_cups = list(current_trays[src])\n                dest_cups = list(current_trays[dest])\n                if dest_cups and src_cups[-1] > dest_cups[-1]:\n                    continue\n                new_src = src_cups[:-1]\n                new_dest = dest_cups + [src_cups[-1]]\n                new_trays = list(current_trays)\n                new_trays[src] = tuple(new_src)\n                new_trays[dest] = tuple(new_dest)\n                new_state = (tuple(new_trays), moves + 1)\n                if tuple(new_trays) not in visited:\n                    visited.add(tuple(new_trays))\n                    queue.append(new_state)\n    \n    print(found if found != -1 and found <= m else -1)\n\nsolve()",
    "timestamp": "2025-08-13 00:53:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint HanoiWithMiddleTray(int n, int m) {\n    int moves = 0;\n    int largestPowerOfThree = 1;\n    vector<int> powerOfThrees = {1}; // Power of Three sequence up to 3^19 (just to ensure we cover the typical problem constraints)\n\n    for (int i = 1; i <= 19; i++) {\n        largestPowerOfThree *= 3;\n        powerOfThrees.push_back(largestPowerOfThree);\n    }\n\n    for (int i = n; i > 0; i--) {\n        moves += 2 * powerOfThrees[i - 1];\n        if (moves > m) {\n            return -1;\n        }\n    }\n    return moves;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int result = HanoiWithMiddleTray(n, m);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:56:36"
  }
]