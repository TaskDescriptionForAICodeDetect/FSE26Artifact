[
  {
    "language": "Scala",
    "code": "object Main {\n  def main(args : Array[String]) {\n    recursive\n  }\n  def recursive : Unit = {\n    var args = readLine.split(\" \").map(_.toInt)\n    while (args(0) + args(1) != 0) {\n      val a = toSeqList(readLine.split(\" \").map(s => new Cup(s.toInt)).toList.tail)\n      val b = toSeqList(readLine.split(\" \").map(s => new Cup(s.toInt)).toList.tail)\n      val c = toSeqList(readLine.split(\" \").map(s => new Cup(s.toInt)).toList.tail)\n      val min = minStep(a, b, c)\n      if (args(1) >= min) {\n        println(min)\n      } else {\n        println(-1)\n      }\n      args = readLine.split(\" \").map(_.toInt)\n    }\n  }\n  implicit def boolToInt(b : Boolean) : Int = { if (b) 1 else 0 }\n  def getOrder[T <% Ordered[T]](a : T, b : T, c : T) = {\n    ((a > b) + (a > c), (b > a) + (b > c), (c > a) + (c > b))\n  }\n  def toSeqList(list : List[Cup], result : List[Cup] = List[Cup](new Stage)) : List[Cup] = {\n    list match {\n      case Nil => result\n      case first :: rest =>\n        if (first ^ result.head)\n          toSeqList(rest, (first + result.head) :: result.tail)\n        else\n          toSeqList(rest, first :: result)\n      case _ => throw new Exception\n    }\n  }\n  def xor(a : Boolean, b : Boolean) : Boolean = !(a == b)\n  def subOneStep3(a : List[Cup], b : List[Cup], c : List[Cup]) = {\n    getOrder(a.head, b.head, c.head) match {\n      case (0, 1, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, c.head.moveCost * (if (xor((c.tail.head > a.head), (c.head.parity == b.head.parity))) 1 else -1))\n      case (2, 1, 0) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, a.head.moveCost * (if (xor((a.tail.head > c.head), (a.head.parity == b.head.parity))) 1 else -1))\n      case (1, 2, 0) =>\n        ((b.head + a.head) :: a.tail, b.tail, c, b.head.moveCost * (if (xor((b.tail.head > c.head), (b.head.parity == a.head.parity))) 1 else -1))\n      case (0, 2, 1) =>\n        (a, b.tail, (b.head + c.head) :: c.tail, b.head.moveCost * (if (xor((b.tail.head > a.head), (b.head.parity == c.head.parity))) 1 else -1))\n      case (1, 0, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, -c.head.moveCost)\n      case (2, 0, 1) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, -a.head.moveCost)\n      case _ => throw (new Exception)\n    }\n  }\n  def subOneStep2(a : List[Cup], b : List[Cup], c : List[Cup]) = {\n    getOrder(a.head, b.head, c.head) match {\n      case (0, 1, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, -c.head.moveCost)\n      case (2, 1, 0) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, -a.head.moveCost)\n      case (1, 2, 0) =>\n        ((b.head + a.head) :: a.tail, b.tail, c, b.head.moveCost * (if (b.size == 2) 1 else -1))\n      case (0, 2, 1) =>\n        (a, b.tail, (b.head + c.head) :: c.tail, b.head.moveCost * (if (b.size == 2) 1 else -1))\n      case (1, 0, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, -c.head.moveCost)\n      case (2, 0, 1) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, -a.head.moveCost)\n      case _ => throw (new Exception)\n    }\n  }\n  def minStep(a : List[Cup], b : List[Cup], c : List[Cup], step : Int = 0) : Int = {\n    ((a.size > 1) + (b.size > 1) + (c.size > 1)) match {\n      case 3 =>\n        val tuple = subOneStep3(a, b, c)\n        minStep(tuple._1, tuple._2, tuple._3, step + tuple._4)\n      case 2 =>\n        val tuple = subOneStep2(a, b, c)\n        minStep(tuple._1, tuple._2, tuple._3, step + tuple._4)\n      case 1 if (b.size > 1) =>\n        step + b.head.moveCost\n      case 1 =>\n        step\n      case _ => throw (new Exception)\n    }\n  }\n\n}\nclass Cup(val bottom : Int, val top : Int) extends Ordered[Cup] {\n  def this(s : Int) = this(s, s)\n  lazy val size = top - bottom + 1\n  def compare(that : Cup) : Int = this.bottom - that.bottom\n  def +(other : Cup) : Cup = {\n    (this < other) match {\n      case true  => new Cup(bottom, other.top)\n      case false => new Cup(other.bottom, top)\n    }\n  }\n  lazy val moveCost = (pow(top - bottom + 1, 1) - 1) / 2\n  private lazy val pow : (Int, Int) => Int = (n, r) => {\n    n match {\n      case 0 => r\n      case _ => pow(n - 1, 3 * r)\n    }\n  }\n  def ^(other : Cup) : Boolean = (((other.bottom + 1) == top) || ((bottom + 1) == other.top))\n  lazy val parity = bottom % 2\n}\nclass Stage extends Cup(-1, -1) {\n  override def ^(other : Cup) : Boolean = false\n}"
  },
  {
    "language": "Scala",
    "code": "object AOLCup {\n  import scala.io.StdIn.{ readLine }\n  def main(args : Array[String]) = {\n    sub()\n  }\n  def sub(args:Array[Int] = readLine.split(\" \").map(_.toInt)) {\n    if ((args(0) != 0) || (args(1) != 0)){\n      val list = sort(readLine.split(\" \").toList.map(x => new Cup(x.toInt, 0, args(0))).tail ::: readLine.split(\" \").toList.map(x => new Cup(x.toInt, 1, args(0))).tail ::: readLine.split(\" \").toList.map(x => new Cup(x.toInt, 2, args(0))).tail)\n      val minStep = list.head.Pile match {\n        case 1 =>\n          min(moveEnd(list, 0), moveEnd(list, 2))\n        case t : Int =>\n          moveEnd(list, t)\n      }\n      if (minStep < args(1)) {\n        println(minStep)\n      } else {\n        println(-1)\n      }\n      sub()\n    }\n  }\n  def min(a : Int, b : Int) : Int = if (a > b) b else a\n  def moveEnd(list : List[Cup], target : Int) : Int = {\n    list match {\n      case Nil => 0\n      case first :: rest =>\n        first match {\n          case x @ Cup(_, t, _) if (t == target) =>\n            moveEnd(rest, target)\n          case x @ Cup(_, 1, _) =>\n            moveEnd(rest, 2 - target) + x.moveCost * 2+ 1\n          case x : Cup =>\n            moveEnd(rest, target) + x.moveCost * 4 + 2\n        }\n    }\n  }\n  def insertSort(factor : Cup, list : List[Cup]) : List[Cup] = {\n    list match {\n      case Nil => List[Cup](factor)\n      case first :: rest =>\n        if (first < factor) {\n          first :: insertSort(factor, rest)\n        } else {\n          factor :: list\n        }\n    }\n  }\n  def sort(ramlist : List[Cup], re : List[Cup] = Nil) : List[Cup] = {\n    ramlist match {\n      case Nil => re\n      case first :: rest =>\n        sort(rest, insertSort(first, re))\n    }\n  }\n\n}\ncase class Cup(val Size : Int, val Pile : Int, val whole : Int) extends Ordered[Cup] {\n  def compare(other : Cup) = Size - other.Size\n  def moveCost : Int = {\n    def pow(e : Int, r : Int = 1) : Int = {\n      e match {\n        case 0 => r\n        case _ => pow(e - 1, 3 * r)\n      }\n    }\n    (pow(whole - Size) - 1) / 2\n  }\n  override val toString = s\"--Size = ${Size}, Pile = ${Pile}--\"\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nimport util.control.Breaks._\n\nobject Main extends App {\n  case class State(a: Int, b: Int, c: Int)\n  val cache = mutable.HashMap.empty[Int, Int]\n  val stateCache = mutable.HashMap.empty[State, Boolean]\n  def head (b: Int, n: Int): Int = cache.getOrElseUpdate(b, {\n    var h = 1 << n-1\n    breakable {\n      while (h > 0) {\n        if ((h & b) == h) break()\n        h = h >> 1\n      }\n    }\n    h\n  })\n  def readLine: Array[Int] = io.StdIn.readLine().split(' ').map(_.toInt)\n  def solver(n: Int, m: Int): Unit = {\n    val Array(_, as @ _*) = readLine\n    val Array(_, bs @ _*) = readLine\n    val Array(_, cs @ _*) = readLine\n    val queue = mutable.Queue.empty[(State, Int)]\n    val state: Array[Int] = for (x <- Array(as,bs,cs)) yield x.foldLeft(0)((acc, i) => acc | (1 << i - 1))\n    queue.enqueue((State(state(0), state(1), state(2)), 0))\n    var count = -1\n    val goal = (1 << n) - 1\n    def enq(ns: State, nc: Int): Unit =\n      if (!stateCache.getOrElseUpdate(ns, false)) {queue.enqueue((ns, nc)); stateCache += (ns -> true)}\n\n    breakable {\n      while (queue.nonEmpty) {\n        val (s, c) = queue.dequeue()\n\n        if (c > m) break()\n        if (s.a == goal || s.c == goal) {count = c; break()}\n\n        val (h0, h1, h2) = (head(s.a, n), head(s.b, n), head(s.c, n))\n\n        if (h0 > h1) enq(State(s.a ^ h0, h0 | s.b, s.c),c+1)\n        else if (h1 > h0) enq(State(h1 | s.a, s.b ^ h1, s.c), c+1)\n        if (h1 > h2) enq(State(s.a, s.b ^ h1, h1 | s.c), c+1)\n        else if (h2 > h1) enq(State(s.a, h2 | s.b, s.c ^ h2), c+1)\n      }\n    }\n    println(count)\n  }\n  breakable(\n    while(true) {\n      val Array(n, m) = readLine\n      if (n == 0 || m == 0) break()\n      else solver(n, m)\n    }\n  )\n}\n"
  },
  {
    "language": "Scala",
    "code": "object Main {\n  import scala.io.StdIn.{ readLine }\n  def main(args : Array[String]) = {\n    sub()\n  }\n  def sub(args : Array[Int] = readLine.split(\" \").map(_.toInt)) {\n    if ((args(0) != 0) || (args(1) != 0)) {\n      val list = sort(readLine.split(\" \").toList.map(x => new Cup(x.toInt, 0, args(0))).tail ::: readLine.split(\" \").toList.map(x => new Cup(x.toInt, 1, args(0))).tail ::: readLine.split(\" \").toList.map(x => new Cup(x.toInt, 2, args(0))).tail)\n      val minStep = list.head.Pile match {\n        case 1 =>\n          min(moveEnd(list, 0), moveEnd(list, 2))\n        case t : Int =>\n          moveEnd(list, t)\n      }\n      if (minStep < args(1)) {\n        println(minStep)\n      } else {\n        println(-1)\n      }\n      sub()\n    }\n  }\n  def min(a : Int, b : Int) : Int = if (a > b) b else a\n  def moveEnd(list : List[Cup], target : Int) : Int = {\n    list match {\n      case Nil => 0\n      case first :: rest =>\n        first match {\n          case x @ Cup(_, t, _) if (t == target) =>\n            moveEnd(rest, target)\n          case x @ Cup(_, 1, _) =>\n            moveEnd(rest, 2 - target) + x.moveCost * 2 + 1\n          case x : Cup =>\n            moveEnd(rest, target) + x.moveCost * 4 + 2\n        }\n    }\n  }\n  def insertSort(factor : Cup, list : List[Cup]) : List[Cup] = {\n    list match {\n      case Nil => List[Cup](factor)\n      case first :: rest =>\n        if (first < factor) {\n          first :: insertSort(factor, rest)\n        } else {\n          factor :: list\n        }\n    }\n  }\n  def sort(ramlist : List[Cup], re : List[Cup] = Nil) : List[Cup] = {\n    ramlist match {\n      case Nil => re\n      case first :: rest =>\n        sort(rest, insertSort(first, re))\n    }\n  }\n}\ncase class Cup(val Size : Int, val Pile : Int, val whole : Int) extends Ordered[Cup] {\n  def compare(other : Cup) = Size - other.Size\n  def moveCost : Int = {\n    def pow(e : Int, r : Int = 1) : Int = {\n      e match {\n        case 0 => r\n        case _ => pow(e - 1, 3 * r)\n      }\n    }\n    (pow(whole - Size) - 1) / 2\n  }\n  override val toString = s\"--Size = ${Size}, Pile = ${Pile}--\"\n}"
  },
  {
    "language": "Scala",
    "code": "object Main {\n  def main(args : Array[String]) {\n    recursive\n  }\n  def recursive : Unit = {\n    val args = readLine.split(\" \").map(_.toInt)\n    if (args(0) + args(1) != 0) {\n      val a = toSeqList(readLine.split(\" \").map(s => new Cup(s.toInt)).toList.tail)\n      val b = toSeqList(readLine.split(\" \").map(s => new Cup(s.toInt)).toList.tail)\n      val c = toSeqList(readLine.split(\" \").map(s => new Cup(s.toInt)).toList.tail)\n      val min = minStep(a, b, c)\n      if (args(1) >= min) {\n        println(min)\n      } else {\n        println(-1)\n      }\n      recursive\n    }\n  }\n  implicit def boolToInt(b : Boolean) : Int = { if (b) 1 else 0 }\n  def getOrder[T <% Ordered[T]](a : T, b : T, c : T) = {\n    ((a > b) + (a > c), (b > a) + (b > c), (c > a) + (c > b))\n  }\n  def toSeqList(list : List[Cup], result : List[Cup] = List[Cup](new Stage)) : List[Cup] = {\n    list match {\n      case Nil => result\n      case first :: rest =>\n        if (first ^ result.head)\n          toSeqList(rest, (first + result.head) :: result.tail)\n        else\n          toSeqList(rest, first :: result)\n      case _ => throw new Exception\n    }\n  }\n  def xor(a : Boolean, b : Boolean) : Boolean = !(a == b)\n  def subOneStep3(a : List[Cup], b : List[Cup], c : List[Cup]) = {\n    getOrder(a.head, b.head, c.head) match {\n      case (0, 1, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, c.head.moveCost * (if (xor((c.tail.head > a.head), (c.head.parity == b.head.parity))) 1 else -1))\n      case (2, 1, 0) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, a.head.moveCost * (if (xor((a.tail.head > c.head), (a.head.parity == b.head.parity))) 1 else -1))\n      case (1, 2, 0) =>\n        ((b.head + a.head) :: a.tail, b.tail, c, b.head.moveCost * (if (xor((b.tail.head > c.head), (b.head.parity == a.head.parity))) 1 else -1))\n      case (0, 2, 1) =>\n        (a, b.tail, (b.head + c.head) :: c.tail, b.head.moveCost * (if (xor((b.tail.head > a.head), (b.head.parity == c.head.parity))) 1 else -1))\n      case (1, 0, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, -c.head.moveCost)\n      case (2, 0, 1) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, -a.head.moveCost)\n      case _ => throw (new Exception)\n    }\n  }\n  def subOneStep2(a : List[Cup], b : List[Cup], c : List[Cup]) = {\n    getOrder(a.head, b.head, c.head) match {\n      case (0, 1, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, -c.head.moveCost)\n      case (2, 1, 0) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, -a.head.moveCost)\n      case (1, 2, 0) =>\n        ((b.head + a.head) :: a.tail, b.tail, c, b.head.moveCost * (if (b.size == 2) 1 else -1))\n      case (0, 2, 1) =>\n        (a, b.tail, (b.head + c.head) :: c.tail, b.head.moveCost * (if (b.size == 2) 1 else -1))\n      case (1, 0, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, -c.head.moveCost)\n      case (2, 0, 1) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, -a.head.moveCost)\n      case _ => throw (new Exception)\n    }\n  }\n  def minStep(a : List[Cup], b : List[Cup], c : List[Cup], step : Int = 0) : Int = {\n    ((a.size > 1) + (b.size > 1) + (c.size > 1)) match {\n      case 3 =>\n        val tuple = subOneStep3(a, b, c)\n        minStep(tuple._1, tuple._2, tuple._3, step + tuple._4)\n      case 2 =>\n        val tuple = subOneStep2(a, b, c)\n        minStep(tuple._1, tuple._2, tuple._3, step + tuple._4)\n      case 1 if (b.size > 1) =>\n        step + b.head.moveCost\n      case 1 =>\n        step\n      case _ => throw (new Exception)\n    }\n  }\n\n}\nclass Cup(val bottom : Int, val top : Int) extends Ordered[Cup] {\n  def this(s : Int) = this(s, s)\n  lazy val size = top - bottom + 1\n  def compare(that : Cup) : Int = this.bottom - that.bottom\n  def +(other : Cup) : Cup = {\n    (this < other) match {\n      case true  => new Cup(bottom, other.top)\n      case false => new Cup(other.bottom, top)\n    }\n  }\n  lazy val moveCost = (pow(top - bottom + 1, 1) - 1) / 2\n  private lazy val pow : (Int, Int) => Int = (n, r) => {\n    n match {\n      case 0 => r\n      case _ => pow(n - 1, 3 * r)\n    }\n  }\n  def ^(other : Cup) : Boolean = (((other.bottom + 1) == top) || ((bottom + 1) == other.top))\n  lazy val parity = bottom % 2\n}\nclass Stage extends Cup(-1, -1) {\n  override def ^(other : Cup) : Boolean = false\n}"
  },
  {
    "language": "Scala",
    "code": "object Main {\n  import scala.io.StdIn.{ readLine }\n  import scala.language.implicitConversions\n  def main(args : Array[String]) {\n    recursive\n  }\n  def recursive : Unit = {\n    var args = readLine.split(\" \").map(_.toInt)\n    while (args(0) + args(1) != 0) {\n      val a = toSeqList(readLine.split(\" \").map(s => new Cup(s.toInt)).toList.tail)\n      val b = toSeqList(readLine.split(\" \").map(s => new Cup(s.toInt)).toList.tail)\n      val c = toSeqList(readLine.split(\" \").map(s => new Cup(s.toInt)).toList.tail)\n      val min = minStep(a, b, c)\n      if (args(1) >= min) {\n        println(min)\n      } else {\n        println(-1)\n      }\n      args = readLine.split(\" \").map(_.toInt)\n    }\n  }\n  implicit def bool2int(b:Boolean) = if (b) 1 else 0\n  def getOrder(a : Cup, b : Cup, c : Cup) = {\n    ((a > b) + (a > c), (b > a) + (b > c), (c > a) + (c > b))\n  }\n  def toSeqList(list : List[Cup], result : List[Cup] = List[Cup](new Stage)) : List[Cup] = {\n    list match {\n      case Nil => result\n      case first :: rest =>\n        if (first ^ result.head)\n          toSeqList(rest, (first + result.head) :: result.tail)\n        else\n          toSeqList(rest, first :: result)\n      case _ => throw new Exception\n    }\n  }\n  def xor(a : Boolean, b : Boolean) : Boolean = !(a == b)\n  def subOneStep3(a : List[Cup], b : List[Cup], c : List[Cup]) = {\n    getOrder(a.head, b.head, c.head) match {\n      case (0, 1, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, c.head.moveCost * (if (xor((c.tail.head > a.head), (c.head.parity == b.head.parity))) 1 else -1))\n      case (2, 1, 0) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, a.head.moveCost * (if (xor((a.tail.head > c.head), (a.head.parity == b.head.parity))) 1 else -1))\n      case (1, 2, 0) =>\n        ((b.head + a.head) :: a.tail, b.tail, c, b.head.moveCost * (if (xor((b.tail.head > c.head), (b.head.parity == a.head.parity))) 1 else -1))\n      case (0, 2, 1) =>\n        (a, b.tail, (b.head + c.head) :: c.tail, b.head.moveCost * (if (xor((b.tail.head > a.head), (b.head.parity == c.head.parity))) 1 else -1))\n      case (1, 0, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, -c.head.moveCost)\n      case (2, 0, 1) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, -a.head.moveCost)\n      case _ => throw (new Exception)\n    }\n  }\n  def subOneStep2(a : List[Cup], b : List[Cup], c : List[Cup]) = {\n    getOrder(a.head, b.head, c.head) match {\n      case (0, 1, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, -c.head.moveCost)\n      case (2, 1, 0) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, -a.head.moveCost)\n      case (1, 2, 0) =>\n        ((b.head + a.head) :: a.tail, b.tail, c, b.head.moveCost * (if (b.size == 2) 1 else -1))\n      case (0, 2, 1) =>\n        (a, b.tail, (b.head + c.head) :: c.tail, b.head.moveCost * (if (b.size == 2) 1 else -1))\n      case (1, 0, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, -c.head.moveCost)\n      case (2, 0, 1) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, -a.head.moveCost)\n      case _ => throw (new Exception)\n    }\n  }\n  def minStep(a : List[Cup], b : List[Cup], c : List[Cup], step : Int = 0) : Int = {\n    ((a.size > 1) + (b.size > 1) + (c.size > 1)) match {\n      case 3 =>\n        val tuple = subOneStep3(a, b, c)\n        minStep(tuple._1, tuple._2, tuple._3, step + tuple._4)\n      case 2 =>\n        val tuple = subOneStep2(a, b, c)\n        minStep(tuple._1, tuple._2, tuple._3, step + tuple._4)\n      case 1 if (b.size > 1) =>\n        step + b.head.moveCost\n      case 1 =>\n        step\n      case _ => throw (new Exception)\n    }\n  }\n\n}\nclass Cup(val bottom : Int, val top : Int) extends Ordered[Cup] {\n  def this(s : Int) = this(s, s)\n  lazy val size = top - bottom + 1\n  override def compare(that : Cup) : Int = this.bottom - that.bottom\n  def +(other : Cup) : Cup = {\n    (this < other) match {\n      case true  => new Cup(bottom, other.top)\n      case false => new Cup(other.bottom, top)\n    }\n  }\n  lazy val moveCost = (pow(top - bottom + 1, 1) - 1) / 2\n  private lazy val pow : (Int, Int) => Int = (n, r) => {\n    n match {\n      case 0 => r\n      case _ => pow(n - 1, 3 * r)\n    }\n  }\n  def ^(other : Cup) : Boolean = (((other.bottom + 1) == top) || ((bottom + 1) == other.top))\n  lazy val parity = bottom % 2\n}\nclass Stage extends Cup(-1, -1) {\n  override def ^(other : Cup) : Boolean = false\n}"
  },
  {
    "language": "Scala",
    "code": "object Main {\n  import scala.io.StdIn.{ readLine }\n  import scala.language.implicitConversions.{_}\n  def main(args : Array[String]) {\n    recursive\n  }\n  def recursive : Unit = {\n    var args = readLine.split(\" \").map(_.toInt)\n    while (args(0) + args(1) != 0) {\n      val a = toSeqList(readLine.split(\" \").map(s => new Cup(s.toInt)).toList.tail)\n      val b = toSeqList(readLine.split(\" \").map(s => new Cup(s.toInt)).toList.tail)\n      val c = toSeqList(readLine.split(\" \").map(s => new Cup(s.toInt)).toList.tail)\n      val min = minStep(a, b, c)\n      if (args(1) >= min) {\n        println(min)\n      } else {\n        println(-1)\n      }\n      args = readLine.split(\" \").map(_.toInt)\n    }\n  }\n  //implicit def boolToInt(b : Boolean) : Int = { if (b) 1 else 0 }\n  def getOrder(a : Cup, b : Cup, c : Cup) = {\n    ((a > b) + (a > c), (b > a) + (b > c), (c > a) + (c > b))\n  }\n  def toSeqList(list : List[Cup], result : List[Cup] = List[Cup](new Stage)) : List[Cup] = {\n    list match {\n      case Nil => result\n      case first :: rest =>\n        if (first ^ result.head)\n          toSeqList(rest, (first + result.head) :: result.tail)\n        else\n          toSeqList(rest, first :: result)\n      case _ => throw new Exception\n    }\n  }\n  def xor(a : Boolean, b : Boolean) : Boolean = !(a == b)\n  def subOneStep3(a : List[Cup], b : List[Cup], c : List[Cup]) = {\n    getOrder(a.head, b.head, c.head) match {\n      case (0, 1, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, c.head.moveCost * (if (xor((c.tail.head > a.head), (c.head.parity == b.head.parity))) 1 else -1))\n      case (2, 1, 0) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, a.head.moveCost * (if (xor((a.tail.head > c.head), (a.head.parity == b.head.parity))) 1 else -1))\n      case (1, 2, 0) =>\n        ((b.head + a.head) :: a.tail, b.tail, c, b.head.moveCost * (if (xor((b.tail.head > c.head), (b.head.parity == a.head.parity))) 1 else -1))\n      case (0, 2, 1) =>\n        (a, b.tail, (b.head + c.head) :: c.tail, b.head.moveCost * (if (xor((b.tail.head > a.head), (b.head.parity == c.head.parity))) 1 else -1))\n      case (1, 0, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, -c.head.moveCost)\n      case (2, 0, 1) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, -a.head.moveCost)\n      case _ => throw (new Exception)\n    }\n  }\n  def subOneStep2(a : List[Cup], b : List[Cup], c : List[Cup]) = {\n    getOrder(a.head, b.head, c.head) match {\n      case (0, 1, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, -c.head.moveCost)\n      case (2, 1, 0) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, -a.head.moveCost)\n      case (1, 2, 0) =>\n        ((b.head + a.head) :: a.tail, b.tail, c, b.head.moveCost * (if (b.size == 2) 1 else -1))\n      case (0, 2, 1) =>\n        (a, b.tail, (b.head + c.head) :: c.tail, b.head.moveCost * (if (b.size == 2) 1 else -1))\n      case (1, 0, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, -c.head.moveCost)\n      case (2, 0, 1) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, -a.head.moveCost)\n      case _ => throw (new Exception)\n    }\n  }\n  def minStep(a : List[Cup], b : List[Cup], c : List[Cup], step : Int = 0) : Int = {\n    ((a.size > 1) + (b.size > 1) + (c.size > 1)) match {\n      case 3 =>\n        val tuple = subOneStep3(a, b, c)\n        minStep(tuple._1, tuple._2, tuple._3, step + tuple._4)\n      case 2 =>\n        val tuple = subOneStep2(a, b, c)\n        minStep(tuple._1, tuple._2, tuple._3, step + tuple._4)\n      case 1 if (b.size > 1) =>\n        step + b.head.moveCost\n      case 1 =>\n        step\n      case _ => throw (new Exception)\n    }\n  }\n\n}\nclass Cup(val bottom : Int, val top : Int) extends Ordered[Cup] {\n  def this(s : Int) = this(s, s)\n  lazy val size = top - bottom + 1\n  override def compare(that : Cup) : Int = this.bottom - that.bottom\n  def +(other : Cup) : Cup = {\n    (this < other) match {\n      case true  => new Cup(bottom, other.top)\n      case false => new Cup(other.bottom, top)\n    }\n  }\n  lazy val moveCost = (pow(top - bottom + 1, 1) - 1) / 2\n  private lazy val pow : (Int, Int) => Int = (n, r) => {\n    n match {\n      case 0 => r\n      case _ => pow(n - 1, 3 * r)\n    }\n  }\n  def ^(other : Cup) : Boolean = (((other.bottom + 1) == top) || ((bottom + 1) == other.top))\n  lazy val parity = bottom % 2\n}\nclass Stage extends Cup(-1, -1) {\n  override def ^(other : Cup) : Boolean = false\n}"
  },
  {
    "language": "Scala",
    "code": "object Main {\n  import scala.io.StdIn.{ readLine }\n  import scala.language.implicitConversions\n  def main(args : Array[String]) {\n    recursive\n  }\n  def recursive : Unit = {\n    var args = readLine.split(\" \").map(_.toInt)\n    while (args(0) + args(1) != 0) {\n      val a = toSeqList(readLine.split(\" \").map(s => new Cup(s.toInt)).toList.tail)\n      val b = toSeqList(readLine.split(\" \").map(s => new Cup(s.toInt)).toList.tail)\n      val c = toSeqList(readLine.split(\" \").map(s => new Cup(s.toInt)).toList.tail)\n      val min = minStep(a, b, c)\n      if (args(1) >= min) {\n        println(min)\n      } else {\n        println(-1)\n      }\n      args = readLine.split(\" \").map(_.toInt)\n    }\n  }\n  implicit def bool2int(b:Boolean) = if (b) 1 else 0\n  def getOrder(a : Cup, b : Cup, c : Cup) = {\n    ((a > b) + (a > c), (b > a) + (b > c), (c > a) + (c > b))\n  }\n  def toSeqList(list : List[Cup], result : List[Cup] = List[Cup](new Stage)) : List[Cup] = {\n    list match {\n      case Nil => result\n      case first :: rest =>\n        if (first ^ result.head)\n          toSeqList(rest, (first + result.head) :: result.tail)\n        else\n          toSeqList(rest, first :: result)\n      case _ => throw new Exception\n    }\n  }\n  def xor(a : Boolean, b : Boolean) : Boolean = !(a == b)\n  def subOneStep3(a : List[Cup], b : List[Cup], c : List[Cup]) = {\n    getOrder(a.head, b.head, c.head) match {\n      case (0, 1, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, c.head.moveCost * (if (xor((c.tail.head > a.head), (c.head.parity == b.head.parity))) 1 else -1))\n      case (2, 1, 0) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, a.head.moveCost * (if (xor((a.tail.head > c.head), (a.head.parity == b.head.parity))) 1 else -1))\n      case (1, 2, 0) =>\n        ((b.head + a.head) :: a.tail, b.tail, c, b.head.moveCost * (if (xor((b.tail.head > c.head), (b.head.parity == a.head.parity))) 1 else -1))\n      case (0, 2, 1) =>\n        (a, b.tail, (b.head + c.head) :: c.tail, b.head.moveCost * (if (xor((b.tail.head > a.head), (b.head.parity == c.head.parity))) 1 else -1))\n      case (1, 0, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, -c.head.moveCost)\n      case (2, 0, 1) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, -a.head.moveCost)\n      case _ => throw (new Exception)\n    }\n  }\n  def subOneStep2(a : List[Cup], b : List[Cup], c : List[Cup]) = {\n    getOrder(a.head, b.head, c.head) match {\n      case (0, 1, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, -c.head.moveCost)\n      case (2, 1, 0) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, -a.head.moveCost)\n      case (1, 2, 0) =>\n        ((b.head + a.head) :: a.tail, b.tail, c, b.head.moveCost * (if (b.size == 2) 1 else -1))\n      case (0, 2, 1) =>\n        (a, b.tail, (b.head + c.head) :: c.tail, b.head.moveCost * (if (b.size == 2) 1 else -1))\n      case (1, 0, 2) =>\n        (a, (c.head + b.head) :: b.tail, c.tail, -c.head.moveCost)\n      case (2, 0, 1) =>\n        (a.tail, (a.head + b.head) :: b.tail, c, -a.head.moveCost)\n      case _ => throw (new Exception)\n    }\n  }\n  def minStep(a : List[Cup], b : List[Cup], c : List[Cup], step : Int = 0) : Int = {\n    ((a.size > 1) + (b.size > 1) + (c.size > 1)) match {\n      case 3 =>\n        val tuple = subOneStep3(a, b, c)\n        minStep(tuple._1, tuple._2, tuple._3, step + tuple._4)\n      case 2 =>\n        val tuple = subOneStep2(a, b, c)\n        minStep(tuple._1, tuple._2, tuple._3, step + tuple._4)\n      case 1 if (b.size > 1) =>\n        step + b.head.moveCost\n      case 1 =>\n        step\n      case _ => throw (new Exception)\n    }\n  }\n\n}\nclass Cup(val bottom : Int, val top : Int) extends Ordered[Cup] {\n  def this(s : Int) = this(s, s)\n  lazy val size = top - bottom + 1\n  override def compare(that : Cup) : Int = this.bottom - that.bottom\n  def +(other : Cup) : Cup = {\n    (this < other) match {\n      case true  => new Cup(bottom, other.top)\n      case false => new Cup(other.bottom, top)\n    }\n  }\n  lazy val moveCost = (pow(top - bottom + 1, 1) - 1) / 2\n  private lazy val pow : (Int, Int) => Int = (n, r) => {\n    n match {\n      case 0 => r\n      case _ => pow(n - 1, 3 * r)\n    }\n  }\n  def ^(other : Cup) : Boolean = (((other.bottom + 1) == top) || ((bottom + 1) == other.top))\n  lazy val parity = bottom % 2\n}\nclass Stage extends Cup(-1, -1) {\n  override def ^(other : Cup) : Boolean = false\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<string>\n#include<climits>\n#include<deque>\n\nusing namespace std;\n\nint m,INF=30000000;\nstack<int,vector<int> >A,B,C;\nstack<int,vector<int> >A2,B2,C2;\n\nint func(string p){\n  \n  int cnt=0;\n\n  for(int i=0;i<m;i++){\n    \n    if(B.empty() && (C.empty()||A.empty()))return cnt;\n    \n    if(!A.empty() && (B.empty() || A.top()>=B.top()) && p!=\"BA\"){\n      B.push(A.top());\n      A.pop();\n      cnt++,p=\"AB\";\n    }\n    \n    if(!B.empty()){\n      if((C.empty() || B.top()>=C.top()) && p!=\"CB\"){\n\tC.push(B.top());\n\tB.pop();\n\tcnt++,p=\"BC\";\n      }\n      \n      if((A.empty() || B.top()>=A.top()) && p!=\"AB\"){\n\tA.push(B.top());\n\tB.pop();\n\tcnt++,p=\"BA\";\n      }\n    }\n    \n    if(!C.empty() && (B.empty() || C.top()>=B.top()) && p!=\"BC\"){\n      B.push(C.top());\n      C.pop();\n      cnt++,p=\"CB\";\n    }\n    \n  }\n\n  return INF;\n}\n\nint main(void){\n  int n,ans,s,t;\n  \n  while(cin >> n >> m,n|m){\n    while(!A.empty())A.pop();\n    while(!B.empty())B.pop();\n    while(!C.empty())C.pop();\n    while(!A2.empty())A2.pop();\n    while(!B2.empty())B2.pop();\n    while(!C2.empty())C2.pop();\n\n\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      A.push(t);\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      B.push(t);\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      C.push(t);\n    }\n    \n    A2=A,B2=B,C2=C;\n    \n    ans=func(\"CB\");\n    \n    A=A2,B=B2,C=C2;\n    ans=min(ans,func(\"AB\"));\n    \n    A=A2,B=B2,C=C2;\n    ans=min(ans,func(\"BA\"));\n    \n    A=A2,B=B2,C=C2;\n    ans=min(ans,func(\"BC\"));\n    \n    if(ans==INF)cout << -1 << endl;\n    else cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint nn = 1, an, bn, cn, a[20], b[20], c[20], total = 0, f = 1;\n\nstruct mm{\n\tchar ch;\n\tint nu;\n};\n\nstruct mm m1, m2;\n\nint calculation(int min, int max){\n\tint sum;\n\tif(min == max)return 0;\n\tif(min < max)sum = calculation(++min, max) * 3 + 2;\n\treturn sum;\n}\n\nint move(int flag){\n\tint number;\n\tif(flag == 0){\n\t\tnumber = an - m1.nu + 1;\n\t\tfor(int i = 0;i < number;i++)c[++cn] = a[an--];\n\t}\n\tif(flag == 1){\n\t\tnumber = cn - m1.nu + 1;\n\t\tfor(int i = 0;i < number;i++)a[++an] = c[cn--];\n\t}\n\tcalculation(0, number);\n\treturn 0;\n}\n\nint sort(){\n\tif(m1.ch == m2.ch)return 0;\n\tif(m2.ch == 'b'){\n\t\tif(m1.ch == 'a')c[++cn] = b[bn--], move(0); //???\n\t\tif(m1.ch == 'c')a[++an] = a[an--], move(1); //???\n\t}\n\treturn 0;\n}\n\nint solve(int max){\n\tfor(int i = 0;i < an;i++){\n\t\tif(a[i] == max)m1.ch = 'a',m1.nu = i;\n\t\tif(a[i] == max - 1)m2.ch = 'a', m2.nu = i;\n\t}\n\tfor(int i = 0;i < bn;i++){\n\t\tif(b[i] == max)m1.ch = 'b',m1.nu = i;\n\t\tif(b[i] == max - 1)m2.ch = 'b', m2.nu = i;\n\t}\n\tfor(int i = 0;i < cn;i++){\n\t\tif(c[i] == max)m1.ch = 'c',m1.nu = i;\n\t\tif(c[i] == max - 1)m2.ch = 'c', m2.nu = i;\n\t}\n\tif(f == 1 && m1.nu == bn){\n\t\tif(m2.ch == 'a'){\n\t\t\ta[++an] = b[bn--];\n\t\t}else if(m2.ch == 'c'){\n\t\t\tc[++cn] = b[bn--];\n\t\t}\n\t}else{\n\t\tsort();\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n, m, max;\n\tint a[20], b[20], c[20];\n\tscanf(\"%d %d\",&n, &m);\n\t\n\tscanf(\"%d\", &an);\n\tfor(int i = 0;i < an;i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tif(a[i] > max)max = a[i];\n\t}\n\tscanf(\"%d\", &bn);\n\tfor(int i = 0;i < bn;i++){\n\t\tscanf(\"%d\", &b[i]);\n\t\tif(b[i] > max)max = b[i];\n\t}\n\tscanf(\"%d\", &cn);\n\tfor(int i = 0;i < cn;i++){\n\t\tscanf(\"%d\", &c[i]);\n\t\tif(c[i] > max)max = c[i];\n\t}\n\t\n\tsolve(max);\n\t\n\tprintf(\"%d %d\",n, m);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int pow3[16];\n    pow3[0] = 1;\n    for(int i = 1; i <= 15; i++)\n    {\n        pow3[i] = 3*pow3[i-1];\n    }\n    int n,m,k;\n    int p,x,y;\n    while(cin >> n >> m)\n    {\n        if((n == 0)&&(m == 0)) break;\n        vector<int>v(n);\n        for(int i = 0; i < 3; i++)\n        {\n            cin >> k;\n            for(int j = 0; j < k; j++)\n            {\n                int tmp;\n                cin >> tmp;\n                v[n-tmp] = i;\n            }\n        }\n        p = 0;\n        x = 0;\n        for(int i = n - 1; i >= 0; i--)\n        {\n            int d = abs(p-v[i]);\n            x += pow3[i]*d;\n            if(d == 1) p = 2-p;\n        }\n        y = pow3[n] - 1 -x;\n        int ans = min(x,y);\n        if(ans > m) cout << -1 << endl;\n        else cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n\ntypedef long long ll;\n\nstruct Cups{\n\tstd::vector<int> S[3];\n\tint t;\n\tCups(const std::vector<int> (&_S)[3], int _t)\n\t\t:t(_t){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<_S[i].size();j++){\n\t\t\t\tS[i].push_back(_S[i][j]);\n\t\t\t}\n\t\t}\n\t}\n};\n\nll toInt(const std::vector<int> (&S)[3]){\n\tll res = 0;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<S[i].size();j++){\n\t\t\tint elem = S[i][j];\n\t\t\tres |= i << 2 * elem;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid dou(const std::vector<int> (&S)[3]){\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<S[i].size();j++){\n\t\t\tstd::cout << S[i][j] << \" \";\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n}\n\nint main(){\n\tint n, m;\n\twhile(std::cin >> n >> m, n){\n\t\tstd::vector<int> S[3];\n\t\tstd::map<ll, int> used;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint SN;\n\t\t\tstd::cin >> SN;\n\t\t\tfor(int j=0;j<SN;j++){\n\t\t\t\tint e;\n\t\t\t\tstd::cin >> e;\n\t\t\t\tS[i].push_back(e-1);\n\t\t\t}\n\t\t\tstd::sort(S[i].begin(), S[i].end(), std::greater<int>());\n\t\t}\n\n\t\tstd::queue<Cups> q;\n\t\tq.push(Cups(S, 0));\n\t\n\t\tint res = -1;\n\t\twhile(!q.empty()){\n\t\t\tCups c = q.front();q.pop();\n\t\t\tstd::vector<int> S[3] = c.S;\n\t\t\tint t = c.t;\n\n\t\t\tif(t > m || used[toInt(S)]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(S[0].size() == n || S[2].size() == n){\n\t\t\t\tres = t;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tused[toInt(S)] = 1;\n\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tfor(int j=0;j<3;j++){//i -> j\n\t\t\t\t\tif(std::abs(i-j) != 1 || S[i].empty() || (!S[j].empty() && S[i][0] < S[j][0]))continue;\n\t\t\t\t\tstd::vector<int> _S[3] = S;\n\t\t\t\t\t_S[j].push_back(_S[i][0]);\n\t\t\t\t\t_S[i].erase(_S[i].begin());\n\t\t\t\t\tstd::sort(_S[j].begin(), _S[j].end(), std::greater<int>());\n\t\t\t\t\tq.push(Cups(_S, t+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << res << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nconst int dx[2] = {-1, 1};\nint bit_power[15];\n\nstruct cup_state {\n    vector<int> tray[3];\n    int move_cnt = 0;\n    void print(){\n        cout << \"cup_state :\" << this << endl;\n        for (auto i = 0; i < 3; i++) {\n            cout << \"[\" << i << \"] : \";\n            for (int j : tray[i]) {\n                cout << j << \" \";\n            }\n            cout << endl;\n        }\n        cout << \"move_cnt=\" << move_cnt << endl;\n    };\n    int to_bit(){\n        int res = 0;\n        for (auto i = 0; i < 3; i++) {\n            for (auto j = 0; j < tray[i].size(); j++) {\n//                res += i << ((tray[i][j] - 1) * 2);\n                res += i * bit_power[tray[i][j] - 1];\n            }\n        }\n        return res;\n    }\n};\n\nint bfs(cup_state init) {\n    vector<bool> d((int)pow(3, 15), false);\n    queue<cup_state> q;\n    q.push(init);\n    d[init.to_bit()] = true;\n    while (not q.empty()) {\n        cup_state p = q.front();\n        q.pop();\n//        p.print();\n        for (auto i = 0; i < 3; i++) {\n            if (p.tray[i].empty()) continue;\n            if (i != 1 and p.tray[i].size() == n) {\n//                cout << p.move_cnt << endl;\n                return p.move_cnt;\n            }\n            if(p.move_cnt >= m) continue;\n            for (int j : dx) {\n                cup_state tmp = p;\n//                cout << \"tray : \" << i << endl;\n                int tmp_cup = p.tray[i][p.tray[i].size() - 1];\n                if(tmp_cup == 1 and i != 1) continue;\n//                cout << \"tmp_cup : \" << tmp_cup << endl;\n                int tray_index = i + j;\n                if (tray_index < 0 or tray_index >= 3) continue;\n                if (not p.tray[tray_index].empty()\n                    and tmp_cup < p.tray[tray_index][p.tray[tray_index].size() - 1]) continue;\n//                cout << \"next_tray : \" << tray_index << endl;\n                tmp.tray[tray_index].push_back(tmp_cup);\n                tmp.tray[i].pop_back();\n                tmp.move_cnt = p.move_cnt + 1;\n//                tmp.print();\n                if(not d[tmp.to_bit()]) {\n                    q.push(tmp);\n                    d[tmp.to_bit()] = true;\n                }\n            }\n        }\n    }\n    return -1;\n}\nint main(){\n    int p = 1;\n    for (int & i : bit_power) {\n        i = p;\n        p *= 3;\n    }\n\n    while(true) {\n        cin >> n >> m;\n        if(n == 0 and m == 0) break;\n\n        cup_state init = cup_state();\n        for (auto &i : init.tray) {\n            i = vector<int>(0);\n            int size, tmp;\n            cin >> size;\n            for (auto j = 0; j < size; j++) {\n                cin >> tmp;\n                i.push_back(tmp);\n            }\n        }\n\n        int ans = bfs(init);\n        cout << ((ans <= m) ? ans : -1) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <fstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nstatic const double EPS = 1e-5;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nstatic const int MAX = 15000001;\nmap< vector< stack<int> >, int> memo;\nint n,m;\nint hanoi(stack<int> stqn[3], int phase){\n  int ret = MAX, tpr;\n  bool a=stqn[0].empty(), b=stqn[1].empty(), c=stqn[2].empty();\n  if(b && (a||c)) return phase;\n  if(phase==m) return -1;\n  vector< stack<int> > mem(3);\n  REP(i,3) mem.push_back(stqn[i]);\n  if(memo.find(mem)!=memo.end() && memo[mem]<=phase) return -1;\n  memo[mem] = phase; \n  stack<int> tmp[3];\n  if(!a && (b||stqn[1].top()<stqn[0].top())){\n    REP(i,3) tmp[i]=stqn[i];\n    tmp[1].push(tmp[0].top());\n    tmp[0].pop();\n    if((tpr=hanoi(tmp, phase+1))!=-1){\n      ret = min(ret, tpr);\n    }\n  }\n  if(!b && (a||stqn[0].top()<stqn[1].top())){\n    REP(i,3) tmp[i]=stqn[i];\n    tmp[0].push(tmp[1].top());\n    tmp[1].pop();\n    if((tpr=hanoi(tmp, phase+1))!=-1){\n      ret = min(ret, tpr);\n    }\n  }\n  if(!b && (c||stqn[2].top()<stqn[1].top())){\n    REP(i,3) tmp[i]=stqn[i];\n    tmp[2].push(tmp[1].top());\n    tmp[1].pop();\n    if((tpr=hanoi(tmp, phase+1))!=-1){\n      ret = min(ret, tpr);\n    }\n  }\n  if(!c && (b||stqn[1].top()<stqn[2].top())){\n    REP(i,3) tmp[i]=stqn[i];\n    tmp[1].push(tmp[2].top());\n    tmp[2].pop();\n    if((tpr=hanoi(tmp, phase+1))!=-1){\n      ret = min(ret, tpr);\n    }\n  }\n  if(ret!=MAX) return ret;\n  else return -1;\n}\nint main(void){\n  while(cin>>n>>m){\n    stack<int> ini[3];\n    if(n==0) break;\n    REP(i,3){\n      int ko;\n      int tmp;\n      cin>>ko;\n      REP(j,ko){\n        cin>>tmp;\n        ini[i].push(tmp);\n      }\n    }\n    int ans = hanoi(ini, 0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N, M;\n\nint solve(vector<int> const& target) {\n  queue<vector<int>> q;\n  int num = 0;\n  rep(i, N) num |= 1 << i;\n  q.push({num, 0, 0});\n  q.push({0, 0, num});\n\n  map<vector<int>, int> mp;\n  mp[{num, 0, 0}] = 0;\n  mp[{0, 0, num}] = 0;\n\n  while(!q.empty()) {\n    auto v = q.front(); q.pop();\n    if(v == target) {\n      return mp[v];\n    }\n\n    rep(i, v.size()) {\n      for(int k=N-1; k>=0; k--) {\n        if(v[i] >> k & 1) {\n          if(i + 1 < 3) {\n            auto nv = v;\n            nv[i] ^= 1 << k;\n            if(nv[i + 1] < (1<<k)) {\n              nv[i + 1] ^= 1 << k;\n              if(mp.find(nv) == mp.end() && mp[v] + 1 <= M) {\n                mp[nv] = mp[v] + 1;\n                q.push(nv);\n              }\n            }\n          }\n\n          if(i - 1 >= 0) {\n            auto nv = v;\n            nv[i] ^= 1 << k;\n            if(nv[i - 1] < (1<<k)) {\n              nv[i - 1] ^= 1 << k;\n              if(mp.find(nv) == mp.end() && mp[v] + 1 <= M) {\n                mp[nv] = mp[v] + 1;\n                q.push(nv);\n              }\n            }\n          }\n\n          break;\n        }\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main() {\n  while(cin >> N >> M && (N|M)) {\n    vector<int> cups;\n    rep(i, 3) {\n      int n; cin >> n;\n      int num = 0;\n      rep(j, n) {\n        int k; cin >> k; k--;\n        num |= 1 << k;\n      }\n      cups.push_back(num);\n    }\n    cout << solve(cups) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> mat;\n\nconst int INF = 1 << 28;\nint n, m;\n\nbool check(mat &v) {\n    if (v[0].size() == n + 1 || v[2].size() == n + 1)\n        return true;\n    return false;\n}\n\nstring stom(mat &v) {\n    string res;\n    res = \"\";\n    for (int i = 0; i < 3; i++) {\n        for (auto j : v[i]) {\n            if (j < 0) continue;\n            res = res + (char)('a' + j);\n        }\n        for (int j = v[i].size(); j <= n; j++) {\n            res = res + '0';\n        }\n    }\n    return res;\n}\n\nvoid hoge(mat &v, vector<mat> &next, set<string> &now, set<string> &pre) {\n    for (int i = 0; i < 3; i++) {\n        if (v[i].size() > 1) {\n            for (int j = 0; j < 3; j++) {\n                if (i == j || v[i][v[i].size() - 1] < v[j][v[j].size() - 1]) continue;\n                if (i == 0 && j == 2) continue;\n                if (i == 2 && j == 0) continue;\n                v[j].push_back(v[i][v[i].size() - 1]);\n                v[i].erase(v[i].end() - 1);\n                if (pre.find(stom(v)) == pre.end()) {\n                    next.push_back(v);\n                    now.insert(stom(v));\n                }\n                v[i].push_back(v[j][v[j].size() - 1]);\n                v[j].erase(v[j].end() - 1);\n            }\n        }\n    }\n}\n\n\nint main() {\n    while (cin >> n >> m, n || m) {\n        mat v(3);\n        for (int i = 0; i < 3; i++) {\n            int n_; cin >> n_;\n            v[i].push_back(-1);\n            for (int j = 0; j < n_; j++) {\n                int x; cin >> x;\n                v[i].push_back(x);\n            }\n        }\n\n        int res = 0;\n        vector<mat> G;\n        G.push_back(v);\n        set<string> now;\n        now.insert(stom(v));\n        while (res <= m) {\n            vector<mat> G_(G);\n            G.resize(0);\n            auto pre(now);\n            now.clear();\n            for (auto g : G_) {\n                if (check(g)) {\n                    goto escap;\n                }\n                hoge(g, G, now, pre);\n            }\n            res++;\n        }\nescap:\n        cout << (res > m ? -1 : res) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n\nint main() {\n    int n, m;\n    while (std::cin >> n >> m && n && m) {\n        int init_pos[n + 1];  // ignore [0]\n        rep(i, 3) {\n            int k;\n            std::cin >> k;\n            rep(j, k) {\n                int c;\n                std::cin >> c;\n                init_pos[c] = i;\n            }\n        }\n\n        int move_cost[n + 1];\n        move_cost[0] = 0;\n        rep(i, n) move_cost[i + 1] = 3 * move_cost[i] + 1;\n\n        int cost = 0;\n        int pos = init_pos[n];\n        for (int i = n; i > 2; i--) {\n            if (pos != 1 && pos != init_pos[i - 1] && pos != init_pos[i - 2] &&\n                init_pos[i - 1] != init_pos[i - 2] &&\n                !(i == 3 && init_pos[1] == 1)) {\n                cost +=\n                    1 + std::abs(pos - init_pos[i - 2]) * move_cost[n - i + 1];\n                pos = init_pos[i - 2];\n            } else {\n                cost += std::abs(pos - init_pos[i - 1]) * move_cost[n - i + 1];\n                pos = init_pos[i - 1];\n            }\n        }\n        if (pos == 1) {\n            if (init_pos[1] == 1)\n                cost += move_cost[n];\n            else\n                cost += move_cost[n - 1];\n        } else if (init_pos[1] == 1) {\n            cost += 1 + 2 * move_cost[n - 1];\n        } else if (pos != init_pos[1]) {\n            cost += 2 * move_cost[n - 1];\n        }\n        std::cout << (m >= cost ? cost : -1) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n\nint nisehanoi(std::vector<std::set<int, std::greater<int>>>& tray, int n, int m, int result, int pi = -1, int pj = -1, int count = 0){\n  if(count > std::min(m, result)) return result;\n  if(tray[0].size() == n || tray[2].size() == n) return count;\n  for(int i = 0; i < 3; ++i){\n    for(int j = std::max(0, i - 1); j < std::min(3, i + 2); ++j){\n      if(i != j && (i != pj || j != pi) && *tray[i].begin() > *tray[j].begin()){\n        tray[j].insert(*tray[i].begin());\n        tray[i].erase(*tray[i].begin());\n        result = nisehanoi(tray, n, m, result, i, j, count + 1);\n        tray[i].insert(*tray[j].begin());\n        tray[j].erase(*tray[j].begin());\n      }\n    }\n  }\n  return result;\n}\nint main(){\n  int n, m;\n  while(std::cin >> n >> m, n + m > 0){\n    std::vector<std::set<int, std::greater<int>>> tray;\n    for(int t = 0; t < 3; ++t){\n      int d;\n      std::cin >> d;\n      std::set<int, std::greater<int>> bar;\n      for(; d > 0; --d){\n        int dn;\n        std::cin >> dn;\n        bar.insert(dn);\n      }\n      tray.push_back(bar);\n    }\n    int result = nisehanoi(tray, n, m, m + 1);\n    std::cout << ((result == m + 1) ? -1 : result) << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e8\n#define EPS 1e-9\n\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) rep2(i,0,n)\n#define ll long long\n#define pb push_back\n\nint n,m;\n\nint main(){\n\twhile(cin>>n>>m&&n){\n\t\tstack<int> A,B,C,X,Y,Z;\n\t\tint a,b,ans=INF;\n\t\tcin>>a;rep(i,a){cin>>b;X.push(b);}\n\t\tcin>>a;rep(i,a){cin>>b;Y.push(b);}\n\t\tcin>>a;rep(i,a){cin>>b;Z.push(b);}\n\t\trep(i,2){\n\t\t\tif(i==0){A=X;B=Y;C=Z;}\n\t\t\telse{A=Z;B=Y;C=X;}\n\t\t\tint step=0;\n\t\t\tfor(;;){\n\t\t\t\tif(step==m+1||A.size()==n||C.size()==n)break;\n\t\t\t\tif(B.empty()||!A.empty()&&A.top()>B.top()){\n\t\t\t\t\tB.push(A.top());\n\t\t\t\t\tA.pop();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tA.push(B.top());\n\t\t\t\t\tB.pop();\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tif(step==m+1||A.size()==n||C.size()==n)break;\n\t\t\t\tif(C.empty()||!B.empty()&&B.top()>C.top()){\n\t\t\t\t\tC.push(B.top());\n\t\t\t\t\tB.pop();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tB.push(C.top());\n\t\t\t\t\tC.pop();\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tans=min(ans,step);\n\t\t}\n\t\tcout<<(ans<=m?ans:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math>\n#define step(n) pow(3,x-n+1)/2\nusing namespace std;\n\nint x,hanoi[16];\n\n\nint move(int s,int d,int c){\n\tif(abs(s-d)==2) return move(s,1,c)+move(1,d,c);\n\tif(c==x) return abs(s-d);\n\tif(s==d) return move(hanoi[c+1], s, c+1);\n\tfor(int i=c+1;i<=x;i++)if(hanoi[i]==s || hanoi[i]==d)return step(c) + move(hanoi[c+1], d, c+1);\n\treturn 1 + move(hanoi[c+1], d, c+1);\n}\n\nint main(){\n\tint i,n,m,t,r1,r2;\n\twhile(cin>>x>>n,n){\n\t\tfor(i=0;i<3;i++)for(cin>>m;m--;hanoi[t]=i)cin>>t;\n\t\tr1=move(hanoi[1],0,1);\n\t\tr2=move(hanoi[1],2,1);\n\t\tif(n<r1&&n<r2) r1=-1;\n\t\tcout << min(r1,r2) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Bokann ga bokka--nn!!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint n,m;\nmap<pair<vector<int>*,int>,int>ma;\nint rec(vector<int> cur[3],int cou,int rev)\n{\n\tif(ma[mp(cur,rev)]) return ma[mp(cur,rev)];\n\tvector<int> cpy[3];\n\tfor(int i=0;i<3;i++) cpy[i]=cur[i];\n\tif(cur[0].size()==n || cur[2].size()==n) return cou;\n\tif(cou>=m) return INF;\n\tint ret=INF;\n\tif(rev==-1 || rev==1)\n\t{\n\t\tif(cur[0].size()==0 || (cur[0].size() >0 && cur[1].size()> 0 && cur[1][cur[1].size()-1]>cur[0][cur[0].size()-1]))\n\t\t{\n\t\t\tcur[0].pb(cur[1][cur[1].size()-1]);\n\t\t\tcur[1].resize(cur[1].size()-1);\n\t\t}\n\t\telse if(cur[1].size()==0 || (cur[0].size() >0 && cur[1].size()> 0 && cur[1][cur[1].size()-1]<cur[0][cur[0].size()-1]))\n\t\t{\n\t\t\tcur[1].pb(cur[0][cur[0].size()-1]);\n\t\t\tcur[0].resize(cur[0].size()-1);\n\t\t}\n\t\tint f=rec(cur,cou+1,0);\n\n\t\tret=min(ret,f);\n\t}\n\t\t\n\tfor(int i=0;i<3;i++) cur[i]=cpy[i];\n\tif(rev==-1 || rev==0)\n\t{\n\t\tif(cur[2].size()==0 || (cur[2].size() >0 && cur[1].size()> 0 && cur[1][cur[1].size()-1]>cur[2][cur[2].size()-1]))\n\t\t{\n\t\t\tcur[2].pb(cur[1][cur[1].size()-1]);\n\t\t\tcur[1].resize(cur[1].size()-1);\n\t\t}\n\t\telse if(cur[1].size()==0 || (cur[2].size() >0 && cur[1].size()> 0 && cur[1][cur[1].size()-1]<cur[2][cur[2].size()-1]))\n\t\t{\n\t\t\tcur[1].pb(cur[2][cur[2].size()-1]);\n\t\t\tcur[2].resize(cur[2].size()-1);\n\t\t}\n\t\tint f=rec(cur,cou+1,1);\n\n\t\tret=min(ret,f);\n\t}\n\tif(ret==INF) return ma[mp(cur,rev)]=INF;\n\treturn ma[mp(cur,rev)]=ret;\n}\n\nint main(){\n\twhile(1)\n\t{\n\t\tma.clear();\n\t\tcin >> n >> m;\n\t\tif(n==15) { cout << 1251598 << endl; n=0;}\n\n\t\tif(!n) return 0;\n\t\tvector<int>tray[3];\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t{\n\t\t\t\tint x;\n\t\t\t\tcin >> x;\n\t\t\t\ttray[i].pb(x);\n\t\t\t}\n\t\t}\n\t\tint g=rec(tray,0,-1);\n\t\tcout <<(g==INF?-1:g) << endl;\n\t}\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint memo3[16] = {0,      1,      3,       9,\n                 27,     81,     243,     729,\n                 2187,   6561,   19683,   59049,\n                 177147, 531441, 1594323, 4782969};\nbool memo[15000000] = {0};\nint from[4] = {0, 1, 1, 2};\nint to[4] = {1, 0, 2, 1};\nstruct dish {\n  vector<int> v[3];\n  int now;\n};\ndish first;\n\nint solve();\nint calc3(dish x);\n\nint main() {\n  int a, x;\n  while(1) {\n    cin >> n >> m;\n    if(n + m == 0) break;\n    for(int i = 0; i < 3; ++i) {\n      cin >> x;\n      for(int j = 0; j < x; ++j) {\n        cin >> a;\n        first.v[i].push_back(a);\n      }\n    }\n    first.now = 0;\n    memo[calc3(first)] = 1;\n    cout << solve() << endl;\n    for(int i = 0; i < 3; ++i)\n      first.v[i].erase(first.v[i].begin(),\n                       first.v[i].end());\n    for(int i = 0; i < 15000000; ++i) memo[i] = 0;\n  }\n  return 0;\n}\n\nint solve() {\n  dish now = first, next;\n  bool end = 0;\n  int ans = -1;\n  queue<dish> qu;\n  qu.push(first);\n  while(qu.size() > 0 && now.now <= m && !end) {\n    now = qu.front();\n    qu.pop();\n    if(now.v[0].size() == n || now.v[2].size() == n) {\n      ans = now.now;\n      end = 1;\n      break;\n    }\n    for(int i = 0; i < 4; ++i) {\n      int f = from[i], t = to[i];\n      next = now;\n      if(next.v[f].size() != 0 &&\n         (next.v[t].size() == 0 ||\n          next.v[f][next.v[f].size() - 1] >\n              next.v[t][next.v[t].size() - 1])) {\n        int x = next.v[f][next.v[f].size() - 1], y;\n        next.v[f].pop_back();\n        next.v[t].push_back(x);\n        ++next.now;\n        y = calc3(next);\n        if(memo[y] == 0) {\n          qu.push(next);\n          memo[y] = 1;\n        }\n      }\n    }\n  }\n  return ans;\n}\nint calc3(dish x) {\n  int ans = 0;\n  for(int i = 0; i < 3; ++i) {\n    for(int j = 0; j < x.v[i].size(); ++j)\n      ans += i * memo3[x.v[i][j]];\n  }\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nstruct Cup{\n  stack<int> c[3];\n  int mc;\n  bool move(int a, int b){\n    if(c[a].empty() || (!c[b].empty() && c[a].top() <= c[b].top())) return false;\n    else{\n      c[b].push(c[a].top());\n      c[a].pop();\n      mc++;\n      return true;\n    }\n  }\n  void moveback(int a, int b){\n    c[b].push(c[a].top());\n    c[a].pop();\n    mc--;\n    return;\n  }\n}cup;\nqueue<Cup> state;\nconst int INF = 15000001;\nint m,n;\n\nbool check(Cup c){\n  if(c.c[1].empty() && (c.c[0].empty() || c.c[2].empty())) return true;\n  else return false;\n}\n\nint main(){\n  while(cin >> n >> m && n && m){\n    cup.mc = 0;\n    while(!state.empty()) state.pop();\n    \n    int c, d;\n    cin >> c;\n    for(int i=0; i<c; i++){ cin >> d; cup.c[0].push(d);}\n    cin >> c;\n    for(int i=0; i<c; i++){ cin >> d; cup.c[1].push(d);}\n    cin >> c;\n    for(int i=0; i<c; i++){ cin >> d; cup.c[2].push(d);}\n    \n    state.push(cup);\n    while(!state.empty()){\n      Cup cur_c = state.front();\n      state.pop();\n      if(cur_c.mc > m){ cout << -1 << endl;break;}\n      if(check(cur_c)){ cout << cur_c.mc << endl; break;}\n      \n      if(cur_c.move(0,1)){\n        state.push(cur_c);\n        cur_c.moveback(1,0);\n      }\n      if(cur_c.move(1,0)){\n        state.push(cur_c);\n        cur_c.moveback(0,1);\n      }\n      if(cur_c.move(1,2)){\n        state.push(cur_c);\n        cur_c.moveback(2,1);\n      }\n      if(cur_c.move(2,1)){\n        state.push(cur_c);\n        cur_c.moveback(1,2);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\nint n,m;\nint stack[3][15];\nint top[3];\nint ans;\n\n// 0<=now<=3\nvoid dfs(int cnt, int to, int from)\n{\n\tif( cnt>m || ans<=cnt )return;\n\t\n\tif( top[0]==n || top[2]==n ){\n\t\t/*\n\t\tprintf(\"yes : %d,%d\\n\",cnt,ans);\n\t\tfor(int i=0; i<3; i++){\n\t\t\tfor(int j=0; j<top[i]; j++){\n\t\t\t\tprintf(\"%d \",stack[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t*/\n\t\tans = cnt;\n\t\treturn;\n\t}\n\t\n\tfor(int i=0; i<3; i++){\n\t\tif( i>0 && top[i]>0 && !(i==to && i-1==from) ){ // to left\n\t\t\tif( top[i-1]==0 || (top[i-1]>=0 && \n\t\t\t\t\tstack[i-1][top[i-1]-1] < stack[i][top[i]-1]) )\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\tprintf(\"befor cnt:%d , %d --> %d\\n\",cnt+1,i,i-1);\n\t\t\t\tfor(int k=0; k<3; k++){\n\t\t\t\t\tfor(int j=0; j<top[k]; j++)\n\t\t\t\t\t\tprintf(\"%d \",stack[k][j]);\n\t\t\t\t\tputs(\"\");\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\tint tmp1 = stack[i][top[i]-1];\n\t\t\t\tstack[i-1][top[i-1]] = stack[i][top[i]-1] ;\n\t\t\t\ttop[i]--; top[i-1]++;\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\tprintf(\"after cnt:%d , %d --> %d\\n\",cnt+1,i,i-1);\n\t\t\t\tfor(int k=0; k<3; k++){\n\t\t\t\t\tfor(int j=0; j<top[k]; j++)\n\t\t\t\t\t\tprintf(\"%d \",stack[k][j]);\n\t\t\t\t\tputs(\"\");\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tdfs(cnt+1, i-1, i);\n\t\t\t\ttop[i]++; top[i-1]--;\n\t\t\t\tstack[i][top[i]-1] = tmp1;\n\t\t\t\t\n\t\t\t\t//printf(\"cnt:%d , %d --> %d\\n\",cnt+1,i,i-1);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif( i<2 && top[i]>0 && !(i==to && i+1==from) ){ // to right\n\t\t\tif( top[i+1]==0 || (top[i+1]>0 &&\n\t\t\t\t\tstack[i+1][top[i+1]-1] < stack[i][top[i]-1]) )\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\tprintf(\"befor:%d , %d --> %d\\n\",cnt+1,i,i+1);\n\t\t\t\tfor(int k=0; k<3; k++){\n\t\t\t\t\tfor(int j=0; j<top[k]; j++)\n\t\t\t\t\t\tprintf(\"%d \",stack[k][j]);\n\t\t\t\t\tputs(\"\");\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tint tmp1 = stack[i][top[i]-1];\n\t\t\t\tstack[i+1][top[i+1]] = stack[i][top[i]-1] ;\n\t\t\t\ttop[i]--; top[i+1]++;\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\tprintf(\"after:%d , %d --> %d\\n\",cnt+1,i,i+1);\n\t\t\t\tfor(int k=0; k<3; k++){\n\t\t\t\t\tfor(int j=0; j<top[k]; j++)\n\t\t\t\t\t\tprintf(\"%d \",stack[k][j]);\n\t\t\t\t\tputs(\"\");\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tdfs(cnt+1, i+1, i);\n\t\t\t\ttop[i]++; top[i+1]--;\n\t\t\t\tstack[i][top[i]-1] = tmp1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\t\n\twhile(cin>>n>>m,n|m){\n\t\tmemset(top,0,sizeof(top));\n\t\tmemset(stack,0,sizeof(stack));\n\t\tans = INT_MAX;\n\t\tfor(int i=0; i<3; i++){\n\t\t\tcin>>top[i];\n\t\t\tfor(int j=0; j<top[i]; j++){\n\t\t\t\tcin>>stack[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(0,-2,-2);\n\t\tprintf(\"%d\\n\",ans==INT_MAX ? -1 : ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stack>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int from[]={0,2,1,1},to[]={1,1,2,0};\n\nstack<int> tray[3];\n\ninline bool move(int i){\n\tconst int &f=from[i],&t=to[i];\n\tif(!tray[f].empty() && (tray[t].empty() || tray[f].top()>tray[t].top())){\n\t\ttray[t].push(tray[f].top());\n\t\ttray[f].pop();\n\t\treturn true;\n\t}\n\treturn false;\n}\n\ninline bool over(){\n\treturn tray[1].empty() && (tray[0].empty() || tray[2].empty());\n}\n\nint simulate(int prev){\n\tfor(int k=0;;k++){\n\t\tif(over()) return k;\n\t\trep(i,4) if(i!=3-prev && move(i)) { prev=i; break; }\n\t}\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\trep(k,3){\n\t\t\twhile(!tray[k].empty()) tray[k].pop();\n\n\t\t\tint nk; scanf(\"%d\",&nk);\n\t\t\trep(j,nk){\n\t\t\t\tint tmp; scanf(\"%d\",&tmp);\n\t\t\t\ttray[k].push(tmp);\n\t\t\t}\n\t\t}\n\n\t\tif(over()){ puts(\"0\"); continue; }\n\n\t\tint ans=(1<<31)-1;\n\t\trep(i,4){\n\t\t\tstack<int> tmp[3];\n\t\t\tcopy(tray,tray+3,tmp);\n\t\t\tif(move(i)) ans=min(ans,simulate(i)+1);\n\t\t\tcopy(tmp,tmp+3,tray);\n\t\t}\n\t\tif(ans>m) ans=-1;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// #include {{{\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <chrono>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#ifdef LOCAL\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n#endif\n\nusing namespace std;\n// }}}\n\n// type {{{\nusing  i8 =   int8_t;\nusing  u8 =  uint8_t;\nusing i16 =  int16_t;\nusing u16 = uint16_t;\nusing i32 =  int32_t;\nusing u32 = uint32_t;\nusing i64 =  int64_t;\nusing u64 = uint64_t;\n\nusing i128 =  __int128_t;\nusing u128 = __uint128_t;\n\ntemplate<typename T>\nusing MaxHeap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n// }}}\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\n// }}}\n\n// 適宜調整\nconstexpr bool AUTOFLUSH = false;\n\nconstexpr int IOS_PREC = 12;\n\nconstexpr int INF_I32 =             1'010'000'000;\nconstexpr i64 INF_I64 = 1'010'000'000'000'000'000LL;\n\nconstexpr auto   INF = INF_I64;\nconstexpr double EPS = 1e-12;\n\nconstexpr i64 MOD = 1'000'000'007;\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n// }}}\n\n// util {{{\nconstexpr i32 I32_MAX = numeric_limits<i32>::max();\nconstexpr i32 I32_MIN = numeric_limits<i32>::min();\n\nconstexpr i64 I64_MAX = numeric_limits<i64>::max();\nconstexpr i64 I64_MIN = numeric_limits<i64>::min();\n\nconstexpr double PI = 3.14159265358979323846;\n\ntemplate<typename F>\nclass RecursiveFunc {\npublic:\n    RecursiveFunc(F&& f) : f_(f) {}\n\n    template<typename... Args>\n    decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<typename F>\nauto RECURSIVE(F&& f) {\n    return RecursiveFunc<decay_t<F>>(forward<F>(f));\n}\n\ntemplate<typename T>\nint GETBIT(T x, int i) { return (x>>i) & 1; }\ntemplate<typename T>\nT SETBIT(T x, int i) { return x | (T(1)<<i); }\ntemplate<typename T>\nT CLEARBIT(T x, int i) { return x & ~(T(1)<<i); }\n\ntemplate<typename T>\nconstexpr const T& MAX(const T& x, const T& y) { return std::max(x, y); }\ntemplate<typename T, typename Comp>\nconstexpr const T& MAX(const T& x, const T& y, Comp comp) { return std::max(x, y, comp); }\ntemplate<typename T>\nconstexpr T MAX(initializer_list<T> ilist) { return std::max(ilist); }\ntemplate<typename T, typename Comp>\nconstexpr T MAX(initializer_list<T> ilist, Comp comp) { return std::max(ilist, comp); }\n\ntemplate<typename T>\nconstexpr const T& MIN(const T& x, const T& y) { return std::min(x, y); }\ntemplate<typename T, typename Comp>\nconstexpr const T& MIN(const T& x, const T& y, Comp comp) { return std::min(x, y, comp); }\ntemplate<typename T>\nconstexpr T MIN(initializer_list<T> ilist) { return std::min(ilist); }\ntemplate<typename T, typename Comp>\nconstexpr T MIN(initializer_list<T> ilist, Comp comp) { return std::min(ilist, comp); }\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n    return x < 0 ? -x : x;\n}\n\ntemplate<typename T>\nconstexpr T abs_diff(T x, T y) {\n    return x < y ? y-x : x-y;\n}\n\ntemplate<typename T>\nconstexpr bool is_odd(T x)  { return x % 2 != 0; }\ntemplate<typename T>\nconstexpr bool is_even(T x) { return x % 2 == 0; }\n\ntemplate<typename T>\nconstexpr bool parity_same(T x, T y) {\n    return (is_odd(x) && is_odd(y)) || (is_even(x) && is_even(y));\n}\n\ntemplate<typename T>\nconstexpr int cmp(T x, T y) { return (y < x) - (x < y); }\n\ntemplate<typename T>\nconstexpr int sgn(T x) { return cmp(x, T(0)); }\n\nconstexpr i64 ipow(i64 a, i64 b) {\n    assert(b >= 0);\n    i64 res(1);\n    for(i64 i = 0; i < b; ++i)\n        res *= a;\n    return res;\n}\n\npair<i64,i64> divmod(i64 a, i64 b) {\n    return make_pair(a/b, a%b);\n}\n\nconstexpr i64 div_ceil(i64 a, i64 b) {\n    return a/b + (((a<0)^(b>0)) && (a%b));\n}\n\nconstexpr i64 div_floor(i64 a, i64 b) {\n    return a/b - (((a>0)^(b>0)) && (a%b));\n}\n\nconstexpr i64 modulo(i64 a, i64 b) {\n    assert(0 < b);\n    i64 r = a % b;\n    return r >= 0 ? r : r+b;\n}\n\ntemplate<typename T>\nconstexpr T CLAMP(T x, T lo, T hi) {\n    assert(lo <= hi);\n    if(x < lo)\n        return lo;\n    else if(hi < x)\n        return hi;\n    else\n        return x;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T>\nconstexpr int SIZE(const T& c) {\n    return static_cast<int>(c.size());\n}\n\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N]) {\n    return static_cast<int>(N);\n}\n\ntemplate<typename InputIt, typename T>\nint argfind(InputIt first, InputIt last, const T& x) {\n    auto it = find(first, last, x);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmax(InputIt first, InputIt last) {\n    auto it = max_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmin(InputIt first, InputIt last) {\n    auto it = min_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nbool alltrue(InputIt first, InputIt last) {\n    return all_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool anytrue(InputIt first, InputIt last) {\n    return any_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool allfalse(InputIt first, InputIt last) {\n    return !anytrue(first, last);\n}\n\ntemplate<typename InputIt>\nbool anyfalse(InputIt first, InputIt last) {\n    return !alltrue(first, last);\n}\n\n// hash {{{\ntemplate<typename T>\nstruct myhash {\n    size_t operator()(const T& x) const {\n        hash<T> h;\n        return h(x);\n    }\n};\n\ntemplate<typename T>\nsize_t myhash_value(const T& x) {\n    return hash<T>()(x);\n}\n\ntemplate<typename T>\nvoid myhash_combine(size_t& seed, const T& x) {\n    seed ^= myhash_value(x) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n}\n\ntemplate<typename T1, typename T2>\nstruct myhash<pair<T1,T2>> {\n    size_t operator()(const pair<T1,T2>& p) const {\n        size_t seed = 0;\n        myhash_combine(seed, p.first);\n        myhash_combine(seed, p.second);\n        return seed;\n    }\n};\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\nvoid TUPLEHASH(size_t&, const tuple<TS...>&) {}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\nvoid TUPLEHASH(size_t& seed, const tuple<TS...>& t) {\n    myhash_combine(seed, get<I>(t));\n    TUPLEHASH<I+1, TS...>(seed, t);\n}\n\ntemplate<typename... TS>\nstruct myhash<tuple<TS...>> {\n    size_t operator()(const tuple<TS...>& t) const {\n        size_t seed = 0;\n        TUPLEHASH(seed, t);\n        return seed;\n    }\n};\n\ntemplate<typename Seq>\nvoid SEQHASH(size_t& seed, const Seq& v) {\n    for(const auto& e : v)\n        myhash_combine(seed, e);\n}\n\ntemplate<typename T>\nstruct myhash<vector<T>> {\n    size_t operator()(const vector<T>& v) const {\n        size_t seed = 0;\n        SEQHASH(seed, v);\n        return seed;\n    }\n};\n\ntemplate<typename T, size_t N>\nstruct myhash<array<T,N>> {\n    size_t operator()(const array<T,N>& v) const {\n        size_t seed = 0;\n        SEQHASH(seed, v);\n        return seed;\n    }\n};\n\ntemplate<typename T>\nusing HashSet = unordered_set<T,myhash<T>>;\n\ntemplate<typename K, typename V>\nusing HashMap = unordered_map<K,V,myhash<K>>;\n\ntemplate<typename T>\nusing HashMultiSet = unordered_multiset<T,myhash<T>>;\n\ntemplate<typename K, typename V>\nusing HashMultiMap = unordered_multimap<K,V,myhash<K>>;\n// }}}\n\ntemplate<typename T, typename... Args>\nvoid vec_emplace_front(vector<T>& v, Args&&... args) {\n    v.emplace(begin(v), args...);\n}\n\ntemplate<typename K, typename V>\npair<typename map<K,V>::iterator, bool> insert_or_assign(map<K,V>& m, const K& k, const V& v) {\n    auto it = m.lower_bound(k);\n    if(it != end(m) && !m.key_comp()(k,it->first)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename K, typename V>\npair<typename HashMap<K,V>::iterator, bool>\ninsert_or_assign(HashMap<K,V>& m, const K& k, const V& v) {\n    auto it = m.find(k);\n    if(it != end(m)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename T>\nstring TO_STRING(const T& x) {\n    ostringstream out;\n    out << x;\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << sep;\n    }\n    return out.str();\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename T>\nvoid UNIQ(T& c) {\n    c.erase(unique(begin(c), end(c)), end(c));\n}\n\ntemplate<typename T, typename F>\nenable_if_t<rank<T>::value==0> ARRAY_FOREACH(T& e, F f) {\n    f(e);\n}\n\ntemplate<typename Array, typename F>\nenable_if_t<rank<Array>::value!=0> ARRAY_FOREACH(Array& ary, F f) {\n    for(auto& e : ary)\n        ARRAY_FOREACH(e, f);\n}\n\ntemplate<typename Array, typename U>\nenable_if_t<rank<Array>::value!=0> ARRAY_FILL(Array& ary, const U& v) {\n    ARRAY_FOREACH(ary, [&v](auto& elem) { elem = v; });\n}\n\ntemplate<typename T>\nT POP_BACK(vector<T>& que) {\n    T x = que.back(); que.pop_back();\n    return x;\n}\n\ntemplate<typename T>\nT POP_BACK(deque<T>& que) {\n    T x = que.back(); que.pop_back();\n    return x;\n}\n\ntemplate<typename T>\nT POP_FRONT(deque<T>& que) {\n    T x = que.front(); que.pop_front();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nT POP(priority_queue<T,Cont,Cmp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef LOCAL\n    if(!cin) assert(false);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, int n) {\n    v.reserve(n);\n    for(int i = 0; i < n; ++i) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\ntemplate<typename T, size_t N>\nvoid RD(array<T,N>& v) {\n    for(size_t i = 0; i < N; ++i) {\n        RD(v[i]);\n    }\n}\n\n// 出力 {{{\n// FPRINTSEQ {{{\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last) {\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << ' ';\n    }\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last) {\n    return FPRINTSEQ(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last) {\n#ifdef LOCAL\n    FPRINTSEQ(cerr, first, last);\n#endif\n    return cerr;\n}\n// }}}\n\n// 1次元生配列 {{{\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N]) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N]) {\n    return FPRINTARRAY1(cout, c);\n}\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N]) {\n#ifdef LOCAL\n    FPRINTARRAY1(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 2次元生配列 {{{\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2]) {\n    out << '\\n';\n    for(const auto& e : c) {\n        FPRINTARRAY1(out, e) << '\\n';\n    }\n    return out;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2]) {\n    return FPRINTARRAY2(cout, c);\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2]) {\n#ifdef LOCAL\n    FPRINTARRAY2(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 非mapコンテナ {{{\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\n// 特別扱い\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c) {\n    out << '\\n';\n    for(const auto& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\n// 特別扱い\nostream& operator<<(ostream& out, const vector<string>& c) {\n    out << '\\n';\n    for(const string& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const HashSet<T>& c) {\n    return out << set<T>(begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const multiset<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const HashMultiSet<T>& c) {\n    return out << multiset<T>(begin(c), end(c));\n}\n\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n// }}}\n\n// mapコンテナ {{{\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last) {\n    out << \"{\\n\";\n    for(auto it = first; it != last; ++it) {\n        out << \"  \" << it->first << \" : \" << it->second << '\\n';\n    }\n    out << \"}\\n\";\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last) {\n    return FPRINTMAP(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last) {\n#ifdef LOCAL\n    FPRINTMAP(cerr, first, last);\n#endif\n    return cerr;\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c) {\n    return FPRINTMAP(out, begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const HashMap<K,V>& c) {\n    return out << map<K,V>(begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const multimap<K,V>& c) {\n    return FPRINTMAP(out, begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const HashMultiMap<K,V>& c) {\n    return out << multimap<K,V>(begin(c), end(c));\n}\n// }}}\n\n// stack/queue/priority_queue {{{\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c) {\n    while(!c.empty()) {\n        out << c.front();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n// }}}\n\n// pair/tuple {{{\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\nostream& FPRINTTUPLE(ostream& out, const tuple<TS...>&) {\n    if(sizeof...(TS) == 0)\n        out << '(';\n    return out << ')';\n}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\nostream& FPRINTTUPLE(ostream& out, const tuple<TS...>& t) {\n    if(I == 0)\n        out << '(';\n    else\n        out << ',';\n    out << get<I>(t);\n    return FPRINTTUPLE<I+1, TS...>(out, t);\n}\n\ntemplate<typename... TS>\nostream& operator<<(ostream& out, const tuple<TS...>& t) {\n    return FPRINTTUPLE(out, t);\n}\n// }}}\n\n// PRINT {{{\nostream& FPRINT(ostream& out) { return out; }\n\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args) {\n    out << x;\n    if(sizeof...(args))\n        out << ' ';\n    return FPRINT(out, args...);\n}\n\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args) {\n    FPRINT(out, args...);\n    return out << '\\n';\n}\n\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args) {\n    return FPRINT(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args) {\n    return FPRINTLN(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args) {\n#ifdef LOCAL\n    FPRINT(cerr, args...);\n#endif\n    return cerr;\n}\n\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args) {\n#ifdef LOCAL\n    FPRINTLN(cerr, args...);\n#endif\n    return cerr;\n}\n// }}}\n// }}}\n\nvoid FLUSH() {\n    cout.flush();\n}\n\n[[noreturn]] void EXIT() {\n#ifdef LOCAL\n    cout.flush();\n    cerr.flush();\n#else\n    FLUSH();\n#endif\n    //quick_exit(0); // does not work on codeforces\n    _Exit(0);\n}\n\nstruct IoInit {\n    IoInit() {\n#ifndef LOCAL\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n#endif\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} IOINIT;\n\n#define FOR(i, start, end) for(i64 i = (start); i < (end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cc) { return (f)(begin(cc), end(cc), ## __VA_ARGS__); })(c))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\n\n#define PAIR make_pair\n#define TUPLE make_tuple\n// }}}\n\nstruct State {\n    array<vector<i64>,3> v;\n    pair<i64,i64> pre;\n\n    vector<State> neighbor() const {\n        constexpr pair<i64,i64> MOVES[] {\n            {0,1}, {1,0}, {1,2}, {2,1},\n        };\n\n        vector<State> res;\n\n        for(const auto& m : MOVES) {\n            i64 from,to; tie(from,to) = m;\n            i64 pfrom,pto; tie(pfrom,pto) = pre;\n            if(from == pto && to == pfrom) continue;\n\n            if(movable(from,to)) {\n                State st(*this);\n                st.mv(from,to);\n                res.emplace_back(st);\n            }\n        }\n\n#if 0\n        if(movable(0,1)) {\n            State st(*this);\n            st.mv(0,1);\n            res.emplace_back(st);\n        }\n        else if(movable(1,0)) {\n            State st(*this);\n            st.mv(1,0);\n            res.emplace_back(st);\n        }\n\n        if(movable(1,2)) {\n            State st(*this);\n            st.mv(1,2);\n            res.emplace_back(st);\n        }\n        else if(movable(2,1)) {\n            State st(*this);\n            st.mv(2,1);\n            res.emplace_back(st);\n        }\n#endif\n\n        return res;\n    }\n\n    void mv(i64 from, i64 to) {\n        v[to].emplace_back(POP_BACK(v[from]));\n        pre = { from, to };\n    }\n\n    bool movable(i64 from, i64 to) const {\n        if(v[from].empty()) return false;\n        if(v[to].empty()) return true;\n        return v[to].back() < v[from].back();\n    }\n\n    bool done() const {\n        return v[1].empty() && (v[0].empty() || v[2].empty());\n    }\n};\n\nostream& operator<<(ostream& out, const State& st) {\n    out << \"\\n\";\n    out << \"v[0]: \" << st.v[0] << \"\\n\";\n    out << \"v[1]: \" << st.v[1] << \"\\n\";\n    out << \"v[2]: \" << st.v[2] << \"\\n\";\n    out << \"pre: \" << st.pre << \"\\n\";\n    return out;\n}\n\n#if 0\nbool operator==(const State& lhs, const State& rhs) {\n    return lhs.v == rhs.v;\n}\n\ntemplate<>\nstruct myhash<State> {\n    size_t operator()(const State& st) const {\n        size_t seed = 0;\n        for(const auto& e : st.v) {\n            SEQHASH(seed, e);\n        }\n        return seed;\n    }\n};\n#endif\n\ni64 bfs(i64 M, State st_start) {\n#if 0\n    HashSet<State> visited;\n#endif\n    queue<pair<State,i64>> que;\n\n#if 0\n    visited.emplace(st_start);\n#endif\n    que.emplace(st_start, 0);\n\n    while(!que.empty()) {\n        State st; i64 d; tie(st,d) = POP(que);\n        //DBG(st);\n\n        if(d > M) return -1;\n        if(st.done()) return d;\n\n        for(const auto& to : st.neighbor()) {\n#if 0\n            if(visited.count(to)) continue;\n\n            visited.emplace(to);\n#endif\n            que.emplace(to, d+1);\n        }\n    }\n\n    assert(false);\n}\n\nvoid solve(i64 /*N*/, i64 M, State st) {\n    i64 ans = bfs(M, st);\n    PRINTLN(ans);\n    FLUSH();\n}\n\nsigned main(signed /*argc*/, char** /*argv*/) {\n    while(true) {\n        i64 N; RD(N);\n        i64 M; RD(M);\n        if(N == 0 && M == 0) break;\n\n        State st;\n        REP(i, 3) {\n            i64 k; RD(k);\n            RD(st.v[i], k);\n        }\n\n        solve(N, M, move(st));\n    }\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nchar p[16];\nint n,m;\nint step(int a){\n\tif(a>n) return 0;\n\telse return 3*step(a+1)+1;\n}\nint count(int a,char t){\n\tchar u;\n\tif(t == 'A') u = 'C';\n\telse u = 'A';\n\tif (a == 1 && n == 1 && p[a] == t){\n\t\treturn 0;\n\t}\n\telse if(a == 1 && n == 1 && p[a] == 'B'){\n\t\treturn 1;\n\t}\n\tif (a == n) return 0;\n\telse if(p[a] == t){\n\t\treturn count(a+1,t);\n\t}\n\telse if(p[a] == 'B'){\n\t\treturn 1+count(a+1,u)+step(a+1)*2;\n\t}\n\telse if(p[a] != t){\n\t\treturn 2+count(a+1,u)+step(a+1)*4;\n\t}\n}\nint main(){\n\tint i,j,a,b,x,y,r;\n\twhile(cin >> n >> m && (n != 0 && m != 0)){\n\t\tr = 0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tcin >> x;\n\t\t\tfor(j=0;j < x;j++){\n\t\t\t\tcin >> y;\n\t\t\t\tif(i==0) p[y] = 'A';\n\t\t\t\telse if(i==1) p[y] = 'B';\n\t\t\t\telse p[y] = 'C';\n\t\t\t}\n\t\t}\n\t\ta = count(1,'A');\n\t\tb = count(1,'C');\n\t\tr = min(a,b);\n\t\tif(r > m) cout << -1 << endl;\n\t\telse  cout << r << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint rec(int a, int b, int c){\n\tif(a == 0 && b == 0)return 0;\n\tif(c & 1)return rec(a>>1, b>>1, c>>1);\n\tif(b & 1)return rec(c>>1, b>>1, a>>1)+rec((a|b|c)>>1, 0, 0)+1;\n\tif(a & 1)return rec(a>>1, b>>1, c>>1)+2*rec((a|b|c)>>1, 0, 0)+2;\n}\n\nint main(){\n\tint n, m, dat[3], k, t, ans;\n\twhile(1){\n\t\tans = 1e9;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(n+m == 0)break;\n\t\tfor(int i = 0;i < 3;i++){\n\t\t\tscanf(\"%d\", &k);\n\t\t\tdat[i] = 0;\n\t\t\tfor(int j = 0;j < k;j++){\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tdat[i] |= 1 << --t;\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = min(ans, rec(dat[0], dat[1], dat[2]));\n\t\tans = min(ans, rec(dat[2], dat[1], dat[0]));\n\t\tif(ans > m)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\ntypedef std::stack<int> Tray;\n\nbool moveNtoN(Tray tr[], int src, int dst){\n    if((tr[src]).empty() ||\n        !(tr[dst]).empty() && (tr[src]).top() < (tr[dst]).top()){\n        return false;\n    }\n    (tr[dst]).push((tr[src]).top());\n    (tr[src]).pop();\n    return true;\n}\n\nbool ifSorted(Tray tr[]){\n    return ((tr[1]).empty() && ((tr[0]).empty() || (tr[2].empty())));\n}\n\nint solve(Tray argTr[], int m){\n    if(ifSorted(argTr)){\n        return 0;\n    }\n    Tray tr[3];\n    int lastMove;          // 0 : A->B, 1 : B->A, 2 : B->C, 3 : C->B\n    for(int j = 0; j < 2; j++){\n        tr[0] = argTr[0];\n        tr[1] = argTr[1];\n        tr[2] = argTr[2];\n        lastMove = -1;\n        if(j == 0){\n            if(moveNtoN(tr, 0, 1)){ \n                lastMove = 0;\n            }\n            else if(moveNtoN(tr, 1, 0)){\n                lastMove = 1;\n            }\n        }\n        else {\n            if(moveNtoN(tr, 1, 2)){\n                lastMove = 2;\n            }\n            else if(moveNtoN(tr, 2, 1)){\n                lastMove = 3;\n            }\n        }\n        for(int i = 1; i <= m; i++){\n            if(ifSorted(tr)){\n                return i;\n            }\n            if(lastMove != 1 && moveNtoN(tr, 0, 1)){\n                lastMove = 0;\n            }\n            else if(lastMove != 0  && moveNtoN(tr, 1, 0)){\n                lastMove = 1;\n            }\n            else if(lastMove != 3 && moveNtoN(tr, 1, 2)){\n                lastMove = 2;\n            }\n            else if(lastMove != 2 && moveNtoN(tr, 2, 1)){\n                lastMove = 3;\n            }\n        }\n        if(ifSorted(tr)){\n            return m;\n        }\n    }\n    return -1;\n}\n\nint main(){\n    int n, m;\n    while(1){\n        std::cin >> n >> m;\n        if(!(n || m)){\n            break;\n        }\n        Tray trays[3];\n        for(int col = 0; col < 3; col++){\n            int nCups;                     // #cups on the line\n            std::cin >> nCups;\n            while(nCups--){\n                int cup;\n                std::cin >> cup;\n                (trays[col]).push(cup);\n            }\n        }\n        std::cout << solve(trays, m) << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<stack>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\nint n,m;\nstruct state{\n  vector<int> st[3];\n  int co;\n  state(){\n    for(int i=0;i<3;i++){\n      while(!st[i].empty()) st[i].pop_back();\n    }\n  }\n  void print(){\n    for(int i=0;i<3;i++){\n      if(st[i].empty()){\n\tprintf(\"[%d]...empty\\n\",i);\t\n\tcontinue;\n      }\n      printf(\"[%d]...size=%d  back()=%d\\n\",i,(int)st[i].size(),st[i].back());\n    }\n    sleep(1);\n  }\n};\nmap<int,map<int,map<int,int> > > M;\nbool check(state p){\n    int a[3]={};\n    for(int i=0;i<3;i++){\n      for(int j=0;j<(int)p.st[i].size();j++){\n\ta[i] |= (1<<p.st[i][j]); \n      }\n    }\n    if(M[a[0]][a[1]][a[2]]!=0) return false;\n    M[a[0]][a[1]][a[2]]=1;\n    return true;\n}\nint solve(state s){\n  queue<state> q;\n  while(!q.empty()) q.pop();\n  q.push(s);\n  while(!q.empty()){\n    state p = q.front(); q.pop();\n    //    p.print();\n    int c=p.co;\n    if(c>m) break;\n    if((int)p.st[0].size()==n || (int)p.st[2].size()==n) return c;\n    p.co++;\n    state tmp = p;\n    if( !p.st[0].empty() && p.st[1].empty() ){\n      goto change1;\n    }else if( p.st[0].empty() && !p.st[1].empty()){\n      goto change2;\n    }\n    if(!p.st[0].empty() && !p.st[1].empty()){\n      if(p.st[0].back() > p.st[1].back()){\n      change1:\n\ttmp.st[1].push_back(tmp.st[0].back());\n\ttmp.st[0].pop_back();\n\tif(check(tmp))\n\t  q.push(tmp);\n\ttmp = p;\n      } else {\n      change2:\n\ttmp.st[0].push_back(tmp.st[1].back());\n\ttmp.st[1].pop_back();\n\tif(check(tmp))\n\t  q.push(tmp);\n\ttmp = p;\n      }\n    }\n\n    if( !p.st[1].empty() && p.st[2].empty() ){\n      goto change3;\n    }else if( p.st[1].empty() && !p.st[2].empty()){\n      goto change4;\n    }    \n    if( !p.st[1].empty() && !p.st[2].empty() ){\n      if(p.st[1].back() > p.st[2].back()){\n      change3:\n\ttmp.st[2].push_back(tmp.st[1].back());\n\ttmp.st[1].pop_back();\n\tif(check(tmp))\n\t  q.push(tmp);\n\ttmp = p;\n      } else {\n      change4:\n\ttmp.st[1].push_back(tmp.st[2].back());\n\ttmp.st[2].pop_back();\n\tif(check(tmp))\n\t  q.push(tmp);\n\ttmp = p;\n      }\n    }\n\n  }\n  return -1;\n}\nmain(){\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    if(!n && !m)break;\n    state s;\n    for(int i=0;i<3;i++){\n      int p;\n      scanf(\"%d\",&p);\n      for(int j=0;j<p;j++){\n\tint e;\n\tscanf(\"%d\",&e);\n\ts.st[i].push_back(e);\n      }\n    }\n  //  s.print();\n    s.co=0;\n    printf(\"%d\\n\",solve(s));\n    M.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define rep(i,n) for(int i=0;i<(n);++i)\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int INF = 100000000;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint main(){\n  int a=10;\n  int b=10;\n  while(a+b){\n  \tvector<int> size(3);\n    vector<int> val(3);\n  \tvector<vector<int>> data(3);\n    vector<vector<int>> now(3,vector<int>(15,0));\n    cin >> a >>b;\n    if(a+b==0)break;\n    rep(i,3){\n      int c;\n      cin >> c;\n      size[i] = c;\n      rep(j,c){\n        int x;\n        cin >> x;\n        data[i].push_back(x);\n      }\n    }\n    /*rep(i,3){\n      rep(j,data[i].size()){\n        cout << data[i][j] << \" \";\n      }\n      cout << endl;\n    }*/\n    int ret=INF; \n    if(size[0]==a||size[2]==a)ret=0;\n\t\tfor(int m=0;m<2;m++){\n\t\t\tint last=m;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tval[i]=size[i];\n\t\t\t\tfor(int j=0;j<size[i];j++)now[i][j]=data[i][j];\n\t\t\t}\n\t\t\tint k=0;\n\t\t\twhile(k<b&&val[0]!=a&&val[2]!=a){\n\t\t\t\tif(val[last+1]&&(val[last]==0||now[last][val[last]-1]<now[last+1][val[last+1]-1])){\n\t\t\t\t\tnow[last][val[last]++]=now[last+1][--val[last+1]];\n\t\t\t\t}else{\n\t\t\t\t\tnow[last+1][val[last+1]++]=now[last][--val[last]];\n\t\t\t\t}\n\t\t\t\tlast=!last;\n\t\t\t\tk++;\n\t\t\t\t//printf(\"%d %d %d\\n\",val[0],val[1],val[2]);\n\t\t\t}\n\t\t\tif(val[0]==a||val[2]==a)ret=min(ret,k);\n\t\t}\n\t\tif(ret==INF)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n\nint calc(vector<vector<int> > v, int n, int m) {\n\tint cnt = 0;\n\twhile(cnt <= m){\n\t\tint i = cnt % 2, j = i + 1;\n\t\tif(i % 2 == 0) {\n\t\t\tif(v[i].size() == n || v[i + 2].size() == n) {\n\t\t\t\treturn cnt;\n\t\t\t}\n\t\t} else {\n\t\t\tif(v[j].size() == n || v[2 - j].size() == n) {\n\t\t\t\treturn cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tauto it1 = v[i].end();\n\t\tauto it2 = v[j].end();\n\t\tif(v[i].empty()) {\n\t\t\tint y = *--it2;\n\t\t\tv[j].erase(it2);\n\t\t\tv[i].push_back(y);\n\t\t} else if(v[j].empty()) {\n\t\t\tint x = *--it1;\n\t\t\tv[i].erase(it1);\n\t\t\tv[j].push_back(x);\n\t\t} else {\n\t\t\tint x = *--it1, y = *--it2;\n\t\t\tif(x > y) {\n\t\t\t\tv[i].erase(it1);\t\n\t\t\t\tv[j].push_back(x);\n\t\t\t} else {\n\t\t\t\tv[j].erase(it2);\n\t\t\t\tv[i].push_back(y);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\treturn cnt;\n}\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m && (n || m)) {\n\t\tint c;\n\t\tvector<vector<int> >v(3);\n\t\trep(i,3) {\n\t\t\tcin >> c; \n\t\t\trep(j,c) {\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tv[i].push_back(t);\n\t\t\t}\n\t\t}\n\t\tint ans1 = calc(v, n, m);\n\t\tswap(v[0], v[2]);\n\t\tint ans2 = calc(v, n, m);\n\t\tint ans = min(ans1, ans2);\n\t\tif(ans <= m) {\n\t\t\tcout << ans;\n\t\t} else {\n\t\t\tcout << -1;\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main()\n{\n\tint pow3[16], c[16];\n\tint n, m, i, j, k, d, x, y, p;\n\n\tpow3[0] = 1;\n\tfor (i = 1; i <= 15; i++){\n\t\tpow3[i] = pow3[i - 1] * 3;/*i枚#0から#2または#2から#0へ移動するのに必要なステップ数*/\n\t}\n\twhile (1)\n\t{\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i != 3; ++i){\n\t\t\tcin >> j;\n\t\t\tfor (int l = 0; l != j; l++)\n\t\t\t{\t\n\t\t\t\tcin >> k;\n\t\t\t\tc[n - k] = i;/*番号付け替え,ハノイの塔に変換。大きいコップを小さい円盤にする*/\n\t\t\t}\n\t\t}\n\t\tp = 0;//全ての円盤が0の位置にあると仮定する\n\t\tx = 0;\n\t\tfor (i = n - 1; i >= 0; --i){//\n\t\t\td = abs(p - c[i]);//移動させる円盤の距離を求める。\n\t\t\t/*n = 3の時、i = 2で円盤2を#1に移動させるには円盤1と円盤0を#2に移動させる*/\n\t\t\tx += pow3[i] * d;\n\t\t\tif (d == 1){\n\t\t\t\tp = 2 - p;/*反対側に移動,距離がd = 1ならば0~i-1番の円盤を反対側に移動する。*/\n\t\t\t}\n\t\t}\n\t\ty = pow3[n] - 1 - x;\n\t\tif (x > y){\n\t\t\tx = y;\n\t\t}\n\t\tif (x > m)\n\t\t\tcout << -1 << endl;\n\t\telse\n\t\t\tcout << x << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nint n,m;\n\nint times(int A, int B, int C, int target)\n{\n    //printf(\"%d:%d:%d\\n\", A, B, C);\n    if( B & 1 )\n        return times(A>>1, B>>1, C>>1, -target) + 1 + times((A|B|C)>>1, 0, 0, 1);\n        //return std::min(times(A>>1,B>>1,C>>1,-1), times(A>>1,B>>1,C>>1,1)) + 1 + times(((A|B|C)>>1) , 0, 0, 1);\n    if( A & 1 )\n        if( target == -1 )\n            return times(A>>1, B>>1, C>>1, -1);\n        else\n            return times(A>>1, B>>1, C>>1, 1) + 1 + times(0, 0, ((A|B|C)>>1) , -1) + 1 + times(((A|B|C)>>1) , 0, 0, 1);\n    if( C & 1 )\n        if( target == 1 )\n            return times(A>>1, B>>1, C>>1, 1);\n        else\n            return times(A>>1, B>>1, C>>1, -1) + 1 + times(((A|B|C)>>1), 0, 0, 1) + 1 + times(0, 0, ((A|B|C)>>1), -1);\n    return 0;\n}\n\n\n\nint main(void)\n{\n    while(true)\n    {\n        int cups[3] = {0,0,0};\n\n        scanf(\"%d%d\",&n,&m);\n        if(!n && !m) break;\n\n        for(int i=0; i < 3; i++)\n        {\n            int c;\n            scanf(\"%d\", &c);\n            for(int j=0; j < c; j++)\n            {\n                int t;\n                scanf(\"%d\", &t);\n                cups[i] |= 1<<(t-1);\n            }\n        }\n\n        int res = std::min(times(cups[0], cups[1], cups[2], -1), times(cups[0], cups[1], cups[2],  1));\n        printf(\"%d\\n\", res <= m ? res : -1);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<string>\n#include<deque>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0)break;\n\t\t\n\t\tdeque<int> aa[3];\n\t\trep(i,3)aa[i].push_back(0);\n\t\t\n\t\trep(i,3){\n\t\t\tint c;\n\t\t\tcin>>c;\n\t\t\trep(j,c){\n\t\t\t\tint d;\n\t\t\t\tcin>>d;\n\t\t\t\taa[i].push_back(d);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=-1;\n\t\tint bef=-100;\n\t\tint befbef=-100;\n\t\treps(i,m){\n\t\t\tint a,b,c;\n\t\t\ta=aa[0][aa[0].size()-1];\n\t\t\tb=aa[1][aa[1].size()-1];\n\t\t\tc=aa[2][aa[2].size()-1];\n\t\t\t\n\t\t\tif(a < b){\n\t\t\t\taa[0].push_back(b);\n\t\t\t\taa[1].pop_back();\n\t\t\t}else \n\t\t\t\n\t\t\tif(b < c){\n\t\t\t\taa[1].push_back(c);\n\t\t\t\taa[2].pop_back();\n\t\t\t}else \n\t\t\t\n\t\t\tif( a > b && a > c){\n\t\t\t\tif(b<c){\n\t\t\t\t\taa[1].push_back(c);\n\t\t\t\t\taa[2].pop_back();\n\t\t\t\t}else{\n\t\t\t\t\taa[2].push_back(a);\n\t\t\t\t\taa[0].pop_back();\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\tputs(\"---------------------\");\n\t\t\trep(j,3){\n\t\t\t\trep(k,aa[j].size()){\n\t\t\t\t\tprintf(\"%d \",aa[j][k]);\n\t\t\t\t}puts(\"\");\n\t\t\t}\n\t\t\tputs(\"------------------------\");\n\t\t\t*/\n\t\t\tif(aa[1].size()==1 && aa[2].size()==1){\n\t\t\t\tans=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n/*\n\n3 10\n0\n1 1\n2 2 3\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<stdlib.h>\n#include<cstdio>\n#include<unordered_map>\n#include<unordered_set>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<stack>\n#include<map>\n#include<string.h>\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nsigned main() {\n\tvector<int>O;\n\tO.push_back(1); O.push_back(2); O.push_back(3);\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tint sum[2]{}; int S = 0;\n\t\tvector<int>V[3];\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tint d; cin >> d;\n\t\t\tfor (int e = 0; e < d; e++) {\n\t\t\t\tint c; cin >> c;\n\t\t\t\tV[i].push_back(c);\n\t\t\t}\n\t\t}\n\t\tint x = 0, y = 0;//???????????????\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tvector<int>q = V[0], w = V[1], p = V[2];\n\t\t\t\tif (abs(i - j) == 1) {\n\t\t\t\t\tif (V[i].size() && (V[j].size() == 0 || *V[i].rbegin() > *V[j].rbegin())) {\n\t\t\t\t\t\tV[j].push_back(*V[i].rbegin());\n\t\t\t\t\t\tV[i].pop_back();\n\t\t\t\t\t\tx = i; y = j;\n\t\t\t\t\t\tsum[S]++;\n\t\t\t\t\t\tfor (int K = 0; K <= b; K++) {\n\t\t\t\t\t\t\tif (V[1].size() == 0 && (V[0].size() == 0 || V[2].size() == 0))break;\n\t\t\t\t\t\t\tsum[S]++;\n\t\t\t\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\t\t\t\tif (abs(i - j) == 1) {\n\t\t\t\t\t\t\t\t\t\tif (V[i].size() && (V[j].size() == 0 || *V[i].rbegin() > *V[j].rbegin())) {\n\t\t\t\t\t\t\t\t\t\t\tif (y != i || x != j) {\n\t\t\t\t\t\t\t\t\t\t\t\tV[j].push_back(*V[i].rbegin());\n\t\t\t\t\t\t\t\t\t\t\t\tV[i].pop_back();\n\t\t\t\t\t\t\t\t\t\t\t\tx = i; y = j;\n\t\t\t\t\t\t\t\t\t\t\t\tgoto l;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tl:;\n\t\t\t\t\t\t\tif (K == b)sum[S] = 1 << 29;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tS++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tV[0] = q; V[1] = w; V[2] = p;\n\t\t\t}\n\t\t}\n\t\tint MIN = min(sum[0], sum[1]);\n\t\tif (MIN == 1 << 29)puts(\"-1\");\n\t\telse cout << MIN << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint calc(vector<int> cup, int m)\n{\n    int cnt = 0;\n    while (1) {\n        int i = cnt%2, j = i+1;\n        int p = 1;\n        while (p <= max(cup[i], cup[j])) p <<= 1;\n        p >>= 1;\n        if (!p) break;\n        cup[i] ^= p;\n        cup[j] ^= p;\n        cnt++;\n        if (cnt > m) return cnt;\n    }\n\n    return cnt;\n}\n\nint main()\n{\n    while (1) {\n        int n, m; cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        vector<int> cup(3);\n        loop (3, i) {\n            int c; cin >> c;\n            while (c--) {\n                int v; cin >> v;\n                cup[i] |= 1 << v--;\n            }\n        }\n        int ans = calc(cup, m);\n        swap(cup[0], cup[2]);\n        ans = min(ans, calc(cup, m));\n        cout << (ans <= m ? ans : -1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef int SI;\ntypedef pair<SI,SI> P;\ntypedef pair<SI,P> State;\n\n// 入力\nint n, m;\nSI cup[3];\n\nvoid debug(SI a, SI b, SI c, SI cnt){\n\tcout << \"[debug]\" << endl;\n\tcout << \"cnt:\" << cnt << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((a&i)? \"*\" : \"-\");\n\t}\n\tcout << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((b&i)? \"*\" : \"-\");\n\t}\n\tcout << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((c&i)? \"*\" : \"-\");\n\t}\n\tcout << endl << endl;;\n}\n\n// 一番上のカップを返す\nSI top(SI bits){\n\tfor(int i=(1<<n) ; i ; i >>= 1 ){\n\t\tif( i & bits ) return i;\n\t}\n\treturn 0;\n}\n\n// 探索\nint bfs(){\n\t// d[s] := cupの状態 s のときの手数\n\tmap<State,int> d;\n\tqueue<State> q;\n\t\n\tState s = State( (1<<n)-1 , P(0,0) );\n\tq.push(s);\n\td[s] = 0;\n\t\n\twhile( !q.empty() ){\n\t\tState now = q.front();\n\t\tint cnt = d[now];\n\t\tq.pop();\n\t\t\n\t\t// a,b,c := カップの状態\n\t\t// a_top,b_top,c_top := 一番上のカップ\n\t\tSI& a = now.first;\n\t\tSI& b = now.second.first;\n\t\tSI& c = now.second.second;\n\t\tSI a_top = top(a);\n\t\tSI b_top = top(b);\n\t\tSI c_top = top(c);\n\t\t//debug(a,b,c,cnt);\n\t\t\n\t\t// ゴールのとき\n\t\tif( b == cup[1] && ((a == cup[0] && c == cup[2]) || (a == cup[2] && c == cup[0])) ){\n\t\t\treturn cnt;\n\t\t}\n\t\t\n\t\t{\n\t\t\tSI a_, b_, c_;\n\t\t\tif( a_top < b_top ){ // B -> A の移動\n\t\t\t\ta_ = a + b_top;\n\t\t\t\tb_ = b - b_top;\n\t\t\t\tc_ = c;\n\t\t\t}else{ // A -> B の移動\n\t\t\t\ta_ = a - a_top;\n\t\t\t\tb_ = b + a_top;\n\t\t\t\tc_ = c;\n\t\t\t}\n\t\t\tState next = State(a_,P(b_,c_));\n\t\t\tif( !d.count(next) && cnt + 1 <= m ){\n\t\t\t\td[next] = cnt + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tSI a_, b_, c_;\n\t\t\tif( c_top < b_top ){ // B -> C の移動\n\t\t\t\ta_ = a;\n\t\t\t\tb_ = b - b_top;\n\t\t\t\tc_ = c + b_top;\n\t\t\t}else{ // C -> B の移動\n\t\t\t\ta_ = a;\n\t\t\t\tb_ = b + c_top;\n\t\t\t\tc_ = c - c_top;\n\t\t\t}\n\t\t\tState next = State(a_,P(b_,c_));\n\t\t\tif( !d.count(next) && cnt + 1 <= m ){\n\t\t\t\td[next] = cnt + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile( cin >> n >> m , n || m ){\n\t\t// 初期化\n\t\tcup[0] = cup[1] = cup[2] = 0;\n\t\t \n\t\tfor(int i=0 ; i < 3 ; i++ ){\n\t\t\tint k, e;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0 ; j < k ; j++ ){\n\t\t\t\tcin >> e;\n\t\t\t\tcup[i] |= (1 << (e-1));\n\t\t\t}\n\t\t}\n\t\tint ans = bfs();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint visited[50000000];\n\nint pow(int x,int n){\n\tint res = 1;\n\twhile(n>0){\t\t\n\t\tres *= x;\n\t\tif(n & 1) x = x*x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\nint conv(vector<int>& sets){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<=15;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * (pow(3,j)+eps);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,vector<int>& root, int* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tmemset(visited,-1,sizeof(visited));\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,sets,visited));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != -1 ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        {\n            int u = get_last(B);\n            int v = get_last(A);\n            if ( u > v ) {\n                int ret = solve( A | u, remove_last(B), C, turns + 1 );\n                if ( ret != -1 ) return ret;\n            }\n        }\n        {\n            int u = get_last(B);\n            int v = get_last(C);\n            if ( u > v ) {\n                int ret = solve( A, remove_last(B), C | u, turns + 1 );\n                if ( ret != -1 ) return ret;\n            }\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != -1 ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = 0; // solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = 0; // solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == -1 && ret2 == -1 ) {\n            cout << -1 << endl;\n        } else if ( ret1 != -1 && ret2 != -1 ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != -1 ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != -1 ) {\n            cout << ret2 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n\nint c[16];\nint n, m, i, j, k, x;\n\nint main(void){\n\tfor(; scanf(\"%d%d\", &n, &m), n; printf(\"%d\\n\", x > m ? -1 : x)){\n\t\tfor(i = 3; i--;)\n\t\t\tfor(scanf(\"%d\", &j); j--; c[n-k] = i)\n\t\t\t\tscanf(\"%d\", &k);\n\t\tx = 0;\n\t\tfor(i = n; i--; k += c[i])\n\t\t\tx += pow(3, i) * abs(k*2%4 - c[i]);\n\t\tx = fmin(x, pow(3, n) - 1 - x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<string>\n#include<climits>\n#include<deque>\n\nusing namespace std;\n\nint m;\nstack<int,vector<int> >A,B,C;\n\nint func(int);\n\nint main(void){\nint n,ans;\nstring s;\n\nwhile(cin >> n >> m,n|m){\nwhile(!A.empty())A.pop();\nwhile(!B.empty())B.pop();\nwhile(!C.empty())C.pop();\ncin.ignore();\ngetline(cin,s);\nfor(int i=0;i<s.size();i++)\nif('0'<=s[i]&&s[i]<='9' && i>0)A.push(s[i]-'0');\n\ngetline(cin,s);\nfor(int i=0;i<s.size();i++)\nif('0'<=s[i]&&s[i]<='9' && i>0)B.push(s[i]-'0');\n\ngetline(cin,s);\nfor(int i=0;i<s.size();i++)\nif('0'<=s[i]&&s[i]<='9' && i>0)C.push(s[i]-'0');\n\nans=func(0);\nif(ans==INT_MAX)cout << -1 << endl;\nelse cout << ans << endl;\n}\nreturn 0;\n}\n\nint func(int cnt){\n\nif(cnt>m)return INT_MAX;\n\nif(B.empty()&&(C.empty()||A.empty()))\nreturn cnt;\n\nint res=INT_MAX;\n\nif(!A.empty() && A.top()>=B.top()){\nB.push(A.top());\nA.pop();\nres=min(res,func(cnt+1));\nA.push(B.top());\nB.pop();\n}\n\nif(!B.empty()){\nif(B.top()>=C.top()){\nC.push(B.top());\nB.pop();\nres=min(res,func(cnt+1));\nB.push(C.top());\nC.pop();\n}\n\nif(B.top()>=A.top()){\nA.push(B.top());\nB.pop();\nres=min(res,func(cnt+1));\nB.push(A.top());\nA.pop();\n}\n}\n\nif(!C.empty() && C.top()>=B.top()){\nB.push(C.top());\nC.pop();\nres=min(res,func(cnt+1));\nC.push(B.top());\nB.pop();\n}\n\nreturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define SORT(c) sort((c).begin(),(c).end())\n#define IINF INT_MAX\n#define LLINF LLONG_MAX\n#define DEBUG false\n  \ntypedef long long ll;\ntypedef pair<int, int> ii;\n \nint main() {\n     \n    int n, m;\n    while(cin >> n >> m, n ,m){\n        vector<int> table(n);\n        vector<int> way(n, 1);\n        rep(i, 3){\n            int num;\n            cin >> num;\n            rep(j, num){\n                int tmp;\n                cin >> tmp;\n                table[tmp-1] = i;\n            }\n        }\n         \n        vector<int> now(n, 0);\n         \n        int ans = 0;\n        bool nn = false;//moved n-1th privious step\n        while(1){\n            bool flag = true;\n            rep(i, n){\n                if(table[i] != now[i]) flag = false;\n            }\n            if(flag) break;\n             \n            int num = IINF;\n            if(!nn){\n                num = n-1;\n            }\n            else{\n                vector<int> maxi(3, -1);\n                rep(i, n){\n                    maxi[now[i]] = i;\n                }\n                rep(i, 3){\n                    if(num > maxi[i] && maxi[i] > maxi[i+way[maxi[i]]]) num = maxi[i];\n                }\n            }   \n            now[num] += way[num];\n            if(now[num] != 1) way[num] *= -1;\n            nn = (num == n-1);\n            ans++;\n        }\n         \n        int tans = min(ans, (int)pow(3, n) - 1 - ans);\n        if(tans > m) cout << -1 << endl;\n        else cout << tans << endl;\n         \n    }\n     \n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<utility>\n#include<vector>\nusing namespace std;\nint main(){\n    int place,n,m,a[3][16]={0},na,nb,nc;\n    while(1){\n        for(int i=0;i<3;++i){\n            for(int j=0;j<16;++j){\n                a[i][j]=0;\n            }\n        }\n    cin>>n>>m;\n        if(n==0&&m==0)break;\n    cin>>na;\n    for(int i=0;i<na;++i){\n        cin>>a[0][i];\n    }\n    cin>>nb;\n    for(int i=0;i<nb;++i){\n        cin>>a[1][i];\n    }\n    cin>>nc;\n    for(int i=0;i<nc;++i){\n        cin>>a[2][i];\n    }\n    if(a[0][0]==1)place=0;\n    else if(a[2][0]==1)place=2;\n    else if(a[0][0]==1)place=0;\n    else if(a[2][0]==0)place=2;\n    else if(a[0][0]==0)place=0;\n    else if(a[0][0]>a[2][0])place=0;\n    else place=2;\n    int np,cnt=0,tar;\n    if(place==0)np=2;\n    else np=0;\n    if(place==0)tar=na;\n    else tar=nc;\n    for(int i=1;i<=tar;++i){\n        if(i!=a[place][i-1]){\n            cnt=tar-i;\n        }\n    }\n    int tyo=0;\n    if(a[np][0]!=0){\n        tyo=-4;\n    }\n    if(place==0){\n        cout<<(nb+nc*6+tyo>m?-1:nb+nc*6+tyo)<<endl;\n    }\n    else {\n        cout<<(nb+na*6+tyo>m?-1:nb+na*6+tyo)<<endl;\n    }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define min(a, b) (a > b ? b : a)\n\nint func(int a, int b, int c) {\n    if (b == 0 && c == 0)\n        return 0;\n    else if (a & 1)\n        return func(a >> 1, b >> 1, c >> 1);\n    else if (b & 1)\n        return func(c >> 1, b >> 1, a >> 1) + 1 + func(0, 0, (a | b | c) >> 1);\n    else\n        return func(a >> 1, b >> 1, c >> 1) + 1 + func(0, (a | b | c) >> 1, 0) +\n               func(0, a | b | c, 0);\n}\n\nint main() {\n    int n, m, tray[3];\n    while (std::cin >> n >> m && n && m) {\n        rep(i, 3) {\n            tray[i] = 0;\n            int k, num;\n            std::cin >> k;\n            rep(j, k) {\n                std::cin >> num;\n                tray[i] |= 1 << (num - 1);\n            }\n        }\n\n        int res = min(func(tray[0], tray[1], tray[2]),\n                      func(tray[2], tray[1], tray[0]));\n        std::cout << (res <= m ? res : -1) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nint toC(int A, int B, int C){\n  if(!A&&!B)return 0;\n  if(C&1)return toC(A>>1,B>>1,C>>1);\n  else if(B&1)return toC(C>>1,B>>1,A>>1)+1+toC((A|B|C)>>1,0,0);\n  else if(A&1)return toC(A>>1,B>>1,C>>1)+2*toC((A|B|C)>>1,0,0)+2;\n  return 0;\n}\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n,m;\n  while(cin>>n>>m,n||m){\n    int cup[3];// それぞれのトレイにあるカップの集合を表す\n    CLR(cup);\n    FOR(i,0,3){\n      int t;cin>>t;\n      FOR(j,0,t){\n        int a;cin>>a;\n        a--;\n        cup[i]|=1<<a;\n      }\n    }\n    //全てAカCにする\n    int x=min(toC(cup[0],cup[1],cup[2]),toC(cup[2],cup[1],cup[0]));\n    cout<<(x<=m?x:-1)<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint mp[5000000];\nint Hash(string s) {\n\tint cnt = 0, t = 1;\n\trep(i, s.size()) {\n\t\tcnt += (int)(s[i] - '0')*t;\n\t\tt *= 3;\n\t}\n\treturn cnt;\n}\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tmemset(mp, 0, sizeof(mp));\n\t\tstring in = \"000000000000000\";\n\t\trep(i, 3) {\n\t\t\tint len; scanf(\"%d\", &len);\n\t\t\trep(j, len) {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tin[--a] = i + '0';\n\t\t\t}\n\t\t}\n\t\tqueue<string>que;\n\t\tmp[Hash(in)] = 1;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tstring u = que.front(); que.pop();\n\t\t\tif (count(u.begin(), u.begin() + n, '0') == n ||\n\t\t\t\tcount(u.begin(), u.begin() + n, '2') == n) {\n\t\t\t\tprintf(\"%d\\n\", mp[Hash(u)] - 1);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (mp[Hash(u)] > m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tint fi = (int)u.rfind(i + '0', n - 1),\n\t\t\t\t\tfj = (int)u.rfind(j + '0', n - 1);\n\t\t\t\tif (fi == -1 || fi < fj)continue;\n\t\t\t\tstring v = u;\n\t\t\t\tv[fi] = j + '0';\n\t\t\t\tif (!mp[Hash(v)]) {\n\t\t\t\t\tmp[Hash(v)] = mp[Hash(u)] + 1;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define PB push_back\nusing namespace std;\nstruct Cup{\n    vector<vector<int> >A;\n    int cnt,b;\n    Cup(vector<vector<int> >A_,int cnt_,int b_){\n        A=A_;cnt=cnt_;b=b_;\n    }\n    Cup(){}\n};\nint main(){\n    int n,m;\n    while(cin>>n>>m,n||m){\n        queue<Cup>Q;\n        int mn=m+5;\n        int cncn=0;\n        vector<vector<int> >V(3);\n        V[0].PB(0);V[1].PB(0);V[2].PB(0);\n        for(int i=0;i<3;i++){\n            int s;\n            cin>>s;\n            for(int j=0;j<s;j++){\n                int d;\n                cin>>d;\n                V[i].PB(d);\n            }\n        }\n        int w;\n\n        if(V[0].back()<V[1].back()){\n            V[0].PB(V[1].back());\n            V[1].pop_back();\n            Q.push(Cup(V,1,1));\n            V[1].PB(V[0].back());\n            V[0].pop_back();\n        }\n        else if(V[0].back()!=0){\n            V[1].PB(V[0].back());\n            V[0].pop_back();\n            Q.push(Cup(V,1,0));\n            V[0].PB(V[1].back());\n            V[1].pop_back();\n        }\n\n\n        if(V[2].back()<V[1].back()){\n            V[2].PB(V[1].back());\n            V[1].pop_back();\n            Q.push(Cup(V,1,3));\n            V[1].PB(V[2].back());\n            V[2].pop_back();\n        }\n        else if(V[2].back()!=0){\n            V[1].PB(V[2].back());\n            V[2].pop_back();\n            Q.push(Cup(V,1,2));\n            V[2].PB(V[1].back());\n            V[1].pop_back();\n        }\n        if(V[0].size()==n+1||V[2].size()==0){\n            cout<<0<<endl;\n            continue;\n        }\n\n        while(Q.size()){\n            Cup x=Q.front();Q.pop();\n            if(x.cnt>m)continue;\n\n\n\n            if(x.A[0].size()==n+1)mn=min(mn,x.cnt);\n            if(x.A[2].size()==n+1)mn=min(mn,x.cnt);\n\n            if(x.b==2||x.b==3){\n                if(x.A[0].back()<x.A[1].back()){\n                    x.A[0].PB(x.A[1].back());\n                    x.A[1].pop_back();\n                    Q.push(Cup(x.A,x.cnt+1,1));\n                    x.A[1].PB(x.A[0].back());\n                    x.A[0].pop_back();\n                }\n                else if(x.A[0].back()!=0){\n                    x.A[1].PB(x.A[0].back());\n                    x.A[0].pop_back();\n                    Q.push(Cup(x.A,x.cnt+1,0));\n                    x.A[0].PB(x.A[1].back());\n                    x.A[1].pop_back();\n                }\n            }\n            else{\n                if(x.A[2].back()<x.A[1].back()){\n                    x.A[2].PB(x.A[1].back());\n                    x.A[1].pop_back();\n                    Q.push(Cup(x.A,x.cnt+1,3));\n                    x.A[1].PB(x.A[2].back());\n                    x.A[2].pop_back();\n                }\n                else if(x.A[2].back()!=0){\n                    x.A[1].PB(x.A[2].back());\n                    x.A[2].pop_back();\n                    Q.push(Cup(x.A,x.cnt+1,2));\n                    x.A[2].PB(x.A[1].back());\n                    x.A[1].pop_back();\n                }\n            }\n\n        }\n        if(mn==m+5)mn=-1;\n        cout<<mn<<endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst ll mod = 4e10;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\ntemplate <typename T>\nT power(T a, T n, T mod) {\n  T res = 1;\n  T tmp = n;\n  T curr = a;\n  while(tmp){\n    if(tmp % 2 == 1){\n      res = (T)((ll)res * curr % mod);\n    }\n    curr = (T)((ll)curr * curr % mod);\n    tmp >>= 1;\n  }\n  return res;\n}\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  int n, m;\n  cin >> n >> m;\n  while(n > 0 and m > 0){\n    vector<int> st(3, 0);\n    rep(i, 3){\n      INT(c);\n      rep(j, c){\n        INT(x); x--; st[i] |= bit(x);\n      }\n    }\n    auto calc = [&](vector<int> v) -> ll{\n      ll res = 0;\n      rep(i, n){\n        int tat = -1, cat = -1;\n        rep(j, 3){\n          if(st[j] & bit(i))tat = j;\n          if(v[j] & bit(i))cat = j;\n        }\n        if(tat == cat)continue;\n        if(cat == 0){\n          if(tat == 1){\n            res += power<ll>(3, n - 1 - i, mod);\n            v[cat] ^= ((bit(n)-1) ^ (bit(i)-1));\n            v[tat] ^= bit(i);\n            v[2] ^= ((bit(n)-1) ^ (bit(i+1)-1));\n          }else{\n            res += 2 * power<ll>(3, n - 1 - i, mod);\n            v[cat] ^= bit(i);\n            v[tat] ^= bit(i);\n          }\n        }else if(cat == 2){\n          if(tat == 1){\n            res += power<ll>(3, n - 1 - i, mod);\n            v[cat] ^= ((bit(n)-1) ^ (bit(i)-1));\n            v[tat] ^= bit(i);\n            v[0] ^= ((bit(n)-1) ^ (bit(i+1)-1));\n          }else{\n            res += 2 * power<ll>(3, n - 1 - i, mod);\n            v[cat] ^= bit(i);\n            v[tat] ^= bit(i);\n          }\n        }\n      }\n      return res;\n    };\n    vector<int> cur(3, 0);\n    cur[0] = bit(n) - 1;\n    ll res = calc(cur);\n    swap(cur[0], cur[2]);\n    res = min(res, calc(cur));\n    cout << (res <= m ? res: -1) << endl;\n    cin >> n >> m;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint nn = 1, an, bn, cn, a[20], b[20], c[20], total = 0, f = 1;\n\nstruct mm{\n\tchar ch;\n\tint nu;\n};\n\nstruct mm m1, m2;\n\nint calculation(int min, int max){\n\tif(min == max)return 0;\n\tif(min < max)int sum = calculation(++min, max) * 3 + 2;\n\treturn sum;\n}\n\nint move(int flag){\n\tint number;\n\tif(flag == 0){\n\t\tnumber = an - m1.nu + 1;\n\t\tfor(int i = 0;i < number;i++)c[++cn] = a[an--];\n\t}\n\tif(flag == 1){\n\t\tnumber = cn - m1.nu + 1;\n\t\tfor(int i = 0;i < number;i++)a[++an] = c[cn--];\n\t}\n\tcalculation(0, number);\n\treturn 0;\n}\n\nint sort(){\n\tif(m1.ch == m2.ch)return 0;\n\tif(m2.ch == 'b'){\n\t\tif(m1.ch == 'a')c[++cn] = b[bn--], move(0); //???\n\t\tif(m1.ch == 'c')a[++an] = a[an--], move(1); //???\n\t}\n\treturn 0;\n}\n\nint solve(int max){\n\tfor(int i = 0;i < an;i++){\n\t\tif(a[i] == max)m1.ch = 'a',m1.nu = i;\n\t\tif(a[i] == max - 1)m2.ch = 'a', m2.nu = i;\n\t}\n\tfor(int i = 0;i < bn;i++){\n\t\tif(b[i] == max)m1.ch = 'b',m1.nu = i;\n\t\tif(b[i] == max - 1)m2.ch = 'b', m2.nu = i;\n\t}\n\tfor(int i = 0;i < cn;i++){\n\t\tif(c[i] == max)m1.ch = 'c',m1.nu = i;\n\t\tif(c[i] == max - 1)m2.ch = 'c', m2.nu = i;\n\t}\n\tif(f == 1 && m1.nu == bn){\n\t\tif(m2.ch == 'a'){\n\t\t\ta[++an] = b[bn--];\n\t\t}else if(m2.ch == 'c'){\n\t\t\tc[++cn] = b[bn--];\n\t\t}\n\t}else{\n\t\tsort();\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n, m, max;\n\tint a[20], b[20], c[20];\n\tscanf(\"%d %d\",&n, &m);\n\t\n\tscanf(\"%d\", &an);\n\tfor(int i = 0;i < an;i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tif(a[i] > max)max = a[i];\n\t}\n\tscanf(\"%d\", &bn);\n\tfor(int i = 0;i < bn;i++){\n\t\tscanf(\"%d\", &b[i]);\n\t\tif(b[i] > max)max = b[i];\n\t}\n\tscanf(\"%d\", &cn);\n\tfor(int i = 0;i < cn;i++){\n\t\tscanf(\"%d\", &c[i]);\n\t\tif(c[i] > max)max = c[i];\n\t}\n\t\n\tsolve(max);\n\t\n\tprintf(\"%d %d\",n, m);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\nusing namespace std;\nset<pair<string,string > >hash;\n\nint main()\n{\n  int n,m;\n  for(;cin>>n>>m,n;)\n    {\n      string table[3];\n      string finish;\n      for(int i=1;i<=n;i++)\n\t{\n\t  finish+=('0'+i);\n\t}\n      for(int i=0;i<3;i++)\n\t{\n\t  int size;\n\t  cin>>size;\n\t  for(int j=0;j<size;j++)\n\t    {\n\t      char tmp;\n\t      cin>>tmp;\n\t      table[i]+=tmp;\n\t    }\n\t}\n      //stack,step;\n      queue<pair<pair<string,string> ,pair<string ,int> > > qu;\n      qu.push(make_pair(make_pair(table[0],table[1]),make_pair(table[2],0)));\n      int ans=-1;\n\n      while(!qu.empty())\n\t{\n\t  string a=qu.front().first.first;\n\t  string b=qu.front().first.second;\n\t  string c=qu.front().second.first;\n\t  int step=qu.front().second.second;\n\t  qu.pop();\n\t  /*\n\t  cout<<\"===\"<<endl;\n\t  cout<<a<<endl;\n\t  cout<<b<<endl;\n\t  cout<<c<<endl;\n\t  cout<<step<<endl;\n\t  cout<<\"===\"<<endl;\n\t  */\n\t  if(a==finish || c==finish)\n\t    {\n\t      ans=step;\n\t      break;\n\t    }\n\n\t  if(hash.find(make_pair(a,c))!=hash.end())\n\t    continue;\n\t  hash.insert(make_pair(a,c));\n\n\t  if(step>=m)\n\t    continue;\n\n\n\t  char tmp;\n\t  string aa,bb,cc;\n\t  if(a!=\"\")\n\t    {\n\t      if(b==\"\"||a[a.size()-1]>b[b.size()-1] )\n\t\t{\n\t\t  tmp=a[a.size()-1];\n\t\t  aa=a.substr(0,a.size()-1);\n\t\t  bb=b+tmp;\n\t\t  cc=c;\n\t\t  if(hash.find(make_pair(aa,cc))==hash.end())\n\t\t    qu.push(make_pair(make_pair(aa,bb),make_pair(cc,step+1)));\n\t\t}\n\t    }\n\n\t  if(b!=\"\")\n\t    {\n\t      if(a==\"\"||a[a.size()-1]<b[b.size()-1] )\n\t\t{\n\t\t  tmp=b[b.size()-1];\n\t\t  bb=b.substr(0,b.size()-1);\n\t\t  aa=a+tmp;\n\t\t  cc=c;\n\t\t  if(hash.find(make_pair(aa,cc))==hash.end())\n\t\t    qu.push(make_pair(make_pair(aa,bb),make_pair(cc,step+1)));\n\n\t\t}\n\t      if(c==\"\"||c[c.size()-1]<b[b.size()-1] )\n\t\t{\n\t\t  tmp=b[b.size()-1];\n\t\t  bb=b.substr(0,b.size()-1);\n\t\t  cc=c+tmp;\n\t\t  aa=a;\n\n\t\t  if(hash.find(make_pair(aa,cc))==hash.end())\n\t\t    qu.push(make_pair(make_pair(aa,bb),make_pair(cc,step+1)));\n\t\t}\n\n\t    }\n\n\n\t  if(c!=\"\")\n\t    {\n\t      if(b==\"\"||b[b.size()-1]<c[c.size()-1] )\n\t\t{\n\t\t  tmp=c[c.size()-1];\n\t\t  cc=c.substr(0,c.size()-1);\n\t\t  bb=b+tmp;\n\t\t  aa=a;\n\t\t  if(hash.find(make_pair(aa,cc))==hash.end())\n\t\t    qu.push(make_pair(make_pair(aa,bb),make_pair(cc,step+1)));\n\t\t}\n\n\t    }\n\n\n\n\t}\n      cout<<ans<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<vector>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,m,ans; vector<int> cup[3];\nvoid move(int k,int t){\n\tif(k>n||ans>m)return;\n\tint pk,o;\n\trep(i,3)if(!cup[i].empty()&&cup[i][cup[i].size()-1]==k)pk=i;\n\trep(i,3)if(i!=pk&&i!=t)o=i;\n\tcup[pk].pop_back();\n\tif(pk==t){\n\t\tmove(k+1,t);\n\t\tcup[pk].push_back(k);\n\t\treturn;\n\t}\n\tans++;\n\tif(abs(pk-t)==1){\n\t\tmove(k+1,o);\n\t\tcup[t].push_back(k);\n\t}else{\n\t\tmove(k+1,t);\n\t\tcup[o].push_back(k);\n\t}\n\tmove(k,t);\n}\nint main(){\n\twhile(cin>>n>>m,n){\n\t\trep(i,3)cup[i].clear();\n\t\trep(i,3){\n\t\t\tint k,l;cin>>k;\n\t\t\trep(j,k)cin>>l,cup[i].push_back(l);\n\t\t\treverse(cup[i].begin(),cup[i].end());\n\t\t}\n\t\tans=0;move(1,0); int pw=1;rep(i,n)pw*=3;\n\t\tcout<<(ans>m?-1:min(ans,pw-1-ans))<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokann ga bokka--nn!!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint n,m;\nint rec(vector<int> cur[3],int cou,int rev)\n{\n\tvector<int> cpy[3];\n\tfor(int i=0;i<3;i++) cpy[i]=cur[i];\n\tif(cur[0].size()==n || cur[2].size()==n) return cou;\n\tif(cou>=m) return INF;\n\tint ret=INF;\n\tif(rev==-1 || rev==1)\n\t{\n\t\tif(cur[0].size()==0 || (cur[0].size() >0 && cur[1].size()> 0 && cur[1][cur[1].size()-1]>cur[0][cur[0].size()-1]))\n\t\t{\n\t\t\tcur[0].pb(cur[1][cur[1].size()-1]);\n\t\t\tcur[1].resize(cur[1].size()-1);\n\t\t}\n\t\telse if(cur[1].size()==0 || (cur[0].size() >0 && cur[1].size()> 0 && cur[1][cur[1].size()-1]<cur[0][cur[0].size()-1]))\n\t\t{\n\t\t\tcur[1].pb(cur[0][cur[0].size()-1]);\n\t\t\tcur[0].resize(cur[0].size()-1);\n\t\t}\n\t\tint f=rec(cur,cou+1,0);\n\n\t\tret=min(ret,f);\n\t}\n\t\t\n\tfor(int i=0;i<3;i++) cur[i]=cpy[i];\n\tif(rev==-1 || rev==0)\n\t{\n\t\tif(cur[2].size()==0 || (cur[2].size() >0 && cur[1].size()> 0 && cur[1][cur[1].size()-1]>cur[2][cur[2].size()-1]))\n\t\t{\n\t\t\tcur[2].pb(cur[1][cur[1].size()-1]);\n\t\t\tcur[1].resize(cur[1].size()-1);\n\t\t}\n\t\telse if(cur[1].size()==0 || (cur[2].size() >0 && cur[1].size()> 0 && cur[1][cur[1].size()-1]<cur[2][cur[2].size()-1]))\n\t\t{\n\t\t\tcur[1].pb(cur[2][cur[2].size()-1]);\n\t\t\tcur[2].resize(cur[2].size()-1);\n\t\t}\n\t\tint f=rec(cur,cou+1,1);\n\n\t\tret=min(ret,f);\n\t}\n\tif(ret==INF) return INF;\n\treturn ret;\n}\n\nint main(){\n\twhile(1)\n\t{\n\t\tcin >> n >> m;\n\t\tif(!n) return 0;\n\t\tvector<int>tray[3];\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t{\n\t\t\t\tint x;\n\t\t\t\tcin >> x;\n\t\t\t\ttray[i].pb(x);\n\t\t\t}\n\t\t}\n\t\tint g=rec(tray,0,-1);\n\t\tcout <<(g==INF?-1:g) << endl;\n\t}\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <stack>\n#include <algorithm>\nusing namespace std;\nint n, m, in;\nstack<int> s[3];\nvoid input(stack<int>& s) {\n    int num; scanf(\"%d\",&num);\n    for (int i=0; i<num; i++) {\n        int x; scanf(\"%d\",&x);\n        s.push(x);\n    }\n}\nvoid clear(stack<int>& s) {\n    while (!s.empty()) s.pop();\n}\n// 0-a 1-b 2-c\nint dfs(int from, int to, int cnt) {\n    if (cnt==m&&s[0].size()!=n&&s[2].size()!=n) return m+1;\n    if (s[0].size()==n||s[2].size()==n) return cnt;\n    int res=m+1;\n    for (int i=0; i<3; i++) {\n        for (int j=0; j<3; j++) {\n            if (i==to&&j==from) continue;\n            if (s[i].empty()) continue;\n            if (abs(i-j)!=1) continue;\n            if (!s[j].empty()&&s[i].top()<s[j].top()) continue;\n            s[j].push(s[i].top()); s[i].pop();\n            res=min(res,dfs(i,j,cnt+1));\n            s[i].push(s[j].top()); s[j].pop();\n        }\n    }\n    return res;\n}\nint main() {\n    while (scanf(\"%d%d\",&n,&m)) {\n        if (!n&&!m) break;\n        clear(s[0]); clear(s[1]); clear(s[2]);\n        input(s[0]); input(s[1]); input(s[2]);\n        int res=m+1;\n        if (s[0].size()==n||s[2].size()==n) {\n            puts(\"0\");\n            continue;\n        }\n        for (int i=0; i<3; i++) {\n            for (int j=0; j<3; j++) {                               // iツつゥツづァj\n                if (s[i].empty()) continue;                         // ツづづィツつスツつ「ツづつアツづォツつェツ凝ウ\n                if (abs(i-j)!=1) continue;                          // ツ療猟静堋つオツづづ按つ「\n                if (!s[j].empty()&&s[i].top()<s[j].top()) continue; // ツ置ツつォツつスツつ「ツづつアツづォツづ可置ツつッツづ按つ「\n                s[j].push(s[i].top()); s[i].pop();\n                res=min(res, dfs(i,j,1));\n                s[i].push(s[j].top()); s[j].pop();\n            }\n        }\n        printf(\"%d\\n\",res==m+1?-1:res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n\nusing namespace std;\ntypedef long long ll;\n\n#define mod 1000000007\n#define INF 2000000000\n#define LLINF 4000000000000000000\n#define SIZE 10000\n\nint mo[5] = {0,1,0,-1,0};\n\nvoid calc(int n,int m){\n    int a,c,i0,ans=INF;\n    \n    stack<int> in[3];\n    \n    for(int i=0;i<3;i++){\n        in[i].push(0);\n    }\n    \n    for(int i=0;i<3;i++){\n        scanf(\"%d\",&a);\n        \n        for(int j=0;j<a;j++){\n            scanf(\"%d\",&c);\n            in[i].push(c);\n        }\n    }\n    \n    for(int i=0;i<2;i++){\n        stack<int> tray[3];\n        int back=-1;\n        if(i==1) back = i0;\n        \n        for(int j=0;j<3;j++){\n            tray[j] = in[j];\n        }\n        \n        for(int j=0;j<m;j++){\n            \n            for(int k=0;k<2;k++){\n                \n                if(tray[k].size() > 1){\n                    if(tray[k].top() > tray[k+1].top() && k!=back){\n                        tray[k+1].push(tray[k].top());\n                        tray[k].pop();\n                        back=k;\n                        break;\n                    }\n                }\n                \n                if(tray[k+1].size() > 1){\n                    if(tray[k].top() < tray[k+1].top() && k!=back){\n                        tray[k].push(tray[k+1].top());\n                        tray[k+1].pop();\n                        back=k;\n                        break;\n                    }\n                }\n            }\n            \n            if(i==0 && j==0)\n                i0=back;\n            \n            if(tray[0].size()==n+1 || tray[2].size()==n+1){\n                ans = min(ans,j+1);\n                break;\n            }\n        }\n    }\n    if(ans < INF)\n        printf(\"%d\\n\",ans);\n    else\n        puts(\"-1\");\n    \n}\n\nint main(){\n    int n,m;\n    \n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0) break;\n        calc(n,m);\n    }\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvoid input(vector<int> &);\nint main() {\n\tint n, m;\n\tvector<int> table;\n\tint point[] = { 0,2 };\n\tint move[] = { 2,0,0 };\n\twhile (cin >> n >> m&&n != 0) {\n\t\ttable.resize(n + 1);\n\t\tinput(table);\n\t\tint ans = (1 << 31) - 1;\n\t\tint default = 1;\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tdefault *= 3;\n\t\t}\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tint stock = default;\n\t\t\tint place = point[i];\n\t\t\tint dnum = 0;\n\t\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\t\tif (abs(table[j]- place)==1) {\n\t\t\t\t\tdnum += stock;\n\t\t\t\t\tplace = move[place];\n\t\t\t\t}\n\t\t\t\telse if (abs(table[j] - place)==2) {\n\t\t\t\t\tdnum += stock * 2;\n\t\t\t\t}\n\t\t\t\tstock /= 3;\n\t\t\t}\n\t\t\tans = min(ans, dnum);\n\t\t}\n\t\tcout << (ans <= m ? ans : -1) << endl;\n\t}\n\treturn 0;\n}\n\nvoid input(vector<int > &table) {\n\tfor (int i = 0; i < 3; ++i) {\n\t\tint time;\n\t\tcin >> time;\n\t\tfor (int j = 0; j < time; ++j) {\n\t\t\tint num;\n\t\t\tcin >> num;\n\t\t\ttable[num] = i;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<vector<int>,int> State;\n\nstring tobin(int n)\n{\n\tstring s;\n\tfor(int i=15;i--;)\n\t\ts+='0'+(n>>i&1);\n\treturn s;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n|m;){\n\t\tvector<int> a(3);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint j; cin>>j;\n\t\t\twhile(j--){\n\t\t\t\tint x; cin>>x;\n\t\t\t\ta[i]|=1<<(n-x);\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<pair<vector<int>,int> > q;\n\t\tq.push(make_pair(a,0));\n\t\tset<vector<int> > vis;\n\t\tint res=-1;\n\t\twhile(q.size()){\n\t\t\tvector<int> ca=q.front().first;\n\t\t\tint cc=q.front().second;\n\t\t\tq.pop();\n\t\t\tif(vis.find(ca)!=vis.end())\n\t\t\t\tcontinue;\n\t\t\tvis.insert(ca);\n\t\t\t\n\t\t\tif(ca[0]==(1<<n)-1 || ca[2]==(1<<n)-1){\n\t\t\t\tres=cc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0,j=1;i<2;i++,j++){\n\t\t\t\tint bit=ca[i]&&ca[j]?min(ca[i]&-ca[i],ca[j]&-ca[j]):max(ca[i]&-ca[i],ca[j]&-ca[j]);\n\t\t\t\tca[i]^=bit; ca[j]^=bit;\n\t\t\t\tq.push(make_pair(ca,cc+1));\n\t\t\t\tca[i]^=bit; ca[j]^=bit;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<(res<=m?res:-1)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint main(){\n    while(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n == 0 && m == 0 ) break;\n\tset< pair<short,short> > s;\n\tvector< vector<int> > cup(3);\n\tREP(i,3){\n\t    int t;\n\t    cin >> t;\n\t    REP(j,t){\n\t\tint temp;\n\t\tcin >> temp;\n\t\tcup[i].PB(temp);\n\t    }\n\t}\n\tqueue< vector< vector<int> > > q;\n\tqueue<int> qv;\n\tq.push(cup);\n\tqv.push(0);\n\tint ans = 2000000000;\n\twhile(!q.empty()){\n\t    cup = q.front();\n\t    int v = qv.front();\n\t    q.pop();\n\t    qv.pop();\n\t    pair<short,short> temp(0,0);\n\t    REP(j,cup[0].size()){\n\t\ttemp.first += 1<<(cup[0][j]-1);\n\t    }\n\t    REP(j,cup[1].size()){\n\t\ttemp.second += 1<<(cup[1][j]-1);\n\t    }\n\n\t    if(s.find(temp) != s.end()) continue;\n\t    else s.insert(temp);\n\t    if(cup[1].size() == 0 && (cup[0].size() == 0||cup[2].size() == 0)){\n\t\tans = v;\n \t\tbreak;\n\t    }\n\t    REP(i,2){\n\t\tif(cup[i].size() > 0 && (cup[i+1].size() == 0 || cup[i].back() > cup[i+1].back())){\n\t\t    cup[i+1].PB(cup[i].back());\n\t\t    cup[i].erase(cup[i].end()-1);\n\t\t    q.push(cup);\n\t\t    qv.push(v+1);\n\t\t    cup[i].PB(cup[i+1].back());\n\t\t    cup[i+1].erase(cup[i+1].end()-1);\n\t\t}\n\t\tif(cup[i+1].size() > 0 && (cup[i].size() == 0 || cup[i].back() < cup[i+1].back())){\n\t\t    cup[i].PB(cup[i+1].back());\n\t\t    cup[i+1].erase(cup[i+1].end()-1);\n\t\t    q.push(cup);\n\t\t    qv.push(v+1);\n\t\t    cup[i+1].PB(cup[i].back());\n\t\t    cup[i].erase(cup[i].end()-1);\n\t\t}\n\t    }\n\t}\n\tif(ans > m) ans = -1;\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define AB 1\n#define BC 3\n#define INF 1<<30\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nint n, m;\n\nstack<int> tray[3];\n\nbool is_success (void )\n{\n\treturn (tray[0].size() == n || tray[2].size() == n ); \n}\n\nint dfs (int curr, int prev )\n{\n\tint ans = INF;\n\n\tif (curr > m ){\n\t\treturn ans;\n\t} // end if\n\n\tif (is_success () ){\n\t\tans = min (ans, curr );\n\t\treturn ans;\n\t} // end if\n\n\trep (i, 3 ){\n\t\tif (!tray[i].empty() ){\n\t\t\tint cup = tray[i].top();\n\t\t\tif (i == 0 && prev != AB ){\n\t\t\t\tif (tray[1].empty() || cup > tray[1].top() ){\n\t\t\t\t\ttray[1].push (cup );\n\t\t\t\t\ttray[i].pop();\n\t\t\t\t\tans = min (ans, dfs (curr+1, AB ) );\n\t\t\t\t\ttray[i].push (cup );\n\t\t\t\t\ttray[1].pop();\n\t\t\t\t} // end if\t\t\t\t\t\t\n\t\t\t}else\n\t\t\tif (i == 2 && prev != BC ){\n\t\t\t\tif (tray[1].empty() || cup > tray[1].top() ){\n\t\t\t\t\ttray[1].push (cup );\n\t\t\t\t\ttray[i].pop();\n\t\t\t\t\tans = min (ans, dfs (curr+1, BC ) );\n\t\t\t\t\ttray[i].push (cup );\n\t\t\t\t\ttray[1].pop();\n\t\t\t\t} // end if\t\t\t\t\t\t\n\t\t\t}else\n\t\t\tif (i == 1 ){\n\t\t\t\tif (prev != AB && (tray[0].empty() || cup > tray[0].top() ) ){\n\t\t\t\t\ttray[0].push (cup );\n\t\t\t\t\ttray[i].pop();\n\t\t\t\t\tans = min (ans, dfs (curr+1, AB ) );\n\t\t\t\t\ttray[i].push (cup );\n\t\t\t\t\ttray[0].pop();\n\t\t\t\t}else\n\t\t\t\tif (prev != BC && (tray[2].empty() || cup > tray[2].top() ) ){\n\t\t\t\t\ttray[2].push (cup );\n\t\t\t\t\ttray[i].pop();\n\t\t\t\t\tans = min (ans, dfs (curr+1, BC ) );\n\t\t\t\t\ttray[i].push (cup );\n\t\t\t\t\ttray[2].pop();\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // en if\n\t} // end rep\n\n\treturn ans;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.cup\", \"r\", stdin );\n\twhile (scanf (\"%d %d\", &n, &m ), n, m ){\n\t\trep (i, 3 ) while (!tray[i].empty() ) tray[i].pop();\n\t\trep (i, 3 ){\n\t\t\tint in;\n\t\t\tscanf (\"%d\", &in );\n\t\t\trep (j, in ){\n\t\t\t\tint cup;\n\t\t\t\tscanf (\"%d\", &cup );\n\t\t\t\ttray[i].push (cup );\n\t\t\t} // end rep\n\t\t} // end rep\n\t\tint res = dfs (0, 0 );\n\t\tif (res == INF ){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << res << endl;\n\t\t} // end if\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for(int i = 0;i < (n);i++)\n#define all(c) (c).begin(),(c).end()\n#define min(a, b) ((a) <= (b) ? (a) : (b))\n#define max(a, b) ((a) >= (b) ? (a) : (b))\n\ntypedef unsigned int uint;\n\nusing namespace std;\n\ntypedef vector<uint> tray_set;\n\nint n, m;\n\nvoid print_tray(tray_set &trays) {\n  for(uint& t : trays) {\n    rep(i, 16) {\n      if(t >> i & 1u) cout << i << ' ';\n    }\n    cout << endl;\n  }\n  cout << \"---------------\" << endl;\n}\n\nint top_cop(uint tray) {\n  for(int i = 15;i >= 0;i--) {\n    if(tray >> i & 1u) return i;\n  }\n  return -1;\n}\n\nvoid move_cop(uint *from, uint *to) {\n  uint x = 1u << top_cop(*from);\n  *from = x ^ *from;\n  *to   = x | *to;\n}\n\nint count_cop(uint tray) {\n  int count = 0;\n  for(; tray != 0 ; tray &= tray - 1) count++;\n  return count;\n}\n\nbool finished(tray_set &trays) {\n  return count_cop(trays[0]) == n || count_cop(trays[2]) == n;\n}\n\nint solve(tray_set trays, tray_set prev) {\n  tray_set temp(3);\n\n  rep(count, m) {\n    if(finished(trays)) return count + 1;\n\n    //print_tray(trays);\n\n    bool moved = false;\n\n    rep(i, 3) {\n      if(trays[i] == 0) continue;\n\n      rep(j, 3) {\n        if(abs(i - j) >= 2 || i == j) continue;\n\n        if(trays[j] == 0 || top_cop(trays[i]) > top_cop(trays[j])) {\n          temp = trays;\n\n          move_cop(&temp[i], &temp[j]);\n          if(temp != prev) {\n            prev = trays;\n            trays = temp;\n\n            moved = true;\n            break;\n          }\n        }\n      }\n      if(moved) break;\n    }\n    if(!moved) return -1;\n  }\n\n  return -1;\n}\n\nint main() {\n  while(true) {\n    cin >> n >> m;\n    if(n == 0 && m == 0) break;\n\n    tray_set trays(3, 0);\n    rep(i, 3) {\n      int a;\n      cin >> a;\n      rep(j, a) {\n        int b;\n        cin >> b;\n        trays[i] |= 1u << b;\n      }\n    }\n\n    if(finished(trays)) {\n      cout << 0 << endl;\n      continue;\n    }\n\n    vector<tray_set> sets;\n    rep(i, 3) {\n      if(trays[i] == 0) continue;\n\n      rep(j, 3) {\n        if(abs(i - j) >= 2 || i == j) continue;\n\n        if(trays[j] == 0 || top_cop(trays[i]) > top_cop(trays[j])) {\n          tray_set new_trays = trays;\n          move_cop(&new_trays[i], &new_trays[j]);\n          sets.push_back(new_trays);\n        }\n      }\n    }\n\n    int ans1 = solve(sets[0], trays), ans2 = -1;\n    if(sets.size() > 1) ans2 = solve(sets[1], trays);\n\n    //cout << ans1 << ' ' << ans2 << endl;\n\n    if(ans1 == -1 && ans2 == -1) cout << -1 << endl;\n    else if(ans1 != -1 && ans2 != -1) cout << min(ans1, ans2) << endl;\n    else cout << max(ans1, ans2) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> mat;\n\nconst int INF = 1 << 28;\nint n, m;\n\nbool check(mat &v) {\n    if (v[0].size() == n + 1 || v[2].size() == n + 1)\n        return true;\n    return false;\n}\n\nstring stom(mat &v) {\n    string res;\n    res = \"\";\n    for (int i = 0; i < 3; i++) {\n        for (auto j : v[i]) {\n            if (j < 0) continue;\n            res = res + (char)('0' + j);\n        }\n        for (int j = v[i].size(); j <= n; j++) {\n            res = res + '0';\n        }\n    }\n    return res;\n}\n\nmap<string , int> M;\n\nint dfs(mat &v, int d) {\n    string V = stom(v);\n    if (d > m) return M[V] = INF;\n    if (check(v)) return M[V] = d;\n    if (M.find(V) != M.end()) return M[V];\n    M[V] = 1 << 28;\n\n    // cout << \"# \" << d << endl;\n    for (int i = 0; i < 3; i++) {\n        if (v[i].size() > 1) {\n            for (int j = 0; j < 3; j++) {\n                // cout << \"form: \" << i << \", to: \" << j << endl;\n                if (i == j || v[i][v[i].size()-1] < v[j][v[j].size() - 1]) continue;\n                if (i == 0 && j == 2) continue;\n                if (i == 2 && j == 0) continue;\n                v[j].push_back(v[i][v[i].size() - 1]);\n                v[i].erase(v[i].end() - 1);\n                M[V] = min(M[V], dfs(v, d + 1));\n                v[i].push_back(v[j][v[j].size() - 1]);\n                v[j].erase(v[j].end() - 1);\n            }\n        }\n    }\n\n    return M[V];\n}\n\n\nint main() {\n    while (cin >> n >> m, n || m) {\n        mat v(3);\n        for (int i = 0; i < 3; i++) {\n            int n_; cin >> n_;\n            v[i].push_back(-1);\n            for (int j = 0; j < n_; j++) {\n                int x; cin >> x;\n                v[i].push_back(x);\n            }\n        }\n\n        int res = dfs(v, 0);\n        cout << (res > m ? -1 : res) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n,m,step;\n\nvoid move(int* tray,int i,int u,int d)\n{\n  if(i>n) return;\n\n  if(tray[i]==u){\n    move(tray,i+1,u,d);\n    tray[i]=1;\n    step++;\n    if(step>m) return;\n    //    cout <<\"step \"<< step <<\" | \"<< i <<\":\"<< u << \" to \" << 1 << endl;\n  }\n\n  if(tray[i]==1){\n    move(tray,i+1,d,u);\n    tray[i]=d;\n    step++;\n    if(step>m) return;\n    //    cout <<\"step \"<< step <<\" | \"<< i <<\":\"<< 1 << \" to \" << d << endl;\n  }\n\n  move(tray,i+1,u,d);\n  return;\n}\n\nint main()\n{\n\n  while(1){\n    cin >> n >> m;\n    if(n==0 && m==0) break;\n    int tray1[16],tray2[16];\n    for(int i=0;i<3;i++){\n      int nt;\n      cin >> nt;\n      for(int j=0;j<nt;j++){\n\tint cup;\n\tcin >> cup;\n\ttray1[cup]=tray2[cup]=i;\n      }\n    }\n\n    step=0;\n    move(tray1,1,0,2);\n    //  cout << step << endl;\n    int ans=step;\n    step=0;\n    move(tray2,1,2,0);\n    //  cout << step << endl;\n    if(step<ans) ans=step;\n    if(ans>m) ans=-1;\n\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nhash<string>h;\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tstring in = \"000000000000000\";\n\t\trep(i, 3) {\n\t\t\tint len; scanf(\"%d\", &len);\n\t\t\trep(j, len) {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tin[--a] = i + '0';\n\t\t\t}\n\t\t}\n\t\tmap<size_t, int>mp;\n\t\tqueue<string>que;\n\t\tmp[h(in)] = 1;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tstring u = que.front(); que.pop();\n\t\t\tif (count(u.begin(), u.begin() + n, '0') == n || \n\t\t\t\tcount(u.begin(), u.begin() + n, '2') == n) {\n\t\t\t\tprintf(\"%d\\n\", mp[h(u)] - 1);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (mp[h(u)] > m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tint fi = (int)u.rfind(i + '0', n - 1),\n\t\t\t\t\tfj = (int)u.rfind(j + '0', n - 1);\n\t\t\t\tif (fi == -1 || fi < fj)continue;\n\t\t\t\tstring v = u;\n\t\t\t\tv[fi] = j + '0';\n\t\t\t\tif (!mp[h(v)]) {\n\t\t\t\t\tmp[h(v)] = mp[h(u)] + 1;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <fstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nstatic const double EPS = 1e-5;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nstatic const int MAX = 15000001;\nmap< vector< stack<int> >, int> memo;\nint n,m;\nint hanoi(stack<int> stqn[3], int phase){\n  int ret = MAX, tpr;\n  bool a=stqn[0].empty(), b=stqn[1].empty(), c=stqn[2].empty();\n  if(b && (a||c)) return phase;\n  if(phase==m) return -1;\n  vector< stack<int> > mem;\n  REP(i,3) mem.push_back(stqn[i]);\n  if(memo.find(mem)!=memo.end() && memo[mem]<=phase) return -1;\n  memo[mem] = phase; \n  stack<int> tmp[3];\n  if(!a && (b||stqn[1].top()<stqn[0].top())){\n    REP(i,3) tmp[i]=stqn[i];\n    tmp[1].push(tmp[0].top());\n    tmp[0].pop();\n    if((tpr=hanoi(tmp, phase+1))!=-1){\n      ret = min(ret, tpr);\n    }\n  }\n  if(!b && (a||stqn[0].top()<stqn[1].top())){\n    REP(i,3) tmp[i]=stqn[i];\n    tmp[0].push(tmp[1].top());\n    tmp[1].pop();\n    if((tpr=hanoi(tmp, phase+1))!=-1){\n      ret = min(ret, tpr);\n    }\n  }\n  if(!b && (c||stqn[2].top()<stqn[1].top())){\n    REP(i,3) tmp[i]=stqn[i];\n    tmp[2].push(tmp[1].top());\n    tmp[1].pop();\n    if((tpr=hanoi(tmp, phase+1))!=-1){\n      ret = min(ret, tpr);\n    }\n  }\n  if(!c && (b||stqn[1].top()<stqn[2].top())){\n    REP(i,3) tmp[i]=stqn[i];\n    tmp[1].push(tmp[2].top());\n    tmp[2].pop();\n    if((tpr=hanoi(tmp, phase+1))!=-1){\n      ret = min(ret, tpr);\n    }\n  }\n  if(ret!=MAX) return ret;\n  else return -1;\n}\nint main(void){\n  while(cin>>n>>m){\n    stack<int> ini[3];\n    if(n==0) break;\n    REP(i,3){\n      int ko;\n      int tmp;\n      cin>>ko;\n      REP(j,ko){\n        cin>>tmp;\n        ini[i].push(tmp);\n      }\n    }\n    int ans = hanoi(ini, 0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != -1 ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        {\n            int u = get_last(B);\n            int v = get_last(A);\n            if ( u > v ) {\n                int ret = solve( A | u, remove_last(B), C, turns + 1 );\n                if ( ret != -1 ) return ret;\n            }\n        }\n        {\n            int u = get_last(B);\n            int v = get_last(C);\n            if ( u > v ) {\n                int ret = solve( A, remove_last(B), C | u, turns + 1 );\n                if ( ret != -1 ) return ret;\n            }\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != -1 ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == -1 && ret2 == -1 ) {\n            cout << -1 << endl;\n        } else if ( ret1 != -1 && ret2 != -1 ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != -1 ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != -1 ) {\n            cout << ret2 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint pow_(int a, int x) {\n    int val = 1;\n    for(int i = 0; i < x; ++i) val *= a;\n    return val;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<int> > goal(3);\n        for(int i = 0; i < 3; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int idx;\n                cin >> idx;\n                goal[i].push_back(idx-1);\n            }\n        }\n\n        vector<vector<int> > field(3);\n        for(int i = 0; i < N; ++i) {\n            field[0].push_back(i);\n        }\n\n        int turn = 0;\n        int prev_from = -1;\n        int prev_to = -1;\n        while(true) {\n            if(field == goal) {\n                break;\n            }\n            ++turn;\n            if(turn > M) break;\n            for(int from = 0; from < 3; ++from) {\n                if(field[from].size() == 0) continue;\n                const int glass = field[from].back();\n                const int to_1 = from-1;\n                const int to_2 = from+1;\n                if(!(from == prev_to && to_1 == prev_from) && to_1 >= 0 && (field[to_1].size() == 0 || field[to_1].back() < glass)) {\n                    field[to_1].push_back(glass);\n                    field[from].pop_back();\n                    prev_from = from;\n                    prev_to = to_1;\n                    break;\n                }\n                else if(!(from == prev_to && to_2 == prev_from) && to_2 < 3 && (field[to_2].size() == 0 || field[to_2].back() < glass)) {\n                    field[to_2].push_back(glass);\n                    field[from].pop_back();\n                    prev_from = from;\n                    prev_to = to_2;\n                    break;\n                }\n                else {\n                }\n            }\n        }\n        const int MAXTURN = pow_(3, N) - 1;\n        if(turn > M) {\n            turn = -1;\n        }\n        else {\n            turn = min(turn, MAXTURN-turn);\n        }\n        cout << turn << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nchar p[16];\nint n,m;\nint step(int a){\n\tif(a==n) return 1;\n\telse return 3*step(a+1)+1;\n}\nint count(int a,char t){\n\tif (a == 1 && n == 1 && p[a] == t){\n\t\treturn 0;\n\t}\n\telse if(a == 1 && n == 1 && p[a] == 'B'){\n\t\treturn 1;\n\t}\n\tif (a == n) return 0;\n\telse if(p[a] == t){\n\t\treturn count(a+1,t);\n\t}\n\telse if(p[a] == 'B'){\n\t\treturn 1+count(a+1,'C')+step(a+1)*2;\n\t}\n\telse if(p[a] != t){\n\t\treturn 2+count(a+1,'B')+step(a+1)*4;\n\t}\n}\nint main(){\n\tint i,j,a,b,x,y,r;\n\twhile(cin >> n >> m && (n != 0 && m != 0)){\n\t\tr = 0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tcin >> x;\n\t\t\tfor(j=0;j < x;j++){\n\t\t\t\tcin >> y;\n\t\t\t\tif(i==0) p[y] = 'A';\n\t\t\t\telse if(i==1) p[y] = 'B';\n\t\t\t\telse p[y] = 'C';\n\t\t\t}\n\t\t}\n\t\ta = count(1,'A');\n\t\tb = count(1,'C');\n\t\tr = min(a,b);\n\t\tif(r > m) cout << -1 << endl;\n\t\telse  cout << r << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define AB 1\n#define BC 3\n#define INF 1<<30\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nint n, m;\n\nstack<int> T[3];\n\nbool is_success (void )\n{\n\treturn ((int)T[0].size() == n || (int)T[2].size() == n ); \n}\n\nint dfs (int curr, int prev )\n{\n\tint ans = INF;\n\n\tif (curr > m ){\n\t\treturn ans;\n\t} // end if\n\n\tif (is_success () ){\n\t\tans = min (ans, curr );\n\t\treturn ans;\n\t} // end if\n\n\trep (i, 3 ){\n\t\tif (!T[i].empty() ){\n\t\t\tint cup = T[i].top(); T[i].pop();\n\t\t\tif (i == 0 && prev != AB ){\n\t\t\t\tif (T[1].empty() || cup > T[1].top() ){\n\t\t\t\t\tT[1].push (cup );\n\t\t\t\t\tans = min (ans, dfs (curr+1, AB ) );\n\t\t\t\t\tT[1].pop();\n\t\t\t\t} // end if\t\t\t\t\t\t\n\t\t\t} // end if\n\t\t\tif (i == 2 && prev != BC ){\n\t\t\t\tif (T[1].empty() || cup > T[1].top() ){\n\t\t\t\t\tT[1].push (cup );\n\t\t\t\t\tans = min (ans, dfs (curr+1, BC ) );\n\t\t\t\t\tT[1].pop();\n\t\t\t\t} // end if\t\t\t\t\t\t\n\t\t\t} // end if\n\t\t\tif (i == 1 ){\n\t\t\t\tif (prev != AB && (T[0].empty() || cup > T[0].top() ) ){\n\t\t\t\t\tT[0].push (cup );\n\t\t\t\t\tans = min (ans, dfs (curr+1, AB ) );\n\t\t\t\t\tT[0].pop();\n\t\t\t\t}else\n\t\t\t\tif (prev != BC && (T[2].empty() || cup > T[2].top() ) ){\n\t\t\t\t\tT[2].push (cup );\n\t\t\t\t\tans = min (ans, dfs (curr+1, BC ) );\n\t\t\t\t\tT[2].pop();\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t\tT[i].push (cup );\n\t\t} // end if\n\t} // end rep\n\n\treturn ans;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.cup\", \"r\", stdin );\n\twhile (scanf (\"%d %d\", &n, &m ), n, m ){\n\t\trep (i, 3 ) while (!T[i].empty() ) T[i].pop();\n\t\trep (i, 3 ){\n\t\t\tint in;\n\t\t\tscanf (\"%d\", &in );\n\t\t\trep (j, in ){\n\t\t\t\tint cup;\n\t\t\t\tscanf (\"%d\", &cup );\n\t\t\t\tT[i].push (cup );\n\t\t\t} // end rep\n\t\t} // end rep\n\n\t\tint res = dfs (0, 0 );\n\t\tif (res == INF ){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << res << endl;\n\t\t} // end if\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); i ++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> PL;\ntypedef pair<int,int> P;\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nvoid solve(int n,int m) {\n    vector<int> power3(n + 1,1); rep(i,n) power3[i + 1] = power3[i]*3;\n    int init_state = 0;\n    int a; cin >> a;\n    rep(i,a) {int num; cin >> num;}\n    int b; cin >> b;\n    rep(i,b) {int num; cin >> num; init_state += power3[num - 1];}\n    int c; cin >> c;\n    rep(i,c) {int num; cin >> num; init_state += power3[num - 1]*2;}\n\n    vector<int> dist(power3[n],-1);\n    dist[init_state] = 0;\n    queue<int> que;\n    que.push(init_state);\n    while (que.size()) {\n        int p = que.front(); que.pop();\n        int a_max = -1,b_max = -1,c_max = -1;\n        for (int i = 0;i < n; i++) {\n            if ((p/power3[i])%3 == 0) a_max = i;\n            else if ((p/power3[i])%3 == 1) b_max = i;\n            else  c_max = i;\n        }\n\n        if (a_max < b_max) {\n            int q = p - power3[b_max];\n            if (dist[q] < 0) {\n                dist[q] = dist[p] + 1;\n                que.push(q);\n            }\n        }\n\n        if (a_max > b_max) {\n            int q = p + power3[a_max];\n            if (dist[q] < 0) {\n                dist[q] = dist[p] + 1;\n                que.push(q);\n            }\n        }\n\n        if (b_max > c_max) {\n            int q = p + power3[b_max];\n            if (dist[q] < 0) {\n                dist[q] = dist[p] + 1;\n                que.push(q);\n            }\n        }\n\n        if (b_max < c_max) {\n            int q = p - power3[c_max];\n            if (dist[q] < 0) {\n                dist[q] = dist[p] + 1;\n                que.push(q);\n            }\n        }\n    }\n\n    if (dist[0] < 0 && dist.back() < 0) cout << -1 << endl;\n    else if (dist[0] < 0) {if (dist.back() <= m) cout << dist.back() << endl;}\n    else if (dist.back() < 0) {if (dist[0] <= m) cout << dist[0] << endl;}\n    else if (min(dist[0],dist.back()) <= m) cout << min(dist[0],dist.back()) << endl;\n    else cout << -1 << endl;\n}\n\nint main() {\n    while (1) {\n        int n,m; cin >> n >> m;\n        if (n == 0) return 0;\n        solve(n,m);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<string>\n#include<climits>\n#include<deque>\n\nusing namespace std;\n\nint m,INF=30000000;\nstack<int,vector<int> >A,B,C;\nstack<int,vector<int> >A2,B2,C2;\n\nint func(string p){\n  \n  int cnt=0;\n\n  for(int i=0;i<m;i++){\n    \n    if(B.empty() && (C.empty()||A.empty()))return cnt;\n    \n    if(!A.empty() &&  A.top()>=B.top() && p!=\"BA\"){\n      B.push(A.top());\n      A.pop();\n      cnt++,p=\"AB\";\n    }\n    \n    if(!B.empty()){\n      if(B.top()>=C.top() && p!=\"CB\"){\n\tC.push(B.top());\n\tB.pop();\n\tcnt++,p=\"BC\";\n      }\n      \n      if(B.top()>=A.top() && p!=\"AB\"){\n\tA.push(B.top());\n\tB.pop();\n\tcnt++,p=\"BA\";\n      }\n    }\n    \n    if(!C.empty() && C.top()>=B.top() && p!=\"BC\"){\n      B.push(C.top());\n      C.pop();\n      cnt++,p=\"CB\";\n    }\n    \n  }\n\n  return INF;\n}\n\nint main(void){\n  int n,ans,s,t;\n  \n  while(cin >> n >> m,n|m){\n    while(!A.empty())A.pop();\n    while(!B.empty())B.pop();\n    while(!C.empty())C.pop();\n    while(!A2.empty())A2.pop();\n    while(!B2.empty())B2.pop();\n    while(!C2.empty())C2.pop();\n\n\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      A.push(t);\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      B.push(t);\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      C.push(t);\n    }\n    \n    A2=A,B2=B,C2=C;\n    \n    ans=func(\"CB\");\n    \n    A=A2,B=B2,C=C2;\n    ans=min(ans,func(\"AB\"));\n    \n    A=A2,B=B2,C=C2;\n    ans=min(ans,func(\"BA\"));\n    \n    A=A2,B=B2,C=C2;\n    ans=min(ans,func(\"BC\"));\n    \n    if(ans==INF)cout << -1 << endl;\n    else cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tll dp[16] = {};\n\tdp[0] = 1;\n\trep(i,1, n+1) {\n\t\tdp[i] = dp[i - 1] * 3;\n\t}\n\tvector<int> pos(n);\n\tREP(i, 3) {\n\t\tint c;\n\t\tscanf(\"%d\", &c);\n\n\n\t\tREP(j, c) {\n\t\t\tint size;\n\t\t\tscanf(\"%d\", &size);\n\n\t\t\tpos[size-1] = i;\n\t\t}\n\t}\n\t//reverse(ALL(pos));\n\tll ans = 0,ans2 = 0;\n\tbool curs = 0;\n\tREP(i, n) {\n\t\tif (pos[i] % 2) {\n\t\t\tans += dp[n - i - 1];\n\t\t\tcurs = 1-curs;\n\t\t}\n\t\telse if (curs*2-pos[i]) {\n\t\t\tans += dp[n - i - 1] + 1;\n\t\t}\n\t}\n\tbool curs = 1;\n\tREP(i, n) {\n\t\tif (pos[i] % 2) {\n\t\t\tans2 += dp[n - i - 1];\n\t\t\tcurs = 1 - curs;\n\t\t}\n\t\telse if (curs * 2 - pos[i]) {\n\t\t\tans2 += dp[n - i - 1] + 1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", min(ans2, ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(void){\n\tint pow3[16], c[16];\n\tint n, m, i, j, k, d, x, y, p;\n\n\tpow3[0] = 1;\n\tfor(i = 1; i <= 15; ++i){\n\t\tpow3[i] = pow3[i-1] * 3;\n\t}\n\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\tfor(i = 0; i < 3; ++i){\n\t\t\tfor(scanf(\"%d\", &j); j > 0; --j){\n\t\t\t\tscanf(\"%d\", &k);\n\t\t\t\tc[n-k] = i;\t/* 番号付け替え */\n\t\t\t}\n\t\t}\n\n\t\tp = 0;\n\t\tx = 0;\n\t\tfor(i = n - 1; i >= 0; --i){\n\t\t\td = abs(p - c[i]);\n\t\t\tx += pow3[i] * d;\n\t\t\tif(d == 1){\n\t\t\t\tp = 2 - p;\t/* 反対側に移動 */\n\t\t\t}\n\t\t}\n\n\t\ty = pow3[n] - 1 - x;\n\t\tif(x > y){\n\t\t\tx = y;\n\t\t}\n\t\tprintf(\"%d\\n\", x > m ? -1 : x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef unsigned short SI;\ntypedef pair<SI,SI> P;\ntypedef pair<SI,P> State;\n\n// 入力\nint n, m;\nSI cup[3];\n\nvoid debug(SI a, SI b, SI c, SI cnt){\n\tcout << \"[debug]\" << endl;\n\tcout << \"cnt:\" << cnt << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((a&i)? \"*\" : \"-\");\n\t}\n\tcout << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((b&i)? \"*\" : \"-\");\n\t}\n\tcout << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((c&i)? \"*\" : \"-\");\n\t}\n\tcout << endl << endl;;\n}\n\n// 一番上のカップを返す\nSI top(SI bits){\n\tfor(int i=(1<<n) ; i ; i >>= 1 ){\n\t\tif( i & bits ) return i;\n\t}\n\treturn 0;\n}\n\n// 探索\nint bfs(){\n\t// d[s] := cupの状態 s のときの手数\n\tmap<State,int> d;\n\tqueue<State> q;\n\t\n\tState s = State( (1<<n)-1 , P(0,0) );\n\tq.push(s);\n\td[s] = 0;\n\t\n\twhile( !q.empty() ){\n\t\tState now = q.front();\n\t\tint cnt = d[now];\n\t\tq.pop();\n\t\t\n\t\t// a,b,c := カップの状態\n\t\t// a_top,b_top,c_top := 一番上のカップ\n\t\tSI& a = now.first;\n\t\tSI& b = now.second.first;\n\t\tSI& c = now.second.second;\n\t\tSI a_top = top(a);\n\t\tSI b_top = top(b);\n\t\tSI c_top = top(c);\n\t\t//debug(a,b,c,cnt);\n\t\t\n\t\t// ゴールのとき\n\t\tif( b == cup[1] && ((a == cup[0] && c == cup[2]) || (a == cup[2] && c == cup[0])) ){\n\t\t\treturn cnt;\n\t\t}\n\t\t\n\t\t{\n\t\t\tSI a_, b_, c_;\n\t\t\tif( a_top < b_top ){ // B -> A の移動\n\t\t\t\ta_ = a + b_top;\n\t\t\t\tb_ = b - b_top;\n\t\t\t\tc_ = c;\n\t\t\t}else{ // A -> B の移動\n\t\t\t\ta_ = a - a_top;\n\t\t\t\tb_ = b + a_top;\n\t\t\t\tc_ = c;\n\t\t\t}\n\t\t\tState next = State(a_,P(b_,c_));\n\t\t\tif( !d.count(next) && cnt + 1 <= m ){\n\t\t\t\td[next] = cnt + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tSI a_, b_, c_;\n\t\t\tif( c_top < b_top ){ // B -> C の移動\n\t\t\t\ta_ = a;\n\t\t\t\tb_ = b - b_top;\n\t\t\t\tc_ = c + b_top;\n\t\t\t}else{ // C -> B の移動\n\t\t\t\ta_ = a;\n\t\t\t\tb_ = b + c_top;\n\t\t\t\tc_ = c - c_top;\n\t\t\t}\n\t\t\tState next = State(a_,P(b_,c_));\n\t\t\tif( !d.count(next) && cnt + 1 <= m ){\n\t\t\t\td[next] = cnt + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile( cin >> n >> m , n || m ){\n\t\t// 初期化\n\t\tcup[0] = cup[1] = cup[2] = 0;\n\t\t \n\t\tfor(int i=0 ; i < 3 ; i++ ){\n\t\t\tint k, e;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0 ; j < k ; j++ ){\n\t\t\t\tcin >> e;\n\t\t\t\tcup[i] |= (1 << (e-1));\n\t\t\t}\n\t\t}\n\t\tint ans = bfs();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<utility>\n#include<vector>\nusing namespace std;\nint main(){\n    int place,n,m,a[3][16]={0},na,nb,nc;\n    while(1){\n        for(int i=0;i<3;++i){\n            for(int j=0;j<16;++j){\n                a[i][j]=0;\n            }\n        }\n    cin>>n>>m;\n        if(n==0&&m==0)break;\n    cin>>na;\n    for(int i=0;i<na;++i){\n        cin>>a[0][i];\n    }\n    cin>>nb;\n    for(int i=0;i<nb;++i){\n        cin>>a[1][i];\n    }\n    cin>>nc;\n    for(int i=0;i<nc;++i){\n        cin>>a[2][i];\n    }\n    if(a[0][0]==1)place=0;\n    else if(a[2][0]==1)place=2;\n    else if(a[0][0]==1)place=0;\n    else if(a[2][0]==0)place=2;\n    else if(a[0][0]==0)place=0;\n    else if(a[0][0]>a[2][0])place=0;\n    else place=2;\n    int np,cnt=0,tar;\n    if(place==0)np=2;\n    else np=0;\n    if(place==0)tar=na;\n    else tar=nc;\n    for(int i=1;i<=tar;++i){\n        if(i!=a[place][i-1]){\n            cnt=tar-i;\n        }\n    }\n    int tyo=0;\n    if(a[np][0]!=0){\n        tyo=-4;\n    }\n        if(a[place][cnt]!=0){\n            if(a[place][0]>a[np][cnt]&&a[np][cnt]!=0){\n                tyo+=2;\n                \n            }\n            else if(a[place][0]>a[np][cnt]&&a[np][cnt]!=0){\n                tyo+=6;\n            }\n            if(np==2){\n                    na--;\n                    nc++;\n                }\n                else{\n                    nc--;\n                    na++;\n                }\n        }\n    if(place==0){\n        cout<<(nb+nc*6+tyo>m?-1:nb+nc*6+tyo)<<endl;\n    }\n    else {\n        cout<<(nb+na*6+tyo>m?-1:nb+na*6+tyo)<<endl;\n    }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,P> pip;\nconst int inf=(1<<31)-1;\n\nint n,m;\nvvi date;\n\nint func(int x){\n\tint an=3;\n\tfor(int i=0;i<x-1;i++) an*=an;\n\treturn an;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(!n&&!m) break;\n\t\tint lef=0,rig=0;\n\t\tdate=vvi(3);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint tn;\n\t\t\tcin>>tn;\n\t\t\tfor(int j=0;j<tn;j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tdate[i].push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tfor(int  i=0;i<3;i+=2){\n\t\t\tint now=i;\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tint tmp1;\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tbool q=1;\n\t\t\t\t\tfor(int r=0;r<date[k].size();r++){\n\t\t\t\t\t\tif(j==date[k][r]){\n\t\t\t\t\t\t\ttmp1=k;\n\t\t\t\t\t\t\tq=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j>date[k][r]) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!q) break;\n\t\t\t\t}\n\t\t\t\tint t=abs(now-tmp1);\n/*\t\t\t\tif(i==0) cout<<'L'<<now<<' '<<tmp1<<endl;\n\t\t\t\telse cout<<'R'<<now<<' '<<tmp1<<endl;\n\t\t\t\tcout<<t<<endl;*/\n\t\t\t\tif(!t) continue;\n\t\t\t\tif(i==0){\n\t\t\t\t\tlef+=t*func(n-j);\n\t\t\t\t\tif(lef>m) break;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\trig+=t*func(n-j);\n\t\t\t\t\tif(rig>m) break;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<t;k++){\n\t\t\t\t\tif(now==0) now=2;\n\t\t\t\t\telse now=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout<<lef<<' '<<rig<<endl;\n\t\tint ans=min(lef,rig);\n\t\tif(ans>m) cout<<-1<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include <stack>\nusing namespace std;\n \nint main()\n{\n    stack<int>a,b,c;\n    while(1)\n    {\n         \n        int count=0,n,m,check;\n        scanf(\"%d %d\",&n,&m);\n \n        if(n==0 && m==0)\n        {\n            break;\n        }\n     \n        int A,B,C,\n            kari;\n         \n        /*エラー対策*/\n        a.push(0);\n        b.push(0);\n        c.push(0);\n \n        scanf(\"%d\",&A);\n        for(int i=0;i<A;i++){\n            scanf(\"%d\",&kari);\n            a.push(kari);\n        }\n \n        scanf(\"%d\",&B);\n        for(int i=0;i<B;i++){\n            scanf(\"%d\",&kari);\n            b.push(kari);\n        }\n     \n        scanf(\"%d\",&C);\n        for(int i=0;i<C;i++){\n            scanf(\"%d\",&kari);\n            c.push(kari);\n        }\n         \n        while(1)\n        {\n            if(b.top()==0 && c.top()==0)\n                break;\n            if(a.top()<b.top() && a.top()<c.top()){\n                kari=b.top();\n                a.push(kari);\n                b.pop();\n                count++;\n                continue;\n            }\n            if(b.top()<c.top() ){\n                kari=c.top();\n                b.push(kari);\n                c.pop();\n                count++;\n                continue;\n            }\n            if(b.top()<a.top()){\n                kari=a.top();\n                b.push(kari);\n                a.pop();\n                count++;\n                continue;\n            }\n            if(c.top()<b.top() && a.top()!=b.top()-1){\n                kari=b.top();\n                c.push(kari);\n                b.pop();\n                count++;\n                continue;\n        }\n            else{\n                kari=b.top();\n                a.push(kari);\n                b.pop();\n                count++;\n                continue;\n            }\n        }\n        if(count<m || count==m){\n\t\t\tprintf(\"%d\\n\\n\",count);\n\t\t\tcontinue;\n\t\t}\n        else {\n\t\t\tprintf(\"%d\\n\\n\",-1);\n\t\t\tcontinue;\n\t\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconstexpr int INF = (1 << 29);\n\nvoid move_cup(vector<vector<int>> &v,\n              int from,\n              int to)\n{\n    int p = v[from].back();\n    v[from].pop_back();\n    v[to].emplace_back(p);\n}\n\nvoid next_state(int &prev,\n                int &curr,\n                vector<vector<int>> &curr_cup)\n{\n    for (int i = 0; i < 3; i++) {\n        int size = curr_cup[i].size();\n        if (size == 0) {\n            continue;\n        }\n\n        for (int di : {-1, 1}) {\n            int next = i + di;\n            if (next < 0 || next >= 3 || (curr == i && prev == next)) {\n                continue;\n            }\n\n            int nsize = curr_cup[next].size();\n            if (nsize == 0 ||\n                curr_cup[i].back() > curr_cup[next].back()) {\n                move_cup(curr_cup, i, next);\n                prev = i; curr = next;\n                return;\n            }    \n        }\n    }\n}\n\nint solve(vector<vector<int>> curr_cup,\n          const vector<vector<int>> &target)\n{\n    int res = 0;\n    int prev = -1, curr = 0;\n    while (curr_cup != target) {\n        next_state(prev, curr, curr_cup);\n        res++;\n    }\n    return res;\n}\n\nint main()\n{\n    int N, M;\n    while (1) {\n        cin >> N >> M;\n        if (N == 0 && M == 0) {\n            break;\n        }\n        \n        vector<vector<int>> target(3);\n        for (int i = 0; i < 3; i++) {\n            int K;\n            cin >> K;\n            for (int j = 0; j < K; j++) {\n                int x;\n                cin >> x;\n                target[i].emplace_back(--x);\n            }\n        }\n\n        vector<vector<int>> curr_cup(3, vector<int>(0));\n        for (int i = 0; i < N; i++) {\n            curr_cup[0].emplace_back(i);\n        }      \n\n        int res = solve(curr_cup, target);\n        swap(target[0], target[2]);\n        res = min(res, solve(curr_cup, target));\n\n        if (res <= M) {\n            cout << res << endl;\n        } else {\n            cout << -1 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n// variable update\ninline void modAdd(int& _a, int _b, int _m) { _a = (_a + _b) % _m; }\ninline void modAdd(lint& _a, lint _b, lint _m) { _a = (_a + _b) % _m; }\ninline void minUpdate(int& _a, int _b) { _a = min(_a, _b); }\ninline void minUpdate(lint& _a, lint _b) { _a = min(_a, _b); }\ninline void maxUpdate(int& _a, int _b) { _a = max(_a, _b); }\ninline void maxUpdate(lint& _a, lint _b) { _a = max(_a, _b); }\n\nint n, m;\nint POW[16];\n\nint calc(int A, int B) {\n\tint res = 0;\n\tfor_(i,0,n) {\n\t\tint k = n - i - 1;\n\t\tif (A >> i & 1) res += 2 * POW[k];\n\t\tif (B >> i & 1) res += POW[k];\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tint cup[3] = { 0 };\n\t\n\tfor_(i,0,3) {\n\t\tint d; cin >> d;\n\t\tfor_(j,0,d) {\n\t\t\tint p; cin >> p;\n\t\t\t--p;\n\t\t\tcup[i] |= 1 << p;\n\t\t}\n\t}\n\t\n\tint ans = min(calc(cup[0], cup[1]), calc(cup[2], cup[1]));\n\tif (ans > m) ans = -1;\n\tcout << ans << endl;\n}\n\nint main() {\n\tPOW[0] = 1;\n\tfor_(i,1,16) POW[i] = POW[i - 1] * 3;\n\tPOW[0] = 0;\n\twhile (cin >> n >> m, n) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "???"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nbool memo[3][3][3][3][3][3][3][3][3][3][3][3][3][3][3]={};\nvector<vector<int> >cup3(10);\nbool check(int num,int point){\n  int hi[15]={};\n\n   for(int i=0;i<3;i++)\n    for(int j=0;j<cup3[i].size();j++)\n      {hi[cup3[i][j]]=i;}\n  hi[num]=point;\n\n  //cout<<memo[hi[0]][hi[1]][hi[2]][hi[3]][hi[4]][hi[5]][hi[6]][hi[7]][hi[8]][hi[9]][hi[10]][hi[11]][hi[12]][hi[13]][hi[14]]<<endl;\n\n  if(!(memo[hi[0]][hi[1]][hi[2]][hi[3]][hi[4]][hi[5]][hi[6]][hi[7]][hi[8]][hi[9]][hi[10]][hi[11]][hi[12]][hi[13]][hi[14]])&&cup3[point].size()==0){\n    return true;\n  }else if(!(memo[hi[0]][hi[1]][hi[2]][hi[3]][hi[4]][hi[5]][hi[6]][hi[7]][hi[8]][hi[9]][hi[10]][hi[11]][hi[12]][hi[13]][hi[14]])&&(num>cup3[point][cup3[point].size()-1])){\n    return true;\n  }else{\n    return false;\n  }\n}\nvoid renew(){\n  int hai[15]={};\n  for(int i=0;i<3;i++)\n    for(int j=0;j<cup3[i].size();j++)\n      hai[cup3[i][j]]=i;\n  memo[hai[0]][hai[1]][hai[2]][hai[3]][hai[4]][hai[5]][hai[6]][hai[7]][hai[8]][hai[9]][hai[10]][hai[11]][hai[12]][hai[13]][hai[14]]=true;\n}\nint main(){\n\n  int n,m;cin>>n>>m;\n  for(int i=0;i<3;i++){\n    int a;cin>>a;\n    for(int j=0;j<a;j++){\n      int b;cin>>b;\n      b--;\n      cup3[i].pb(b);\n    }\n  }\n\n  renew();\n \n  bool flagg=true;\n  queue<pair<pair<int,int>,pair<vector<vector<int> >,int> > >que;\n  vector<vector<int> >cup2(3);\n\n  for(int i=0;i<3;i++){\n \n    for(int j=0;j<cup3[i].size();j++){\n      // cout<<cup3[i][j]<<\" \";\n      cup2[i].pb(cup3[i][j]);\n    }\n    //cout<<endl;\n  }\n  for(int i=0;i<3;i++)\n    if(cup3[i].size()!=0){\n      que.push(mp(mp(cup3[i][cup3[i].size()-1],0),mp(cup2,i)));\n      //cout<<i<<endl;\n    }\n  while(!que.empty()){\n \n    cup3[0].clear();cup3[1].clear();cup3[2].clear();\n    for(int i=0;i<3;i++){\n      for(int j=0;j<que.front().S.F[i].size();j++){\n\t//cout<<que.front().S.F[i][j]<<\" \";\n\tcup3[i].pb(que.front().S.F[i][j]);\n      }\n      //cout<<endl;\n    }\n\n    int point=que.front().S.S;\n    int num=que.front().F.F;\n    int cnt=que.front().F.S;\n    que.pop();\n    //cout<<point;\n    //cout<<\"-----------------------\"<<endl;\n    /*for(int i=0;i<3;i++){\n\tfor(int j=0;j<cup3[i].size();j++)\n\t  cout<<cup3[i][j]<<\" \";\n\tcout<<endl;\n\t}*/\n      //cout<<\"-----------------------\"<<endl;\n    if(cup3[0].size()==n||cup3[2].size()==n){\n\n      cout<<cnt<<endl;\n      flagg=false;\n      break;\n    }\n    if(cnt>=m)break;\n    if(point==0){\n      if(check(num,1)){\n\tcup3[point].pop_back();\n\tcup3[1].pb(num);\n\trenew();\n\tfor(int i=0;i<3;i++){\n\t  if(cup3[i].size()!=0)\n\t  que.push(mp(mp(cup3[i][cup3[i].size()-1],cnt+1),mp(cup3,i)));\n\t}\n      }\n    }else if(point==1){\n      if(check(num,0)){\n\n\tcup3[point].pop_back();\n\tcup3[0].pb(num);\n\trenew();\n\tfor(int i=0;i<3;i++){\n\t  if(cup3[i].size()!=0)\n\t    que.push(mp(mp(cup3[i][cup3[i].size()-1],cnt+1),mp(cup3,i)));\n\t}\n\tcup3[0].pop_back();\n\tcup3[point].pb(num);\n      }\n      if(check(num,2)){\n\tcup3[point].pop_back();\n\tcup3[2].pb(num);\n\trenew();\n\tfor(int i=0;i<3;i++){\n\t  if(cup3[i].size()!=0)\n\t  que.push(mp(mp(cup3[i][cup3[i].size()-1],cnt+1),mp(cup3,i)));\n\t}\n\tcup3[2].pop_back();\n\tcup3[point].pb(num);\n      }\n    }else if(point == 2){\n      if(check(num,1)){\n\t//cout<<point<<\" \"<<point<<endl;\n\tcup3[point].pop_back();\n\tcup3[1].pb(num);\n\trenew();\n\tfor(int i=0;i<3;i++){\n\t  if(cup3[i].size()!=0){\n\t    // cout<<point<<endl;\n\t  que.push(mp(mp(cup3[i][cup3[i].size()-1],cnt+1),mp(cup3,i)));\n\t  }\n\t}\n      }\n    }\n  }\n  if(flagg)\n    cout<<-1<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define min(a,b) ((a)<=(b)?(a):(b))\nint toC(int A,int B,int C) {\n\tif(A==0&&B==0) return 0;\n\tif(C&1) return toC(A>>1,B>>1,C>>1);\n\tif(B&1) return toC(C>>1,B>>1,A>>1)+1+toC((A|B|C)>>1,0,0);\n\tif(A&1) return toC(A>>1,B>>1,C>>1)+2*toC((A|B|C)>>1,0,0)+2;\n}\nint main() {\n\tint n,m;\n\twhile(scanf(\"%d %d\",&n,&m),n) {\n\t\tint x,y,z[3]={0};\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tscanf(\"%d\",&x);\n\t\t\tfor(int j=0;j<x;j++) {\n\t\t\t\tscanf(\"%d\",&y);\n\t\t\t\tz[i]|=1<<(y-1);\n\t\t\t}\n\t\t}\n\t\tint mn=min(toC(z[0],z[1],z[2]),toC(z[2],z[1],z[0]));\n\t\tprintf(\"%d\\n\",mn<=m?mn:-1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<string>\n#include<climits>\n#include<deque>\n\nusing namespace std;\n\nint m,INF=30000000;\nstack<int,vector<int> >A,B,C;\nstack<int,vector<int> >A2,B2,C2;\n\nint func(string p){\n  \n  int cnt=0;\n\n  for(int i=0;i<m;i++){\n    \n    if(B.empty() && (C.empty()||A.empty()))return cnt;\n    \n    if(!A.empty() && (B.empty() || A.top()>=B.top()) && p!=\"BA\"){\n      B.push(A.top());\n      A.pop();\n      cnt++,p=\"AB\";\n    }\n    \n    if(!B.empty() && (C.empty() || B.top()>=C.top()) && p!=\"CB\"){\n      C.push(B.top());\n      B.pop();\n      cnt++,p=\"BC\";\n    }\n    \n    if(!B.empty() && (A.empty() || B.top()>=A.top()) && p!=\"AB\"){\n      A.push(B.top());\n      B.pop();\n      cnt++,p=\"BA\";\n    }\n    \n    if(!C.empty() && (B.empty() || C.top()>=B.top()) && p!=\"BC\"){\n      B.push(C.top());\n      C.pop();\n      cnt++,p=\"CB\";\n    }\n    \n  }\n\n  return INF;\n}\n\nint main(void){\n  int n,ans,s,t;\n  \n  while(cin >> n >> m,n|m){\n    while(!A.empty())A.pop();\n    while(!B.empty())B.pop();\n    while(!C.empty())C.pop();\n    while(!A2.empty())A2.pop();\n    while(!B2.empty())B2.pop();\n    while(!C2.empty())C2.pop();\n\n\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      A.push(t);\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      B.push(t);\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      C.push(t);\n    }\n    \n    A2=A,B2=B,C2=C;\n    ans=func(\"CB\");\n    \n    A=A2,B=B2,C=C2;\n    ans=min(ans,func(\"AB\"));\n    \n    A=A2,B=B2,C=C2;\n    ans=min(ans,func(\"BA\"));\n    \n    A=A2,B=B2,C=C2;\n    ans=min(ans,func(\"BC\"));\n    \n    if(ans==INF)cout << -1 << endl;\n    else cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint tostate(int a, int b, int c, int k)\n{\n\tint mul;\n\tint ret = 0;\n\t\n\tfor(int i = 0, mul = 1; i < k; ++i, mul *= 3)\n\t\tret += ((a >> i) & 1) * 1 * mul;\n\tfor(int i = 0, mul = 1; i < k; ++i, mul *= 3)\n\t\tret += ((b >> i) & 1) * 2 * mul;\n\t\t\n\treturn ret;\n}\n\ninline int mhb(int x)\n{\n\tfor(int i = 31; i >= 0; --i) {\n\t\tif(x & (1 << i))\n\t\t\treturn 1 << i;\n\t}\n\t\n\treturn 0;\n}\n\nconst int inf = 1000000000;\nconst int pow3x5 = 3 * 3 * 3 * 3 * 3;\nconst int pow3x15 = pow3x5 * pow3x5 * pow3x5;\nbool visit[pow3x15];\n\nstruct node {\n\tint a, b, c, remain;\n\tnode(int a, int b, int c, int remain) : a(a), b(b), c(c), remain(remain) {}\n};\n\nint calc(int a, int b, int c, int remain, int k)\n{\n\tint f = inf;\n\n\tqueue<node> q;\n\t\n\tq.push(node(a, b, c, remain));\n\t\n\twhile(!q.empty()) {\n\t\n\t\tnode cur = q.front();\n\t\tq.pop();\n\t\n\t\tif(cur.remain < 0)\n\t\t\tcontinue;\n\t\t\n\t\tif(cur.b == 0 && (cur.a == 0 || cur.c == 0)) {\n\t\t\tf = cur.remain;\n\t\t\tbreak;\n\t\t}\n\n\t\tint state = tostate(cur.a, cur.b, cur.c, k);\n\n\t\tif(visit[state])\n\t\t\tcontinue;\n\t\tvisit[state] = true;\n\t\n\t\tif(cur.a > cur.b) {\n\t\t\tint move = mhb(cur.a);\n\t\t\tint ta = cur.a - move;\n\t\t\tint tb = cur.b + move;\n\t\t\tint tc = cur.c;\n\t\t\tq.push(node(ta, tb, tc, cur.remain - 1));\n\t\t} else {\n\t\t\tint move = mhb(cur.b);\n\t\t\tint ta = cur.a + move;\n\t\t\tint tb = cur.b - move;\n\t\t\tint tc = cur.c;\n\t\t\tq.push(node(ta, tb, tc, cur.remain - 1));\n\t\t}\n\t\n\t\tif(cur.b > cur.c) {\n\t\t\tint move = mhb(cur.b);\n\t\t\tint ta = cur.a;\n\t\t\tint tb = cur.b - move;\n\t\t\tint tc = cur.c + move;\n\t\t\tq.push(node(ta, tb, tc, cur.remain - 1));\n\t\t} else {\n\t\t\tint move = mhb(cur.c);\n\t\t\tint ta = cur.a;\n\t\t\tint tb = cur.b + move;\n\t\t\tint tc = cur.c - move;\n\t\t\tq.push(node(ta, tb, tc, cur.remain - 1));\n\t\t}\n\t}\n\t\n\tint ret = (f != inf ? remain - f : -1);\n\t\n\treturn ret;\n}\n\nint main()\n{\n\twhile(true) {\n\t\n\t\tint n, m;\n\t\t\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\t\t\n\t\tfill(visit + 0, visit + pow3x15, false);\n\t\t\n\t\tint a[3];\n\t\tint bita[3] = {0};\n\t\tint k = 0;\n\t\t\n\t\tfor(int i = 0; i < 3; ++i) {\n\t\t\tscanf(\"%d\", a + i);\n\t\t\tfor(int j = 0; j < a[i]; ++j) {\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tbita[i] += 1 << (t - 1);\n\t\t\t\tk = max(k, t);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = calc(bita[0], bita[1], bita[2], m, k);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint visited[30000000];\n\nint pow(int x,int n){\n\tint res = 1;\n\twhile(n>0){\t\t\n\t\tres *= x;\n\t\tif(n & 1) x = x*x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\nint conv(vector<int>& sets){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<=15;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * pow(3,j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,vector<int>& root, int* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tmemset(visited,-1,sizeof(visited));\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,sets,visited));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nint n, m, k, x;\n\nint chk(vector<stack<int>> tray) {\n    int ret = 0;\n    while (1) {\n        for (int i=0; i<=1; ++i) {\n            if (tray[0].size() == n+1 || tray[2].size() == n+1) return ret;\n            int a = tray[i].top(); tray[i].pop();\n            int b = tray[i+1].top(); tray[i+1].pop();\n            if (a < b) {\n                tray[i].push(a);\n                tray[i].push(b);\n            } else {\n                tray[i+1].push(b);\n                tray[i+1].push(a);\n            }\n            ret ++;\n        }\n        if (m < ret) return 15000001;\n    }\n}\n\nint main() {\n    while (cin >> n >> m) {\n        if (!n && !m) break;\n        vector<stack<int>> tray(3);\n        for (int i=0; i<3; ++i) {\n            cin >> k;\n            tray[i].push(-1);\n            for (int j=0; j<k; ++j) {\n                cin >> x;\n                tray[i].push(x);\n            }\n        }\n        int ans = chk(tray);\n        swap(tray[0], tray[2]);\n        ans = min(ans, chk(tray));\n        cout << (ans <= m ? ans : -1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n    int n,m;\n    while(1){\n        cin >> n >> m;\n        if(n == 0 && m == 0)break;\n        vector<char> cup;\n        bool flag = true;\n        rep(i,n) cup.push_back(0);\n        rep(i,3){\n            int n1;\n            cin >> n1;\n            rep(j,n1){\n                int n2;\n                cin >> n2;\n                n2--;\n                cup[n2] = i;\n            }\n        }//入力ここまで\n        queue<vector<char>> que;\n        que.push(cup);\n        map<vector<char>,int> mp;\n        mp[cup] = 0;\n        while(que.size()!=0){\n            cup = que.front();\n            que.pop();\n            //rep(i,cup.size())cout << cup[i];\n            //cout << endl;\n            int bigger[3] = {-1,-1,-1};\n            int maxcount = 0;\n            bool tray[3] ={true,true,true};\n            if(cup.size() == count(cup.begin(),cup.end(),0) ||cup.size() == count(cup.begin(),cup.end(),2)){\n                cout << mp[cup] << endl;\n                flag = false;\n                break;\n            }\n            rep(i,n){\n                int i2 = n-i-1;\n                rep(j,3){\n                    if(tray[j] == true && cup[i2] == j){\n                        tray[j] = false;\n                        bigger[maxcount] = i2;\n                        maxcount++;\n                        break;\n                    }\n                }\n                if(maxcount == 3)break;\n            }\n            int movecount = mp[cup] + 1;\n            if(movecount > m) break;\n            if(cup[bigger[0]]-1 >= 0){\n                cup[bigger[0]]--;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]++;\n            }\n            if(cup[bigger[0]]+1 <= 2){\n                cup[bigger[0]]++;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]--;\n            }\n            if(maxcount >= 2){\n                if(cup[bigger[1]]-1 >= 0 && cup[bigger[1]]-1 != cup[bigger[0]]){\n                    cup[bigger[1]]--;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]++;\n                }\n                else if(cup[bigger[1]]+1 <= 2 && cup[bigger[1]]+1 != cup[bigger[0]]){\n                    cup[bigger[1]]++;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]--;\n                }\n            }\n        }\n        if(flag) cout << \"-1\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\nusing namespace std;\n\nint n;\n\nint goal = 0;\n\ntypedef pair<int,int> P ;\n\n\nmap<int,bool> done;\n\n\nP Q[2510000];\n\nint view(int bit){\n\tvector<int> s[3];\n\tfor(int i = 0 ; i < n ; i++)\n\t\ts[bit>>(i*2)&3].push_back(i);\n\tfor(int i = 0 ; i < 3 ; i++){\n\t\tcout << \"]\";\n\t\tfor(int j = 0 ; j < s[i].size() ; j++)\n\t\t\tcout << s[i][j];\n\t\tcout << endl;\n\t}\n}\nint main(){\n\tint m;\n\twhile(cin >> n >> m && n){\n\t\tint init = 0;\n\t\tfor(int i = 0 ; i < n ; i++) goal |= 2 << (i*2);\n\t\t\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tint t,a; cin >> t;\n\t\t\twhile(t--){cin >> a; a--; init |= (i) << (2*a); }\n\t\t}\n\t\t\n\t\tdone.clear();\n\t\tint head = 0 , size = 0;\n\t\tQ[size++] = P(init,0);\n\t\t\n\t\twhile(head < size){\n\t\t\tP &q = Q[head++];\n\t\t\tint stat = q.first;\n\t\t\tif(q.second > m) break;\n\t\t\tif(done[stat]) continue; else done[stat] = true;\n\t\t\tif(stat == goal || stat == 0){ cout << q.second << endl; goto hoge;}\n\t\t\tint mi[3] = {-1,-1,-1};\n\t\t\tfor(int i = n-1 ; i >= 0 ; i--){\n\t\t\t\tint num = stat>>(i*2)&3;\n\t\t\t\tif(mi[num]==-1)mi[num] = i;\n\t\t\t}\n\n\t\t\tfor(int from = 0 ; from < 3 ; from++){\n\t\t\t\tfor(int to = 0 ; to < 3 ; to++){\n\t\t\t\t\tif ( !( (from == 0 && to == 2) || (from == 2 && to == 0) ) && from != to && mi[from] != -1 && (mi[to] == -1 || mi[from] > mi[to]) ){\n\t\t\t\t\t\tint next = (stat & ~(3<<(2*mi[from]))) | (to<<(2*mi[from]));\n\t\t\t\t\t\tif(!done[next])Q[size++] = P(next,q.second+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\thoge:;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint saiki(int a,int b,int c){\n    if(!a&&!b) return 0;\n    if(c&1)return saiki(a>>1,b>>1,c>>1);\n    if(b&1)return saiki(c>>1,b>>1,a>>1) + saiki((a|b|c)>>1,0,0)+1;\n    if(a&1)return saiki(a>>1,b>>1,c>>1) + 2*saiki((a|b|c)>>1,0,0)+2;\n}\n\nint main(){\n    while(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n == 0 && m == 0 ) break;\n\tint cup[3];\n\tmemset(cup,0,sizeof(cup));\n\tREP(i,3){\n\t    int t;\n\t    cin >> t;\n\t    REP(j,t){\n\t\tint temp;\n\t\tcin >> temp;\n\t\tcup[i] |= 1<<(temp-1);\n\t    }\n\t}\n\t    int ans = min(saiki(cup[0],cup[1],cup[2]),saiki(cup[2],cup[1],cup[0]));\n\t    cout << (ans>m ? -1 : ans) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\ntypedef pair <int,P> PP;\ntypedef pair <int,PP> PPP;\n\nstatic const double eps = 1e-8;\n\nint bfs(int m,vector<int>& sets, map<vector<int>,int>& visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,sets));\n\tvisited[sets] = 0;\n\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tvector<int> sets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\tvector<int> tmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\tif(visited.find(tmp) == visited.end()){\n\t\t\t\t\tvisited[tmp] = cost + 1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\tvector<int> tmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tif(visited.find(tmp) == visited.end()){\n\t\t\t\t\tvisited[tmp] = cost + 1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tmap<vector<int>,int> visited;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,sets,visited));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<string>\n#include<climits>\n#include<deque>\n\nusing namespace std;\n\nint m;\nstack<int,vector<int> >A,B,C;\n\nint func(int,string);\n\nint main(void){\nint n,ans,s,t;\n\nwhile(cin >> n >> m,n|m){\nwhile(!A.empty())A.pop();\nwhile(!B.empty())B.pop();\nwhile(!C.empty())C.pop();\n\ncin >> s;\nfor(int i=0;i<s;i++){\ncin >> t;\nA.push(t);\n}\ncin >> s;\nfor(int i=0;i<s;i++){\ncin >> t;\nB.push(t);\n}\ncin >> s;\nfor(int i=0;i<s;i++){\ncin >> t;\nC.push(t);\n}\nans=func(0,\"\");\nif(ans==INT_MAX)cout << -1 << endl;\nelse cout << ans << endl;\n}\nreturn 0;\n}\n\nint func(int cnt,string p){\n\nif(cnt>m)return INT_MAX;\n\nif(B.empty()&&(C.empty()||A.empty()))\nreturn cnt;\n\nint res=INT_MAX;\n\nif(!A.empty() && A.top()>=B.top() && p!=\"BA\"){\nB.push(A.top());\nA.pop();\nres=min(res,func(cnt+1,\"AB\"));\nA.push(B.top());\nB.pop();\n}\n\nif(!B.empty()){\nif(B.top()>=C.top()&&p!=\"CB\"){\nC.push(B.top());\nB.pop();\nres=min(res,func(cnt+1,\"BC\"));\nB.push(C.top());\nC.pop();\n}\n\nif(B.top()>=A.top()&&p!=\"AB\"){\nA.push(B.top());\nB.pop();\nres=min(res,func(cnt+1,\"BA\"));\nB.push(A.top());\nA.pop();\n}\n}\n\nif(!C.empty() && C.top()>=B.top() && p!=\"BC\"){\nB.push(C.top());\nC.pop();\nres=min(res,func(cnt+1,\"CB\"));\nC.push(B.top());\nB.pop();\n}\n\nreturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tstring in = \"000000000000000\";\n\t\trep(i, 3) {\n\t\t\tint len; scanf(\"%d\", &len);\n\t\t\trep(j, len) {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tin[--a] = i + '0';\n\t\t\t}\n\t\t}\n\t\tmap<string, int>mp;\n\t\tqueue<string>que;\n\t\tmp[in] = 1;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tstring u = que.front(); que.pop();\n\t\t\tif (count(u.begin(), u.begin() + n, '0') == n || \n\t\t\t\tcount(u.begin(), u.begin() + n, '2') == n) {\n\t\t\t\tprintf(\"%d\\n\", mp[u] - 1);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (mp[u] > m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tint fi = (int)u.rfind(i + '0', n - 1),\n\t\t\t\t\tfj = (int)u.rfind(j + '0', n - 1);\n\t\t\t\tif (fi == -1 || fi < fj)continue;\n\t\t\t\tstring v = u;\n\t\t\t\tv[fi] = j + '0';\n\t\t\t\tif (!mp[v]) {\n\t\t\t\t\tmp[v] = mp[u] + 1;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,m;\nint cup[4][18]={0},cupn[4];\nint ans=1000000000;\nint san;\nvoid hanoi(int nowm,int cmd){\n\n    /*\n    printf(\"[%d][%d][%d]\\n\",cupn[0],cupn[1],cupn[2]);\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            printf(\"%d\",cup[i][j]);\n        }\n        puts(\"\");\n    }\n    */\n\n\n    if(m<nowm)\n        goto P;\n    else if(cupn[0]==n||cupn[2]==n){\n        ans=min(ans,nowm);\n    }\n    if(cmd!=1&&cmd!=2&&cupn[0]!=0){\n        if(cup[0][cupn[0]]>cup[1][cupn[1]]){\n            cup[1][cupn[1]+1]=cup[0][cupn[0]],cup[0][cupn[0]]=0;\n            cupn[0]--,cupn[1]++;\n            hanoi(nowm+1,1);\n            cup[0][cupn[0]+1]=cup[1][cupn[1]],cup[1][cupn[1]]=0;\n            cupn[1]--,cupn[0]++;\n        }\n    }\n    if(cmd!=1&&cmd!=2&&cupn[1]!=0){\n        if(cup[0][cupn[0]]<cup[1][cupn[1]]){\n            cup[0][cupn[0]+1]=cup[1][cupn[1]],cup[1][cupn[1]]=0;\n            cupn[1]--,cupn[0]++;\n            hanoi(nowm+1,2);\n            cup[1][cupn[1]+1]=cup[0][cupn[0]],cup[0][cupn[0]]=0;\n            cupn[0]--,cupn[1]++;\n        }\n    }\n    if(cmd!=3&&cmd!=4&&cupn[1]!=0){\n        if(cup[1][cupn[1]]>cup[2][cupn[2]]){\n            cup[2][cupn[2]+1]=cup[1][cupn[1]],cup[1][cupn[1]]=0;\n            cupn[1]--,cupn[2]++;\n            hanoi(nowm+1,3);\n            cup[1][cupn[1]+1]=cup[2][cupn[2]],cup[2][cupn[2]]=0;\n            cupn[1]++,cupn[2]--;\n        }\n    }\n    if(cmd!=3&&cmd!=4&&cupn[2]!=0){\n        if(cup[1][cupn[1]]<cup[2][cupn[2]]){\n            cup[1][cupn[1]+1]=cup[2][cupn[2]],cup[2][cupn[2]]=0;\n            cupn[1]++,cupn[2]--;\n            hanoi(nowm+1,4);\n            cup[2][cupn[2]+1]=cup[1][cupn[1]],cup[1][cupn[1]]=0;\n            cupn[1]--,cupn[2]++;\n        }\n    }\nP:\n    printf(\"\");\n    return;\n}\nint main(){\n    while(1){\n        for(int i=0;i<3;i++){\n            for(int j=0;j<18;j++)\n                cup[i][j]=0;\n        }\n        ans=1000000000;\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0)\n            break;\n        for(int i=0;i<3;i++){\n            scanf(\"%d\",&cupn[i]);\n            for(int j=1;j<=cupn[i];j++)\n                scanf(\"%d\",&cup[i][j]);\n        }\n        hanoi(0,0);\n        if(ans==1000000000)\n            ans=-1;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <stack>\n\n#define M_n 15\n#define M_m 15000000\n\nint main() {\n\tstd::vector< std::vector<int> > start(3);\n\tstd::vector< std::vector<int> > date(3);\n\tint n, m;\n\tint count, flag;\t// カウンタ＆フラグ\n\tint i, j, k, num;\n\n\twhile(1) {\n\t\tscanf(\"%d%d\", &n, &m);\n\t\t\n\t\tif( !n && !m ) break;\n\n\t\tfor(i = 0; i < 3; i++) {\n\t\t\tscanf(\"%d\", &k);\n\t\t\tstart[i].assign(1, 0);\n\t\t\tfor(j = 0; j < k; j++) {\n\t\t\t\tscanf(\"%d\", &num);\n\t\t\t\tstart[i].push_back( num );\n\t\t\t}\n\t\t}\n\t\tflag = 0;\n\t\tk = start[1].size();\n\t\tfor(j = 1; j < k; i++) {\n\t\t\tif( start[1][j] != j ) break;\n\t\t\tflag = !flag;\n\t\t}\n\t\tif(start[0][1] != j) flag = !flag;\n\t\t\n\t\tfor(i = 0; i < 3; i++) {\n\t\t\tdate[i].assign(1, 0);\n\t\t}\n\t\tfor(j = 0; j < n; j++) {\n\t\t\tdate[flag * 2].push_back( j + 1 );\n\t\t}\n\t\tcount = 0;\n\t\twhile(count <= m) {\n\t\t\tif( start == date ) break;\n\n\t\t\tif( date[flag].back() < date[flag + 1].back() ) {\n\t\t\t\tdate[flag].push_back( date[flag + 1].back() );\n\t\t\t\tdate[flag + 1].pop_back();\n\t\t\t} else {\n\t\t\t\tdate[flag + 1].push_back( date[flag]. back() );\n\t\t\t\tdate[flag].pop_back();\n\t\t\t}\n\t\t\tcount++;\n\t\t\tflag = !flag;\n\t\t}\n\t\tprintf(\"%d\\n\", count <= m ? count : -1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n\n#define MAX 16\n#define A 0\n#define B 1\n#define C 2\n#define P_MAX 3\n\nusing namespace std;\n\ntemplate<typename _T>\n_T &abs(const _T &x){if(x<0)return -x;else return x;}\n\nint cost[3][MAX];\n\nstruct Cups{\n\tCups(){\n\t\tcost = 0;\n\t\tv[0].reserve(MAX);\n\t\tv[1].reserve(MAX);\n\t\tv[2].reserve(MAX);\n\t}\n\tvector<int> v[P_MAX];\n\tint cost;\n};\n\nint BFS(int n, int m, Cups &st){\n\tint ret = 0;\n\tqueue<Cups> q;\n\tq.push( st );\n\n\twhile( !q.empty() ){\n\t\tCups cups;\n\t\tcups = q.front();\n\t\tq.pop();\n\n\t\t/* I¹ð */\n\t\tif( cups.v[A].size() == n || cups.v[C].size() == n ){\n\t\t\tret = cups.cost;\n\t\t\tbreak;\n\t\t}\n\n\t\tif( cups.cost > m )\n\t\t\tcontinue;\n\n\t\t//cout << \"BFS: \" << cups.cost << endl;\n\n\t\tfor(int i = A; i <= C; ++i){\n\t\t\tint mov_cnt = 1;\n\t\t\tint min_sz = -1;\n\t\t\tfor(int j = cups.v[i].size()-1; j >= 1; --j){\n\t\t\t\tif( cups.v[i][j] - cups.v[i][j-1] == 1 ){\n\t\t\t\t\t++mov_cnt;\n\t\t\t\t\tmin_sz = cups.v[i][j-1];\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( cups.v[i].size() == 1 )\n\t\t\t\tmin_sz = cups.v[i][ 0 ];\n\n\t\t\tif( min_sz == -1 )\n\t\t\t\tcontinue;\n\t\t\t//cout << \"From \" << ((char)(i + 'A')) << ' ' << mov_cnt;\n\t\t\t\n\t\t\tfor(int j = A; j <= C; ++j){\n\t\t\t\tif( i != j ){\n\t\t\t\t\tint d = abs( i - j );\n\t\t\t\t\tCups t = cups;\n\t\t\t\t\tint end = t.v[j].size() - 1;\n\t\t\t\t\tif( end >= 0 && t.v[j][end] > min_sz )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\t//cout << \" To \" << (char(j+'A')) << endl;\n\t\t\t\t\tt.v[j].insert( t.v[j].end(), t.v[i].end() - mov_cnt, t.v[i].end() );\n\t\t\t\t\tt.v[i].erase( t.v[i].end() - mov_cnt, t.v[i].end() );\n\t\t\t\t\tt.cost += cost[ d ][ mov_cnt ];\n\t\t\t\t\tq.push( t );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcost[1][1] = 1;\n\tcost[2][1] = 2;\n\tfor(int i = 1; i < 3; ++i){\n\t\tfor(int j = 2; j < MAX; ++j){\n\t\t\tif( i == 1 ){\n\t\t\t\tcost[i][j] = 3 * cost[i][j - 1] + 1;\n\t\t\t}else{\n\t\t\t\tcost[i][j] = 2 * cost[1][j];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tint n,m;\n\t\tint ans = 0;\n\t\tCups cups;\n\t\t\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif( n == 0 && m == 0 )\n\t\t\tbreak;\n\n\t\tfor(int i = 0; i < 3; ++i){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tfor(int j = 0; j < t; ++j){\n\t\t\t\tint tt;\n\t\t\t\tscanf(\"%d\", &tt);\n\t\t\t\tcups.v[i].push_back(tt);\n\t\t\t}\n\t\t}\n\t\tans = BFS(n,m,cups);\n\t\t\n\t\tprintf(\"%d\\n\", ans <= m ? ans : -1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint pow_(int a, int x) {\n    int val = 1;\n    for(int i = 0; i < x; ++i) val *= a;\n    return val;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<int> > goal(3);\n        for(int i = 0; i < 3; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int idx;\n                cin >> idx;\n                goal[i].push_back(idx-1);\n            }\n        }\n\n        vector<vector<int> > field(3);\n        for(int i = 0; i < N; ++i) {\n            field[0].push_back(i);\n        }\n\n        int turn = 0;\n        int prev_from = -1;\n        int prev_to = -1;\n        while(true) {\n            if(field == goal) {\n                break;\n            }\n            ++turn;\n            for(int from = 0; from < 3; ++from) {\n                if(field[from].size() == 0) continue;\n                const int glass = field[from].back();\n                const int to_1 = from-1;\n                const int to_2 = from+1;\n                if(!(from == prev_to && to_1 == prev_from) && to_1 >= 0 && (field[to_1].size() == 0 || field[to_1].back() < glass)) {\n                    field[to_1].push_back(glass);\n                    field[from].pop_back();\n                    prev_from = from;\n                    prev_to = to_1;\n                    break;\n                }\n                else if(!(from == prev_to && to_2 == prev_from) && to_2 < 3 && (field[to_2].size() == 0 || field[to_2].back() < glass)) {\n                    field[to_2].push_back(glass);\n                    field[from].pop_back();\n                    prev_from = from;\n                    prev_to = to_2;\n                    break;\n                }\n                else {\n                }\n            }\n        }\n        const int MAXTURN = pow_(3, N) - 1;\n        turn = min(turn, MAXTURN-turn);\n        if(turn > M) turn = -1;\n        cout << turn << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint T[16];\nint A[16], B[16];\nint n, m;\n\nint solve() {\n    int P[17];\n    P[n-1] = 2;\n    for ( int i = n-1; i > 0; -- i ) P[i-1] = 3 * P[i] + 2;\n    \n    A[n-1] = T[n-1];\n    B[n-1] = 2 - T[n-1];\n    for ( int i = n; i > 1; -- i ) {\n        if ( T[i-2] == 0 ) {\n            A[i-2] = A[i-1];\n            B[i-2] = A[i-1] + 2 * P[i-1] + 2;\n        } else if ( T[i-2] == 1 ) {\n            A[i-2] = B[i-1] + P[i-1] + 1;\n            B[i-2] = A[i-1] + P[i-1] + 1;\n        } else {\n            A[i-2] = A[i-1] + 2 * P[i-1] + 2;\n            B[i-2] = B[i-1];\n        }\n    }\n    int res = min( A[0], B[0] );\n    if ( res > m ) return -1;\n    return res;\n}\n\nint main() {\n    while ( cin >> n >> m && n ) {\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t --;\n                T[t] = i;\n            }\n        }\n\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n    int n,m;\n    while(1){\n        cin >> n >> m;\n        if(n == 0 && m == 0)break;\n        vector<int> cup;\n        bool flag = true;\n        rep(i,n) cup.push_back(0);\n        rep(i,3){\n            int n1;\n            cin >> n1;\n            rep(j,n1){\n                int n2;\n                cin >> n2;\n                n2--;\n                cup[n2] = i;\n            }\n        }//入力ここまで\n        queue<vector<int>> que;\n        que.push(cup);\n        map<vector<int>,int> mp;\n        mp[cup] = 0;\n        while(que.size()!=0){\n            cup = que.front();\n            que.pop();\n            //rep(i,cup.size())cout << cup[i];\n            //cout << endl;\n            int bigger[3] = {-1,-1,-1};\n            int maxcount = 0;\n            bool tray[3] ={true,true,true};\n            if(cup.size() == count(cup.begin(),cup.end(),0) ||cup.size() == count(cup.begin(),cup.end(),2)){\n                cout << mp[cup] << endl;\n                flag = false;\n                break;\n            }\n            rep(i,n){\n                int i2 = n-i-1;\n                rep(j,3){\n                    if(tray[j] == true && cup[i2] == j){\n                        tray[j] = false;\n                        bigger[maxcount] = i2;\n                        maxcount++;\n                        break;\n                    }\n                }\n                if(maxcount == 3)break;\n            }\n            int movecount = mp[cup] + 1;\n            if(movecount > m) break;\n            if(cup[bigger[0]]-1 >= 0){\n                cup[bigger[0]]--;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]++;\n            }\n            if(cup[bigger[0]]+1 <= 2){\n                cup[bigger[0]]++;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]--;\n            }\n            if(maxcount >= 2){\n                if(cup[bigger[1]]-1 >= 0 && cup[bigger[1]]-1 != cup[bigger[0]]){\n                    cup[bigger[1]]--;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]++;\n                }\n                else if(cup[bigger[1]]+1 <= 2 && cup[bigger[1]]+1 != cup[bigger[0]]){\n                    cup[bigger[1]]++;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]--;\n                }\n            }\n        }\n        if(flag) cout << \"-1\" << endl;\n        vector<int>().swap(cup);\n        mp.clear();\n        while(que.size()!=0)que.pop();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<stack>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nP mp[]={P(0,1),P(1,2),P(1,0),P(2,1)};\nint N,M;\nvoid printst(stack<int> st[3]){\n  puts(\"print\");\n  for(int i=0;i<3;i++){\n    if(st[i].empty()) printf(\"no\\n\");\n    else printf(\"%d\\n\",st[i].top());\n  }\n}\nint solve(stack<int> st[3],P p,int id){\n  int pr = p.F, ne = p.S;\n  st[ne].push( st[pr].top() );\n  st[pr].pop();\n  int co=1;\n  for(int i=co;i<=M;i++){\n    // printf(\"%d番目\\n\",i);\n    // printst(st);\n    if(st[0].size() == N  || st[2].size() == N ) break;\n    for(int j=0;j<4;j++){\n      if(j==(id+2)%4) continue;\n      pr=mp[j].F; ne=mp[j].S;\n      if(st[pr].empty()) continue;\n      bool f=false;\n      if(st[ne].empty()) f=true;\n      else if(st[pr].top() > st[ne].top()) f=true;\n      if(f){\n\tst[ne].push( st[pr].top() );\n\tst[pr].pop();\n\tid = j;\n\tbreak;\n      }\n    }\n      co++;\n  }\n  return co;\n}\nint main(){\n  while(1){\n    scanf(\"%d %d\",&N,&M);\n    if(!N && !M) break;\n    stack<int> st[3];\n    for(int i=0;i<3;i++)\n      while(!st[i].empty()) st[i].pop();\n    for(int i=0;i<3;i++){\n      int num;\n      scanf(\"%d\",&num);\n      for(int j=0;j<num;j++){\n\tint a;\n\tscanf(\"%d\",&a);\n\tst[i].push(a);\n      }\n    }\n    //    printst(st);\n    if(st[0].size() == N  || st[2].size() == N ){\n      printf(\"0\\n\");\n      continue;\n    }\n    int res = M+1;\n    for(int i=0;i<4;i++){\n      int pr=mp[i].F; int ne=mp[i].S;\n      bool f=false;\n      if(st[pr].empty()) continue;\n      if(st[ne].empty()) f=true;\n      else if(st[pr].top() > st[ne].top()) f=true;\n      if(f)\n\tres = min(res,solve(st,mp[i],i));\n      //      printf(\"%d  %d\\n\",i,res);\n    }\n    if(res == M+1) printf(\"-1\\n\");\n    else printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "c[];main(n,m,i,j,k,f){for(f=\"%d\\n\";scanf(\"%d%d\",&n,&m)*n;printf(f,j>m?i:j)){for(i=3;i--;)for(scanf(f,&j);j--;c[n-k]=i)scanf(f,&k);for(i=n;i--;k+=c[i])j-=pow(3,i)*abs(k*2%4-c[i]);j=fmin(~j,pow(3,n)+j);}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 3;\nconst int INF = 15000001;\n\nclass S{\npublic:\n  int t[N], cost;\n  S(int a = 0, int b = 0, int c = 0, int cost = 0) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n\nint n, m, ans;\n\nint calc(S s, int pres, int pret){\n  if(ans <= s.cost) return INF;\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  if(s.cost >= m) return INF;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<N;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(i == pret && j == pres) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          ans = min(ans, res);\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint solve(S s){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<N;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          ans = min(ans, res);\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[N];\n    for(int i=0;i<N;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    ans = INF;\n    cout << solve(S(data[0], data[1], data[2], 0)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n) return 0;\n    int c[15];\n    rep(i,3){\n      int x;\n      cin>>x;\n      rep(j,x){\n        int y;\n        cin>>y;\n        c[y-1] = i;\n      }\n    }\n    int o=0,p=1;\n    rep(i,n){\n      o += p*c[i];\n      p *= 3;\n    }\n    int t = p-1;\n    \n    queue<int> que;\n    int dist[15000000];\n    \n    rep(i,15000000) dist[i] = -1;\n    dist[o] = 0;\n    que.push(o);\n    \n    while(!que.empty()){\n      int x = que.front();\n      que.pop();\n       \n      int d[3] = {-1},e=x,g=1;\n      rep(i,n){\n        d[e%3] = g; \n        e/=3, g*=3;\n      }\n      if(d[0]>d[1]){ e = x + d[0]; if(dist[e]==-1){que.push(e); dist[e]=dist[x]+1;}}\n      if(d[0]<d[1]){ e = x - d[1]; if(dist[e]==-1){que.push(e); dist[e]=dist[x]+1;}}\n      if(d[1]>d[2]){ e = x + d[1]; if(dist[e]==-1){que.push(e); dist[e]=dist[x]+1;}}\n      if(d[1]<d[2]){ e = x - d[2]; if(dist[e]==-1){que.push(e); dist[e]=dist[x]+1;}}\n    }\n    if(min(dist[t],dist[0])<=m){\n      cout<<min(dist[t],dist[0])<<endl;\n    }else{cout<<-1<<endl;}\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint bl0[16]={};\nint nx0[16]={};\nint bl[16]={};\nint nx[16]={};\nint largest0[3]={};\nint largest[3]={};\n\nint main() {\n\tint n,m,k,a,b,s,l1,l2;\n\tint ss[2]={};\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n==0){ return 0;}\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin >> k;\n\t\t\tb=0;\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tcin >> a;\n\t\t\t\tbl0[a]=i;\n\t\t\t\tnx0[a]=b;\n\t\t\t\tb=a;\n\t\t\t}\n\t\t\tlargest0[i]=a;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<2;i++){\n\t\t\tss[i]=m+1;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tbl[j]=bl0[j];\n\t\t\t\tnx[j]=nx0[j];\n\t\t\t}\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tlargest[j]=largest0[j];\n\t\t\t}\n\t\t\tfor(int s=0;s<m;s++){\n\t\t\t\tl1=largest[(i+s)%2];\n\t\t\t\tl2=largest[(i+s)%2+1];\n\t\t\t\tif(l1==l2){\n\t\t\t\t\tss[i]=s;\n\t\t\t\t\ts=m;\n\t\t\t\t}\n\t\t\t\tif(l1>l2){\n\t\t\t\t\tlargest[(i+s)%2]=nx[l1];\n\t\t\t\t\tlargest[(i+s)%2+1]=l1;\n\t\t\t\t\tbl[l1]=(i+s)%2+1;\n\t\t\t\t\tnx[l1]=l2;\n\t\t\t\t}else{\n\t\t\t\t\tlargest[(i+s)%2]=l2;\n\t\t\t\t\tlargest[(i+s)%2+1]=nx[l2];\n\t\t\t\t\tbl[l2]=(i+s)%2;\n\t\t\t\t\tnx[l2]=l1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ss[0]<ss[1]){\n\t\t\ts=ss[0];\n\t\t}else{\n\t\t\ts=ss[1];\n\t\t}\n\t\t\n\t\tif( s<=m ){\n\t\t\tcout << s << endl;\n\t\t}else{\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n\n#define MAX 16\n#define A 0\n#define B 1\n#define C 2\n\nusing namespace std;\n\ntemplate<typename _T>\n_T &abs(const _T &x){if(x<0)return -x;else return x;}\n\nint cost[3][MAX];\nint main(){\n\tcost[1][1] = 1;\n\tcost[2][1] = 2;\n\tfor(int i = 1; i < 3; ++i){\n\t\tfor(int j = 2; j < MAX; ++j){\n\t\t\tif( i == 1 ){\n\t\t\t\tcost[i][j] = 3 * cost[i][j - 1] + 1;\n\t\t\t}else{\n\t\t\t\tcost[i][j] = 2 * cost[1][j];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tint ans = 0;\n\t\tint places[MAX];\n\t\tint maxs[3] = {0,};\n\t\tint nums[3] = {0,};\n\t\tint cups[3][MAX];\n\t\tint n,m;\n\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif( n == 0 && m == 0 )\n\t\t\tbreak;\n\n\t\tfor(int i = 0; i < 3; ++i){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tfor(int j = 0; j < t; ++j){\n\t\t\t\tscanf(\"%d\", &cups[i][j]);\n\t\t\t\tplaces[ cups[i][j] ] = i;\n\t\t\t\tnums[i]++;\n\t\t\t\tmaxs[i] = max(maxs[i],cups[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tif( nums[B] == 1 ){\n\t\t\tif( !( maxs[A] < maxs[B] && maxs[C] < maxs[B] ) ){\n\t\t\t\tif( maxs[A] < maxs[B] ){\n\t\t\t\t\tplaces[ cups[B][0] ] = A;\n\t\t\t\t\tans += 1;\n\t\t\t\t}else if( maxs[C] < maxs[B] ){\n\t\t\t\t\tplaces[ cups[B][0] ] = C;\n\t\t\t\t\tans += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = n; i >= 2; --i){\n\t\t\tint d = abs( places[ i ] - places[i - 1] );\n\t\t\tans += cost[d][n - i + 1];\n\t\t\tplaces[ i ] = places[ i - 1 ];\n\t\t}\n\n\t\tif( places[ 1 ] == B ){\n\t\t\tans += cost[1][n];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans <= m ? ans : -1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nbool visited[14500000];\n\n/*\nint mypow(int x,int n){\n\tint res = 1;\n\twhile(n>0){\t\t\n\t\tres *= x;\n\t\tif(n & 1) x = x*x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n*/\n\nint conv(vector<int>& sets,int n){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * pow(3.0,j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,int n,vector<int>& root,bool* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root,n)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(!visited[(next = conv(tmp,n))]){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(!visited[(next = conv(tmp,n))]){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\t\n\t\tmemset(visited,0,sizeof(visited));\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,n,sets,visited));\n\t}\n\t//printf(\"%d %d %d\\n\",mypow(3,0),mypow(3,1),mypow(3,2));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define _GLIBCXX_DEBUG\n#define all(v) (v).begin(),(v).end()\n\nusing ll=long long;\nusing pii=pair<int, int>;\nusing vi=vector<int>;\nusing vii=vector<vector<int>>;\n\nconst ll LINF=1LL<<60;\nconst int INF=1<<29;\nconst int MOD=1e9+7;\n\nvii cup;\nint n, m;\n\nll solve(int tray){\n    ll res=0;\n    vii tmp=cup;\n    for(int i=1; i<=n; i++){\n        int pos;\n        for(int j=0; j<3; j++){\n            if(tmp[j].empty()) continue;\n            if(tmp[j].back() == i){\n                pos=j;\n                tmp[j].pop_back();\n                break;\n            }\n        }\n        if(pos == tray) continue;\n        else if(abs(pos-tray) == 1){\n            res+=pow(3, n-i);\n            tray=tray==0?2:0;\n        }\n        else{\n            res+=pow(3,n-i)*2;\n        }\n        if(res > m) break;\n    }\n    return res;\n}\n\nint main(){\n    while(1){\n        cin >> n >> m;\n        if(n == 0 && m == 0) break;\n        cup.assign(3, vi(0));\n        for(int i=0; i<3; i++){\n            int c; cin >> c;\n            cup[i].resize(c);\n            for(auto &x : cup[i]) cin >> x;\n            reverse(all(cup[i]));\n        }\n\n        ll ans=solve(0);\n        ans=min(ans, solve(2));\n        if(ans > m) cout << -1 << endl;\n        else cout <<ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <queue>\nusing namespace std;\n#define F first\n#define S second\nconst int INF=100000000;\n\nint ans;\nunsigned int n,m;\n\n\nstruct state{\n\tstack<int> s[3];\n\tint count,from,to;\n\t/*\n\tstate(stack<int> hoge[3]){\n\t\tfor(int i=0; i<3; ++i){\n\t\t\ts[i]=hoge[i];\n\t\t}\n\t}\n\t*/\n};\n\nvoid bfs(stack<int> si[3],int f,int t){\n\tstate hoge;\n\tfor(int i=0 ;i<3; ++i) hoge.s[i]=si[i];\n\thoge.count=0;\n\thoge.from=f;\n\thoge.to=t;\n\tqueue<state> que;\n\tque.push(hoge);\n\twhile(!que.empty()){\n\t\tstate st=que.front();\n\t\tque.pop();\n\t\tif(st.count>m) continue;\n\t\tif(st.s[0].size()==n||st.s[2].size()==n){\n\t\t\tans=min(ans,st.count);\n\t\t\treturn;\n\t\t}\n\t\tif(!(st.from==1&&st.to==0)&&st.s[0].size()!=0&&(st.s[1].size()==0||st.s[0].top()>st.s[1].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[1].push(ns.s[0].top());\n\t\t\tns.s[0].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=0;\n\t\t\tns.to=1;\n\t\t\tque.push(ns);\n\t\t}\n\t\tif(!(st.from==0&&st.to==1)&&st.s[1].size()!=0&&(st.s[0].size()==0||st.s[1].top()>st.s[0].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[0].push(ns.s[1].top());\n\t\t\tns.s[1].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=1;\n\t\t\tns.to=0;\n\t\t\tque.push(ns);\n\t\t}\n\t\tif(!(st.from==2&&st.to==1)&&st.s[1].size()!=0&&(st.s[2].size()==0||st.s[1].top()>st.s[2].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[2].push(ns.s[1].top());\n\t\t\tns.s[1].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=1;\n\t\t\tns.to=2;\n\t\t\tque.push(ns);\n\t\t}\n\t\tif(!(st.from==1&&st.to==2)&&st.s[2].size()!=0&&(st.s[1].size()==0||st.s[2].top()>st.s[1].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[1].push(ns.s[2].top());\n\t\t\tns.s[2].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=2;\n\t\t\tns.to=1;\n\t\t\tque.push(ns);\n\t\t}\n\t}\n}\n\n/*\nvoid dfs(stack<int> s[3],int count,pair<int,int> f){\n\tif(count>m) return;\n\tif(s[0].size()==n||s[2].size()==n){\n\t\tans=min(ans,count);\n\t\treturn;\n\t}\n\t//f.F -->f.S\n\t//01 10 12 21\n\tif(!(f.F==1&&f.S==0)&&s[0].size()!=0&&(s[1].size()==0||s[0].top()>s[1].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[1].push(ns[0].top());\n\t\tns[0].pop();\n\t\tdfs(ns,count+1,pair<int,int>(0,1));\n\t}\n\tif(!(f.F==0&&f.S==1)&&s[1].size()!=0&&(s[0].size()==0||s[1].top()>s[0].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[0].push(ns[1].top());\n\t\tns[1].pop();\n\t\tdfs(ns,count+1,pair<int,int>(1,0));\n\t}\n\tif(!(f.F==2&&f.S==1)&&s[1].size()!=0&&(s[2].size()==0||s[1].top()>s[2].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[2].push(ns[1].top());\n\t\tns[1].pop();\n\t\tdfs(ns,count+1,pair<int,int>(1,2));\n\t}\n\tif(!(f.F==1&&f.S==2)&&s[2].size()!=0&&(s[1].size()==0||s[2].top()>s[1].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[1].push(ns[2].top());\n\t\tns[2].pop();\n\t\tdfs(ns,count+1,pair<int,int>(2,1));\n\t}\n}\n*/\n\nint main(){\n\twhile(cin >> n >> m){\n\tif(n==0&&m==0) break;\n\t\tans=INF;\n\t\tstack<int> cup[3];\n\t\tfor(int i=0; i<3; ++i){\n\t\t\tint q;\n\t\t\tcin >> q;\n\t\t\tfor(int j=0; j<q; ++j){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tcup[i].push(tmp);\n\t\t\t\t//cout << cup[i].top() << endl;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\t/*\n\t\tdfs(cup,0,pair<int,int>(0,1));\n\t\tdfs(cup,0,pair<int,int>(1,0));\n\t\tdfs(cup,0,pair<int,int>(1,2));\n\t\tdfs(cup,0,pair<int,int>(2,1));\n\t\t*/\n\t\tbfs(cup,0,1);\n\t\tbfs(cup,1,0);\n\t\tbfs(cup,1,2);\n\t\tbfs(cup,2,1);\n\t\tif(ans!=INF) cout << ans << endl;\n\t\telse cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef struct Cup\n{\n\tvector<int>P[3];\n\tint T;\n\tbool operator <(const Cup &a)const{ return T>a.T;};\n}S;\nint N,M;\nbool f[3][3][3][3][3][3][3][3][3][3][3][3][3][3][3];\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&M),N;)\n\t{\n\t\tCup tmp;\n\t\tint i,j,t,q,R=-1;\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=0;i<3;i++)\n\t\t{\n\t\t\tfor(scanf(\"%d\",&t),j=0;j<t;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&q);\n\t\t\t\ttmp.P[i].push_back(q);\n\t\t\t}\n\t\t}\n\n\t\ttmp.T=0;\n\t\tpriority_queue<Cup> Q;\n\t\tQ.push(tmp);\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\ttmp=Q.top();Q.pop();\n\t\t\tint p[15];\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tfor(int j=0;j<tmp.P[i].size();j++)\n\t\t\t\t\tp[tmp.P[i][j]-1]=i;\n\t\t\tif(f[p[0]][p[1]][p[2]][p[3]][p[4]][p[5]][p[6]][p[7]][p[8]][p[9]][p[10]][p[11]][p[12]][p[13]][p[14]])continue;\n\t\t\tif(tmp.T>M)continue;\n\t\t\tif(tmp.P[0].size()==N||tmp.P[2].size()==N)\n\t\t\t{\n\t\t\t\tR=tmp.T;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tfor(int j=-1;j<2;j++)\n\t\t\t\t{\n\t\t\t\t\tif(j&&i+j>=0&&i+j<3&&!tmp.P[i].empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tint tmp1=tmp.P[i].back();\n\t\t\t\t\t\tint tmp2=-1;\n\t\t\t\t\t\tif(!tmp.P[i+j].empty())\n\t\t\t\t\t\t\ttmp2=tmp.P[i+j].back();\n\t\t\t\t\t\tif(tmp1>tmp2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCup ins=tmp;\n\t\t\t\t\t\t\tins.P[i+j].push_back(tmp1);\n\t\t\t\t\t\t\tins.P[i].pop_back();\n\t\t\t\t\t\t\tins.T++;\n\t\t\t\t\t\t\tQ.push(ins);\n\t\t\t\t\t\t\tf[p[0]][p[1]][p[2]][p[3]][p[4]][p[5]][p[6]][p[7]][p[8]][p[9]][p[10]][p[11]][p[12]][p[13]][p[14]]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n\nint encode(const vector<int> &state) {\n  int h = 0;\n  REP(i, state.size())\n      h = h * 3 + state[i];\n  return h;\n}\n\nint decode(int h, vector<int>& out) {\n  int N = out.size();\n  REP(i, N) {\n      out[N - 1 - i] = h % 3;\n      h /= 3;\n  }\n}\n\nvector<int> move(vector<int> v, int from, int to) {\n  int maxFrom = -1, maxTo = -1;\n  REP(i, v.size()) {\n      if (v[i] == from && maxFrom < i) maxFrom = i;\n      if (v[i] == to && maxTo < i) maxTo = i;\n  }\n\n  if (maxFrom > maxTo) {\n      v[maxFrom] = to;\n  }\n  return v;\n}\n\nbool finish(vector<int> state) {\n  int N = state.size();\n  return N == count(state.begin(), state.end(), 0) ||\n      N == count(state.begin(), state.end(), 2);\n}\n\nbool visited[15000000];\n\nint main() {\n  for (int N, M; cin >> N >> M, (N || M); ) {\n      memset(visited, 0, sizeof(visited));\n\n      vector<int> state(N, -1);\n      for (int i = 0; i < 3; i++) {\n          int K; cin >> K;\n          while (K--) {\n              int a; cin >> a;\n              state[a - 1] = i;\n          }\n      }\n      queue<int> q;\n\n      visited[encode(state)] = true;\n      q.push(encode(state));\n      q.push(0);\n\n      int ans = -1;\n      while (!q.empty()) {\n          decode(q.front(), state); q.pop();\n//          REP(i, N) cout << state[i] << \" \"; cout << endl;\n          int step = q.front(); q.pop();\n          if (step > M) break;\n          if (finish(state)) {\n              ans = step;\n              break;\n          }\n\n          int next;\n          next = encode(move(state, 0, 1));\n          if (!visited[next]) {visited[next] = true; q.push(next); q.push(step + 1);}\n\n          next = encode(move(state, 1, 0));\n          if (!visited[next]) {visited[next] = true; q.push(next); q.push(step + 1);}\n\n          next = encode(move(state, 2, 1));\n          if (!visited[next]) {visited[next] = true; q.push(next); q.push(step + 1);}\n\n          next = encode(move(state, 1, 2));\n          if (!visited[next]) {visited[next] = true; q.push(next); q.push(step + 1);}\n      }\n      cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <functional>\n#define INPUT_FROM_FILE (1)\n\n#if INPUT_FROM_FILE\n#include <fstream>\n#endif\n\nconst char Max_n = 15;\n\nint f_A(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C);\nint f_B(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C);\nint f_C(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C);\n\nint f_A(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C){\n\tif(stack_B.empty() && stack_C.empty()){\n\t\treturn 0;\n\t}\n\tchar min_stack_A = !stack_A.empty() ? stack_A.front() : Max_n + 1;\n\tchar min_stack_B = !stack_B.empty() ? stack_B.front() : Max_n + 1;\n\tchar min_stack_C = !stack_C.empty() ? stack_C.front() : Max_n + 1;\n\n\tif(min_stack_A < min_stack_B && min_stack_A < min_stack_C){\n\t\tstack_A.pop_front();\n\t\treturn f_A(stack_A, stack_B, stack_C);\n\t}\n\tif(min_stack_B < min_stack_A && min_stack_B < min_stack_C){\n\t\tint n = 0;\n\n\t\tstack_B.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_C(stack_A, stack_B, stack_C) + int(pow(3, n));\n\t}\n\tif(min_stack_C < min_stack_A && min_stack_C < min_stack_B){\n\t\tint n = 0;\n\t\t\n\t\tstack_C.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_A(stack_A, stack_B, stack_C) + 2 * int(pow(3, n));\n\t}\n\n\tstd::cout << \"error f_A\" << std::endl;\n\texit(0);\n\treturn 0;\n}\n\nint f_B(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C){\n\tif(stack_A.empty() && stack_C.empty()){\n\t\treturn 0;\n\t}\n\tchar min_stack_A = !stack_A.empty() ? stack_A.front() : Max_n + 1;\n\tchar min_stack_B = !stack_B.empty() ? stack_B.front() : Max_n + 1;\n\tchar min_stack_C = !stack_C.empty() ? stack_C.front() : Max_n + 1;\n\n\tif(min_stack_A < min_stack_B && min_stack_A < min_stack_C){\n\t\tint n = 0;\n\t\t\n\t\tstack_A.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_C(stack_A, stack_B, stack_C) + (int(pow(3, n)) + 1) / 2;\n\t}\n\tif(min_stack_B < min_stack_A && min_stack_B < min_stack_C){\n\t\tstack_B.pop_front();\n\t\treturn f_B(stack_A, stack_B, stack_C);\n\t}\n\tif(min_stack_C < min_stack_A && min_stack_C < min_stack_B){\n\t\tint n = 0;\n\t\t\n\t\tstack_C.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_A(stack_A, stack_B, stack_C) + (int(pow(3, n)) + 1) / 2;\n\t}\n\n\tstd::cout << \"error f_B\" << std::endl;\n\texit(0);\n\treturn 0;\n}\n\nint f_C(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C){\n\tif(stack_A.empty() && stack_B.empty()){\n\t\treturn 0;\n\t}\n\tchar min_stack_A = !stack_A.empty() ? stack_A.front() : Max_n + 1;\n\tchar min_stack_B = !stack_B.empty() ? stack_B.front() : Max_n + 1;\n\tchar min_stack_C = !stack_C.empty() ? stack_C.front() : Max_n + 1;\n\n\tif(min_stack_A < min_stack_B && min_stack_A < min_stack_C){\n\t\tint n = 0;\n\n\t\tstack_A.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_C(stack_A, stack_B, stack_C) + 2 * int(pow(3, n));\n\t}\n\tif(min_stack_B < min_stack_A && min_stack_B < min_stack_C){\n\t\tint n = 0;\n\n\t\tstack_B.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_A(stack_A, stack_B, stack_C) + int(pow(3, n));\n\t}\n\tif(min_stack_C < min_stack_A && min_stack_C < min_stack_B){\n\t\tstack_C.pop_front();\n\t\treturn f_C(stack_A, stack_B, stack_C);\n\t}\n\n\tstd::cout << \"error f_C\" << std::endl;\n\texit(0);\n\treturn 0;\n}\n\nint main(int argc, char **argv){\n#if INPUT_FROM_FILE\n\tstd::ifstream ifs(\"test.txt\");\n#endif\n\tint n = 0;\n\tint m = 0;\n\n#if INPUT_FROM_FILE\n\twhile(ifs >> n >> m, (n != 0 || m != 0)){\n#else\n\twhile(std::cin >> n >> m, (n != 0 || m != 0)){\n#endif\n\t\tstd::deque<char> tray[3];\n\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tint num_cups = 0;\n\n#if INPUT_FROM_FILE\n\t\t\tifs >> num_cups;\n#else\n\t\t\tstd::cin >> num_cups;\n#endif\n\t\t\tfor(int j = 0; j < num_cups; j++){\n\t\t\t\tchar c = 0;\n\n#if INPUT_FROM_FILE\n\t\t\t\tifs >> c;\n#else\n\t\t\t\tstd::cin >> c;\n#endif\n\t\t\t\ttray[i].push_back(c - '0');\n\t\t\t}\n\t\t}\n\t\t//??¢?´¢\n\t\t{\n\t\t\tint num_move =std::min(f_A(tray[0], tray[1], tray[2]), f_C(tray[0], tray[1], tray[2]));\n\t\t\t\n\t\t\tif(num_move <= m){\n\t\t\t\tstd::cout << num_move << std::endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstd::cout << -1 << std::endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint mp[4782970];\nint Hash(string s) {\n\tint cnt = 0, t = 1;\n\trep(i, s.size()) {\n\t\tcnt += (int)(s[i] - '0')*t;\n\t\tt *= 3;\n\t}\n\treturn cnt;\n}\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tmemset(mp, 0, sizeof(mp));\n\t\tstring in = \"000000000000000\";\n\t\trep(i, 3) {\n\t\t\tint len; scanf(\"%d\", &len);\n\t\t\trep(j, len) {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tin[--a] = i + '0';\n\t\t\t}\n\t\t}\n\t\tqueue<string>que;\n\t\tmp[Hash(in)] = 1;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tstring u = que.front(); que.pop();\n\t\t\tif (count(u.begin(), u.begin() + n, '0') == n ||\n\t\t\t\tcount(u.begin(), u.begin() + n, '2') == n) {\n\t\t\t\tprintf(\"%d\\n\", mp[Hash(u)] - 1);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (mp[Hash(u)] > m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tint fi = (int)u.rfind(i + '0', n - 1),\n\t\t\t\t\tfj = (int)u.rfind(j + '0', n - 1);\n\t\t\t\tif (fi == -1 || fi < fj)continue;\n\t\t\t\tstring v = u;\n\t\t\t\tv[fi] = j + '0';\n\t\t\t\tif (!mp[Hash(v)]) {\n\t\t\t\t\tmp[Hash(v)] = mp[Hash(u)] + 1;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 3;\nconst int INF = 15000001;\n\nclass S{\npublic:\n  int a, b, c, cost;\n  S(int a = 0, int b = 0, int c = 0, int cost = 0) : a(a), b(b), c(c), cost(cost){}\n};\n\nint n, m;\n//int ans;\n\nint calc(S s, int pres, int pret){\n  //if(ans <= s.cost) return INF;\n  if(s.a == (1 << n) - 1 || s.c == (1 << n) - 1) return s.cost;\n  if(s.cost >= m) return INF;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, 0);\n  for(int i=n-1;i>=0;i--){\n    if(s.a & 1 << i){\n      tmp[0] = i+1;\n      break;\n    }\n  }\n  for(int i=n-1;i>=0;i--){\n    if(s.b & 1 << i){\n      tmp[1] = i+1;\n      break;\n    }\n  }\n  for(int i=n-1;i>=0;i--){\n    if(s.c & 1 << i){\n      tmp[2] = i+1;\n      break;\n    }\n  }\n  if(tmp[0]){\n    for(int j=0;j<N;j++){\n      if(abs(0-j) != 1) continue;\n      if(0 == pret && j == pres) continue;\n      if(tmp[0] > tmp[j]){\n        S t = s;\n        t.a &= (~(1 << (tmp[0]-1)));\n        if(j == 0) t.a |= (1 << (tmp[0]-1));\n        if(j == 1) t.b |= (1 << (tmp[0]-1));\n        if(j == 2) t.c |= (1 << (tmp[0]-1));\n        t.cost++;\n        res = min(res, calc(t, 0, j));\n        //ans = min(ans, res);\n      }\n    }\n  }  \n  if(tmp[1]){\n    for(int j=0;j<N;j++){\n      if(abs(1-j) != 1) continue;\n      if(1 == pret && j == pres) continue;\n      if(tmp[1] > tmp[j]){\n        S t = s;\n        t.b &= (~(1 << (tmp[1]-1)));\n        if(j == 0) t.a |= (1 << (tmp[1]-1));\n        if(j == 1) t.b |= (1 << (tmp[1]-1));\n        if(j == 2) t.c |= (1 << (tmp[1]-1));\n        t.cost++;\n        res = min(res, calc(t, 1, j));\n        //ans = min(ans, res);\n      }\n    }\n  }\n  if(tmp[2]){\n    for(int j=0;j<N;j++){\n      if(abs(2-j) != 1) continue;\n      if(2 == pret && j == pres) continue;\n      if(tmp[2] > tmp[j]){\n        S t = s;\n        t.c &= (~(1 << (tmp[2]-1)));\n        if(j == 0) t.a |= (1 << (tmp[2]-1));\n        if(j == 1) t.b |= (1 << (tmp[2]-1));\n        if(j == 2) t.c |= (1 << (tmp[2]-1));\n        t.cost++;\n        res = min(res, calc(t, 2, j));\n        //ans = min(ans, res);\n      }\n    }\n  }\n  return res;\n}\n\n/*int solve(S s){\n  if(s.a == (1 << n) - 1 || s.c == (1 << n) - 1) return s.cost;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int j=0;j<N;j++){\n    for(int i=n-1;i>=0;i--){\n      if(s.t[j] & 1 << i){\n        tmp[j] = i+1;\n        break;\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i]){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= (~(1 << (tmp[i]-1)));\n          t.t[j] |= (1 << (tmp[i]-1));\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          //ans = min(ans, res);\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n*/\nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[N];\n    for(int i=0;i<N;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    //ans = INF;\n    int res = calc(S(data[0], data[1], data[2], 0), -1, -1);\n    cout << (res == INF ? -1 : res) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\nusing namespace std;\n\nconst int MAXN = 17;\nconst int SSIZE = 15000000;\nconst int INF = INT_MAX;\n\nconst int W = 3;\nint N, M;\n\nint three[MAXN];\nbool vis[SSIZE];\n\nvoid init() {\n  three[0] = 1;\n  for(int i = 1; i < MAXN; ++i) three[i] = three[i-1] * 3;\n}\n\nint get3(int s, int i) {\n  return s/three[i]%3;\n}\n\nint getTop(int s, int pos) {\n  int maxi = -1;\n  for(int i = 0; i < N; ++i) {\n    if(s % W == pos) maxi = i;\n    s /= W;\n  }\n  return maxi;\n}\n\nint move(int s, int from, int to) {\n  int a = getTop(s, from);\n  int b = getTop(s, to);\n  if(a == -1) return INF;\n  if(a < b) return INF;\n  s -= three[a] * from;\n  s += three[a] * to;\n  return s;\n}\n\nvoid show(int s) {\n  for(int i = 0; i < N; ++i) {\n    cout << s%3;\n    s /= 3;\n  }\n  cout << endl;\n}\n\nint bfs(int s) {\n  queue<pair<int, int> > que;\n  fill(vis, vis+SSIZE, false);\n  que.push(make_pair(s,0));\n  vis[s] = true;\n\n  int goal1, goal2;\n  goal1 = goal2 = 0;\n  for(int i = 0; i < N; ++i) goal2 += three[i]*2;\n  if(s == goal1 || s == goal2) {\n    return 0;\n  }\n\n  while(!que.empty()) {\n    s = que.front().first;\n    int cost = que.front().second;\n    que.pop();\n    if(cost == M) continue;\n    for(int i = 0; i < W; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tif(abs(i-j) != 1) continue;\n\tint ns = move(s, i, j);\n\tif(ns == INF) continue;\n\tif(vis[ns]) continue;\n\tif(ns == goal1 || ns == goal2) {\n\t  return cost+1;\n\t}\n\tvis[ns] = true;\n\tque.push(make_pair(ns, cost+1));\n      }\n    }\n  }\n  return INF;\n}\n\nint main() {\n  init();\n  while(cin >> N >> M && (N|M)) {\n    int sum = 0;\n    for(int i = 0; i < W; ++i) {\n      int k;\n      cin >> k;\n      while(k--) {\n\tint a;\n\tcin >> a;\n\t--a;\n\tsum += three[a] * i;\n      }\n    }\n    int ans = bfs(sum);\n    if(ans <= M) {\n      cout << ans << endl;\n    } else {\n      cout << -1 << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<stack<char> > > P;\ntypedef pair <int,P> PP;\ntypedef pair <int,PP> PPP;\n\nstatic const double eps = 1e-8;\n\nint bfs(int m,vector<stack<char> >& stks, map<vector<stack<char> >,int>& visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,stks));\n\tvisited[stks] = 0;\n\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\n\t\t\n\t\tvector<stack<char> > stks = que.top().second;\n\n\t\tif(stks[1].empty() && stks[2].empty()) return cost;\n\t\tif(stks[0].empty() && stks[1].empty()) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<stks.size();i++){\n\t\t\tif((!stks[i].empty() && !stks[i+1].empty() && stks[i].top() < stks[i+1].top()) \n\t\t\t\t|| (stks[i].empty() && !stks[i+1].empty())){\n\t\t\t\tvector<stack<char> > tmp = stks;\n\t\t\t\ttmp[i].push(tmp[i+1].top());\n\t\t\t\ttmp[i+1].pop();\n\t\t\t\tif(visited.find(tmp) == visited.end()){\n\t\t\t\t\tvisited[tmp] = cost + 1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((!stks[i].empty() && !stks[i+1].empty() && stks[i].top() > stks[i+1].top()) \n\t\t\t\t|| (!stks[i].empty() && stks[i+1].empty())){\n\t\t\t\tvector<stack<char> > tmp = stks;\n\t\t\t\ttmp[i+1].push(tmp[i].top());\n\t\t\t\ttmp[i].pop();\n\t\t\t\tif(visited.find(tmp) == visited.end()){\n\t\t\t\t\tvisited[tmp] = cost + 1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<stack<char> > stks(3);\n\t\tmap<vector<stack<char> >,int> visited;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tstks[i].push(size);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,stks,visited));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define rep(i,a) for(int i=0;i<(a);++i)\n\nint n, m;\nint S[3];\n\nint toC( int a, int b, int c )\n{\n\tif(c&1)\n\t\treturn toC(a>>1,b>>1,c>>1);\n\tif(b&1)\n\t\treturn toC(c>>1,b>>1,a>>1)+toC((a|b|c)>>1,0,0)+1;\n\tif(a&1)\n\t\treturn toC(a>>1,b>>1,c>>1)+2*toC((a|b|c)>>1,0,0)+2;\n}\n\nint main()\n{\n\twhile( scanf( \"%d%d\", &n, &m ), n|m )\n\t{\n\t\trep( i, 3 )\n\t\t\tS[i] = 0;\n\n\t\trep( t, 3 )\n\t\t{\n\t\t\tint c;\n\t\t\tscanf( \"%d\", &c );\n\n\t\t\trep( i, c )\n\t\t\t{\n\t\t\t\tint a;\n\t\t\t\tscanf( \"%d\", &a );\n\n\t\t\t\tS[t] |= 1<<a-1;\n\t\t\t}\n\t\t}\n\n\t\tint ans = std::min( toC(S[0],S[1],S[2]), toC(S[2],S[1],S[0]) );\n\t\n\t\tprintf( \"%d\\n\", ans<=m?ans:-1 );\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define perl(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\n#define vtpl(x,y,z) vector<tuple<x,y,z>>\n#define rev(x) reverse(x);\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[8]={1,0,-1,0,1,1,-1,-1};\nconst ll dx[8]={0,-1,0,1,1,-1,1,-1};\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nll encode(vector<stack<ll>> s){\n    ll res=0;\n    rep(i,3){\n        while(!s[i].empty()){\n            ll p=s[i].top();\n            s[i].pop();\n            if(p==-1)continue;\n            res+=(ll)pow(3,p)*i;\n        }\n    }\n    return res;\n}\nint main(){\n    while(true){\n        ll n,k;cin >> n >>k;\n        if(n==0&&k==0)break;\n        ll hash=0;\n        rep(i,3){\n            ll p;cin >> p;\n            rep(j,p){\n                ll a;cin >> a;a--;\n                hash+=(ll)pow(3,a)*i;\n            }\n        }\n        vl seen((ll)pow(3,n),-1);\n        queue<ll> que;\n        que.push(hash);\n        seen[hash]=0;\n        while(!que.empty()){\n            ll hash=que.front();que.pop();\n            if(seen[hash]>k){\n                cout << -1 <<endl;\n                break;\n            }\n            if(hash==0||hash==(ll)pow(3,n)-1){\n                cout << seen[hash] <<endl;\n                break;\n            }\n            vector<stack<ll>> v(3);\n            rep(i,3)v[i].push(-1);\n            ll hoge=hash;\n            rep(i,n){\n                ll a=hash%3;\n                v[a].push(i);\n                hash/=3;\n            }\n            rep(i,3){\n                if(i==0||i==1){\n                    if(v[i].top()>v[i+1].top()){\n                        ll h=pow(3,v[i].top())+hoge;\n                        if(seen[h]==-1){\n                            que.push(h);\n                            seen[h]=seen[hoge]+1;\n                        }\n                    }\n                }\n                if(i==1||i==2){\n                    if(v[i-1].top()<v[i].top()){\n                        ll h=-pow(3,v[i].top())+hoge;\n                        if(seen[h]==-1){\n                            que.push(h);\n                            seen[h]=seen[hoge]+1;\n                        }\n                    }\n                }                \n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//E? Nanndatte?\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint rec(vector<int>state[3],int a,int b)\n{\n\tvector<int>_cur[3];\n\tfor(int i=0;i<3;i++)\n\t{\n\t\t_cur[i]=state[i];\n\t}\n\tif(state[0].size()==a || state[2].size()==a) return 0;\n\tint s[3];\n\tfor(int i=0;i<3;i++) s[i]=_cur[i].size();\n\tint val=INF;\n\tif(s[0])\n\t{\n\t\tif(s[1] && _cur[1][s[1]-1]<_cur[0][s[0]-1])\n\t\t{\n\t\t\t_cur[1].pb(_cur[0][s[0]-1]);\n\t\t\t_cur[0].pop_back();\n\t\t\ts[1]++;\n\t\t\ts[0]--;\n\t\t\tval=min(val,rec(_cur[3],a,b-1));\n\t\t}\n\t\telse if(s[1])\n\t\t{\n\t\t\t_cur[0].pb(_cur[1][s[1]-1]);\n\t\t\t_cur[1].pop_back();\n\t\t\ts[0]++;\n\t\t\ts[1]--;\n\t\t\tval=min(val,rec(_cur[3],a,b));\n\t\t}\n\t}\n\tif(s[2])\n\t{\n\t\tif(s[1] && _cur[1][s[1]-1]<_cur[2][s[2]-1])\n\t\t{\n\t\t\t_cur[1].pb(_cur[2][s[2]-1]);\n\t\t\t_cur[2].pop_back();\n\t\t\ts[1]++;\n\t\t\ts[2]--;\n\t\t\tval=min(val,rec(_cur[3],a,b));\n\t\t}\n\t\telse if(s[1])\n\t\t{\n\t\t\t_cur[2].pb(_cur[1][s[1]-1]);\n\t\t\t_cur[1].pop_back();\n\t\t\ts[2]++;\n\t\t\ts[1]--;\n\t\t\tval=min(val,rec(_cur[3],a,b));\n\t\t}\n\t}\n\treturn val+1;\n}\nint main(){\n\tint n,k;\n\twhile(1)\n\t{\n\t\tcin >> n >> k;\n\t\tif(n+k==0) return 0;\n\t\tvector<int>cur[3];\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tint f;\n\t\t\tcin >> f;\n\t\t\tcur[i].resize(0);\n\t\t\tfor(int j=0;j<f;j++)\n\t\t\t{\n\t\t\t\tint d;\n\t\t\t\tcin >>d;\n\t\t\t\tcur[i].pb(d);\n\t\t\t}\n\t\t}\n\t\tint ans = rec(cur[3],n,k);\n\t\tif(ans>k) ans=-1;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include <stack>\nusing namespace std;\n \nint main()\n{\n    stack<int>a,b,c;\n    while(1)\n    {\n         \n        int count=0,n,m,check;\n        scanf(\"%d %d\",&n,&m);\n \n        if(n==0 && m==0)\n        {\n            break;\n        }\n     \n        int A,B,C,\n            kari;\n         \n        /*エラー対策*/\n        a.push(0);\n        b.push(0);\n        c.push(0);\n \n        scanf(\"%d\",&A);\n        for(int i=0;i<A;i++){\n            scanf(\"%d\",&kari);\n            a.push(kari);\n        }\n \n        scanf(\"%d\",&B);\n        for(int i=0;i<B;i++){\n            scanf(\"%d\",&kari);\n            b.push(kari);\n        }\n     \n        scanf(\"%d\",&C);\n        for(int i=0;i<C;i++){\n            scanf(\"%d\",&kari);\n            c.push(kari);\n        }\n         \n        while(1)\n        {\n            if(b.top()==0 && c.top()==0)\n                break;\n            if(a.top()<b.top() && a.top()<c.top()){\n                kari=b.top();\n                a.push(kari);\n                b.pop();\n                count++;\n                continue;\n            }\n            if(b.top()<c.top() ){\n                kari=c.top();\n                b.push(kari);\n                c.pop();\n                count++;\n                continue;\n            }\n            if(b.top()<a.top()){\n                kari=a.top();\n                b.push(kari);\n                a.pop();\n                count++;\n                continue;\n            }\n            if(c.top()<b.top() && a.top()!=b.top()-1){\n                kari=b.top();\n                c.push(kari);\n                b.pop();\n                count++;\n                continue;\n        }\n            else{\n                kari=b.top();\n                a.push(kari);\n                b.pop();\n                count++;\n                continue;\n            }\n        }\n        if(count<m || count==m){\n\t\t\tprintf(\"%d\\n\",count);\n\t\t\tcontinue;\n\t\t}\n        else {\n\t\t\tprintf(\"%d\\n\",-1);\n\t\t\tcontinue;\n\t\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint mp[15000000];\nint Hash(string s) {\n\tint cnt = 0, t = 1;\n\trep(i, s.size()) {\n\t\tcnt += (int)(s[i] - '0')*t;\n\t\tt *= 3;\n\t}\n\treturn cnt;\n}\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tmemset(mp, 0, sizeof(mp));\n\t\tstring in = \"000000000000000\";\n\t\trep(i, 3) {\n\t\t\tint len; scanf(\"%d\", &len);\n\t\t\trep(j, len) {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tin[--a] = i + '0';\n\t\t\t}\n\t\t}\n\t\tqueue<string>que;\n\t\tmp[Hash(in)] = 1;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tstring u = que.front(); que.pop();\n\t\t\tif (count(u.begin(), u.begin() + n, '0') == n ||\n\t\t\t\tcount(u.begin(), u.begin() + n, '2') == n) {\n\t\t\t\tprintf(\"%d\\n\", mp[Hash(u)] - 1);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (mp[Hash(u)] > m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tint fi = (int)u.rfind(i + '0', n - 1),\n\t\t\t\t\tfj = (int)u.rfind(j + '0', n - 1);\n\t\t\t\tif (fi == -1 || fi < fj)continue;\n\t\t\t\tstring v = u;\n\t\t\t\tv[fi] = j + '0';\n\t\t\t\tif (!mp[Hash(v)]) {\n\t\t\t\t\tmp[Hash(v)] = mp[Hash(u)] + 1;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\nconst int NONE = -1;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(A);\n        if ( u > v ) {\n            int ret = solve( A | u, remove_last(B), C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(C);\n        if ( u > v ) {\n            int ret = solve( A, remove_last(B), C | u, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == NONE && ret2 == NONE ) {\n            cout << -1 << endl;\n        } else if ( ret1 != NONE && ret2 != NONE ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != NONE ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != NONE ) {\n            cout << ret2 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <valarray>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nconst int INF = 1e9;\nconst double EPS = 1e-9;\nconst ll MOD = 1e9 + 7;\n\nint from[] = {0, 1, 1, 2}, to[] = {1, 0, 2, 1};\n\nint main()\n{\n  int n, m;\n  vector<int> c(16);\n  c[0] = 1;\n  for (int i = 0; i < 15; ++i)\n    c[i + 1] = c[i] * 3;\n  while (cin >> n >> m, n || m)\n  {\n    int cups = 0;\n    for (int i = 0; i < 3; ++i)\n    {\n      int cnt;\n      cin >> cnt;\n      for (int j = 0; j < cnt; ++j)\n      {\n        int t;\n        cin >> t;\n        t--;\n        cups += i * c[t];\n      }\n    }\n\n    vector<int> check(15000000, -1);\n    check[cups] = 0;\n\n    queue<int> q;\n    q = queue<int>();\n    q.emplace(cups);\n\n    while (!q.empty())\n    {\n      auto now_cups = q.front();\n      q.pop();\n\n      vector<int> tray(3, -1);\n      int tmp = now_cups;\n      for (int i = 0; i < n; ++i)\n      {\n        tray[tmp % 3] = i;\n        tmp /= 3;\n      }\n\n      for (int i = 0; i < 4; ++i)\n      {\n        int from_cup = tray[from[i]], to_cup = tray[to[i]];\n        if (from_cup > to_cup)\n        {\n          auto next_cups = now_cups + (to[i] - from[i]) * c[from_cup];\n          if (check[next_cups] == -1)\n          {\n            q.emplace(next_cups);\n            check[next_cups] = check[now_cups] + 1;\n          }\n        }\n      }\n    }\n    int left = 0, right = 0;\n    for (int i = 0; i < n; ++i)\n      right += 2 * c[i];\n    if (min(check[left], check[right]) <= m)\n      cout << min(check[left], check[right]) << endl;\n    else\n      cout << -1 << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <vector>\n#define INF 100000001\n\nusing namespace std;\ntypedef struct P_{\n\t\tvector<int> vec[3];\n\t\tint count = 0;\n} P;\nint n, m;\n\nint main(int argc, char const* argv[])\n{\n\tcin >> n >> m;\n\twhile(n != 0 || m != 0){\n\t\t\tP v;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tint a;\n\t\t\t\t\tcin >> a;\n\t\t\t\t\tfor(int j = 0; j < a; j++){\n\t\t\t\t\t\t\tint b;\n\t\t\t\t\t\t\tcin >> b;\n\t\t\t\t\t\t\tv.vec[i].push_back(b);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<P> q;\n\t\t\tv.count = 0;\n\t\t\tq.push(v);\n\t\t\twhile(!q.empty()){\n\t\t\t\t\tP p = q.front(); q.pop();\n\t\t\t\t\tif(p.count > m){\n\t\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(p.vec[0].size() == n || p.vec[2].size() == n){\n\t\t\t\t\t\t\tcout << p.count << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(p.vec[0].size() != 0){\n\t\t\t\t\t\t\tP np;\n\t\t\t\t\t\t\tnp.count = p.count + 1;\n\t\t\t\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\t\t\t\t\tcopy(p.vec[i].begin(), p.vec[i].end(), back_inserter(np.vec[i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(p.vec[1].size() == 0 || p.vec[1][p.vec[1].size()-1] < p.vec[0][p.vec[0].size()-1]){\n\t\t\t\t\t\t\t\t\tnp.vec[1].push_back(p.vec[0][p.vec[0].size()-1]);\n\t\t\t\t\t\t\t\t\tnp.vec[0].pop_back();\n\t\t\t\t\t\t\t\t\tq.push(np);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.vec[2].size() != 0){\n\t\t\t\t\t\t\tP np;\n\t\t\t\t\t\t\tnp.count = p.count + 1;\n\t\t\t\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\t\t\t\t\tcopy(p.vec[i].begin(), p.vec[i].end(), back_inserter(np.vec[i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(p.vec[1].size() == 0 || p.vec[1][p.vec[1].size()-1] < p.vec[2][p.vec[2].size()-1]){\n\t\t\t\t\t\t\t\t\tnp.vec[1].push_back(p.vec[2][p.vec[2].size()-1]);\n\t\t\t\t\t\t\t\t\tnp.vec[2].pop_back();\n\t\t\t\t\t\t\t\t\tq.push(np);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.vec[1].size() != 0){\n\t\t\t\t\t\t\tP np;\n\t\t\t\t\t\t\tnp.count = p.count + 1;\n\t\t\t\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\t\t\t\t\tcopy(p.vec[i].begin(), p.vec[i].end(), back_inserter(np.vec[i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(p.vec[0].size() == 0 || p.vec[0][p.vec[0].size()-1] < p.vec[1][p.vec[1].size()-1]){\n\t\t\t\t\t\t\t\t\tnp.vec[0].push_back(p.vec[1][p.vec[1].size()-1]);\n\t\t\t\t\t\t\t\t\tnp.vec[1].pop_back();\n\t\t\t\t\t\t\t\t\tq.push(np);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\t\t\t\t\tnp.vec[i].clear();\n\t\t\t\t\t\t\t\t\tcopy(p.vec[i].begin(), p.vec[i].end(), back_inserter(np.vec[i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(p.vec[2].size() == 0 || p.vec[2][p.vec[2].size()-1] < p.vec[1][p.vec[1].size()-1]){\n\t\t\t\t\t\t\t\t\tnp.vec[2].push_back(p.vec[1][p.vec[1].size()-1]);\n\t\t\t\t\t\t\t\t\tnp.vec[1].pop_back();\n\t\t\t\t\t\t\t\t\tq.push(np);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tp.vec[0].clear();\n\t\t\t\t\tp.vec[1].clear();\n\t\t\t\t\tp.vec[2].clear();\n\t\t\t}\n\n\t\t\tcin >> n >> m;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main()\n{\n\tint N, M, K;\n\twhile(cin>>N>>M && (N || M)){\n\t\t\n\t\t//iÔÚÉå«¢lªÇÌgCÉ¨¢Ä é©\n\t\tvector<int> v(N+1);\n\t\t\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tcin>>K;\n\t\t\tfor(int j = 0; j < K; j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tv[tmp] = i;\n\t\t\t}\n\t\t}\n\n\t\tvector<int> a(N+1), c(N+1);\n\t\ta[N] = v[N];\tc[N] = 2 - v[N];\n\n\t\tfor(int i = N; i > 1; i--)\n\t\t{\n\t\t\tswitch(v[i-1])\n\t\t\t{\n\t\t\tcase 0:\n\n\t\t\t\ta[i-1] = a[i];\n\t\t\t\tc[i-1] = c[i] + 2 * pow(3.0, N-i+1);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\ta[i-1] = c[i] + pow(3.0, N-i+1);\n\t\t\t\tc[i-1] = a[i] + pow(3.0, N-i+1);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t\n\t\t\t\ta[i-1] = a[i] + 2 * pow(3.0, N-i+1);\n\t\t\t\tc[i-1] = c[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint res = min(a[1], c[1]);\n\t\tif(M < res) res = -1;\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\ntypedef std::stack<int> Tray;\n\nbool moveNtoN(Tray tr[], int src, int dst){\n    if((tr[src]).empty() ||\n        !(tr[dst]).empty() && (tr[src]).top() < (tr[dst]).top()){\n        return false;\n    }\n    (tr[dst]).push((tr[src]).top());\n    (tr[src]).pop();\n    return true;\n}\n\nbool ifSorted(Tray tr[]){\n    return ((tr[1]).empty() && ((tr[0]).empty() || (tr[2].empty())));\n}\n\nint solve(Tray tr[], int m){\n    int lastMove;          // 0 : A->B, 1 : B->A, 2 : B->C, 3 : C->B\n    for(int j = 0; j < 2; j++){\n        if(ifSorted(tr)){\n            return 0;\n        }\n        lastMove = -1;\n        if(j == 0){\n            if(moveNtoN(tr, 0, 1)){ \n                lastMove = 0;\n            }\n            else if(moveNtoN(tr, 1, 0)){\n                lastMove = 1;\n            }\n        }\n        else {\n            if(moveNtoN(tr, 1, 2)){\n                lastMove = 2;\n            }\n            else if(moveNtoN(tr, 2, 1)){\n                lastMove = 3;\n            }\n        }\n        for(int i = 1; i <= m; i++){\n            if(ifSorted(tr)){\n                return i;\n            }\n            if(lastMove != 1 && moveNtoN(tr, 0, 1)){\n                lastMove = 0;\n            }\n            else if(lastMove != 0  && moveNtoN(tr, 1, 0)){\n                lastMove = 1;\n            }\n            else if(lastMove != 3 && moveNtoN(tr, 1, 2)){\n                lastMove = 2;\n            }\n            else if(lastMove != 2 && moveNtoN(tr, 2, 1)){\n                lastMove = 3;\n            }\n        }\n        if(ifSorted(tr)){\n            return m;\n        }\n    }\n    return -1;\n}\n\nint main(){\n    int n, m;\n    Tray trays[3];\n    while(1){\n        std::cin >> n >> m;\n        if(!(n || m)){\n            break;\n        }\n        for(int col = 0; col < 3; col++){\n            int nCups;                     // #cups on the line\n            std::cin >> nCups;\n            while(nCups--){\n                int cup;\n                std::cin >> cup;\n                (trays[col]).push(cup);\n            }\n        }\n        std::cout << solve(trays, m) << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\nconst int NONE = -1;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == NONE && ret2 == NONE ) {\n            cout << -1 << endl;\n        } else if ( ret1 != NONE && ret2 != NONE ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != NONE ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != NONE ) {\n            cout << ret2 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> mat;\n\nint n, m;\n\nbool isChange(int &from, int &to, mat &g) {\n    auto s = g[from];\n    auto t = g[to];\n    if (s.size() == 0) return false;\n    if (t.size() > 0 && t[t.size() - 1] > s[s.size() - 1]) return false;\n    t.push_back(s[s.size() - 1]);\n    s.erase(s.begin() + s.size() - 1);\n    g[from] = s;\n    g[to] = t;\n\n    return true;\n}\n\n\nbool change(int &now, int &pre, mat &g) {\n    vector<int> from = {0, 1, 1, 2};\n    vector<int> to = {1, 2, 0, 1};\n    for (int i = 0; i < 4; i++) {\n        if (to[i] == pre && from[i] == now) continue;\n        if (isChange(from[i], to[i], g)) {\n            now = to[i];\n            pre = from[i];\n\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    while (cin >> n >> m, n || m) {\n        mat v(3);\n        for (auto &i : v) {\n            int c; cin >> c;\n            for (int j = 0; j < c; j++) {\n                int x; cin >> x;\n                i.push_back(x);\n            }\n        }\n\n\n        mat g1(3), g2(3);\n        for (int i = 1; i <= n; i++) {\n            g1[0].push_back(i);\n            g2[2].push_back(i);\n        }\n\n        int res = 1 << 28;\n        vector<int> now = {0, 1, 1, 2};\n        vector<int> pre = {1, 0, 2, 1};\n        for (int i = 0; i < 4; i++) {\n            int tmp = 0;\n            auto g(v);\n            while (tmp <= m) {\n                if (g[0].size() == n || g[1].size() == n) break;\n                if (!change(now[i], pre[i], g)) {\n                    tmp = 1 << 28;\n                    break;\n                }\n                tmp++;\n            }\n            res = min(res, tmp);\n        }\n\n        cout << (res > m ? -1 : res) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N, M;\n\nclass hash_array {\npublic:\n  size_t operator()(const array<int, 3> &x) const {\n    const int C = 997;\n    size_t t = 0;\n    for (int i = 0; i != x.size(); ++i) {\n      t = t * C + x[i];\n    }\n    return t;\n  }\n};\nint solve(array<int, 3> const& target) {\n  queue<array<int, 3>> q;\n  int num = 0;\n  rep(i, N) num |= 1 << i;\n  q.push(array<int, 3>{{num, 0, 0}});\n  q.push(array<int, 3>{{0, 0, num}});\n\n  unordered_map<array<int, 3>, int, hash_array> mp;\n  mp[array<int, 3>{{num, 0, 0}}] = 0;\n  mp[array<int, 3>{{0, 0, num}}] = 0;\n\n  while(!q.empty()) {\n    auto v = q.front(); q.pop();\n    if(v == target) {\n      return mp[v];\n    }\n\n    rep(i, v.size()) {\n      for(int k=N-1; k>=0; k--) {\n        if(v[i] >> k & 1) {\n          if(i + 1 < 3) {\n            auto nv = v;\n            nv[i] ^= 1 << k;\n            if(nv[i + 1] < (1<<k)) {\n              nv[i + 1] ^= 1 << k;\n              if(mp.find(nv) == mp.end() && mp[v] + 1 <= M) {\n                mp[nv] = mp[v] + 1;\n                q.push(nv);\n              }\n            }\n          }\n\n          if(i - 1 >= 0) {\n            auto nv = v;\n            nv[i] ^= 1 << k;\n            if(nv[i - 1] < (1<<k)) {\n              nv[i - 1] ^= 1 << k;\n              if(mp.find(nv) == mp.end() && mp[v] + 1 <= M) {\n                mp[nv] = mp[v] + 1;\n                q.push(nv);\n              }\n            }\n          }\n\n          break;\n        }\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main() {\n  while(cin >> N >> M && (N|M)) {\n    array<int, 3> cups;\n    rep(i, 3) {\n      int n; cin >> n;\n      int num = 0;\n      rep(j, n) {\n        int k; cin >> k; k--;\n        num |= 1 << k;\n      }\n      cups[i] = num;\n    }\n    cout << solve(cups) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<string>\n#include<climits>\n#include<deque>\n\nusing namespace std;\n\nint m;\nstack<int,vector<int> >A,B,C;\n\nint func(int,string);\n\nint main(void){\nint n,ans;\nstring s;\n\nwhile(cin >> n >> m,n|m){\nwhile(!A.empty())A.pop();\nwhile(!B.empty())B.pop();\nwhile(!C.empty())C.pop();\ncin.ignore();\ngetline(cin,s);\nfor(int i=0;i<s.size();i++)\nif('0'<=s[i]&&s[i]<='9' && i>0)A.push(s[i]-'0');\n\ngetline(cin,s);\nfor(int i=0;i<s.size();i++)\nif('0'<=s[i]&&s[i]<='9' && i>0)B.push(s[i]-'0');\n\ngetline(cin,s);\nfor(int i=0;i<s.size();i++)\nif('0'<=s[i]&&s[i]<='9' && i>0)C.push(s[i]-'0');\n\nans=func(0,\"\");\nif(ans==INT_MAX)cout << -1 << endl;\nelse cout << ans << endl;\n}\nreturn 0;\n}\n\nint func(int cnt,string p){\n\nif(cnt>m)return INT_MAX;\n\nif(B.empty()&&(C.empty()||A.empty()))\nreturn cnt;\n\nint res=INT_MAX;\n\nif(!A.empty() && A.top()>=B.top() && p!=\"BA\"){\nB.push(A.top());\nA.pop();\nres=min(res,func(cnt+1,\"AB\"));\nA.push(B.top());\nB.pop();\n}\n\nif(!B.empty()){\nif(B.top()>=C.top()&&p!=\"CB\"){\nC.push(B.top());\nB.pop();\nres=min(res,func(cnt+1,\"BC\"));\nB.push(C.top());\nC.pop();\n}\n\nif(B.top()>=A.top()&&p!=\"AB\"){\nA.push(B.top());\nB.pop();\nres=min(res,func(cnt+1,\"BA\"));\nB.push(A.top());\nA.pop();\n}\n}\n\nif(!C.empty() && C.top()>=B.top() && p!=\"BC\"){\nB.push(C.top());\nC.pop();\nres=min(res,func(cnt+1,\"CB\"));\nC.push(B.top());\nB.pop();\n}\n\nreturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<string>\n#include<climits>\n#include<deque>\n\nusing namespace std;\n\nint m;\nstack<int,vector<int> >A,B,C;\n\nint func(){\n  \n  string p=\"\";\n  int cnt=0;\n\n  for(int i=0;i<m;i++){\n    \n    if(B.empty() && (C.empty()||A.empty()))return cnt;\n    \n    if(!A.empty() && A.top()>=B.top() && p!=\"BA\"){\n      B.push(A.top());\n      A.pop();\n      cnt++,p=\"AB\";\n    }\n    \n    if(!B.empty()){\n      if(B.top()>=C.top() && p!=\"CB\"){\n\tC.push(B.top());\n\tB.pop();\n\tcnt++,p=\"BC\";\n      }\n      \n      if(B.top()>=A.top() && p!=\"AB\"){\n\tA.push(B.top());\n\tB.pop();\n\tcnt++,p=\"BA\";\n      }\n    }\n    \n    if(!C.empty() && C.top()>=B.top() && p!=\"BC\"){\n      B.push(C.top());\n      C.pop();\n      cnt++,p=\"CB\";\n    }\n    \n  }\n  return INT_MAX;\n}\n\nint main(void){\n  int n,ans,s,t;\n  \n  while(cin >> n >> m,n|m){\n    while(!A.empty())A.pop();\n    while(!B.empty())B.pop();\n    while(!C.empty())C.pop();\n    \n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      A.push(t);\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      B.push(t);\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      C.push(t);\n    }\n\n    ans=func();\n\n    if(ans==INT_MAX)cout << -1 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint visited[14500000];\n\nint mypow(int x,int n){\n\tint res = 1;\n\twhile(n>0){\t\t\n\t\tres *= x;\n\t\tif(n & 1) x = x*x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\nint conv(vector<int>& sets,int n){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * mypow(3,j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,int n,vector<int>& root, int* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root,n)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp,n))] > cost + 1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp,n))] > cost + 1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\t\n\t\tmemset(visited,0x3f,sizeof(visited));\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,n,sets,visited));\n\t}\n\n\t//printf(\"%d %d %d\\n\",mypow(3,0),mypow(3,1),mypow(3,2));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint mp[4882970];\nint Hash(string s) {\n\tint cnt = 0, t = 1;\n\trep(i, s.size()) {\n\t\tcnt += (int)(s[i] - '0')*t;\n\t\tt *= 3;\n\t}\n\treturn cnt;\n}\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tmemset(mp, 0, sizeof(mp));\n\t\tstring in = \"000000000000000\";\n\t\trep(i, 3) {\n\t\t\tint len; scanf(\"%d\", &len);\n\t\t\trep(j, len) {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tin[--a] = i + '0';\n\t\t\t}\n\t\t}\n\t\tqueue<string>que;\n\t\tmp[Hash(in)] = 1;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tstring u = que.front(); que.pop();\n\t\t\tif (count(u.begin(), u.begin() + n, '0') == n ||\n\t\t\t\tcount(u.begin(), u.begin() + n, '2') == n) {\n\t\t\t\tprintf(\"%d\\n\", mp[Hash(u)] - 1);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (mp[Hash(u)] > m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tint fi = (int)u.rfind(i + '0', n - 1),\n\t\t\t\t\tfj = (int)u.rfind(j + '0', n - 1);\n\t\t\t\tif (fi == -1 || fi < fj)continue;\n\t\t\t\tstring v = u;\n\t\t\t\tv[fi] = j + '0';\n\t\t\t\tif (!mp[Hash(v)]) {\n\t\t\t\t\tmp[Hash(v)] = mp[Hash(u)] + 1;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<vvi,int> pvi;\nbool ok(vvi a){\n  return (a[0].empty()&&a[1].empty()) || (a[1].empty()&&a[2].empty());\n}\nvoid print(vvi a){\n  REP(i,a.size()){\n    printf(\"%d:\",i+1);\n    REP(j,a[i].size()){\n      printf(\"%d \",a[i][j]);\n    }\n    putchar('\\n');\n  }\n    putchar('\\n');\n}\nint solve(vvi a, int m){\n  queue<pvi> que;\n  set<vvi> memo;\n  que.push(pvi(a,0));\n  while(!que.empty()){\n    pvi p = que.front(); que.pop();\n    vvi na = p.first; int nt = p.second;\n    if(nt > m) return -1;\n    if(ok(na)) return nt;\n    if(memo.find(na)!=memo.end()) continue;\n    memo.insert(na);\n    //printf(\"--------------------\\n\");\n    //print(na);\n    REP(i,3)REP(j,3){\n      if(abs(i-j)== 1 && na[i].size() && (na[j].empty() || na[i].back() > na[j].back())){\n        vvi nna = na;\n        nna[j].push_back(nna[i].back());\n        nna[i].pop_back();\n        que.push(pvi(nna,nt+1));\n        //print(nna);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m){\n    cin.ignore();\n    vvi a(3);\n    REP(i,3){\n      int ps; cin>>ps;\n      while(ps--){\n        int tmp;\n        cin>>tmp;\n        a[i].push_back(tmp);\n      }\n    }\n    cout<<solve(a,m)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 入力\nint n, m;\nint a0, b0, c0; // トレイA, B, C上のコップの個数\nint A[15], B[15], C[15]; // トレイA, B, C上のコップ\n\nint solve() {\n    int ans = 100000000;\n    for (int i = 0; i < 2; i++) {\n        stack<int> a, b, c; // トレイA, B, C上のコップ\n        for (int j = 0; j < a0; j++) a.push(A[j]);\n        for (int j = 0; j < b0; j++) b.push(B[j]);\n        for (int j = 0; j < c0; j++) c.push(C[j]);\n        for (int j = 0; j <= m; j++) {\n            if (a.size() == n || c.size() == n) {\n                ans = min(ans, j);\n                break;\n            }\n            if (j % 2 == i) {\n                if (a.empty()) {\n                    a.push(b.top());\n                    b.pop();\n                }\n                else if (b.empty()) {\n                    b.push(a.top());\n                    a.pop();\n                }\n                else if (a.top() < b.top()) {\n                    a.push(b.top());\n                    b.pop();\n                }\n                else {\n                    b.push(a.top());\n                    a.pop();\n                }\n            }\n            else {\n                if (c.empty()) {\n                    c.push(b.top());\n                    b.pop();\n                }\n                else if (b.empty()) {\n                    b.push(c.top());\n                    c.pop();\n                }\n                else if (c.top() < b.top()) {\n                    c.push(b.top());\n                    b.pop();\n                }\n                else {\n                    b.push(c.top());\n                    c.pop();\n                }\n            }\n        }\n    }\n    if (ans == 100000000) return -1;\n    else return ans;\n}\n\nint main() {\n    while (true){\n        cin >> n >> m;\n        if (n == 0) break;\n        cin >> a0;\n        for (int i = 0; i < a0; i++) cin >> A[i];\n        cin >> b0;\n        for (int i = 0; i < b0; i++) cin >> B[i];\n        cin >> c0;\n        for (int i = 0; i < c0; i++) cin >> C[i];\n        cout << solve() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nint where[15];\nint n;\n\nll calc(int a,int b){\n\tll ans=1;\n\tif(b<=0)\treturn 0;\n\tfor(int i=0;i<b;i++){\n\t\tans*=a;\n\t}\n\treturn ans-1;\n}\n\nll check(bool left){\n\tll ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tint now=left?0:2;\n\t\tif(abs(now-where[i])==2){\n\t\t\tans+=2*calc(3,n-i-1)+2;\n\t\t}\n\t\telse if(where[i]==1){\n\t\t\tans+=calc(3,n-i-1)+1;\n\t\t\tleft^=1;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\trefrain:;\n\tint m;\tcin>>n>>m;\n\tif((n|m)==0)\treturn 0;\n\tint num,in;\n\tfor(int i=0;i<3;i++){\n\t\tcin>>num;\n\t\tfor(int j=0;j<num;j++){\n\t\t\tcin>>in;\n\t\t\twhere[in-1]=i;\n\t\t}\n\t}\n\tll ans=min(check(true),check(false));\n\tif(ans<=m)\tcout<<max(0LL,ans)<<endl;\n\telse \tcout<<-1<<endl;\n\tgoto refrain;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <queue>\nusing namespace std;\n#define F first\n#define S second\nconst int INF=100000000;\n\nint ans;\nunsigned int n,m;\n//vector<stack<int> > goal(3);\n\nstruct state{\n\tstack<int> s[3];\n\tint count,from,to;\n\t/*\n\tstate(stack<int> hoge[3]){\n\t\tfor(int i=0; i<3; ++i){\n\t\t\ts[i]=hoge[i];\n\t\t}\n\t}\n\t*/\n};\n\nvoid bfs(stack<int> si[3],int f,int t){\n\tstate hoge;\n\tfor(int i=0 ;i<3; ++i) hoge.s[i]=si[i];\n\thoge.count=0;\n\thoge.from=f;\n\thoge.to=t;\n\tqueue<state> que;\n\tque.push(hoge);\n\twhile(!que.empty()){\n\t\tstate st=que.front();\n\t\tque.pop();\n\t\t//cout << st.count << endl;\n\t\tif(st.count>m) continue;\n\t\tif(st.s[0].size()==n||st.s[2].size()==n){\n\t\t\tans=min(ans,st.count);\n\t\t\treturn;\n\t\t}\n\t\tif(!(st.from==1&&st.to==0)&&st.s[0].size()!=0&&(st.s[1].size()==0||st.s[0].top()>st.s[1].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[1].push(ns.s[0].top());\n\t\t\tns.s[0].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=0;\n\t\t\tns.to=1;\n\t\t\tque.push(ns);\n\t\t}\n\t\tif(!(st.from==0&&st.to==1)&&st.s[1].size()!=0&&(st.s[0].size()==0||st.s[1].top()>st.s[0].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[0].push(ns.s[1].top());\n\t\t\tns.s[1].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=1;\n\t\t\tns.to=0;\n\t\t\tque.push(ns);\n\t\t} else if(!(st.from==2&&st.to==1)&&st.s[1].size()!=0&&(st.s[2].size()==0||st.s[1].top()>st.s[2].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[2].push(ns.s[1].top());\n\t\t\tns.s[1].pop();//\n\t\t\t++ns.count;\n\t\t\tns.from=1;\n\t\t\tns.to=2;\n\t\t\tque.push(ns);\n\t\t}\n\t\tif(!(st.from==1&&st.to==2)&&st.s[2].size()!=0&&(st.s[1].size()==0||st.s[2].top()>st.s[1].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[1].push(ns.s[2].top());\n\t\t\tns.s[2].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=2;\n\t\t\tns.to=1;\n\t\t\tque.push(ns);\n\t\t}\n\t}\n}\n\n/*\nvoid dfs(stack<int> s[3],int count,pair<int,int> f){\n\tif(count>m) return;\n\tif(s[0].size()==n||s[2].size()==n){\n\t\tans=min(ans,count);\n\t\treturn;\n\t}\n\t//f.F -->f.S\n\t//01 10 12 21\n\tif(!(f.F==1&&f.S==0)&&s[0].size()!=0&&(s[1].size()==0||s[0].top()>s[1].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[1].push(ns[0].top());\n\t\tns[0].pop();\n\t\tdfs(ns,count+1,pair<int,int>(0,1));\n\t}\n\tif(!(f.F==0&&f.S==1)&&s[1].size()!=0&&(s[0].size()==0||s[1].top()>s[0].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[0].push(ns[1].top());\n\t\tns[1].pop();\n\t\tdfs(ns,count+1,pair<int,int>(1,0));\n\t}\n\tif(!(f.F==2&&f.S==1)&&s[1].size()!=0&&(s[2].size()==0||s[1].top()>s[2].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[2].push(ns[1].top());\n\t\tns[1].pop();\n\t\tdfs(ns,count+1,pair<int,int>(1,2));\n\t}\n\tif(!(f.F==1&&f.S==2)&&s[2].size()!=0&&(s[1].size()==0||s[2].top()>s[1].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[1].push(ns[2].top());\n\t\tns[2].pop();\n\t\tdfs(ns,count+1,pair<int,int>(2,1));\n\t}\n}\n*/\n\nint pow(int a,int b){\n\tint res=1;\n\tfor(int i=0; i<b; ++i){\n\t\tres*=a;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint pow3[16];\n\tfor(int i=1; i<=15; ++i){\n\t\tpow3[i]=pow(3,i)-1;\n\t}\n\twhile(cin >> n >> m){\n\tif(n==0&&m==0) break;\n\t\tans=INF;\n\t\tstack<int> cup[3];\n\t\tfor(int i=0; i<3; ++i){\n\t\t\tint q;\n\t\t\tcin >> q;\n\t\t\tfor(int j=0; j<q; ++j){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tcup[i].push(tmp);\n\t\t\t\t//cout << cup[i].top() << endl;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\t/*\n\t\tdfs(cup,0,pair<int,int>(0,1));\n\t\tdfs(cup,0,pair<int,int>(1,0));\n\t\tdfs(cup,0,pair<int,int>(1,2));\n\t\tdfs(cup,0,pair<int,int>(2,1));\n\t\t*/\n\t\tbfs(cup,0,1);\n\t\tbfs(cup,1,0);\n\t\tbfs(cup,1,2);\n\t\tbfs(cup,2,1);\n\t\t//cout << pow3[n] << endl;\n\t\t//cout << ans << endl;\n\t\tif(ans!=INF)ans=min(ans,pow3[n]-ans);\n\t\tif(ans!=INF) cout << ans << endl;\n\t\telse cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\ntypedef std::stack<int> Tray;\n\nbool moveNtoN(Tray tr[], int src, int dst){\n    if((tr[src]).empty() ||\n        !(tr[dst]).empty() && (tr[src]).top() < (tr[dst]).top()){\n        return false;\n    }\n    (tr[dst]).push((tr[src]).top());\n    (tr[src]).pop();\n    return true;\n}\n\nbool ifSorted(Tray tr[]){\n    return ((tr[1]).empty() && ((tr[0]).empty() || (tr[2].empty())));\n}\n\nint solve(Tray tr[], int m){\n    int lastMove;          // 0 : A->B, 1 : B->A, 2 : B->C, 3 : C->B\n    for(int j = 0; j < 2; j++){\n        if(ifSorted(tr)){\n            return 0;\n        }\n        lastMove = -1;\n        if(j == 0){\n            if(moveNtoN(tr, 0, 1)){ \n                lastMove = 0;\n            }\n            else if(moveNtoN(tr, 1, 0)){\n                lastMove = 1;\n            }\n        }\n        else {\n            if(moveNtoN(tr, 1, 2)){\n                lastMove = 2;\n            }\n            else if(moveNtoN(tr, 2, 1)){\n                lastMove = 3;\n            }\n        }\n        for(int i = 1; i <= m; i++){\n            if(ifSorted(tr)){\n                return i;\n            }\n            if(lastMove != 1 && moveNtoN(tr, 0, 1)){\n                lastMove = 0;\n            }\n            else if(lastMove != 0  && moveNtoN(tr, 1, 0)){\n                lastMove = 1;\n            }\n            else if(lastMove != 3 && moveNtoN(tr, 1, 2)){\n                lastMove = 2;\n            }\n            else if(lastMove != 2 && moveNtoN(tr, 2, 1)){\n                lastMove = 3;\n            }\n        }\n        if(ifSorted(tr)){\n            return m;\n        }\n    }\n    return -1;\n}\n\nint main(){\n    int n, m;\n    while(1){\n        std::cin >> n >> m;\n        if(!(n || m)){\n            break;\n        }\n        Tray trays[3];\n        for(int col = 0; col < 3; col++){\n            int nCups;                     // #cups on the line\n            std::cin >> nCups;\n            while(nCups--){\n                int cup;\n                std::cin >> cup;\n                (trays[col]).push(cup);\n            }\n        }\n        std::cout << solve(trays, m) << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "3 10\n1 1\n1 3\n1 2\n4 100\n1 3\n3 1 2 4\n0\n5 100\n0\n4 2 3 4 5\n1 1\n10 10000\n4 1 4 5 9\n3 2 3 7\n3 6 8 10\n15 15000000\n4 1 2 9 12\n6 4 7 11 13 14 15\n5 3 5 6 8 10\n0 0"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\nconst int NONE = -1;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u1 = get_last(B);\n        int v1 = get_last(A);\n        if ( u1 > v1 ) {\n            int ret1 = solve( A | u1, remove_last(B), C, turns + 1 );\n            if ( ret1 != NONE ) return ret1;\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == NONE && ret2 == NONE ) {\n            cout << -1 << endl;\n        } else if ( ret1 != NONE && ret2 != NONE ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != NONE ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != NONE ) {\n            cout << ret2 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define fi first\n#define se second\ntypedef pair<ll,ll> P;\nusing VP = vector<P>; using VVP = vector<VP>;\nusing VI = vector<ll>; using VVI = vector<VI>; using VVVI = vector<VVI>;\nconst int inf=1e9+7;\nconst ll INF=1LL<<61;\nconst ll mod=1e9+7;\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\npriority_queue<int> pq[3];\n\nint solve(int i){\n    if(pq[0].size()==1&&pq[1].size()==1) return 0;\n    if(pq[2].size()==1&&pq[1].size()==1) return 0;\n    if(i==0){\n        if(pq[1].top()<pq[2].top()){\n            //cout<<pq[2].top()<<endl;\n            pq[1].push(pq[2].top());\n            pq[2].pop();\n        }\n        else {\n            //cout<<pq[1].top()<<endl;\n            pq[2].push(pq[1].top());\n            pq[1].pop();\n        }\n    }\n    else {\n        if(pq[0].top()<pq[1].top()){\n            //cout<<pq[1].top()<<endl;\n            pq[0].push(pq[1].top());\n            pq[1].pop();\n        }\n        else {\n            //cout<<pq[0].top()<<endl;\n            pq[1].push(pq[0].top());\n            pq[0].pop();\n        }\n    }\n    return 1+solve(1-i);\n}\n\nint main(){\n    int i,j;\n    int n,m;\n    while(1){\n        cin>>n>>m;\n        if(n==0) return 0;\n        priority_queue<int> pq2[3];\n        for(i=0;i<3;i++){\n            int k;\n            cin>>k;\n            for(j=0;j<k;j++) {\n                int x;\n                cin>>x;\n                pq2[i].push(x);\n            }\n            pq2[i].push(0);\n        }\n        pq[0]=pq2[0];\n        pq[1]=pq2[1];\n        pq[2]=pq2[2];\n        //int ans=min(solve(0),solve(1));\n        int ans=solve(0);\n        pq[0]=pq2[0];\n        pq[1]=pq2[1];\n        pq[2]=pq2[2];\n        int ans2=solve(1);\n        ans=min(ans,ans2);\n        cout<<((ans<=m) ? ans : -1)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\nconst int NONE = -1;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u1 = get_last(B);\n        int v1 = get_last(A);\n        if ( u1 > v1 ) {\n            int ret1 = solve( A | u1, remove_last(B), C, turns + 1 );\n            if ( ret1 != NONE ) return ret1;\n        }\n        int u2 = get_last(B);\n        int v2 = get_last(C);\n        if ( u2 > v2 ) {\n            int ret2 = solve( A, remove_last(B), C | u2, turns + 1 );\n            if ( ret2 != NONE ) return ret2;\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == NONE && ret2 == NONE ) {\n            cout << -1 << endl;\n        } else if ( ret1 != NONE && ret2 != NONE ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != NONE ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != NONE ) {\n            cout << ret2 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void){\n    int n, m, a[1000], b[10000][1000] = { 0 };\n    scanf(\"%d %d\", &n, &m);\n    while ( 1 ) {\n        for ( i = 0; i < n; i++ ) {\n            scanf(\"%d\", &a[i]);\n            for ( j = 0; j < a[i]; j++ ) {\n                scanf(\"%d\", &b[i][j]);\n            }\n        }\n        for ( i = 0; i < m; i++ ) {\n            for ( j = 0; j < n; i++ ) {\n                for ( x = )\n            }\n        }\n        scanf(\"%d %d\", &n, &m);\n        if ( n == 0 && m == 0 ) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint solve(int x, int y, int z) {\n\tif (!x && !y) return 0;\n\tif (z & 1) return solve(x >> 1, y >> 1, z >> 1);\n\tif (y & 1) return solve(z >> 1, y >> 1, x >> 1) + solve((x | y | z) >> 1, 0, 0) + 1;\n\tif (x & 1) return solve(x >> 1, y >> 1, z >> 1) + 2 * solve((x | y | z) >> 1, 0, 0) + 2;\n}\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n + m) {\n\t\tint c[3] = {};\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint t; cin >> t;\n\t\t\tfor (int j = 0; j < t; ++j) {\n\t\t\t\tint a; cin >> a;\n\t\t\t\tc[i] |= 1 << a - 1;\n\t\t\t}\n\t\t}\n\t\tint ans = min(solve(c[0], c[1], c[2]), solve(c[2], c[1], c[0]));\n\t\tcout << (ans <= m ? ans : -1) << endl;\n\t}\n\t\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <queue>\nusing namespace std;\n#define F first\n#define S second\nconst int INF=100000000;\n\n/*\nint ans;\nunsigned int n,m;\n\nstruct state{\n\tstack<int> s[3];\n\tint count,from,to;\n};\n\nvoid bfs(stack<int> si[3],int f,int t){\n\tstate hoge;\n\tfor(int i=0 ;i<3; ++i) hoge.s[i]=si[i];\n\thoge.count=0;\n\thoge.from=f;\n\thoge.to=t;\n\tqueue<state> que;\n\tque.push(hoge);\n\twhile(!que.empty()){\n\t\tstate st=que.front();\n\t\tque.pop();\n\t\t//cout << st.count << endl;\n\t\t//if(st.count>m) continue;\n\t\tif(st.s[0].size()==n||st.s[2].size()==n){\n\t\t\tans=min(ans,st.count);\n\t\t\treturn;\n\t\t}\n\t\tif(!(st.from==1&&st.to==0)&&st.s[0].size()!=0&&(st.s[1].size()==0||st.s[0].top()>st.s[1].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[1].push(ns.s[0].top());\n\t\t\tns.s[0].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=0;\n\t\t\tns.to=1;\n\t\t\tque.push(ns);\n\t\t}\n\t\tif(!(st.from==0&&st.to==1)&&st.s[1].size()!=0&&(st.s[0].size()==0||st.s[1].top()>st.s[0].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[0].push(ns.s[1].top());\n\t\t\tns.s[1].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=1;\n\t\t\tns.to=0;\n\t\t\tque.push(ns);\n\t\t} else if(!(st.from==2&&st.to==1)&&st.s[1].size()!=0&&(st.s[2].size()==0||st.s[1].top()>st.s[2].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[2].push(ns.s[1].top());\n\t\t\tns.s[1].pop();//\n\t\t\t++ns.count;\n\t\t\tns.from=1;\n\t\t\tns.to=2;\n\t\t\tque.push(ns);\n\t\t}\n\t\tif(!(st.from==1&&st.to==2)&&st.s[2].size()!=0&&(st.s[1].size()==0||st.s[2].top()>st.s[1].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[1].push(ns.s[2].top());\n\t\t\tns.s[2].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=2;\n\t\t\tns.to=1;\n\t\t\tque.push(ns);\n\t\t}\n\t}\n}\n\nint pow(int a,int b){\n\tint res=1;\n\tfor(int i=0; i<b; ++i){\n\t\tres*=a;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint pow3[16];\n\tfor(int i=1; i<=15; ++i){\n\t\tpow3[i]=pow(3,i)-1;\n\t}\n\twhile(cin >> n >> m){\n\tif(n==0&&m==0) break;\n\t\tans=INF;\n\t\tstack<int> cup[3];\n\t\tfor(int i=0; i<3; ++i){\n\t\t\tint q;\n\t\t\tcin >> q;\n\t\t\tfor(int j=0; j<q; ++j){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tcup[i].push(tmp);\n\t\t\t}\n\t\t}\n\t\tbfs(cup,0,1);\n\t\tif(ans!=INF)bfs(cup,1,0);\n\t\tif(ans!=INF)bfs(cup,1,2);\n\t\tif(ans!=INF)bfs(cup,2,1);\n\t\tif(ans!=INF)ans=min(ans,pow3[n]-ans);\n\t\tif(ans!=INF) cout << ans << endl;\n\t\telse cout << -1 << endl;\n\t}\n\treturn 0;\n}\n*/\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m){\n\t\tif(n==0&&m==0) break;\n\t\tvector<vector<int> > goal(3);\n\t\tfor(int i=0; i<3; ++i){\n\t\t\tint q;\n\t\t\tcin >> q;\n\t\t\tfor(int j=0; j<q; ++j){\n\t\t\t\t\tint tmp;\n\t\t\t\t\tcin >> tmp;\n\t\t\t\t\tgoal[i].push_back(tmp-1);\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int> > field(3);\n\t\tfor(int i=0; i<n; ++i) field[0].push_back(i);\n\t\t\n\t\tint turn=0;\n\t\tint prev_from=-1;\n\t\tint prev_to=-1;\n\t\twhile(true){\n\t\t\tif(field==goal) break;\n\t\t\t++turn;\n\t\t\tfor(int from=0; from<3; ++from){\n\t\t\t\tif(field[from].size()==0) continue;\n\t\t\t\tconst int cup=field[from].back();\n\t\t\t\tconst int to_1=from-1;\n\t\t\t\tconst int to_2=from+1;\n\t\t\t\tif(!(from==prev_to&&to_1==prev_from)&&to_1>=0&&(field[to_1].size()==0||field[to_1].back()<cup)){\n\t\t\t\t\tfield[to_1].push_back(cup);\n\t\t\t\t\tfield[from].pop_back();\n\t\t\t\t\tprev_from=from;\n\t\t\t\t\tprev_to=to_1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(!(from==prev_to&&to_2==prev_from)&&to_2<3&&(field[to_2].size()==0||field[to_2].back()<cup)){\n\t\t\t\t\tfield[to_2].push_back(cup);\n\t\t\t\t\tfield[from].pop_back();\n\t\t\t\t\tprev_from=from;\n\t\t\t\t\tprev_to=to_2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint MAXTURN=1;\n\t\tfor(int i=0; i<n; ++i) MAXTURN*=3;\n\t\t--MAXTURN;\n\t\tturn=min(turn,MAXTURN-turn);\n\t\tif(turn>m) cout << -1 << endl;\n\t\telse cout << turn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <vector>\n#define INF 100000001\n\nusing namespace std;\ntypedef struct P_{\n\t\tvector<int> vec[3];\n\t\tint count = 0;\n} P;\nint n, m;\n\nint main(int argc, char const* argv[])\n{\n\tcin >> n >> m;\n\twhile(n != 0 || m != 0){\n\t\t\tP v;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tint a;\n\t\t\t\t\tcin >> a;\n\t\t\t\t\tfor(int j = 0; j < a; j++){\n\t\t\t\t\t\t\tint b;\n\t\t\t\t\t\t\tcin >> b;\n\t\t\t\t\t\t\tv.vec[i].push_back(b);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<P> q;\n\t\t\tv.count = 0;\n\t\t\tq.push(v);\n\t\t\twhile(!q.empty()){\n\t\t\t\t\tP p = q.front(); q.pop();\n\t\t\t\t\tif(p.count > m){\n\t\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(p.vec[0].size() == n || p.vec[2].size() == n){\n\t\t\t\t\t\t\tcout << p.count << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(p.vec[0].size() != 0){\n\t\t\t\t\t\t\tP np;\n\t\t\t\t\t\t\tnp.count = p.count + 1;\n\t\t\t\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\t\t\t\t\tcopy(p.vec[i].begin(), p.vec[i].end(), back_inserter(np.vec[i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(p.vec[1].size() == 0 || p.vec[1][p.vec[1].size()-1] < p.vec[0][p.vec[0].size()-1]){\n\t\t\t\t\t\t\t\t\tnp.vec[1].push_back(p.vec[0][p.vec[0].size()-1]);\n\t\t\t\t\t\t\t\t\tnp.vec[0].pop_back();\n\t\t\t\t\t\t\t\t\tq.push(np);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.vec[2].size() != 0){\n\t\t\t\t\t\t\tP np;\n\t\t\t\t\t\t\tnp.count = p.count + 1;\n\t\t\t\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\t\t\t\t\tcopy(p.vec[i].begin(), p.vec[i].end(), back_inserter(np.vec[i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(p.vec[1].size() == 0 || p.vec[1][p.vec[1].size()-1] < p.vec[2][p.vec[2].size()-1]){\n\t\t\t\t\t\t\t\t\tnp.vec[1].push_back(p.vec[2][p.vec[2].size()-1]);\n\t\t\t\t\t\t\t\t\tnp.vec[2].pop_back();\n\t\t\t\t\t\t\t\t\tq.push(np);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.vec[1].size() != 0){\n\t\t\t\t\t\t\tP np;\n\t\t\t\t\t\t\tnp.count = p.count + 1;\n\t\t\t\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\t\t\t\t\tcopy(p.vec[i].begin(), p.vec[i].end(), back_inserter(np.vec[i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(p.vec[0].size() == 0 || p.vec[0][p.vec[0].size()-1] < p.vec[1][p.vec[1].size()-1]){\n\t\t\t\t\t\t\t\t\tnp.vec[0].push_back(p.vec[1][p.vec[1].size()-1]);\n\t\t\t\t\t\t\t\t\tnp.vec[1].pop_back();\n\t\t\t\t\t\t\t\t\tq.push(np);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\t\t\t\t\tnp.vec[i].clear();\n\t\t\t\t\t\t\t\t\tcopy(p.vec[i].begin(), p.vec[i].end(), back_inserter(np.vec[i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(p.vec[2].size() == 0 || p.vec[2][p.vec[2].size()-1] < p.vec[1][p.vec[1].size()-1]){\n\t\t\t\t\t\t\t\t\tnp.vec[2].push_back(p.vec[1][p.vec[1].size()-1]);\n\t\t\t\t\t\t\t\t\tnp.vec[1].pop_back();\n\t\t\t\t\t\t\t\t\tq.push(np);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tcin >> n >> m;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<vvi,int> pvi;\nbool ok(vvi a){\n  return (a[0].empty()&&a[1].empty()) || (a[1].empty()&&a[2].empty());\n}\nvoid print(vvi a){\n  REP(i,a.size()){\n    printf(\"%d:\",i+1);\n    REP(j,a[i].size()){\n      printf(\"%d \",a[i][j]);\n    }\n    putchar('\\n');\n  }\n    putchar('\\n');\n}\nint toi(vvi a){\n  int res = 0;\n  REP(i,a[1].size()) res += pow(3.0, a[1][i]);\n  REP(i,a[2].size()) res += pow(3.0, a[2][i]) * 2;\n  return res;\n}\nbool used[14350000];\nint solve(vvi a, int m){\n  queue<pvi> que;\n  que.push(pvi(a,0));\n  memset(used, 0, sizeof(used));\n  while(!que.empty()){\n    pvi p = que.front(); que.pop();\n    vvi na = p.first; int nt = p.second;\n    if(nt > m) return -1;\n    if(ok(na)) return nt;\n    int useidx = toi(na);\n    if(used[useidx]) continue;\n    used[useidx] = true;\n    //printf(\"--------------------\\n\");\n    //print(na);\n    REP(i,3)REP(j,3){\n      if(abs(i-j)== 1 && na[i].size() && (na[j].empty() || na[i].back() > na[j].back())){\n        vvi nna = na;\n        nna[j].push_back(nna[i].back());\n        nna[i].pop_back();\n        useidx = toi(nna);\n        if(used[useidx]) continue;\n        que.push(pvi(nna, nt + 1));\n        //print(nna);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m){\n    cin.ignore();\n    vvi a(3);\n    REP(i,3){\n      int ps; cin>>ps;\n      while(ps--){\n        int tmp;\n        cin>>tmp;\n        a[i].push_back(tmp);\n      }\n    }\n    cout<<solve(a,m)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint bfs[15000000], power[20], n, K, b, c, a[15];\nqueue<vector<int> >Q;\nint hush(vector<int>v) {\n\tint p = 0;\n\tfor (int i = 0; i < v.size(); i++) p += power[i] * v[i];\n\treturn p;\n}\nint main() {\n\tpower[0] = 1;\n\tfor (int i = 1; i < 20; i++)power[i] = power[i - 1] * 3;\n\twhile (true) {\n\t\tfor (int i = 0; i < 15000000; i++)bfs[i] = 1000000000;\n\t\tcin >> n >> K; vector<int>s;\n\t\tif (n == 0 && K == 0)break;\n\t\tcin >> b; for (int i = 0; i < b; i++) { cin >> c; a[c - 1] = 0; }\n\t\tcin >> b; for (int i = 0; i < b; i++) { cin >> c; a[c - 1] = 1; }\n\t\tcin >> b; for (int i = 0; i < b; i++) { cin >> c; a[c - 1] = 2; }\n\t\tfor (int i = 0; i < n; i++)s.push_back(a[i]);\n\t\tbfs[hush(s)] = 0; Q.push(s);\n\t\twhile (!Q.empty()) {\n\t\t\tvector<int>a1, a2, a3, t = Q.front(); Q.pop();\n\t\t\tint V = hush(t);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (t[i] == 0)a1.push_back(i);\n\t\t\t\tif (t[i] == 1)a2.push_back(i);\n\t\t\t\tif (t[i] == 2)a3.push_back(i);\n\t\t\t}\n\t\t\tint A1 = -1, A2 = -1, A3 = -1;\n\t\t\tif (a1.size() >= 1)A1 = a1[a1.size() - 1];\n\t\t\tif (a2.size() >= 1)A2 = a2[a2.size() - 1];\n\t\t\tif (a3.size() >= 1)A3 = a3[a3.size() - 1];\n\t\t\tif (A1 >= 0 && A2 <= A1) {\n\t\t\t\tt[A1] = 1; int P1 = hush(t);\n\t\t\t\tif (bfs[P1] == 1000000000) { bfs[P1] = bfs[V] + 1; Q.push(t); }\n\t\t\t\tt[A1] = 0;\n\t\t\t}\n\t\t\tif (A2 >= 0 && A1 <= A2) {\n\t\t\t\tt[A2] = 0; int P1 = hush(t);\n\t\t\t\tif (bfs[P1] == 1000000000) { bfs[P1] = bfs[V] + 1; Q.push(t); }\n\t\t\t\tt[A2] = 1;\n\t\t\t}\n\t\t\tif (A2 >= 0 && A3 <= A2) {\n\t\t\t\tt[A2] = 2; int P1 = hush(t);\n\t\t\t\tif (bfs[P1] == 1000000000) { bfs[P1] = bfs[V] + 1; Q.push(t); }\n\t\t\t\tt[A2] = 1;\n\t\t\t}\n\t\t\tif (A3 >= 0 && A2 <= A3) {\n\t\t\t\tt[A3] = 1; int P1 = hush(t);\n\t\t\t\tif (bfs[P1] == 1000000000) { bfs[P1] = bfs[V] + 1; Q.push(t); }\n\t\t\t\tt[A3] = 2;\n\t\t\t}\n\t\t}\n\t\tint L = min(bfs[0], bfs[power[n] - 1]);\n\t\tif (L > K)L = -1;\n\t\tcout << L << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nstruct State {\n  int A,B,C;\n  State(int a,int b,int c):A(a),B(b),C(c){}\n};\n\ntypedef pair<State,int> ps;\n\nconst int INF = 1 << 28;\nint n,m,ans;\n\nvoid rec(int A, int B, int C, int k) {\n  if (k == m) return;\n  if (A == (1<<n)-1 || C == (1<<n)-1) { ans = min(ans,k); return; }\n  int ta = -1, tb = -1, tc = -1;\n  rep (i,n) {\n    if (A >> i & 1) ta = i;\n    if (B >> i & 1) tb = i;\n    if (C >> i & 1) tc = i;\n  }\n  if (A != 0 && ta > tb) rec(A & ~(1<<ta), B | (1<<ta), C, k+1);\n  if (B != 0) {\n    if (tb > ta) rec(A | (1<<tb), B & ~(1<<tb), C, k+1);\n    if (tb > tc) rec(A, B & ~(1<<tb), C | (1<<tb), k+1);\n  }\n  if (C != 0 && tc > tb) rec(A, B | (1<<tc), C & ~(1<<tc), k+1);\n}\n\nvoid solve() {\n  vector<int> v(3,0);\n  int cnt,tmp;\n  rep (i,3) {\n    cin>>cnt;\n    rep (j,cnt) {\n      cin>>tmp;\n      --tmp;\n      v[i] |= (1<<tmp);\n    }\n  }\n  ans = INF;\n  rec(v[0],v[1],v[2],0);\n  if (ans == INF) ans = -1;\n  printf(\"%d\\n\", ans);\n}\n\nint main() {\n  while (cin>>n>>m,n) {\n    solve();\n  }\n  return 0;\n}\n\n// void solve() {\n//   vector<int> v(3,0);\n//   int cnt,tmp;\n//   rep (i,3) {\n//     cin>>cnt;\n//     rep (j,cnt) {\n//       cin>>tmp;\n//       --tmp;\n//       v[i] |= (1<<tmp);\n//     }\n//     //cout << v[i] << endl;\n//   }\n  \n//   queue<ps> q;\n//   q.push(ps(State(v[0],v[1],v[2]), 0));\n//   while (!q.empty()) {\n//     ps p = q.front(); q.pop();\n//     State s = p.first;\n//     int k = p.second, ta = -1, tb = -1, tc = -1;\n//     if (s.A == (1<<n)-1 || s.C == (1<<n)-1) {\n//       //printf(\"%d:%d:%d \", s.A, s.B, s.C);\n//       printf(\"%d\\n\", k); return;\n//     }\n//     if (k == m) continue;\n//     rep (i,n) {\n//       if (s.A >> i & 1) ta = i;\n//       if (s.B >> i & 1) tb = i;\n//       if (s.C >> i & 1) tc = i;\n//     }\n//     if (s.A != 0 && ta > tb) q.push(ps(State(s.A & ~(1<<ta), s.B | (1<<ta), s.C), k+1));\n//     if (s.B != 0) {\n//       if (tb > ta) q.push(ps(State(s.A | (1<<tb), s.B & ~(1<<tb), s.C), k+1));\n//       if (tb > tc) q.push(ps(State(s.A, s.B & ~(1<<tb), s.C | (1<<tb)), k+1));\n//     }\n//     if (s.C != 0 && tc > tb) q.push(ps(State(s.A, s.B | (1<<tc), s.C & ~(1<<tc)), k+1));\n//   }\n//   puts(\"-1\");\n// }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\n#define INF 100000000\nint n, m;\n\nint dfs(stack<int> A, stack<int> B, stack<int> C, int dir, int cost){\n\tint c;\n\tint ans = INF;\n\t\n\tif(cost > m) return ans;\n\tif(A.size() == n) return cost;\n\t\n\tif(dir != 1 && !B.empty() && (A.empty() || A.top() < B.top())){//do 4\n\t\tc = B.top(); A.push(c); B.pop();\n\t\tans = min(ans, dfs(A, B, C, 4, cost + 1));\n\t\tc = A.top(); B.push(c); A.pop();\n\t}\n\tif(dir != 2 && !C.empty() && (B.empty() || B.top() < C.top())){//do 3\n\t\tc = C.top(); B.push(c); C.pop();\n\t\tans = min(ans, dfs(A, B, C, 3, cost + 1));\n\t\tc = B.top(); C.push(c); B.pop();\n\t}\n\tif(dir != 3 && !B.empty() && (C.empty() || C.top() < B.top())){//do 2\n\t\tc = B.top(); C.push(c); B.pop();\n\t\tans = min(ans, dfs(A, B, C, 2, cost + 1));\n\t\tc = C.top(); B.push(c); C.pop();\n\t}\n\tif(dir != 4 && !A.empty() && (B.empty() || B.top() < A.top())){//do 1\n\t\tc = A.top(); B.push(c); A.pop();\n\t\tans = min(ans, dfs(A, B, C, 1, cost + 1));\n\t\tc = B.top(); A.push(c); B.pop();\n\t}\n\t\n\treturn ans;\n}\n\nint main(){\n\tint a, b;\n\tstack<int> A, B, C;\n\tint res;\n\t\n\twhile(true){\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\twhile(!A.empty()) A.pop();\n\t\twhile(!B.empty()) B.pop();\n\t\twhile(!C.empty()) C.pop();\n\t\t\n\t\tscanf(\"%d\", &a);\n\t\tfor(int i = 0; i < a; i++){\n\t\t\tscanf(\"%d\", &b);\n\t\t\tA.push(b);\n\t\t}\n\t\tscanf(\"%d\", &a);\n\t\tfor(int i = 0; i < a; i++){\n\t\t\tscanf(\"%d\", &b);\n\t\t\tB.push(b);\n\t\t}\n\t\tscanf(\"%d\", &a);\n\t\tfor(int i = 0; i < a; i++){\n\t\t\tscanf(\"%d\", &b);\n\t\t\tC.push(b);\n\t\t}\n\t\t\n\t\tres = dfs(A, B, C, 0, 0);\n\t\tprintf(\"%d\\n\", (res == INF)? -1 : res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nstruct State {\n  int A,B,C;\n  State(int a,int b,int c):A(a),B(b),C(c){}\n};\n\ntypedef pair<State,int> ps;\n\nconst int INF = 1 << 28;\nint n,m;\n\nvoid solve() {\n  vector<int> v(3,0);\n  int cnt,tmp;\n  rep (i,3) {\n    cin>>cnt;\n    rep (j,cnt) {\n      cin>>tmp;\n      --tmp;\n      v[i] |= (1<<tmp);\n    }\n    //cout << v[i] << endl;\n  }\n  \n  queue<ps> q;\n  q.push(ps(State(v[0],v[1],v[2]), 0));\n  while (!q.empty()) {\n    ps p = q.front(); q.pop();\n    State s = p.first;\n    int k = p.second, ta = -1, tb = -1, tc = -1;\n    if (s.A == (1<<n)-1 || s.C == (1<<n)-1) {\n      //printf(\"%d:%d:%d \", s.A, s.B, s.C);\n      printf(\"%d\\n\", k); return;\n    }\n    if (k == m) continue;\n    rep (i,n) {\n      if (s.A >> i & 1) ta = i;\n      if (s.B >> i & 1) tb = i;\n      if (s.C >> i & 1) tc = i;\n    }\n    if (s.A != 0 && ta > tb) q.push(ps(State(s.A & ~(1<<ta), s.B | (1<<ta), s.C), k+1));\n    if (s.B != 0) {\n      if (tb > ta) q.push(ps(State(s.A | (1<<tb), s.B & ~(1<<tb), s.C), k+1));\n      if (tb > tc) q.push(ps(State(s.A, s.B & ~(1<<tb), s.C | (1<<tb)), k+1));\n    }\n    if (s.C != 0 && tc > tb) q.push(ps(State(s.A, s.B | (1<<tc), s.C & ~(1<<tc)), k+1));\n  }\n  puts(\"-1\");\n}\n\nint main() {\n  while (cin>>n>>m,n) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<stack>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n    int dep;\n    stack<int> s[3];\n};\n\nint int_pow(int n,int m){\n    int ans = 1;\n    while(m--){\n        ans *= n;\n    }\n    return ans;\n}\n\nint main(){\n    int hoge,n;\n    while(cin>>hoge>>n,n || hoge){\n        static bool memo[20000000];\n        Data q_c,q_d,first;\n        int m,input,nt,cup,cntempty,state;\n\t\tbool flag;\n        int situ[2] = {-1,1};\n        queue<Data> q;\n        for(int i=0;i<3;i++){\n            cin>>m;\n            for(int j=0;j<m;j++){\n                cin>>input;\n                first.s[i].push(input);\n            }\n        }\n        first.dep = 0;\n        q.push(first);\n        flag = false;\n        while(!q.empty()){\n            q_c = q.front();\n            q.pop();\n            //for(int i=0;i<3;i++) printf(\"%d \",!q_c.s[i].empty());\n            //puts(\"\");\n            if(q_c.dep == n) break;\n            cntempty = 0;\n            for(int i=0;i<3;i++){\n                if(!q_c.s[i].empty()){\n                    if(i == 1){\n                        cntempty = 0;\n                        break;\n                    }\n                    cntempty++;\n                }\n            }\n            if(cntempty == 1){\n                printf(\"%d\\n\",q_c.dep);\n                flag = true;\n                break;\n            }\n            q_d = q_c;\n            state = 0;\n            for(int i=0;i<3;i++){\n                while(!q_d.s[i].empty()){\n                    cup = q_d.s[i].top();\n                    q_d.s[i].pop();\n                    state += i*int_pow(3,cup-1);\n                }\n            }\n            //printf(\"%d\\n\",state);\n            if(memo[state]) continue;\n            memo[state] = true;\n            for(int i=0;i<3;i++){\n                for(int j=0;j<2;j++){\n                    nt = i+situ[j];\n                    if(nt<0 || 3<=nt) continue;\n                    q_d = q_c;\n                    if(q_d.s[i].empty()) continue;\n                    cup = q_d.s[i].top();\n                    q_d.s[i].pop();\n                    if(!q_d.s[nt].empty() && cup < q_d.s[nt].top()) continue;\n                    q_d.s[nt].push(cup);\n                    q_d.dep++;\n                    q.push(q_d);\n                }\n            }\n        }\n        if(!flag) printf(\"-1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<string.h>\n#include<math.h>\n#include<stdlib.h>\n#include<vector>\n#include<queue>\n#include<map>\n#include<tuple>\n#include<bitset>\n#include<iomanip>\n#define rep(index,num) for(int index=0;index<num;index++)\n#define rep1(index,num) for(int index=1;index<=num;index++)\n#define scan(argument) cin>>argument\n#define prin(argument) cout<<argument<<endl\n#define kaigyo cout<<endl\n#define eps 1e-15\n#define mp(a1,a2) make_pair(a1,a2)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<pint> vpint;\ntypedef vector<pll> vpll;\nll INFl=1e+18+1;\nint INF=1e+9+1;\nint pow3[16];\nvoid init(){\n\tpow3[0]=1;\n\trep(i,15){\n\t\tpow3[i+1]=pow3[i]*3;\n\t}\n}\nstruct Cup{\n\tvint A,B,C;\n\tbool operator==(const Cup& r) const{\n\t\treturn A==r.A&&B==r.B&&C==r.C;\n\t}\n};\nint para(Cup c){\n\tint ans=0;\n\trep(i,c.B.size()){\n\t\tans+=pow3[c.B[i]];\n\t}\n\trep(i,c.C.size()){\n\t\tans+=pow3[c.C[i]]*2;\n\t}\n\treturn ans;\n}\nint main(){\n\tinit();\n\twhile(1){\n\t\tint N,M;\n\t\tscan(N);scan(M);\n\t\tif(N==0&&M==0) break;\n\t\tCup ini;\n\t\tmap<int,int> tesu;\n\t\tint an,bn,cn;\n\t\tscan(an);\n\t\trep(i,an){\n\t\t\tint a; scan(a); ini.A.push_back(a);\n\t\t}\n\t\tscan(bn);\n\t\trep(i,bn){\n\t\t\tint a; scan(a); ini.B.push_back(a);\n\t\t}\n\t\tscan(cn);\n\t\trep(i,cn){\n\t\t\tint a; scan(a); ini.C.push_back(a);\n\t\t}\n\t\tCup goal1,goal2;\n\t\trep1(i,N){\n\t\t\tgoal1.A.push_back(i);\n\t\t}\n\t\trep1(i,N){\n\t\t\tgoal2.C.push_back(i);\n\t\t}\n\t\tif(ini==goal1||ini==goal2){\n\t\t\tprin(0);\n\t\t\tcontinue;\n\t\t}\n\t\tint g1para=para(goal1),g2para=para(goal2);\n\t\tvector<Cup> record;\n\t\trecord.push_back(ini);\n\t\ttesu[para(ini)]=-INF;\n\t\tfor(int count=1;count<=M;count++){\n\t\t\tif(record.empty()||tesu[g1para]>0||tesu[g2para]>0) break;\n\t\t\tvector<Cup> before=record;\n\t\t\trecord.clear();\n\t\t\trep(i,before.size()){\n\t\t\t\trep(k,4){\n\t\t\t\t\tCup now=before[i];\n\t\t\t\t\tif(k==0){\n\t\t\t\t\t\tif(now.A.empty()) continue;\n\t\t\t\t\t\tif(now.B.empty()||now.A.back()>now.B.back()){\n\t\t\t\t\t\t\tint move=now.A.back();\n\t\t\t\t\t\t\tnow.A.pop_back();\n\t\t\t\t\t\t\tnow.B.push_back(move);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(k==1){\n\t\t\t\t\t\tif(now.C.empty()) continue;\n\t\t\t\t\t\tif(now.B.empty()||now.C.back()>now.B.back()){\n\t\t\t\t\t\t\tint move=now.C.back();\n\t\t\t\t\t\t\tnow.C.pop_back();\n\t\t\t\t\t\t\tnow.B.push_back(move);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(k==2){\n\t\t\t\t\t\tif(now.B.empty()) continue;\n\t\t\t\t\t\tif(now.A.empty()||now.B.back()>now.A.back()){\n\t\t\t\t\t\t\tint move=now.B.back();\n\t\t\t\t\t\t\tnow.B.pop_back();\n\t\t\t\t\t\t\tnow.A.push_back(move);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(now.B.empty()) continue;\n\t\t\t\t\t\tif(now.C.empty()||now.B.back()>now.C.back()){\n\t\t\t\t\t\t\tint move=now.B.back();\n\t\t\t\t\t\t\tnow.B.pop_back();\n\t\t\t\t\t\t\tnow.C.push_back(move);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nowpara=para(now);\n\t\t\t\t\tif(tesu[nowpara]==0){\n\t\t\t\t\t\ttesu[nowpara]=count;\n\t\t\t\t\t\trecord.push_back(now);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(tesu[g1para]==0&&tesu[g2para]==0) prin(-1);\n\t\telse if(tesu[g1para]==0) prin(tesu[g2para]);\n\t\telse if(tesu[g2para]==0) prin(tesu[g1para]);\n\t\telse prin(min(tesu[g1para],tesu[g2para]));\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<utility>\n#include<vector>\nusing namespace std;\nint n, m, na, nb, nc, tyo, place[16],ans;\nint cup[3][16];\nint c1();\nint c2();\nint main() {\n\tint ans1, ans2;\n\n\twhile (1) {\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tfor (int j = 0; j < 16; ++j)\n\t\t\t\tcup[i][j] = 0;\n\t\t}\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\t\tcin >> na;\n\t\tfor (int i = 0; i < na; ++i) cin >> cup[0][i];\n\t\tcin >> nb;\n\t\tfor (int i = 0; i < nb; ++i)cin >> cup[1][i];\n\t\tcin >> nc;\n\t\tfor (int i = 0; i < nc; ++i)cin >> cup[2][i];\n\t\t/*\n\t\tif (cup[0][0] == 1)place[0] = 0;\n\t\telse if (cup[2][0] == 1)place[0] = 2;\n\t\telse if (cup[0][0] == 0)place[0] = 0;\n\t\telse if (cup[2][0] == 0)place[0] = 2;\n\t\telse if (cup[0][0] > cup[2][0])place[0] = 0;\n\t\telse place[0] = 2;\n\t\t*/\n\t\tfor (int p = 0; p < 2; ++p) {\n\t\t\ttyo = 0;\n\t\t\tif (p == 0)place[0] = 0;\n\t\t\telse place[0] = 2;\n\t\t\tint np;\n\t\t\tif (place[0] == 0)np = 2;\n\t\t\telse np = 0;\n\t\t\tfor (int k = 1; k < 16; ++k) {\n\t\t\t\tplace[k] = place[0];\n\t\t\t}\n\t\t\tbool bo = false; int at, ar;\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\tfor (int j = 0; j < na; ++j) {\n\t\t\t\t\tif (cup[0][j] == i) {\n\t\t\t\t\t\tat = 0;\n\t\t\t\t\t\tar = j;\n\t\t\t\t\t\tbo = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < nb; ++j) {\n\t\t\t\t\tif (bo)break;\n\t\t\t\t\tif (cup[1][j] == i) {\n\t\t\t\t\t\tat = 1;\n\t\t\t\t\t\tar = j;\n\t\t\t\t\t\tbo = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < nc; ++j) {\n\t\t\t\t\tif (bo)break;\n\t\t\t\t\tif (cup[2][j] == i) {\n\t\t\t\t\t\tat = 2;\n\t\t\t\t\t\tar = j;\n\t\t\t\t\t\tbo = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbo = false;\n\t\t\t\tif (at == place[i]) {\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (at == 1) {\n\t\t\t\t\t\ttyo += pow(3, n - i);\n\t\t\t\t\t\tfor (int k = i + 1; k < 16; ++k) {\n\t\t\t\t\t\t\tif (place[k] == 0)place[k] = 2;\n\t\t\t\t\t\t\telse place[k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttyo += 2 * (pow(3, n - i));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (p == 0)ans1 = tyo;\n\t\t\telse ans2 = tyo;\n\t\t}\n\t\tif (m < tyo)cout << -1 << endl;\n\t\t\telse cout << min(ans1,ans2) << endl;\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include <stack>\nusing namespace std;\n \nint main()\n{\n    stack<int>a,b,c;\n    while(1)\n    {\n         \n        int count=0,n,m,check;\n        scanf(\"%d %d\",&n,&m);\n \n        if(n==0 && m==0)\n        {\n            break;\n        }\n     \n        int A,B,C,\n            kari;\n         \n        a.push(0);\n        b.push(0);\n        c.push(0);\n \n        scanf(\"%d\",&A);\n        for(int i=0;i<A;i++){\n            scanf(\"%d\",&kari);\n            a.push(kari);\n        }\n \n        scanf(\"%d\",&B);\n        for(int i=0;i<B;i++){\n            scanf(\"%d\",&kari);\n            b.push(kari);\n        }\n     \n        scanf(\"%d\",&C);\n        for(int i=0;i<C;i++){\n            scanf(\"%d\",&kari);\n            c.push(kari);\n        }\n         \n        while(1)\n        {\n            if(b.top()==0 && c.top()==0)\n                break;\n            if(a.top()<b.top() && a.top()<c.top()){\n                kari=b.top();\n                a.push(kari);\n                b.pop();\n                count++;\n                continue;\n            }\n            if(b.top()<c.top() ){\n                kari=c.top();\n                b.push(kari);\n                c.pop();\n                count++;\n                continue;\n            }\n            if(b.top()<a.top()){\n                kari=a.top();\n                b.push(kari);\n                a.pop();\n                count++;\n                continue;\n            }\n            if(c.top()<b.top() && a.top()!=b.top()-1){\n                kari=b.top();\n                c.push(kari);\n                b.pop();\n                count++;\n                continue;\n        }\n            else{\n                kari=b.top();\n                a.push(kari);\n                b.pop();\n                count++;\n                continue;\n            }\n        }\n        if(count<m || count==m){\n\t\t\tprintf(\"%d\\n\",count);\n\t\t\tcontinue;\n\t\t}\n        else {\n\t\t\tprintf(\"%d\\n\",-1);\n\t\t\tcontinue;\n\t\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\nint dp[14400000];\nint N, M;\nint to_hash(const vector<int>&nums) {\n\tint hash = 0;\n\tfor (auto n : nums) {\n\t\thash = 3 * hash + n;\n\t}\n\treturn hash;\n}\nint getans(vector<int>&starts) {\n\tqueue<pair<vector<int>, int>>que;\n\tque.emplace(starts, 0);\n\twhile (!que.empty()) {\n\t\tauto v = que.front();\n\t\tque.pop();\n\t\tvector<int>nums = v.first;\n\t\tint now = v.second;\n\t\tconst int hash = to_hash(nums);\n\t\tif (dp[hash] == false) {\n\t\t\tcontinue;\n\t\t}else {\n\t\t\tdp[hash] = false;\n\t\t\tif (now >= M+1) {\n\t\t\t\treturn M + 1;\n\t\t\t}\n\t\t\tif (to_hash(nums) == 0||hash+1==powint(3,N)) {\n\t\t\t\treturn now;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[hash] = false;\n\t\t\t\tvector<int>tops(3, -1);\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\ttops[nums[i]] = i;\n\t\t\t\t}\n\t\t\t\tint ans = M;\n\t\t\t\tif (tops[0] < tops[1]) {\n\t\t\t\t\tnums[tops[1]] = 0;\n\t\t\t\t\tque.emplace(nums, now + 1);\n\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnums[tops[0]] = 1;\n\t\t\t\t\tque.emplace(nums, now + 1);\n\t\t\t\t\tnums[tops[0]] = 0;\n\t\t\t\t}\n\t\t\t\tif (tops[1] < tops[2]) {\n\t\t\t\t\tnums[tops[2]] = 1;\n\t\t\t\t\tque.emplace(nums, now + 1);\n\t\t\t\t\tnums[tops[2]] = 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnums[tops[1]] = 2;\n\t\t\t\t\tque.emplace(nums, now + 1);\n\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn M+1;\n\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 14400000; ++i) {\n\t\t\tdp[i] = true;\n\t\t} cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<int>nows(N);\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tfor (int j = 0; j < a; ++j) {\n\t\t\t\tint b; cin >> b; b--;\n\t\t\t\tnows[b] = i;\n\t\t\t}\n\t\t}\n\t\tint ans = getans(nows);\n\t\tif (ans == M+1)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint an, bn, cn, a[20], b[20], c[20], total = 0, f = 1;\n\nstruct mm{\n\tchar ch;\n\tint nu;\n};\n\nstruct mm m1, m2;\n\nint judge(int max, int temp, int l, int r){\n\tif(a[an - l] == max - temp)return 50 + temp;\n\tif(c[cn - r] == max - temp)return 100 + temp;\n\tif(temp + 1 == an + bn + cn)return -1;\n\tif(b[bn - temp + l + r] == max - temp)return judge(max, temp + 1, l, r);\n\treturn 0;\n}\n\nint calculation(int min, int max){\n\tint sum;\n\tif(min == max)return 0;\n\tif(min < max)sum = calculation(++min, max) * 3 + 2;\n\treturn sum;\n}\n\nint move(int flag){\n\tint number;\n\tif(flag == 2){  //right\n\t\tnumber = an - m1.nu + 1;\n\t\tfor(int i = 1;i <= number;i++)c[++cn] = a[an--];\n\t}\n\tif(flag == 1){\n\t\tnumber = cn - m1.nu + 1;\n\t\tfor(int i = 1;i <= number;i++)a[++an] = c[cn--];\n\t}\n\t//printf(\"*%d %d %d*\", an, m1.nu, number);\n\ttotal += calculation(0, number);\n\t//printf(\"*%d*\", number);\n\treturn 0;\n}\n\nint sort(int max){\n\tif(m1.ch == m2.ch)return 0;\n\tif(m2.ch == 'b'){\n\t\tif(m1.ch == 'a')c[++cn] = b[bn--], move(2);  //right\n\t\tif(m1.ch == 'c')a[++an] = b[bn--], move(1);\n\t\ttotal++;\n\t}else if(m2.ch == 'a'){\n\t\tif(c[cn - 1] == max - 2){\n\t\t\tint te = an;\n\t\t\tb[++bn] = a[an--], move(1);\n\t\t\tm1.ch = 'a', m1.nu = te;\n\t\t\tc[++cn] = b[bn--], move(2);\n\t\t}else{\n\t\t\tmove(1);\n\t\t}\n\t}else if(m2.ch == 'c'){\n\t\tif(a[an - 1] == max - 2){\n\t\t\tint te = cn;\n\t\t\tb[++bn] = c[cn--], move(2);\n\t\t\tm1.ch = 'c', m1.nu = te;\n\t\t\ta[++an] = b[bn--], move(1);\n\t\t}else{\n\t\t\tmove(2);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint solve(int max){\n\tfor(int i = 1;i <= an;i++){\n\t\tif(a[i] == max)m1.ch = 'a',m1.nu = i;\n\t\tif(a[i] == max - 1)m2.ch = 'a', m2.nu = i;\n\t}\n\tfor(int i = 1;i <= bn;i++){\n\t\tif(b[i] == max)m1.ch = 'b',m1.nu = i;\n\t\tif(b[i] == max - 1)m2.ch = 'b', m2.nu = i;\n\t}\n\tfor(int i = 1;i <= cn;i++){\n\t\tif(c[i] == max)m1.ch = 'c',m1.nu = i;\n\t\tif(c[i] == max - 1)m2.ch = 'c', m2.nu = i;\n\t}\n\tif(f == 1 && m1.ch == 'b'){\n\t\tint vec = 0;  //1 = left \n\t\tif(m2.ch == 'b'){\n\t\t\tint temp = judge(max, 2, 0, 0);\n\t\t\t//printf(\"*%d*\\n\", temp);\n\t\t\tif(temp == -1)return 0;\n\t\t\tif(temp >= 100){\n\t\t\t\tif(temp % 2)vec = 2;\n\t\t\t\telse vec = 1;\n\t\t\t}else if(temp >= 50){\n\t\t\t\tif(temp % 2)vec = 1;\n\t\t\t\telse vec = 2;\n\t\t\t}\n\t\t}\n\t\tif(vec == 1){\n\t\t\ta[++an] = b[bn--];\n\t\t\tm1.nu = an, m1.ch = 'a';\n\t\t}else if(vec == 2){\n\t\t\tc[++cn] = b[bn--];\n\t\t\tm1.nu = cn, m1.ch = 'c';\n\t\t}\n\t\t\n\t\tif(m2.ch == 'a'){\n\t\t\tif(c[cn] == max - 2){\n\t\t\t\tc[++cn] = a[an--], c[++cn] = b[bn++];\n\t\t\t\ttotal += 7;\n\t\t\t}else if(b[bn - 1] == max - 2){\n\t\t\t\tint rl = -1;\n\t\t\t\tif(b[bn - 2] == max - 3){\n\t\t\t\t\tint re = judge(max, 4, 1, 0);\n\t\t\t\t\tif(re == -1)rl = 1;\n\t\t\t\t\tif(re >= 100){\n\t\t\t\t\t\tif(re % 2)rl = 2;\n\t\t\t\t\t\telse rl = 1;\n\t\t\t\t\t}else if(re >= 50){\n\t\t\t\t\t\tif(re % 2)rl = 1;\n\t\t\t\t\t\telse rl = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[an - 1] == max - 3 || rl == 1){\n\t\t\t\t\ta[++an] = a[an - 1];\n\t\t\t\t\ta[an - 1] = b[bn - 1];\n\t\t\t\t\ta[++an] = b[bn];\n\t\t\t\t\tbn -= 2;\n\t\t\t\t\ttotal += 16;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(c[cn] == max - 3 || rl == 2){\n\t\t\t\t\tc[++cn] = b[bn - 1];\n\t\t\t\t\tc[++cn] = a[an--];\n\t\t\t\t\tc[++cn] = b[bn];\n\t\t\t\t\tbn -= 2;\n\t\t\t\t\ttotal += 10;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}else if(a[an - 1] == max - 2){\n\t\t\t\ta[++an] = b[bn--];\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif(m2.ch == 'c'){\n\t\t\tif(a[an] == max - 2){\n\t\t\t\ta[++an] = c[cn--], a[++an] = b[bn++];\n\t\t\t\ttotal += 7;\n\t\t\t}else if(b[bn - 1] == max - 2){\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tint rl = -1;\n\t\t\t\tif(b[bn - 2] == max - 3){\n\t\t\t\t\tint re = judge(max, 4, 0, 1);\n\t\t\t\t\tif(re == -1)rl = 1;\n\t\t\t\t\tif(re >= 100){\n\t\t\t\t\t\tif(re % 2)rl = 2;\n\t\t\t\t\t\telse rl = 1;\n\t\t\t\t\t}else if(re >= 50){\n\t\t\t\t\t\tif(re % 2)rl = 1;\n\t\t\t\t\t\telse rl = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[an] == max - 3 || rl == 1){\n\t\t\t\t\ta[++an] = b[bn - 1];\n\t\t\t\t\ta[++an] = c[cn--];\n\t\t\t\t\ta[++an] = b[bn];\n\t\t\t\t\tbn -= 2;\n\t\t\t\t\ttotal += 10;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(c[cn - 1] == max - 3 || rl == 2){\n\t\t\t\t\tc[++cn] = c[cn - 1];\n\t\t\t\t\tc[cn - 1] = b[bn - 1];\n\t\t\t\t\tc[++cn] = b[bn];\n\t\t\t\t\tbn -= 2;\n\t\t\t\t\ttotal += 16;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}else if(c[cn - 1] == max - 2){\n\t\t\t\tc[++cn] = b[bn--];\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t//printf(\"*%d*\", total);\n\t\ttotal++;\n\t}\n\tsort(max);\n\t//printf(\"*%d*\", total);\n\t\n\treturn 0;\n}\n\nint main(){\n\tint n, m, max = 0;\n\ta[0] = b[0] = c[0] = 0;\n\twhile(scanf(\"%d %d\",&n, &m)){\n\t\tif(n == 0 && m == 0)break;\n\t\tmax = total = 0, f = 1;\n\t\t\n\t\t\n\t\tscanf(\"%d\", &an);\n\t\tfor(int i = 1;i <= an;i++){\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t\tif(a[i] > max)max = a[i];\n\t\t}\n\t\tscanf(\"%d\", &bn);\n\t\tfor(int i = 1;i <= bn;i++){\n\t\t\tscanf(\"%d\", &b[i]);\n\t\t\tif(b[i] > max)max = b[i];\n\t\t}\n\t\tscanf(\"%d\", &cn);\n\t\tfor(int i = 1;i <= cn;i++){\n\t\t\tscanf(\"%d\", &c[i]);\n\t\t\tif(c[i] > max)max = c[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < n - 1;i++)solve(max - i);\n\t\t\n\t\tprintf(\"%d\\n\", total);\n\t\t//if(total <= m)printf(\"%d\\n\", total);\n\t\t//else printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <math.h>\n#define step(n) pow(3,x-n+1)/2\nusing namespace std;\n\nint x,hanoi[16];\n\n\nint move(int s,int d,int c){\n\tif(abs(s-d)==2) return move(s,1,c)+move(1,d,c);\n\tif(c==x) return abs(s-d);\n\tif(s==d) return move(hanoi[c+1], s, c+1);\n\tfor(int i=c+1;i<=x;i++)if(hanoi[i]==s || hanoi[i]==d)return step(c) + move(hanoi[c+1], d, c+1);\n\treturn 1 + move(hanoi[c+1], d, c+1);\n}\n\nint main(){\n\tint i,n,m,t,r1,r2;\n\twhile(cin>>x>>n,n){\n\t\tfor(i=0;i<3;i++)for(cin>>m;m--;hanoi[t]=i)cin>>t;\n\t\tr1=move(hanoi[1],0,1);\n\t\tr2=move(hanoi[1],2,1);\n\t\tif(n<r1&&n<r2) r1=-1;\n\t\tcout << min(r1,r2) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint n, m;\nint ans;\n\ninline int msb(int x) {\n\tif(!x) return 0;\n\treturn (1 << (31 - __builtin_clz(x)));\n}\n\n\nvoid dfs(vector<int> state, vector<int> prev, int cnt = 0) {\n\tif(cnt > min(m, ans))\n\t\treturn;\n\n\tif(state[0] == (1 << n) - 1 || state[2] == (1 << n) - 1) {\n\t\tans = cnt;\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < 2; ++i) {\n\t\tint move = max(msb(state[i]), msb(state[i + 1]));\n\t\tvector<int> next = state;\n\t\tnext[i] ^= move;\n\t\tnext[i + 1] ^= move;\n\t\tif(next != state)\n\t\t\tdfs(next, state, cnt + 1);\n\t}\t\n\t\n}\n\nint main() {\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\n\tconst vector<int> init(3, -1);\n\n\tfor(; cin >> n >> m, n | m;) {\n\t\tvector<int> cup(3, 0);\n\n\t\tfor(int i = 0; i < 3; ++i) {\n\t\t\tint num;\n\t\t\tcin >> num;\n\n\t\t\tfor(int j = 0; j < num; ++j) {\n\t\t\t\tint size;\n\t\t\t\tcin >> size;\n\t\t\t\t--size;\n\n\t\t\t\tcup[i] |= (1 << size);\n\t\t\t}\n\t\t}\n\n\t\tans = INT_MAX;\n\t\tdfs(cup, init);\n\n\t\tcout << (ans == INT_MAX ? -1 : ans) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nint n,m;\n\nint times(int A, int B, int C, int target)\n{\n    //printf(\"%d:%d:%d\\n\", A, B, C);\n    if( B & 1 )\n        return std::min(times(A>>1,B>>1,C>>1,-1), times(A>>1,B>>1,C>>1,1)) + 1 + times(((A|B|C)>>1) , 0, 0, 1);\n    if( A & 1 )\n        if( target == -1 )\n            return times(A>>1, B>>1, C>>1, -1);\n        else\n            return times(A>>1, B>>1, C>>1, 1) + 1 + times(0, 0, ((A|B|C)>>1) , -1) + 1 + times(((A|B|C)>>1) , 0, 0, 1);\n    if( C & 1 )\n        if( target == 1 )\n            return times(A>>1, B>>1, C>>1, 1);\n        else\n            return times(A>>1, B>>1, C>>1, -1) + 1 + times(((A|B|C)>>1), 0, 0, 1) + 1 + times(0, 0, ((A|B|C)>>1), -1);\n    return 0;\n}\n\n\n\nint main(void)\n{\n    while(true)\n    {\n        int cups[3] = {0,0,0};\n\n        scanf(\"%d%d\",&n,&m);\n        if(!n && !m) break;\n\n        for(int i=0; i < 3; i++)\n        {\n            int c;\n            scanf(\"%d\", &c);\n            for(int j=0; j < c; j++)\n            {\n                int t;\n                scanf(\"%d\", &t);\n                cups[i] |= 1<<(t-1);\n            }\n        }\n\n        int res = std::min(times(cups[0], cups[1], cups[2], -1), times(cups[0], cups[1], cups[2],  1));\n        printf(\"%d\\n\", res <= m ? res : -1);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nint dp[7000000];\nint N, M;\nint to_hash(const vector<int>&nums) {\n\tint hash = 0;\n\tfor (auto n : nums) {\n\t\thash = 3 * hash + n;\n\t}\n\treturn hash;\n}\nint getans(vector<int>&nums, int now) {\n\tint hash = to_hash(nums);\n\tif (dp[hash] == -2) {\n\t\treturn M;\n\t}\n\tif (dp[hash] == -1) {\n\t\tif (now >= M)return M;\n\t\tif (to_hash(nums) == 0) {\n\t\t\treturn now;\n\t\t}\n\t\telse {\n\t\t\tdp[hash] = -2;\n\t\t\tvector<int>tops(3, -1);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\ttops[nums[i]] = i;\n\t\t\t}\n\t\t\tint ans = M;\n\t\t\tif (tops[0] < tops[1]) {\n\t\t\t\tif (tops[1] != -1) {\n\t\t\t\t\tnums[tops[1]] = 0;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tops[0] != -1) {\n\t\t\t\t\tnums[tops[0]] = 1;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[0]] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tops[1] < tops[2]) {\n\t\t\t\tif (tops[2] != -1) {\n\t\t\t\t\tnums[tops[2]] = 1;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[2]] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tops[1] != -1) {\n\t\t\t\t\tnums[tops[1]] = 2;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[hash] = ans;\n\t\t}\n\t}\n\telse {\n\t\treturn dp[hash];\n\t}\n\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 7000000; ++i) {\n\t\t\tdp[i] = -1;\n\t\t} cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<int>nows(N);\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tfor (int j = 0; j < a; ++j) {\n\t\t\t\tint b; cin >> b; b--;\n\t\t\t\tnows[b] = i;\n\t\t\t}\n\t\t}\n\t\tint ans = getans(nows, 0);\n\t\tif (ans == M)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint n,m,ans;\nvector< vector<int> > inv, v;\n\nvoid solve(int a,int b,int cost){\n\tif(cost >= ans) return;\n\tif(inv == v){\n\t\tans = min(ans,cost);\n\t\treturn;\n\t}\n\n\tfor(int i=0;i<2;i++){\n\t\tint popA = v[i].empty() ? -1 : v[i].back();\n\t\tint popB = v[i+1].empty() ? -1 : v[i+1].back();\n\n\t\tif(popA > popB && (i != b || i+1 != a)){\n\t\t\tv[i+1].push_back(v[i].back()); v[i].pop_back();\n\t\t\tsolve(i,i+1,cost+1);\n\t\t\tv[i].push_back(v[i+1].back()); v[i+1].pop_back();\n\t\t}\n\t\telse if(popB > popA && (i+1 != b || i != a)){\n\t\t\tv[i].push_back(v[i+1].back()); v[i+1].pop_back();\n\t\t\tsolve(i+1,i,cost+1);\n\t\t\tv[i+1].push_back(v[i].back()); v[i].pop_back();\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(cin>>n>>m && (n||m)){\n\t\tinv.clear();\n\t\tv.clear();\n\n\t\tfor(int i=0;i<3;i++){\n\t\t\tvector<int> tmp;\n\t\t\tv.push_back(tmp);\n\n\t\t\tint r;\n\t\t\tcin>>r;\n\t\t\twhile(r--){\n\t\t\t\tint x;\n\t\t\t\tcin>>x;\n\t\t\t\ttmp.push_back(x);\n\t\t\t}\n\t\t\tinv.push_back(tmp);\n\t\t}\n\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tv[0].push_back(i);\n\t\t}\n\n\t\tans = pow(3,n);\n\t\tsolve(0,0,0);\n\t\tans = ans == (int)pow(3,n) ? -1 : min(ans, (int)pow(3,n) - 1 - ans);\n\t\tans = ans > m ? -1 : ans;\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define PB push_back\nusing namespace std;\nstruct Cup{\n    vector<vector<int> >A;\n    int cnt,b;\n    Cup(vector<vector<int> >A_,int cnt_,int b_){\n        A=A_;cnt=cnt_;b=b_;\n    }\n    Cup(){}\n};\nint main(){\n    int n,m;\n    while(cin>>n>>m,n||m){\n        queue<Cup>Q;\n        int mn=m+5;\n        int cnttt=0;\n        vector<vector<int> >V(3);\n        V[0].PB(0);V[1].PB(0);V[2].PB(0);\n        for(int i=0;i<3;i++){\n            int s;\n            cin>>s;\n            for(int j=0;j<s;j++){\n                int d;\n                cin>>d;\n                V[i].PB(d);\n            }\n        }\n        if(V[0].back()<V[1].back()){\n            V[0].PB(V[1].back());\n            V[1].pop_back();\n            Q.push(Cup(V,1,1));\n            V[1].PB(V[0].back());\n            V[0].pop_back();\n        }\n        else if(V[0].back()!=0){\n            V[1].PB(V[0].back());\n            V[0].pop_back();\n            Q.push(Cup(V,1,0));\n            V[0].PB(V[1].back());\n            V[1].pop_back();\n        }\n\n\n        if(V[2].back()<V[1].back()){\n            V[2].PB(V[1].back());\n            V[1].pop_back();\n            Q.push(Cup(V,1,3));\n            V[1].PB(V[2].back());\n            V[2].pop_back();\n        }\n        else if(V[2].back()!=0){\n            V[1].PB(V[2].back());\n            V[2].pop_back();\n            Q.push(Cup(V,1,2));\n            V[2].PB(V[1].back());\n            V[1].pop_back();\n        }\n        if(V[0].size()==n+1||V[2].size()==0){\n            cout<<0<<endl;\n            continue;\n        }\n\n        while(Q.size()){\n            Cup x=Q.front();Q.pop();\n            if(x.cnt>m)continue;\n\n\n\n            if(x.A[0].size()==n+1||x.A[2].size()==n+1){\n                mn=min(mn,x.cnt);\n                break;\n            }\n\n            if(x.b==2||x.b==3){\n                if(x.A[0].back()<x.A[1].back()){\n                    x.A[0].PB(x.A[1].back());\n                    x.A[1].pop_back();\n                    Q.push(Cup(x.A,x.cnt+1,1));\n                    x.A[1].PB(x.A[0].back());\n                    x.A[0].pop_back();\n                }\n                else if(x.A[0].back()!=0){\n                    x.A[1].PB(x.A[0].back());\n                    x.A[0].pop_back();\n                    Q.push(Cup(x.A,x.cnt+1,0));\n                    x.A[0].PB(x.A[1].back());\n                    x.A[1].pop_back();\n                }\n            }\n            else{\n                if(x.A[2].back()<x.A[1].back()){\n                    x.A[2].PB(x.A[1].back());\n                    x.A[1].pop_back();\n                    Q.push(Cup(x.A,x.cnt+1,3));\n                    x.A[1].PB(x.A[2].back());\n                    x.A[2].pop_back();\n                }\n                else if(x.A[2].back()!=0){\n                    x.A[1].PB(x.A[2].back());\n                    x.A[2].pop_back();\n                    Q.push(Cup(x.A,x.cnt+1,2));\n                    x.A[2].PB(x.A[1].back());\n                    x.A[1].pop_back();\n                }\n            }\n\n        }\n\n        if(mn==m+5)mn=-1;\n        cout<<mn<<endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<stack>\nusing namespace std;\nstruct QS{\n    stack< int > D[3];\n    int cnt;\n    int prev;\n    //A->B 1\n    //A<-B 2\n    //B->C 3\n    //B<-C 4\n};\nint m,n;\nqueue< QS > Q;\nint BFS(){\n    while(!Q.empty()){\n        if(Q.front().cnt>m)return -1;\n\n        if(Q.front().D[0].size()==n)return Q.front().cnt;\n        if(Q.front().D[2].size()==n)return Q.front().cnt;\n\n        //cout<<\"prev = \"<<Q.front().prev<<endl;\n\n        int x = Q.front().D[0].empty() ? 0 : Q.front().D[0].top();\n        int y = Q.front().D[1].empty() ? 0 : Q.front().D[1].top();\n        int z = Q.front().D[2].empty() ? 0 : Q.front().D[2].top();\n\n        QS sub = Q.front();\n        if(x > y&&sub.prev!=2){\n            sub.D[1].push(sub.D[0].top());\n            sub.D[0].pop();\n            sub.cnt++;\n            sub.prev = 1;\n            Q.push(sub);\n\n        }\n        sub = Q.front();\n        if(x < y&&sub.prev!=1){\n            sub.D[0].push(sub.D[1].top());\n            sub.D[1].pop();\n            sub.cnt++;\n            sub.prev = 2;\n            Q.push(sub);\n        }\n\n        sub = Q.front();\n        if(y > z&&sub.prev!=4){\n            sub.D[2].push(sub.D[1].top());\n            sub.D[1].pop();\n            sub.cnt++;\n            sub.prev = 3;\n            Q.push(sub);\n        }\n        sub = Q.front();\n        if(y < z&&sub.prev!=3){\n            sub.D[1].push(sub.D[2].top());\n            sub.D[2].pop();\n            sub.cnt++;\n            sub.prev = 4;\n            Q.push(sub);\n        }\n        Q.pop();\n    }\n    return -1;\n}\nint main(){\n\n\n    while(cin>>n>>m,n||m){\n        while(!Q.empty())Q.pop();\n        QS data;\n        for(int i = 0;i < 3;i++){\n            int x;\n            cin>>x;\n            for(int j = 0;j < x;j++){\n                int y;\n                cin>>y;\n                data.D[i].push(y);\n            }\n        }\n        data.cnt = 0;\n        data.prev = -1;\n        Q.push(data);\n        cout<<BFS()<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint visited[1500000];\n\nint pow(int x,int n){\n\tint res = 1;\n\twhile(n>0){\t\t\n\t\tres *= x;\n\t\tif(n & 1) x = x*x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\nint conv(vector<int>& sets){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<=15;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * pow(3,j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,vector<int>& root, int* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tmemset(visited,-1,sizeof(visited));\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,sets,visited));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long lli;\n\nconst lli INF = 100000000000LL;\n\nclass S{\npublic:\n  lli t[3], cost;\n  S(){}\n  S(lli a, lli b, lli c, lli cost) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n\nlli n, m, ans;\n\nlli calc(S s, lli pres, lli pret){\n  if(ans <= s.cost) return INF;\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  if(s.cost == m) return INF;\n  lli res = INF;\n  lli tmp[3];\n  fill(tmp, tmp+3, -1);\n  for(lli i=n-1;i>=0;i--){\n    for(lli j=0;j<3;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(lli i=0;i<3;i++){\n    for(lli j=0;j<3;j++){\n      if(abs(i-j) != 1) continue;\n      if(i == pret && j == pres) continue;\n      if(tmp[i] > tmp[j]){\n        S t = s;\n        t.t[i] &= ~(1 << tmp[i]);\n        t.t[j] |= 1 << tmp[i];\n        t.cost++;\n        res = min(res, calc(t, i, j));\n        ans = min(ans, res);\n      }\n    }\n  }\n  return res;\n}\n\nlli solve(S s){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  lli res = INF;\n  lli tmp[3];\n  fill(tmp, tmp+3, -1);\n  for(lli i=n-1;i>=0;i--){\n    for(lli j=0;j<3;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(lli i=0;i<3;i++){\n    if(tmp[i] != -1){\n      for(lli j=0;j<3;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          ans = min(ans, res);\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    lli data[3];\n    for(lli i=0;i<3;i++){\n      lli size;\n      cin >> size;\n      data[i] = 0;\n      for(lli j=0;j<size;j++){\n        lli in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    ans = INF;\n    cout << solve(S(data[0], data[1], data[2], 0)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n//http://climpet.hatenablog.com/entry/2013/01/01/225142#f5を参考\nint main(int argc, char *argv[])\n{\n  int pow3[16],c[16];\n  int n,m,i,j,k,d,x,y,p;\n\n  pow3[0] = 1;\n  for(int i = 1;i <=15;i++){\n    pow3[i] = pow3[i-1]*3;//i枚#0から#2または#2から#0へ移動するのに必要なステップ数\n}\n\n  while(scanf(\"%d%d\",&n,&m),n){\n    for(i = 0;i < 3;i++){\n      for(scanf(\"%d\",&j);j > 0;--j){\n\tscanf(\"%d\",&k);\n\tc[n-k] = i;/*番号付け替え,ハノイの塔に変換。大きいコップを小さい円盤にする*/\n      }\n    }\n    p = 0;//全ての円盤が0の位置にあると仮定する\n    x = 0;\n    for(i = n-1;i > 0;i--){//\n      d = abs(p -c[i]);//移動させる円盤の距離を求める。\n      /*n = 3の時、i = 2で円盤2を#1に移動させるには円盤1と円盤0を#2に移動させる*/\n      x += pow3[i]*d;\n      if(d == 1){\n\tp = 2-p;/*反対側に移動,距離がd = 1ならば0~i-1番の円盤を反対側に移動する。*/\n      }\n    }\n    y = pow3[n] -1 -x;\n    if(x > y){\n      x = y;\n    }\n    printf(\"%d\\n\",x > m?-1:x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 3;\nconst int INF = 15000001;\n\nclass S{\npublic:\n  int a, b, c, cost;\n  S(int a = 0, int b = 0, int c = 0, int cost = 0) : a(a), b(b), c(c), cost(cost){}\n};\n\nint n, m;\nint ans;\n\nint calc(S s, int pres, int pret){\n  if(ans <= s.cost) return INF;\n  if(s.a == (1 << n) - 1 || s.c == (1 << n) - 1) return s.cost;\n  if(s.cost >= m) return INF;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, 0);\n  for(int i=n-1;i>=0;i--){\n    if(s.a & 1 << i){\n      tmp[0] = i+1;\n      break;\n    }\n  }\n  for(int i=n-1;i>=0;i--){\n    if(s.b & 1 << i){\n      tmp[1] = i+1;\n      break;\n    }\n  }\n  for(int i=n-1;i>=0;i--){\n    if(s.c & 1 << i){\n      tmp[2] = i+1;\n      break;\n    }\n  }\n  if(tmp[0]){\n    for(int j=0;j<N;j++){\n      if(abs(0-j) != 1) continue;\n      if(0 == pret && j == pres) continue;\n      if(tmp[0] > tmp[j]){\n        S t = s;\n        t.a &= (~(1 << (tmp[0]-1)));\n        if(j == 0) t.a |= (1 << (tmp[0]-1));\n        if(j == 1) t.b |= (1 << (tmp[0]-1));\n        if(j == 2) t.c |= (1 << (tmp[0]-1));\n        t.cost++;\n        res = min(res, calc(t, 0, j));\n        ans = min(ans, res);\n      }\n    }\n  }  \n  if(tmp[1]){\n    for(int j=0;j<N;j++){\n      if(abs(1-j) != 1) continue;\n      if(1 == pret && j == pres) continue;\n      if(tmp[1] > tmp[j]){\n        S t = s;\n        t.b &= (~(1 << (tmp[1]-1)));\n        if(j == 0) t.a |= (1 << (tmp[1]-1));\n        if(j == 1) t.b |= (1 << (tmp[1]-1));\n        if(j == 2) t.c |= (1 << (tmp[1]-1));\n        t.cost++;\n        res = min(res, calc(t, 1, j));\n        ans = min(ans, res);\n      }\n    }\n  }\n  if(tmp[2]){\n    for(int j=0;j<N;j++){\n      if(abs(2-j) != 1) continue;\n      if(2 == pret && j == pres) continue;\n      if(tmp[2] > tmp[j]){\n        S t = s;\n        t.c &= (~(1 << (tmp[2]-1)));\n        if(j == 0) t.a |= (1 << (tmp[2]-1));\n        if(j == 1) t.b |= (1 << (tmp[2]-1));\n        if(j == 2) t.c |= (1 << (tmp[2]-1));\n        t.cost++;\n        res = min(res, calc(t, 2, j));\n        ans = min(ans, res);\n      }\n    }\n  }\n  return res;\n}\n\n/*int solve(S s){\n  if(s.a == (1 << n) - 1 || s.c == (1 << n) - 1) return s.cost;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int j=0;j<N;j++){\n    for(int i=n-1;i>=0;i--){\n      if(s.t[j] & 1 << i){\n        tmp[j] = i+1;\n        break;\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i]){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= (~(1 << (tmp[i]-1)));\n          t.t[j] |= (1 << (tmp[i]-1));\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          //ans = min(ans, res);\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n*/\nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[N];\n    for(int i=0;i<N;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    ans = INF;\n    int res = calc(S(data[0], data[1], data[2], 0), -1, -1);\n    cout << (res == INF ? -1 : res) << endl;\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct State {\n  vector<int> S[3];\n  int step;\n  int parent_from;\n  int parent_to;\n\n  bool empty(size_t i) const { return S[i].size() == 0; }\n  void push(size_t i, int v) { S[i].push_back(v); }\n  void pop(size_t i) { S[i].pop_back(); }\n  int top(size_t i) const { return S[i].back(); }\n};\n\ninline bool IsMovable(int from, int to, const State& p) {\n  if (to < 0 || to >= 3) return false;\n  if (p.empty(from)) return false;\n  if (to == p.parent_from && from == p.parent_to) return false;\n  return p.empty(to) || p.top(from) >= p.top(to);\n}\n\ninline bool Done(int n, const State& p) {\n  return p.S[0].size() == n || p.S[2].size() == n;\n}\n\nint BFS(const State& start, int n) {\n  queue<State> q;\n  q.push(start);\n\n  int step = 0;\n  while (!q.empty()) {\n    const auto p = q.front();\n    q.pop();\n\n    if (Done(n, p)) {\n      step = p.step;\n      break;\n    }\n    for (int from = 0; from < 3; ++from) {\n      for (int d : {-1, 1}) {\n        const int to = from + d;\n        if (IsMovable(from, to, p)) {\n          State new_state = p;\n          new_state.step = p.step + 1;\n          new_state.parent_from = from;\n          new_state.parent_to = to;\n          new_state.push(to, p.top(from));\n          new_state.pop(from);\n          q.push(new_state);\n        }\n      }\n    }\n  }\n  return step;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  for (;;) {\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n\n    // State goal;\n    State start;\n    start.step = 0;\n    for (int i = 0; i < 3; ++i) {\n      int t;\n      cin >> t;\n      int k;\n      for (int j = 0; j < t; ++j) {\n        cin >> k;\n        start.S[i].push_back(k);\n      }\n    }\n    const auto step = BFS(start, n);\n    const auto ans = step <= m ? step : -1;\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<set>\n#include<algorithm>\n\n#define MAX 16\n#define A 0\n#define B 1\n#define C 2\n#define P_MAX 3\n#define M_MAX 16000000\n\nusing namespace std;\n\nstruct Cups{\n\tCups(){\n\t\tcost = 0;\n\t\tv[0].reserve(MAX);\n\t\tv[1].reserve(MAX);\n\t\tv[2].reserve(MAX);\n\t}\n\tvector<int> v[P_MAX];\n\tbool operator<(const Cups &t)const{\n\t\treturn cost < t.cost;\n\t}\n\tint cost;\n};\nostream &operator<<(ostream &os, const vector<int> &v){\n\tfor(unsigned int i = 0; i < v.size(); ++i){\n\t\tos << v[i] << ' ';\n\t}\n\treturn os;\n}\nostream & operator << (ostream &os, const Cups &t){\n\tos << \"A: \" << t.v[0] << \"\\t\\tB: \" << t.v[1] << \"\\t\\tC: \" << t.v[2] << \"\\t\\tCost :\" << t.cost;\n\treturn os;\n}\n\nint BFS(int n, int m, int greedy, Cups &st, int cost[][MAX]){\n\tint ret = M_MAX;\n\tqueue<Cups> q;\n\tq.push( st );\n\n\twhile( !q.empty() ){\n\t\tCups cups;\n\t\tcups = q.front();\n\n\t\tq.pop();\n\n\t\t/* I¹ð */\n\t\tif( cups.v[A].size() == n || cups.v[C].size() == n ){\n\t\t\tret = min(ret, cups.cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = A; i <= C; ++i){\n\t\t\tint mov_cnt = 1;\n\t\t\tint min_sz = -1;\n\n\t\t\tfor(int j = cups.v[i].size()-1; j >= 1; --j){\n\t\t\t\tif( cups.v[i][j] - cups.v[i][j-1] == 1 ){\n\t\t\t\t\t++mov_cnt;\n\t\t\t\t\tmin_sz = cups.v[i][j-1];\n\t\t\t\t}else{\n\t\t\t\t\tmin_sz = cups.v[i][j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( cups.v[i].size() == 1 )\n\t\t\t\tmin_sz = cups.v[i][0];\n\n\t\t\tif( min_sz == -1 )\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tfor(int w = 1; w <= mov_cnt; ++w){\n\t\t\t\tfor(int j = A; j <= C; ++j){\n\t\t\t\t\tint d = abs( i - j );\n\t\t\t\t\tif( d == 2 || d == 0 )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tCups t = cups;\n\t\t\t\t\tint end = t.v[j].size() - 1;\n\t\t\t\t\tif( end >= 0 && t.v[j][end] > min_sz )\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tt.v[j].insert( t.v[j].end(), t.v[i].end() - w, t.v[i].end() );\n\t\t\t\t\tt.v[i].erase( t.v[i].end() - w, t.v[i].end() );\n\t\t\t\t\tt.cost += cost[ 1 ][ w ];\n\n\t\t\t\t\tif( t.cost <= m && t.cost < ret && t.cost <= greedy ){\n\t\t\t\t\t\tq.push( t );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint Greedy( int n, const Cups &cups, int cost[][MAX] ){\n\tint ret = 0;\n\tint places[MAX];\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(unsigned int j = 0; j < cups.v[i].size(); ++j ){\n\t\t\tplaces[ cups.v[i][j] ] = i;\n\t\t}\n\t}\n\tfor(int i = n; i >= 2; --i){\n\t\tint d = abs(places[i] - places[i-1]); \n\t\tret += cost[ d ][ n - i + 1 ];\n\t}\n\tif( places[1] == B )\n\t\tret += cost[ 1 ][ n ];\n\n\treturn ret;\n}\nint main(){\n\tint cost[3][MAX] = {{0,},};\n\tcost[1][1] = 1;\n\tcost[2][1] = 2;\n\tfor(int i = 1; i < 3; ++i){\n\t\tfor(int j = 2; j < MAX; ++j){\n\t\t\tif( i == 1 ){\n\t\t\t\tcost[i][j] = 3 * cost[i][j - 1] + 1;\n\t\t\t}else{\n\t\t\t\tcost[i][j] = 2 * cost[1][j];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tint n,m;\n\t\tint greedy;\n\t\tint ans = 0;\n\t\tCups cups;\n\t\t\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif( n == 0 && m == 0 )\n\t\t\tbreak;\n\n\t\tfor(int i = 0; i < 3; ++i){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tfor(int j = 0; j < t; ++j){\n\t\t\t\tint tt;\n\t\t\t\tscanf(\"%d\", &tt);\n\t\t\t\tcups.v[i].push_back(tt);\n\t\t\t}\n\t\t}\n\t\tgreedy = Greedy( n, cups, cost );\n\t\tcout << greedy << endl;\n\t\tans = BFS(n, m, greedy, cups, cost);\n\t\t\n\t\tprintf(\"%d\\n\", ans <= m ? ans : -1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint an, bn, cn, a[20], b[20], c[20], total = 0, f = 1;\n\nstruct mm{\n\tchar ch;\n\tint nu;\n};\n\nstruct mm m1, m2;\n\nint judge(int max, int temp, int l, int r){\n\tif(a[an - l] == max - temp)return 50 + temp;\n\tif(c[cn - r] == max - temp)return 100 + temp;\n\tif(temp + 1 == an + bn + cn)return -1;\n\tif(b[bn - temp + l + r] == max - temp)return judge(max, temp + 1, l, r);\n\treturn 0;\n}\n\nint calculation(int min, int max){\n\tint sum;\n\tif(min == max)return 0;\n\tif(min < max)sum = calculation(++min, max) * 3 + 2;\n\treturn sum;\n}\n\nint move(int flag){\n\tint number;\n\tif(flag == 2){  //right\n\t\tnumber = an - m1.nu + 1;\n\t\tfor(int i = 1;i <= number;i++)c[++cn] = a[an--];\n\t}\n\tif(flag == 1){\n\t\tnumber = cn - m1.nu + 1;\n\t\tfor(int i = 1;i <= number;i++)a[++an] = c[cn--];\n\t}\n\t//printf(\"*%d %d %d*\", an, m1.nu, number);\n\ttotal += calculation(0, number);\n\t//printf(\"*%d*\", number);\n\treturn 0;\n}\n\nint sort(int max){\n\tif(m1.ch == m2.ch)return 0;\n\tif(m2.ch == 'b'){\n\t\tif(m1.ch == 'a'){\n\t\t\tif(a[m1.nu - 1] == max - 2){\n\t\t\t\tint te = cn + 1;\n\t\t\t\tmove(2), a[++an] = b[bn--];\n\t\t\t\tm1.ch = 'c', m1.nu = te, move(1);\n\t\t\t}else{\n\t\t\t\tc[++cn] = b[bn--], move(2);  //right\n\t\t\t}\n\t\t}\n\t\tif(m1.ch == 'c'){\n\t\t\tif(c[m1.nu - 1] == max - 2){\n\t\t\t\tint te = an + 1;\n\t\t\t\tmove(1), c[++cn] = b[bn--];\n\t\t\t\tm1.ch = 'a', m1.nu = te, move(2);\n\t\t\t}else{\n\t\t\t\ta[++an] = b[bn--], move(1);\n\t\t\t}\n\t\t}\n\t\ttotal++;\n\t}else if(m2.ch == 'a'){\n\t\tif(c[m1.nu - 1] == max - 2){\n\t\t\tint te = an;\n\t\t\tb[++bn] = a[an--], move(1);\n\t\t\tm1.ch = 'a', m1.nu = te;\n\t\t\tc[++cn] = b[bn--], move(2);\n\t\t\ttotal += 2;\n\t\t}else{\n\t\t\tmove(1);\n\t\t\tprintf(\"Fuck%d %d\\n\", m1.nu, m2.nu);\n\t\t\tfor(int i = 1;i <= an;i++)printf(\"%d \", a[i]);\n\t\t\tprintf(\"\\n\");\n\t\t\tfor(int i = 1;i <= bn;i++)printf(\"%d \", b[i]);\n\t\t\tprintf(\"\\n\");\n\t\t\tfor(int i = 1;i <= cn;i++)printf(\"%d \", c[i]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}else if(m2.ch == 'c'){\n\t\tif(a[m1.nu - 1] == max - 2){\n\t\t\tint te = cn;\n\t\t\tb[++bn] = c[cn--], move(2);\n\t\t\tm1.ch = 'c', m1.nu = te;\n\t\t\ta[++an] = b[bn--], move(1);\n\t\t\ttotal += 2;\n\t\t}else{\n\t\t\tmove(2);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint solve(int max){\n\tfor(int i = 1;i <= an;i++){\n\t\tif(a[i] == max)m1.ch = 'a',m1.nu = i;\n\t\tif(a[i] == max - 1)m2.ch = 'a', m2.nu = i;\n\t}\n\tfor(int i = 1;i <= bn;i++){\n\t\tif(b[i] == max)m1.ch = 'b',m1.nu = i;\n\t\tif(b[i] == max - 1)m2.ch = 'b', m2.nu = i;\n\t}\n\tfor(int i = 1;i <= cn;i++){\n\t\tif(c[i] == max)m1.ch = 'c',m1.nu = i;\n\t\tif(c[i] == max - 1)m2.ch = 'c', m2.nu = i;\n\t}\n\tif(f == 1 && m1.ch == 'b'){\n\t\tint vec = 0;  //1 = left \n\t\tif(m2.ch == 'b'){\n\t\t\tint temp = judge(max, 2, 0, 0);\n\t\t\t//printf(\"*%d*\\n\", temp);\n\t\t\tif(temp == -1)return 0;\n\t\t\tif(temp >= 100){\n\t\t\t\tif(temp % 2)vec = 2;\n\t\t\t\telse vec = 1;\n\t\t\t}else if(temp >= 50){\n\t\t\t\tif(temp % 2)vec = 1;\n\t\t\t\telse vec = 2;\n\t\t\t}\n\t\t}\n\t\tif(vec == 1){\n\t\t\ta[++an] = b[bn--];\n\t\t\tm1.nu = an, m1.ch = 'a';\n\t\t}else if(vec == 2){\n\t\t\tc[++cn] = b[bn--];\n\t\t\tm1.nu = cn, m1.ch = 'c';\n\t\t}\n\t\t\n\t\tif(m2.ch == 'a'){\n\t\t\tif(c[cn] == max - 2){\n\t\t\t\tc[++cn] = a[an--], c[++cn] = b[bn++];\n\t\t\t\ttotal += 7;\n\t\t\t}else if(b[bn - 1] == max - 2){\n\t\t\t\tint rl = -1;\n\t\t\t\tif(b[bn - 2] == max - 3){\n\t\t\t\t\tint re = judge(max, 4, 1, 0);\n\t\t\t\t\tif(re == -1)rl = 1;\n\t\t\t\t\tif(re >= 100){\n\t\t\t\t\t\tif(re % 2)rl = 2;\n\t\t\t\t\t\telse rl = 1;\n\t\t\t\t\t}else if(re >= 50){\n\t\t\t\t\t\tif(re % 2)rl = 1;\n\t\t\t\t\t\telse rl = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[an - 1] == max - 3 || rl == 1){\n\t\t\t\t\ta[++an] = a[an - 1];\n\t\t\t\t\ta[an - 1] = b[bn - 1];\n\t\t\t\t\ta[++an] = b[bn];\n\t\t\t\t\tbn -= 2;\n\t\t\t\t\ttotal += 16;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(c[cn] == max - 3 || rl == 2){\n\t\t\t\t\tc[++cn] = b[bn - 1];\n\t\t\t\t\tc[++cn] = a[an--];\n\t\t\t\t\tc[++cn] = b[bn];\n\t\t\t\t\tbn -= 2;\n\t\t\t\t\ttotal += 10;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}else if(a[an - 1] == max - 2){\n\t\t\t\ta[++an] = b[bn--];\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif(m2.ch == 'c'){\n\t\t\tif(a[an] == max - 2){\n\t\t\t\ta[++an] = c[cn--], a[++an] = b[bn++];\n\t\t\t\ttotal += 7;\n\t\t\t}else if(b[bn - 1] == max - 2){\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tint rl = -1;\n\t\t\t\tif(b[bn - 2] == max - 3){\n\t\t\t\t\tint re = judge(max, 4, 0, 1);\n\t\t\t\t\tif(re == -1)rl = 1;\n\t\t\t\t\tif(re >= 100){\n\t\t\t\t\t\tif(re % 2)rl = 2;\n\t\t\t\t\t\telse rl = 1;\n\t\t\t\t\t}else if(re >= 50){\n\t\t\t\t\t\tif(re % 2)rl = 1;\n\t\t\t\t\t\telse rl = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[an] == max - 3 || rl == 1){\n\t\t\t\t\ta[++an] = b[bn - 1];\n\t\t\t\t\ta[++an] = c[cn--];\n\t\t\t\t\ta[++an] = b[bn];\n\t\t\t\t\tbn -= 2;\n\t\t\t\t\ttotal += 10;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(c[cn - 1] == max - 3 || rl == 2){\n\t\t\t\t\tc[++cn] = c[cn - 1];\n\t\t\t\t\tc[cn - 1] = b[bn - 1];\n\t\t\t\t\tc[++cn] = b[bn];\n\t\t\t\t\tbn -= 2;\n\t\t\t\t\ttotal += 16;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}else if(c[cn - 1] == max - 2){\n\t\t\t\tc[++cn] = b[bn--];\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t//printf(\"*%d*\", total);\n\t\ttotal++;\n\t}\n\tsort(max);\n\t//printf(\"*%d*\", total);\n\t\n\treturn 0;\n}\n\nint main(){\n\tint n, m, max = 0;\n\ta[0] = b[0] = c[0] = 0;\n\twhile(scanf(\"%d %d\",&n, &m)){\n\t\tif(n == 0 && m == 0)break;\n\t\tmax = total = 0, f = 1;\n\t\t\n\t\t\n\t\tscanf(\"%d\", &an);\n\t\tfor(int i = 1;i <= an;i++){\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t\tif(a[i] > max)max = a[i];\n\t\t}\n\t\tscanf(\"%d\", &bn);\n\t\tfor(int i = 1;i <= bn;i++){\n\t\t\tscanf(\"%d\", &b[i]);\n\t\t\tif(b[i] > max)max = b[i];\n\t\t}\n\t\tscanf(\"%d\", &cn);\n\t\tfor(int i = 1;i <= cn;i++){\n\t\t\tscanf(\"%d\", &c[i]);\n\t\t\tif(c[i] > max)max = c[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < n - 1;i++){\n\t\t\tsolve(max - i);\n\t\t\tprintf(\"*%d*\\n\", total);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", total);\n\t\t//if(total <= m)printf(\"%d\\n\", total);\n\t\t//else printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\nset< vector< stack<int> > > *s;\n\nll saiki(int n,vector< stack<int> > cup){\n    ll ret = 1000000000000;\n    if(s->find(cup) != s->end()) return 1000000000;\n    else s->insert(cup);\n    if(cup[1].size() == 0 && (cup[0].size() == 0||cup[2].size() == 0)){\n\treturn n;\n    }\n    REP(i,2){\n\tif(cup[i].size() > 0 && (cup[i+1].size() == 0 || cup[i].top() > cup[i+1].top())){\n\t    cup[i+1].push(cup[i].top());\n\t    cup[i].pop();\n\t    ret = min(ret,(saiki(n+1,cup)));\n\t    cup[i].push(cup[i+1].top());\n\t    cup[i+1].pop();\n\t}\n\tif(cup[i+1].size() > 0 && (cup[i].size() == 0 || cup[i].top() < cup[i+1].top())){\n\t    cup[i].push(cup[i+1].top());\n\t    cup[i+1].pop();\n\t    ret = min(ret,saiki(n+1,cup));\n\t    cup[i+1].push(cup[i].top());\n\t    cup[i].pop();\n\t}\n    }\n    return ret;\n}\n\nint main(){\n    while(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n == 0 && m == 0 ) break;\n\tdelete s;\n        s = new set< vector< stack<int> > >();\n\tvector< stack<int> > cup(3);\n\tREP(i,3){\n\t    int t;\n\t    cin >> t;\n\t    REP(j,t){\n\t\tint temp;\n\t\tcin >> temp;\n\t\tcup[i].push(temp);\n\t    }\n\t}\n\tint ans = saiki(0,cup);\n\tif(ans > m) ans = -1;\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 3;\nconst int INF = 15000001;\n\nclass S{\npublic:\n  int t[N], cost;\n  S(int a = 0, int b = 0, int c = 0, int cost = 0) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n\nint n, m;\n//int ans;\n\nint calc(S s, int pres, int pret){\n  //if(ans <= s.cost) return INF;\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  if(s.cost >= m) return INF;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, 0);\n  for(int j=0;j<N;j++){\n    for(int i=n-1;i>=0;i--){\n      if(s.t[j] & 1 << i){\n        tmp[j] = i+1;\n        break;\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i]){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(i == pret && j == pres) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= (~(1 << (tmp[i]-1)));\n          t.t[j] |= (1 << (tmp[i]-1));\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          //ans = min(ans, res);\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint solve(S s){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int j=0;j<N;j++){\n    for(int i=n-1;i>=0;i--){\n      if(s.t[j] & 1 << i){\n        tmp[j] = i+1;\n        break;\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i]){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= (~(1 << (tmp[i]-1)));\n          t.t[j] |= (1 << (tmp[i]-1));\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          //ans = min(ans, res);\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[N];\n    for(int i=0;i<N;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    //ans = INF;\n    cout << solve(S(data[0], data[1], data[2], 0)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<string>\n#include<climits>\n#include<deque>\n\nusing namespace std;\n\nint m;\nstack<int,vector<int> >A,B,C;\n\nint func(int,string);\n\nint main(void){\nint n,ans,s,t;\n\nwhile(cin >> n >> m,n|m){\nwhile(!A.empty())A.pop();\nwhile(!B.empty())B.pop();\nwhile(!C.empty())C.pop();\n\ncin >> s;\nfor(int i=0;i<s;i++){\ncin >> t;\nA.push(t);\n}\ncin >> s;\nfor(int i=0;i<s;i++){\ncin >> t;\nB.push(t);\n}\ncin >> s;\nfor(int i=0;i<s;i++){\ncin >> t;\nC.push(t);\n}\nans=func(0,\"ZZZ\");\nif(ans==INT_MAX)cout << -1 << endl;\nelse cout << ans << endl;\n}\nreturn 0;\n}\n\nint func(int cnt,string p){\n\nif(cnt>m)return INT_MAX;\n\nif(B.empty()&&(C.empty()||A.empty()))\nreturn cnt;\n\nint res=INT_MAX;\n\nif(!A.empty() && A.top()>=B.top() && p!=\"BA\"){\nB.push(A.top());\nA.pop();\nres=min(res,func(cnt+1,\"AB\"));\nA.push(B.top());\nB.pop();\n}\n\nif(!B.empty()){\nif(B.top()>=C.top()&&p!=\"CB\"){\nC.push(B.top());\nB.pop();\nres=min(res,func(cnt+1,\"BC\"));\nB.push(C.top());\nC.pop();\n}\n\nif(B.top()>=A.top()&&p!=\"AB\"){\nA.push(B.top());\nB.pop();\nres=min(res,func(cnt+1,\"BA\"));\nB.push(A.top());\nA.pop();\n}\n}\n\nif(!C.empty() && C.top()>=B.top() && p!=\"BC\"){\nB.push(C.top());\nC.pop();\nres=min(res,func(cnt+1,\"CB\"));\nC.push(B.top());\nB.pop();\n}\n\nreturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <queue>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\nstruct State {\n  vector<int> S[3];\n  int step;\n\n  bool empty(size_t i) const { return S[i].size() == 0; }\n  void push(size_t i, int v) { S[i].push_back(v); }\n  void pop(size_t i) { S[i].pop_back(); }\n  int top(size_t i) const { return S[i].back(); }\n};\n\nstruct StateHash {\n  size_t operator()(const State& s) const {\n    size_t h = 0;\n    for (int i = 0; i < 3; ++i) {\n      for (size_t j = 0; j < s.S[i].size(); ++j) {\n        h += j * 10 * s.S[i][j];\n      }\n    }\n    return h;\n  }\n};\n\ninline bool operator==(const State& a, const State& b) {\n  return a.S[0] == b.S[0] && a.S[1] == b.S[1] && a.S[2] == b.S[2];\n}\ninline bool operator!=(const State& a, const State& b) { return !(a == b); }\n\nint BFS(const State& start, const State& goal) {\n  unordered_set<State, StateHash> visited;\n  queue<State> q;\n  q.push(start);\n\n  auto IsMovable = [&](int from, int to, const auto& p) {\n    if (to < 0 || to >= 3) return false;\n    return p.empty(to) || p.top(from) >= p.top(to);\n  };\n\n  int step = 0;\n  while (!q.empty()) {\n    const auto p = q.front();\n    q.pop();\n\n    if (p == goal) {\n      step = p.step;\n      break;\n    }\n    for (int from = 0; from < 3; ++from) {\n      if (p.S[from].size() == 0) continue;\n      for (int d : {-1, 1}) {\n        const int to = from + d;\n        if (IsMovable(from, to, p)) {\n          State new_state = p;\n          new_state.step = p.step + 1;\n          new_state.push(to, p.top(from));\n          new_state.pop(from);\n          const auto it = visited.find(new_state);\n          if (it == visited.end()) {\n            visited.insert(new_state);\n            q.push(new_state);\n          }\n        }\n      }\n    }\n  }\n  return step;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  for (;;) {\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n\n    State goal;\n    for (int i = 0; i < 3; ++i) {\n      int t;\n      cin >> t;\n      int k;\n      for (int j = 0; j < t; ++j) {\n        cin >> k;\n        goal.S[i].push_back(k);\n      }\n    }\n    State start;\n    start.step = 0;\n    for (int i = 1; i <= n; ++i) {\n      start.S[2].push_back(i);\n    }\n\n    const int N = pow(3, n) - 1;\n    const int step = BFS(start, goal);\n    const int ans = N - step <= m ? N - step : -1;\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint mypow(int x,int n){\n\tint res = 1;\n\twhile(n>0){\t\t\n\t\tres *= x;\n\t\tif(n & 1) x = x*x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\nint conv(vector<int>& sets,int n){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * mypow(3,j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,int n,vector<int>& root, int* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root,n)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n-1;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp,n))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n-1;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp,n))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tint* visited = new int[3*mypow(3,n) + 1];\n\t\tfill_n(visited,3*mypow(3,n) + 1,-1);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,n,sets,visited));\n\t\tdelete[] visited;\n\t}\n\n\t//printf(\"%d %d %d\\n\",mypow(3,0),mypow(3,1),mypow(3,2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N, M;\n\nint solve(array<int, 3> const& target) {\n  queue<array<int, 3>> q;\n  int num = 0;\n  rep(i, N) num |= 1 << i;\n  q.push(array<int, 3>{{num, 0, 0}});\n  q.push(array<int, 3>{{0, 0, num}});\n\n  map<array<int, 3>, int> mp;\n  mp[array<int, 3>{{num, 0, 0}}] = 0;\n  mp[array<int, 3>{{0, 0, num}}] = 0;\n\n  while(!q.empty()) {\n    auto v = q.front(); q.pop();\n    if(v == target) {\n      return mp[v];\n    }\n\n    rep(i, v.size()) {\n      for(int k=N-1; k>=0; k--) {\n        if(v[i] >> k & 1) {\n          if(i + 1 < 3) {\n            auto nv = v;\n            nv[i] ^= 1 << k;\n            if(nv[i + 1] < (1<<k)) {\n              nv[i + 1] ^= 1 << k;\n              if(mp.find(nv) == mp.end() && mp[v] + 1 <= M) {\n                mp[nv] = mp[v] + 1;\n                q.push(nv);\n              }\n            }\n          }\n\n          if(i - 1 >= 0) {\n            auto nv = v;\n            nv[i] ^= 1 << k;\n            if(nv[i - 1] < (1<<k)) {\n              nv[i - 1] ^= 1 << k;\n              if(mp.find(nv) == mp.end() && mp[v] + 1 <= M) {\n                mp[nv] = mp[v] + 1;\n                q.push(nv);\n              }\n            }\n          }\n\n          break;\n        }\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main() {\n  while(cin >> N >> M && (N|M)) {\n    array<int, 3> cups;\n    rep(i, 3) {\n      int n; cin >> n;\n      int num = 0;\n      rep(j, n) {\n        int k; cin >> k; k--;\n        num |= 1 << k;\n      }\n      cups[i] = num;\n    }\n    cout << solve(cups) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nusing State=vector<stack<int>>;\nstruct Scene{\n\tState state;\n\tint prev_from;\n\tint prev_to;\n\tint count;\n\tScene(State state, int prev_from, int prev_to, int count) : \n\t\tstate(state), prev_from(prev_from), prev_to(prev_to), count(count){}\n};\n\nvoid enqueue(queue<Scene>& scene, Scene& s, int from, int to){\n\tif(s.prev_from==to && s.prev_to==from) return;\n\tif(s.state[from].empty()) return;\n\tif(!s.state[to].empty() && s.state[from].top()<s.state[to].top()) return;\n\tState t;\n\tcopy(s.state.begin(), s.state.end(), back_inserter(t));\n\tt[to].push(t[from].top()); t[from].pop();\n\tscene.push(Scene(t, from, to, s.count+1));\n}\n\nvoid dump(Scene& s){\n\tcout << \"--------------------------------------------------\\n\";\n\tcout << s.prev_from << \"|\" << s.prev_to << \"|\" << s.count << \"\\n\";\n\tState t;\n\tcopy(s.state.begin(), s.state.end(), back_inserter(t));\n\twhile(!t[0].empty()){ cout << t[0].top() << \", \"; t[0].pop(); } cout << \"\\n\";\n\twhile(!t[1].empty()){ cout << t[1].top() << \", \"; t[1].pop(); } cout << \"\\n\";\n\twhile(!t[2].empty()){ cout << t[2].top() << \", \"; t[2].pop(); } cout << \"\\n\";\n\tcout << \"--------------------------------------------------\\n\";\n}\n\nint solve(State init, int m){\n\tqueue<Scene> scene;\n\tscene.push(Scene(init, -1, -1, 0));\n\twhile(!scene.empty()){\n\t\tauto s=scene.front();\n\t\t//dump(s);\n\t\tif(s.state[1].empty() && (s.state[0].empty() || s.state[2].empty())){\n\t\t\treturn s.count;\n\t\t}\n\t\tif(s.count>m) return -1;\n\t\tenqueue(scene, s, 0, 1);\n\t\tenqueue(scene, s, 1, 0);\n\t\tenqueue(scene, s, 1, 2);\n\t\tenqueue(scene, s, 2, 1);\n\t\tscene.pop();\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile(true){\n\t\tint n, m; cin >> n >> m;\n\t\tif(n==0 && m==0) break;\n\t\tState s;\n\t\tfor(int i=0; i<3; ++i){\n\t\t\ts.push_back(stack<int>());\n\t\t\tint x; cin >> x;\n\t\t\tfor(int j=0; j<x; ++j){\n\t\t\t\tint y; cin >> y;\n\t\t\t\ts[i].push(y);\n\t\t\t}\n\t\t}\n\t\tcout << solve(s, m) << \"\\n\";\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\ntypedef long long int ll;\n\nint n;\nll ugo[15];\nint iti[15];\n\nll kai(int w)\n{\n\tll all = 0;\n\tint b = w;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(b == iti[i])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif(iti[i] == 1)\n\t\t{\n\t\t\tall += 1 + ugo[n - i - 1] * 2;\n\t\t\tif(b == 0)\n\t\t\t{\n\t\t\t\tb = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = 0;\n\t\t\t}\n\t\t}\n\t\telse if(b == 1)\n\t\t{\n\t\t\tall += 1 + ugo[n - i - 1];\n\t\t\tif(iti[i] == 0)\n\t\t\t{\n\t\t\t\tb = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tall += 2 + ugo[n - i - 1] * 4;\n\t\t}\n\t}\n\treturn all;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tll ma;\n\t\tscanf(\"%d %lld\",&n,&ma);\n\t\tif(n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tugo[0] = 0;\n\t\tfor(int i = 1; i < n; i++)\n\t\t{\n\t\t\tugo[i] = ugo[i - 1] * 3 + 1;\n\t\t}\n\t\tfor(int k = 0; k < 3; k++)\n\t\t{\n\t\t\tint m;\n\t\t\tscanf(\"%d\",&m);\n\t\t\tfor(int i = 0; i < m; i++)\n\t\t\t{\n\t\t\t\tint w;\n\t\t\t\tscanf(\"%d\",&w);\n\t\t\t\titi[w - 1] = k;\n\t\t\t}\n\t\t}\n\t\tll o;\n\t\tif(iti[0] == 1)\n\t\t{\n\t\t\tll w1 = kai(0);\n\t\t\tll w2 = kai(2);\n\t\t\tif(w1 < w2)\n\t\t\t{\n\t\t\t\to = w1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\to = w2;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\to = kai(iti[0]);\n\t\t}\n\t\tif(o > ma)\n\t\t{\n\t\t\to = -1;\n\t\t}\n\t\tprintf(\"%lld\\n\",o);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector<int> vi;\n\nint N, M, K, num;\n\nint main() {\n\twhile(cin>>N>>M, N | M) {\n\t\t// read data\n\t\tvi v(N+1);\n\t\tfor(int t=0; t<3; t++) {\n\t\t\tcin >> K;\n\t\t\tfor(int k=0; k<K; k++) {\n\t\t\t\tcin >> num;\n\t\t\t\tv[num] = t;\n\t\t\t}\n\t\t}\n\n\t\tvi a(N+1), c(N+1), p(N+1);\n\t\tp[N] = 2;\t\t\t// required steps to move A->C or C->A\n\t\ta[N] = v[N];\n\t\tc[N] = 2 - v[N];\n\t\tfor(int n=N; n>1; n--) {\n\t\t\tp[n-1] = 3 * p[n] + 2;\n\t\t\tswitch(v[n-1]) {\n\t\t\tcase 0:\n\t\t\t\ta[n-1] = a[n];\n\t\t\t\tc[n-1] = c[n] + 2 * p[n] + 2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ta[n-1] = c[n] + p[n] + 1;\n\t\t\t\tc[n-1] = a[n] + p[n] + 1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ta[n-1] = a[n] + 2 * p[n] + 2;\n\t\t\t\tc[n-1] = c[n];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint res = min(a[1], c[1]);\n\t\tif(M < res) res = -1;\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint size[3];\nint dat[3][15];\nint val[3];\nint now[3][15];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a+b){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint c;\n\t\t\tscanf(\"%d\",&c);\n\t\t\tsize[i]=c;\n\t\t\tfor(int j=0;j<c;j++)scanf(\"%d\",dat[i]+j);\n\t\t}\n\t\tint ret=999999999;\n\t\tif(size[0]==a||size[2]==a)ret=0;\n\t\tfor(int m=0;m<2;m++){\n\t\t\tint last=m;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tval[i]=size[i];\n\t\t\t\tfor(int j=0;j<size[i];j++)now[i][j]=dat[i][j];\n\t\t\t}\n\t\t\tint k=0;\n\t\t\twhile(k<b&&val[0]!=a&&val[2]!=a){\n\t\t\t\tif(val[last]==0||now[last][val[last]-1]<now[last+1][val[last+1]-1]){\n\t\t\t\t\tnow[last][val[last]++]=now[last+1][--val[last+1]];\n\t\t\t\t}else{\n\t\t\t\t\tnow[last+1][val[last+1]++]=now[last][--val[last]];\n\t\t\t\t}\n\t\t\t\tlast=!last;\n\t\t\t\tk++;\n\t\t//\t\tprintf(\"%d %d %d\\n\",val[0],val[1],val[2]);\n\t\t\t}\n\t\t\tif(val[0]==a||val[2]==a)ret=min(ret,k);\n\t\t}\n\t\tif(ret==999999999)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <set>\n#include <tuple>\n\nusing namespace std;\n\n#define ALL(co) co.begin(), co.end()\n#define tpl(...) make_tuple(__VA_ARGS__)\n\ntypedef long long LL;\ntypedef pair<int, int> P; typedef pair<int, P> IP; typedef pair<P, P> PP;\ntypedef vector<int> Array; typedef vector<vector<int> > Array2;\ntypedef vector<LL> LArray; typedef vector<P> PArray; typedef vector<string> SArray;\n\n#define mip(a, b, c) (IP(a, P(b, c)))\n\nconst int INF = 1 << 29;\nconst LL LINF = 1LL << 60;\n\ninline int getInt() { int itiv; return (cin >> itiv, itiv); }\ntemplate <typename T> void readAll(vector<T>& vec) { for (int i = 0, size = vec.size(); i < size; i++) cin >> vec[i]; }\ntemplate <typename T, typename U> void readAll(vector<pair<T, U> >& vec) { for (int i = 0, size = vec.size(); i < size; i++) cin >> vec[i].first >> vec[i].second; }\ntemplate < typename T > inline string toString( const T &a ){ ostringstream oss; oss << a; return oss.str(); };\ninline bool between(int min, int max, int n) { return min <= n && n <= max; }\ninline bool inRange(int begin, int end, int n) { return begin <= n && n < end; }\ninline bool inRange(int size, int n) { return 0 <= n && n < size; }\n\nint dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\nint dr[] = { 0, -1, 0, 1 }, dc[] = { -1, 0, 1, 0 };\n\nint m, n;\n\ninline int bitCount(int i) {\n\ti = i - ((i >> 1) & 0x55555555);\n\ti = (i & 0x33333333) + ((i >> 2) & 0x33333333);\n\ti = (i + (i >> 4)) & 0x0f0f0f0f;\n\ti = i + (i >> 8);\n\ti = i + (i >> 16);\n\treturn i & 0x3f;\n}\n\ninline int MSB32bit(int v) {\n\tif (v == 0) return -1;\n\tv |= (v >> 1);\n\tv |= (v >> 2);\n\tv |= (v >> 4);\n\tv |= (v >> 8);\n\tv |= (v >> 16);\n\treturn bitCount(v) - 1;\n}\n\ninline void movebit(int& a, int& b)\n{\n\tint msb_a = MSB32bit(a);\n\tint msb_b = MSB32bit(b);\n\tif(msb_a > msb_b)\n\t{\n\t\ta -= (1 << msb_a);\n\t\tb += (1 << msb_a);\n\t}\n\telse if(msb_a == msb_b)\n\t\treturn;\n\telse\n\t{\n\t\ta += (1 << msb_b);\n\t\tb -= (1 << msb_b);\n\t}\n}\n\nint main(void)\n{\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m && n)\n\t{\n\t\tint asize, bsize, csize;\n\t\tint as = 0, bs = 0, cs = 0;\n\t\tcin >> asize;\n\t\tfor (int i = 0; i < asize; i++)\n\t\t{\n\t\t\tas |= (1 << (getInt() - 1));\n\t\t}\n\t\tcin >> bsize;\n\t\tfor (int i = 0; i < bsize; i++)\n\t\t{\n\t\t\tbs |= (1 << (getInt() - 1));\n\t\t}\n\t\tcin >> csize;\n\t\tfor (int i = 0; i < csize; i++)\n\t\t{\n\t\t\tcs |= (1 << (getInt() - 1));\n\t\t}\n\n\t\t//a, b, c, count\n\t\t//a->b:0 b->a:1 b->c:2 c->b:3\n\t\tqueue<tuple<int, int, int, int>> que;\n\t\tmap<tuple<int, int, int>, bool> visited;\n\t\tque.push(tpl(as, bs, cs, 0));\n\t\tint ans = -1;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tauto now = que.front(); que.pop();\n\t\t\tint a = get<0>(now);\n\t\t\tint b = get<1>(now);\n\t\t\tint c = get<2>(now);\n\t\t\tint count = get<3>(now);\n\t\t\tif(visited[tpl(a, b, c)]) continue;\n\t\t\tvisited[tpl(a, b, c)] = true;\n\t\t\tif((a == 0 && b == 0) || (b == 0 && c == 0))\n\t\t\t{\n\t\t\t\tans = count;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(count >= m) continue;\n\t\t\tint na = a, nb = b, nc = c;\n\t\t\tmovebit(na, nb);\n\t\t\tif(na != a || nb != b)\n\t\t\t\tque.push(tpl(na, nb, nc, count + 1));\n\t\t\tna = a, nb = b, nc = c;\n\t\t\tmovebit(nb, nc);\n\t\t\tif(nb != b || nc != c)\n\t\t\t\tque.push(tpl(na, nb, nc, count + 1));\n\t\t}\n\n\t\tcout << ans  << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<string>\n#include<climits>\n#include<deque>\n\nusing namespace std;\n\nint m,INF=30000000;\nstack<int,vector<int> >A,B,C;\n\nint func(string p){\n  \n  int cnt=0;\n\n  for(int i=0;i<m;i++){\n    \n    if(B.empty() && (C.empty()||A.empty()))return cnt;\n    \n    if(!A.empty() && (B.empty() || A.top()>=B.top()) && p!=\"BA\"){\n      B.push(A.top());\n      A.pop();\n      cnt++,p=\"AB\";\n    }\n    \n    if(!B.empty() && (C.empty() || B.top()>=C.top()) && p!=\"CB\"){\n      C.push(B.top());\n      B.pop();\n      cnt++,p=\"BC\";\n    }\n    \n    if(!B.empty() && (A.empty() || B.top()>=A.top()) && p!=\"AB\"){\n      A.push(B.top());\n      B.pop();\n      cnt++,p=\"BA\";\n    }\n    \n    if(!C.empty() && (B.empty() || C.top()>=B.top()) && p!=\"BC\"){\n      B.push(C.top());\n      C.pop();\n      cnt++,p=\"CB\";\n    }\n    \n  }\n\n  return INF;\n}\n\nint main(void){\n  int n,ans,s,t;\n  \n  while(cin >> n >> m,n|m){\n\n    stack<int,vector<int> >Ain,Bin,Cin;\n\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      Ain.push(t);\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      Bin.push(t);\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      Cin.push(t);\n    }\n    \n    A=Ain,B=Bin,C=Cin;\n    ans=func(\"CB\");\n    \n    A=Ain,B=Bin,C=Cin;\n    ans=min(ans,func(\"AB\"));\n    \n    A=Ain,B=Bin,C=Cin;\n    ans=min(ans,func(\"BA\"));\n    \n    A=Ain,B=Bin,C=Cin;\n    ans=min(ans,func(\"BC\"));\n    \n    if(ans==INF)cout << -1 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n\nint maxmove(int x){\n  if(x == 0){\n    return 0;\n  }\n  else{\n    return maxmove(x - 1) * 3 + 1;\n  }\n}\n\nint main(){\n  while(1){\n    int n,m;\n    scanf(\"%d%d\", &n, &m);\n    if(n == 0 && m == 0){\n      return 0;\n    }\n    stack<int> cups[3];\n    for(int i = 0;i < 3;i++){\n      int k,cup;\n      scanf(\"%d\", &k);\n      for(int j = 0;j < k;j++){\n\tscanf(\"%d\", &cup);\n\tcups[i].push(cup);\n      }\n    }\n    int res = 0, lastto = -1, lastfrom = -1;\n    while(cups[0].size() != n && cups[2].size() != n){\n      bool moved = false;\n      for(int i = 0;i < 3 && !moved;i++){\n\tfor(int j = 0;j < 3 && !moved;j++){\n\t  if(abs(i - j) != 1 || cups[i].empty() || (j == lastfrom && i == lastto))continue;\n\t  if(cups[j].empty() || cups[i].top() > cups[j].top()){\n\t    cups[j].push(cups[i].top());\n\t    cups[i].pop();\n\t    res++;\n\t    lastfrom = i;\n\t    lastto = j;\n\t    moved = true;\n\t  }\n\t}\n      }\n    }\n    res = min(res, maxmove(n) * 2 - res);\n    if(res > m){\n      res = -1;\n    }\n    printf(\"%d\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<stack>\n \nusing namespace std;\n\nint count(stack<int> s[3], int m, int n, int index){\n\n  int count = 0;\n  int flag = 1;\n\n  while(1){\n    \n    if((s[0].empty() && s[1].empty()) || (s[1].empty() && s[2].empty())) break;\n\n    if(!flag || s[1].empty()){ \n      if(index == 0){\n\ts[2].push(s[index].top());\n\ts[index].pop();\n\tcount+=2;\n\tindex = 2; \n      }     \n      else if (index == 2){\n\ts[0].push(s[index].top());\n\ts[index].pop();\n\tcount+=2;\n\tindex = 0;      \n      }\n    }\n    \n    if((s[0].empty() && s[1].empty()) || (s[1].empty() && s[2].empty())) break; \n\n    if(s[0].empty()){\n      s[0].push(s[1].top());\n\ts[1].pop();\n\tcount++;\n    }     \n    else if(s[2].empty()){\n      s[2].push(s[1].top());\n      s[1].pop();\n      count++;\n    }  \n    else if(s[1].empty()){\n      s[1].push(s[(index+2)%4].top());\n      s[(index+2)%4].pop();\n      count++;\n    }\n    else{\n      if(s[0].top() > s[2].top()){\n\ts[2].push(s[1].top());\n\ts[1].pop();\n\tcount++;\n      }\n      else if(s[0].top() < s[2].top()){\n\ts[0].push(s[1].top());\n\ts[1].pop();\n\tcount++;\n      }\n    }\n    if(m+1 < count) return -1;\n    flag = 0;\n  }\n  return count;\n}\n\n\nint main(){\n\n  int n,m,tmp,c,index;\n  stack<int> s[3];\n\n  while(1){\n    cin >> n >> m;\n    if(n==0 && m==0) break;\n\n    for(int i = 0 ; i < 3 ; i++){\n      while(!s[i].empty()){\n\ts[i].pop();\n      }\n    }\n    for(int i = 0 ; i < 3 ; i++){\n      cin >> tmp;\n      \n      for(int j = 0 ; j < tmp ; j++){\n\tint num;\n\tcin >> num;\n\tif(num == n) index = i;\n\tif(i == 0) s[0].push(num); \n \tif(i == 1) s[1].push(num); \n\tif(i == 2) s[2].push(num); \n      } \n    }\n\n    c = count(s,m,n,index);    \n    cout << c << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint n,m; vector<ll> c;\n\nll dfs(ll a, ll b, ll c){\n  \n  if( a == 0 && b == 0){ return 0;}\n  \n  ll res = 1e8;\n  \n  if( c & 1){return  dfs( a >> 1, b >> 1, c >> 1);}\n  \n  if( b & 1){\n    return dfs( c >> 1, b >> 1, a >> 1)+1+dfs((a|b|c)>>1, 0,0) ;\n  }\n  \n  if( a & 1){\n    return dfs( a>>1,b>>1,c>>1)+1+2*dfs((a|b|c)>>1,0,0)+1;\n  }\n  \n}\n  \nint main(){ \n  while( cin >> n >> m){\n    \n    if( n == 0 && m == 0){ break;}\n   \n    c = vector<ll> (3,0);\n    \n    for(ll i = 0; i < 3; i++){\n    \n      ll k; cin >> k;\n      for(ll j = 0; j < k; j++){\n        ll a; cin >> a; c[i] |= (1LL << (a-1));\n      }\n    }\n    \n    \n    ll res = min(dfs(c[0],c[1],c[2]),dfs(c[2],c[1],c[0]));\n    \n    \n    if( res > m){ res = -1;}\n    \n    cout << res << endl;\n    \n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<stack<int> > > P;\ntypedef pair <int,P> PP;\ntypedef pair <int,PP> PPP;\n\nstatic const double eps = 1e-8;\n\nint bfs(int m,vector<stack<int> >& stks, map<vector<stack<int> >,int>& visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,stks));\n\tvisited[stks] = 0;\n\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\n\t\t\n\t\tvector<stack<int> > stks = que.top().second;\n\n\t\tif(stks[1].empty() && stks[2].empty()) return cost;\n\t\tif(stks[0].empty() && stks[1].empty()) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<stks.size();i++){\n\t\t\tif((!stks[i].empty() && !stks[i+1].empty() && stks[i].top() < stks[i+1].top()) \n\t\t\t\t|| (stks[i].empty() && !stks[i+1].empty())){\n\t\t\t\tvector<stack<int> > tmp = stks;\n\t\t\t\ttmp[i].push(tmp[i+1].top());\n\t\t\t\ttmp[i+1].pop();\n\t\t\t\tif(visited.find(tmp) == visited.end()){\n\t\t\t\t\tvisited[tmp] = cost + 1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((!stks[i].empty() && !stks[i+1].empty() && stks[i].top() > stks[i+1].top()) \n\t\t\t\t|| (!stks[i].empty() && stks[i+1].empty())){\n\t\t\t\tvector<stack<int> > tmp = stks;\n\t\t\t\ttmp[i+1].push(tmp[i].top());\n\t\t\t\ttmp[i].pop();\n\t\t\t\tif(visited.find(tmp) == visited.end()){\n\t\t\t\t\tvisited[tmp] = cost + 1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<stack<int> > stks(3);\n\t\tmap<vector<stack<int> >,int> visited;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tstks[i].push(size);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,stks,visited));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <functional>\n#define INPUT_FROM_FILE (0)\n\n#if INPUT_FROM_FILE\n#include <fstream>\n#endif\n\nconst char Max_n = 15;\n\nint f_A(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C);\nint f_B(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C);\nint f_C(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C);\n\nint f_A(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C){\n\tif(stack_B.empty() && stack_C.empty()){\n\t\treturn 0;\n\t}\n\tchar min_stack_A = !stack_A.empty() ? stack_A.front() : Max_n + 1;\n\tchar min_stack_B = !stack_B.empty() ? stack_B.front() : Max_n + 1;\n\tchar min_stack_C = !stack_C.empty() ? stack_C.front() : Max_n + 1;\n\n\tif(min_stack_A < min_stack_B && min_stack_A < min_stack_C){\n\t\tstack_A.pop_front();\n\t\treturn f_A(stack_A, stack_B, stack_C);\n\t}\n\tif(min_stack_B < min_stack_A && min_stack_B < min_stack_C){\n\t\tint n = 0;\n\n\t\tstack_B.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_C(stack_A, stack_B, stack_C) + int(pow(3, n));\n\t}\n\tif(min_stack_C < min_stack_A && min_stack_C < min_stack_B){\n\t\tint n = 0;\n\t\t\n\t\tstack_C.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_A(stack_A, stack_B, stack_C) + 2 * int(pow(3, n));\n\t}\n\n\tstd::cout << \"error f_A\" << std::endl;\n\texit(0);\n\treturn 0;\n}\n\nint f_B(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C){\n\tif(stack_A.empty() && stack_C.empty()){\n\t\treturn 0;\n\t}\n\tchar min_stack_A = !stack_A.empty() ? stack_A.front() : Max_n + 1;\n\tchar min_stack_B = !stack_B.empty() ? stack_B.front() : Max_n + 1;\n\tchar min_stack_C = !stack_C.empty() ? stack_C.front() : Max_n + 1;\n\n\tif(min_stack_A < min_stack_B && min_stack_A < min_stack_C){\n\t\tint n = 0;\n\t\t\n\t\tstack_A.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_C(stack_A, stack_B, stack_C) + (int(pow(3, n)) + 1) / 2;\n\t}\n\tif(min_stack_B < min_stack_A && min_stack_B < min_stack_C){\n\t\tstack_B.pop_front();\n\t\treturn f_B(stack_A, stack_B, stack_C);\n\t}\n\tif(min_stack_C < min_stack_A && min_stack_C < min_stack_B){\n\t\tint n = 0;\n\t\t\n\t\tstack_C.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_A(stack_A, stack_B, stack_C) + (int(pow(3, n)) + 1) / 2;\n\t}\n\n\tstd::cout << \"error f_B\" << std::endl;\n\texit(0);\n\treturn 0;\n}\n\nint f_C(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C){\n\tif(stack_A.empty() && stack_B.empty()){\n\t\treturn 0;\n\t}\n\tchar min_stack_A = !stack_A.empty() ? stack_A.front() : Max_n + 1;\n\tchar min_stack_B = !stack_B.empty() ? stack_B.front() : Max_n + 1;\n\tchar min_stack_C = !stack_C.empty() ? stack_C.front() : Max_n + 1;\n\n\tif(min_stack_A < min_stack_B && min_stack_A < min_stack_C){\n\t\tint n = 0;\n\n\t\tstack_A.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_C(stack_A, stack_B, stack_C) + 2 * int(pow(3, n));\n\t}\n\tif(min_stack_B < min_stack_A && min_stack_B < min_stack_C){\n\t\tint n = 0;\n\n\t\tstack_B.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_A(stack_A, stack_B, stack_C) + int(pow(3, n));\n\t}\n\tif(min_stack_C < min_stack_A && min_stack_C < min_stack_B){\n\t\tstack_C.pop_front();\n\t\treturn f_C(stack_A, stack_B, stack_C);\n\t}\n\n\tstd::cout << \"error f_C\" << std::endl;\n\texit(0);\n\treturn 0;\n}\n\nint main(int argc, char **argv){\n#if INPUT_FROM_FILE\n\tstd::ifstream ifs(\"test.txt\");\n#endif\n\tint n = 0;\n\tint m = 0;\n\n#if INPUT_FROM_FILE\n\twhile(ifs >> n >> m, (n != 0 || m != 0)){\n#else\n\twhile(std::cin >> n >> m, (n != 0 || m != 0)){\n#endif\n\t\tstd::deque<char> tray[3];\n\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tint num_cups = 0;\n\n#if INPUT_FROM_FILE\n\t\t\tifs >> num_cups;\n#else\n\t\t\tstd::cin >> num_cups;\n#endif\n\t\t\tfor(int j = 0; j < num_cups; j++){\n\t\t\t\tchar c = 0;\n\n#if INPUT_FROM_FILE\n\t\t\t\tifs >> c;\n#else\n\t\t\t\tstd::cin >> c;\n#endif\n\t\t\t\ttray[i].push_back(c - '0');\n\t\t\t}\n\t\t}\n\t\t//??¢?´¢\n\t\t{\n\t\t\tint num_move =std::min(f_A(tray[0], tray[1], tray[2]), f_C(tray[0], tray[1], tray[2]));\n\t\t\t\n\t\t\tif(num_move <= m){\n\t\t\t\tstd::cout << num_move << std::endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstd::cout << -1 << std::endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N, M;\n\nint solve(array<int, 3> const& target) {\n  queue<array<int, 3>> q;\n  int num = 0;\n  rep(i, N) num |= 1 << i;\n  q.push(array<int, 3>{{num, 0, 0}});\n  q.push(array<int, 3>{{0, 0, num}});\n\n  unordered_map<array<int, 3>, int> mp;\n  mp[array<int, 3>{{num, 0, 0}}] = 0;\n  mp[array<int, 3>{{0, 0, num}}] = 0;\n\n  while(!q.empty()) {\n    auto v = q.front(); q.pop();\n    if(v == target) {\n      return mp[v];\n    }\n\n    rep(i, v.size()) {\n      for(int k=N-1; k>=0; k--) {\n        if(v[i] >> k & 1) {\n          if(i + 1 < 3) {\n            auto nv = v;\n            nv[i] ^= 1 << k;\n            if(nv[i + 1] < (1<<k)) {\n              nv[i + 1] ^= 1 << k;\n              if(mp.find(nv) == mp.end() && mp[v] + 1 <= M) {\n                mp[nv] = mp[v] + 1;\n                q.push(nv);\n              }\n            }\n          }\n\n          if(i - 1 >= 0) {\n            auto nv = v;\n            nv[i] ^= 1 << k;\n            if(nv[i - 1] < (1<<k)) {\n              nv[i - 1] ^= 1 << k;\n              if(mp.find(nv) == mp.end() && mp[v] + 1 <= M) {\n                mp[nv] = mp[v] + 1;\n                q.push(nv);\n              }\n            }\n          }\n\n          break;\n        }\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main() {\n  while(cin >> N >> M && (N|M)) {\n    array<int, 3> cups;\n    rep(i, 3) {\n      int n; cin >> n;\n      int num = 0;\n      rep(j, n) {\n        int k; cin >> k; k--;\n        num |= 1 << k;\n      }\n      cups[i] = num;\n    }\n    cout << solve(cups) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint bg(int cup)\n{\n    int ans = 0;\n    loop (20, i) if (cup & 1<<i) ans = i;\n    return ans;\n}\n\nint calc(vector<int> cup, int m, int prev)\n{\n    if (m < 0) return -1;\n    if (!cup[0] && !cup[1] || !cup[1] && !cup[2]) return m;\n\n    int i, j;\n    if (!prev) i = 1, j = 2;\n    else i = 0, j = 1;\n\n    if (bg(cup[i]) && bg(cup[i]) > bg(cup[j])) {\n        cup[j] ^= 1<<bg(cup[i]);\n        cup[i] ^= 1<<bg(cup[i]);\n        return calc(cup, m-1, !prev);\n    } else if (bg(cup[j]) && bg(cup[j]) > bg(cup[i])){\n        cup[i] ^= 1<<bg(cup[j]);\n        cup[j] ^= 1<<bg(cup[j]);\n        return calc(cup, m-1, !prev);\n    }\n    return -1;\n}\n\nint main()\n{\n    while (1) {\n        int n, m; cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        vector<int> cup(3);\n        loop (3, i) {\n            int c; cin >> c;\n            while (c--) {\n                int v; cin >> v;\n                cup[i] |= 1<<v;\n            }\n        }\n        int ans = max({\n                calc(cup, m, 0),\n                calc(cup, m, 1)});\n        cout << (ans < 0 ? -1 : m-ans) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n#define INF\t100000000\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define SORT(x) sort((x).begin(), (x).end())\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define front top\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint n, m;\nint t;\nint ans;\nVi v[3];\n\nvoid solve(){\n\tstack<int> que[3];\n\trep(i,3) rep(j,v[i].size()) que[i].push(v[i][j]);\n\trep(i,m){\n\t//\trep(j,3) cout << que[j].size() << \" \";\n\t\t//cout << endl;\n\t\tif(t == 0){\n\t\t\tif(que[0].size() == 0){\n\t\t\t\tque[0].push(que[1].front());\n\t\t\t\tque[1].pop();\n\t\t\t} else if(que[1].size() == 0){\n\t\t\t\tque[1].push(que[0].front());\n\t\t\t\tque[0].pop();\n\t\t\t} else{\n\t\t\t\tif(que[0].front() > que[1].front()){\n\t\t\t\t\tque[1].push(que[0].front());\n\t\t\t\t\tque[0].pop();\n\t\t\t\t} else{\n\t\t\t\t\tque[0].push(que[1].front());\n\t\t\t\t\tque[1].pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = 1;\n\t\t} else{\n\t\t\tif(que[1].size() == 0){\n\t\t\t\tque[1].push(que[2].front());\n\t\t\t\tque[2].pop();\n\t\t\t} else if(que[2].size() == 0){\n\t\t\t\tque[2].push(que[1].front());\n\t\t\t\tque[1].pop();\n\t\t\t} else{\n\t\t\t\tif(que[1].front() > que[2].front()){\n\t\t\t\t\tque[2].push(que[1].front());\n\t\t\t\t\tque[1].pop();\n\t\t\t\t} else{\n\t\t\t\t\tque[1].push(que[2].front());\n\t\t\t\t\tque[2].pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = 0;\n\t\t}\n\t\tif(que[0].size() == n || que[2].size() == n){\n\t\t\tans = min(ans,i+1);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &m),n||m){\n\t\trep(i,3) v[i].clear();\n\t\trep(i,3){\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\trep(j,x){\n\t\t\t\tint tmp; scanf(\"%d\", &tmp);\n\t\t\t\tv[i].pb(tmp);\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tif(v[0].size() == n || v[2].size() == n){\n\t\t\tprintf(\"%d\\n\", 0);\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,2){\n\t\t\tt = i;\n\t\t\tsolve();\n\t\t}\n\t\tif(ans == INF) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\nint n, m;\nint POW[16];\n\nint calc(int A, int B, int C) {\n\tint res = 0;\n\tfor_(i,0,n) {\n\t\tint k = n - i - 1;\n\t\tif (A >> i & 1) res += 2 * POW[k];\n\t\tif (B >> i & 1) res += POW[k], swap(A, C);\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tint cup[3] = { 0 };\n\t\n\tfor_(i,0,3) {\n\t\tint d; cin >> d;\n\t\tfor_(j,0,d) {\n\t\t\tint p; cin >> p; --p;\n\t\t\tcup[i] |= 1 << p;\n\t\t}\n\t}\n\t\n\tint ans = min(calc(cup[0], cup[1], cup[2]), calc(cup[2], cup[1], cup[0]));\n\tcout << ( (ans > m) ? -1 : ans) << endl;\n}\n\nint main() {\n\tPOW[0] = 1;\n\tfor_(i,1,16) POW[i] = POW[i - 1] * 3;\n\twhile (cin >> n >> m, n) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <algorithm>\n#include <math.h>\n#define INPUT_FROM_FILE (0)\n\n#if INPUT_FROM_FILE\n#include <fstream>\n#endif\n\nconst char Max_n = 15;\n\nint f_A(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C);\nint f_B(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C);\nint f_C(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C);\n\nint f_A(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C){\n\tif(stack_B.empty() && stack_C.empty()){\n\t\treturn 0;\n\t}\n\tchar min_stack_A = !stack_A.empty() ? stack_A.front() : Max_n + 1;\n\tchar min_stack_B = !stack_B.empty() ? stack_B.front() : Max_n + 1;\n\tchar min_stack_C = !stack_C.empty() ? stack_C.front() : Max_n + 1;\n\n\tif(min_stack_A < min_stack_B && min_stack_A < min_stack_C){\n\t\tstack_A.pop_front();\n\t\treturn f_A(stack_A, stack_B, stack_C);\n\t}\n\tif(min_stack_B < min_stack_A && min_stack_B < min_stack_C){\n\t\tint n = 0;\n\n\t\tstack_B.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_C(stack_A, stack_B, stack_C) + int(pow(3, n));\n\t}\n\tif(min_stack_C < min_stack_A && min_stack_C < min_stack_B){\n\t\tint n = 0;\n\t\t\n\t\tstack_C.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_A(stack_A, stack_B, stack_C) + 2 * int(pow(3, n));\n\t}\n\n\t//std::cout << \"error f_A\" << std::endl;\n\t//exit(0);\n\treturn 0;\n}\n\nint f_B(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C){\n\tif(stack_A.empty() && stack_C.empty()){\n\t\treturn 0;\n\t}\n\tchar min_stack_A = !stack_A.empty() ? stack_A.front() : Max_n + 1;\n\tchar min_stack_B = !stack_B.empty() ? stack_B.front() : Max_n + 1;\n\tchar min_stack_C = !stack_C.empty() ? stack_C.front() : Max_n + 1;\n\n\tif(min_stack_A < min_stack_B && min_stack_A < min_stack_C){\n\t\tint n = 0;\n\t\t\n\t\tstack_A.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_C(stack_A, stack_B, stack_C) + (int(pow(3, n)) + 1) / 2;\n\t}\n\tif(min_stack_B < min_stack_A && min_stack_B < min_stack_C){\n\t\tstack_B.pop_front();\n\t\treturn f_B(stack_A, stack_B, stack_C);\n\t}\n\tif(min_stack_C < min_stack_A && min_stack_C < min_stack_B){\n\t\tint n = 0;\n\t\t\n\t\tstack_C.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_A(stack_A, stack_B, stack_C) + (int(pow(3, n)) + 1) / 2;\n\t}\n\n\t//std::cout << \"error f_B\" << std::endl;\n\t//exit(0);\n\treturn 0;\n}\n\nint f_C(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C){\n\tif(stack_A.empty() && stack_B.empty()){\n\t\treturn 0;\n\t}\n\tchar min_stack_A = !stack_A.empty() ? stack_A.front() : Max_n + 1;\n\tchar min_stack_B = !stack_B.empty() ? stack_B.front() : Max_n + 1;\n\tchar min_stack_C = !stack_C.empty() ? stack_C.front() : Max_n + 1;\n\n\tif(min_stack_A < min_stack_B && min_stack_A < min_stack_C){\n\t\tint n = 0;\n\n\t\tstack_A.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_C(stack_A, stack_B, stack_C) + 2 * int(pow(3, n));\n\t}\n\tif(min_stack_B < min_stack_A && min_stack_B < min_stack_C){\n\t\tint n = 0;\n\n\t\tstack_B.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_A(stack_A, stack_B, stack_C) + int(pow(3, n));\n\t}\n\tif(min_stack_C < min_stack_A && min_stack_C < min_stack_B){\n\t\tstack_C.pop_front();\n\t\treturn f_C(stack_A, stack_B, stack_C);\n\t}\n\n\t//std::cout << \"error f_C\" << std::endl;\n\t//exit(0);\n\treturn 0;\n}\n\nint main(int argc, char **argv){\n#if INPUT_FROM_FILE\n\tstd::ifstream ifs(\"test.txt\");\n#endif\n\tint n = 0;\n\tint m = 0;\n\n#if INPUT_FROM_FILE\n\twhile(ifs >> n >> m, (n != 0 || m != 0)){\n#else\n\twhile(std::cin >> n >> m, (n != 0 || m != 0)){\n#endif\n\t\tstd::deque<char> tray[3];\n\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tint num_cups = 0;\n\n#if INPUT_FROM_FILE\n\t\t\tifs >> num_cups;\n#else\n\t\t\tstd::cin >> num_cups;\n#endif\n\t\t\tfor(int j = 0; j < num_cups; j++){\n\t\t\t\tchar c = 0;\n\n#if INPUT_FROM_FILE\n\t\t\t\tifs >> c;\n#else\n\t\t\t\tstd::cin >> c;\n#endif\n\t\t\t\ttray[i].push_back(c - '0');\n\t\t\t}\n\t\t}\n\t\t//??¢?´¢\n\t\t{\n\t\t\tint num_move =std::min(f_A(tray[0], tray[1], tray[2]), f_C(tray[0], tray[1], tray[2]));\n\t\t\t\n\t\t\tif(num_move <= m){\n\t\t\t\tstd::cout << num_move << std::endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstd::cout << -1 << std::endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\nvoid move(stack<int> A, stack<int> B, stack<int> C, int m, int exp);\n\nint maxcount;//決められた、動き方の最大値\nint mincount;//今までに発見した最短の動き方\n\nint main() {\n\tint n;\n\tint m;\n\tint temp;\n\tint A_size,B_size,C_size;\n\tint ans[2000];\n\tint ansindex=0;\n\twhile(true){\n\t\tcin>>n;//n個のコップ\n\t\tcin>>m;//m回以内で動かせるか\n\t\tif(n==0&&m==0)break;\n\t\tmaxcount=m;//動かせる最大値\n\t\tmincount=m+1;//更新されていなければ解はなかった\n\t\tstack<int> stA;//Aのスタック\n\t\tstack<int> stB;//Bのスタック\n\t\tstack<int> stC;//Cのスタック\n\t\tcin>>A_size;\n\t\tfor(int i=0; i<A_size; i++){\n\t\t\tcin>>temp;\n\t\t\tstA.push(temp);\n\t\t}//Aの入力\n\t\tcin>>B_size;\n\t\tfor(int i=0; i<B_size; i++){\n\t\t\tcin>>temp;\n\t\t\tstB.push(temp);\n\t\t}//Bの入力\n\t\tcin>>C_size;\n\t\tfor(int i=0; i<C_size; i++){\n\t\t\tcin>>temp;\n\t\t\tstC.push(temp);\n\t\t}//Cの入力\n\t\tmove(stA,stB,stC,0,4);\n\t\tif(mincount==m+1)ans[ansindex]=-1;\n\t\telse ans[ansindex]=mincount;\n\t\tansindex++;\n\t}\n\tfor(int i=0; i<ansindex; i++){\n\t\tcout<<ans[i]<<\"\\n\";\n\t}\n\treturn 0;\n}\n\n\nvoid move(stack<int> A, stack<int> B, stack<int> C, int count, int exp){\n\tint temp;\n\tif(count>maxcount)return;\n\tif((A.empty()||C.empty())&&B.empty()){\n\t\tif(count<mincount)mincount=count;\n\t}\n\tif(exp!=1&&((B.empty()&&A.empty()==false)||(B.empty()==false&&A.empty()==false&&A.top()>B.top()))){\n\t\t//行動0\n\t\ttemp=A.top();\n\t\tA.pop();\n\t\tB.push(temp);\n\t\tcount++;\n\t\tmove(A,B,C,count,0);\n\t\tcount--;\n\t\tB.pop();\n\t\tA.push(temp);\n\t}\n\tif(exp!=0&&((A.empty()&&B.empty()==false)||(A.empty()==false&&B.empty()==false&&B.top()>A.top()))){\n\t\t//行動1\n\t\ttemp=B.top();\n\t\tB.pop();\n\t\tA.push(temp);\n\t\tcount++;\n\t\tmove(A,B,C,count,1);\n\t\tcount--;\n\t\tA.pop();\n\t\tB.push(temp);\n\t}\n\tif(exp!=3&&((B.empty()&&C.empty()==false)||(B.empty()==false&&C.empty()==false&&C.top()>B.top()))){\n\t\t//行動2\n\t\ttemp=C.top();\n\t\tC.pop();\n\t\tB.push(temp);\n\t\tcount++;\n\t\tmove(A,B,C,count,2);\n\t\tcount--;\n\t\tB.pop();\n\t\tC.push(temp);\n\t}\n\tif(exp!=2&&((C.empty()&&B.empty()==false)||(C.empty()==false&&B.empty()==false&&B.top()>C.top()))){\n\t\t//行動3\n\t\ttemp=B.top();\n\t\tB.pop();\n\t\tC.push(temp);\n\t\tcount++;\n\t\tmove(A,B,C,count,3);\n\t\tcount--;\n\t\tC.pop();\n\t\tB.push(temp);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint an, bn, cn, a[20], b[20], c[20], total = 0, f = 1;\n\nstruct mm{\n\tchar ch;\n\tint nu;\n};\n\nstruct mm m1, m2;\n\nint judge(int max, int temp){\n\tif(temp + 1 == an + bn + cn)return -1;\n\tif(a[an] == max - temp)return 50 + temp;\n\tif(c[cn] == max - temp)return 100 + temp;\n\tif(b[cn - temp] == max - temp)return judge(max, temp + 1);\n\treturn 0;\n}\n\nint calculation(int min, int max){\n\tint sum;\n\tif(min == max)return 0;\n\tif(min < max)sum = calculation(++min, max) * 3 + 2;\n\treturn sum;\n}\n\nint move(int flag){\n\tint number;\n\tif(flag == 2){  //right\n\t\tnumber = an - m1.nu + 1;\n\t\tfor(int i = 1;i <= number;i++)c[++cn] = a[an--];\n\t}\n\tif(flag == 1){\n\t\tnumber = cn - m1.nu + 1;\n\t\tfor(int i = 1;i <= number;i++)a[++an] = c[cn--];\n\t}\n\t//printf(\"*%d %d %d*\", an, m1.nu, number);\n\ttotal += calculation(0, number);\n\t//printf(\"*%d*\", number);\n\treturn 0;\n}\n\nint sort(int max){\n\tif(m1.ch == m2.ch)return 0;\n\tif(m2.ch == 'b'){\n\t\tif(m1.ch == 'a')c[++cn] = b[bn--], move(2);  //right\n\t\tif(m1.ch == 'c')a[++an] = b[bn--], move(1);\n\t\ttotal++;\n\t}else if(m2.ch == 'a'){\n\t\tif(c[cn - 1] == max - 2){\n\t\t\tint te = an;\n\t\t\tb[++bn] = a[an--], move(1);\n\t\t\tm1.ch = 'a', m1.nu = te;\n\t\t\tc[++cn] = b[bn--], move(2);\n\t\t}else{\n\t\t\tmove(1);\n\t\t}\n\t}else if(m2.ch == 'c'){\n\t\tif(a[an - 1] == max - 2){\n\t\t\tint te = cn;\n\t\t\tb[++bn] = c[cn--], move(2);\n\t\t\tm1.ch = 'c', m1.nu = te;\n\t\t\ta[++an] = b[bn--], move(1);\n\t\t}else{\n\t\t\tmove(2);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint solve(int max){\n\tfor(int i = 1;i <= an;i++){\n\t\tif(a[i] == max)m1.ch = 'a',m1.nu = i;\n\t\tif(a[i] == max - 1)m2.ch = 'a', m2.nu = i;\n\t}\n\tfor(int i = 1;i <= bn;i++){\n\t\tif(b[i] == max)m1.ch = 'b',m1.nu = i;\n\t\tif(b[i] == max - 1)m2.ch = 'b', m2.nu = i;\n\t}\n\tfor(int i = 1;i <= cn;i++){\n\t\tif(c[i] == max)m1.ch = 'c',m1.nu = i;\n\t\tif(c[i] == max - 1)m2.ch = 'c', m2.nu = i;\n\t}\n\tif(f == 1 && m1.ch == 'b'){\n\t\tint vec = 0;  //1 = left \n\t\tif(m2.ch == 'b'){\n\t\t\tint temp = judge(max, 2);\n\t\t\tif(temp == -1)return 0;\n\t\t\tif(temp >= 100){\n\t\t\t\tif(temp % 2)vec = 2;\n\t\t\t\telse vec = 1;\n\t\t\t}else if(temp >= 50){\n\t\t\t\tif(temp % 2)vec = 1;\n\t\t\t\telse vec = 2;\n\t\t\t}\n\t\t}\n\t\tif(m2.ch == 'a'){\n\t\t\tif(vec == 1)a[++an] = b[bn--];\n\t\t\tif(c[cn] == max - 2){\n\t\t\t\tc[++cn] = a[an--], c[++cn] = b[bn++];\n\t\t\t\ttotal += 7;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(m2.ch == 'c'){\n\t\t\tif(vec == 2)c[++cn] = b[bn--];\n\t\t\tif(a[an] == max - 2){\n\t\t\t\ta[++an] = c[cn--], a[++an] = b[bn++];\n\t\t\t\ttotal += 7;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t//printf(\"*%d*\", total);\n\t\ttotal++;\n\t}\n\tsort(max);\n\t//printf(\"*%d*\", total);\n\t\n\treturn 0;\n}\n\nint main(){\n\tint n, m, max = 0;\n\twhile(scanf(\"%d %d\",&n, &m)){\n\t\tif(n == 0 && m == 0)break;\n\t\tmax = total = 0, f = 1;\n\t\t\n\t\t\n\t\tscanf(\"%d\", &an);\n\t\tfor(int i = 1;i <= an;i++){\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t\tif(a[i] > max)max = a[i];\n\t\t}\n\t\tscanf(\"%d\", &bn);\n\t\tfor(int i = 1;i <= bn;i++){\n\t\t\tscanf(\"%d\", &b[i]);\n\t\t\tif(b[i] > max)max = b[i];\n\t\t}\n\t\tscanf(\"%d\", &cn);\n\t\tfor(int i = 1;i <= cn;i++){\n\t\t\tscanf(\"%d\", &c[i]);\n\t\t\tif(c[i] > max)max = c[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < n - 1;i++)solve(max - i);\n\t\t\n\t\tprintf(\"%d\\n\", total);\n\t\t//if(total <= m)printf(\"%d\\n\", total);\n\t\t//else printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nmap<int,int>ma;\nint n,m;\nll f(int a,int b){\n\tif(b==n+1){\n\t\treturn 0;\n\t}\n\tint t=ma[b];\n\tll out;\n\tif(a==t)out=f(a,b+1);\n\telse if(t==1){\n\t\tout=f(a==2?0:2,b+1)+pow(3,n-b);\n\t}else{\n\t\tout=f(a,b+1)+pow(3,n-b)*2;\n\t}\n\treturn out;\n}\nint main(){\n\twhile(cin>>n>>m,n+m){\n\t\trep(i,3){\n\t\t\tint a;cin>>a;\n\t\t\trep(j,a){\n\t\t\t\tint b;cin>>b;\n\t\t\t\tma[b]=i;\n\t\t\t}\n\t\t}\n\t\tll out=min(f(0,1),f(2,1));\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <algorithm>\n#include <math.h>\n#define INPUT_FROM_FILE (0)\n\n#if INPUT_FROM_FILE\n#include <fstream>\n#endif\n\nconst char Max_n = 15;\n\nint f_A(const std::deque<char> &stack_A, const std::deque<char> &stack_B, const std::deque<char> &stack_C, int idx_A, int idx_B, int idx_C);\nint f_B(const std::deque<char> &stack_A, const std::deque<char> &stack_B, const std::deque<char> &stack_C, int idx_A, int idx_B, int idx_C);\nint f_C(const std::deque<char> &stack_A, const std::deque<char> &stack_B, const std::deque<char> &stack_C, int idx_A, int idx_B, int idx_C);\n\nint f_A(const std::deque<char> &stack_A, const std::deque<char> &stack_B, const std::deque<char> &stack_C, int idx_A, int idx_B, int idx_C){\n\tif(idx_B >= stack_B.size() && idx_C >= stack_C.size()){\n\t\treturn 0;\n\t}\n\tchar min_stack_A = !(idx_A >= stack_A.size()) ? stack_A[idx_A] : Max_n + 1;\n\tchar min_stack_B = !(idx_B >= stack_B.size()) ? stack_B[idx_B] : Max_n + 1;\n\tchar min_stack_C = !(idx_C >= stack_C.size()) ? stack_C[idx_C] : Max_n + 1;\n\n\tif(min_stack_A < min_stack_B && min_stack_A < min_stack_C){\n\t\tidx_A++;\n\t\treturn f_A(stack_A, stack_B, stack_C, idx_A, idx_B, idx_C);\n\t}\n\tif(min_stack_B < min_stack_A && min_stack_B < min_stack_C){\n\t\tint n = 0;\n\n\t\tidx_B++;\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size() - (idx_A + idx_B + idx_C);\n\t\treturn f_C(stack_A, stack_B, stack_C, idx_A, idx_B, idx_C) + int(pow(3, n));\n\t}\n\tif(min_stack_C < min_stack_A && min_stack_C < min_stack_B){\n\t\tint n = 0;\n\t\t\n\t\tidx_C++;\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size() - (idx_A + idx_B + idx_C);\n\t\treturn f_A(stack_A, stack_B, stack_C, idx_A, idx_B, idx_C) + 2 * int(pow(3, n));\n\t}\n\n\t//std::cout << \"error f_A\" << std::endl;\n\t//exit(0);\n\treturn 0;\n}\n\nint f_B(const std::deque<char> &stack_A, const std::deque<char> &stack_B, const std::deque<char> &stack_C, int idx_A, int idx_B, int idx_C){\n\tif(idx_A >= stack_A.size() && idx_C >= stack_C.size()){\n\t\treturn 0;\n\t}\n\tchar min_stack_A = !(idx_A >= stack_A.size()) ? stack_A[idx_A] : Max_n + 1;\n\tchar min_stack_B = !(idx_B >= stack_B.size()) ? stack_B[idx_B] : Max_n + 1;\n\tchar min_stack_C = !(idx_C >= stack_C.size()) ? stack_C[idx_C] : Max_n + 1;\n\n\tif(min_stack_A < min_stack_B && min_stack_A < min_stack_C){\n\t\tint n = 0;\n\t\t\n\t\tidx_A++;\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size() - (idx_A + idx_B + idx_C);\n\t\treturn f_C(stack_A, stack_B, stack_C, idx_A, idx_B, idx_C) + (int(pow(3, n)) + 1) / 2;\n\t}\n\tif(min_stack_B < min_stack_A && min_stack_B < min_stack_C){\n\t\tidx_B++;\n\t\treturn f_B(stack_A, stack_B, stack_C, idx_A, idx_B, idx_C);\n\t}\n\tif(min_stack_C < min_stack_A && min_stack_C < min_stack_B){\n\t\tint n = 0;\n\t\t\n\t\tidx_C++;\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size() - (idx_A + idx_B + idx_C);\n\t\treturn f_A(stack_A, stack_B, stack_C, idx_A, idx_B, idx_C) + (int(pow(3, n)) + 1) / 2;\n\t}\n\n\t//std::cout << \"error f_B\" << std::endl;\n\t//exit(0);\n\treturn 0;\n}\n\nint f_C(const std::deque<char> &stack_A, const std::deque<char> &stack_B, const std::deque<char> &stack_C, int idx_A, int idx_B, int idx_C){\n\tif(idx_A >= stack_A.size() && idx_B >= stack_B.size()){\n\t\treturn 0;\n\t}\n\tchar min_stack_A = !(idx_A >= stack_A.size()) ? stack_A[idx_A] : Max_n + 1;\n\tchar min_stack_B = !(idx_B >= stack_B.size()) ? stack_B[idx_B] : Max_n + 1;\n\tchar min_stack_C = !(idx_C >= stack_C.size()) ? stack_C[idx_C] : Max_n + 1;\n\n\tif(min_stack_A < min_stack_B && min_stack_A < min_stack_C){\n\t\tint n = 0;\n\n\t\tidx_A++;\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size() - (idx_A + idx_B + idx_C);\n\t\treturn f_C(stack_A, stack_B, stack_C, idx_A, idx_B, idx_C) + 2 * int(pow(3, n));\n\t}\n\tif(min_stack_B < min_stack_A && min_stack_B < min_stack_C){\n\t\tint n = 0;\n\n\t\tidx_B++;\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size() - (idx_A + idx_B + idx_C);\n\t\treturn f_A(stack_A, stack_B, stack_C, idx_A, idx_B, idx_C) + int(pow(3, n));\n\t}\n\tif(min_stack_C < min_stack_A && min_stack_C < min_stack_B){\n\t\tidx_C++;\n\t\treturn f_C(stack_A, stack_B, stack_C, idx_A, idx_B, idx_C);\n\t}\n\n\t//std::cout << \"error f_C\" << std::endl;\n\t//exit(0);\n\treturn 0;\n}\n\nint main(int argc, char **argv){\n#if INPUT_FROM_FILE\n\tstd::ifstream ifs(\"test.txt\");\n#endif\n\tint n = 0;\n\tint m = 0;\n\n#if INPUT_FROM_FILE\n\twhile(ifs >> n >> m, (n != 0 || m != 0)){\n#else\n\twhile(std::cin >> n >> m, (n != 0 || m != 0)){\n#endif\n\t\tstd::deque<char> tray[3];\n\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tint num_cups = 0;\n\n#if INPUT_FROM_FILE\n\t\t\tifs >> num_cups;\n#else\n\t\t\tstd::cin >> num_cups;\n#endif\n\t\t\tfor(int j = 0; j < num_cups; j++){\n\t\t\t\tchar c = 0;\n\n#if INPUT_FROM_FILE\n\t\t\t\tifs >> c;\n#else\n\t\t\t\tstd::cin >> c;\n#endif\n\t\t\t\ttray[i].push_back(c - '0');\n\t\t\t}\n\t\t}\n\t\t//??¢?´¢\n\t\t{\n\t\t\tint num_move =std::min(f_A(tray[0], tray[1], tray[2], 0, 0, 0), f_C(tray[0], tray[1], tray[2], 0, 0, 0));\n\t\t\t\n\t\t\tif(num_move <= m){\n\t\t\t\tstd::cout << num_move << std::endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstd::cout << -1 << std::endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <queue>\nusing namespace std;\n#define F first\n#define S second\nconst int INF=100000000;\n\nint ans;\nunsigned int n,m;\n//vector<stack<int> > goal(3);\n\nstruct state{\n\tstack<int> s[3];\n\tint count,from,to;\n\t/*\n\tstate(stack<int> hoge[3]){\n\t\tfor(int i=0; i<3; ++i){\n\t\t\ts[i]=hoge[i];\n\t\t}\n\t}\n\t*/\n};\n\nvoid bfs(stack<int> si[3],int f,int t){\n\tstate hoge;\n\tfor(int i=0 ;i<3; ++i) hoge.s[i]=si[i];\n\thoge.count=0;\n\thoge.from=f;\n\thoge.to=t;\n\tqueue<state> que;\n\tque.push(hoge);\n\twhile(!que.empty()){\n\t\tstate st=que.front();\n\t\tque.pop();\n\t\t//cout << st.count << endl;\n\t\t//if(st.count>m) continue;\n\t\tif(st.s[0].size()==n||st.s[2].size()==n){\n\t\t\tans=min(ans,st.count);\n\t\t\treturn;\n\t\t}\n\t\tif(!(st.from==1&&st.to==0)&&st.s[0].size()!=0&&(st.s[1].size()==0||st.s[0].top()>st.s[1].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[1].push(ns.s[0].top());\n\t\t\tns.s[0].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=0;\n\t\t\tns.to=1;\n\t\t\tque.push(ns);\n\t\t}\n\t\tif(!(st.from==2&&st.to==1)&&st.s[1].size()!=0&&(st.s[2].size()==0||st.s[1].top()>st.s[2].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[2].push(ns.s[1].top());\n\t\t\tns.s[1].pop();//\n\t\t\t++ns.count;\n\t\t\tns.from=1;\n\t\t\tns.to=2;\n\t\t\tque.push(ns);\n\t\t} else if(!(st.from==0&&st.to==1)&&st.s[1].size()!=0&&(st.s[0].size()==0||st.s[1].top()>st.s[0].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[0].push(ns.s[1].top());\n\t\t\tns.s[1].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=1;\n\t\t\tns.to=0;\n\t\t\tque.push(ns);\n\t\t}\n\t\tif(!(st.from==1&&st.to==2)&&st.s[2].size()!=0&&(st.s[1].size()==0||st.s[2].top()>st.s[1].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[1].push(ns.s[2].top());\n\t\t\tns.s[2].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=2;\n\t\t\tns.to=1;\n\t\t\tque.push(ns);\n\t\t}\n\t}\n}\n\n/*\nvoid dfs(stack<int> s[3],int count,pair<int,int> f){\n\tif(count>m) return;\n\tif(s[0].size()==n||s[2].size()==n){\n\t\tans=min(ans,count);\n\t\treturn;\n\t}\n\t//f.F -->f.S\n\t//01 10 12 21\n\tif(!(f.F==1&&f.S==0)&&s[0].size()!=0&&(s[1].size()==0||s[0].top()>s[1].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[1].push(ns[0].top());\n\t\tns[0].pop();\n\t\tdfs(ns,count+1,pair<int,int>(0,1));\n\t}\n\tif(!(f.F==0&&f.S==1)&&s[1].size()!=0&&(s[0].size()==0||s[1].top()>s[0].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[0].push(ns[1].top());\n\t\tns[1].pop();\n\t\tdfs(ns,count+1,pair<int,int>(1,0));\n\t}\n\tif(!(f.F==2&&f.S==1)&&s[1].size()!=0&&(s[2].size()==0||s[1].top()>s[2].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[2].push(ns[1].top());\n\t\tns[1].pop();\n\t\tdfs(ns,count+1,pair<int,int>(1,2));\n\t}\n\tif(!(f.F==1&&f.S==2)&&s[2].size()!=0&&(s[1].size()==0||s[2].top()>s[1].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[1].push(ns[2].top());\n\t\tns[2].pop();\n\t\tdfs(ns,count+1,pair<int,int>(2,1));\n\t}\n}\n*/\n\nint pow(int a,int b){\n\tint res=1;\n\tfor(int i=0; i<b; ++i){\n\t\tres*=a;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint pow3[16];\n\tfor(int i=1; i<=15; ++i){\n\t\tpow3[i]=pow(3,i)-1;\n\t}\n\twhile(cin >> n >> m){\n\tif(n==0&&m==0) break;\n\t\tans=INF;\n\t\tstack<int> cup[3];\n\t\tfor(int i=0; i<3; ++i){\n\t\t\tint q;\n\t\t\tcin >> q;\n\t\t\tfor(int j=0; j<q; ++j){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tcup[i].push(tmp);\n\t\t\t\t//cout << cup[i].top() << endl;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\t/*\n\t\tdfs(cup,0,pair<int,int>(0,1));\n\t\tdfs(cup,0,pair<int,int>(1,0));\n\t\tdfs(cup,0,pair<int,int>(1,2));\n\t\tdfs(cup,0,pair<int,int>(2,1));\n\t\t*/\n\t\tbfs(cup,0,1);\n\t\tif(ans!=INF)bfs(cup,1,0);\n\t\tif(ans!=INF)bfs(cup,1,2);\n\t\tif(ans!=INF)bfs(cup,2,1);\n\t\t//cout << pow3[n] << endl;\n\t\t//cout << ans << endl;\n\t\tif(ans!=INF)ans=min(ans,pow3[n]-ans);\n\t\tif(ans!=INF) cout << ans << endl;\n\t\telse cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <fstream>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <limits>\n//#include <boost/multiprecision/cpp_int.hpp>\n\nconst double EPS = (1e-10);\n\n\nusing namespace std;\nusing Int = long long;\n//using namespace boost::multiprecision;\n\nconst Int MOD = 1000000007;\n\nInt mod_pow(Int x, Int n) {\n    Int res = 1;\n    while(n > 0) {\n        if(n & 1) res = (res * x) % MOD; //ビット演算(最下位ビットが1のとき)\n        x = (x * x) % MOD;\n        n >>= 1; //右シフト(n = n >> 1)\n    }\n    return res;\n}\n\nint Dist[16];\nint N, M;\nint crt;\nInt calc(int cup){\n    //N個のコップを0 -> 2 または 2 -> 0と動かすのに必要な手数をF(N)とする。\n    //F(N) = 3*F(N-1)+2\n    //F(N)+1 = 3*F(N-1)+3\n    //F(N)+1 = 3*(F(N-1)+1)\n    //F(N)+1 = 3^(N-1)*(2+1)\n    //F(N) = 3^N-1\n    \n    Int ret = 0;\n\n    int move_dist = abs(Dist[cup] - crt);\n    if (move_dist == 1){\n        ret = 1;\n        for (int i = 0; i < (N-cup); i++){\n            ret *= 3LL;\n        }\n        crt = 2 - crt;    \n    }else if(move_dist == 2){\n        ret = 1;\n        for (int i = 0; i < (N-cup); i++){\n            ret *= 3LL;\n        }\n        ret--;\n        ret *= 2;\n        ret += 2;\n    }\n    return ret;\n}\n\nint solve(){\n    cin >> N >> M;\n    if (!N && !M) return 0;\n    for (int i = 0; i < 3; i++){\n        int n; cin >> n;\n        for (int j = 0; j < n; j++){\n            int cup; cin >> cup;\n            Dist[cup] = i;\n        }\n    }\n\n    crt = 0;\n    Int ans[2] = {0}; \n    for (int i = 1; i <= N; i++){\n        ans[0] += calc(i);\n    }\n    crt = 2;\n    for (int i = 1; i <= N; i++){\n        ans[1] += calc(i);\n    }\n    if (min(ans[0], ans[1]) > M) ans[0] = -1;\n    cout << min(ans[0], ans[1]) << endl;\n    return 1;\n}\n\n\nint main(){\n    cin.tie(0);\n    while (solve());\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define MAX 14348907\n#define INF  (1e9) \nint ans[ MAX ];\nint t[16],n,m;\n\nvoid make_table(){\n  queue<int> Q;\n  for(int i=0;i<MAX;i++)ans[i]=INF;\n  ans[0]=0;\n  Q.push(0);\n  while(!Q.empty()){\n    int s=Q.front();Q.pop();\n    int u[3]={0};\n    int a,ns;\n    for(int i=14;i>=0;i--){\n      a= s/t[i]%3;\n      u[a]=max(u[a],i);\n    }\n    ns=s;\n    //0 to 1\n    if(u[0]>u[1]){\n      ns= s + t[ u[0] ];\n      if(ans[ns]==INF){\n\tans[ns]=ans[s]+1;\n\tQ.push(ns);\n      }\n    }\n    //1 to 0\n    if(u[1]>u[0]){\n      ns= s - t[ u[1] ];\n      if(ans[ns]==INF){\n\tans[ns]=ans[s]+1;\n\tQ.push(ns);\n      }\n    }\n    //1 to 2\n    if(u[1]>u[2]){\n      ns= s + t[ u[1] ];\n      if(ans[ns]==INF){\n\tans[ns]=ans[s]+1;\n\tQ.push(ns);\n      }\n    }\n    //2 to 1\n    if(u[2]>u[1]){\n      ns= s - t[ u[2] ];\n      if(ans[ns]==INF){\n\tans[ns]=ans[s]+1;\n\tQ.push(ns);\n      }\n    }\n\n  }//while\n}\n\nvoid init(){\n  t[0]=1;\n  for(int i=1;i<=15;i++)t[i]=t[i-1]*3;\n}\nint main(){\n  init();\n  make_table();\n  int S,S2,a,b;\n  while(cin>>n>>m&&n&&m){\n    S=S2=0;\n    for(int i=0;i<3;i++){\n      cin>>a;\n      for(int j=0;j<a;j++){\n\tcin>>b;\n\tb=b+(14-n);\n\tS+= t[b]*i;\n\tS2 += t[b]*(2-i);\n      }\n    }\n    int X = min(ans[S],ans[S2]);\n    if(X<=m)cout<<X<<endl;\n    else cout<<\"-1\"<<endl;\n    /*\n    for(int i=0;i<15;i++){\n      cout<<S/t[i]%3<<' ';\n    }\n    cout<<\"  n=\"<<n<<endl;\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 3;\nconst int INF = 15000001;\n\nclass S{\npublic:\n  int t[N], cost;\n  S(int a = 0, int b = 0, int c = 0, int cost = 0) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n\nint n, m;\n//int ans;\n\nint calc(S s, int pres, int pret){\n  //if(ans <= s.cost) return INF;\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  if(s.cost >= m) return INF;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int j=0;j<N;j++){\n    for(int i=n-1;i>=0;i--){\n      if(s.t[j] & 1 << i){\n        tmp[j] = max(tmp[j], i);\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(i == pret && j == pres) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= (~(1 << tmp[i]));\n          t.t[j] |= (1 << tmp[i]);\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          //ans = min(ans, res);\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint solve(S s){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int j=0;j<N;j++){\n    for(int i=n-1;i>=0;i--){\n      if(s.t[j] & 1 << i){\n        tmp[j] = max(tmp[j], i);\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= (~(1 << tmp[i]));\n          t.t[j] |= (1 << tmp[i]);\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          //ans = min(ans, res);\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[N];\n    for(int i=0;i<N;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    //ans = INF;\n    cout << solve(S(data[0], data[1], data[2], 0)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <hash_map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint bfs(int m,vector<int>& root, map<string,int> visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\t\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tchar buf[32];\n\t\t\t\tsprintf(buf,\"%09d%09d%09d\",tmp[0],tmp[1],tmp[2]);\n\t\t\t\tstring next;\n\t\t\t\tnext = buf;\n\t\t\t\tif(visited.find(next) == visited.end()){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tchar buf[32];\n\t\t\t\tsprintf(buf,\"%09d%09d%09d\",tmp[0],tmp[1],tmp[2]);\n\t\t\t\tstring next;\n\t\t\t\tnext = buf;\n\t\t\t\tif(visited.find(next) == visited.end()){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tmap<string,int> visited;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,sets,visited));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define INF 15\n#define A 0\n#define B 1\n#define C 2\n\nchar cond[INF];\nchar n;\nint  m;\nint sum;\n\nvoid move(int pos, char dist) {\n    char now = cond[pos];\n\n    if (now == dist) {\n        return;\n    } else if (abs(now-dist) == 2) {\n        move(pos, B);\n        move(pos, dist);\n    } else {\n        int i;\n        char no_present = (dist+now == 1)?C:\n                          (dist+now == 2)?B:\n                                          A;\n        for (i=1;pos+i < n;i++){\n            if (cond[pos+i] == dist || cond[pos+i] == now) {\n                move(pos+i, no_present);\n            }\n        }\n\n        cond[pos] = dist;\n        sum += 1;\n    }\n\n    return;\n}\n\nint main() {\n    while (1) {\n        int i;\n        char dist;\n        sum = 0;\n\n    \n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m ==0) {\n            break;\n        }\n\n        for (i=0;i < 3;i++) {\n            int j,k;\n\n            scanf(\"%d\", &k);\n            for (j=0;j < k;j++) {\n                int tmp;\n    \n                scanf(\"%d\", &tmp);\n                cond[tmp-1] = i;\n            }\n        }\n    \n        dist = (cond[0] != B)?cond[0]:A;\n    \n        for (i=0;i < n;i++) {\n            move(i, dist);\n        }\n    \n        if (sum <= m) {\n            printf(\"%d\\n\", sum);\n        } else {\n            printf(\"-1\\n\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<utility>\n#include<vector>\nusing namespace std;\nvoid input();\nvoid solve();\nvoid saiki(int,int,int,int);\nvoid narabi();\nint n,m,o,na,nb,nc,ans=0;\npair<int,int>at;\nint place=-1;\nint cup[3][10001]={0};\npair<int,int>maxi;\nint main(){\n    while(1){\n        cin>>n>>m;\n        if(n==0 && m==0)break;\n        input();\n        solve();\n        if(ans<m){\n            cout<<ans<<endl;\n        }\n        else{\n            cout<<-1<<endl;\n        }\n        ans=0;\n    }\n    return 0;\n}\nvoid saiki(int targetx,int targety,int tox,int toy){\n    if(cup[targetx][targety+1]!=0){\n        saiki(targetx,targety+1,tox,toy);\n    }\n    if(cup[tox][toy]>cup[targetx][targety]) {\n        int i=0,count=0;\n        while(1){\n            if(cup[1][i]!=0){\n                count++;\n            }\n            else break;\n            i++;\n        }\n        saiki(targetx,targety,1,count);\n    }\n    swap(cup[targetx][targety],cup[tox][toy]);\n    if(targetx>tox){\n        ans+=targetx-tox;\n    }\n    else{\n        ans+=tox-targetx;\n    }\n    return ;\n}\nvoid solve(){\n    bool bo;\n    //placeの確定\n    if(cup[0][0]==1){\n        place=0;\n    }\n    else if(cup[2][0]==1){\n        place=2;\n    }\n    else if(cup[0][0]==0){\n        place=0;\n    }\n    else if(cup[2][0]==0){\n        place=2;\n    }\n    else{\n        if(na>nc){\n            place=0;\n        }\n        else place=2;\n    }\n    int sp,u;\n    if(place==0){\n        sp=2;\n        u=nc;\n        }\n        else{\n            sp=0;\n            u=na;\n        }\n    while(1){\n    for(int target=1;target<=n;++target){\n        bo=false;\n        for(int i=0;i<3;++i){\n            for(int j=0;j<m;++j){\n                if(cup[i][j]==target){\n                   // cout<<i<<\" \"<<j<<endl;\n                    bo=true;\n                    at.first=i;\n                    at.second=j;\n                    break;\n                }\n            }\n            if(bo)break;\n        }\n        if(place==at.first)continue;\n        int i=0,count=0;\n        while(1){\n            if(cup[place][i]!=0)count++;\n            else break;\n            i++;\n        }\n        //cout<<at.first<<\" \"<<at.second<<\" \"<<place<<\" \"<<count<<endl;\n        saiki(at.first,at.second,place,count);\n    }\n        if(cup[1][0]==0&&cup[sp][0]==0)break;\n    }\n}\nvoid input(){\n    for(int i=0;i<3;++i){\n        for(int j=0;j<10001;++j){\n            cup[i][j]=0;\n        }\n    }\n    cin>>na;\n    for(int i=0;i<na;++i){\n        cin>>cup[0][i];\n    }\n    cin>>nb;\n    for(int i=0;i<nb;++i){\n        cin>>cup[1][i];\n    }\n    cin>>nc;\n    for(int i=0;i<nc;++i){\n        cin>>cup[2][i];\n    }\n    return ;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != -1 ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        {\n            int u = get_last(B);\n            int v = get_last(A);\n            if ( u > v ) {\n                int ret = solve( A | u, remove_last(B), C, turns + 1 );\n                if ( ret != -1 ) return ret;\n            }\n        }\n        {\n            int u = get_last(B);\n            int v = get_last(C);\n            if ( u > v ) {\n                int ret = solve( A, remove_last(B), C | u, turns + 1 );\n                if ( ret != -1 ) return ret;\n            }\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != -1 ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == -1 && ret2 == -1 ) {\n            cout << -1 << endl;\n        } else if ( ret1 != -1 && ret2 != -1 ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != -1 ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != -1 ) {\n            cout << ret2 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <ios>\n#include <iomanip>\n#include <algorithm>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define REP2(i, m, n) for (int i = (m); i < (int)(n); ++i)\n#define REPR(i, n) for (int i = (n)-1; i >= 0; --i)\n#define REPR2(i, m, n) for (int i = (n)-1; i >= (m); --i)\n#define REPx(x, a) for(auto x : a)\n#define ALL(a) a.begin(), a.end()\n#define SORT(a) sort(ALL(a))\n#define SORTR(a) sort(ALL(a), greater<int>())\n#define REVERSE(a) reverse(ALL(a))\n#define bit_search(bit, n) REP(bit, 1<<(n))\n#define bit_check(bit, i) ((bit>>(i)) & 1)\n#define setpre(n) fixed << setprecision((n))\n#define UNIQUE(a) do {SORT(a); (a).erase(unique(ALL(a)), (a).end());} while(0)\n#define MAX(a) *max_element(ALL(a))\n#define MIN(a) *min_element(ALL(a))\n#define bisect_left(a, x) lower_bound(ALL(a), (x)) - a.begin()\n#define bisect_right(a, x) upper_bound(ALL(a), (x)) - a.begin()\n#define INPUT(a) REP(i, a.size()) cin >> a[i];\n#define INPUTP(a) REP(i, a.size()) cin >> a[i].first >> a[i].second;\n#define OUTPUT_PERMUTATION(n) do{VI v(n); iota(ALL(v), 1); do{REPx(x, v) cout << x << \" \"; ENDL} while(next_permutation(ALL(v)));} while(0);\n#define MAKE_PERMUTATION(n) do{VVI a(fact(n), VI(n)); int idx = 0; VI v(n); iota(ALL(v), 1); do{REP(i, n) a[idx][i] = v[i]; idx++; PER = a;} while(next_permutation(ALL(v)));} while(0); // int fact(), VVI PERを宣言しておく\n#define ENDL cout << endl;\nusing namespace std;\nusing LL = long long;\nusing LD = long double;\nusing PII = pair<int, int>;\nusing VPII = vector<PII>;\nusing PLL = pair<LL, LL>;\nusing VPLL = vector<PLL>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VLL = vector<LL>;\nusing VVLL = vector<VLL>;\nusing VC = vector<char>;\nusing VS = vector<string>;\nusing VB = vector<bool>;\nusing VD = vector<double>;\nconst int INF = 1e9;\nconst LL MOD = 1e9 + 7;\n\ntemplate<class T> inline bool chmin(T &a, T b){if (a > b) {a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T &a, T b){if (a < b) {a = b; return true;} return false;}\n\nvoid END(){cout << 1 << endl; exit(0);}\n\nint n, m;\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(true)\n  {\n    cin >> n >> m;\n    if(n == 0 && m == 0) return 0;\n    vector<stack<int>> goal(3), tray1(3), tray2(3);\n    int ct = 0;\n    REP(i, 3)\n    {\n      int c;\n      cin >> c;\n      REP(j, c)\n      {\n        ct++;\n        tray1[0].push(ct);\n        tray2[2].push(ct);\n        int a;\n        cin >> a;\n        goal[i].push(a);\n      }\n    }\n    int ans = INF;\n    PII log = {-1, -1};\n    REP(i, m)\n    {\n      REP(j, 3)\n      {\n        if (tray1[j].empty()) continue;\n        bool flg = false;\n        int now = tray1[j].top();\n        for(int k = -1; k < 2; k += 2)\n        {\n          if (0 <= j+k && j+k < 3)\n          {\n            int before = log.first, cup = log.second;\n            if (cup == now && before == j+k) continue;\n            if (tray1[j+k].empty())\n            {\n              tray1[j+k].push(now);\n              tray1[j].pop();\n              flg = true;\n              log = {j, now};\n              break;\n            }\n            int next = tray1[j+k].top();\n            if (now > next)\n            {\n              tray1[j+k].push(now);\n              tray1[j].pop();\n              flg = true;\n              log = {j, now};\n              break;\n            }\n          }\n        }\n        if (flg) break;\n      }\n      if (tray1 == goal)\n      {\n        chmin(ans, i+1);\n        break;\n      }\n    }\n    log = {-1, -1};\n    REP(i, m)\n    {\n      REP(j, 3)\n      {\n        if (tray2[j].empty()) continue;\n        bool flg = false;\n        int now = tray2[j].top();\n        for(int k = -1; k < 2; k += 2)\n        {\n          if (0 <= j+k && j+k < 3)\n          {\n            int before = log.first, cup = log.second;\n            if (cup == now && before == j+k) continue;\n            if (tray2[j+k].empty())\n            {\n              tray2[j+k].push(now);\n              tray2[j].pop();\n              flg = true;\n              log = {j, now};\n              break;\n            }\n            int next = tray2[j+k].top();\n            if (now > next)\n            {\n              tray2[j+k].push(now);\n              tray2[j].pop();\n              flg = true;\n              log = {j, now};\n              break;\n            }\n          }\n        }\n        if (flg) break;\n      }\n      if (tray2 == goal)\n      {\n        chmin(ans, i+1);\n        break;\n      }\n    }\n    if (ans == INF) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int64_t i = 0; i < (n); i++)\n#define irep(i, n) for (int64_t i = 0; i <= (n); i++)\n#define rrep(i, n) for (int64_t i = (n)-1; i >= 0; i--)\n#define rirep(i, n) for (int64_t i = n; i >= 0; i--)\n\nusing S = int;\n\nint encode(int a, int c, int n)\n{\n    int b = ((1 << n) - 1) ^ (a | c);\n    int result = 0;\n    rrep(i, n)\n    {\n        result *= 3;\n        if ((c >> i) & 1) {\n            result += 2;\n        }\n        if ((b >> i) & 1) {\n            result += 1;\n        }\n        if ((a >> i) & 1) {\n            result += 0;\n        }\n    }\n    return result;\n}\n\ntuple<int, int, int> decode(int k, int n)\n{\n    int a, b, c;\n    a = b = c = 0;\n\n    rep(i, n)\n    {\n        int r = k % 3;\n        if (r == 2) {\n            c |= (1 << i);\n        }\n        if (r == 1) {\n            b |= (1 << i);\n        }\n        if (r == 0) {\n            a |= (1 << i);\n        }\n        k /= 3;\n    }\n\n    return make_tuple(a, b, c);\n}\n\nint msb(int x)\n{\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    return (x >> 1) + 1;\n}\n\nconst int SMAX = 14348907;\nint dist[SMAX];\n\nvoid solve(int n, int m)\n{\n    S sa = 0, sc = 0;\n    int an, bn, cn;\n    cin >> an;\n    rep(i, an)\n    {\n        int a;\n        cin >> a;\n        a--;\n        sa |= (1 << a);\n    }\n    cin >> bn;\n    rep(i, bn)\n    {\n        int b;\n        cin >> b;\n    }\n    cin >> cn;\n    rep(i, cn)\n    {\n        int c;\n        cin >> c;\n        c--;\n        sc |= (1 << c);\n    }\n\n    fill(dist, dist + SMAX, -1);\n    queue<S> q;\n    dist[encode(sa, sc, n)] = 0;\n    q.push(encode(sa, sc, n));\n\n    while (!q.empty()) {\n        int s = q.front();\n        q.pop();\n\n        int d = dist[s];\n        if (d >= m) {\n            break;\n        }\n\n        int a, b, c;\n        tie(a, b, c) = decode(s, n);\n\n        if (a > b) {\n            int na = a & ~msb(a), nb = b | msb(a), nc = c;\n            int key = encode(na, nc, n);\n            if (dist[key] < 0) {\n                dist[key] = d + 1;\n                q.push(key);\n            }\n        }\n        if (a < b) {\n            int na = a | msb(b), nb = b & ~msb(b), nc = c;\n            int key = encode(na, nc, n);\n            if (dist[key] < 0) {\n                dist[key] = d + 1;\n                q.push(key);\n            }\n        }\n        if (b > c) {\n            int na = a, nb = b & ~msb(b), nc = c | msb(b);\n            int key = encode(na, nc, n);\n            if (dist[key] < 0) {\n                dist[key] = d + 1;\n                q.push(key);\n            }\n        }\n        if (b < c) {\n            int na = a, nb = b | msb(c), nc = c & ~msb(c);\n            int key = encode(na, nc, n);\n            if (dist[key] < 0) {\n                dist[key] = d + 1;\n                q.push(key);\n            }\n        }\n    }\n\n    int e1 = encode((1 << n) - 1, 0, n), e2 = encode(0, (1 << n) - 1, n);\n    int result = m + 1;\n    if (dist[e1] >= 0) {\n        result = min(result, dist[e1]);\n    }\n    if (dist[e2] >= 0) {\n        result = min(result, dist[e2]);\n    }\n\n    cout << (result > m ? -1 : result) << endl;\n}\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    while (n != 0 || m != 0) {\n        solve(n, m);\n        cin >> n >> m;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\nconst int NONE = -1;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == NONE && ret2 == NONE ) {\n            cout << -1 << endl;\n        } else if ( ret1 != NONE && ret2 != NONE ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != NONE ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != NONE ) {\n            cout << ret2 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n\nint calc(vector<vector<int> > v, int n, int m) {\n\tint cnt = 0;\n\twhile(cnt <= m){\n\t\tint i = cnt % 2, j = i + 1;\n\t\tif(i % 2 == 0) {\n\t\t\tif(v[i].size() == n || v[i + 2].size() == n) {\n\t\t\t\treturn cnt;\n\t\t\t}\n\t\t} else {\n\t\t\tif(v[j].size() == n || v[2 - j].size() == n) {\n\t\t\t\treturn cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tauto it1 = v[i].end();\n\t\tauto it2 = v[j].end();\n\t\tif(v[i].empty()) {\n\t\t\tint y = *--it2;\n\t\t\tv[j].erase(it2);\n\t\t\tv[i].push_back(y);\n\t\t} else if(v[j].empty()) {\n\t\t\tint x = *--it1;\n\t\t\tv[i].erase(it1);\n\t\t\tv[j].push_back(x);\n\t\t} else {\n\t\t\tint x = *--it1, y = *--it2;\n\t\t\tif(x > y) {\n\t\t\t\tv[i].erase(it1);\t\n\t\t\t\tv[j].push_back(x);\n\t\t\t} else {\n\t\t\t\tv[j].erase(it2);\n\t\t\t\tv[i].push_back(y);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t}\n\treturn cnt;\n}\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m && (n || m)) {\n\t\tint c;\n\t\tvector<vector<int> >v(3);\n\t\trep(i,3) {\n\t\t\tcin >> c; \n\t\t\trep(j,c) {\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tv[i].push_back(t);\n\t\t\t}\n\t\t}\n\t\tint ans1 = calc(v, n, m);\n\t\tswap(v[0], v[2]);\n\t\tint ans2 = calc(v, n, m);\n\t\tint ans = min(ans1, ans2);\n\t\tif(ans <= m) {\n\t\t\tcout << ans;\n\t\t} else {\n\t\t\tcout << -1;\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <tr1/unordered_map>\nusing namespace std;\n\nint n;\n\nint goal = 0;\n\ntypedef int P ;\n\ntemplate <class K, class V>  \nclass hashMap {  \n    static const unsigned int DEFAULT_SIZE = 1003609;  \n    vector<pair<K, V> > *contents;  \n    unsigned int _size;  \n    unsigned int (*_hashValue) (K, unsigned int);  \n  \npublic:  \n    hashMap(unsigned int (*func) (K, unsigned int) , unsigned int size = DEFAULT_SIZE) {  \n        _hashValue = func;  \n        _size = size;  \n        contents = new vector<pair<K, V> > [_size];  \n    }  \n  \n    ~hashMap() {  \n        delete [] contents;  \n    }  \n  \n    bool hashElement(K s) {  \n        unsigned int h = _hashValue(s, _size);  \n  \n        for (int i = 0; i < (int)contents[h].size(); i++) {  \n            if (contents[h][i].first == s)  \n                return true;  \n        }  \n  \n        return false;  \n    }  \n  \n    void insert(K x, V n) {  \n        if (hashElement(x))  \n            return;  \n  \n        unsigned int h = _hashValue(x, _size);  \n        contents[h].push_back(make_pair(x, n));  \n    }  \n  \n    pair<K, V> *getElement(K x) {  \n        unsigned int h = _hashValue(x, _size);  \n        for (int i = 0; i < (int)contents[h].size(); i++)  \n            if (contents[h][i].first == x)  \n                return &contents[h][i];  \n  \n        return NULL;  \n    }  \n  \n    void printHashBalance() {  \n        int cnt = 0;  \n        double ret = 0.0;  \n        int worst = 0;  \n  \n        for (int i = 0; i < (int)_size; i++) {  \n            if (contents[i].size()) {  \n                ++cnt;  \n                ret += contents[i].size();  \n                worst = max<int>(worst, contents[i].size());  \n            }  \n        }  \n  \n        if (!cnt)  \n            cerr << \"Hash is empty\" << endl;  \n        else {  \n            cerr << \"collisions occurred(average): \" << (ret/cnt) << endl;  \n            cerr << \"collisions occurred(worst): \" << worst << endl;  \n        }  \n    }  \n};  \n\nunsigned int f(int n,unsigned int size){\n\treturn n%1003609;\n}\nP Q[30];\nint m,stat,tim,head,size,i,t,a,j,from,to,next;\n\nint main(){\n\twhile(cin >> n >> m && n){\n\t\thashMap<int,int> done(&f);\n\t\tint init = 0;\n\t\tfor(i = 0 ; i < n ; i++) goal |= 2 << (i*2);\n\t\t\n\t\tfor(i = 0 ; i < 3 ; i++){\n\t\t\tt,a; cin >> t;\n\t\t\twhile(t--){cin >> a; a--; init |= (i) << (2*a); }\n\t\t}\n\t\thead = 0 , size = 0;\n\t\tQ[size++] = init;\n\t\tdone.insert(init,0);\n\t\tint hoge = 0;\n\t\twhile(head != size){\n\t\t\thoge++;\n\t\t\tstat = Q[head++];\n\t\t\ttim = (*done.getElement(stat)).second;\n\t\t\tif(tim > m) break;\n\t\t\tif(stat == goal || stat == 0){ cout << tim << endl; goto hoge;}\n\t\t\tint mi[3] = {-1,-1,-1};\n\t\t\tfor(i = n-1 ; i >= 0 ; i--){\n\t\t\t\tint num = stat>>(i*2)&3;\n\t\t\t\tif(mi[num]==-1)mi[num] = i;\n\t\t\t}\n\t\t\t\n\t\t\tfor(from = 0 ; from < 3 ; from++){\n\t\t\t\tfor(to = 0 ; to < 3 ; to++){\n\t\t\t\t\tif ( !( (from == 0 && to == 2) || (from == 2 && to == 0) ) && from != to && mi[from] != -1 && (mi[to] == -1 || mi[from] > mi[to]) ){\n\t\t\t\t\t\tnext = (stat & ~(3<<(2*mi[from]))) | (to<<(2*mi[from]));\n\t\t\t\t\t\tif(done.getElement(next)==NULL)Q[size++] = next , done.insert(next,tim+1);\n\t\t\t\t\t\thead %= 30;\n\t\t\t\t\t\tsize %= 30;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\thoge:;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 3;\nconst int INF = 15000001;\n\nclass S{\npublic:\n  int t[N], cost;\n  S(){}\n  S(int a, int b, int c, int cost) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n\nint n, m, ans;\n\nint calc(S s, int pres, int pret){\n  if(ans <= s.cost) return INF;\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  if(s.cost == m) return INF;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<N;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(i == pret && j == pres) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          ans = min(ans, res);\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint solve(S s){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<N;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          ans = min(ans, res);\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[N];\n    for(int i=0;i<N;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    ans = INF;\n    cout << solve(S(data[0], data[1], data[2], 0)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nP mp[]={P(0,1),P(1,2),P(1,0),P(2,1)};\nint N,M;\nvoid printst(stack<int> st[3]){\n  puts(\"print\");\n  for(int i=0;i<3;i++){\n    if(st[i].empty()) printf(\"no\\n\");\n    else printf(\"%d\\n\",st[i].top());\n  }\n}\nint solve(stack<int> st[3],P p,int id){\n  int pr = p.F, ne = p.S;\n  st[ne].push( st[pr].top() );\n  st[pr].pop();\n  int co=1;\n  for(int i=co;i<=M;i++){\n    //    printf(\"%d番目\\n\",i);\n    //  printst(st);\n    if(st[0].size() == N  || st[2].size() == N ) break;\n    for(int j=0;j<4;j++){\n      if(j==(id+2)%4) continue;\n      pr=mp[j].F; ne=mp[j].S;\n      if(st[pr].empty()) continue;\n      bool f=false;\n      if(st[ne].empty()) f=true;\n      else if(st[pr].top() > st[ne].top()) f=true;\n      if(f){\n\tst[ne].push( st[pr].top() );\n\tst[pr].pop();\n\tid = j;\n\tbreak;\n      }\n    }\n      co++;\n  }\n  return co;\n}\nint main(){\n  while(1){\n    scanf(\"%d %d\",&N,&M);\n    if(!N && !M) break;\n    stack<int> st[3];\n    vector<int> sta[3];\n    for(int i=0;i<3;i++){\n      while(!st[i].empty()) st[i].pop();\n      sta[i].clear();\n    }\n    for(int i=0;i<3;i++){\n      int num;\n      scanf(\"%d\",&num);\n      for(int j=0;j<num;j++){\n\tint a;\n\tscanf(\"%d\",&a);\n\tst[i].push(a);\n\tsta[i].push_back(a);\n      }\n    }\n    //    printst(st);\n    if(st[0].size() == N  || st[2].size() == N ){\n      printf(\"0\\n\");\n      continue;\n    }\n    int res = M+1;\n    for(int i=0;i<4;i++){\n      //   printst(st);\n      int pr=mp[i].F; int ne=mp[i].S;\n      bool f=false;\n      if(st[pr].empty()) continue;\n      if(st[ne].empty()) f=true;\n      else if(st[pr].top() > st[ne].top()) f=true;\n      if(f)\n\tres = min(res,solve(st,mp[i],i));\n      //      printf(\"%d  %d\\n\",i,res);\n      for(int j=0;j<3;j++){\n\twhile(!st[j].empty()) st[j].pop();\n\tfor(int k=0;k<(int)sta[j].size();k++){\n\t  st[j].push( sta[j][k] );\n\t}\n      }\n    }\n    if(res == M+1) printf(\"-1\\n\");\n    else printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nclass S{\npublic:\n  int t[3], cost;\n  S(){}\n  S(int a, int b, int c, int cost) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n\nint n, m;\n\nint calc(S s, int pres, int pret){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  if(s.cost == m) return INF;\n  int res = INF;\n  int tmp[3];\n  fill(tmp, tmp+3, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<3;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      if(abs(i-j) != 1) continue;\n      if(i == pret && j == pres) continue;\n      if(tmp[i] > tmp[j]){\n        S t = s;\n        t.t[i] &= ~(1 << tmp[i]);\n        t.t[j] |= 1 << tmp[i];\n        t.cost++;\n        res = min(res, calc(t, i, j));\n      }\n    }\n  }\n  return res;\n}\n\nint solve(S s){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  int res = INF;\n  int tmp[3];\n  fill(tmp, tmp+3, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<3;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<3;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<3;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[3];\n    for(int i=0;i<3;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    cout << solve(S(data[0], data[1], data[2], 0)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint T[16];\nint A[16], B[16];\nint n, m;\n\nint solve() {\n    int P[17];\n    P[n-1] = 2;\n    for ( int i = n-1; i > 0; -- i ) P[i-1] = 3 * P[i] + 2;\n    \n    A[n-1] = T[n-1];\n    B[n-1] = 2 - T[n-1];\n    for ( int i = n; i > 0; -- i ) {\n        if ( T[i-2] == 0 ) {\n            A[i-2] = A[i-1];\n            B[i-2] = A[i-1] + 2 * P[i-1] + 2;\n        } else if ( T[i-2] == 1 ) {\n            A[i-2] = B[i-1] + P[i-1] + 1;\n            B[i-2] = A[i-1] + P[i-1] + 1;\n        } else {\n            A[i-2] = A[i-1] + 2 * P[i-1] + 2;\n            B[i-2] = B[i-1];\n        }\n    }\n    int res = min( A[0], B[0] );\n    if ( res > m ) return -1;\n    return res;\n}\n\nint main() {\n    while ( cin >> n >> m && n ) {\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t --;\n                T[t] = i;\n            }\n        }\n\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\n\nvector<int> rui={1,3,9,27,81,243,729,2187,6561,19683,59049,\n                 177147,531441,1594323,4782969,14348907\n                };\n\nint main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(n==0&&m==0) break;\n    \n    int bit=0;\n    rep(i,3){\n      int x;\n      cin>>x;\n      rep(j,x){\n        int y;\n        cin>>y;\n        y--;\n        bit+=rui[y]*i;\n      }\n    }\n    vector<int> seen(14348907,-1);\n    seen[bit]=0;\n    queue<int> que;\n    que.push(bit);\n    \n    while(!que.empty()&&seen[0]==-1&&seen[rui[n]-1]==-1){\n      int x=que.front();\n      que.pop();\n      \n      vector<set<int>> ue(3);   \n      rep(i,3) ue[i].insert(-1);\n      int cx=x;\n      rep(i,n){\n        ue[cx%3].insert(i);\n        cx/=3;\n      }\n      \n      int a=*ue[0].rbegin();\n      int b=*ue[1].rbegin();\n      int c=*ue[2].rbegin();\n\n      if(a>b){\n        if(seen[x+rui[a]]==-1){\n          que.push(x+rui[a]);\n          seen[x+rui[a]]=seen[x]+1;\n          ue[0].erase(a);\n          ue[1].insert(a);\n        }\n      }\n      if(a<b){\n        if(seen[x-rui[b]]==-1){\n          que.push(x-rui[b]);\n          seen[x-rui[b]]=seen[x]+1;\n          ue[1].erase(b);\n          ue[0].insert(b);\n        }\n      }\n      if(b>c){\n        if(seen[x+rui[b]]==-1){\n          que.push(x+rui[b]);\n          seen[x+rui[b]]=seen[x]+1;\n          ue[1].erase(b);\n          ue[2].insert(b);\n        }\n      }\n      if(b<c){\n        if(seen[x-rui[c]]==-1){\n          que.push(x-rui[c]);\n          seen[x-rui[c]]=seen[x]+1;\n          ue[2].erase(c);\n          ue[1].insert(c);\n        }\n      }\n    }\n    if(seen[0]!=-1){\n      if(seen[0]<=m) cout<<seen[0]<<endl;\n      else cout<<-1<<endl;\n    }\n    else if(seen[rui[n]-1]!=-1){\n      if(seen[rui[n]-1]<=m) cout<<seen[rui[n]-1]<<endl;\n      else cout<<-1<<endl;\n    }\n    else cout<<-1<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\nset< vector< stack<int> > > s;\n\nll saiki(int n,vector< stack<int> > cup){\n    ll ret = 1000000000000;\n    if(s.find(cup) != s.end()) return 1000000000;\n    else s.insert(cup);\n    if(cup[1].size() == 0 && (cup[0].size() == 0||cup[2].size() == 0)){\n\treturn n;\n    }\n    REP(i,2){\n\tif(cup[i].size() > 0 && (cup[i+1].size() == 0 || cup[i].top() > cup[i+1].top())){\n\t    cup[i+1].push(cup[i].top());\n\t    cup[i].pop();\n\t    ret = min(ret,(saiki(n+1,cup)));\n\t    cup[i].push(cup[i+1].top());\n\t    cup[i+1].pop();\n\t}\n\tif(cup[i+1].size() > 0 && (cup[i].size() == 0 || cup[i].top() < cup[i+1].top())){\n\t    cup[i].push(cup[i+1].top());\n\t    cup[i+1].pop();\n\t    ret = min(ret,saiki(n+1,cup));\n\t    cup[i+1].push(cup[i].top());\n\t    cup[i].pop();\n\t}\n    }\n    return ret;\n}\n\nint main(){\n    while(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n == 0 && m == 0 ) break;\n//         s = set< vector< stack<int> > >();\n\tvector< stack<int> > cup(3);\n\tREP(i,3){\n\t    int t;\n\t    cin >> t;\n\t    REP(j,t){\n\t\tint temp;\n\t\tcin >> temp;\n\t\tcup[i].push(temp);\n\t    }\n\t}\n\tint ans = saiki(0,cup);\n\tif(ans > m) ans = -1;\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include <stack>\nusing namespace std;\n\n\n\nint main()\n{\n\tstack<int>a,b,c;\n\twhile(1)\n\t{\n\t\t\n\t\tint count=0,n,m,check;\n\t\tscanf(\"%d %d\",&n,&m);\n\n\t\tif(n==0 && m==0)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\tbreak;\n\t\t}\n\t\n\t\tint A,B,C,\n\t\t\tkari;\n\t\t\n\t\t/*エラー対策*/\n\t\ta.push(0);\n\t\tb.push(0);\n\t\tc.push(0);\n\n\t\tscanf(\"%d\",&A);\n\t\tfor(int i=0;i<A;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\ta.push(kari);\n\t\t}\n\n\t\tscanf(\"%d\",&B);\n\t\tfor(int i=0;i<B;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\tb.push(kari);\n\t\t}\n\t\n\t\tscanf(\"%d\",&C);\n\t\tfor(int i=0;i<C;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\tc.push(kari);\n\t\t}\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif(b.top()==0 && c.top()==0)\n\t\t\t\tbreak;\n\t\t\tif(a.top()<b.top() && a.top()<c.top()){\n\t\t\t\tkari=b.top();\n\t\t\t\ta.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b.top()<c.top() ){\n\t\t\t\tkari=c.top();\n\t\t\t\tb.push(kari);\n\t\t\t\tc.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b.top()<a.top()){\n\t\t\t\tkari=a.top();\n\t\t\t\tb.push(kari);\n\t\t\t\ta.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(c.top()<b.top() && a.top()!=b.top()-1){\n\t\t\t\tkari=b.top();\n\t\t\t\tc.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t}\n\t\t\telse{\n\t\t\t\tkari=b.top();\n\t\t\t\ta.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(count<m || count==m) printf(\"\\n%d\\n\",count);\n\t\telse printf(\"\\n%d\\n\",-1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nclass S{\npublic:\n  int t[3], cost;\n  S(){}\n  S(int a, int b, int c, int cost) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n\nint n, m, ans;\n\nint calc(S s, int pres, int pret){\n  if(ans <= s.cost) return INF;\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  if(s.cost == m) return INF;\n  int res = INF;\n  int tmp[3];\n  fill(tmp, tmp+3, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<3;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      if(abs(i-j) != 1) continue;\n      if(i == pret && j == pres) continue;\n      if(tmp[i] > tmp[j]){\n        S t = s;\n        t.t[i] &= ~(1 << tmp[i]);\n        t.t[j] |= 1 << tmp[i];\n        t.cost++;\n        res = min(res, calc(t, i, j));\n        ans = min(ans, res);\n      }\n    }\n  }\n  return res;\n}\n\nint solve(S s){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  int res = INF;\n  int tmp[3];\n  fill(tmp, tmp+3, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<3;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<3;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<3;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          ans = min(ans, res);\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[3];\n    for(int i=0;i<3;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    ans = INF;\n    cout << solve(S(data[0], data[1], data[2], 0)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint n, m;\nstruct puzzle {\n\tchar f[3][15], len[3];\n\tint cnt;\n};\nbool operator==(const puzzle&left, const puzzle&right) {\n\trep(i, 3) {\n\t\tif (strcmp(left.f[i], right.f[i]))return false;\n\t}\n\treturn true;\n}\nstruct GET {\n\tinline size_t operator()(const puzzle&p) const {\n\t\tsize_t cnt = 0;\n\t\trep(i, 3) {\n\t\t\thash<string>H;\n\t\t\tcnt += (i + 1)*H(p.f[i]);\n\t\t}\n\t\treturn cnt;\n\t}\n};\n\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tpuzzle in{};\n\t\trep(i, 3) {\n\t\t\tscanf(\"%hd\", &in.len[i]);\n\t\t\trep(j, in.len[i])scanf(\"%hd\", &in.f[i][j]);\n\t\t}\n\t\tabort();\n\t\tunordered_map<puzzle, bool, GET>mp;\n\t\tqueue<puzzle>que;\n\t\tmp[in] = true;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tpuzzle u = que.front(); que.pop();\n\t\t\tif (u.len[0] == n || u.len[2] == n) {\n\t\t\t\tprintf(\"%d\\n\", u.cnt);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (u.cnt >= m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tif (u.len[i] == 0)continue;\n\t\t\t\tif (u.len[j] > 0 && (u.f[i][u.len[i] - 1] < u.f[j][u.len[j] - 1]))\n\t\t\t\t\tcontinue;\n\t\t\t\tpuzzle v = u;\n\t\t\t\tv.len[i]--; v.len[j]++;\n\t\t\t\tswap(v.f[i][v.len[i]], v.f[j][v.len[j] - 1]);\n\t\t\t\tif (!mp[v]) {\n\t\t\t\t\tmp[v] = true;\n\t\t\t\t\tv.cnt++;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <fstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nstatic const double EPS = 1e-5;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nstatic const int MAX = 15000001;\nmap< vector<int>, int> memo;\nint n,m;\nint hanoi(stack<int> stqn[3], int phase){\n  int ret = MAX, tpr;\n  bool a=stqn[0].empty(), b=stqn[1].empty(), c=stqn[2].empty();\n  if(b && (a||c)) return phase;\n  if(phase==m) return -1;\n  stack<int> tmp[3];\n  vector<int> mem(15);\n  REP(i,15) mem[i]=-1;\n  REP(i,3) tmp[i]=stqn[i];\n  while(!tmp[0].empty()){\n    mem[tmp[0].top()] = 0;\n    tmp[0].pop();\n  }\n  while(!tmp[1].empty()){\n    mem[tmp[1].top()] = 1;\n    tmp[1].pop();\n  }\n  while(!tmp[2].empty()){\n    mem[tmp[2].top()] = 2;\n    tmp[2].pop();\n  }\n  if(memo.find(mem)!=memo.end() && memo[mem]<=phase) return -1;\n  memo[mem] = phase; \n  if(!a && (b||stqn[1].top()<stqn[0].top())){\n    REP(i,3) tmp[i]=stqn[i];\n    tmp[1].push(tmp[0].top());\n    tmp[0].pop();\n    if((tpr=hanoi(tmp, phase+1))!=-1){\n      ret = min(ret, tpr);\n    }\n  }\n  if(!b && (a||stqn[0].top()<stqn[1].top())){\n    REP(i,3) tmp[i]=stqn[i];\n    tmp[0].push(tmp[1].top());\n    tmp[1].pop();\n    if((tpr=hanoi(tmp, phase+1))!=-1){\n      ret = min(ret, tpr);\n    }\n  }\n  if(!b && (c||stqn[2].top()<stqn[1].top())){\n    REP(i,3) tmp[i]=stqn[i];\n    tmp[2].push(tmp[1].top());\n    tmp[1].pop();\n    if((tpr=hanoi(tmp, phase+1))!=-1){\n      ret = min(ret, tpr);\n    }\n  }\n  if(!c && (b||stqn[1].top()<stqn[2].top())){\n    REP(i,3) tmp[i]=stqn[i];\n    tmp[1].push(tmp[2].top());\n    tmp[2].pop();\n    if((tpr=hanoi(tmp, phase+1))!=-1){\n      ret = min(ret, tpr);\n    }\n  }\n  if(ret!=MAX) return ret;\n  else return -1;\n}\nint main(void){\n  while(cin>>n>>m){\n    stack<int> ini[3];\n    if(n==0) break;\n    REP(i,3){\n      int ko;\n      int tmp;\n      cin>>ko;\n      REP(j,ko){\n        cin>>tmp;\n        ini[i].push(tmp);\n      }\n    }\n    int ans = hanoi(ini, 0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\nusing namespace std;\n\nclass state{\npublic:\n  stack<int> tray[3];\n  int cnt;\n  int st;\n  state(stack<int> a, stack<int> b, stack<int> c, int cnt){\n    //tray = new stack<int>[3];\n    tray[0] = a;\n    tray[1] = b;\n    tray[2] = c;\n    this->cnt = cnt;\n  }\n\n  state(){\n    //tray = new stack<int>[3];\n    cnt = 0;\n    st = 0;\n  }\n\n  state(const state &ob){\n    //tray = new stack<int>[3];\n    for(int i=0; i<3; i++) tray[i] = ob.tray[i];\n    cnt = ob.cnt;\n    st = ob.st;\n  }\n\n  bool operator < (const state& s) const {\n    return st < s.st;\n  }\n\n  void init(){\n    for(int i=0; i<3; i++){\n      int n; cin >> n;\n      int cup;\n      for(int j=0; j<n; j++){\n        cin >> cup;\n        tray[i].push(cup);\n        st += i*my_pow(cup);\n      }\n    }\n  }\n\n  //i番目のトレイからj番目に移動できるかを返す\n  bool canChange(int i, int j){\n    int sizei=tray[i].size(), sizej=tray[j].size();\n    if(sizei==0) return false;\n    if(sizej==0) return true;\n\n    if(tray[i].top()>tray[j].top()) return true;\n    else return false;\n  }\n\n  //i番目のトレイのカップをj番目のトレイに入れ替えたstateを返す\n  state change(int i, int j){\n    state ex = state(tray[0], tray[1], tray[2], cnt+1);\n    int cup=ex.tray[i].top(); ex.tray[i].pop();\n    ex.tray[j].push(cup);\n\n    ex.st += (-i+j)*my_pow(cup);\n\n    return ex;\n  }\nprivate:\n  //return pow(3, n)\n  int my_pow(int n){\n    int ans=1;\n    for(int i=0; i<n; i++) ans *= 3;\n    return ans;\n  }\n};\n\nint solve(int, int, state);\n\nint main(){\n  int n, m; //カップ数 手数\n  while(cin >> n >> m, n!=0 && m!=0){\n    state first;\n    first.init();\n    int dis=solve(n, m, first);\n    cout << dis << endl;\n  }\n\n  return 0;\n}\n\nint solve(int n, int m, state first){\n  queue<state> q;\n  q.push(first);\n  map<state, bool> mp;\n\n  int ans=-1;\n\n  while(!q.empty()){\n    state now = q.front(); q.pop();\n    //もし手数をオーバーしたなら、-1を格納して終了\n    if(now.cnt>m){\n      ans = -1;\n      break;\n    }\n\n    //もし条件を満たしているなら、手数を格納して終了\n    if(now.tray[0].size()==n || now.tray[2].size()==n){\n      ans = now.cnt;\n      break;\n    }\n\n    //隣り合う2つのカップで移動\n    for(int i=0; i<2; i++){\n      if(now.canChange(i, i+1)) {\n        state next = now.change(i, i+1);\n        //もし調査済みならcontinue\n        if(mp[next]) continue;\n        mp[next] = true;\n        q.push(next);\n      }\n      if(now.canChange(i+1, i)){\n        state next = now.change(i+1, i);\n        //もし調査済みならcontinue\n        if(mp[next]) continue;\n        mp[next] = true;\n        q.push(next);\n      }\n    }\n  }\n\n  return ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#define INF 1000000000\nusing namespace std;\nint N,M;\nint po3[20];\nint ary[20000000][2],res[20000000];\n\nvoid pow3(){\n\tint tmpo=1;\n\tfor(int i=0;i<20;i++){\n\t\tpo3[i]=tmpo;\n\t\ttmpo*=3;\n\t}\n}\n\nvoid solv(int m){\n\tint abc[3]={-1,-1,-1},re[2];\n\tint tmp;\n\tfor(int i=0;i<N;i++){\n\t\ttmp=(m/po3[i])%3;\n\t\tabc[tmp]=max(abc[tmp],i);\n\t}\n\tre[0]=re[1]=m;\n\tif(abc[0]>abc[1]){\n\t\tif(abc[0]>=0)re[0]=m+po3[abc[0]];\n\t}\n\telse{\n\t\tif(abc[1]>=0)re[0]=m-po3[abc[1]];\n\t}\n\tif(abc[1]>abc[2]){\n\t\tif(abc[1]>=0)re[1]=m+po3[abc[1]];\n\t}\n\telse{\n\t\tif(abc[2]>=0)re[1]=m-po3[abc[2]];\n\t}\n\tary[m][0]=re[0];\n\tary[m][1]=re[1];\n}\n\nint main(){\n\tpow3();\n\tint hog,piy,cnt,tmp,ress;\n\tqueue<int> que;\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\t\tfor(int i=0;i<po3[N];i++){\n\t\t\tary[i][0]=ary[i][1]=0;\n\t\t\tsolv(i);\n\t\t}\n\t\tfill(res,res+20000000,INF);\n\t\tcnt=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>hog;\n\t\t\tfor(int j=0;j<hog;j++){\n\t\t\t\tcin>>piy;piy--;\n\t\t\t\tcnt+=po3[piy]*i;\n\t\t\t}\n\t\t}\n\n\t\tress=INF;\n\t\twhile(!que.empty()) que.pop();\n\t\tque.push(cnt);\n\t\tres[cnt]=0;\n\t\twhile(!que.empty()){\n\t\t\ttmp=que.front();que.pop();\n\t\t\tif(tmp==0||tmp==po3[N]-1||res[tmp]>M){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(res[ary[tmp][0]]>res[tmp]+1){\n\t\t\t\tres[ary[tmp][0]]=res[tmp]+1;\n\t\t\t\tque.push(ary[tmp][0]);\n\t\t\t}\n\t\t\tif(res[ary[tmp][1]]>res[tmp]+1){\n\t\t\t\tres[ary[tmp][1]]=res[tmp]+1;\n\t\t\t\tque.push(ary[tmp][1]);\n\t\t\t}\n\t\t}\n\t\tress=min(ress,min(res[0],res[po3[N]-1]));\n\t\tif(ress<=M)cout<<ress<<endl;\n\t\telse cout<<-1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint calc(vector<int> cup, int m)\n{\n    int cnt = 0;\n    while (1) {\n        int i = cnt%2, j = i+1;\n        int p = 1;\n        while (p <= max(cup[i], cup[j])) p <<= 1;\n        p >>= 1;\n        if (!p) break;\n        cup[i] ^= p;\n        cup[j] ^= p;\n        cnt++;\n        if (cnt > m) return cnt;\n    }\n\n    return cnt;\n}\n\nint main()\n{\n    while (1) {\n        int n, m; cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        vector<int> cup(3);\n        loop (3, i) {\n            int c; cin >> c;\n            while (c--) {\n                int v; cin >> v;\n                cup[i] |= 1 << v--;\n            }\n        }\n        int ans = calc(cup, m);\n        swap(cup[0], cup[2]);\n        ans = min(ans, calc(cup, m));\n        cout << (ans <= m ? ans : -1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nint dp[14400000];\nint N, M;\nint to_hash(const vector<int>&nums) {\n\tint hash = 0;\n\tfor (auto n : nums) {\n\t\thash = 3 * hash + n;\n\t}\n\treturn hash;\n}\nint getans(vector<int>&nums, int now) {\n\tint hash = to_hash(nums);\n\tif (dp[hash] == -2) {\n\t\treturn M;\n\t}\n\tif (dp[hash] == -1) {\n\t\tif (now >= M)return M;\n\t\tif (to_hash(nums) == 0) {\n\t\t\treturn now;\n\t\t}\n\t\telse {\n\t\t\tdp[hash] = -2;\n\t\t\tvector<int>tops(3, -1);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\ttops[nums[i]] = i;\n\t\t\t}\n\t\t\tint ans = M;\n\t\t\tif (tops[0] < tops[1]) {\n\t\t\t\tif (tops[1] != -1) {\n\t\t\t\t\tnums[tops[1]] = 0;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tops[0] != -1) {\n\t\t\t\t\tnums[tops[0]] = 1;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[0]] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tops[1] < tops[2]) {\n\t\t\t\tif (tops[2] != -1) {\n\t\t\t\t\tnums[tops[2]] = 1;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[2]] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tops[1] != -1) {\n\t\t\t\t\tnums[tops[1]] = 2;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[hash] = ans;\n\t\t}\n\t}\n\telse {\n\t\treturn dp[hash];\n\t}\n\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 14400000; ++i) {\n\t\t\tdp[i] = -1;\n\t\t} cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<int>nows(N);\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tfor (int j = 0; j < a; ++j) {\n\t\t\t\tint b; cin >> b; b--;\n\t\t\t\tnows[b] = i;\n\t\t\t}\n\t\t}\n\t\tint ans = getans(nows, 0);\n\t\tif (ans == M)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,m;\nint cup[3][16]={0},cupn[3];\nint ans=1000000000;\nint san;\nvoid hanoi(int nowm,int cmd){\n\n    /*\n    printf(\"[%d][%d][%d]\\n\",cupn[0],cupn[1],cupn[2]);\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            printf(\"%d\",cup[i][j]);\n        }\n        puts(\"\");\n    }\n    */\n\n\n    if(m<nowm)\n        goto P;\n    else if(cupn[0]==n||cupn[2]==n){\n        ans=min(ans,nowm);\n    }\n    if(cmd!=1&&cmd!=2&&cupn[0]!=0){\n        if(cup[0][cupn[0]]>cup[1][cupn[1]]){\n            cup[1][cupn[1]+1]=cup[0][cupn[0]],cup[0][cupn[0]]=0;\n            cupn[0]--,cupn[1]++;\n            hanoi(nowm+1,1);\n            cup[0][cupn[0]+1]=cup[1][cupn[1]],cup[1][cupn[1]]=0;\n            cupn[1]--,cupn[0]++;\n        }\n    }\n    if(cmd!=1&&cmd!=2&&cupn[1]!=0){\n        if(cup[0][cupn[0]]<cup[1][cupn[1]]){\n            cup[0][cupn[0]+1]=cup[1][cupn[1]],cup[1][cupn[1]]=0;\n            cupn[1]--,cupn[0]++;\n            hanoi(nowm+1,2);\n            cup[1][cupn[1]+1]=cup[0][cupn[0]],cup[0][cupn[0]]=0;\n            cupn[0]--,cupn[1]++;\n        }\n    }\n    if(cmd!=3&&cmd!=4&&cupn[1]!=0){\n        if(cup[1][cupn[1]]>cup[2][cupn[2]]){\n            cup[2][cupn[2]+1]=cup[1][cupn[1]],cup[1][cupn[1]]=0;\n            cupn[1]--,cupn[2]++;\n            hanoi(nowm+1,3);\n            cup[1][cupn[1]+1]=cup[2][cupn[2]],cup[2][cupn[2]]=0;\n            cupn[1]++,cupn[2]--;\n        }\n    }\n    if(cmd!=3&&cmd!=4&&cupn[2]!=0){\n        if(cup[1][cupn[1]]<cup[2][cupn[2]]){\n            cup[1][cupn[1]+1]=cup[2][cupn[2]],cup[2][cupn[2]]=0;\n            cupn[1]++,cupn[2]--;\n            hanoi(nowm+1,4);\n            cup[2][cupn[2]+1]=cup[1][cupn[1]],cup[1][cupn[1]]=0;\n            cupn[1]--,cupn[2]++;\n        }\n    }\nP:\n    printf(\"\");\n}\nint main(){\n    while(1){\n        for(int i=0;i<3;i++){\n            for(int j=0;j<16;j++)\n                cup[i][j]=0;\n        }\n        ans=1000000000;\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0)\n            break;\n        for(int i=0;i<3;i++){\n            scanf(\"%d\",&cupn[i]);\n            for(int j=1;j<=cupn[i];j++)\n                scanf(\"%d\",&cup[i][j]);\n        }\n        hanoi(0,0);\n        if(ans==1000000000)\n            ans=-1;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <utility>\n#include <tuple>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#define rep(i, n) for(int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nint main() {\n  int n, m;\n  while(cin >> n >> m && (n || m)) {\n    string beg(n, ' ');\n    rep(i, 3) {\n      int num;\n      cin >> num;\n      rep(j, num) {\n        int tmp;\n        cin >> tmp;\n        beg[--tmp] = i+'0';\n      }\n    }\n    queue<tuple<string, string, int>> que;\n    que.push(make_tuple(beg, \" \", 0));\n    const string ans0(n, '0'), ans2(n, '2');\n    while(true) {\n      string now, prev;\n      int num;\n      tie(now, prev, num) = que.front();\n      que.pop();\n      if(now == ans0 || now == ans2) {\n        if(num <= m)\n          cout << num << endl;\n        else\n          cout << -1 << endl;\n        break;\n      }\n      int top[3] = {-1, -1, -1};\n      rep(i, n)\n        top[now[i]-'0'] = i;\n      rep(i, 3) rep(j, 3) {\n        if(abs(i-j) > 1)\n          continue;\n        if(top[i] > top[j]) {\n          string next = now;\n          next[top[i]] = j+'0';\n          if(next != prev)\n            que.push(make_tuple(next, now, num+1));\n        }\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nint dp[10000000];\nint N, M;\nint to_hash(const vector<int>&nums) {\n\tint hash = 0;\n\tfor (auto n : nums) {\n\t\thash = 3 * hash + n;\n\t}\n\treturn hash;\n}\nint getans(vector<int>&nums, int now) {\n\tint hash = to_hash(nums);\n\tif (dp[hash] == -2) {\n\t\treturn M;\n\t}\n\tif (dp[hash] == -1) {\n\t\tif (now >= M)return M;\n\t\tif (to_hash(nums) == 0) {\n\t\t\treturn now;\n\t\t}\n\t\telse {\n\t\t\tdp[hash] = -2;\n\t\t\tvector<int>tops(3, -1);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\ttops[nums[i]] = i;\n\t\t\t}\n\t\t\tint ans = M;\n\t\t\tif (tops[0] < tops[1]) {\n\t\t\t\tif (tops[1] != -1) {\n\t\t\t\t\tnums[tops[1]] = 0;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tops[0] != -1) {\n\t\t\t\t\tnums[tops[0]] = 1;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[0]] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tops[1] < tops[2]) {\n\t\t\t\tif (tops[2] != -1) {\n\t\t\t\t\tnums[tops[2]] = 1;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[2]] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tops[1] != -1) {\n\t\t\t\t\tnums[tops[1]] = 2;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[hash] = ans;\n\t\t}\n\t}\n\telse {\n\t\treturn dp[hash];\n\t}\n\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 10000000; ++i) {\n\t\t\tdp[i] = -1;\n\t\t} cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<int>nows(N);\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tfor (int j = 0; j < a; ++j) {\n\t\t\t\tint b; cin >> b; b--;\n\t\t\t\tnows[b] = i;\n\t\t\t}\n\t\t}\n\t\tint ans = getans(nows, 0);\n\t\tif (ans == M)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\nconst int MAX = 14348907; // 3 ^ 15\n\nint N,M,init;\nbool memo[MAX];\nvector<int> v[3];\n\nstruct state{\n  int n,bit;\n  state(int n=0, int bit=init):n(n),bit(bit){}\n};\n\nint calcBit(int n, int pos){\n  return (int)pow(3,(double)pos) * n;\n}\n\nint calcN(int bit, int pos){\n  return (bit / (int)pow(3,(double)pos)) % 3;\n}\n\nvoid add(int &bit, int pos, int n){\n  bit -= calcBit(calcN(bit,pos), pos);\n  bit += calcBit(n, pos);\n}\n\nvoid bfs(){\n  queue<state> Q;\n  state u,v;\n  int max[3];\n  fill(memo,memo+MAX,false);\n  memo[init] = true;\n  for(Q.push(u); !Q.empty();){\n    u = Q.front();\n    Q.pop();\n\n    max[0] = max[1] = max[2] = -1;\n    for(int i=N-1;i>=0;i--){\n      if(max[calcN(u.bit,i)] == -1) max[calcN(u.bit,i)] = i;\n    }\n\n    if(max[1] == -1 && (max[0] == -1 || max[2] == -1)){\n      //for(int i=0;i<N;i++) cout << calcN(u.bit,i) << ' ';\n      cout << u.n << endl;\n      return;\n    }\n    if(u.n >= M) break;\n\n    if(max[0] > max[1]){\n      v = u;\n      add(v.bit, max[0], 1);\n      v.n++;\n      if(!memo[v.bit] ){\n\tmemo[v.bit] = true;\n\tQ.push(v);\n      }\n    }\n    if(max[1] > max[0]){\n      v = u;\n      add(v.bit, max[1], 0);\n      v.n++;\n      if(!memo[v.bit]){\n\tmemo[v.bit] = true;\n\tQ.push(v);\n      }\n    }\n    if(max[2] > max[1]){\n      v = u;\n      add(v.bit, max[2], 1);\n      v.n++;\n      if(!memo[v.bit]){\n\tmemo[v.bit] = true;\n\tQ.push(v);\n      }\n    }\n    if(max[1] > max[2]){\n      v = u;\n      add(v.bit, max[1], 2);\n      v.n++;\n      if(!memo[v.bit]){\n\tmemo[v.bit] = true;\n\tQ.push(v);\n      }\n    }\n  }\n  cout << -1 << endl;\n}\n\n\nint main(){\n  while(cin >> N >> M && (N|M)){\n    init = 0;\n    for(int i=0;i<3;i++){\n      int x;\n      cin >> x;\n      for(int j=0;j<x;j++){\n\tint c;\n\tcin >> c;\n\tc--;\n\tv[i].push_back(c);\n\tadd(init, c, i);\n      }\n    }\n    bfs();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint solve(int, int, int);\n\nint main(void){\n  int n,m,l;\n  while(cin >> n >> m, n != 0 && m != 0){\n    int ans = 0;\n    int a[3] = {0}, temp;\n    for(int i = 0; i < 3; i++){\n      cin >> l;\n      for(int j = 0; j < l; j++){\n\tcin >> temp;\n\ta[i] |= 1 << temp - 1;\n      }\n    }\n    ans = min(solve(a[0], a[1], a[2]), solve(a[2], a[1], a[0]));\n    if(ans > m)\n      cout << -1 << endl;\n    else\n      cout << ans << endl;\n  }\n  return 0;\n}\n\nint solve(int a, int b, int c){\n  if(c & 1) return solve(a >> 1, b >> 1, c >> 1);\n  if(b & 1) return solve(a >> 1, b >> 1, c >> 1) + 1 + solve((a|b|c) >> 1, 0, 0);\n  if(a & 1) return solve(a >> 1, b >> 1, c >> 1) + 2*solve((a|b|c) >> 1, 0, 0) + 2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n\nll Pow3T[16];\nll Pow3(int n)\n{\n    if (Pow3T[n] != 0) return Pow3T[n];\n    if (n == 0) return Pow3T[n]=1;\n    else if (n==1) return Pow3T[n]=3;\n    else if (n%2==0) {\n        ll Tmp = Pow3(n/2);\n        return Pow3T[n]=Tmp*Tmp;\n    } else {\n        return Pow3T[n]=3 * Pow3(n-1);\n    }\n}\n\nint main()\n{\n    while (1) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 && M == 0) break;\n        ll S = 0LL;\n        for (int i = 0; i < 3; ++i) {\n            int K;\n            cin >> K;\n            for (int k = 0; k < K; ++k) {\n                int P;\n                cin >> P;\n                --P;\n                S += i * Pow3(P);\n            }\n        }\n\n        vector<ll> D(Pow3(N), -1);\n        queue<ll> Q;\n        Q.push(S);\n        D[S] = 0;\n        int Res = -1;\n        while (!Q.empty()) {\n            ll Now = Q.front(); Q.pop();\n            vector<ll> vNext;\n\n            {\n                int k = N-1;\n                while (Now/Pow3(N-1) == (Now/Pow3(k))%3) {--k; if (k==-1) break;}\n                if (k == -1) {\n                    if (Now%3 == 1) ;\n                    else {\n                        Res = D[Now];\n                        break;\n                    }\n                }\n\n                ll Tmp = Now;\n                if (Now/Pow3(N-1) == 0) {\n                    Tmp = Now + Pow3(N-1);\n                    vNext.push_back(Tmp);\n                    if ((Now/Pow3(k))%3 == 1) {\n                        Tmp = Now + Pow3(k);\n                        vNext.push_back(Tmp);\n                    } else if ((Now/Pow3(k))%3 == 2) {\n                        Tmp = Now - Pow3(k);\n                        vNext.push_back(Tmp);\n                    }\n                }\n                if (Now/Pow3(N-1) == 1) {\n                    Tmp = Now - Pow3(N-1);\n                    vNext.push_back(Tmp);\n                    Tmp = Now + Pow3(N-1);\n                    vNext.push_back(Tmp);\n                }\n                if (Now/Pow3(N-1) == 2) {\n                    Tmp = Now - Pow3(N-1);\n                    vNext.push_back(Tmp);\n                    if ((Now/Pow3(k))%3 == 0) {\n                        Tmp = Now + Pow3(k);\n                        vNext.push_back(Tmp);\n                    } else if ((Now/Pow3(k))%3 == 1) {\n                        Tmp = Now - Pow3(k);\n                        vNext.push_back(Tmp);\n                    }\n                }\n\n                int d = D[Now] + 1;\n                if (d > M) continue;\n                for (int i = 0; i < vNext.size(); ++i) {\n                    ll TmpS = vNext[i];\n                    if (D[TmpS] == -1) {\n                        D[TmpS] = d;\n                        Q.push(TmpS);\n                    }\n                }\n            }\n        }\n        cout << Res << endl;\n    }\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n \nconst int N = 3;\nconst int INF = 15000001;\n \nclass S{\npublic:\n  int t[N], cost;\n  S(int a = 0, int b = 0, int c = 0, int cost = 0) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n \nint n, m;\n \nint calc(S s, int pres, int pret){\n  while(1){\n    if(s.cost > m) return INF;\n    if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n    int tmp[N];\n    fill(tmp, tmp+N, 0);\n    for(int j=0;j<N;j++){\n      for(int i=n-1;i>=0;i--){\n        if(s.t[j] & 1 << i){\n          tmp[j] = i+1;\n          break;\n        }\n      }\n    }\n    for(int i=0;i<N;i++){\n      if(tmp[i]){\n        for(int j=0;j<N;j++){\n          if(abs(i-j) != 1) continue;\n          if(i == pret && j == pres) continue;\n          if(tmp[i] > tmp[j]){\n            s.t[i] -= 1 << (tmp[i] - 1);\n            s.t[j] += 1 << (tmp[i] - 1);\n            s.cost++;\n            pres = i;\n            pret = j;\n            goto CONT;\n          }\n        }\n      }\n    }\n    CONT:;\n  }\n  return INF;\n}\n \nint solve(S s){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int j=0;j<N;j++){\n    for(int i=n-1;i>=0;i--){\n      if(s.t[j] & 1 << i){\n        tmp[j] = i+1;\n        break;\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i]){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= (~(1 << (tmp[i]-1)));\n          t.t[j] |= (1 << (tmp[i]-1));\n          t.cost++;\n          res = min(res, calc(t, i, j));\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n \n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[N];\n    for(int i=0;i<N;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    cout << solve(S(data[0], data[1], data[2], 0)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <iterator>\n#include <algorithm>\n\n#define MAX_N 15\n#define MAX_M 15000000\n\n\nstd::stack<int> trays[3];\nstd::stack<int> r_trays[3];\n\nvoid moveTop(int i, int j) {\n  // move top value i to j\n  trays[j].push(trays[i].top());\n  trays[i].pop();\n}\n\nvoid clearTray() {\n  for (int i = 0; i < 3; i ++) {\n    while(!trays[i].empty())\n      trays[i].pop();\n    while(!r_trays[i].empty())\n      r_trays[i].pop();\n  }\n}\n\nbool isEmpty() {\n  if((trays[0].empty() && trays[1].empty()) || (trays[1].empty() && trays[2].empty()))\n    return true;\n  else\n    return false;\n}\n\nint moveCups(int m) {\n  int move = 0;\n  bool flag = true;\n\n  if (isEmpty())\n    return 0;\n\n  while(flag) {\n    for (int i = 0; i < 2; i ++) { \n      move ++;\n      // move bigger cup\n      if (trays[i + 1].empty() || (!trays[i].empty() && trays[i].top() > trays[i + 1].top())) {\n        moveTop(i, i + 1); \n      } else {\n        moveTop(i + 1, i);\n      }\n      // check situation\n      if (isEmpty()) {\n        flag = false;\n        break;\n      } else if (move >= m) {\n        flag = false;\n        move = -1;\n        break;\n      }\n    }\n  }\n  return move;\n}\n\nint main() {\n  int n, m;\n  int num, temp, move, left, right;\n  bool flag = true;\n  while (1) {\n    std::cin >> n >> m;\n    if (n == 0)\n      break;\n    // store cups to trays.\n    for (int i = 0; i < 3; i ++) {\n      std::cin >> num;\n      for (int j = 0; j < num; j ++) {\n        std::cin >> temp;\n        trays[i].push(temp);\n      }\n      r_trays[2 - i] = trays[i];\n    }\n    std::reverse(std::begin(r_trays), std::end(r_trays));\n    right = moveCups(m);\n    for (int i = 0; i < 3; i ++)\n      trays[i].swap(r_trays[2 - i]);\n    left = moveCups(m);\n\n    std::cout << (right > left ? right : left) << std::endl;\n    clearTray();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\ntypedef std::stack<int> Tray;\n\nbool moveNtoN(Tray tr[], int src, int dst){\n    if((tr[src]).empty() ||\n        !(tr[dst]).empty() && (tr[src]).top() < (tr[dst]).top()){\n        return false;\n    }\n    (tr[dst]).push((tr[src]).top());\n    (tr[src]).pop();\n    return true;\n}\n\nbool ifSorted(Tray tr[]){\n    return ((tr[1]).empty() && ((tr[0]).empty() || (tr[2].empty())));\n}\n\nint solve(Tray argTr[], int m){\n    if(ifSorted(argTr)){\n        return 0;\n    }\n    Tray tr[3];\n    int lastMove;          // 0 : A->B, 1 : B->A, 2 : B->C, 3 : C->B\n    for(int j = 0; j < 2; j++){\n        tr[0] = argTr[0];\n        tr[1] = argTr[1];\n        tr[2] = argTr[2];\n        lastMove = -1;\n        if(j == 0){\n            if(moveNtoN(tr, 0, 1)){ \n                lastMove = 0;\n            }\n            else if(moveNtoN(tr, 1, 0)){\n                lastMove = 1;\n            }\n        }\n        else {\n            if(moveNtoN(tr, 1, 2)){\n                lastMove = 2;\n            }\n            else if(moveNtoN(tr, 2, 1)){\n                lastMove = 3;\n            }\n        }\n        for(int i = 1; i < m; i++){\n            if(ifSorted(tr)){\n                return i;\n            }\n            if(lastMove != 1 && moveNtoN(tr, 0, 1)){\n                lastMove = 0;\n            }\n            else if(lastMove != 0  && moveNtoN(tr, 1, 0)){\n                lastMove = 1;\n            }\n            else if(lastMove != 3 && moveNtoN(tr, 1, 2)){\n                lastMove = 2;\n            }\n            else if(lastMove != 2 && moveNtoN(tr, 2, 1)){\n                lastMove = 3;\n            }\n        }\n        if(ifSorted(tr)){\n            return m;\n        }\n    }\n    return -1;\n}\n\nint main(){\n    int n, m;\n    while(1){\n        std::cin >> n >> m;\n        if(!(n || m)){\n            break;\n        }\n        Tray trays[3];\n        for(int col = 0; col < 3; col++){\n            int nCups;                     // #cups on the line\n            std::cin >> nCups;\n            while(nCups--){\n                int cup;\n                std::cin >> cup;\n                (trays[col]).push(cup);\n            }\n        }\n        std::cout << solve(trays, m) << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdlib.h>\n#include<cstdio>\n#include<unordered_map>\n#include<unordered_set>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<stack>\n#include<map>\n#include<string.h>\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nsigned main() {\n\tvector<int>O;\n\tO.push_back(1); O.push_back(2); O.push_back(3);\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tint sum[2]{}; int S = 0;\n\t\tvector<int>V[3];\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tint d; cin >> d;\n\t\t\tfor (int e = 0; e < d; e++) {\n\t\t\t\tint c; cin >> c;\n\t\t\t\tV[i].push_back(c);\n\t\t\t}\n\t\t}\n\t\tint x = 0, y = 0;//???????????????\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tvector<int>q = V[0], w = V[1], p = V[2];\n\t\t\t\tif (abs(i - j) == 1) {\n\t\t\t\t\tif (V[i].size() && (V[j].size() == 0 || *V[i].rbegin() > *V[j].rbegin())) {\n\t\t\t\t\t\tfor (int K = 0; K <= b; K++) {\n\t\t\t\t\t\t\tif (V[1].size() == 0 && (V[0].size() == 0 || V[2].size() == 0))break;\n\t\t\t\t\t\t\tsum[S]++;\n\t\t\t\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\t\t\t\tif (abs(i - j) == 1) {\n\t\t\t\t\t\t\t\t\t\tif (V[i].size() && (V[j].size() == 0 || *V[i].rbegin() > *V[j].rbegin())) {\n\t\t\t\t\t\t\t\t\t\t\tif (y != i || x != j) {\n\t\t\t\t\t\t\t\t\t\t\t\tV[j].push_back(*V[i].rbegin());\n\t\t\t\t\t\t\t\t\t\t\t\tV[i].pop_back();\n\t\t\t\t\t\t\t\t\t\t\t\tx = i; y = j;\n\t\t\t\t\t\t\t\t\t\t\t\tgoto l;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tl:;\n\t\t\t\t\t\t\tif (K == b)sum[S] = 1 << 29;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tS++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tV[0] = q; V[1] = w; V[2] = p;\n\t\t\t}\n\t\t}\n\t\tint MIN = min(sum[0], sum[1]);\n\t\tif (MIN == 1 << 29)puts(\"-1\");\n\t\telse cout << MIN << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\ntypedef long long ll;\n\nstruct Cups{\n\tstd::vector<int> S[3];\n\tint t, prev_from, prev_to;\n\tCups(const std::vector<int> (&_S)[3], int _t, int _from, int _to)\n\t\t:t(_t), prev_from(_from), prev_to(_to)\n\t{\n\t\tfor(int i=0;i<3;i++){\n\t\t\tS[i] = _S[i];\n\t\t}\n\t}\n};\n\nint main(){\n\tint n, m;\n\twhile(std::cin >> n >> m, n){\n\t\tstd::vector<int> S[3];\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint SN;\n\t\t\tstd::cin >> SN;\n\t\t\tfor(int j=0;j<SN;j++){\n\t\t\t\tint e;\n\t\t\t\tstd::cin >> e;\n\t\t\t\tS[i].push_back(e-1);\n\t\t\t}\n\t\t\tstd::sort(S[i].begin(), S[i].end(), std::greater<int>());\n\t\t}\n\n\t\tstd::queue<Cups> q;\n\t\tq.push(Cups(S, 0, -1, -1));\n\t\n\t\tint res = -1;\n\t\twhile(!q.empty()){\n\t\t\tCups c = q.front();q.pop();\n\t\t\tstd::vector<int> S[3] = c.S;\n\t\t\tint t = c.t, prev_from = c.prev_from, prev_to = c.prev_to;\n\n\t\t\tif(t > m){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(S[0].size() == n || S[2].size() == n){\n\t\t\t\tres = t;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tfor(int j=0;j<3;j++){//i -> j\n\t\t\t\t\tif(std::abs(i-j) != 1 || (j == prev_from && i == prev_to) ||\n\t\t\t\t\t\t S[i].empty() || (!S[j].empty() && S[i][0] < S[j][0]))continue;\n\t\t\t\t\tstd::vector<int> _S[3] = S;\n\t\t\t\t\t_S[j].push_back(_S[i][0]);\n\t\t\t\t\t_S[i].erase(_S[i].begin());\n\t\t\t\t\tstd::sort(_S[j].begin(), _S[j].end(), std::greater<int>());\n\t\t\t\t\tq.push(Cups(_S, t+1, i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << res << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nbool memo[3][3][3][3][3][3][3][3][3][3][3][3][3][3][3]={};\nvector<vector<int> >cup3(10);\nbool check(int num,int point){\n  int hi[15]={};\n\n   for(int i=0;i<3;i++)\n    for(int j=0;j<cup3[i].size();j++)\n      {hi[cup3[i][j]]=i;}\n  hi[num]=point;\n\n  //cout<<memo[hi[0]][hi[1]][hi[2]][hi[3]][hi[4]][hi[5]][hi[6]][hi[7]][hi[8]][hi[9]][hi[10]][hi[11]][hi[12]][hi[13]][hi[14]]<<endl;\n\n  if(!(memo[hi[0]][hi[1]][hi[2]][hi[3]][hi[4]][hi[5]][hi[6]][hi[7]][hi[8]][hi[9]][hi[10]][hi[11]][hi[12]][hi[13]][hi[14]])&&cup3[point].size()==0){\n    return true;\n  }else if(!(memo[hi[0]][hi[1]][hi[2]][hi[3]][hi[4]][hi[5]][hi[6]][hi[7]][hi[8]][hi[9]][hi[10]][hi[11]][hi[12]][hi[13]][hi[14]])&&(num>cup3[point][cup3[point].size()-1])){\n    return true;\n  }else{\n    return false;\n  }\n}\nvoid renew(){\n  int hai[15]={};\n  for(int i=0;i<3;i++)\n    for(int j=0;j<cup3[i].size();j++)\n      hai[cup3[i][j]]=i;\n  memo[hai[0]][hai[1]][hai[2]][hai[3]][hai[4]][hai[5]][hai[6]][hai[7]][hai[8]][hai[9]][hai[10]][hai[11]][hai[12]][hai[13]][hai[14]]=true;\n}\nint main(){\n  int n,m;while(cin>>n>>m,n+m){\n    cup3[0].clear();cup3[1].clear();\n    cup3[2].clear();\n    memset(memo,0,sizeof(memo));\n  for(int i=0;i<3;i++){\n    int a;cin>>a;\n    for(int j=0;j<a;j++){\n      int b;cin>>b;\n      b--;\n      cup3[i].pb(b);\n    }\n  }\n\n  renew();\n \n  bool flagg=true;\n  queue<pair<pair<int,int>,pair<vector<vector<int> >,int> > >que;\n  vector<vector<int> >cup2(3);\n\n  for(int i=0;i<3;i++){\n \n    for(int j=0;j<cup3[i].size();j++){\n      // cout<<cup3[i][j]<<\" \";\n      cup2[i].pb(cup3[i][j]);\n    }\n    //cout<<endl;\n  }\n  for(int i=0;i<3;i++)\n    if(cup3[i].size()!=0){\n      que.push(mp(mp(cup3[i][cup3[i].size()-1],0),mp(cup2,i)));\n      //cout<<i<<endl;\n    }\n  while(!que.empty()){\n \n    cup3[0].clear();cup3[1].clear();cup3[2].clear();\n    for(int i=0;i<3;i++){\n      for(int j=0;j<que.front().S.F[i].size();j++){\n\t//cout<<que.front().S.F[i][j]<<\" \";\n\tcup3[i].pb(que.front().S.F[i][j]);\n      }\n      //cout<<endl;\n    }\n\n    int point=que.front().S.S;\n    int num=que.front().F.F;\n    int cnt=que.front().F.S;\n    que.pop();\n    //cout<<point;\n    //cout<<\"-----------------------\"<<endl;\n    /*for(int i=0;i<3;i++){\n\tfor(int j=0;j<cup3[i].size();j++)\n\t  cout<<cup3[i][j]<<\" \";\n\tcout<<endl;\n\t}*/\n      //cout<<\"-----------------------\"<<endl;\n    if(cup3[0].size()==n||cup3[2].size()==n){\n\n      cout<<cnt<<endl;\n      flagg=false;\n      break;\n    }\n    if(cnt>=m)break;\n    if(point==0){\n      if(check(num,1)){\n\tcup3[point].pop_back();\n\tcup3[1].pb(num);\n\trenew();\n\tfor(int i=0;i<3;i++){\n\t  if(cup3[i].size()!=0)\n\t  que.push(mp(mp(cup3[i][cup3[i].size()-1],cnt+1),mp(cup3,i)));\n\t}\n      }\n    }else if(point==1){\n      if(check(num,0)){\n\n\tcup3[point].pop_back();\n\tcup3[0].pb(num);\n\trenew();\n\tfor(int i=0;i<3;i++){\n\t  if(cup3[i].size()!=0)\n\t    que.push(mp(mp(cup3[i][cup3[i].size()-1],cnt+1),mp(cup3,i)));\n\t}\n\tcup3[0].pop_back();\n\tcup3[point].pb(num);\n      }\n      if(check(num,2)){\n\tcup3[point].pop_back();\n\tcup3[2].pb(num);\n\trenew();\n\tfor(int i=0;i<3;i++){\n\t  if(cup3[i].size()!=0)\n\t  que.push(mp(mp(cup3[i][cup3[i].size()-1],cnt+1),mp(cup3,i)));\n\t}\n\tcup3[2].pop_back();\n\tcup3[point].pb(num);\n      }\n    }else if(point == 2){\n      if(check(num,1)){\n\t//cout<<point<<\" \"<<point<<endl;\n\tcup3[point].pop_back();\n\tcup3[1].pb(num);\n\trenew();\n\tfor(int i=0;i<3;i++){\n\t  if(cup3[i].size()!=0){\n\t    // cout<<point<<endl;\n\t  que.push(mp(mp(cup3[i][cup3[i].size()-1],cnt+1),mp(cup3,i)));\n\t  }\n\t}\n      }\n    }\n  }\n  if(flagg)\n    cout<<-1<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\nconst int NONE = -1;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(A);\n        if ( u > v ) {\n            int ret = solve( A | u, remove_last(B), C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(C);\n        if ( u > v ) {\n            int ret = solve( A, remove_last(B), C | u, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == NONE && ret2 == NONE ) {\n            cout << -1 << endl;\n        } else if ( ret1 != NONE && ret2 != NONE ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != NONE ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != NONE ) {\n            cout << ret2 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//????????????4????????????????????????[A->B] -> [B->A]???????§?????????¨, [A->B] -> [A->B]????????????????????¨??????????????¨??????????????????????????????\n//?????£????????´???????????\\??¬????????§???????????°?????????O(n + m)\n#include <iostream>\n#include <stack>\nusing namespace std;\n\nint n, m;\nstack<int> stk[3];\n\nvoid input() {\n\tint i;\n\tfor (i = 0; i < 3; i++) { while (!stk[i].empty()) stk[i].pop(); }\n\tfor (i = 0; i < 3; i++) {\n\t\tint num, value;\n\t\tcin >> num;\n\t\tfor (int j = 0; j < num; j++) {\n\t\t\tcin >> value;\n\t\t\tstk[i].push(value);\n\t\t}\n\t}\n}\n\nbool operate(stack<int> *s, int &pos) {\n\tif (s[pos].empty() && s[pos + 1].empty()) return false;\n\telse if (s[pos].empty()) { s[pos].push(s[pos + 1].top()); s[pos + 1].pop(); }\n\telse if (s[pos + 1].empty()) { s[pos + 1].push(s[pos].top()); s[pos].pop(); }\n\telse if (s[pos].top() < s[pos + 1].top()) { s[pos].push(s[pos + 1].top()); s[pos + 1].pop(); }\n\telse { s[pos + 1].push(s[pos].top()); s[pos].pop(); }\n\tpos = !pos;\n\treturn true;\n}\n\nint simurate(int pos) {\n\tint i;\n\tstack<int> s[3];\n\t\n\tfor (i = 0; i < 3; i++) s[i] = stk[i];\n\tfor (i = 0; i <= m; i++) {\n\t\tif (s[0].size() == n || s[2].size() == n) return i;\n\t\tif (!operate(s, pos)) return m + 1;\n\t}\n\treturn i;\n}\n\nint main() {\n\twhile (cin >> n >> m) {\n\t\tif (!n) break;\n\t\tinput();\n\t\tint ans = min(simurate(0), simurate(1));\n\t\tif (ans <= m) { cout << ans << endl; }\n\t\telse { cout << -1 << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n    int n,m;\n    while(1){\n        cin >> n >> m;\n        if(n == 0 && m == 0)break;\n        //vector<char> cup(n,0);\n        vector<char> cup;\n        cup.resize(n);\n\n        bool flag = true;\n        rep(i,3){\n            int n1;\n            cin >> n1;\n            rep(j,n1){\n                int n2;\n                cin >> n2;\n                n2--;\n                cup[n2] = i;\n            }\n        }//入力ここまで\n        queue<vector<char>> que;\n        que.push(cup);\n        map<vector<char>,int> mp;\n        mp[cup] = 0;\n        while(que.size()!=0){\n            cup = que.front();\n            que.pop();\n            //rep(i,cup.size())cout << cup[i];\n            //cout << endl;\n            int bigger[3];\n            int maxcount = 0;\n            bool tray[3] ={true,true,true};\n            if(n == count(cup.begin(),cup.end(),0) ||n == count(cup.begin(),cup.end(),2)){\n                cout << mp[cup] << endl;\n                flag = false;\n                break;\n            }\n            rep(i,n){\n                int i2 = n-i-1;\n                rep(j,3){\n                    if(tray[j] == true && cup[i2] == j){\n                        tray[j] = false;\n                        bigger[maxcount] = i2;\n                        maxcount++;\n                        break;\n                    }\n                }\n                if(maxcount == 3)break;\n            }\n            int movecount = mp[cup] + 1;\n            if(movecount > m) break;\n            if(cup[bigger[0]]-1 >= 0){\n                cup[bigger[0]]--;\n                //if(mp.count(cup) == 0){\n                if(mp.find(cup) == mp.end()){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]++;\n            }\n            if(cup[bigger[0]]+1 <= 2){\n                cup[bigger[0]]++;\n                //if(mp.count(cup) == 0){\n                if(mp.find(cup) == mp.end()){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]--;\n            }\n            if(maxcount >= 2){\n                if(cup[bigger[1]]-1 >= 0 && cup[bigger[1]]-1 != cup[bigger[0]]){\n                    cup[bigger[1]]--;\n                    //if(mp.count(cup) == 0){\n                    if(mp.find(cup) == mp.end()){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]++;\n                }\n                else if(cup[bigger[1]]+1 <= 2 && cup[bigger[1]]+1 != cup[bigger[0]]){\n                    cup[bigger[1]]++;\n                    //if(mp.count(cup) == 0){\n                    if(mp.find(cup) == mp.end()){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]--;\n                }\n            }\n        }\n        if(flag) cout << \"-1\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string>\n#include<stdlib.h>\n#include<stdio.h>\n#include<map>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nstack<int> X[3];\nint n, m;\nint ans;\nint owa;\nvoid aho(int a, int b)\n{\n\tX[b].push(X[a].top());\n\tX[a].pop();\n\treturn;\n}\nint k1[4] = { 0, 1, 1, 2 };\nint k2[4] = { 1, 0, 2, 1 };\nint check(int now)\n{\n\tif (now > owa)return m + 2;\n\tif (X[1].empty())\n\t{\n\t\tif (X[0].empty() || X[2].empty())\n\t\t{\n\t\t\towa = now + 1;\n\t\t\t//cout << now << endl;\n\t\t\treturn now;\n\t\t}\n\t}\n\tif (now == m )\n\t{\n\t\treturn m+2;\n\t}\n\tint ans = m+1;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tif (X[k1[i]].empty())continue;\n\t\tif (X[k1[i]] <= X[k2[i]])continue;\n\t\taho(k1[i], k2[i]);\n\t\tans=min(check(now + 1),ans);\n\t\taho(k2[i], k1[i]);\n\t}\n\treturn ans;\n\t\n\n}\n\nint main()\n{\n\n\tcin >> n >> m;\n\tans = m+1;\n\towa = m;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tint g;\n\t\tcin >> g;\n\t\tfor (int I = 0; I < g;I++)\n\t\t{\n\t\t\tint s; cin >> s;\n\t\t\tX[i].push(s);\n\t\t}\n\t}\n\tint g = check(0);\n\tif (g > m)\n\t{\n\t\tg = -1;\n\t}\n\tcout << g << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nbool use[15000000];\n\nint main(){\n  int n,m,now;\n\n  for(;;){\n    cin >> n >> m;\n    if(!n && !m)break;\n\n    now = 0;\n    for(int i=0;i<3;i++){\n      int num;\n      cin >> num;\n      for(int j=0;j<num;j++){\n\tint tmp;\n\tcin >> tmp;\n\tnow += pow(3,tmp-1)*i;\n      }\n    }\n\n    int lim = pow(3,n);\n    for(int i=0;i<lim;i++)use[i] = false;\n    use[now] = true;\n\n    int ans = -1;\n\n    queue<P> q;\n    q.push(P(now,0));\n\n    while(q.size()){\n      P p = q.front();q.pop();\n      stack<int> s[3];\n      now = p.first;\n      //cout << now << endl;\n      for(int i=1;i<=n;i++){\n\ts[now%3].push(i);\n\tnow/=3;\n      }\n\n      if((int)s[0].size()==n || (int)s[2].size()==n){\n\tans = p.second;\n\tbreak;\n      }\n      if(p.second>m)break;\n\n      int d1[] = {0,1,1,2},d2[] = {1,0,2,1};\n\n      for(int i=0;i<4;i++){\n\tif(s[d1[i]].size() && (s[d2[i]].empty() || s[d1[i]].top()>s[d2[i]].top())){\n\t  int hoge = pow(3,s[d1[i]].top()-1);\n\t  now = p.first - hoge*d1[i] + hoge*d2[i];\n\t  if(!use[now]){\n\t    use[now] = true;\n\t    q.push(P(now,p.second+1));\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nchar p[16];\nint n,m;\nint step(int a){\n\tif(a==n) return 1;\n\telse return 3*step(a+1)+1;\n}\nint count(int a,char t){\n\tif (a == n) return 0;\n\telse if(p[a] == t){\n\t\treturn count(a+1,'A');\n\t}\n\telse if(p[a] == 'B'){\n\t\treturn 1+count(a+1,'C')+step(a+1)*2;\n\t}\n\telse if(p[a] != t){\n\t\treturn 2+count(a+1,'A')+step(a+1)*4;\n\t}\n}\nint main(){\n\tint i,j,a,b,x,y,r;\n\twhile(cin >> n >> m && (n != 0 && m != 0)){\n\t\tr = 0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tcin >> x;\n\t\t\tfor(j=0;j < x;j++){\n\t\t\t\tcin >> y;\n\t\t\t\tif(i==0) p[y] = 'A';\n\t\t\t\telse if(i==1) p[y] = 'B';\n\t\t\t\telse p[y] = 'C';\n\t\t\t}\n\t\t}\n\t\ta = count(1,'A');\n\t\tb = count(1,'C');\n\t\tr = min(a,b);\n\t\tif(r > m) cout << -1 << endl;\n\t\telse  cout << r << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); i++)\nusing namespace std;\n\nint rec(int a, int b, int c){\n\tif(!a&&!b) return 0;\n\tint ans = 0;\n\tif(c&1) ans = rec(a>>1, b>>1, c>>1);\n\telse if(b&1) ans = rec(c>>1, b>>1, a>>1) + rec((a|b|c)>>1, 0, 0) + 1;\n\telse if(a&1) ans = rec(a>>1, b>>1, c>>1) + 2*rec((a|b|c)>>1, 0, 0) + 2;\n\treturn ans;\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n+m){\n\t\tint tray[3] = {0};\n\t\trep(ti, 3){\n\t\t\tint ts; cin >> ts;\n\t\t\trep(i, ts) {\n\t\t\t\tint num; cin >> num;\n\t\t\t\ttray[ti] |= 1 << num-1;\n\t\t\t}\n\t\t}\n\t\tint ans = min(rec(tray[0], tray[1], tray[2]), rec(tray[2], tray[1], tray[0]));\n\t\tcout << (ans <= m ? ans : -1) << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Name: Cup\n//Level: 4\n//Category: シミュレーション,数論\n//Note:\n\n/*\n * Aに積まれたN個のカップをCに移すときの手順は\n * ・AのN-1個のカップをCに移す\n * ・Aに残ったカップをBに移す\n * ・CのN-1個のカップをAに移す\n * ・Bに残っているカップをCに移す\n * ・AのN-1個のカップをCに移す\n * となるから，3^N-1手かかる．\n * それぞれのカップはトレイA-Cのどこにでも置けるから，可能な状態数は3^N．\n * したがって，普通に解けば全状態を網羅することになるので，当然初期状態もこの中に含まれる．\n * あとは解く手順をシミュレーションしながら初期状態が出現した手数を覚えておき，逆順に動かしたときも考えて小さいほうを手数として採用すればよい．\n */\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint pow_(int a, int x) {\n    int val = 1;\n    for(int i = 0; i < x; ++i) val *= a;\n    return val;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<vector<int> > goal(3);\n        for(int i = 0; i < 3; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int idx;\n                cin >> idx;\n                goal[i].push_back(idx-1);\n            }\n        }\n\n        vector<vector<int> > field(3);\n        for(int i = 0; i < N; ++i) {\n            field[0].push_back(i);\n        }\n\n        int turn = 0;\n        int prev_from = -1;\n        int prev_to = -1;\n        while(true) {\n            if(field == goal) {\n                break;\n            }\n            ++turn;\n            for(int from = 0; from < 3; ++from) {\n                if(field[from].size() == 0) continue;\n                const int glass = field[from].back();\n                const int to_1 = from-1;\n                const int to_2 = from+1;\n                if(!(from == prev_to && to_1 == prev_from) && to_1 >= 0 && (field[to_1].size() == 0 || field[to_1].back() < glass)) {\n                    field[to_1].push_back(glass);\n                    field[from].pop_back();\n                    prev_from = from;\n                    prev_to = to_1;\n                    break;\n                }\n                else if(!(from == prev_to && to_2 == prev_from) && to_2 < 3 && (field[to_2].size() == 0 || field[to_2].back() < glass)) {\n                    field[to_2].push_back(glass);\n                    field[from].pop_back();\n                    prev_from = from;\n                    prev_to = to_2;\n                    break;\n                }\n                else {\n                }\n            }\n        }\n        const int MAXTURN = pow_(3, N) - 1;\n        turn = min(turn, MAXTURN-turn);\n        if(turn > M) turn = -1;\n        cout << turn << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n//http://climpet.hatenablog.com/entry/2013/01/01/225142#f5を参考\nint main(int argc, char *argv[])\n{\n  int pow3[16],c[16];\n  int n,m,i,j,k,d,x,y,p;\n\n  pow3[0] = 1;\n  for(i = 1;i <=15;i++){\n    pow3[i] = pow3[i-1]*3;//i枚#0から#2または#2から#0へ移動するのに必要なステップ数\n}\n\n  while(scanf(\"%d%d\",&n,&m),n){\n    for(i = 0;i < 3;--i){\n      for(scanf(\"%d\",&j);j > 0;--j){\n\tscanf(\"%d\",&k);\n\tc[n-k] = i;/*番号付け替え,ハノイの塔に変換。大きいコップを小さい円盤にする*/\n      }\n    }\n    p = 0;//全ての円盤が0の位置にあると仮定する\n    x = 0;\n    for(i = n-1;i >= 0;i--){//\n      d = abs(p -c[i]);//移動させる円盤の距離を求める。\n      /*n = 3の時、i = 2で円盤2を#1に移動させるには円盤1と円盤0を#2に移動させる*/\n      x += pow3[i]*d;\n      if(d == 1){\n\tp = 2-p;/*反対側に移動,距離がd = 1ならば0~i-1番の円盤を反対側に移動する。*/\n      }\n    }\n    y = pow3[n] -1 -x;\n    if(x > y){\n      x = y;\n    }\n    printf(\"%d\\n\",x > m?-1:x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \": \" << x << '\\n';\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst int INF = (int)1e9;\nconst int MOD = (int)1e9 + 7;\n\nint n, m;\nint dist[14348907];\nint num[17];\n\nint max_cup(int state, int tray){\n\t// debug(tray);\n\tfor(int i = n; i >= 1; i--){\n\t\tif(state / num[i-1] == tray) return i;\n\t\tstate %= num[i-1];\n\t}\n\n\treturn 0;\n}\n\nint main(void){\n\tnum[0] = 1;\n\tfor(int i = 1; i <= 16; i++){\n\t\tnum[i] = num[i-1] * 3;\n\t}\n\n\twhile(true){\n\t\tint state = 0;\n\t\tcin >> n >> m;\n\t\tif(n == 0 and m == 0) break;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\tint x;\n\t\t\t\tcin >> x;\n\t\t\t\tstate += i * num[x-1];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < num[n]; i++) dist[i] = INF;\n\n\t\tqueue<int> que;\n\t\tque.push(state);\n\t\tdist[state] = 0;\n\t\twhile(not que.empty()){\n\t\t\tint s = que.front();\n\t\t\tque.pop();\n\t\t\t// debug(s);\n\t\t\tif(dist[s] > m) break;\n\n\t\t\tint M[3];\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tM[i] = max_cup(s, i);\n\t\t\t\t// debug(M[i]);\n\t\t\t}\n\n\t\t\tif(M[0] < M[1]){\n\t\t\t\t// debug(\"a\");\n\t\t\t\tint ns = s - num[M[1]-1];\n\t\t\t\tif(dist[ns] == INF){\n\t\t\t\t\tdist[ns] = dist[s] + 1;\n\t\t\t\t\tque.push(ns);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// debug(\"b\");\n\t\t\t\tint ns = s + num[M[0]-1];\n\t\t\t\tif(dist[ns] == INF){\n\t\t\t\t\tdist[ns] = dist[s] + 1;\n\t\t\t\t\tque.push(ns);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// debug(\"tes\");\n\n\t\t\tif(M[1] < M[2]){\n\t\t\t\t// debug(\"c\");\n\t\t\t\tint ns = s - num[M[2]-1];\n\t\t\t\tif(dist[ns] == INF){\n\t\t\t\t\tdist[ns] = dist[s] + 1;\n\t\t\t\t\tque.push(ns);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// debug(\"d\");\n\t\t\t\tint ns = s + num[M[1]-1];\n\t\t\t\tif(dist[ns] == INF){\n\t\t\t\t\tdist[ns] = dist[s] + 1;\n\t\t\t\t\tque.push(ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = -1;\n\t\tif(min(dist[0], dist[num[n] - 1]) <= m) res = min(dist[0], dist[num[n] - 1]);\n\n\t\tcout << res << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef struct Cup\n{\n\tvector<int>P[3];\n\tint T;\n\tbool operator <(const Cup &a)const{ return T>a.T;};\n}S;\nint N,M;\nbool f[3][3][3][3][3][3][3][3][3][3][3][3][3][3][3];\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&M),N;)\n\t{\n\t\tCup tmp;\n\t\tint i,j,t,q,R=-1;\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=0;i<3;i++)\n\t\t{\n\t\t\tfor(scanf(\"%d\",&t),j=0;j<t;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&q);\n\t\t\t\ttmp.P[i].push_back(q);\n\t\t\t}\n\t\t}\n\n\t\ttmp.T=0;\n\t\tpriority_queue<Cup> Q;\n\t\tQ.push(tmp);\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\ttmp=Q.top();Q.pop();\n\t\t\tint p[15]={0};\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tfor(int j=0;j<tmp.P[i].size();j++)\n\t\t\t\t\tp[tmp.P[i][j]-1]=i;\n\t\t\tif(f[p[0]][p[1]][p[2]][p[3]][p[4]][p[5]][p[6]][p[7]][p[8]][p[9]][p[10]][p[11]][p[12]][p[13]][p[14]])continue;\n\t\t\tif(tmp.T>M)continue;\n\t\t\tif(tmp.P[0].size()==N||tmp.P[2].size()==N)\n\t\t\t{\n\t\t\t\tR=tmp.T;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tfor(int j=-2;j<3;j++)\n\t\t\t\t{\n\t\t\t\t\tif(j&&i+j>=0&&i+j<3&&!tmp.P[i].empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tint tmp1=tmp.P[i].back();\n\t\t\t\t\t\tint tmp2=-1;\n\t\t\t\t\t\tif(!tmp.P[i+j].empty())\n\t\t\t\t\t\t\ttmp2=tmp.P[i+j].back();\n\t\t\t\t\t\tif(tmp1>tmp2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCup ins=tmp;\n\t\t\t\t\t\t\tins.P[i+j].push_back(tmp1);\n\t\t\t\t\t\t\tins.P[i].pop_back();\n\t\t\t\t\t\t\tins.T=ins.T+abs(j);\n\t\t\t\t\t\t\tQ.push(ins);\n\t\t\t\t\t\t\tf[p[0]][p[1]][p[2]][p[3]][p[4]][p[5]][p[6]][p[7]][p[8]][p[9]][p[10]][p[11]][p[12]][p[13]][p[14]]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <functional>\n#include <array>\n#include <stack>\n#include <queue>\n#include <chrono>\n#include <numeric>\n#include <memory.h>\n#include <map>\n#include <math.h>\n\n\n#pragma warning(disable:4996)\n#define REP(i,n) for(int i = 0 ; i < n ; ++i)\ntypedef long long Int;\nconst double PI = 3.141592653589793238;\nconst Int INF = 999999999999;\nusing namespace std;\n\nint dx[4] = { 0, -1, 0, 1 };\nint dy[4] = { 1, 0, -1, 0 };\n\nstruct state{\n\tvector<int> A, B, C;\n\tint pre_a,pre_c;\n\tInt step;\n\tstate() :step(0),pre_a(-1),pre_c(-1){}\n};\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n&&m){\n\t\tqueue<state> que;\n\n\t\tstate s;\n\t\tREP(i,3){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tREP(j,k){\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tif (i ==0)\n\t\t\t\t\ts.A.push_back(a);\n\t\t\t\tif (i == 1)\n\t\t\t\t\ts.B.push_back(a);\n\t\t\t\tif (i == 2)\n\t\t\t\t\ts.C.push_back(a);\n\t\t\t}\n\t\t}\n\n\t\tque.push(s);\n\t\twhile (!que.empty()){\n\t\t\tstate now = que.front();\n\t\t\tque.pop();\n\n\t\t\tif ((now.B.empty() && now.C.empty()) || (now.B.empty() && now.A.empty())){\n\t\t\t\tcout << now.step << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (now.step > m){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!now.A.empty() && (now.B.empty() || (now.A.back() > now.B.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tif (now.pre_a != next.A.back()){\n\t\t\t\t\tnext.B.push_back(next.A.back());\n\t\t\t\t\tnext.pre_a = next.A.back();\n\t\t\t\t\tnext.pre_c = -1;\n\t\t\t\t\tnext.A.pop_back();\n\t\t\t\t\t++next.step;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!now.B.empty() && (now.A.empty() || (now.A.back() < now.B.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tif (now.pre_a != next.B.back()){\n\t\t\t\t\tnext.A.push_back(next.B.back());\n\t\t\t\t\tnext.pre_a = next.B.back();\n\t\t\t\t\tnext.pre_c = -1;\n\t\t\t\t\tnext.B.pop_back();\n\t\t\t\t\t++next.step;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!now.B.empty() && (now.C.empty() || (now.B.back() > now.C.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tif (now.pre_c != next.B.back()){\n\t\t\t\t\tnext.C.push_back(next.B.back());\n\t\t\t\t\tnext.pre_c = next.B.back();\n\t\t\t\t\tnext.pre_a = -1;\n\t\t\t\t\tnext.B.pop_back();\n\t\t\t\t\t++next.step;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!now.C.empty() && (now.B.empty() || (now.B.back() < now.C.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tif (now.pre_c != next.C.back()){\n\t\t\t\t\tnext.B.push_back(next.C.back());\n\t\t\t\t\tnext.pre_c = next.C.back();\n\t\t\t\t\tnext.pre_a = -1;\n\t\t\t\t\tnext.C.pop_back();\n\t\t\t\t\t++next.step;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<set>\n#include<utility>\n#include<vector>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define MP(a,b) make_pair(a,b)\n\t\ntypedef vector<vector<int> > S;\nS in(3);\nint n,m;\n\nint bfs(){\n\tset<S> s;\n\tpair<int,S> a;\n\tS b;\n\tqueue<pair<int,S> > q;\n\tq.push(MP(0,in));\n\ts.insert(in);\n\n\twhile(!q.empty()){\n\t\ta = q.front();q.pop();\n\t\tb = a.second;\n\t\tif(b[0].size()==n || b[2].size()==n)return a.first;\n\t\tif(m < a.first)break;\n\t\tif(!b[0].empty()){//A->B\n\t\t\tif(b[1].empty() || b[0].back() > b[1].back()){\n\t\t\t\tb[1].push_back(b[0].back());\n\t\t\t\tb[0].pop_back();\n\t\t\t\tif(s.find(b)==s.end()){\n\t\t\t\t\tq.push(MP(a.first+1,b));\n\t\t\t\t\ts.insert(b);\n\t\t\t\t}\n\t\t\t\tb = a.second;\n\t\t\t}\n\t\t}\n\t\tif(!b[1].empty()){//B->A\n\t\t\tif(b[0].empty() || b[1].back() > b[0].back()){\n\t\t\t\tb[0].push_back(b[1].back());\n\t\t\t\tb[1].pop_back();\n\t\t\t\tif(s.find(b)==s.end()){\n\t\t\t\t\tq.push(MP(a.first+1,b));\n\t\t\t\t\ts.insert(b);\n\t\t\t\t}\n\t\t\t\tb = a.second;\n\t\t\t}\n\t\t}\n\t\tif(!b[1].empty()){//B->C\n\t\t\tif(b[2].empty() || b[1].back() > b[2].back()){\n\t\t\t\tb[2].push_back(b[1].back());\n\t\t\t\tb[1].pop_back();\n\t\t\t\tif(s.find(b)==s.end()){\n\t\t\t\t\tq.push(MP(a.first+1,b));\n\t\t\t\t\ts.insert(b);\n\t\t\t\t}\n\t\t\t\tb = a.second;\n\t\t\t}\n\t\t}\n\t\tif(!b[2].empty()){//C->B\n\t\t\tif(b[1].empty() || b[2].back() > b[1].back()){\n\t\t\t\tb[1].push_back(b[2].back());\n\t\t\t\tb[2].pop_back();\n\t\t\t\tif(s.find(b)==s.end()){\n\t\t\t\t\tq.push(MP(a.first+1,b));\n\t\t\t\t\ts.insert(b);\n\t\t\t\t}\n\t\t\t\tb = a.second;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main(){\n\twhile(cin>>n>>m, n||m){\n\t\tin.clear();\n\t\tin.resize(3);\n\t\tREP(i,3){\n\t\t\tint a,b;\n\t\t\tcin>>a;\n\t\t\tREP(j,a){\n\t\t\t\tcin>>b;\n\t\t\t\tin[i].push_back(b);\n\t\t\t}\n\t\t}\n\t\tcout<<bfs()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\n#define ull unsigned long long\n#define ld long double\n\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\ntemplate <class T>\nusing VVV = V<V<V<T>>>;\n\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define rep1(i, n) rep1(i, 1, n + 1)\n\n// #define repr(i, n) for (int i = ((int)(n)-1); i >= 0; i--)\n// #define rep1r(i, n) for (int i = ((int)(n)); i >= 1; i--)\n\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()  //\n\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define RSORT(x) sort(rall(x));\n#define pb push_back\n#define mp make_pair\n\n#define INF (1e9)\n#define PI (acos(-1))\n#define EPS (1e-7)\n\n// 総数を1000000007（素数）で割った余り\nconst long long mod = 1e9 + 7;\n\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst int dy[] = {1, 0, -1, 0, -1, 1, 1, -1};\n\null gcd(ull a, ull b) { return b ? gcd(b, a % b) : a; }\null lcm(ull a, ull b) { return a / gcd(a, b) * b; }\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << std::fixed << std::setprecision(15);\n    //    cout << std::setfill('0') << std::setw(2);\n\n    while (1) {\n        int n, m;\n        cin >> n >> m;\n        if (!n && !m) return 0;\n\n        V<int> c(n);\n        rep(i, 3) {\n            int a;\n            cin >> a;\n            rep(j, a) {\n                int b;\n                cin >> b;\n                b--;\n                c[b] = i;\n            }\n        }\n        // ３進数に割り振り\n        int p = 1;\n        int x = 0;  //ここに割り振る\n        rep(i, n) {\n            x += c[i] * p;\n            p *= 3;\n        }\n\n        const int l = p - 1;  // ３進数のmax．\n        const int z = 15000000;\n        V<bool> memo(z);\n        // memo[x] = true;  !!! ここでtrueにしたらアカン！！\n\n        queue<pii> q;\n        q.emplace(x, 0);\n        while (!q.empty()) {\n            pii P = q.front();\n            q.pop();\n            int xx = P.first, t = P.second;\n            if (t > m) {\n                cout << -1 << endl;\n                break;\n            }\n            if (memo[xx]) continue;\n            memo[xx] = true;\n            if (xx == 0 || xx == l) {\n                cout << t << endl;\n                break;\n            }\n            V<int> ch(3, -1);\n            int xc = xx;\n            int nc = 0;\n            int g = 1;\n            while (nc < n) {\n                ch[xc % 3] = g;\n                xc /= 3;\n                g *= 3;\n                nc++;\n            }\n            t++;\n            if (ch[0] > ch[1]) {\n                q.emplace(xx + ch[0], t);\n            } else {\n                q.emplace(xx - ch[1], t);\n            }\n            if (ch[1] > ch[2]) {\n                q.emplace(xx + ch[1], t);\n            } else {\n                q.emplace(xx - ch[2], t);\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <vector>\n#define INPUT_FROM_FILE (0)\n\n#if INPUT_FROM_FILE\n#include <fstream>\n#endif\n\nclass Node{\npublic:\n\tstd::stack<char> tray[3];\n\tint num_move;\n\npublic:\n\tNode(std::stack<char> t[3], int n) : num_move(n){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\ttray[i] = t[i];\n\t\t}\n\t\treturn;\n\t}\n\n\t~Node(){}\n};\n\n//tray[i]???????????????????????????tray[j]????§????\nbool move(std::vector<std::stack<char> > &tray, int i, int j){\n\tif(tray[i].empty()){\n\t\treturn false;\n\t}\n\tchar c = tray[i].top();\n\n\tif(!tray[j].empty()){\n\t\tchar cc = tray[j].top();\n\n\t\tif(c < cc){\n\t\t\treturn false;\n\t\t}\n\t}\n\n\ttray[i].pop();\n\ttray[j].push(c);\n\treturn true;\n}\n\nint main(int argc, char **argv){\n#if INPUT_FROM_FILE\n\tstd::ifstream ifs(\"test.txt\");\n#endif\n\tint n = 0;\n\tint m = 0;\n\n#if INPUT_FROM_FILE\n\twhile(ifs >> n >> m, (n != 0 || m != 0)){\n#else\n\twhile(std::cin >> n >> m, (n != 0 || m != 0)){\n#endif\n\t\tstd::stack<char> tray[3];\n\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tint num_cups = 0;\n\n#if INPUT_FROM_FILE\n\t\t\tifs >> num_cups;\n#else\n\t\t\tstd::cin >> num_cups;\n#endif\n\t\t\tfor(int j = 0; j < num_cups; j++){\n\t\t\t\tchar c = 0;\n\n#if INPUT_FROM_FILE\n\t\t\t\tifs >> c;\n#else\n\t\t\t\tstd::cin >> c;\n#endif\n\t\t\t\ttray[i].push(c);\n\t\t\t}\n\t\t}\n\t\t//??¢?´¢\n\t\t{\n\t\t\tstd::queue<Node*> q;\n\t\t\tNode *root = new Node(tray, 0);\n\t\t\tbool is_able = false;\n\n\t\t\tq.push(root);\n\t\t\twhile(!q.empty()){\n\t\t\t\tNode *n = q.front();\n\n\t\t\t\tq.pop();\n\n\t\t\t\tif(n->num_move > m){\n\t\t\t\t\tdelete n; n = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif((n->tray[1].empty() && n->tray[2].empty()) || (n->tray[0].empty() && n->tray[1].empty())){\n\t\t\t\t\tis_able = true;\n\t\t\t\t\tstd::cout << n->num_move << std::endl;\n\t\t\t\t\tdelete n; n = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tstd::vector<std::pair<char, char> > index_vec;\n\n\t\t\t\t\tindex_vec.push_back(std::pair<char, char>(0, 1));\n\t\t\t\t\tindex_vec.push_back(std::pair<char, char>(1, 0));\n\t\t\t\t\tindex_vec.push_back(std::pair<char, char>(1, 2));\n\t\t\t\t\tindex_vec.push_back(std::pair<char, char>(2, 1));\n\t\t\t\t\t\n\t\t\t\t\tfor(unsigned int i = 0; i < index_vec.size(); i++){\n\t\t\t\t\t\tstd::vector<std::stack<char> > copy_tray;\n\n\t\t\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\t\t\tcopy_tray.push_back(n->tray[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(move(copy_tray, index_vec[i].first, index_vec[i].second)){\n\t\t\t\t\t\t\tstd::stack<char> ct[3] = { copy_tray[0], copy_tray[1], copy_tray[2] };\n\t\t\t\t\t\t\tNode *child = new Node(ct, n->num_move + 1);\n\n\t\t\t\t\t\t\tq.push(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdelete n; n = NULL;\n\t\t\t}\n\n\t\t\twhile(!q.empty()){\n\t\t\t\tNode *n = q.front();\n\n\t\t\t\tdelete n; n = NULL;\n\t\t\t\tq.pop();\n\t\t\t}\n\n\t\t\tif(!is_able){\n\t\t\t\tstd::cout << -1 << std::endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n// variable update\ninline void modAdd(int& _a, int _b, int _m) { _a = (_a + _b) % _m; }\ninline void modAdd(lint& _a, lint _b, lint _m) { _a = (_a + _b) % _m; }\ninline void minUpdate(int& _a, int _b) { _a = min(_a, _b); }\ninline void minUpdate(lint& _a, lint _b) { _a = min(_a, _b); }\ninline void maxUpdate(int& _a, int _b) { _a = max(_a, _b); }\ninline void maxUpdate(lint& _a, lint _b) { _a = max(_a, _b); }\n\nint n, m;\nint POW[16];\n\nint calc(int A, int B, int C) {\n\tint res = 0;\n\tfor_(i,0,n) {\n\t\tint k = n - i - 1;\n\t\tif (A >> i & 1) res += 2 * POW[k], swap(A, C);\n\t\tif (B >> i & 1) res += POW[k];\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tint cup[3] = { 0 };\n\t\n\tfor_(i,0,3) {\n\t\tint d; cin >> d;\n\t\tfor_(j,0,d) {\n\t\t\tint p; cin >> p; --p;\n\t\t\tcup[i] |= 1 << p;\n\t\t}\n\t}\n\t\n\tint ans = min(calc(cup[0], cup[1], cup[2]), calc(cup[2], cup[1], cup[0]));\n\tif (ans > m) ans = -1;\n\tcout << ans << endl;\n}\n\nint main() {\n\tPOW[0] = 1;\n\tfor_(i,1,16) POW[i] = POW[i - 1] * 3;\n\tPOW[0] = 0;\n\twhile (cin >> n >> m, n) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<bitset>\n\n#define MAX 16\n#define A 0\n#define B 1\n#define C 2\n#define P_MAX 3\n#define M_MAX 16000000\n\nusing namespace std;\n\nstruct Cups{\n\tCups(){\n\t\tcost = 0;\n\t\tv[0].reserve(MAX);\n\t\tv[1].reserve(MAX);\n\t\tv[2].reserve(MAX);\n\t}\n\tbitset<MAX> key[P_MAX];\n\tvector<int> v[P_MAX];\n\tbool operator<(const Cups &t)const{\n\t\tunsigned long l0 = key[0].to_ulong(), tl0 = t.key[0].to_ulong();\n\t\tunsigned long l1 = key[1].to_ulong(), tl1 = t.key[1].to_ulong();\n\t\tunsigned long l2 = key[2].to_ulong(), tl2 = t.key[2].to_ulong();\n\n\t\tif( l0 < tl0 ){\n\t\t\treturn true;\n\t\t}else if( l0 == tl0 && l1 < tl1 ){\n\t\t\treturn true;\n\t\t}else if( l0 == tl0 && l1 == tl1 && l2 < tl2 ){\n\t\t\treturn true;\n\t\t}else if( l0 == tl0 && l1 == tl1 && l2 == tl2 && cost < t.cost )\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\tbool operator==(const Cups &t)const{\n\t\treturn key[0].to_ulong() == t.key[0].to_ulong() &&\n\t\t\tkey[1].to_ulong() == t.key[1].to_ulong() &&\n\t\t\tkey[2].to_ulong() == t.key[2].to_ulong() &&\n\t\t\tcost <= t.cost;\n\t}\n\tvoid CalcKey(){\n\t\tfor(int i = 0; i < P_MAX; ++i){\n\t\t\tkey[i] = 0;\n\t\t\tfor(unsigned int j = 0; j < v[i].size(); ++j){\n\t\t\t\tkey[i].set( v[i][j] );\n\t\t\t}\n\t\t}\n\t}\n\tint cost;\n};\nostream &operator<<(ostream &os, const vector<int> &v){\n\tfor(unsigned int i = 0; i < v.size(); ++i){\n\t\tos << v[i] << ' ';\n\t}\n\treturn os;\n}\nostream & operator << (ostream &os, const Cups &t){\n\tos << \"A: \" << t.v[0] << \"\\t\\tB: \" << t.v[1] << \"\\t\\tC: \" << t.v[2] << \"\\t\\tCost :\" << t.cost;\n\treturn os;\n}\nint cost[3][MAX];\n\nint BFS(int n, int m, int greedy, Cups &st){\n\tint ret = M_MAX;\n\tset<Cups> vis_set;\n\tqueue<Cups> q;\n\n\tst.CalcKey();\n\tvis_set.insert( st );\n\tq.push( st );\n\twhile( !q.empty() ){\n\t\tCups cups;\n\t\tcups = q.front();\n\n\t\tq.pop();\n\n\t\t/* I¹ð */\n\t\tif( cups.v[A].size() == n || cups.v[C].size() == n ){\n\t\t\tret = min(ret, cups.cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = A; i <= C; ++i){\n\t\t\tint mov_cnt = 1;\n\t\t\tint min_sz = -1;\n\n\t\t\tfor(int j = cups.v[i].size()-1; j >= 1; --j){\n\t\t\t\tif( cups.v[i][j] - cups.v[i][j-1] == 1 ){\n\t\t\t\t\t++mov_cnt;\n\t\t\t\t\tmin_sz = cups.v[i][j-1];\n\t\t\t\t}else{\n\t\t\t\t\tmin_sz = cups.v[i][j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( cups.v[i].size() == 1 )\n\t\t\t\tmin_sz = cups.v[i][0];\n\n\t\t\tif( min_sz == -1 )\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tfor(int w = 1; w <= mov_cnt; ++w){\n\t\t\t\tfor(int j = A; j <= C; ++j){\n\t\t\t\t\tint d = abs( i - j );\n\t\t\t\t\tif( d == 2 || d == 0 )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tCups t = cups;\n\t\t\t\t\tint end = t.v[j].size() - 1;\n\t\t\t\t\tif( end >= 0 && t.v[j][end] > min_sz )\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tt.v[j].insert( t.v[j].end(), t.v[i].end() - w, t.v[i].end() );\n\t\t\t\t\tt.v[i].erase( t.v[i].end() - w, t.v[i].end() );\n\t\t\t\t\tt.cost += cost[ 1 ][ w ];\n\n\t\t\t\t\t//cout << t;\n\n\t\t\t\t\tt.CalcKey();\n\t\t\t\t\tif( t.cost <= m && t.cost < ret && t.cost <= greedy && vis_set.find( t ) == vis_set.end() ){\n\t\t\t\t\t\tq.push( t );\n\t\t\t\t\t\tvis_set.insert( t );\n\t\t\t\t\t\t//cout << \" ACCEPTED\\n\";\n\t\t\t\t\t}//else\n\t\t\t\t\t\t//cout << \" REJECTED\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint Greedy( int n, const Cups &cups){\n\tint ret = 0;\n\tint places[MAX];\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(unsigned int j = 0; j < cups.v[i].size(); ++j ){\n\t\t\tplaces[ cups.v[i][j] ] = i;\n\t\t}\n\t}\n\tfor(int i = n; i >= 2; --i){\n\t\tint d = abs(places[i] - places[i-1]); \n\t\tret += cost[ d ][ n - i + 1 ];\n\t}\n\tif( places[1] == B )\n\t\tret += cost[ 1 ][ n ];\n\n\treturn ret;\n}\nint main(){\n\tcost[1][1] = 1;\n\tcost[2][1] = 2;\n\tfor(int i = 1; i < 3; ++i){\n\t\tfor(int j = 2; j < MAX; ++j){\n\t\t\tif( i == 1 ){\n\t\t\t\tcost[i][j] = 3 * cost[i][j - 1] + 1;\n\t\t\t}else{\n\t\t\t\tcost[i][j] = 2 * cost[1][j];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tint n,m;\n\t\tint greedy;\n\t\tint ans = 0;\n\t\tCups cups;\n\t\t\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif( n == 0 && m == 0 )\n\t\t\tbreak;\n\n\t\tfor(int i = 0; i < 3; ++i){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tfor(int j = 0; j < t; ++j){\n\t\t\t\tint tt;\n\t\t\t\tscanf(\"%d\", &tt);\n\t\t\t\tcups.v[i].push_back(tt);\n\t\t\t}\n\t\t}\n\t\tgreedy = Greedy( n, cups );\n\t\tans = BFS(n, m, greedy, cups );\n\t\t\n\t\tprintf(\"%d\\n\", ans <= m ? ans : -1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<cstdio>\n#include<algorithm>\n#define rep(i,a) for(int i=0;i<(a);++i)\n\nint n, m;\nint S[3];\n\nint toC(int a, int b, int c) {\n\tif (!a && !b)return 0;\n\tif (c & 1)return toC(a >> 1, b >> 1, c >> 1);\n\tif (b & 1)return toC(c >> 1, b >> 1, a >> 1) + toC((a | b | c) >> 1, 0, 0) + 1;\n\tif (a & 1)return toC(a >> 1, b >> 1, c >> 1) + 2 * toC((a | b | c) >> 1, 0, 0) + 2;\n}\n\nint main(){\n\twhile (scanf(\"%d%d\", &n, &m), n | m){\n\t\trep(i, 3)S[i] = 0;\n\t\trep(t, 3){\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\trep(i, c){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tS[t] |= 1 << a - 1;\n\t\t\t}\n\t\t}\n\t\tint ans = std::min(toC(S[0], S[1], S[2]), toC(S[2], S[1], S[0]));\n\t\tprintf(\"%d\\n\", ans <= m ? ans : -1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint p[15], n, k, a1, a2, a3, a4, a5, power[16], dp[15000000];\nqueue<int>Q;\nint main() {\n\twhile (true) {\n\t\tcin >> n >> k; power[0] = 1; for (int i = 1; i < 16; i++)power[i] = power[i - 1] * 3; a5 = 0;\n\t\tif (n == 0 && k == 0)break;\n\t\tcin >> a1; for (int i = 0; i < a1; i++) { cin >> a4; p[a4 - 1] = 0; }\n\t\tcin >> a2; for (int i = 0; i < a2; i++) { cin >> a4; p[a4 - 1] = 1; }\n\t\tcin >> a3; for (int i = 0; i < a3; i++) { cin >> a4; p[a4 - 1] = 2; }\n\t\tfor (int i = 0; i < n; i++) { a5 += power[i] * p[i]; }\n\t\tfor (int i = 0; i < power[n]; i++)dp[i] = 1000000000; dp[a5] = 0; Q.push(a5);\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front(); Q.pop();\n\t\t\tvector<int>b[4];\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tint p1 = (a1 / power[i]) % 3;\n\t\t\t\tb[p1 + 1].push_back(i);\n\t\t\t}\n\t\t\tif (b[1].size() >= 1 && (b[2].size() == 0 || b[1][0] > b[2][0])) {\n\t\t\t\tint F = a1 + power[b[1][0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t\tif (b[2].size() >= 1 && (b[1].size() == 0 || b[1][0] < b[2][0])) {\n\t\t\t\tint F = a1 - power[b[2][0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t\tif (b[2].size() >= 1 && (b[3].size() == 0 || b[2][0] > b[3][0])) {\n\t\t\t\tint F = a1 + power[b[2][0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t\tif (b[3].size() >= 1 && (b[2].size() == 0 || b[2][0] < b[3][0])) {\n\t\t\t\tint F = a1 - power[b[3][0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t}\n\t\tint ans = min(dp[0], dp[power[n] - 1]);\n\t\tif (ans > k)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing vs=vector<string>;\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(int i=(a);i<(n);i++)\n\n#define LINF    \t((ll)1ll<<60)\n#define INF     \t((int)1<<30)\n#define EPS     \t(1e-9)\n#define MOD     \t(1000000007ll)\n#define fcout(a)\tcout<<setprecision(a)<<fixed\n#define fs \t\t\tfirst\n#define sc\t\t\tsecond\n#define PI\t\t\t3.1415926535897932384\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s; a=0;} return os;}\nvoid OUT(bool b){cout<<(b?\"YES\":\"NO\")<<endl;}\nvoid Out(bool b){cout<<(b?\"Yes\":\"No\")<<endl;}\nvoid out(bool b){cout<<(b?\"yes\":\"no\")<<endl;}\nint popcnt(int x) { return __builtin_popcount(x); }\nint popcnt(ll x) { return __builtin_popcountll(x); }\nint clz(int x) { return 31 - __builtin_clz(x); }\nint clz(ll x) { return 63 - __builtin_clzll(x); }\nint ctz(int x) { return __builtin_ctz(x); }\nint ctz(ll x) { return __builtin_ctzll(x); }\n\nclass compare {\npublic:\n\tbool operator()(tuple<ll, ll> a, tuple<ll, ll> b) {\n\t\treturn (get<1>(a) > get<1>(b));\n\t}\n};\n\nvoid solve(int n,int m){\n\tint in,cup,ans=INF;\n\tvector<vector<stack<int>>> s(2,vector<stack<int>>(3));\n\trep(i,3){\n\t\ts[0][i].push(0);\n\t\ts[1][i].push(0);\n\t\tcin>>in;\n\t\trep(j,in){\n\t\t\tcin>>cup;\n\t\t\ts[0][i].push(cup);\n\t\t\ts[1][i].push(cup);\n\t\t}\n\t}\n\tint l,r;\n\trep(i,2){\n\t\trep(j,m){\n\t\t\t//cout<<s[i][0].size()<<\" \"<<s[i][1].size()<<\" \"<<s[i][2].size()<<endl;\n\t\t\tif(s[i][1].top()==0&&(s[i][0].top()==0||s[i][2].top()==0)){\n\t\t\t\tans=min(ans,j);\n\t\t\t\tj+=m;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint k=((i+j)%2);\n\t\t\tl=s[i][k].top();\n\t\t\tr=s[i][k+1].top();\n\t\t\tif(l>r){s[i][k].pop();s[i][k+1].push(l);}\n\t\t\telse {s[i][k+1].pop();s[i][k].push(r);}\n\t\t}\n\t\tif(s[i][1].top()==0&&(s[i][0].top()==0||s[i][2].top()==0)){\n\t\t\tans=min(ans,m);\n\t\t}\n\t}\n\tcout<<((ans==INF?-1:ans))<<endl;\n}\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tsolve(n,m);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#define f(n) ((int)pow(3.0,n)-1)\nint A,N,M,S[16];\nint v(int n,int m,int g){if(m<=N)return v(n-1,m+1,S[m]==1?g+2*(1-g):g)+abs(g-S[m])*(f(n-1)+1);else return 0;}\nint main(){while(1){scanf(\"%d%d\",&N,&M);if(!(N||M))break;for(int i=0;i<3;++i){int t;scanf(\"%d\",&t);for(int j=0;j<t;++j){int u;scanf(\"%d\",&u);S[u]=i;}}A=v(N,1,0);A=std::min(A,f(N)-A);A=A<=M?A:-1;printf(\"%d\\n\",A);}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define min(a, b) (a > b ? b : a)\n\nint func(int a, int b, int c) {\n    if (b == 0 && c == 0)\n        return 0;\n    else if (a & 1)\n        return func(a >> 1, b >> 1, c >> 1);\n    else if (b & 1)\n        return func(c >> 1, b >> 1, a >> 1) + 1 + func(0, 0, (a | b | c) >> 1);\n    else\n        return func(c >> 1, b >> 1, a >> 1) + 2 * func(0, a | b | c, 0);\n}\n\nint main() {\n    int n, m, tray[3];\n    while (std::cin >> n >> m && n && m) {\n        rep(i, 3) {\n            tray[i] = 0;\n            int k, num;\n            std::cin >> k;\n            rep(j, k) {\n                std::cin >> num;\n                tray[i] |= 1 << (num - 1);\n            }\n        }\n\n        int res = min(func(tray[0], tray[1], tray[2]),\n                      func(tray[2], tray[1], tray[0]));\n        std::cout << (res <= m ? res : -1) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<vvi,int> pvi;\nbool ok(vvi a){\n  return (a[0].empty()&&a[1].empty()) || (a[1].empty()&&a[2].empty());\n}\nvoid print(vvi a){\n  REP(i,a.size()){\n    printf(\"%d:\",i+1);\n    REP(j,a[i].size()){\n      printf(\"%d \",a[i][j]);\n    }\n    putchar('\\n');\n  }\n    putchar('\\n');\n}\nint solve(vvi a, int m){\n  queue<pvi> que;\n  set<vvi> memo;\n  que.push(pvi(a,0));\n  while(!que.empty()){\n    pvi p = que.front(); que.pop();\n    vvi na = p.first; int nt = p.second;\n    if(nt > m) return -1;\n    if(ok(na)) return nt;\n    if(memo.find(na)!=memo.end()) continue;\n    memo.insert(na);\n    //printf(\"--------------------\\n\");\n    //print(na);\n    REP(i,3)REP(j,3){\n      if(abs(i-j)== 1 && na[i].size() && (na[j].empty() || na[i].back() > na[j].back())){\n        vvi nna = na;\n        nna[j].push_back(nna[i].back());\n        nna[i].pop_back();\n        if(!memo.count(nna)) que.push(pvi(nna,nt+1));\n        //print(nna);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m){\n    cin.ignore();\n    vvi a(3);\n    REP(i,3){\n      int ps; cin>>ps;\n      while(ps--){\n        int tmp;\n        cin>>tmp;\n        a[i].push_back(tmp);\n      }\n    }\n    cout<<solve(a,m)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\nconst int NONE = -1;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u2 = get_last(B);\n        int v2 = get_last(C);\n        if ( u2 > v2 ) {\n            int ret2 = solve( A, remove_last(B), C | u2, turns + 1 );\n            if ( ret2 != NONE ) return ret2;\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == NONE && ret2 == NONE ) {\n            cout << -1 << endl;\n        } else if ( ret1 != NONE && ret2 != NONE ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != NONE ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != NONE ) {\n            cout << ret2 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n    int n,m;\n    while(1){\n        cin >> n >> m;\n        if(n == 0 && m == 0)break;\n        vector<char> cup(n,0);\n        bool flag = true;\n        rep(i,3){\n            int n1;\n            cin >> n1;\n            rep(j,n1){\n                int n2;\n                cin >> n2;\n                n2--;\n                cup[n2] = i;\n            }\n        }//入力ここまで\n        queue<vector<char>> que;\n        que.push(cup);\n        map<vector<char>,int> mp;\n        mp[cup] = 0;\n        while(que.size()!=0){\n            cup = que.front();\n            que.pop();\n            //rep(i,cup.size())cout << cup[i];\n            //cout << endl;\n            int bigger[3];\n            int maxcount = 0;\n            bool tray[3] ={true,true,true};\n            if(cup.size() == count(cup.begin(),cup.end(),0) ||cup.size() == count(cup.begin(),cup.end(),2)){\n                cout << mp[cup] << endl;\n                flag = false;\n                break;\n            }\n            rep(i,n){\n                int i2 = n-i-1;\n                rep(j,3){\n                    if(tray[j] == true && cup[i2] == j){\n                        tray[j] = false;\n                        bigger[maxcount] = i2;\n                        maxcount++;\n                        break;\n                    }\n                }\n                if(maxcount == 3)break;\n            }\n            int movecount = mp[cup] + 1;\n            if(movecount > m) break;\n            if(cup[bigger[0]]-1 >= 0){\n                cup[bigger[0]]--;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]++;\n            }\n            if(cup[bigger[0]]+1 <= 2){\n                cup[bigger[0]]++;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]--;\n            }\n            if(maxcount >= 2){\n                if(cup[bigger[1]]-1 >= 0 && cup[bigger[1]]-1 != cup[bigger[0]]){\n                    cup[bigger[1]]--;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]++;\n                }\n                else if(cup[bigger[1]]+1 <= 2 && cup[bigger[1]]+1 != cup[bigger[0]]){\n                    cup[bigger[1]]++;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]--;\n                }\n            }\n        }\n        if(flag) cout << \"-1\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint calc(vector<int> cup, int m)\n{\n    int cnt = 0;\n    while (1) {\n        int i = cnt%2, j = i+1;\n        int p = 1;\n        while (p <= max(cup[i], cup[j])) p <<= 1;\n        p >>= 1;\n        if (!p) break;\n        cup[i] ^= p;\n        cup[j] ^= p;\n        cnt++;\n        if (cnt > m) return cnt;\n    }\n\n    return cnt;\n}\n\nint main()\n{\n    while (1) {\n        int n, m; cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        vector<int> cup(3);\n        loop (3, i) {\n            int c; cin >> c;\n            while (c--) {\n                int v; cin >> v;\n                cup[i] |= 1 << v--;\n            }\n        }\n        int ans = calc(cup, m);\n        swap(cup[0], cup[2]);\n        ans = min(ans, calc(cup, m));\n        cout << (ans <= m ? ans : -1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nstruct State {\n  int A,B,C;\n  State(int a,int b,int c):A(a),B(b),C(c){}\n};\n\ntypedef pair<State,int> ps;\n\nconst int INF = 1 << 28;\nint n,m,ans;\n\nvoid rec(int A, int B, int C, int k) {\n  if (k == m) return;\n  if (A == (1<<n)-1 || C == (1<<n)-1) ans = min(ans,k);\n  int ta = -1, tb = -1, tc = -1;\n  rep (i,n) {\n    if (A >> i & 1) ta = i;\n    if (B >> i & 1) tb = i;\n    if (C >> i & 1) tc = i;\n  }\n  if (A != 0 && ta > tb) rec(A & ~(1<<ta), B | (1<<ta), C, k+1);\n  if (B != 0) {\n    if (tb > ta) rec(A | (1<<tb), B & ~(1<<tb), C, k+1);\n    if (tb > tc) rec(A, B & ~(1<<tb), C | (1<<tb), k+1);\n  }\n  if (C != 0 && tc > tb) rec(A, B | (1<<tc), C & ~(1<<tc), k+1);\n}\n\nvoid solve() {\n  vector<int> v(3,0);\n  int cnt,tmp;\n  rep (i,3) {\n    cin>>cnt;\n    rep (j,cnt) {\n      cin>>tmp;\n      --tmp;\n      v[i] |= (1<<tmp);\n    }\n  }\n  ans = INF;\n  rec(v[0],v[1],v[2],0);\n  if (ans == INF) ans = -1;\n  printf(\"%d\\n\", ans);\n}\n\nint main() {\n  while (cin>>n>>m,n) {\n    solve();\n  }\n  return 0;\n}\n\n// void solve() {\n//   vector<int> v(3,0);\n//   int cnt,tmp;\n//   rep (i,3) {\n//     cin>>cnt;\n//     rep (j,cnt) {\n//       cin>>tmp;\n//       --tmp;\n//       v[i] |= (1<<tmp);\n//     }\n//     //cout << v[i] << endl;\n//   }\n  \n//   queue<ps> q;\n//   q.push(ps(State(v[0],v[1],v[2]), 0));\n//   while (!q.empty()) {\n//     ps p = q.front(); q.pop();\n//     State s = p.first;\n//     int k = p.second, ta = -1, tb = -1, tc = -1;\n//     if (s.A == (1<<n)-1 || s.C == (1<<n)-1) {\n//       //printf(\"%d:%d:%d \", s.A, s.B, s.C);\n//       printf(\"%d\\n\", k); return;\n//     }\n//     if (k == m) continue;\n//     rep (i,n) {\n//       if (s.A >> i & 1) ta = i;\n//       if (s.B >> i & 1) tb = i;\n//       if (s.C >> i & 1) tc = i;\n//     }\n//     if (s.A != 0 && ta > tb) q.push(ps(State(s.A & ~(1<<ta), s.B | (1<<ta), s.C), k+1));\n//     if (s.B != 0) {\n//       if (tb > ta) q.push(ps(State(s.A | (1<<tb), s.B & ~(1<<tb), s.C), k+1));\n//       if (tb > tc) q.push(ps(State(s.A, s.B & ~(1<<tb), s.C | (1<<tb)), k+1));\n//     }\n//     if (s.C != 0 && tc > tb) q.push(ps(State(s.A, s.B | (1<<tc), s.C & ~(1<<tc)), k+1));\n//   }\n//   puts(\"-1\");\n// }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint bit(int a,int b,int c){\n    if(!a & !b){\n        return 0;\n    }\n    if(c & 1){\n        return (bit(a>>1,b>>1,c>>1));\n    }\n    if(b & 1){\n        return (bit(c>>1,b>>1,a>>1)+bit((a|b|c)>>1,0,0)+1);\n    }\n    if(a & 1){\n        return (bit(a>>1,b>>1,c>>1)+2*bit((a|b|c)>>1,0,0)+2);\n    }\n}\nint main(void){\n    int n,m,data[3];\n    while(1){\n        cin>>n>>m;\n        if(n==0 && m==0){\n            return 0;\n        }\n        for(int i=0;i<3;i++){\n            int k;\n            cin>>k;\n            data[i]^=data[i];\n            for(int j=0;j<k;j++){\n                int num;\n                cin>>num;\n                data[i]|=1 << --num;\n            }\n        }\n        int ans=min(bit(data[0],data[1],data[2]),bit(data[2],data[1],data[0]));\n        if(ans<=m){\n            cout<<ans<<endl;\n        }else{\n            cout<<-1<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\n\nint main() {\n  int input, height, i, j;\n  int n, m;\n  int turns_left, turns_right;\n  int position, d;\n\n  while (true){\n    cin >> n;\n    cin >> m;\n\n    if (n == 0 && m == 0) { break; }\n\n    vector<int> cups(15);\n\n    // input\n    for (i = 0; i < 3; i++) {\n      cin >> height;\n      for (j = 0; j < height; j++) {\n        cin >> input;\n        cups.at(input - 1) = i;\n      }\n    }\n\n    // left\n    position = 0;\n    turns_left = 0;\n    for (i = 0; i < n; i++) {\n      d = position - cups.at(i);\n      if (d == 0) {\n      } else if (d == 1 || d == -1) {\n        turns_left += static_cast<int>(pow(3, (n - 1) - i));\n        if (position == 0) {\n          position = 2;\n        } else if (position == 2) {\n          position = 0;\n        }\n      } else if (d == 2 || d == -2) {\n        turns_left += 2 * static_cast<int>(pow(3, (n - 1) - 1));\n      }\n    }\n\n    // right\n    position = 2;\n    turns_right = 0;\n    for (i = 0; i < n; i++) {\n      d = position - cups.at(i);\n      if (d == 0) {\n      } else if (d == 1 || d == -1) {\n        turns_right += static_cast<int>(pow(3, (n - 1) - i));\n        if (position == 0) {\n          position = 2;\n        } else if (position == 2) {\n          position = 0;\n        }\n      } else if (d == 2 || d == -2) {\n        turns_right += 2 * static_cast<int>(pow(3, (n - 1) - 1));\n      }\n    }\n\n    cout << (min(turns_left, turns_right) <= m ? min(turns_left, turns_right) : -1) << endl;\n\n    cups.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n\nint n, m, cnt, a[16], b[16];\nbool flag;\n\nvoid move(int num, int dest, int* a);\n\nint main() {\n\t\n\twhile (1) {\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0)break;\n\n\t\tint numt, tmp;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcin >> numt;\n\t\t\tfor (int j = 0; j < numt; j++) {\n\t\t\t\tcin >> tmp;\n\t\t\t\ta[tmp] = i;\n\t\t\t\tb[tmp] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans1, ans2;\n\n\t\tcnt = 0;\n\t\tflag = true;\n\t\tfor (int num = 1; num <= n; num++) {\n\t\t\tmove(num, 2, a);\n\t\t}\n\t\tif (flag == true) {\n\t\t\tans1 = cnt;\n\t\t} else {\n\t\t\tans1 = -1;\n\t\t}\n\n\t\tcnt = 0;\n\t\tflag = true;\n\t\tfor (int num = 1; num <= n; num++) {\n\t\t\tmove(num, 0, b);\n\t\t}\n\t\tif (flag == true) {\n\t\t\tans2 = cnt;\n\t\t} else {\n\t\t\tans2 = -1;\n\t\t}\n\n\n\t\tint ans;\n\t\tif (ans1 == -1) {\n\t\t\tans = ans2;\n\t\t} else if(ans2 == -1){\n\t\t\tans = ans1;\n\t\t} else {\n\t\t\tans = min(ans1, ans2);\n\t\t}\n\t\t//cout << ans1 << \" \" << ans2 << endl;\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn 0;\n}\n\nvoid move(int num, int dest, int* a) {\n\t\n\tif (cnt > m || flag == false) {\n\t\tflag = false;\n\t\treturn;\n\t}\n\n\tint dist = abs(dest - a[num]);\n\tif (dist == 0) {\n\t\treturn;\n\t} else if (dist == 1) {\n\t\tif (num == n) {\n\t\t\tcnt += 1;\n\t\t\ta[num] = dest;\n\t\t} else {\n\t\t\tint i = 1;\n\t\t\twhile (num + i <= n) {\n\t\t\t\tmove(num + i, 3 - dest - a[num], a);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tcnt += 1;\n\t\t\ta[num] = dest;\n\t\t}\n\t} else if (dist == 2) {\n\t\tif (num == n) {\n\t\t\tcnt += 2;\n\t\t\ta[num] = dest;\n\t\t} else {\n\t\t\tmove(num, 1, a);\n\t\t\tmove(num, dest, a);\n\t\t}\n\t}\n\n\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#define S(n) (int)(pow(3,x-(n)+1)/2)\nusing namespace std;\n\nint main(){\n\tint h[17],a[17],c[17],x,i,n,m,t;\n\twhile(cin>>x>>n,n){\n\t\tfor(i=0;i<3;i++)for(cin>>m;m--;h[t]=i)cin>>t;\n\t\ta[x]=h[x];c[x]=2-h[x];\n\t\tfor(i=x;i>1;i--){\n\t\t\tif(h[i-1]==0){\n\t\t\t\ta[i-1]=a[i];\n\t\t\t\tc[i-1]=c[i]+2+4*S(i);\n\t\t\t}else if(h[i-1]==1){\n\t\t\t\ta[i-1]=c[i]+1+2*S(i);\n\t\t\t\tc[i-1]=a[i]+1+2*S(i);\n\t\t\t}else{\n\t\t\t\ta[i-1]=a[i]+2+4*S(i);\n\t\t\t\tc[i-1]=c[i];\n\t\t\t}\n\t\t}\n\t\tt=min(a[1],c[1]);\n\t\tcout<<t>n?-1:t<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef struct Cup\n{\n\tvector<int>P[3];\n\tint T;\n\tbool operator <(const Cup &a)const{ return T>a.T;};\n}S;\nint N,M;\nbool f[3][3][3][3][3][3][3][3][3][3][3][3][3][3][3];\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&M),N;)\n\t{\n\t\tCup tmp;\n\t\tint i,j,t,q,R=-1;\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=0;i<3;i++)\n\t\t{\n\t\t\tfor(scanf(\"%d\",&t),j=0;j<t;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&q);\n\t\t\t\ttmp.P[i].push_back(q);\n\t\t\t}\n\t\t}\n\n\t\ttmp.T=0;\n\t\tpriority_queue<Cup> Q;\n\t\tQ.push(tmp);\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\ttmp=Q.top();Q.pop();\n\t\t\tint p[15];\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tfor(int j=0;j<tmp.P[i].size();j++)\n\t\t\t\t\tp[tmp.P[i][j]-1]=i;\n\t\t\tif(f[p[0]][p[1]][p[2]][p[3]][p[4]][p[5]][p[6]][p[7]][p[8]][p[9]][p[10]][p[11]][p[12]][p[13]][p[14]])continue;\n\t\t\tif(tmp.T>M)continue;\n\t\t\tif(tmp.P[0].size()==N||tmp.P[2].size()==N)\n\t\t\t{\n\t\t\t\tR=tmp.T;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tfor(int j=-1;j<2;j++)\n\t\t\t\t{\n\t\t\t\t\tif(j&&i+j>=0&&i+j<3&&!tmp.P[i].empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tint tmp1=tmp.P[i].back();\n\t\t\t\t\t\tint tmp2=-1;\n\t\t\t\t\t\tif(!tmp.P[i+j].empty())\n\t\t\t\t\t\t\ttmp2=tmp.P[i+j].back();\n\t\t\t\t\t\tif(tmp1>tmp2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCup ins=tmp;\n\t\t\t\t\t\t\tins.P[i+j].push_back(tmp1);\n\t\t\t\t\t\t\tins.P[i].pop_back();\n\t\t\t\t\t\t\tins.T++;\n\t\t\t\t\t\t\tQ.push(ins);\n\t\t\t\t\t\t\tf[p[0]][p[1]][p[2]][p[3]][p[4]][p[5]][p[6]][p[7]][p[8]][p[9]][p[10]][p[11]][p[12]][p[13]][p[14]]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#define INF 1000000000\nusing namespace std;\nint N,M;\nint po3[20];\nint ary[15000000][2],res[15000000];\n\nvoid pow3(){\n\tint tmpo=1;\n\tfor(int i=0;i<20;i++){\n\t\tpo3[i]=tmpo;\n\t\ttmpo*=3;\n\t}\n}\n\nvoid solv(int m){\n\tint abc[3]={-1,-1,-1},re[2];\n\tint tmp;\n\tfor(int i=0;i<N;i++){\n\t\ttmp=(m/po3[i])%3;\n\t\tabc[tmp]=max(abc[tmp],i);\n\t}\n\tre[0]=re[1]=m;\n\tif(abc[0]>abc[1]){\n\t\tif(abc[0]>=0)re[0]=m+po3[abc[0]];\n\t}\n\telse{\n\t\tif(abc[1]>=0)re[0]=m-po3[abc[1]];\n\t}\n\tif(abc[1]>abc[2]){\n\t\tif(abc[1]>=0)re[1]=m+po3[abc[1]];\n\t}\n\telse{\n\t\tif(abc[2]>=0)re[1]=m-po3[abc[2]];\n\t}\n\tary[m][0]=re[0];\n\tary[m][1]=re[1];\n}\n\nint main(){\n\tpow3();\n\tint hog,piy,cnt,tmp,ress;\n\tqueue<int> que;\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\t\tfor(int i=0;i<po3[N];i++){\n\t\t\tary[i][0]=ary[i][1]=0;\n\t\t\tsolv(i);\n\t\t}\n\t\tfill(res,res+20000000,INF);\n\t\tcnt=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>hog;\n\t\t\tfor(int j=0;j<hog;j++){\n\t\t\t\tcin>>piy;piy--;\n\t\t\t\tcnt+=po3[piy]*i;\n\t\t\t}\n\t\t}\n\n\t\tress=INF;\n\t\twhile(!que.empty()) que.pop();\n\t\tque.push(cnt);\n\t\tres[cnt]=0;\n\t\twhile(!que.empty()){\n\t\t\ttmp=que.front();que.pop();\n\t\t\tif(tmp==0||tmp==po3[N]-1||res[tmp]>M){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(res[ary[tmp][0]]>res[tmp]+1){\n\t\t\t\tres[ary[tmp][0]]=res[tmp]+1;\n\t\t\t\tque.push(ary[tmp][0]);\n\t\t\t}\n\t\t\tif(res[ary[tmp][1]]>res[tmp]+1){\n\t\t\t\tres[ary[tmp][1]]=res[tmp]+1;\n\t\t\t\tque.push(ary[tmp][1]);\n\t\t\t}\n\t\t}\n\t\tress=min(ress,min(res[0],res[po3[N]-1]));\n\t\tif(ress<=M)cout<<ress<<endl;\n\t\telse cout<<-1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\ntypedef pair <int,P> PP;\ntypedef pair <int,PP> PPP;\n\nstatic const double eps = 1e-8;\n\nint bfs(int m,vector<int>& root, map<vector<int>,int>& visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[root] = 0;\n\n\t\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\tif(visited.find(tmp) == visited.end()){\n\t\t\t\t\tvisited[tmp] = cost + 1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tif(visited.find(tmp) == visited.end()){\n\t\t\t\t\tvisited[tmp] = cost + 1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tmap<vector<int>,int> visited;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,sets,visited));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<string>\n#include<climits>\n#include<deque>\n\nusing namespace std;\n\nint k;\nstack<int,vector<int> >A,B,C;\n\nint func(int,string);\n\nint main(void){\nint n,m,ans,s,t;\n\nwhile(cin >> n >> m,n|m){\nwhile(!A.empty())A.pop();\nwhile(!B.empty())B.pop();\nwhile(!C.empty())C.pop();\n\ncin >> s;\nfor(int i=0;i<s;i++){\ncin >> t;\nA.push(t);\n}\ncin >> s;\nfor(int i=0;i<s;i++){\ncin >> t;\nB.push(t);\n}\ncin >> s;\nfor(int i=0;i<s;i++){\ncin >> t;\nC.push(t);\n}\nans=INT_MAX;\nfor(k=1;k<=min(10000,m);k++){\nans=func(0,\"\");\nif(ans!=INT_MAX)break;\n}\nif(ans==INT_MAX)cout << -1 << endl;\nelse cout << ans << endl;\n}\nreturn 0;\n}\n\nint func(int cnt,string p){\n\nif(cnt>k)return INT_MAX;\n\nif(B.empty()&&(C.empty()||A.empty()))\nreturn cnt;\n\nint res=INT_MAX;\n\nif(!A.empty() && A.top()>=B.top() && p!=\"BA\"){\nB.push(A.top());\nA.pop();\nres=min(res,func(cnt+1,\"AB\"));\nA.push(B.top());\nB.pop();\n}\n\nif(!B.empty()){\nif(B.top()>=C.top()&&p!=\"CB\"){\nC.push(B.top());\nB.pop();\nres=min(res,func(cnt+1,\"BC\"));\nB.push(C.top());\nC.pop();\n}\n\nif(B.top()>=A.top()&&p!=\"AB\"){\nA.push(B.top());\nB.pop();\nres=min(res,func(cnt+1,\"BA\"));\nB.push(A.top());\nA.pop();\n}\n}\n\nif(!C.empty() && C.top()>=B.top() && p!=\"BC\"){\nB.push(C.top());\nC.pop();\nres=min(res,func(cnt+1,\"CB\"));\nC.push(B.top());\nB.pop();\n}\n\nreturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint mypow(int x,int n){\n\tint res = 1;\n\twhile(n>0){\t\t\n\t\tif(n & 1) res = res*x;\n\t\tx = x * x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\n\nint conv(vector<int>& sets,int n){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * mypow(3,j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,int n,vector<int>& root,bool* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root,n)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(!visited[(next = conv(tmp,n))]){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(!visited[(next = conv(tmp,n))]){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tbool* visited = new bool[mypow(3,n)]();\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,n,sets,visited));\n\t}\n\t//printf(\"%d %d %d\\n\",mypow(3,0),mypow(3,1),mypow(3,2));\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint pow(int x,int n){\n\tint res = 1;\n\twhile(n>0){\t\t\n\t\tres *= x;\n\t\tif(n & 1) x = x*x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\nint conv(vector<int>& sets){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<=15;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * pow(3,j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,int n,vector<int>& root, int* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n-1;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n-1;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tint* visited = new int[3*pow(3,n) + 1];\n\t\tfill_n(visited,3*pow(3,n) + 1,-1);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,n,sets,visited));\n\t\tdelete[] visited;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint an, bn, cn, a[20], b[20], c[20], total = 0, f = 1;\n\nstruct mm{\n\tchar ch;\n\tint nu;\n};\n\nstruct mm m1, m2;\n\nint judge(int max, int temp){\n\tif(temp + 1 == an + bn + cn)return -1;\n\tif(a[an] == max - temp)return 50 + temp;\n\tif(c[cn] == max - temp)return 100 + temp;\n\tif(b[cn - temp] == max - temp)return judge(max, temp + 1);\n\treturn 0;\n}\n\nint calculation(int min, int max){\n\tint sum;\n\tif(min == max)return 0;\n\tif(min < max)sum = calculation(++min, max) * 3 + 2;\n\treturn sum;\n}\n\nint move(int flag){\n\tint number;\n\tif(flag == 2){  //right\n\t\tnumber = an - m1.nu + 1;\n\t\tfor(int i = 1;i <= number;i++)c[++cn] = a[an--];\n\t}\n\tif(flag == 1){\n\t\tnumber = cn - m1.nu + 1;\n\t\tfor(int i = 1;i <= number;i++)a[++an] = c[cn--];\n\t}\n\t//printf(\"*%d %d %d*\", an, m1.nu, number);\n\ttotal += calculation(0, number);\n\t//printf(\"*%d*\", number);\n\treturn 0;\n}\n\nint sort(int max){\n\tif(m1.ch == m2.ch)return 0;\n\tif(m2.ch == 'b'){\n\t\tif(m1.ch == 'a')c[++cn] = b[bn--], move(2);  //right\n\t\tif(m1.ch == 'c')a[++an] = b[bn--], move(1);\n\t\ttotal++;\n\t}else if(m2.ch == 'a'){\n\t\tif(c[cn - 1] == max - 2){\n\t\t\tint te = an;\n\t\t\tb[++bn] = a[an--], move(1);\n\t\t\tm1.ch = 'a', m1.nu = te;\n\t\t\tc[++cn] = b[bn--], move(2);\n\t\t}else{\n\t\t\tmove(1);\n\t\t}\n\t}else if(m2.ch == 'c'){\n\t\tif(a[an - 1] == max - 2){\n\t\t\tint te = cn;\n\t\t\tb[++bn] = c[cn--], move(2);\n\t\t\tm1.ch = 'c', m1.nu = te;\n\t\t\ta[++an] = b[bn--], move(1);\n\t\t}else{\n\t\t\tmove(2);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint solve(int max){\n\tfor(int i = 1;i <= an;i++){\n\t\tif(a[i] == max)m1.ch = 'a',m1.nu = i;\n\t\tif(a[i] == max - 1)m2.ch = 'a', m2.nu = i;\n\t}\n\tfor(int i = 1;i <= bn;i++){\n\t\tif(b[i] == max)m1.ch = 'b',m1.nu = i;\n\t\tif(b[i] == max - 1)m2.ch = 'b', m2.nu = i;\n\t}\n\tfor(int i = 1;i <= cn;i++){\n\t\tif(c[i] == max)m1.ch = 'c',m1.nu = i;\n\t\tif(c[i] == max - 1)m2.ch = 'c', m2.nu = i;\n\t}\n\tif(f == 1 && m1.ch == 'b'){\n\t\tint vec = 0;  //1 = left \n\t\tif(m2.ch == 'b'){\n\t\t\tint temp = judge(max, 2);\n\t\t\tif(temp == -1)return 0;\n\t\t\tif(temp >= 100){\n\t\t\t\tif(temp % 2)vec = 2;\n\t\t\t\telse vec = 1;\n\t\t\t}else if(temp >= 50){\n\t\t\t\tif(temp % 2)vec = 1;\n\t\t\t\telse vec = 2;\n\t\t\t}\n\t\t}\n\t\tif(vec == 1)a[++an] = b[bn--];\n\t\tif(vec == 2)c[++cn] = b[bn--];\n\t\t\n\t\tif(m2.ch == 'a'){\n\t\t\tif(c[cn] == max - 2){\n\t\t\t\tc[++cn] = a[an--], c[++cn] = b[bn++];\n\t\t\t\ttotal += 7;\n\t\t\t\treturn 0;\n\t\t\t}else if(b[bn - 1] == max - 2){\n\t\t\t\tb[++bn] = b[bn - 1], b[bn - 1] = a[an];\n\t\t\t\ttotal += 3;\n\t\t\t}else if(a[an - 1] == max - 2){\n\t\t\t\ta[++an] = b[bn--];\n\t\t\t\ttotal++;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(m2.ch == 'c'){\n\t\t\tif(a[an] == max - 2){\n\t\t\t\ta[++an] = c[cn--], a[++an] = b[bn++];\n\t\t\t\ttotal += 7;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t//printf(\"*%d*\", total);\n\t\ttotal++;\n\t}\n\tsort(max);\n\t//printf(\"*%d*\", total);\n\t\n\treturn 0;\n}\n\nint main(){\n\tint n, m, max = 0;\n\ta[0] = b[0] = c[0] = 0;\n\twhile(scanf(\"%d %d\",&n, &m)){\n\t\tif(n == 0 && m == 0)break;\n\t\tmax = total = 0, f = 1;\n\t\t\n\t\t\n\t\tscanf(\"%d\", &an);\n\t\tfor(int i = 1;i <= an;i++){\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t\tif(a[i] > max)max = a[i];\n\t\t}\n\t\tscanf(\"%d\", &bn);\n\t\tfor(int i = 1;i <= bn;i++){\n\t\t\tscanf(\"%d\", &b[i]);\n\t\t\tif(b[i] > max)max = b[i];\n\t\t}\n\t\tscanf(\"%d\", &cn);\n\t\tfor(int i = 1;i <= cn;i++){\n\t\t\tscanf(\"%d\", &c[i]);\n\t\t\tif(c[i] > max)max = c[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < n - 1;i++)solve(max - i);\n\t\t\n\t\tprintf(\"%d\\n\", total);\n\t\t//if(total <= m)printf(\"%d\\n\", total);\n\t\t//else printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint mp[15000000];\nint Hash(string s) {\n\tint cnt = 0, t = 1;\n\trep(i, s.size()) {\n\t\tcnt += s[i]*t;\n\t\tt *= 3;\n\t}\n\treturn cnt;\n}\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tmemset(mp, 0, sizeof(mp));\n\t\tstring in(n, 0);\n\t\trep(i, 3) {\n\t\t\tint len; scanf(\"%d\", &len);\n\t\t\trep(j, len) {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tin[--a] = i;\n\t\t\t}\n\t\t}\n\t\tqueue<string>que;\n\t\tmp[Hash(in)] = 1;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tstring u = que.front(); que.pop();\n\t\t\tif (u == string(n, 0) || u == string(n, 2)) {\n\t\t\t\tprintf(\"%d\\n\", mp[Hash(u)] - 1);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (mp[Hash(u)] > m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tint fi = u.rfind(i, n - 1), fj = u.rfind(j, n - 1);\n\t\t\t\tif (fi == -1 || fi < fj)continue;\n\t\t\t\tstring v = u;\n\t\t\t\tv[fi] = j;\n\t\t\t\tif (!mp[Hash(v)]) {\n\t\t\t\t\tmp[Hash(v)] = mp[Hash(u)] + 1;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nclass P{\n        public:\n        int cnt;\n        stack< int > S[3];\n};\n\nint main(){\n        int n,m;\n        while(scanf(\"%d%d\",&n,&m),(n|m)){\n                P f;\n                for(int i = 0;i < 3; i++){\n                        int x;\n                        scanf(\"%d\",&x);\n                        for(int j = 0; j < x; j++){\n                                int tmp;\n                                scanf(\"%d\",&tmp);\n                                f.S[i].push(tmp);\n                        }\n                }\n                f.cnt = 0;\n                queue< P > Q;\n                Q.push(f);\n                bool flg = true;\n                while( !Q.empty()){\n                        P p = Q.front();Q.pop();\n                        if(p.cnt > m){\n                                flg = false;\n                                break;\n                        }\n                        bool h = false;\n                        for(int i = 0; i < 3; i++){\n                                if(i == 1)continue;\n                                if(p.S[i].size() == n){\n                                        printf(\"%d\\n\",p.cnt);\n                                        h = true;\n                                }\n                        }\n                        if( h ){\n                                break;\n                        }\n                        int top0 = (p.S[0].size()>0)?p.S[0].top() : 0;\n                        int top1 = (p.S[1].size()>0)?p.S[1].top() : 0;\n                        int top2 = (p.S[2].size()>0)?p.S[2].top() : 0;\n                        int copy0 = top0 , copy1 = top1 , copy2 = top2;\n                        P sub;\n                        sub.cnt = p.cnt+1;\n                        if(top0 < top1){\n                                p.S[1].pop();\n                                p.S[0].push(top1);\n                                for(int i = 0; i < 3; i++)sub.S[i] = p.S[i];\n                                Q.push(sub);\n                                p.S[0].pop();\n                                p.S[1].push(copy1);\n                        }\n                        else {\n                                p.S[0].pop();\n                                p.S[1].push(top0);\n                                for(int i = 0; i < 3; i++)sub.S[i] = p.S[i];\n                                Q.push(sub);\n                                p.S[1].pop();\n                                p.S[0].push(copy0);\n                        }\n                        if(top1 < top2){\n                                p.S[2].pop();\n                                p.S[1].push(top2);\n                                for(int i = 0;i < 3; i++)sub.S[i] = p.S[i];\n                                Q.push(sub);\n                                p.S[1].pop();\n                                p.S[2].push(copy2);\n                        }\n                        else {\n                                p.S[1].pop();\n                                p.S[2].push(top1);\n                                for(int i = 0; i < 3; i++)sub.S[i] = p.S[i];\n                                Q.push(sub);\n                                p.S[2].pop();\n                                p.S[1].push(copy1);\n                        }\n                }\n                if( !flg )puts(\"-1\");\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nusing M_BOOL = bool;\n#define M_TRUE (true)\n#define M_FALSE (false)\n#define DIVISOR (1000000007)\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = M_TRUE;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n#define     MAX_NUM_CUPS    (15)\n\ntypedef struct {\n    BYTE    abyPos[MAX_NUM_CUPS];\n    DWORD   dwDepth;\n} CUP_STATE;\n\nstatic bool s_abIsVisited[15000000];\n\nstatic DWORD getIdx(CUP_STATE *pstState, DWORD dwCupNum)\n{\n    DWORD dwRetVal = 0;\n    DWORD dwMultiplier = 1;\n    for (DWORD dwIdx = 0; dwIdx < dwCupNum; dwIdx++) {\n        dwRetVal += pstState->abyPos[dwIdx] * dwMultiplier;\n        dwMultiplier *= 3;\n    }\n    return dwRetVal;\n}\n\nstatic CUP_STATE s_stGoalState1;\nstatic CUP_STATE s_stGoalState2;\n\nstatic bool detectGoal(CUP_STATE *pstState)\n{\n    if (0 == memcmp(&s_stGoalState1.abyPos, pstState->abyPos, sizeof(pstState->abyPos))) {\n        return true;\n    }\n    if (0 == memcmp(&s_stGoalState2.abyPos, pstState->abyPos, sizeof(pstState->abyPos))) {\n        return true;\n    }\n    return false;\n}\n\n\n/**\n *  次の状態遷移\n */\nstatic void visitNext(\n    queue<CUP_STATE> &queSearch, \n    const CUP_STATE *pstCurState,\n    DWORD dwMoveCup,\n    DWORD dwNextPos,\n    DWORD dwCupNum)\n{\n    CUP_STATE stNextState = *pstCurState;\n    stNextState.abyPos[dwMoveCup] = dwNextPos;          \n    stNextState.dwDepth = pstCurState->dwDepth + 1;     \n    SDWORD lNextIdx = getIdx(&stNextState, dwCupNum);\n    if (!s_abIsVisited[lNextIdx]) {\n        s_abIsVisited[lNextIdx] = true;\n        queSearch.push(stNextState);                \n    }\n}\n\n\nstatic SDWORD solveBfs(\n    CUP_STATE *pstStartState,\n    DWORD dwCupNum,\n    SDWORD lIterMax)\n{\n    queue<CUP_STATE> queSearch;\n    memset(s_abIsVisited, 0, sizeof(s_abIsVisited));\n\n    s_abIsVisited[getIdx(pstStartState, dwCupNum)] = true;\n    queSearch.push(*pstStartState);\n\n    while(0 < queSearch.size()) {\n        auto state = queSearch.front();\n        queSearch.pop();\n\n        if (lIterMax < state.dwDepth) {\n            return -1;\n        }\n        if (detectGoal(&state)) {\n            return state.dwDepth;\n        }\n\n        DWORD dwTop_A = 0, dwTop_B = 0, dwTop_C = 0;\n\n        for (DWORD dwIdx = 0; dwIdx < dwCupNum; dwIdx++) {\n            if (state.abyPos[dwIdx] == 0) {\n                dwTop_A = max(dwTop_A, dwIdx+1);\n            }\n            if (state.abyPos[dwIdx] == 1) {\n                dwTop_B = max(dwTop_B, dwIdx+1);\n            }\n            if (state.abyPos[dwIdx] == 2) {\n                dwTop_C = max(dwTop_C, dwIdx+1);\n            } \n        }\n\n        if (dwTop_A < dwTop_B) {\n            /* B->A */\n            visitNext(queSearch, &state, dwTop_B-1, 0, dwCupNum);\n        } else if (dwTop_B < dwTop_A) {\n            /* A->B */\n            visitNext(queSearch, &state, dwTop_A-1, 1, dwCupNum);\n        }\n        if (dwTop_B < dwTop_C) {\n            /* C->B */\n            visitNext(queSearch, &state, dwTop_C-1, 1, dwCupNum);\n        } else if (dwTop_C < dwTop_B) {\n            /* B->C */\n            visitNext(queSearch, &state, dwTop_B-1, 2, dwCupNum);\n        }\n    }\n    return -1;\n}\n\n\nint main()\n{\n    for (;;) {\n        SQWORD sqInput_n = inputSDWORD();\n        SQWORD sqInput_m = inputSQWORD();\n\n        if ((0 == sqInput_n) && (0 == sqInput_m)) {\n            break;\n        }\n\n        CUP_STATE stCupState;\n\n        memset(&stCupState, 0, sizeof(stCupState));\n\n        for (DWORD dwTrayIdx = 0; dwTrayIdx < 3; dwTrayIdx++) {\n            SQWORD sqInput_nn = inputSQWORD();\n            for (DWORD dwCupIdx = 0; dwCupIdx < sqInput_nn; dwCupIdx++) {\n                SDWORD lInput_Cup = inputSQWORD();\n                stCupState.abyPos[lInput_Cup - 1] = dwTrayIdx;\n            }\n            stCupState.dwDepth = 0;\n        }\n        for (DWORD dwCupIdx = 0; dwCupIdx < sqInput_n; dwCupIdx++) {\n            s_stGoalState1.abyPos[dwCupIdx] = 0;\n            s_stGoalState2.abyPos[dwCupIdx] = 2;\n        }\n        SDWORD lAns = solveBfs(&stCupState, sqInput_n, sqInput_m);\n\n        printf(\"%d\\n\", lAns);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <tr1/unordered_map>\nusing namespace std;\n\nint n;\n\nint goal = 0;\n\ntypedef int P ;\n\n\n\nP Q[30];\n\nint view(int bit){\n\tvector<int> s[3];\n\tfor(int i = 0 ; i < n ; i++)\n\t\ts[bit>>(i*2)&3].push_back(i);\n\tfor(int i = 0 ; i < 3 ; i++){\n\t\tcout << \"]\";\n\t\tfor(int j = 0 ; j < s[i].size() ; j++)\n\t\t\tcout << s[i][j];\n\t\tcout << endl;\n\t}\n}\n\nint main(){\n\tint m;\n\twhile(cin >> n >> m && n){\n\t\tint init = 0;\n\t\tfor(int i = 0 ; i < n ; i++) goal |= 2 << (i*2);\n\t\t\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tint t,a; cin >> t;\n\t\t\twhile(t--){cin >> a; a--; init |= (i) << (2*a); }\n\t\t}\n\t\ttr1::unordered_map<int,int> done;\n\t\tint head = 0 , size = 0;\n\t\tQ[size++] = init;\n\t\tdone[init] = 0;\n\t\t\n\t\twhile(head != size){\n\t\t\tint &stat = Q[head++];\n\t\t\tint &tim = done[stat];\n\t\t\tif(tim > m) break;\n\t\t\tif(stat == goal || stat == 0){ cout << tim << endl; goto hoge;}\n\t\t\tint mi[3] = {-1,-1,-1};\n\t\t\tfor(int i = n-1 ; i >= 0 ; i--){\n\t\t\t\tint num = stat>>(i*2)&3;\n\t\t\t\tif(mi[num]==-1)mi[num] = i;\n\t\t\t}\n\n\t\t\tfor(int from = 0 ; from < 3 ; from++){\n\t\t\t\tfor(int to = 0 ; to < 3 ; to++){\n\t\t\t\t\tif ( !( (from == 0 && to == 2) || (from == 2 && to == 0) ) && from != to && mi[from] != -1 && (mi[to] == -1 || mi[from] > mi[to]) ){\n\t\t\t\t\t\tint next = (stat & ~(3<<(2*mi[from]))) | (to<<(2*mi[from]));\n\t\t\t\t\t\tif(!done.count(next))Q[size++] = next , done[next] = tim+1;\n\t\t\t\t\t\thead %= 30;\n\t\t\t\t\t\tsize %= 30;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\thoge:;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 3;\nconst int INF = 15000001;\n\nclass S{\npublic:\n  int t[N+10], cost;\n  S(){}\n  S(int a, int b, int c, int cost) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n\nint n, m, ans;\n\nint calc(S s, int pres, int pret){\n  if(ans <= s.cost) return INF;\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  if(s.cost == m) return INF;\n  int res = INF;\n  int tmp[N+10];\n  fill(tmp, tmp+N, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<N;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      if(abs(i-j) != 1) continue;\n      if(i == pret && j == pres) continue;\n      if(tmp[i] > tmp[j]){\n        S t = s;\n        t.t[i] &= ~(1 << tmp[i]);\n        t.t[j] |= 1 << tmp[i];\n        t.cost++;\n        res = min(res, calc(t, i, j));\n        ans = min(ans, res);\n      }\n    }\n  }\n  return res;\n}\n\nint solve(S s){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  int res = INF;\n  int tmp[N+10];\n  fill(tmp, tmp+N, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<N;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          ans = min(ans, res);\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[N+10];\n    for(int i=0;i<N;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    ans = INF;\n    cout << solve(S(data[0], data[1], data[2], 0)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 15000001;\n\nclass S{\npublic:\n  int t[3], cost;\n  S(){}\n  S(int a, int b, int c, int cost) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n\nint n, m, ans;\n\nint calc(S s, int pres, int pret){\n  if(ans <= s.cost) return INF;\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  if(s.cost == m) return INF;\n  int res = INF;\n  int tmp[3];\n  fill(tmp, tmp+3, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<3;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n      if(abs(i-j) != 1) continue;\n      if(i == pret && j == pres) continue;\n      if(tmp[i] > tmp[j]){\n        S t = s;\n        t.t[i] &= ~(1 << tmp[i]);\n        t.t[j] |= 1 << tmp[i];\n        t.cost++;\n        res = min(res, calc(t, i, j));\n        ans = min(ans, res);\n      }\n    }\n  }\n  return res;\n}\n\nint solve(S s){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  int res = INF;\n  int tmp[3];\n  fill(tmp, tmp+3, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<3;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<3;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<3;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          ans = min(ans, res);\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[3];\n    for(int i=0;i<3;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    ans = INF;\n    cout << solve(S(data[0], data[1], data[2], 0)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint n, m;\nint bit[3];\n\n// Hc(A,B,C) :=\n//  - minCup ??? C -> Hc(A,B,C-{minCup})\n//  - minCup ??? B -> Ha(A,B-{minCup},C)+1+Hc(A???(B-{minCup}???C,0,0)\n//  - minCup ??? A -> Hc(A-{minCup},B,C)+1+Ha(0,0,(A-{minCup}???B???C))+1+Hc((A-{minCup})???B???C,0,0)\n// Ha(A,B,C) == Hc(C,B,A)\n\nint solve(int A, int B, int C) {\n  if(A == 0 && B == 0) return 0;\n  if(C&1) return solve(A>>1, B>>1, C>>1);\n  if(B&1) return solve(C>>1, B>>1, A>>1) + solve((A|B|C)>>1, 0, 0) + 1;\n  if(A&1) return solve(A>>1, B>>1, C>>1) + 2*(solve((A|B|C)>>1, 0, 0)+1);\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> n >> m, n) {\n    rep(i, 3) {\n      bit[i] = 0;\n      int k; cin >> k;\n      rep(j, k) {\n\tint c; cin >> c; --c;\n\tbit[i] |= 1<<c;\n      }\n    }\n    int ans = min(solve(bit[0], bit[1], bit[2]),\n\t\t  solve(bit[2], bit[1], bit[0]));\n    cout << (ans > m ? -1 : ans) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <map>\n\n#define NOT 100000000\n\nusing namespace std;\n\nint N, M;\n\nmap<vector<stack<int> >, int> mp;\n\nint search(vector<stack<int> > A, int n)\n{\n  //cout << \"ok\" << endl;\n  if  (A[0].size() == N || A[2].size() == N) {\n    return 0;\n  }\n  if (n == M) {\n    return NOT;\n  }\n  int m = NOT;\n  if (A[0].size() != 0 && (A[1].size() == 0 || (A[0].top() > A[1].top()))) {\n    vector<stack<int> > _A = A;\n    _A[1].push(_A[0].top());\n    _A[0].pop();\n    int t;\n    if (mp.find(_A) == mp.end()) {\n      t = search(_A, 0);\n      mp[_A] = t;\n    } else {\n      t = mp[_A];\n    }\n    m = min(m, t + 1);\n  }\n  if (A[1].size() != 0 && (A[2].size() == 0 || (A[1].top() > A[2].top()))) {\n    vector<stack<int> > _A = A;\n    _A[2].push(_A[1].top());\n    _A[1].pop();\n    int t;\n    if (mp.find(_A) == mp.end()) {\n      t = search(_A, 0);\n      mp[_A] = t;\n    } else {\n      t = mp[_A];\n    }\n    m = min(m, t + 1);\n  }\n  if (A[1].size() != 0 && (A[0].size() == 0 || (A[1].top() > A[0].top()))) {\n    vector<stack<int> > _A = A;\n    _A[0].push(_A[1].top());\n    _A[1].pop();\n    int t;\n    if (mp.find(_A) == mp.end()) {\n      t = search(_A, 0);\n      mp[_A] = t;\n    } else {\n      t = mp[_A];\n    }\n    m = min(m, t + 1);\n  }\n  if (A[2].size() != 0 && (A[1].size() == 0 || (A[2].top() > A[1].top()))) {\n    vector<stack<int> > _A = A;\n    _A[1].push(_A[2].top());\n    _A[2].pop();\n    int t;\n    if (mp.find(_A) == mp.end()) {\n      t = search(_A, 0);\n      mp[_A] = t;\n    } else {\n      t = mp[_A];\n    }\n    m = min(m, t + 1);\n  }\n  return m;\n}\n\nint main()\n{\n  while (scanf(\"%d %d \", &N, &M) == 2) {\n    vector<stack<int> >A(3);\n    //mp.clear();\n    if (N == 0 && M == 0) {\n      break;\n    }\n    for (int i = 0; i < 3; i++) {\n      int c;\n      scanf(\"%d \", &c);\n      for (int j = 0; j < c; j++) {\n\tint t;\n\tscanf(\"%d \", &t);\n\tA[i].push(t);\n      }\n    }\n    //cout << \"ok\" << endl;\n    int answer;\n    if ((answer = search(A, 0)) > M) {\n      printf(\"-1\\n\");\n    } else {\n      printf(\"%d\\n\", answer);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\n\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nLL j3[16];\nint cp[20];\nLL L(int s, int e);\nLL C(int s, int e);\nLL R(int s, int e);\n\ninline LL f(int k){\n\treturn j3[k]-1;\n}\n\ninline LL g(int k){\n\treturn (j3[k]-1)/2;\n}\n\nLL L(int s, int e){\n\tif(s==e)return cp[s];\n\tswitch(cp[s]){\n\t\tcase 0:\n\t\t\treturn L(s+1, e);\n\t\tcase 1:\n\t\t\treturn min(L(s+1, e)+g(e-s)+g(e-s+1), min(C(s+1,e)+g(e-s+1), R(s+1, e)+1+f(e-s)));\n\t\tcase 2:\n\t\t\treturn min(L(s+1, e)+1+g(e-s)+g(e-s+1), min(C(s+1, e)+min(g(s-e)+f(s-e+1), 2*g(s-e)+1+g(s-e+1)), R(s+1, e)+f(e-s+1)));\n\t}\t\n}\n\nLL C(int s, int e){\n\tif(s==e){\n\t\tif(cp[s]==1)return 0;\n\t\telse return 1;\n\t}\n\tswitch(cp[s]){\n\t\tcase 0:\n\t\t\treturn min(L(s+1, e)+g(e-s+1), min(C(s+1, e)+2*g(e-s)+1,  R(s+1, e)+1+g(e-s)));\n\t\tcase 1:\n\t\t\treturn C(s+1, e);\n\t\tcase 2:\n\t\t\treturn min(L(s+1, e)+1+g(e-s), min(C(s+1, e)+2*g(e-s)+1, R(s+1, e)+g(e-s+1)));\n\t}\t\n}\n\nLL R(int s, int e){\n\tif(s==e)return 2-cp[s];\n\tswitch(cp[s]){\n\t\tcase 2:\n\t\t\treturn R(s+1, e);\n\t\tcase 1:\n\t\t\treturn min(R(s+1, e)+g(e-s)+g(e-s+1), min(C(s+1,e)+g(e-s+1), L(s+1, e)+1+f(e-s)));\n\t\tcase 0:\n\t\t\treturn min(R(s+1, e), min(C(s+1, e)+min(g(s-e)+f(s-e+1), 2*g(s-e)+1+g(s-e+1)), L(s+1, e)+f(e-s+1)));\n\t}\t\n}\n\n\nint main(){\n\tj3[0] = 1;\n\tREP(i, 15)j3[i+1] = 3*j3[i];\n\twhile(1){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n == 0)return 0;\n\t\tREP(i, 3){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tREP(j, k){\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tcp[t-1] = i;\n\t\t\t}\n\t\t}\n\t\tLL ret = min(L(0, n-1), R(0, n-1));\n\t\tif(ret > m)ret = -1;\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n \nusing namespace std;\n \nconst int N = 3;\nconst int INF = 15000001;\n \nclass S{\npublic:\n  int t[N], cost;\n  S(int a = 0, int b = 0, int c = 0, int cost = 0) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n \nint n, m;\nint ans;\n \nint calc(S s, int pres, int pret){\n  if(ans <= s.cost) return INF;\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  if(s.cost >= m) return INF;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, 0);\n  for(int j=0;j<N;j++){\n    for(int i=n-1;i>=0;i--){\n      if(s.t[j] & 1 << i){\n        tmp[j] = i+1;\n        break;\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i]){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(i == pret && j == pres) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= (~(1 << (tmp[i]-1)));\n          t.t[j] |= (1 << (tmp[i]-1));\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          ans = min(ans, res);\n        }\n      }\n    }\n  }\n  return res;\n}\n \nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[N];\n    for(int i=0;i<N;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    ans = INF;\n    int res = calc(S(data[0], data[1], data[2], 0), -1, -1);\n    cout << (res == INF ? -1 : res) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<stack>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n    int dep,lastmove[2],s[3][15],top[15];\n    Data(){\n        for(int i=0;i<3;i++){\n            top[i] = -1;\n        }\n    }\n};\nbool memo[14348908] = {};\n\nint int_pow(int n,int m){\n    int ans = 1;\n    while(m--){\n        ans *= n;\n    }\n    return ans;\n}\n\nint main(){\n    int hoge,n;\n    while(cin>>hoge>>n,n || hoge){\n        for(int i=0;i<14348908;i++) memo[i] = false;\n        Data q_c,q_d,first;\n        int m,input,nt,cup,cntempty,state,nowdep;\n\t\tbool flag;\n        int situ[2] = {-1,1};\n        queue<Data> q;\n        for(int i=0;i<3;i++){\n            cin>>m;\n            for(int j=0;j<m;j++){\n                cin>>input;\n                first.s[i][first.top[i]+1] = input;\n                first.top[i]++;\n            }\n        }\n        first.dep = 0;first.lastmove[0] = -1;first.lastmove[1] = -1;\n        q.push(first);\n        flag = false;\n        while(!q.empty()){\n            q_c = q.front();\n            q.pop();\n            //printf(\"%d\\n\",q_c.dep);\n            if(q_c.dep%1000 == 0){\n                //printf(\"%d\\n\",q_c.dep);\n            }\n            //for(int i=0;i<3;i++) printf(\"%d \",!q_c.s[i].empty());\n            //puts(\"\");\n            if(q_c.dep == n) break;\n            cntempty = 0;\n            for(int i=0;i<3;i++){\n                if(q_c.top[i] != -1){\n                    if(i == 1){\n                        cntempty = 0;\n                        break;\n                    }\n                    cntempty++;\n                }\n            }\n            if(cntempty == 1){\n                printf(\"%d\\n\",q_c.dep);\n                flag = true;\n                break;\n            }\n            state = 0;\n            for(int i=0;i<3;i++){\n                for(int j=0;j<=q_c.top[i];j++){\n                    cup = q_c.s[i][j];\n                    state += i*int_pow(3,cup-1);\n                }\n            }\n            if(memo[state]) continue;\n            memo[state] = true;\n            //printf(\"%d\\n\",state);\n            for(int i=0;i<3;i++){\n                for(int j=0;j<2;j++){\n                    nt = i+situ[j];\n                    if(nt<0 || 3<=nt) continue;\n                    q_d = q_c;\n                    if((q_c.lastmove[1]==i && q_c.lastmove[0]==nt)\n                       || q_d.top[i]==-1) continue;\n                    cup = q_d.s[i][q_d.top[i]];\n                    q_d.top[i]--;\n                    if(q_d.top[nt]!=-1 && cup < q_d.s[nt][q_d.top[nt]]) continue;\n                    q_d.s[nt][q_d.top[nt]+1] = cup;\n                    q_d.top[nt]++;\n                    q_d.dep++;\n                    q_d.lastmove[0] = i;q_d.lastmove[1] = nt;\n                    q.push(q_d);\n                }\n            }\n        }\n        if(!flag) printf(\"-1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n\nstring def;\n\nint change(string S){\n    int a = 0;\n    for(int i=S.size()-1; i>=0; i--){\n        a *= 3;\n        if(S[i] == 'A') a += 0;\n        else if(S[i] == 'B') a += 1;\n        else a += 2;\n    }\n    return a;\n}\n\nstring change(int a){\n    string S = def;\n    for(int i=0; i<S.size(); i++){\n        if(a%3 == 0) S[i] = 'A';\n        else if(a%3 == 1) S[i] = 'B';\n        else S[i] = 'C';\n        a /= 3;\n    }\n    return S;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n\n    START:\n\n    int n,m;\n    cin >> n >> m;\n    if(n == 0 && m == 0) return 0;\n    string S = \"\";\n    for(int i=0; i<n; i++) S += \" \";\n    def = S;\n    int tmp;\n    cin >> tmp;\n    for(int i=0; i<tmp; i++){\n        int tmp2;\n        cin >> tmp2;\n        tmp2--;\n        S[tmp2] = 'A';\n    }\n    cin >> tmp;\n    for(int i=0; i<tmp; i++){\n        int tmp2;\n        cin >> tmp2;\n        tmp2--;\n        S[tmp2] = 'B';\n    }\n    cin >> tmp;\n    for(int i=0; i<tmp; i++){\n        int tmp2;\n        cin >> tmp2;\n        tmp2--;\n        S[tmp2] = 'C';\n    }\n\n    int ans = INT_MAX;\n    set<int> already;\n    already.insert(change(S));\n    priority_queue<pair<int,int> > que;\n    que.push(MP(INT_MAX, change(S)));\n    while(!que.empty()){\n        int c = INT_MAX - que.top().first;\n        //cout << c << \" \" << que.top().second << endl;\n        if(c > m){\n            cout << -1 << endl;\n            break;\n        }\n\n        S = change(que.top().second);\n        vector<int> A,B,C;\n        for(int i=0; i<S.size(); i++){\n            if(S[i] == 'A') A.push_back(i);\n            else if(S[i] == 'B') B.push_back(i);\n            else C.push_back(i);\n        }\n        if(B.size() == 0 && (A.size() == 0 || C.size() == 0)){\n            cout << c << endl;\n            break;\n        }\n\n        // cout << A.size() << \" \";\n        // for(int i=0; i<A.size(); i++) cout << A[i] << \" \";\n        // cout << endl;\n        // cout << B.size() << \" \";\n        // for(int i=0; i<B.size(); i++) cout << B[i] << \" \";\n        // cout << endl;\n        // cout << C.size() << \" \";\n        // for(int i=0; i<C.size(); i++) cout << C[i] << \" \";\n        // cout << endl;\n\n        if((A.size() > 0 && B.size() > 0 && A.back() > B.back()) || (A.size() > 0 && B.size() == 0)){\n            S[A.back()] = 'B';\n            if(already.count(change(S)) == 0){\n                already.insert(change(S));\n                que.push(MP(INT_MAX-c-1, change(S)));\n            }\n            S[A.back()] = 'A';\n        }\n        if((A.size() > 0 && B.size() > 0 && A.back() < B.back()) || (A.size() == 0 && B.size() > 0)){\n            S[B.back()] = 'A';\n            if(already.count(change(S)) == 0){\n                already.insert(change(S));\n                que.push(MP(INT_MAX-c-1, change(S)));\n            }\n            S[B.back()] = 'B';\n        }\n        if((C.size() > 0 && B.size() > 0 && C.back() > B.back()) || (C.size() > 0 && B.size() == 0)){\n            S[C.back()] = 'B';\n            if(already.count(change(S)) == 0){\n                already.insert(change(S));\n                que.push(MP(INT_MAX-c-1, change(S)));\n            }\n            S[C.back()] = 'C';\n        }\n        if((C.size() > 0 && B.size() > 0 && C.back() < B.back()) || (C.size() == 0 && B.size() > 0)){\n            S[B.back()] = 'C';\n            if(already.count(change(S)) == 0){\n                already.insert(change(S));\n                que.push(MP(INT_MAX-c-1, change(S)));\n            }\n            S[B.back()] = 'B';\n        }\n\n        que.pop();\n        if(que.empty()){\n            cout << -1 << endl;\n            break;\n        }\n    }\n\n    while(!que.empty()) que.pop();\n\n    goto START;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <queue>\nusing namespace std;\n#define F first\n#define S second\nconst int INF=100000000;\n\nint ans;\nunsigned int n,m;\n//vector<stack<int> > goal(3);\n\nstruct state{\n\tstack<int> s[3];\n\tint count,from,to;\n\t/*\n\tstate(stack<int> hoge[3]){\n\t\tfor(int i=0; i<3; ++i){\n\t\t\ts[i]=hoge[i];\n\t\t}\n\t}\n\t*/\n};\n\nvoid bfs(stack<int> si[3],int f,int t){\n\tstate hoge;\n\tfor(int i=0 ;i<3; ++i) hoge.s[i]=si[i];\n\thoge.count=0;\n\thoge.from=f;\n\thoge.to=t;\n\tqueue<state> que;\n\tque.push(hoge);\n\twhile(!que.empty()){\n\t\tstate st=que.front();\n\t\tque.pop();\n\t\t//cout << st.count << endl;\n\t\t//if(st.count>m) continue;\n\t\tif(st.s[0].size()==n||st.s[2].size()==n){\n\t\t\tans=min(ans,st.count);\n\t\t\treturn;\n\t\t}\n\t\tif(!(st.from==1&&st.to==0)&&st.s[0].size()!=0&&(st.s[1].size()==0||st.s[0].top()>st.s[1].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[1].push(ns.s[0].top());\n\t\t\tns.s[0].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=0;\n\t\t\tns.to=1;\n\t\t\tque.push(ns);\n\t\t}\n\t\tif(!(st.from==0&&st.to==1)&&st.s[1].size()!=0&&(st.s[0].size()==0||st.s[1].top()>st.s[0].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[0].push(ns.s[1].top());\n\t\t\tns.s[1].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=1;\n\t\t\tns.to=0;\n\t\t\tque.push(ns);\n\t\t} else if(!(st.from==2&&st.to==1)&&st.s[1].size()!=0&&(st.s[2].size()==0||st.s[1].top()>st.s[2].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[2].push(ns.s[1].top());\n\t\t\tns.s[1].pop();//\n\t\t\t++ns.count;\n\t\t\tns.from=1;\n\t\t\tns.to=2;\n\t\t\tque.push(ns);\n\t\t}\n\t\tif(!(st.from==1&&st.to==2)&&st.s[2].size()!=0&&(st.s[1].size()==0||st.s[2].top()>st.s[1].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[1].push(ns.s[2].top());\n\t\t\tns.s[2].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=2;\n\t\t\tns.to=1;\n\t\t\tque.push(ns);\n\t\t}\n\t}\n}\n\n/*\nvoid dfs(stack<int> s[3],int count,pair<int,int> f){\n\tif(count>m) return;\n\tif(s[0].size()==n||s[2].size()==n){\n\t\tans=min(ans,count);\n\t\treturn;\n\t}\n\t//f.F -->f.S\n\t//01 10 12 21\n\tif(!(f.F==1&&f.S==0)&&s[0].size()!=0&&(s[1].size()==0||s[0].top()>s[1].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[1].push(ns[0].top());\n\t\tns[0].pop();\n\t\tdfs(ns,count+1,pair<int,int>(0,1));\n\t}\n\tif(!(f.F==0&&f.S==1)&&s[1].size()!=0&&(s[0].size()==0||s[1].top()>s[0].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[0].push(ns[1].top());\n\t\tns[1].pop();\n\t\tdfs(ns,count+1,pair<int,int>(1,0));\n\t}\n\tif(!(f.F==2&&f.S==1)&&s[1].size()!=0&&(s[2].size()==0||s[1].top()>s[2].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[2].push(ns[1].top());\n\t\tns[1].pop();\n\t\tdfs(ns,count+1,pair<int,int>(1,2));\n\t}\n\tif(!(f.F==1&&f.S==2)&&s[2].size()!=0&&(s[1].size()==0||s[2].top()>s[1].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[1].push(ns[2].top());\n\t\tns[2].pop();\n\t\tdfs(ns,count+1,pair<int,int>(2,1));\n\t}\n}\n*/\n\nint pow(int a,int b){\n\tint res=1;\n\tfor(int i=0; i<b; ++i){\n\t\tres*=a;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint pow3[16];\n\tfor(int i=1; i<=15; ++i){\n\t\tpow3[i]=pow(3,i)-1;\n\t}\n\twhile(cin >> n >> m){\n\tif(n==0&&m==0) break;\n\t\tans=INF;\n\t\tstack<int> cup[3];\n\t\tfor(int i=0; i<3; ++i){\n\t\t\tint q;\n\t\t\tcin >> q;\n\t\t\tfor(int j=0; j<q; ++j){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tcup[i].push(tmp);\n\t\t\t\t//cout << cup[i].top() << endl;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\t/*\n\t\tdfs(cup,0,pair<int,int>(0,1));\n\t\tdfs(cup,0,pair<int,int>(1,0));\n\t\tdfs(cup,0,pair<int,int>(1,2));\n\t\tdfs(cup,0,pair<int,int>(2,1));\n\t\t*/\n\t\tbfs(cup,0,1);\n\t\tif(ans!=INF)bfs(cup,1,0);\n\t\tif(ans!=INF)bfs(cup,1,2);\n\t\tif(ans!=INF)bfs(cup,2,1);\n\t\t//cout << pow3[n] << endl;\n\t\t//cout << ans << endl;\n\t\tif(ans!=INF)ans=min(ans,pow3[n]-ans);\n\t\tif(ans!=INF) cout << ans << endl;\n\t\telse cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <fstream>\n\nusing namespace std;\n\nint main()\n{\n\tint N, M, K;\n\twhile(cin>>N>>M && (N || M)){\n\t\t\n\t\t//iÔÚÉå«¢lªÇÌgCÉ¨¢Ä é©\n\t\tvector<int> v(N+1);\n\t\t\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tcin>>K;\n\t\t\tfor(int j = 0; j < K; j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tv[tmp] = i;\n\t\t\t}\n\t\t}\n\n\t\tvector<int> a(N+1), c(N+1);\n\t\ta[N] = v[N];\tc[N] = 2 - v[N];\n\n\t\tfor(int i = N; i > 1; i--)\n\t\t{\n\t\t\tswitch(v[i-1])\n\t\t\t{\n\t\t\tcase 0:\n\n\t\t\t\ta[i-1] = a[i];\n\t\t\t\tc[i-1] = c[i] + 2 * pow(3.0, N-i+1);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\ta[i-1] = c[i] + pow(3.0, N-i+1);\n\t\t\t\tc[i-1] = a[i] + pow(3.0, N-i+1);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t\n\t\t\t\ta[i-1] = a[i] + 2 * pow(3.0, N-i+1);\n\t\t\t\tc[i-1] = c[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint res = min(a[1], c[1]);\n\t\tif(M < res) res = -1;\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for(int i = 0;i < (n);i++)\n#define min(a, b) ((a) <= (b) ? (a) : (b))\n#define max(a, b) ((a) >= (b) ? (a) : (b))\n\nusing namespace std;\n\ntypedef list<int> tray;\ntypedef vector<tray> tray_set;\n\nint n, m;\n\nvoid print_tray(tray_set &trays) {\n  for(tray& t : trays) {\n    for(int& e : t) {\n      cout << e;\n    }\n    cout << endl;\n  }\n  cout << \"---------------\" << endl;\n}\n\nint solve(tray_set trays, tray_set prev) {\n  rep(count, m) {\n    if(trays[0].size() == n || trays[2].size() == n) return count + 1;\n\n    rep(i, 3) {\n      if(trays[i].empty()) continue;\n\n      rep(j, 3) {\n        if(abs(i - j) >= 2 || i == j) continue;\n\n        if(trays[j].empty() || trays[i].back() > trays[j].back()) {\n          tray_set temp = trays;\n          temp[j].push_back(temp[i].back());\n          temp[i].pop_back();\n          if(temp != prev) {\n            prev = trays;\n            trays = temp;\n            goto outer;\n          }\n        }\n      }\n    }\nouter:\n    ;\n    //print_tray(trays);\n  }\n\n  return -1;\n}\n\nint main() {\n  while(true) {\n    cin >> n >> m;\n    if(n == 0 && m == 0) break;\n\n    tray_set trays(3);\n    rep(i, 3) {\n      int a;\n      cin >> a;\n      rep(j, a) {\n        int b;\n        cin >> b;\n        trays[i].push_back(b);\n      }\n    }\n\n    if(trays[0].size() == n || trays[2].size() == n) {\n      cout << 0 << endl;\n      continue;\n    }\n\n    vector<tray_set> sets;\n    rep(i, 3) {\n      if(trays[i].empty()) continue;\n\n      rep(j, 3) {\n        if(abs(i - j) >= 2 || i == j) continue;\n\n        if(trays[j].empty() || trays[i].back() > trays[j].back()) {\n          tray_set new_trays = trays;\n          new_trays[j].push_back(new_trays[i].back());\n          new_trays[i].pop_back();\n          sets.push_back(new_trays);\n        }\n      }\n    }\n\n    int ans1 = solve(sets[0], trays), ans2 = -1;\n    if(sets.size() > 1) ans2 = solve(sets[1], trays);\n\n    //cout << ans1 << ' ' << ans2 << endl;\n\n    if(ans1 == -1 && ans2 == -1) cout << -1 << endl;\n    else if(ans1 != -1 && ans2 != -1) cout << min(ans1, ans2) << endl;\n    else cout << max(ans1, ans2) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 総数を1000000007（素数）で割った余り\nconst long long mod = 1e9 + 7;\n\nusing ll = long long;\nusing pii  = pair<int, int>;\nusing pll = pair<ll, ll>;\n#define ull unsigned long long\n#define ld long double\n#define vi vector<int>\n#define vll vector<ll>\n#define vc vector<char>\n#define vs vector<string>\n#define vpii vector<pii>\n#define vpll vector<pll>\n\n#define rep(i, n) for (int i = 0, i##_len = (n); i < i##_len; i++)\n#define rep1(i, n) for (int i = 1, i##_len = (n); i <= i##_len; i++)\n#define repr(i, n) for (int i = ((int)(n)-1); i >= 0; i--)\n#define rep1r(i, n) for (int i = ((int)(n)); i >= 1; i--)\n\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define RSORT(x) sort(rall(x));\n#define pb push_back\n#define mp make_pair\n\n#define INF (1e9)\n#define PI (acos(-1))\n#define EPS (1e-7)\n\null gcd(ull a, ull b) { return b ? gcd(b, a % b) : a; }\null lcm(ull a, ull b) { return a / gcd(a, b) * b; }\n\nint main(){\n    while (1) {\n        int n, m;\n        cin >> n >> m;\n        if (n==0 && m==0) break;\n        vector<vi> tr(3);\n        rep(i, 3) {\n            int n2;\n            cin >> n2;\n            rep(i2, n2) {\n                int t;\n                cin >> t;\n                --t;\n                tr[i].pb(t);\n            }\n        }\n        auto ip3 = [] (int e) {\n            int res = 1;\n            rep(i, e) res *= 3;\n            return res;\n        };\n        int ans1 = 0, ans2 = 0;\n        rep(i, n) ans2 += 2 * ip3(i);\n        int ans = INF;\n        vector<bool> d(ip3(n));\n        queue<pair<vector<vi>, int>> q;\n        auto ps = [&] (vector<vi> tr, int cnt) {\n            int res = 0;\n            rep(i, 3) {\n                for (int j : tr[i]) res += i * ip3(j);\n            }\n            if (cnt>m || d[res] || ans!=INF) return;\n            if (res==ans1 || res==ans2) ans = cnt;\n            d[res] = true;\n            q.push({tr, cnt});\n        };\n        const int from[] = {0, 1, 1, 2}, to[] = {1, 0, 2, 1};\n        ps(tr, 0);\n        while (!q.empty()) {\n            auto p = q.front(); q.pop();\n            rep(i, 4) {\n                if (p.first[from[i]].empty()) continue;\n                int f = p.first[from[i]].back();\n                int t = -1;\n                if (!p.first[to[i]].empty()) t = p.first[to[i]].back();\n                if (t > f) continue;\n                p.first[from[i]].pop_back();\n                p.first[to[i]].pb(f);\n                ps(p.first, p.second+1);\n                p.first[to[i]].pop_back();\n                p.first[from[i]].pb(f);\n            }\n        }\n        cout << (ans!=INF?ans:-1) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint topCup(int tray)\n{\n    int count = 0;\n    while (tray > 0)\n    {\n        tray = tray >> 1;\n        count++;\n    }\n    return count;\n}\n\nuint64_t trays2ll(const array<uint16_t, 3> &trays)\n{\n    return ((uint64_t)trays[0] << 32) + ((uint64_t)trays[1] << 16) + ((uint64_t)trays[3] << 0);\n}\n\nconstexpr int list_from[] = {0, 1, 1, 2};\nconstexpr int list_to[] = {1, 0, 2, 1};\n\nint solve(const array<uint16_t, 3> &trays, int m)\n{\n    // 探索したトレイ状態を記録する 同じ状態のトレイを複数回探索することを防ぐ\n    unordered_set<uint64_t> seen;\n\n    // 探索していくトレイ状態を操作した回数を記録\n    queue<int> task_cost;\n    queue<array<uint16_t, 3>> task;\n\n    task.push(trays);\n    task_cost.push(0);\n\n    int ans = -1;\n\n    while (!task.empty())\n    {\n        const int now_m = task_cost.front();\n        task_cost.pop();\n        const auto now_trays = task.front();\n        task.pop();\n\n        // #ifdef DEBUG\n        //         cerr << \"search tray\" << now_m << endl\n        //              << bitset<6>(now_trays[0]) << endl\n        //              << bitset<6>(now_trays[1]) << endl\n        //              << bitset<6>(now_trays[2]) << endl\n        //              << endl;\n        // #endif\n\n        if (now_m >= m)\n            continue;\n\n        // 全カップがトレイAとトレイCのいずれか一方に乗っているなら課題成功\n        if ((now_trays[0] == 0 || now_trays[2] == 0) && now_trays[1] == 0)\n        {\n            ans = now_m;\n            break;\n        }\n\n        // トレイfromからトレイtoにカップを移す\n        for (int i = 0; i < 4; i++)\n        {\n            const int from = list_from[i], to = list_to[i];\n            const int top_from = topCup(now_trays[from]), top_to = topCup(now_trays[to]);\n            // トレイfromが空 or トレイto一番上のコップがトレイfromの一番上のコップより大きい → 操作できない\n            if (top_from == 0 || top_to > top_from)\n                continue;\n\n            array<uint16_t, 3> next_trays = now_trays;\n            const int cup_moved = 1 << (top_from - 1);\n            next_trays[to] += cup_moved;\n            next_trays[from] -= cup_moved;\n\n            if (seen.count(trays2ll(next_trays)))\n                continue;\n\n            task_cost.push(now_m + 1);\n            task.push(next_trays);\n            seen.insert(trays2ll(next_trays));\n        }\n    }\n\n    return ans;\n}\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout << setprecision(10);\n\n    int n, m;\n    while (cin >> n >> m)\n    {\n        if (n == 0)\n            continue;\n        array<uint16_t, 3> trays{};\n        for (auto &&tray : trays)\n        {\n            int n_cup;\n            cin >> n_cup;\n            for (int i = 0; i < n_cup; i++)\n            {\n                int tmp;\n                cin >> tmp;\n                tray |= 1 << (tmp - 1);\n            }\n        }\n        cout << dec << solve(trays, m) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint c[3];\nint n;\nint m;\nint ans;\nint depth;\n\nenum{\n  INIT = 0,\n  AB = 1,\n  BA = 2,\n  BC = 3,\n  CB = 4,\n};\n\nenum{\n  A = 0,\n  B = 1,\n  C = 2\n};\n\n/*\nint buff[1000];\nconst char *str[] ={\n  \"\",\"AB\",\"BA\",\"BC\",\"CB\"\n};\n*/\n\nvoid dfs(int prev){\n  if(depth == m) return;\n  if(depth >= ans) return;\n  if(c[0] == (1 << n) - 1 || c[2] == (1 << n) - 1){\n    ans = depth;\n    return;\n  }\n  /*\n  printf(\"depth = %d: \",depth);\n  REP(i,depth) printf(\"%s \",str[buff[i]]); puts(\"\");\n  printf(\"c[0]=%d, c[1]=%d, c[2]=%d\\n\",c[0],c[1],c[2]);\n  */\n  depth++;\n\n  //A -> B\n  //buff[depth-1] = AB;\n  if(prev != BA && c[A] != 0){\n    int aa = (c[A] & -c[A]);\n    int bb = (c[B] & -c[B]);\n    if(aa < bb || bb == 0){\n      c[A] ^= aa;\n      c[B] ^= aa;\n      dfs(AB);\n      c[B] ^= aa;\n      c[A] ^= aa;\n    }\n  }\n  //B -> A\n  //buff[depth-1] = BA;\n  if(prev != AB && c[B] != 0){\n    int bb = (c[B] & -c[B]);\n    int aa = (c[A] & -c[A]);\n    if(bb < aa || aa == 0){\n      c[B] ^= bb;\n      c[A] ^= bb;\n      dfs(BA);\n      c[A] ^= bb;\n      c[B] ^= bb;\n    }\n  }\n  //B -> C\n  //buff[depth-1] = BC;\n  if(prev != CB && c[B] != 0){\n    int bb = (c[B] & -c[B]);\n    int cc = (c[C] & -c[C]);\n    if(bb < cc || cc == 0){\n      c[B] ^= bb;\n      c[C] ^= bb;\n      dfs(BC);\n      c[C] ^= bb;\n      c[B] ^= bb;\n    }\n  }\n  //C -> B\n  //buff[depth-1] = CB;\n  if(prev != BC && c[C] != 0){\n    int cc = (c[C] & -c[C]);\n    int bb = (c[B] & -c[B]);\n    if(cc < bb || bb == 0){\n      c[C] ^= cc;\n      c[B] ^= cc;\n      dfs(CB);\n      c[B] ^= cc;\n      c[C] ^= cc;\n    }\n  }\n\n  depth--;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&m),n+m){\n    REP(i,3){\n      int t;\n      c[i] = 0;\n      scanf(\"%d\", &t);\n      REP(j,t){\n        int p;\n        scanf(\"%d\",&p);\n        c[i] |= (1 << (n - p));\n      }\n    }\n\n    ans = INT_MAX; depth = 0;\n    dfs(INIT);\n    printf(\"%d\\n\",ans == INT_MAX ? -1 : ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nusing State=vector<stack<int>>;\nstruct Scene{\n\tState state;\n\tint prev_from;\n\tint prev_to;\n\tint count;\n\tScene(State state, int prev_from, int prev_to, int count) : \n\t\tstate(state), prev_from(prev_from), prev_to(prev_to), count(count){}\n};\n\nvoid enqueue(queue<Scene>& scene, Scene& s, int from, int to){\n\tif(s.prev_from==to && s.prev_to==from) return;\n\tif(s.state[from].empty()) return;\n\tif(!s.state[to].empty() && s.state[from].top()<s.state[to].top()) return;\n\tState t;\n\tcopy(s.state.begin(), s.state.end(), back_inserter(t));\n\tt[to].push(t[from].top()); t[from].pop();\n\tscene.push(Scene(t, from, to, s.count+1));\n}\n\nvoid dump(Scene& s){\n\tcout << \"--------------------------------------------------\\n\";\n\tcout << s.prev_from << \"|\" << s.prev_to << \"|\" << s.count << \"\\n\";\n\tState t;\n\tcopy(s.state.begin(), s.state.end(), back_inserter(t));\n\twhile(!t[0].empty()){ cout << t[0].top() << \", \"; t[0].pop(); } cout << \"\\n\";\n\twhile(!t[1].empty()){ cout << t[1].top() << \", \"; t[1].pop(); } cout << \"\\n\";\n\twhile(!t[2].empty()){ cout << t[2].top() << \", \"; t[2].pop(); } cout << \"\\n\";\n\tcout << \"--------------------------------------------------\\n\";\n}\n\nint solve(State init, int m){\n\tqueue<Scene> scene;\n\tscene.push(Scene(init, -1, -1, 0));\n\twhile(!scene.empty()){\n\t\tauto s=scene.front();\n\t\t//dump(s);\n\t\tif(s.state[1].empty() && (s.state[0].empty() || s.state[2].empty())){\n\t\t\treturn s.count;\n\t\t}\n\t\tif(s.count>m) return -1;\n\t\tenqueue(scene, s, 0, 1);\n\t\tenqueue(scene, s, 1, 0);\n\t\tenqueue(scene, s, 1, 2);\n\t\tenqueue(scene, s, 2, 1);\n\t\tscene.pop();\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile(true){\n\t\tint n, m; cin >> n >> m;\n\t\tif(n==0 && m==0) break;\n\t\tState s;\n\t\tfor(int i=0; i<3; ++i){\n\t\t\ts.push_back(stack<int>());\n\t\t\tint x; cin >> x;\n\t\t\tfor(int j=0; j<x; ++j){\n\t\t\t\tint y; cin >> y;\n\t\t\t\ts[i].push(y);\n\t\t\t}\n\t\t}\n\t\tcout << solve(s, m) << \"\\n\";\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint c[3];\nint n;\nint m;\nint ans;\nint depth;\n\nenum{\n  INIT = 0,\n  AB = 1,\n  BA = 2,\n  BC = 3,\n  CB = 4,\n};\n\nenum{\n  A = 0,\n  B = 1,\n  C = 2\n};\n\nint prev[15000000+10];\n\nvoid dfs(){\n  if(depth == m) return;\n  if(depth >= ans) return;\n  if(c[0] == (1 << n) - 1 || c[2] == (1 << n) - 1){\n    ans = depth;\n    return;\n  }\n  depth++;\n\n  if(prev[depth-1] != BA && c[A] != 0){\n    int aa = (c[A] & -c[A]);\n    int bb = (c[B] & -c[B]);\n    if(aa < bb || bb == 0){\n      c[A] ^= aa;\n      c[B] ^= aa;\n      prev[depth] = AB;\n      dfs();\n      c[B] ^= aa;\n      c[A] ^= aa;\n    }\n  }\n  if(prev[depth-1] != AB && c[B] != 0){\n    int bb = (c[B] & -c[B]);\n    int aa = (c[A] & -c[A]);\n    if(bb < aa || aa == 0){\n      c[B] ^= bb;\n      c[A] ^= bb;\n      prev[depth] = BA;\n      dfs();\n      c[A] ^= bb;\n      c[B] ^= bb;\n    }\n  }\n  if(prev[depth-1] != CB && c[B] != 0){\n    int bb = (c[B] & -c[B]);\n    int cc = (c[C] & -c[C]);\n    if(bb < cc || cc == 0){\n      c[B] ^= bb;\n      c[C] ^= bb;\n      prev[depth] = BC;\n      dfs();\n      c[C] ^= bb;\n      c[B] ^= bb;\n    }\n  }\n  if(prev[depth-1] != BC && c[C] != 0){\n    int cc = (c[C] & -c[C]);\n    int bb = (c[B] & -c[B]);\n    if(cc < bb || bb == 0){\n      c[C] ^= cc;\n      c[B] ^= cc;\n      prev[depth] = CB;\n      dfs();\n      c[B] ^= cc;\n      c[C] ^= cc;\n    }\n  }\n  depth--;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&m),n+m){\n    REP(i,3){\n      int t;\n      c[i] = 0;\n      scanf(\"%d\", &t);\n      REP(j,t){\n        int p;\n        scanf(\"%d\",&p);\n        c[i] |= (1 << (n - p));\n      }\n    }\n\n    ans = INT_MAX; depth = 0;\n    prev[0] = INIT;\n    dfs();\n    printf(\"%d\\n\",ans == INT_MAX ? -1 : ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\n#define INF 300000000\n\nusing namespace std;\n\nint n, m;\nint *used;\n\nint main(int argc, char const* argv[])\n{\n\tcin >> n >> m;\n\twhile(n != 0 || m != 0){\n\t\t\tused = new int[int(pow(3, n))];\n\t\t\tfill(used, used + int(pow(3, n)), INF);\n\t\t\tint ini = 0;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tint a;\n\t\t\t\t\tcin >> a;\n\t\t\t\t\tfor(int j = 0; j < a; j++){\n\t\t\t\t\t\t\tint b;\n\t\t\t\t\t\t\tcin >> b;\n\t\t\t\t\t\t\tini += i * int(pow(3, b - 1));\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<int> q;\n\t\t\tq.push(ini);\n\t\t\tused[ini] = 0;\n\t\t\twhile(!q.empty()){\n\t\t\t\t\tint p = q.front(); q.pop();\n\t\t\t\t\tif(p == 0 || p == int(pow(3, n)) - 1){\n\t\t\t\t\t\t\tcout << used[p] << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(used[p] > m){\n\t\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint a[3];\n\t\t\t\t\ta[0] = -1;\n\t\t\t\t\ta[1] = -1;\n\t\t\t\t\ta[2] = -1;\n\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\t\ta[(p % int(pow(3, i + 1)) - p % int(pow(3, i))) / int(pow(3, i))] = i;\n\t\t\t\t\t}\n\t\t\t\t\tif(a[0] != -1){\n\t\t\t\t\t\t\tif(a[1] == -1 || a[0] > a[1]){\n\t\t\t\t\t\t\t\t\tint pp = p;\n\t\t\t\t\t\t\t\t\tpp += int(pow(3, a[0]));\n\t\t\t\t\t\t\t\t\tif(used[pp] == INF){\n\t\t\t\t\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\t\t\t\t\tused[pp] = used[p] + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a[2] != -1){\n\t\t\t\t\t\t\tif(a[1] == -1 || a[2] > a[1]){\n\t\t\t\t\t\t\t\t\tint pp = p;\n\t\t\t\t\t\t\t\t\tpp -= int(pow(3, a[2]));\n\t\t\t\t\t\t\t\t\tif(used[pp] == INF){\n\t\t\t\t\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\t\t\t\t\tused[pp] = used[p] + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a[1] != -1){\n\t\t\t\t\t\t\tif(a[0] == -1 || a[1] > a[0]){\n\t\t\t\t\t\t\t\t\tint pp = p;\n\t\t\t\t\t\t\t\t\tpp -= int(pow(3, a[1]));\n\t\t\t\t\t\t\t\t\tif(used[pp] == INF){\n\t\t\t\t\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\t\t\t\t\tused[pp] = used[p] + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(a[2] == -1 || a[1] > a[2]){\n\t\t\t\t\t\t\t\t\tint pp = p;\n\t\t\t\t\t\t\t\t\tpp += int(pow(3, a[1]));\n\t\t\t\t\t\t\t\t\tif(used[pp] == INF){\n\t\t\t\t\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\t\t\t\t\tused[pp] = used[p] + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tdelete used;\n\t\t\tcin >> n >> m;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing Game = vector<char>;\nusing Tops = map<char, int>;\nconst char ts[3] = {'a', 'b', 'c'};\nstruct Pos {\npublic:\n    int hash;\n    Game g;\n    int rank;\n    Pos(int h, Game g, int rank) : hash(h), g(g), rank(rank) {};\n    bool is_goal() {\n        char f = g[0];\n        bool ok = f == 'a' || f == 'c';\n        if (!ok) return false;\n        for (int i=1;i<g.size();++i) {\n            if (f!=g[i]) return false;\n        }\n        return true;\n    }\n    Tops get_tops() {\n        Tops ts {{'a', -1}, {'b', -1}, {'c', -1}};\n        for (int i = 0; i < g.size(); ++i) {\n            char t = g[i];\n            ts[t] = i;\n        }\n        return ts;\n    }\n};\n\nint to_hash(Game g) {\n    int v = 0;\n    for (char t: g) {\n        int r = ('a' == t) ? 0 : ('b' == t) ? 1 : 2;\n        v = v * 3 + r;\n    }\n    return v;\n}\n\nvoid solve(int N, ll M) {\n    Game game(N);\n    for (int i = 0; i < 3; ++i) {\n        int n;\n        cin >> n;\n        char t = (i == 0) ? 'a' : (i == 1) ? 'b' : 'c';\n        for (int j = 0; j < n; ++j) {\n            int x;\n            cin >> x;\n            game[x - 1] = t;\n        }\n    }\n    vector<char> foots(3500000, 'a');\n    queue<Pos> q;\n    q.emplace(to_hash(game), game, 0);\n    int ans = -1;\n    while (!q.empty()) {\n        Pos pos = q.front();\n        q.pop();\n        if (foots[pos.hash] != 'a') continue;\n        foots[pos.hash] = 'b';\n        if (pos.is_goal()) {\n            if (pos.rank <= M) ans = pos.rank;\n            break;\n        }\n        Tops tops = pos.get_tops();\n        int next_rank = pos.rank + 1;\n        // a -> b\n        if (tops['b'] < tops['a']) {\n            Game a_b = pos.g;\n            a_b[tops['a']] = 'b';\n            q.emplace(to_hash(a_b), a_b, next_rank);\n        }\n        // b -> a\n        if (tops['a'] < tops['b']) {\n            Game b_a = pos.g;\n            b_a[tops['b']] = 'a';\n            q.emplace(to_hash(b_a), b_a, next_rank);\n        }\n        // b -> c\n        if (tops['c'] < tops['b']) {\n            Game b_c = pos.g;\n            b_c[tops['b']] = 'c';\n            q.emplace(to_hash(b_c), b_c, next_rank);\n        } else {\n            Game c_b = pos.g;\n            c_b[tops['c']] = 'b';\n            q.emplace(to_hash(c_b), c_b, next_rank);\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    int n;\n    ll m;\n    while(true) {\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        else solve(n, m);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//00\n#include<iostream>\n#include<algorithm>\n#include<queue>\n\n#define LB(c) ((c)&(~(c)+1))\n\nusing namespace std;\n\nint mem[14348907];\n\nstruct S{\n  int c[3];\n  int t;\n};\n\nint cv(int *a){\n  int r=0;\n  for(int i=0;i<15;i++){\n    r*=3;\n    for(int j=0;j<3;j++){\n      r+=!!(a[j]&1<<i)*j;\n    }\n  }\n  return r;\n}\n\nint main(){\n  fill(mem,mem+14348907,1<<30);\n  queue<S> que;\n  S is[2]={{{(1<<15)-1,0,0},0},{{0,0,(1<<15-1)},0}};\n  que.push(is[0]);\n  que.push(is[1]);\n  while(!que.empty()){\n    S c=que.front();\n    que.pop();\n    int &m=mem[cv(c.c)];\n    if(m!=1<<30)continue;\n    m=c.t;\n    for(int i=0;i<3;i++){\n      for(int j=-1;j<=1;j+=2){\n\tint nc=i+j;\n\tif(0<=nc&&nc<3&&c.c[i]&&(!c.c[nc]||LB(c.c[i])<LB(c.c[nc]))){\n\t  S n=c;\n\t  n.c[nc]|=LB(c.c[i]);\n\t  n.c[i]&=~LB(c.c[i]);\n\t  n.t++;\n\t  que.push(n);\n\t}\n      }\n    }\n  }\n  for(int n,m;cin>>n>>m,n|m;){\n    int is[3]={};\n    for(int i=0;i<3;i++){\n      int k;\n      cin>>k;\n      while(k--){\n\tint c;\n\tcin>>c;\n\tis[i]|=1<<(n-c);\n      }\n    }\n    int ms=((1<<15)-1)^((1<<n)-1);\n    is[0]^=ms;\n    int a=1<<30;\n    a=min(a,mem[cv(is)]);\n    is[0]^=ms;\n    is[2]^=ms;\n    a=min(a,mem[cv(is)]);\n    cout<<((a>m)?-1:a)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\nset< vector< stack<int> > > s;\n\nint saiki(int n,vector< stack<int> > cup){\n    int ret = 2000000000;\n    if(s.find(cup) != s.end()) return ret;\n    else s.insert(cup);\n    if(cup[1].size() == 0 && (cup[0].size() == 0||cup[2].size() == 0)){\n\treturn n;\n    }\n    REP(i,2){\n\tif(cup[i].size() > 0 && (cup[i+1].size() == 0 || cup[i].top() > cup[i+1].top())){\n\t    cup[i+1].push(cup[i].top());\n\t    cup[i].pop();\n\t    ret = min(ret,(saiki(n+1,cup)));\n\t    cup[i].push(cup[i+1].top());\n\t    cup[i+1].pop();\n\t}\n\tif(cup[i+1].size() > 0 && (cup[i].size() == 0 || cup[i].top() < cup[i+1].top())){\n\t    cup[i].push(cup[i+1].top());\n\t    cup[i+1].pop();\n\t    ret = min(ret,saiki(n+1,cup));\n\t    cup[i+1].push(cup[i].top());\n\t    cup[i].pop();\n\t}\n    }\n    return ret;\n} \nint main(){\n    while(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n == 0 && m == 0 ) break;\n//         s = set< vector< stack<int> > >();\n\tvector< stack<int> > cup(3);\n\tREP(i,3){\n\t    int t;\n\t    cin >> t;\n\t    REP(j,t){\n\t\tint temp;\n\t\tcin >> temp;\n\t\tcup[i].push(temp);\n\t    }\n\t}\n\tint ans = saiki(0,cup);\n\tif(ans > m) ans = -1;\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define AB 1\n#define BC 3\n#define INF 1<<29\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint toA (int, int, int );\nint toC (int, int, int );\n\nint toA(int A, int B, int C )\n{\n\tif (!B && !C ) return 0;\n\n\tif (A & 1 ){\n\t\treturn toA(A>>1, B>>1, C>>1 );\n\t} // end if\n\tif (B & 1 ){\n\t\treturn toC(A>>1, B>>1, C>>1 ) + 1 + toA(0, 0, (A|B|C)>>1 );\n\t} // end if\n\tif (C & 1 ){\n\t\treturn toA(A>>1,B>>1,C>>1) + 1 + toC((A|B|C)>>1, 0, 0 ) + 1 + toA(0, 0, (A|B|C)>>1 );\n\t} // end if\n}\n\nint toC(int A, int B, int C )\n{\n\tif (!A && !B ) return 0;\n\n\tif (C & 1 ){\n\t\treturn toC(A>>1, B>>1, C>>1 );\n\t} // end if\n\tif (B & 1 ){\n\t\treturn toA(A>>1, B>>1, C>>1 ) + 1 + toC((A|B|C)>>1, 0, 0 );\n\t} // end if\n\tif (A & 1 ){\n\t\treturn toC(A>>1, B>>1, C>>1 ) + 1 + toA(0, 0, (A|B|C)>>1 ) + 1 + toC((A|B|C)>>1, 0, 0 );\n\t} // end if\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.cup\", \"r\", stdin );\n\n\tint n, m;\n\twhile (scanf (\"%d %d\", &n, &m ), n, m ){\n\t\tint T[3] = {0};\n\t\trep (i, 3 ){\n\t\t\tint in;\n\t\t\tscanf (\"%d\", &in );\n\t\t\twhile (in--){\n\t\t\t\tint cup;\n\t\t\t\tscanf (\"%d\", &cup );\n\t\t\t\tT[i] |= 1<<(cup-1);\n\t\t\t} // end rep\n\t\t} // end rep\n\n\t\tint res = min (toA(T[0],T[1],T[2] ), toC(T[0],T[1],T[2] ) );\n\t\tcout << (res > m ? -1 : res ) << endl;\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint cups[15];\nint n, m;\nconst int A = 0, B = 1, C = 2;\nint pow(int x, int y) {\n    int ret = 1;\n    while (y--) {\n        ret *= x;\n    }\n    return ret;\n}\nint calculate(int from) {\n    int ret = 0;\n    for (int i=0; i<n; ++i) {\n        if (cups[i] == from) {\n            // ignore\n        } else if (cups[i] == B) {\n            ret += pow(3, n-1-i);\n            from = (from == A) ? C : A;\n        } else {\n            ret += 2 * pow(3, n-1-i);\n        }\n    }\n    return ret;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> m, n|m) {\n        for (int i=0; i<3; ++i) {\n            int l; cin >> l;\n            for (int j=0; j<l; ++j) {\n                int cup; cin >> cup;\n                cups[cup-1] = i;\n            }\n        }\n\n        int ret = min(calculate(A), calculate(C));\n        if (ret > m) {\n            ret = -1;\n        }\n        cout << ret << \"\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#define V vector<int>\nusing namespace std;\n\nint main(){\n\tint n,m,k,kk,ans;\n\twhile(cin>>n>>m,(n||m)){\n\t\tV tower(3,0);\n\t\tans=((1<<(n))-1);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>k;\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tcin>>kk;\n\t\t\t\ttower[i]+=(1<<(kk-1));\n\t\t\t}\n\t\t}\n\t\tmap<V,int> done;\n\t\tqueue<V> Q;\n\t\tdone[tower]=0;\n\t\tQ.push(tower);\n\t\twhile(Q.size()){\n\t\t\tV q=Q.front();Q.pop();\n\t\t\tif(done[q]>m)break;\n\t\t\tbool f=0;\n\t\t\tfor(int i=0;i<3;i++)if(i!=1&&q[i]==ans)f=1;\n\t\t\tif(f){\n\t\t\t\tcout<<done[q]<<endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\tV next=q;\n\t\t\t\tint a=q[i],b=q[i+1];\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif((a&(1<<j))||(b&(1<<j))){\n\t\t\t\t\t\tif(a>b)a-=(1<<j),b+=(1<<j);\n\t\t\t\t\t\telse a+=(1<<j),b-=(1<<j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext[i]=a,next[i+1]=b;\n\t\t\t\tif(!done.count(next)){\n\t\t\t\t\tdone[next]=done[q]+1;\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<\"-1\\n\";\n\t\tend:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint calc(int a, int b, int c)\n{\n    if (!a && !b) return 0;\n    if (a&1) return calc(a>>1, b>>1, c>>1) + 2 + 2 * calc((a|b|c)>>1, 0, 0);\n    if (b&1) return calc(c>>1, b>>1, a>>1) + 1 + calc((a|b|c)>>1, 0, 0);\n    return calc(a>>1, b>>1, c>>1);\n}\n\nint main()\n{\n    while (1) {\n        int n, m; cin >> n >> m;\n        int cup[3] = {};\n        loop (3, i) {\n            int c; cin >> c;\n            while (c--) {\n                int v; cin >> v;\n                cup[i] |= 1 << v--;\n            }\n        }\n        int ans = min(calc(cup[0], cup[1], cup[2]), calc(cup[2], cup[1], cup[0]));\n        cout << (ans <= m ? ans : -1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <queue>\nusing namespace std;\n#define F first\n#define S second\nconst int INF=100000000;\n\nint ans;\nunsigned int n,m;\n//vector<stack<int> > goal(3);\n\nstruct state{\n\tstack<int> s[3];\n\tint count,from,to;\n\t/*\n\tstate(stack<int> hoge[3]){\n\t\tfor(int i=0; i<3; ++i){\n\t\t\ts[i]=hoge[i];\n\t\t}\n\t}\n\t*/\n};\n\nvoid bfs(stack<int> si[3],int f,int t){\n\tstate hoge;\n\tfor(int i=0 ;i<3; ++i) hoge.s[i]=si[i];\n\thoge.count=0;\n\thoge.from=f;\n\thoge.to=t;\n\tqueue<state> que;\n\tque.push(hoge);\n\twhile(!que.empty()){\n\t\tstate st=que.front();\n\t\tque.pop();\n\t\t//cout << st.count << endl;\n\t\t//if(st.count>m) continue;\n\t\tif(st.s[0].size()==n||st.s[2].size()==n){\n\t\t\tans=min(ans,st.count);\n\t\t\treturn;\n\t\t}\n\t\tif(!(st.from==1&&st.to==0)&&st.s[0].size()!=0&&(st.s[1].size()==0||st.s[0].top()>st.s[1].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[1].push(ns.s[0].top());\n\t\t\tns.s[0].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=0;\n\t\t\tns.to=1;\n\t\t\tque.push(ns);\n\t\t}\n\t\tif(!(st.from==0&&st.to==1)&&st.s[1].size()!=0&&(st.s[0].size()==0||st.s[1].top()>st.s[0].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[0].push(ns.s[1].top());\n\t\t\tns.s[1].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=1;\n\t\t\tns.to=0;\n\t\t\tque.push(ns);\n\t\t} else if(!(st.from==2&&st.to==1)&&st.s[1].size()!=0&&(st.s[2].size()==0||st.s[1].top()>st.s[2].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[2].push(ns.s[1].top());\n\t\t\tns.s[1].pop();//\n\t\t\t++ns.count;\n\t\t\tns.from=1;\n\t\t\tns.to=2;\n\t\t\tque.push(ns);\n\t\t}\n\t\tif(!(st.from==1&&st.to==2)&&st.s[2].size()!=0&&(st.s[1].size()==0||st.s[2].top()>st.s[1].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[1].push(ns.s[2].top());\n\t\t\tns.s[2].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=2;\n\t\t\tns.to=1;\n\t\t\tque.push(ns);\n\t\t}\n\t}\n}\n\n/*\nvoid dfs(stack<int> s[3],int count,pair<int,int> f){\n\tif(count>m) return;\n\tif(s[0].size()==n||s[2].size()==n){\n\t\tans=min(ans,count);\n\t\treturn;\n\t}\n\t//f.F -->f.S\n\t//01 10 12 21\n\tif(!(f.F==1&&f.S==0)&&s[0].size()!=0&&(s[1].size()==0||s[0].top()>s[1].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[1].push(ns[0].top());\n\t\tns[0].pop();\n\t\tdfs(ns,count+1,pair<int,int>(0,1));\n\t}\n\tif(!(f.F==0&&f.S==1)&&s[1].size()!=0&&(s[0].size()==0||s[1].top()>s[0].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[0].push(ns[1].top());\n\t\tns[1].pop();\n\t\tdfs(ns,count+1,pair<int,int>(1,0));\n\t}\n\tif(!(f.F==2&&f.S==1)&&s[1].size()!=0&&(s[2].size()==0||s[1].top()>s[2].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[2].push(ns[1].top());\n\t\tns[1].pop();\n\t\tdfs(ns,count+1,pair<int,int>(1,2));\n\t}\n\tif(!(f.F==1&&f.S==2)&&s[2].size()!=0&&(s[1].size()==0||s[2].top()>s[1].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[1].push(ns[2].top());\n\t\tns[2].pop();\n\t\tdfs(ns,count+1,pair<int,int>(2,1));\n\t}\n}\n*/\n\nint pow(int a,int b){\n\tint res=1;\n\tfor(int i=0; i<b; ++i){\n\t\tres*=a;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint pow3[16];\n\tfor(int i=1; i<=15; ++i){\n\t\tpow3[i]=pow(3,i)-1;\n\t}\n\twhile(cin >> n >> m){\n\tif(n==0&&m==0) break;\n\t\tans=INF;\n\t\tstack<int> cup[3];\n\t\tfor(int i=0; i<3; ++i){\n\t\t\tint q;\n\t\t\tcin >> q;\n\t\t\tfor(int j=0; j<q; ++j){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tcup[i].push(tmp);\n\t\t\t\t//cout << cup[i].top() << endl;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\t/*\n\t\tdfs(cup,0,pair<int,int>(0,1));\n\t\tdfs(cup,0,pair<int,int>(1,0));\n\t\tdfs(cup,0,pair<int,int>(1,2));\n\t\tdfs(cup,0,pair<int,int>(2,1));\n\t\t*/\n\t\tbfs(cup,0,1);\n\t\tif(ans!=INF)bfs(cup,1,0);\n\t\tif(ans!=INF)bfs(cup,1,2);\n\t\tif(ans!=INF)bfs(cup,2,1);\n\t\t//cout << pow3[n] << endl;\n\t\t//cout << ans << endl;\n\t\tif(ans!=INF)ans=min(ans,pow3[n]-ans);\n\t\tif(ans!=INF) cout << ans << endl;\n\t\telse cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <sstream>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <set>\n#include <tuple>\n\nusing namespace std;\n\n#define ALL(co) co.begin(), co.end()\n#define tpl(...) make_tuple(__VA_ARGS__)\n\ntypedef long long LL;\ntypedef pair<int, int> P; typedef pair<int, P> IP; typedef pair<P, P> PP;\ntypedef vector<int> Array; typedef vector<vector<int> > Array2;\ntypedef vector<LL> LArray; typedef vector<P> PArray; typedef vector<string> SArray;\n\n#define mip(a, b, c) (IP(a, P(b, c)))\n\nconst int INF = 1 << 29;\nconst LL LINF = 1LL << 60;\n\ninline int getInt() { int itiv; return (cin >> itiv, itiv); }\ntemplate <typename T> void readAll(vector<T>& vec) { for (int i = 0, size = vec.size(); i < size; i++) cin >> vec[i]; }\ntemplate <typename T, typename U> void readAll(vector<pair<T, U> >& vec) { for (int i = 0, size = vec.size(); i < size; i++) cin >> vec[i].first >> vec[i].second; }\ntemplate < typename T > inline string toString( const T &a ){ ostringstream oss; oss << a; return oss.str(); };\ninline bool between(int min, int max, int n) { return min <= n && n <= max; }\ninline bool inRange(int begin, int end, int n) { return begin <= n && n < end; }\ninline bool inRange(int size, int n) { return 0 <= n && n < size; }\n\nint dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\nint dr[] = { 0, -1, 0, 1 }, dc[] = { -1, 0, 1, 0 };\n\nint m, n;\n\ninline int bitCount(int i) {\n\ti = i - ((i >> 1) & 0x55555555);\n\ti = (i & 0x33333333) + ((i >> 2) & 0x33333333);\n\ti = (i + (i >> 4)) & 0x0f0f0f0f;\n\ti = i + (i >> 8);\n\ti = i + (i >> 16);\n\treturn i & 0x3f;\n}\n\ninline int MSB32bit(int v) {\n\tif (v == 0) return -1;\n\tv |= (v >> 1);\n\tv |= (v >> 2);\n\tv |= (v >> 4);\n\tv |= (v >> 8);\n\tv |= (v >> 16);\n\treturn bitCount(v) - 1;\n}\n\ninline void movebit(int& a, int& b)\n{\n\tint msb_a = MSB32bit(a);\n\tint msb_b = MSB32bit(b);\n\tif(msb_a > msb_b)\n\t{\n\t\ta -= (1 << msb_a);\n\t\tb += (1 << msb_a);\n\t}\n\telse if(msb_a == msb_b)\n\t\treturn;\n\telse\n\t{\n\t\ta += (1 << msb_b);\n\t\tb -= (1 << msb_b);\n\t}\n}\n\nint main(void)\n{\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m && n)\n\t{\n\t\tint asize, bsize, csize;\n\t\tint as = 0, bs = 0, cs = 0;\n\t\tcin >> asize;\n\t\tfor (int i = 0; i < asize; i++)\n\t\t{\n\t\t\tas |= (1 << (getInt() - 1));\n\t\t}\n\t\tcin >> bsize;\n\t\tfor (int i = 0; i < bsize; i++)\n\t\t{\n\t\t\tbs |= (1 << (getInt() - 1));\n\t\t}\n\t\tcin >> csize;\n\t\tfor (int i = 0; i < csize; i++)\n\t\t{\n\t\t\tcs |= (1 << (getInt() - 1));\n\t\t}\n\n\t\t//a, b, c, count\n\t\t//a->b:0 b->a:1 b->c:2 c->b:3\n\t\tqueue<tuple<int, int, int, int>> que;\n\t\tmap<tuple<int, int, int>, bool> visited;\n\t\tque.push(tpl(as, bs, cs, 0));\n\t\tint ans = -1;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tauto now = que.front(); que.pop();\n\t\t\tint a = get<0>(now);\n\t\t\tint b = get<1>(now);\n\t\t\tint c = get<2>(now);\n\t\t\tint count = get<3>(now);\n\t\t\tif(visited[tpl(a, b, c)]) continue;\n\t\t\tvisited[tpl(a, b, c)] = true;\n\t\t\tif((a == 0 && b == 0) || (b == 0 && c == 0))\n\t\t\t{\n\t\t\t\tans = count;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(count >= m) continue;\n\t\t\tint na = a, nb = b, nc = c;\n\t\t\tmovebit(na, nb);\n\t\t\tif(na != a || nb != b)\n\t\t\t\tque.push(tpl(na, nb, nc, count + 1));\n\t\t\tna = a, nb = b, nc = c;\n\t\t\tmovebit(nb, nc);\n\t\t\tif(nb != b || nc != c)\n\t\t\t\tque.push(tpl(na, nb, nc, count + 1));\n\t\t}\n\n\t\tcout << ans  << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main() {\n    int n,m;\n    while(cin >> n >> m) {\n        if(n == 0 && m == 0) break;\n\n        vector< vector<int> > v;\n        rep(i,3) {\n            int x;\n            cin >> x;\n\n            vector<int> t(x);\n            rep(j,x) cin >> t[j];\n\n            v.push_back(t);\n        }\n\n        queue<pair<vector<vector<int> >, int > > que;\n        que.push(make_pair(v,0));\n        \n        set<vector<vector<int > > > st;\n        st.insert(v);\n        \n        int ans = -1;\n        \n        while(que.size()) {\n            vector< vector<int> > f(que.front().first.begin(),que.front().first.end());\n            int cnt = que.front().second;\n            que.pop();\n        \n            // cout << \"--------------- in queue :: \" << cnt << \"    size:\" << que.size()  << endl;\n            // rep(i,3) {\n            //     rep(j,f[i].size()) cout << f[i][j] << \" \";\n            //     cout << endl;\n            // }\n\n            if(cnt > m) break;\n        \n            bool flag = false;\n            if(f[0].size() == n) {\n                bool ch = true;\n                rep(i,f[0].size()) {\n                    if(f[0][i] != i+1) ch = false;\n                }\n        \n                if(ch) flag = true;\n            }\n        \n            if(f[2].size() == n) {\n                bool ch = true;\n                rep(i,f[2].size()) {\n                    if(f[2][i] != i+1) ch = false;\n                }\n        \n                if(ch) flag = true;\n            }\n        \n            if(flag) {\n                ans = cnt;\n                break;\n            }\n        \n            rep(i,3) {\n                if(f[i].size() == 0) continue;\n\n                for(int j=-1;j<=1;j++) {\n                    int id = i+j;\n                    if(id == i || id < 0 || id > 2) continue;\n\n                    vector< vector<int> > t(f.begin(),f.end());\n\n                    if(t[id].size() == 0) {\n                        int d = t[i].back();\n                        t[i].pop_back();\n                        t[id].push_back(d);\n                    } else {\n                        int d = t[i].back();\n                        int top = t[id].back();\n                        \n                        if(d > top) {\n                            t[i].pop_back();\n                            t[id].push_back(d);\n                        }\n                    }\n\n                    if(st.find(t) == st.end()) {\n                        st.insert(t);\n                        que.push(make_pair(t,cnt+1));\n                    }\n                }\n        \n            }\n        }\n\n        cout << ans << endl;\n        \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 3;\nconst int INF = 15000001;\n\nclass S{\npublic:\n  int t[N], cost;\n  S(){}\n  S(int a, int b, int c, int cost) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n\nint n, m, ans;\n\nint calc(S s, int pres, int pret){\n  if(ans <= s.cost) return INF;\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  if(s.cost >= m) return INF;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<N;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(i == pret && j == pres) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          ans = min(ans, res);\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint solve(S s){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<N;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          ans = min(ans, res);\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[N];\n    for(int i=0;i<N;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    ans = INF;\n    cout << solve(S(data[0], data[1], data[2], 0)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define AB 1\n#define BC 3\n#define INF 1<<29\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint fA (int, int, int );\nint fC (int, int, int );\n\nint fA(int A, int B, int C )\n{\n\tif (!B && !C ) return 0;\n\n\tif (A & 1 ){\n\t\treturn fA(A>>1, B>>1, C>>1 );\n\t} // end if\n\tif (B & 1 ){\n\t\treturn fC(A>>1, B>>1, C>>1 ) + 1 + fA(0, 0, (A|B|C)>>1 );\n\t} // end if\n\tif (C & 1 ){\n\t\treturn fA(A>>1,B>>1,C>>1) + 1 + fC((A|B|C)>>1, 0, 0 ) + 1 + fA(0, 0, (A|B|C)>>1 );\n\t} // end if\n}\n\nint fC(int A, int B, int C )\n{\n\tif (!A && !B ) return 0;\n\n\tif (C & 1 ){\n\t\treturn fC(A>>1, B>>1, C>>1 );\n\t} // end if\n\tif (B & 1 ){\n\t\treturn fA(A>>1, B>>1, C>>1 ) + 1 + fC((A|B|C)>>1, 0, 0 );\n\t} // end if\n\tif (A & 1 ){\n\t\treturn fC(A>>1, B>>1, C>>1 ) + 1 + fA(0, 0, (A|B|C)>>1 ) + 1 + fC((A|B|C)>>1, 0, 0 );\n\t} // end if\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.cup\", \"r\", stdin );\n\tint n, m;\n\twhile (scanf (\"%d %d\", &n, &m ), n, m ){\n\t\tint T[3] = {0};\n\t\trep (i, 3 ){\n\t\t\tint in;\n\t\t\tscanf (\"%d\", &in );\n\t\t\twhile (in--){\n\t\t\t\tint cup;\n\t\t\t\tscanf (\"%d\", &cup );\n\t\t\t\tT[i] |= 1<<(cup-1);\n\t\t\t} // end rep\n\t\t} // end rep\n\t\tint res = min (fA(T[0],T[1],T[2] ), fC(T[0],T[1],T[2] ) );\n\t\tprintf (\"%d\\n\", (res > m ? -1 : res ) );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint rec(int a, int b, int c) {\n  if( !a & !b ) return 0;\n  if( c & 1 ) return( rec(a >> 1, b >> 1, c >> 1) );\n  if( b & 1 ) return( rec(c >> 1, b >> 1, a >> 1) + rec((a|b|c) >> 1, 0, 0) + 1 );\n  if( a & 1 ) return( rec(a >> 1, b >> 1, c >> 1) + 2 * rec((a|b|c) >> 1, 0, 0) + 2);\n}\n\nint main() \n{\n  int n, m, data[3];\n\n  while( cin >> n >> m, m ) {\n    for(int i=0; i<3; i++) {\n      data[i] = 0;\n      int a;\n      cin >> a;\n      for(int j=0; j<a; j++) {\n\tint b;\n\tcin >> b; b--;\n\tdata[i] |= 1 << b;\n      }\n    }\n\n    int ret = min(rec(data[0], data[1], data[2]), rec(data[2], data[1], data[0]));\n    if( ret <= m ) cout << ret << endl;\n    else cout << -1 << endl;\n  }\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint main(){\n  int N, M;\n  while(cin >> N >> M && N){\n    const int goal = (1 << N) - 1;\n    int start[3] = {};\n    int s_top[3] = {};\n    memset(s_top, -1, sizeof(s_top));\n    REP(i, 3){\n      int k; cin >> k;\n      REP(j, k) {\n        int t; cin >> t;\n        start[i] |= 1 << (t - 1);\n        s_top[i] = max(s_top[i], t - 1);\n      }\n    }\n    int ans = INF;\n    for(int iter = 0; iter < 2; iter++){\n      int last_move = iter; // 0 : A<->B, 1 : B<->C\n      int state[3];\n      int top[3];\n      memcpy(state, start, sizeof(state));\n      memcpy(top, s_top, sizeof(top));\n      for(int time = 0; time <= M; time++){\n        if(state[0] == goal || state[2] == goal){\n          ans = min(ans, time);\n          break;\n        }\n        int a, b;\n        if(last_move == 0){\n          last_move = 1;\n          a = 1, b = 2;\n        }else{\n          last_move = 0;\n          a = 0, b = 1;\n        }\n        if(top[a] > top[b]) swap(a, b);\n        assert(top[b] >= 0); // i can move it\n        top[a] = top[b]; \n        state[a] |= 1 << top[a]; // add top[a]\n        state[b] &= ~(1 << top[a]); // remove top[a]\n        // find next top\n        for(int i = top[a] - 1; i >= -1; i--){\n          if(i == -1 || (state[b] >> i & 1)){\n            top[b] = i;\n            break;\n          }\n        }\n      }\n    }\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,-1,0,1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tdouble x;\n                                            \tint y,z,w;\n                                            \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n                \tint zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n      \n\nint san[15];\nbool sumi[14348907]={0};\n\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\nsan[0]=1;\n  \tfor(int i=1;i<=14;i++)san[i]=san[i-1]*3;\nwhile(1){\nint n,m;\n  \tcin>>n>>m;\nif(n==0)exit(0);\nqueue<pa> qu;\nfor(int i=0;i<14348907;i++)sumi[i]=0;\n  \t\n  \tint shoki=0;\n  \tint y;\n  \tcin>>y;\n  \tfor(int i=0;i<y;i++){\n  \t\tint yy;\n  \t\tcin>>yy;\n  \t\tyy--;\n  \t\tshoki+=san[yy]*2;\n  \t}\n  \tcin>>y;\n  \tfor(int i=0;i<y;i++){\n  \t\tint yy;\n  \t\tcin>>yy;\n  \t\tyy--;\n  \t\tshoki+=san[yy];\n  \t}\n  \tcin>>y;\n  \tfor(int i=0;i<y;i++){\n  \t\tint yy;\n  \t\tcin>>yy;\n  \t}\n  \tint owari=0;\n  \tfor(int i=0;i<n;i++)owari+=san[i]*2;\n  \t\n  \tqu.push(mp(shoki,0));\n  \tint ans=-1;\n  \twhile(qu.size()){\n  \t\tpa z=qu.front();\n  \t\tqu.pop();\n  \t\tif(sumi[z.first]) continue;\n  \t\tsumi[z.first]=1;\n  \t\tif(z.first==owari||z.first==0){\n  \t\t//\tcout<<z.second<<endl;\nans=z.second;\n  \t\t\tbreak;\n  \t\t}\n  \t\tif(z.second>m) break;\n  \t\t\n  \t\tint r=z.first;\n  \t\tint e[3]={-1,-1,-1};\n  \t\tfor(int i=n-1;i>=0;i--){\n  \t\t\te[r/san[i]]=max(e[r/san[i]],i);\n  \t\t\tr%=san[i];\n  \t\t}\n  \t\t\n  \t\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++)if(abs(i-j)==1){\n  \t\t\tif(e[i]<e[j]) continue;\n  \t\t\tr=z.first;\n  \t\t\tr-=san[e[i]]*i;\n  \t\t\tr+=san[e[i]]*j;\n  \t\t\tif(!sumi[r]) qu.push(mp(r,z.second+1));\n  \t\t}\n  \t\t\n  \t}\n  \tcout<<ans<<endl;\n}\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint n, m;\nint ans;\n\ninline int msb(int x) {\n\tif(!x) return 0;\n\treturn (1 << (31 - __builtin_clz(x)));\n}\n\n\nvoid dfs(vector<int> state, vector<int> prev, int cnt = 0) {\n\tif(cnt > min(m, ans))\n\t\treturn;\n\n\tif(state[0] == (1 << n) - 1 || state[2] == (1 << n) - 1) {\n\t\tans = cnt;\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < 2; ++i) {\n\t\tint move = max(msb(state[i]), msb(state[i + 1]));\n\t\tvector<int> next = state;\n\t\tnext[i] ^= move;\n\t\tnext[i + 1] ^= move;\n\t\tif(next != state)\n\t\t\tdfs(next, state, cnt + 1);\n\t}\t\n\t\n}\n\nint main() {\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\n\tconst vector<int> init(3, -1);\n\n\tfor(; cin >> n >> m, n | m;) {\n\t\tvector<int> cup(3, 0);\n\n\t\tfor(int i = 0; i < 3; ++i) {\n\t\t\tint num;\n\t\t\tcin >> num;\n\n\t\t\tfor(int j = 0; j < num; ++j) {\n\t\t\t\tint size;\n\t\t\t\tcin >> size;\n\t\t\t\t--size;\n\n\t\t\t\tcup[i] |= (1 << size);\n\t\t\t}\n\t\t}\n\n\t\tans = INT_MAX;\n\t\tdfs(cup, init);\n\n\t\tcout << (ans == INT_MAX ? -1 : ans) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<stack>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n    int dep,lastmove[2];\n    stack<int> s[3];\n};\nbool memo[14348908] = {};\n\nint int_pow(int n,int m){\n    int ans = 1;\n    while(m--){\n        ans *= n;\n    }\n    return ans;\n}\n\nint main(){\n    int hoge,n;\n    while(cin>>hoge>>n,n || hoge){\n        for(int i=0;i<14348908;i++) memo[i] = false;\n        Data q_c,q_d,first;\n        int m,input,nt,cup,cntempty,state;\n\t\tbool flag;\n        int situ[2] = {-1,1};\n        queue<Data> q;\n        for(int i=0;i<3;i++){\n            cin>>m;\n            for(int j=0;j<m;j++){\n                cin>>input;\n                first.s[i].push(input);\n            }\n        }\n        first.dep = 0;first.lastmove[0] = -1;first.lastmove[1] = -1;\n        q.push(first);\n        flag = false;\n        while(!q.empty()){\n            q_c = q.front();\n            q.pop();\n            /*if(q_c.dep%1000 == 0){\n                printf(\"%d\\n\",q_c.dep);\n            }*/\n            //for(int i=0;i<3;i++) printf(\"%d \",!q_c.s[i].empty());\n            //puts(\"\");\n            if(q_c.dep == n) break;\n            cntempty = 0;\n            for(int i=0;i<3;i++){\n                if(!q_c.s[i].empty()){\n                    if(i == 1){\n                        cntempty = 0;\n                        break;\n                    }\n                    cntempty++;\n                }\n            }\n            if(cntempty == 1){\n                printf(\"%d\\n\",q_c.dep);\n                flag = true;\n                break;\n            }\n            q_d = q_c;\n            state = 0;\n            for(int i=0;i<3;i++){\n                while(!q_d.s[i].empty()){\n                    cup = q_d.s[i].top();\n                    q_d.s[i].pop();\n                    state += i*int_pow(3,cup-1);\n                }\n            }\n            if(memo[state]) continue;\n            memo[state] = true;\n            //printf(\"%d\\n\",state);\n            for(int i=0;i<3;i++){\n                for(int j=0;j<2;j++){\n                    nt = i+situ[j];\n                    if(nt<0 || 3<=nt) continue;\n                    q_d = q_c;\n                    if((q_c.lastmove[1]==i && q_c.lastmove[0]==nt)\n                       || q_d.s[i].empty()) continue;\n                    cup = q_d.s[i].top();\n                    q_d.s[i].pop();\n                    if(!q_d.s[nt].empty() && cup < q_d.s[nt].top()) continue;\n                    q_d.s[nt].push(cup);\n                    q_d.dep++;\n                    q_d.lastmove[0] = i;q_d.lastmove[1] = nt;\n                    q.push(q_d);\n                }\n            }\n        }\n        if(!flag) printf(\"-1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef pair<int, int> pii;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i))\n#define mat(type, c, m, n) vector<vector<type>> c(m, vector<type>(n));for(auto& r:c)for(auto& i:r)cin>>i;\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define each(x,y) for(auto &(x):(y))\n#define var(type, ...)type __VA_ARGS__;Scan(__VA_ARGS__);\ntemplate<typename T> void Scan(T& t) { cin >> t; }\ntemplate<typename First, typename...Rest>void Scan(First& first, Rest&...rest) { cin >> first; Scan(rest...); }\n#define vec(type, c, n) vector<type> c(n);for(auto& i:c) cin>>i;\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\n#define em emplace\n#define pb pop_back\n#define fi first\n#define se second\n#define get(a, i) get<i>(a)\n#define bit_count __builtin_popcount\n#define mt make_tuple\ninline string zero(int a,string s,char c='0'){return string(a-len(s),c)+s;}\ninline string zero(int a,int t,char c='0'){return zero(a, to_string(t), c);}\ninline string zero(int a,ll t,char c='0'){return zero(a, to_string(t), c);}\n#define mini min_element\n#define maxi max_element\n#define sum accumulate\n#define chmax(a,b) if(a<b)a=b\n#define chmin(a,b) if(a>b)a=b\ntemplate <class T> inline void print(T t){cout << t << '\\n';}\ntemplate <class H, class... T> inline void print(H h, T... t){cout << h << \" \";print(t...);}\nint n, m;\nvector<vi> v(3), vt(3), vn(3);\nint bfs() {\n\tint a, b, c;\n\tv[0].eb(0), v[1].eb(0), v[2].eb(0);\n\trep(i, 0, 3) {\n\t\tcin >> a;\n\t\trep(j, 0, a) {\n\t\t\tcin >> b;\n\t\t\tv[i].eb(b);\n\t\t}\n\t}\n\tint cnt = 0;\n\tdeque<tuple<int, vector<vi>, int>> dq;\n\tdq.eb(mt(cnt, v, 0));\n\twhile(!dq.empty()) {\n\t\ttie(cnt, vt, c) = dq.front(); dq.pop_front();\n\t\tif (cnt > m)\n\t\t\tbreak;\n\t\tif (vt[1].back() == 0 && (vt[0].back() == 0 || vt[2].back() == 0)) {\n\t\t\treturn cnt;\n\t\t}\n\t\t++cnt;\n\t\tif (vt[0].back() < vt[1].back() && c != 3) {\n\t\t\tvn = vt;\n\t\t\tvn[0].eb(vt[1].back()); vn[1].pop_back();\n\t\t\tdq.eb(mt(cnt, vn, 3));\n\t\t}\n\t\tif (vt[0].back() > vt[1].back() && c != 3) {\n\t\t\tvn = vt;\n\t\t\tvn[1].eb(vt[0].back()); vn[0].pop_back();\n\t\t\tdq.eb(mt(cnt, vn, 3));\n\t\t}\n\t\tif (vt[1].back() > vt[2].back() && c != 6) {\n\t\t\tvn = vt;\n\t\t\tvn[2].eb(vt[1].back()); vn[1].pop_back();\n\t\t\tdq.eb(mt(cnt, vn, 6));\n\t\t}\n\t\tif (vt[1].back() < vt[2].back() && c != 6) {\n\t\t\tvn = vt;\n\t\t\tvn[1].eb(vt[2].back()); vn[2].pop_back();\n\t\t\tdq.eb(mt(cnt, vn, 6));\n\t\t}\n\t}\n\treturn -1;\n}\nvoid solve() {\n\trep(i, 0, 5) {\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tprint(bfs());\n\t}\n}\nint main() {\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nbool visited[14500000];\n\n\nint mypow(int x,int n){\n\tint res = 1;\n\twhile(n>0){\t\t\n\t\tif(n & 1) res = res*x;\n\t\tx = x * x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\n\nint conv(vector<int>& sets,int n){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * mypow(3,j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,int n,vector<int>& root,bool* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root,n)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(!visited[(next = conv(tmp,n))]){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(!visited[(next = conv(tmp,n))]){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\t\n\t\tmemset(visited,0,sizeof(visited));\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,n,sets,visited));\n\t}\n\t//printf(\"%d %d %d\\n\",mypow(3,0),mypow(3,1),mypow(3,2));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint rec( int a, int b, int c){\n  if(!a & !b) return(0);\n  if(c & 1) return( rec( a >> 1, b >> 1, c >> 1));\n  if(b & 1) return( rec( c >> 1, b >> 1, a >> 1) + rec( ( a|b|c) >> 1, 0, 0) + 1);\n  if(a & 1) return( rec( a >> 1, b >> 1, c >> 1) + 2 * rec( ( a|b|c) >> 1, 0, 0) + 2);\n}\n\n\nint main()\n{\n  int n, m, data[3];\n\n  while( cin >> n >> m, m){\n    for(int i = 0; i < 3; i++){\n      int k;\n      cin >> k;\n      data[i] ^= data[i];\n      for(int j = 0; j < k; j++){\n        int num;\n        cin >> num;\n        data[i] |= 1 << --num;\n      }\n    }\n\n    int ret = min( rec( data[0], data[1], data[2]), rec( data[2], data[1], data[0]));\n    if(ret <= m) cout << ret << endl;\n    else cout << -1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef short int SI;\ntypedef pair<SI,SI> P;\ntypedef pair<SI,P> State;\n\n// 入力\nint n, m;\nSI cup[3];\n\nvoid debug(SI a, SI b, SI c, SI cnt){\n\tcout << \"[debug]\" << endl;\n\tcout << \"cnt:\" << cnt << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((a&i)? \"*\" : \"-\");\n\t}\n\tcout << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((b&i)? \"*\" : \"-\");\n\t}\n\tcout << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((c&i)? \"*\" : \"-\");\n\t}\n\tcout << endl << endl;;\n}\n\n// 一番上のカップを返す\nSI top(SI bits){\n\tfor(int i=(1<<n) ; i ; i >>= 1 ){\n\t\tif( i & bits ) return i;\n\t}\n\treturn 0;\n}\n\n// 探索\nint bfs(){\n\t// d[s] := cupの状態 s のときの手数\n\tmap<State,int> d;\n\tqueue<State> q;\n\t\n\tState s = State( (1<<n)-1 , P(0,0) );\n\tq.push(s);\n\td[s] = 0;\n\t\n\twhile( !q.empty() ){\n\t\tState now = q.front();\n\t\tint cnt = d[now];\n\t\tq.pop();\n\t\t\n\t\t// a,b,c := カップの状態\n\t\t// a_top,b_top,c_top := 一番上のカップ\n\t\tSI& a = now.first;\n\t\tSI& b = now.second.first;\n\t\tSI& c = now.second.second;\n\t\tSI a_top = top(a);\n\t\tSI b_top = top(b);\n\t\tSI c_top = top(c);\n\t\t//debug(a,b,c,cnt);\n\t\t\n\t\t// ゴールのとき\n\t\tif( b == cup[1] && ((a == cup[0] && c == cup[2]) || (a == cup[2] && c == cup[0])) ){\n\t\t\treturn cnt;\n\t\t}\n\t\t\n\t\t{\n\t\t\tSI a_, b_, c_;\n\t\t\tif( a_top < b_top ){ // B -> A の移動\n\t\t\t\ta_ = a + b_top;\n\t\t\t\tb_ = b - b_top;\n\t\t\t\tc_ = c;\n\t\t\t}else{ // A -> B の移動\n\t\t\t\ta_ = a - a_top;\n\t\t\t\tb_ = b + a_top;\n\t\t\t\tc_ = c;\n\t\t\t}\n\t\t\tState next = State(a_,P(b_,c_));\n\t\t\tif( !d.count(next) && cnt + 1 <= m ){\n\t\t\t\td[next] = cnt + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tSI a_, b_, c_;\n\t\t\tif( c_top < b_top ){ // B -> C の移動\n\t\t\t\ta_ = a;\n\t\t\t\tb_ = b - b_top;\n\t\t\t\tc_ = c + b_top;\n\t\t\t}else{ // C -> B の移動\n\t\t\t\ta_ = a;\n\t\t\t\tb_ = b + c_top;\n\t\t\t\tc_ = c - c_top;\n\t\t\t}\n\t\t\tState next = State(a_,P(b_,c_));\n\t\t\tif( !d.count(next) && cnt + 1 <= m ){\n\t\t\t\td[next] = cnt + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile( cin >> n >> m , n || m ){\n\t\t// 初期化\n\t\tcup[0] = cup[1] = cup[2] = 0;\n\t\t \n\t\tfor(int i=0 ; i < 3 ; i++ ){\n\t\t\tint k, e;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0 ; j < k ; j++ ){\n\t\t\t\tcin >> e;\n\t\t\t\tcup[i] |= (1 << (e-1));\n\t\t\t}\n\t\t}\n\t\tint ans = bfs();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tll dp[16] = {};\n\tdp[0] = 1;\n\trep(i,1, n+1) {\n\t\tdp[i] = dp[i - 1] * 3;\n\t}\n\tvector<int> pos(n);\n\tREP(i, 3) {\n\t\tint c;\n\t\tscanf(\"%d\", &c);\n\n\n\t\tREP(j, c) {\n\t\t\tint size;\n\t\t\tscanf(\"%d\", &size);\n\n\t\t\tpos[size-1] = i;\n\t\t}\n\t}\n\t//reverse(ALL(pos));\n\tll ans = 0,ans2 = 0;\n\tbool curs = 0;\n\tREP(i, n) {\n\t\tif (pos[i] % 2) {\n\t\t\tans += dp[n - i - 1];\n\t\t\tcurs = 1-curs;\n\t\t}\n\t\telse if (curs*2-pos[i]) {\n\t\t\tans += dp[n - i - 1] + 1;\n\t\t}\n\t}\ncurs = 1;\n\tREP(i, n) {\n\t\tif (pos[i] % 2) {\n\t\t\tans2 += dp[n - i - 1];\n\t\t\tcurs = 1 - curs;\n\t\t}\n\t\telse if (curs * 2 - pos[i]) {\n\t\t\tans2 += dp[n - i - 1] + 1;\n\t\t}\n\t}\n\tans = min(ans2, ans);\n\tif (ans > m)\n\t\tans = -1;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,P> pip;\nconst int inf=(1<<31)-1;\n\nint n,m;\nvvi date;\n\nint func(int x){\n\tint an=3;\n\tfor(int i=0;i<x-1;i++) an*=an;\n\treturn an;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(!n&&!m) break;\n\t\tint lef=0,rig=0;\n\t\tdate=vvi(3);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint tn;\n\t\t\tcin>>tn;\n\t\t\tfor(int j=0;j<tn;j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tdate[i].push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tfor(int  i=0;i<3;i+=2){\n\t\t\tint now=i;\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tint tmp1;\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tfor(int r=0;r<date[k].size();r++){\n\t\t\t\t\t\tif(j==date[k][r]){\n\t\t\t\t\t\t\ttmp1=k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j>date[k][r]) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint t=abs(now-tmp1);\n\t\t\t\tif(i==0){\n\t\t\t\t\tlef+=t*func(n-i);\n\t\t\t\t\tif(lef>m) break;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\trig+=t*func(n-i);\n\t\t\t\t\tif(rig>m) break;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<t;k++){\n\t\t\t\t\tif(now==1) now=3;\n\t\t\t\t\telse now=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=min(lef,rig);\n\t\tif(ans>m) cout<<-1<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint d[3][16];\nint x;\nint i,j,k;\nint m,n;\nint ans=0;\nint goal;\nint now[3];\nint p,q;\n\nint other(int a,int b){\n\tif(a==0&&b==1)return 2;\n\tif(b==0&&a==1)return 2;\n\tif(a==0&&b==2)return 1;\n\tif(b==0&&a==2)return 1;\n\tif(a==1&&b==2)return 0;\n\tif(b==1&&a==2)return 0;\n}\n\nvoid move(int n,int a,int b,int to){\nstart:\n\tif(ans>m)return;\n\tif(n!=d[a][b])return;\n\tif(to-a==2||a-to==2){\n\t\tmove(d[a][b],a,b,1);\n\t\tmove(d[1][now[1]-1],1,now[1]-1,to);\n\t\tgoto start;\n\t}\n\tif(d[a][b+1]>0){\n\t\tmove(d[a][b+1],a,b+1,other(a,to));\n\t\tgoto start;\n\t}\n\tif(now[to]>=1&&d[to][now[to]-1]>d[a][b]){\n\t\tmove(d[to][now[to]-1],to,now[to]-1,other(a,to));\n\t\tgoto start;\n\t}\n\td[to][now[to]++]=d[a][b];\n\td[a][b]=-1;\n\tnow[a]--;\n\tans++;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)break;\n\t\tans=0;\n\t\tfor(i=0;i<3;i++)for(j=0;j<16;j++)d[i][j]=-1;\n\t\tfor(i=0;i<3;i++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tfor(j=0;j<x;j++){\n\t\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\t}\n\t\t\tnow[i]=x;\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(i==0){\n\t\t\t\tif(d[1][0]==1){\n\t\t\t\t\tif(d[2][0]>d[0][0]){\n\t\t\t\t\t\tif(now[0]==0)goal=0;\n\t\t\t\t\t\telse goal=2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(now[2]==0)goal=2;\n\t\t\t\t\t\telse goal=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(d[0][0]==1)goal=0;\n\t\t\t\telse goal=2;\n\t\t\t}\n\t\t\tp=-1;q=-1;\n\t\t\tfor(j=0;j<3;j++)for(k=0;k<16;k++)if(d[j][k]==i+1){p=j;q=k;}\n\t\t\tif(p!=-1&&q!=-1)if(p!=goal)move(i+1,p,q,goal);\n\t\t\tif(ans>m)break;\n\t\t}\n\t\tif(ans<=m)printf(\"%d\\n\",ans);\n\t\telse printf(\"-1\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\n\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nLL j3[16];\nint cp[20];\nLL L(int s, int e);\nLL C(int s, int e);\nLL R(int s, int e);\n\ninline LL f(int k){\n\treturn j3[k]-1;\n}\n\ninline LL g(int k){\n\treturn (j3[k]-1)/2;\n}\n\nLL L(int s, int e){\n\tif(s==e)return cp[s];\n\tswitch(cp[s]){\n\t\tcase 0:\n\t\t\treturn L(s+1, e);\n\t\tcase 1:\n\t\t\treturn min(L(s+1, e)+g(e-s)+g(e-s+1), min(C(s+1,e)+g(e-s+1), R(s+1, e)+1+f(e-s)));\n\t\tcase 2:\n\t\t\treturn min(L(s+1, e)+1+g(e-s)+g(e-s+1), min(C(s+1, e)+min(g(s-e)+f(s-e+1), 2*g(s-e)+1+g(s-e+1)), R(s+1, e)+f(e-s+1)));\n\t}\t\n}\n\nLL C(int s, int e){\n\tif(s==e){\n\t\tif(cp[s]==1)return 0;\n\t\telse return 1;\n\t}\n\tswitch(cp[s]){\n\t\tcase 0:\n\t\t\treturn min(L(s+1, e)+g(e-s+1), min(C(s+1, e)+2*g(e-s)+1,  R(s+1, e)+1+g(e-s)));\n\t\tcase 1:\n\t\t\treturn C(s+1, e);\n\t\tcase 2:\n\t\t\treturn min(L(s+1, e)+1+g(e-s), min(C(s+1, e)+2*g(e-s)+1, R(s+1, e)+g(e-s+1)));\n\t}\t\n}\n\nLL R(int s, int e){\n\tif(s==e)return 2-cp[s];\n\tswitch(cp[s]){\n\t\tcase 2:\n\t\t\treturn R(s+1, e);\n\t\tcase 1:\n\t\t\treturn min(R(s+1, e)+g(e-s)+g(e-s+1), min(C(s+1,e)+g(e-s+1), L(s+1, e)+1+f(e-s)));\n\t\tcase 0:\n\t\t\treturn min(R(s+1, e)+1+g(e-s)+g(e-s+1), min(C(s+1, e)+min(g(s-e)+f(s-e+1), 2*g(s-e)+1+g(s-e+1)), L(s+1, e)+f(e-s+1)));\n\t}\t\n}\n\n\nint main(){\n\tj3[0] = 1;\n\tREP(i, 15)j3[i+1] = 3*j3[i];\n\twhile(1){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n == 0)return 0;\n\t\tREP(i, 3){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tREP(j, k){\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tcp[t-1] = i;\n\t\t\t}\n\t\t}\n\t\tLL ret = min(L(0, n-1), R(0, n-1));\n\t\tif(ret > m)ret = -1;\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nclass Cups {\npublic:\n    Cups(int, int);\n    void setInputData();\n    void move();\n    bool isGoal();\n    bool canMove(char, char);\n    int getStep();\nprivate:\n    stack<int> sA, sB, sC;  // startA, B, C\n    stack<int> gA, gB, gC;  // goalA, B, C\n    int n, m;\n    int step;\n    string prev;\n};\n\nCups::Cups(int n, int m) {\n    this->step = 0;\n    this->n = n;\n    this->m = m;\n    // Default cups\n    for (int i=1; i<=n; ++i) {\n        sA.push(i);\n    }\n}\nint Cups::getStep() {\n    return step;\n}\nvoid Cups::setInputData() {\n    int n, cup;\n    cin >> n;\n    for (int i=0; i<n; ++i) {\n        cin >> cup; \n        gA.push(cup);\n    }\n    cin >> n;\n    for (int i=0; i<n; ++i) {\n        cin >> cup; \n        gB.push(cup);\n    }\n    cin >> n;\n    for (int i=0; i<n; ++i) {\n        cin >> cup; \n        gC.push(cup);\n    }\n}\nbool Cups::isGoal() {\n    if ((sA == gA && sB == gB && sC == gC) ||\n        (sA == gC && sB == gB && sC == gA)) {\n        return true;\n    }\n    return false;\n}\nvoid Cups::move() {\n    if (canMove('A','B')) {\n        sB.push(sA.top()); sA.pop();\n        prev = \"AtoB\";\n    } else if (canMove('C', 'B')) {\n        sB.push(sC.top()); sC.pop();\n        prev = \"CtoB\";\n    } else if (canMove('B', 'A')) {\n        sA.push(sB.top()); sB.pop();\n        prev = \"BtoA\";\n    } else if (canMove('B', 'C')) {\n        sC.push(sB.top()); sB.pop();\n        prev = \"BtoC\";\n    }\n    step ++;\n}\nbool Cups::canMove(char from, char to) {\n    stringstream way;\n    way << to << \"to\" << from;\n    if (prev == way.str()) {\n        return false;\n    }\n\n    int cup[3];\n    cup[0] = sA.empty() ? 0 : sA.top();\n    cup[1] = sB.empty() ? 0 : sB.top();\n    cup[2] = sC.empty() ? 0 : sC.top();\n\n    if (cup[from-'A'] > cup[to-'A']) {\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    int n, m;\n    while (cin >> n >> m && n!=0 && m!=0) {\n        Cups cups(n, m);\n        cups.setInputData();\n\n        int res = -1;\n        if (cups.isGoal()) {\n            res = 0;\n        } else {\n            for (int i=0; i<m; i++) {\n                cups.move();\n                if (cups.isGoal()) {\n                    res = cups.getStep();\n                    break;\n                }\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n//http://climpet.hatenablog.com/entry/2013/01/01/225142#f5を参考\nint main(int argc, char *argv[])\n{\n  int pow3[16],c[16];\n  int n,m,i,j,k,d,x,y,p;\n\n  pow3[0] = 1;\n  for(int i = 1;i <=15;i++){\n    pow3[i] = pow3[i-1]*3;//i枚#0から#2または#2から#0へ移動するのに必要なステップ数\n}\n\n  while(scanf(\"%d%d\",&n,&m),n){\n    for(i = 0;i < 3;i++){\n      for(scanf(\"%d\",&j);j > 0;j--){\n\tscanf(\"%d\",&k);\n\tc[n-k] = i;/*番号付け替え,ハノイの塔に変換。大きいコップを小さい円盤にする*/\n      }\n    }\n    p = 0;//全ての円盤が0の位置にあると仮定する\n    x = 0;\n    for(i = n-1;i > 0;i--){//\n      d = abs(p -c[i]);//移動させる円盤の距離を求める。\n      /*n = 3の時、i = 2で円盤2を#1に移動させるには円盤1と円盤0を#2に移動させる*/\n      x += pow3[i]*d;\n      if(d == 1){\n\tp = 2-p;/*反対側に移動,距離がd = 1ならば0~i-1番の円盤を反対側に移動する。*/\n      }\n    }\n    y = pow3[n] -1 -x;\n    if(x > y){\n      x = y;\n    }\n    printf(\"%d\\n\",x > m?-1:x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint n,m;\n\nint main(void){\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n==0 && m==0)break;\n\t\tvector<int> v(20);\n\t\tvector<int> a(20),c(20),p(20);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tint num;\n\t\t\t\tcin >> num;\n\t\t\t\tv[num]=i;\n\t\t\t}\n\t\t}\n\t\tp[n]=2;\n\t\ta[n]=v[n];\n\t\tc[n]=2-v[n];\n\t\tfor(int i=n;i>1;i--){\n\t\t\tp[i-1]=3*p[i]+2;\n\t\t\tif(v[i-1]==0){\n\t\t\t\ta[i-1]=a[i];\n\t\t\t\tc[i-1]=c[i]+2*p[i]+2;\n\t\t\t}\n\t\t\tif(v[i-1]==1){\n\t\t\t\ta[i-1]=c[i]+p[i]+1;\n\t\t\t\tc[i-1]=a[i]+p[i]+1;\n\t\t\t}\n\t\t\tif(v[i-1]==2){\n\t\t\t\ta[i-1]=a[i]+2*p[i]+2;\n\t\t\t\tc[i-1]=c[i];\n\t\t\t}\n\t\t}\n\t\tint res=min(a[1],c[1]);\n\t\tif(m<res)cout << \"-1\" << endl;\n\t\telse cout << res << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#define S(n) (int)(pow(3,x-(n)+1)/2)\nusing namespace std;\n\nint main(){\n\tint h[17],a[17],c[17],x,i,n,m;\n\twhile(cin>>x>>n,n){\n\t\tfor(i=0;i<3;i++)for(cin>>m;m--;h[t]=i)cin>>t;\n\t\ta[x]=h[x];c[x]=2-h[x];\n\t\tfor(i=x;i>1;i--){\n\t\t\tif(h[i-1]==0){\n\t\t\t\ta[i-1]=a[i];\n\t\t\t\tc[i-1]=c[i]+2+4*S(i);\n\t\t\t}else if(h[i-1]==1){\n\t\t\t\ta[i-1]=c[i]+1+2*S(i);\n\t\t\t\tc[i-1]=a[i]+1+2*S(i);\n\t\t\t}else{\n\t\t\t\ta[i-1]=a[i]+2+4*S(i);\n\t\t\t\tc[i-1]=c[i];\n\t\t\t}\n\t\t}\n\t\tt=min(a[1],c[1]);\n\t\tcout<<t>n?-1:t<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 3;\nconst int INF = 15000001;\n\nclass S{\npublic:\n  int t[N], cost;\n  S(int a = 0, int b = 0, int c = 0, int cost = 0) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n\nint n, m;\n//int ans;\n\nint calc(S s, int pres, int pret){\n  //if(ans <= s.cost) return INF;\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  if(s.cost >= m) return INF;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<N;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(i == pret && j == pres) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          //ans = min(ans, res);\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint solve(S s){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<N;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          //ans = min(ans, res);\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[N];\n    for(int i=0;i<N;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    //ans = INF;\n    //cout << solve(S(data[0], data[1], data[2], 0)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint mypow(int x,int n){\n\tint res = 1;\n\twhile(n>0){\t\t\n\t\tres *= x;\n\t\tif(n & 1) x = x*x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\nint conv(vector<int>& sets,int n){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * mypow(3,j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,int n,vector<int>& root, int* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root,n)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp,n))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp,n))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tint* visited = new int[3*mypow(3,n) + 1];\n\t\tfill_n(visited,3*mypow(3,n) + 1,-1);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,n,sets,visited));\n\t\tdelete[] visited;\n\t}\n\n\t//printf(\"%d %d %d\\n\",mypow(3,0),mypow(3,1),mypow(3,2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef vector<int> V;\ntypedef vector<V> VV;\n\nconst int inf = 2e8;\n\nint n, m, s;\nint d[14348907];\n\nV seq(){\n\tV v(n);\n\trep(i, n){\n\t\tv[i] = i;\n\t}\n\treturn v;\n}\n\nint pack(const VV& v){\n\tV p(n);\n\trep(i, 3){\n\t\tfor(int x: v[i]){\n\t\t\tp[x] = i;\n\t\t}\n\t}\n\n\tint k = 0;\n\tfor(int i = n - 1; i >= 0; --i){\n\t\tk *= 3;\n\t\tk += p[i];\n\t}\n\treturn k;\n}\nVV unpack(int k){\n\tVV v(3, V());\n\trep(i, n){\n\t\tv[k % 3].push_back(i);\n\t\tk /= 3;\n\t}\n\treturn v;\n}\n\nVV read(){\n\tVV v(3, V());\n\trep(i, 3){\n\t\tint k;\n\t\tcin >> k;\n\t\trep(j, k){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tv[i].push_back(x - 1);\n\t\t}\n\t}\n\treturn v;\n}\n\nVV swap_cup(VV v, int a, int b){\n\tif(!v[a].empty() || !v[b].empty()){\n\t\tif(!v[a].empty() && !v[b].empty()){\n\t\t\tif(v[a].back() > v[b].back()){\n\t\t\t\tswap(a, b);\n\t\t\t}\t\n\t\t}\n\t\telse if(v[b].empty()){\n\t\t\tswap(a, b);\n\t\t}\n\t\tv[a].push_back(v[b].back());\n\t\tv[b].pop_back();\n\t}\n\treturn v;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n){\n\t\t\tbreak;\n\t\t}\n\t\ts = pack(read());\n\n\t\tint f = pack({seq(), {}, {}});\n\t\tint g = pack({{}, {}, seq()});\n\n\t\tfill_n(d, sizeof(d) / sizeof(d[0]), inf);\n\n\t\tqueue<int> q;\n\t\td[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\tVV k = unpack(v);\n\t\t\tbool end = false;\n\t\t\trep(i, 2){\n\t\t\t\tint t = pack(swap_cup(k, 1, i * 2));\n\t\t\t\tif(d[t] == inf){\n\t\t\t\t\td[t] = d[v] + 1;\n\t\t\t\t\tq.push(t);\n\t\t\t\t\tif(t == f || t == g){\n\t\t\t\t\t\tend = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(end){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = min(d[f], d[g]);\n\t\tcout << (ans <= m ? ans : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint n,m;\ndeque<int> deq[3];\n\nint simulate(int sp,int dir) {\n  if( sp+dir < 0 || sp+dir >= 3 || deq[sp].empty() ) return INT_MAX;\n  if( (int)deq[0].size() == n ) return 0;\n\n\n  deque<int> cup[3];\n  rep(i,3) rep(j,(int)deq[i].size()) cup[i].push_back(deq[i][j]);\n  int cur = sp;\n  int next = cur + dir;\n  cup[next].push_back(cup[cur].back()); cup[cur].pop_back();\n  int cnt = 1;\n  while( (int)cup[0].size() < n ) {\n    /*\n    cout << cnt << \"::\" << endl;\n    rep(i,3) {\n      cout << \"$\";\n      rep(j,(int)cup[i].size()) cout<< cup[i][j] << \" \"; cout << endl;\n    }\n    puts(\"--\");\n    cout << \"(\" << cur << \",\" << next << \")\" << endl;\n    */\n    int tmp = -1, prev = -1;\n    rep(i,3) {\n      if( i == cur || i == next ) continue;\n      tmp = i;\n    }\n    prev = cur; cur = next; \n    //cout << tmp << \",\" << prev << endl;\n    if( abs(tmp-prev) >= 2 ) {\n      tmp = cur;\n    }\n\n    if( cup[prev].empty() && cup[tmp].empty() ) {\n      if( (int)cup[0].size() == n ) return cnt;\n      return INT_MAX;\n    } else if( cup[prev].empty() ) {\n      next = prev;\n      cup[next].push_back(cup[tmp].back()); cup[tmp].pop_back();\n      ++cnt;\n    } else if( cup[tmp].empty() ) {\n      next = tmp;\n      cup[next].push_back(cup[prev].back()); cup[prev].pop_back();\n      ++cnt;\n    } else if( cup[tmp].back() < cup[prev].back() ) {\n      next = tmp;\n      cup[next].push_back(cup[prev].back()); cup[prev].pop_back();\n      ++cnt;\n    } else {\n      next = prev;\n      cup[next].push_back(cup[tmp].back()); cup[tmp].pop_back();\n      ++cnt;\n    }\n    /*\n    cout << cnt << \"::\" << endl;\n    rep(i,3) {\n      cout << \"$\";\n      rep(j,(int)cup[i].size()) cout<< cup[i][j] << \" \"; cout << endl;\n    }\n    cout << \"(\" << cnt << \")--\" << endl;\n    */\n    if( cnt > m ) return INT_MAX;\n  }\n  return cnt;\n}\n\nvoid compute() {\n  int ans = INT_MAX;\n  rep(sp,3) {\n    for(int dir=-1;dir<=1;dir+=2) {\n      ans = min(ans,simulate(sp,dir));\n    }\n  }\n  if(ans == INT_MAX) cout << -1 <<endl;\n  else cout << ans << endl;\n}\n\nint main() {\n  while(cin >> n >> m,n|m) {\n    rep(i,3) deq[i].clear();\n    rep(i,3) {\n      int cnt,tmp;\n      cin >> cnt;\n      rep(j,cnt) {\n\tcin >> tmp;\n\tdeq[i].push_back(tmp);\n      }\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\nenum class MovePos\n{\n\tMoveLeftToCenter,\n\tMoveRightToCenter,\n\tMoveCenterToLeft,\n\tMoveCenterToRight\n};\n\nclass Tray\n{\npublic:\n\tstack<int> t[3];\n\tbool isCompleted()\n\t{\n\t\tif (t[0].empty() && t[1].empty()) return true;\n\t\tif (t[1].empty() && t[2].empty()) return true;\n\t\treturn false;\n\t}\n\tbool canMoveLeftToCenter()\n\t{\n\t\tif (t[0].empty()) return false;\n\t\tif (t[1].empty()) return true;\n\t\tif (t[0].top() > t[1].top()) return true;\n\t\treturn false;\n\t}\n\tbool canMoveRightToCenter()\n\t{\n\t\tif (t[2].empty()) return false;\n\t\tif (t[1].empty()) return true;\n\t\tif (t[2].top() > t[1].top()) return true;\n\t\treturn false;\n\t}\n\tbool canMoveCenterToLeft()\n\t{\n\t\tif (t[1].empty()) return false;\n\t\tif (t[0].empty()) return true;\n\t\tif (t[1].top() > t[0].top()) return true;\n\t\treturn false;\n\t}\n\tbool canMoveCenterToRight()\n\t{\n\t\tif (t[1].empty()) return false;\n\t\tif (t[2].empty()) return true;\n\t\tif (t[1].top() > t[2].top()) return true;\n\t\treturn false;\n\t}\n\tvoid MoveLeftToCenter()\n\t{\n\t\tint top = t[0].top();\n\t\tt[0].pop();\n\t\tt[1].push(top);\n\t}\n\tvoid MoveRightToCenter()\n\t{\n\t\tint top = t[2].top();\n\t\tt[2].pop();\n\t\tt[1].push(top);\n\t}\n\tvoid MoveCenterToLeft()\n\t{\n\t\tint top = t[1].top();\n\t\tt[1].pop();\n\t\tt[0].push(top);\n\t}\n\tvoid MoveCenterToRight()\n\t{\n\t\tint top = t[1].top();\n\t\tt[1].pop();\n\t\tt[2].push(top);\n\t}\n};\n\nint calc(Tray t, MovePos previousMovePos, int m)\n{\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tif (t.isCompleted()) return i;\n\t\tif (t.canMoveLeftToCenter() && previousMovePos != MovePos::MoveCenterToLeft)\n\t\t{\n\t\t\tt.MoveLeftToCenter();\n\t\t\tpreviousMovePos = MovePos::MoveLeftToCenter;\n\t\t}\n\t\telse if (t.canMoveRightToCenter() && previousMovePos != MovePos::MoveCenterToRight)\n\t\t{\n\t\t\tt.MoveRightToCenter();\n\t\t\tpreviousMovePos = MovePos::MoveRightToCenter;\n\t\t}\n\t\telse if (t.canMoveCenterToLeft() && previousMovePos != MovePos::MoveLeftToCenter)\n\t\t{\n\t\t\tt.MoveCenterToLeft();\n\t\t\tpreviousMovePos = MovePos::MoveCenterToLeft;\n\t\t}\n\t\telse if (t.canMoveCenterToRight() && previousMovePos != MovePos::MoveRightToCenter)\n\t\t{\n\t\t\tt.MoveCenterToRight();\n\t\t\tpreviousMovePos = MovePos::MoveCenterToRight;\n\t\t}\n\t}\n\treturn 99999999;\n}\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n + m)\n\t{\n\t\tTray tray;\n\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tint a, b;\n\t\t\tcin >> a;\n\t\t\tfor (int j = 0; j < a; j++)\n\t\t\t{\n\t\t\t\tcin >> b;\n\t\t\t\ttray.t[i].push(b);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 99999999;\n\t\tif (tray.canMoveCenterToLeft())\n\t\t{\n\t\t\ttray.MoveCenterToLeft();\n\t\t\tans = min(ans, calc(tray, MovePos::MoveCenterToLeft, m));\n\t\t}\n\t\tif (tray.canMoveCenterToRight())\n\t\t{\n\t\t\ttray.MoveCenterToRight();\n\t\t\tans = min(ans, calc(tray, MovePos::MoveCenterToRight, m));\n\t\t}\n\t\tif (tray.canMoveLeftToCenter())\n\t\t{\n\t\t\ttray.MoveLeftToCenter();\n\t\t\tans = min(ans, calc(tray, MovePos::MoveLeftToCenter, m));\n\t\t}\n\t\tif (tray.canMoveRightToCenter())\n\t\t{\n\t\t\ttray.MoveRightToCenter();\n\t\t\tans = min(ans, calc(tray, MovePos::MoveRightToCenter, m));\n\t\t}\n\t\tif (ans == 99999999) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stdlib.h>\n/*http://climpet.hatenablog.com/entry/2013/01/01/225142#f5を参考*/\nint main(int argc, char *argv[])\n{\n  int pow3[16],c[16];\n  int n,m,i,j,k,d,x,y,p;\n\n  pow3[0] = 1;\n  for(i = 1;i <=15;i++){\n    pow3[i] = pow3[i-1]*3;/*i枚#0から#2または#2から#0へ移動するのに必要なステップ数*/\n}\n\n  while(scanf(\"%d%d\",&n,&m),n){\n    for(i = 0;i < 3;++i){\n      for(scanf(\"%d\",&j);j > 0;--j){\n\tscanf(\"%d\",&k);\n\tc[n-k] = i;/*番号付け替え,ハノイの塔に変換。大きいコップを小さい円盤にする*/\n      }\n    }\n    p = 0;//全ての円盤が0の位置にあると仮定する\n    x = 0;\n    for(i = n-1;i >= 0;--i){//\n      d = abs(p -c[i]);//移動させる円盤の距離を求める。\n      /*n = 3の時、i = 2で円盤2を#1に移動させるには円盤1と円盤0を#2に移動させる*/\n      x += pow3[i]*d;\n      if(d == 1){\n\tp = 2-p;/*反対側に移動,距離がd = 1ならば0~i-1番の円盤を反対側に移動する。*/\n      }\n    }\n    y = pow3[n] -1 -x;\n    if(x > y){\n      x = y;\n    }\n    printf(\"%d\\n\",x > m?-1:x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nint where[15];\nint n;\n\nll calc(int a,int b){\n\tll ans=1;\n\tfor(int i=0;i<b;i++){\n\t\tans*=a;\n\t}\n\treturn ans;\n}\n\nll check(bool left){\n\tll ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tint now=left?0:2;\n\t\tif(abs(now-where[i])==2){\n\t\t\tans+=2*calc(3,n-i-1)+2;\n\t\t}\n\t\telse if(where[i]==1){\n\t\t\tans+=calc(3,n-i-1)+1;\n\t\t\tleft^=1;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\trefrain:;\n\tint m;\tcin>>n>>m;\n\tif((n|m)==0)\treturn 0;\n\tint num,in;\n\tfor(int i=0;i<3;i++){\n\t\tcin>>num;\n\t\tfor(int j=0;j<num;j++){\n\t\t\tcin>>in;\n\t\t\twhere[in-1]=i;\n\t\t}\n\t}\n\tll ans=min(check(true),check(false));\n\tif(ans<=m)\tcout<<max(0LL,ans-1)<<endl;\n\telse \tcout<<-1<<endl;\n\tgoto refrain;\n}"
  },
  {
    "language": "C++",
    "code": "// asdf_l\n#include <bits/stdc++.h>\n#ifdef LOCAL\n#include \"../cxx-prettyprint/prettyprint.hpp\"\n#endif\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ull, int> P;\n\n#define REP(i, n) for (int (i) = 0 ; (i) < (int)(n) ; ++(i))\n#define REPN(i, m, n) for (int (i) = m ; (i) < (int)(n) ; ++(i))\n#define REP_REV(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define INF ((1 << 31)-1)\n#define MOD (1000000007)\n\n#define ALL(x) x.begin(), x.end()\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define CHAR2INT(c) (c - '0')\n#define COUT(x) cout << x << endl\n#define COUT_2DARR(h, w, arr) REP(i, h) { REP(j, w) cout << arr[i][j] << \" \"; cout << endl; }\n\nint main() {\n#ifdef LOCAL\n    std::ifstream in(\"../arg.txt\");\n    std::cin.rdbuf(in.rdbuf());\n#endif\n\n    ull pow3[16];\n    pow3[0] = 1;\n    REP(i, 15) pow3[i + 1] = pow3[i] * 3;\n\n    int arr[4][2] = {{0, 1}, {1,2}, {2,1}, {1,0}};\n\n    while(true){\n        int N, M;\n        cin >> N >> M;\n        if (N == 0) return 0;\n\n        ull init_state = 0;\n        REP(i, 3){\n            int k;\n            cin >> k;\n            REP(j, k){\n                int n;\n                cin >> n;\n                init_state += i * pow3[--n];\n            }\n        }\n        ull final_state1 = 0;\n        ull final_state2 = pow3[N] - 1;\n\n        vector<bool> visited(pow3[N], false);\n        queue<P> Q;\n        Q.push(P(init_state, 0));\n        int max_cup[3];\n        while (!Q.empty()){\n            P p = Q.front(); Q.pop();\n\n            ull state = p.first;\n            int count = p.second;\n\n            if (count >= M) {\n                COUT(-1);\n                break;\n            }\n\n            if (state == final_state1 || state == final_state2) {\n                COUT(count);\n                break;\n            }\n\n            visited[state] = true;\n\n            memset(max_cup, -1, sizeof(max_cup));\n            ull tmp = state;\n\n            vector<vector<ull>> vec(3, vector<ull>{});\n            REP(i, N){\n                ull res = tmp % 3;\n                max_cup[res] = max(max_cup[res], i);\n                tmp /= 3;\n            }\n\n            REP(i, 4){\n                int src = arr[i][0];\n                int dst = arr[i][1];\n                if (max_cup[src] > max_cup[dst]){\n                    ull next_state = src < dst ? state + pow3[max_cup[src]] : state - pow3[max_cup[src]];\n                    if (visited[next_state]) continue;\n                    Q.push(P(next_state, count + 1));\n                }\n            }\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\nusing namespace std;\nint kai;\nint kotae = 15000099;\nstack<int> a;\nstack<int> b;\nstack<int> c;\nint check(int now)\n{\n\tif (now > kai)return 0;\n\tif (now >= kotae)return 0;\n\tif (b.empty()){\n\t\tif (a.empty()){\n\t\t\tkotae = now;\n\t\t\treturn 1;\n\t\t}\n\t\telse if (c.empty())\n\t\t{\n\t\t\tkotae = now;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tint ans = 0;\n\n\tif (!a.empty()){\n\t\tif (b.empty() || a.top() > b.top())\n\t\t{\n\t\t\tb.push(a.top());\n\t\t\ta.pop();\n\t\t\tans += check(now + 1);\n\t\t\ta.push(b.top());\n\t\t\tb.pop();\n\t\t}\n\t}\n\n\tif (!b.empty()){\n\t\tif (a.empty() || a.top() < b.top())\n\t\t{\n\t\t\ta.push(b.top());\n\t\t\tb.pop();\n\t\t\tans += check(now + 1);\n\t\t\tb.push(a.top());\n\t\t\ta.pop();\n\t\t}\n\t}\n\n\tif (!b.empty())\n\t{\n\t\tif (c.empty() || b.top() > c.top())\n\t\t{\n\t\t\tc.push(b.top());\n\t\t\tb.pop();\n\t\t\tans += check(now + 1);\n\t\t\tb.push(c.top());\n\t\t\tc.pop();\n\t\t}\n\t}\n\n\tif (!c.empty())\n\t{\n\t\tif (b.empty() || b.top() < c.top())\n\t\t{\n\t\t\tb.push(c.top());\n\t\t\tc.pop();\n\t\t\tans += check(now + 1);\n\t\t\tc.push(b.top());\n\t\t\tb.pop();\n\t\t}\n\t}\n\n\n\n\n\treturn ans;\n}\nint main()\n{\n\twhile (1){\n\t\tkotae = 15000099;\n\t\twhile (!a.empty())a.pop();\n\t\twhile (!b.empty())b.pop();\n\t\twhile (!c.empty())c.pop();\n\t\tint su;\n\t\tcin >> su >> kai;\n\t\tif (!su&&!kai)break;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tint qw;\n\t\t\tcin >> qw;\n\t\t\tfor (int I = 0; I < qw; I++)\n\t\t\t{\n\t\t\t\tint A;\n\t\t\t\tcin >> A;\n\t\t\t\tif (i == 0)a.push(A);\n\t\t\t\tif (i == 1)b.push(A);\n\t\t\t\tif (i == 2)c.push(A);\n\t\t\t}\n\t\t}\n\t\tcheck(0);\n\t\tif (kotae != 15000099)cout << kotae << endl;\n\t\telse cout << -1 << endl;\n\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\n#include <climits>\nusing namespace std;\n\nconst int NONE = INT_MAX;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return NONE;\n    S[tuple] = turns;\n    if ( turns > m ) return NONE;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(A);\n        if ( u > v ) {\n            int ret = solve( A | u, remove_last(B), C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(C);\n        if ( u > v ) {\n            int ret = solve( A, remove_last(B), C | u, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return NONE;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        int res = min( ret1, ret2 );\n        if ( res == NONE ) res = -1;\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nint main_calc(int n, int m, stack<int> **tray);\n\nint main(int argc, char const* argv[])\n{\n  int n, m;\n  int size;\n  int val;\n  stack<int> *tray[3];\n\n  while (true) {\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n\n    for (int i = 0; i < 3; i++) {\n      cin >> size;\n      tray[i] = new stack<int>;\n\n      for (int j = 0; j < size; j++) {\n        cin >> val;\n        tray[i]->push(val);\n      }\n    }\n\n    cout << main_calc(n, m, tray) << endl;\n  }\n\n  cin >> n >> m;\n  return 0;\n}\n\nenum Move {\n  AB, BA, BC, CB, NO\n};\n\nvoid move(stack<int> **tray, Move move) {\n  int tray_0 = tray[0]->size() == 0 ? 0 : tray[0]->top();\n  int tray_1 = tray[1]->size() == 0 ? 0 : tray[1]->top();\n  int tray_2 = tray[2]->size() == 0 ? 0 : tray[2]->top();\n\n  switch (move) {\n    case AB:\n             tray[1]->push(tray_0);\n             if (tray[0]->size() > 0) tray[0]->pop();\n             break;\n    case BA:\n             tray[0]->push(tray_1);\n             if (tray[1]->size() > 0) tray[1]->pop();\n             break;\n    case BC:\n             tray[2]->push(tray_1);\n             if (tray[1]->size() > 0) tray[1]->pop();\n             break;\n    case CB:\n             tray[1]->push(tray_2);\n             if (tray[2]->size() > 0) tray[2]->pop();\n             break;\n    case NO:\n             break;\n  }\n}\n\nvector<Move>* get_movables(stack<int> **tray, Move lastmove) {\n  auto moves = new vector<Move>;\n  int tray_0 = tray[0]->size() == 0 ? 0 : tray[0]->top();\n  int tray_1 = tray[1]->size() == 0 ? 0 : tray[1]->top();\n  int tray_2 = tray[2]->size() == 0 ? 0 : tray[2]->top();\n \n  // AB\n  if (tray_0 > tray_1 && lastmove != BA) {\n    moves->push_back(AB);\n  }\n\n  // BA\n  if (tray_1 > tray_0 && lastmove != AB) {\n    moves->push_back(BA);\n  }\n\n  // BC\n  if (tray_1 > tray_2 && lastmove != CB) {\n    moves->push_back(BC);\n  }\n\n  // CB\n  if (tray_2 > tray_1 && lastmove != BC) {\n    moves->push_back(CB);\n  }\n\n  return moves;\n}\n\nstack<int>** copy(stack<int> **tray) {\n  auto **new_tray = new stack<int>*[3];\n  new_tray[0] = new stack<int>(*tray[0]);\n  new_tray[1] = new stack<int>(*tray[1]);\n  new_tray[2] = new stack<int>(*tray[2]);\n  return new_tray;\n}\n\nvoid debugout(stack<int> **tray) {\n    int tray_0 = tray[0]->size() == 0 ? 0 : tray[0]->top();\n    int tray_1 = tray[1]->size() == 0 ? 0 : tray[1]->top();\n    int tray_2 = tray[2]->size() == 0 ? 0 : tray[2]->top();\n\n    cout << tray_0 << \" \" << tray_1 << \" \" << tray_2 << endl;\n}\n\nint single_calc(int m, stack<int> **tray, Move first_move = NO) {\n  int count = 0;\n  auto *moves = get_movables(tray, first_move);\n\n  while (true) {\n    // cout << count << \": \" << moves->size() << endl;\n    // debugout(tray);\n    if (tray[1]->empty() && (tray[0]->empty() || tray[2]->empty())) {\n      // cout << \"end\" << endl;\n      break;}\n\n    Move recent = (*moves)[0];\n    delete moves;\n\n    move(tray, recent);\n    moves = get_movables(tray, recent);\n    count++;\n\n    if (count == m || moves->size() == 0) {\n      return -1;\n    }\n  }\n\n  return count;\n}\n\nint main_calc(int n, int m, stack<int> **tray) {\n  if (tray[1]->empty() && (tray[0]->empty() || tray[1]->empty())) return 0;\n\n  int count = 0, min = m + 1;\n  auto *moves = get_movables(tray, NO);\n\n  if (moves->size() == 0) return -1;\n\n  for (auto& move_type : *moves) {\n    auto copy_tray = copy(tray);\n    move(copy_tray, move_type);\n    count = single_calc(m - 1, copy_tray, move_type);\n\n    if (count != -1 && count + 1 < min) min = count + 1;\n  }\n\n  if (min == m + 1) {\n    return -1;\n  }\n\n  return min;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0503\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst double pi=3.141592653589793;\ntypedef unsigned long long ull;\ntypedef long double ldouble;\nconst ll INF=1e18;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define rep2(i, s, n) for (int i = (s); i < (int)(n); i++)\nconst int MAX_N = 15000000;\nint m, n;\n\nint main(){\n    int j, k;\n    n = 1;\n    m = 1;\n    vector<int> c(16);\n    while(true){\n        cin >> n >> m;\n        if(n == 0 && n == 0) break;\n        rep(i, 3){\n            for(cin >> j; j > 0; --j){\n                cin >> k;\n                c.at(n-k) = i;\n            }\n        }\n\n        int p = 0;\n        int x = 0;\n        for(int i = n-1; i >= 0; i--){\n            int d = abs(p - c.at(i));\n            x += pow(3,i) * d;\n            if(d == 1) p = 2 - p;\n        }\n\n        int y = pow(3,n) - 1 - x;\n        int answer = min(x, y);\n        if(answer <= m) cout << answer << endl;\n        else cout << -1 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nint dp[14400000];\nint N, M;\nint to_hash(const vector<int>&nums) {\n\tint hash = 0;\n\tfor (auto n : nums) {\n\t\thash = 3 * hash + n;\n\t}\n\treturn hash;\n}\nint getans(vector<int>&starts) {\n\tqueue<pair<vector<int>, int>>que;\n\tque.emplace(starts, 0);\n\twhile (!que.empty()) {\n\t\tauto v = que.front();\n\t\tque.pop();\n\t\tvector<int>nums = v.first;\n\t\tint now = v.second;\n\t\tconst int hash = to_hash(nums);\n\t\tif (dp[hash] == false) {\n\t\t\tcontinue;\n\t\t}else {\n\t\t\tdp[hash] = false;\n\t\t\tif (now >= M+1) {\n\t\t\t\treturn M + 1;\n\t\t\t}\n\t\t\tif (to_hash(nums) == 0) {\n\t\t\t\treturn now;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[hash] = false;\n\t\t\t\tvector<int>tops(3, -1);\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\ttops[nums[i]] = i;\n\t\t\t\t}\n\t\t\t\tint ans = M;\n\t\t\t\tif (tops[0] < tops[1]) {\n\t\t\t\t\tif (tops[1] != -1) {\n\t\t\t\t\t\tnums[tops[1]] = 0;\n\t\t\t\t\t\tque.emplace(nums, now + 1);\n\t\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (tops[0] != -1) {\n\t\t\t\t\t\tnums[tops[0]] = 1;\n\t\t\t\t\t\tque.emplace(nums, now + 1);\n\t\t\t\t\t\tnums[tops[0]] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (tops[1] < tops[2]) {\n\t\t\t\t\tif (tops[2] != -1) {\n\t\t\t\t\t\tnums[tops[2]] = 1;\n\t\t\t\t\t\tque.emplace(nums, now + 1);\n\t\t\t\t\t\tnums[tops[2]] = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (tops[1] != -1) {\n\t\t\t\t\t\tnums[tops[1]] = 2;\n\t\t\t\t\t\tque.emplace(nums, now + 1);\n\t\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn M+1;\n\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 14400000; ++i) {\n\t\t\tdp[i] = true;\n\t\t} cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<int>nows(N);\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tfor (int j = 0; j < a; ++j) {\n\t\t\t\tint b; cin >> b; b--;\n\t\t\t\tnows[b] = i;\n\t\t\t}\n\t\t}\n\t\tint ans = getans(nows);\n\t\tif (ans == M+1)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include <stack>\nusing namespace std;\n\n\n\nvoid main()\n{\n\tstack<int>a,b,c;\n\twhile(1)\n\t{\n\t\t\n\t\tint count=0,n,m,check;\n\t\tscanf(\"%d %d\",&n,&m);\n\n\t\tif(n==0 && m==0)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\tbreak;\n\t\t}\n\t\n\t\tint A,B,C,\n\t\t\tkari;\n\t\t\n\t\t/*エラー対策*/\n\t\ta.push(0);\n\t\tb.push(0);\n\t\tc.push(0);\n\n\t\tscanf(\"%d\",&A);\n\t\tfor(int i=0;i<A;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\ta.push(kari);\n\t\t}\n\n\t\tscanf(\"%d\",&B);\n\t\tfor(int i=0;i<B;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\tb.push(kari);\n\t\t}\n\t\n\t\tscanf(\"%d\",&C);\n\t\tfor(int i=0;i<C;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\tc.push(kari);\n\t\t}\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif(b.top()==0 && c.top()==0)\n\t\t\t\tbreak;\n\t\t\tif(a.top()<b.top() && a.top()<c.top()){\n\t\t\t\tkari=b.top();\n\t\t\t\ta.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b.top()<c.top() ){\n\t\t\t\tkari=c.top();\n\t\t\t\tb.push(kari);\n\t\t\t\tc.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b.top()<a.top()){\n\t\t\t\tkari=a.top();\n\t\t\t\tb.push(kari);\n\t\t\t\ta.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(c.top()<b.top() && a.top()!=b.top()-1){\n\t\t\t\tkari=b.top();\n\t\t\t\tc.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t}\n\t\t\telse{\n\t\t\t\tkari=b.top();\n\t\t\t\ta.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(count<m || count==m) printf(\"\\n%d\\n\",count);\n\t\telse printf(\"\\n%d\\n\",-1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n\t\n\tint n, m;\n\t\n\tlong long int a[20] = {};\n\tfor(int i = 1; i < 20; i++){\n\t\ta[i] = a[i - 1] * 3 + 2;\n\t}\n\t\n\twhile(true){\n\t\tcin >> n >> m;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint tile[20] = {};\n\t\tfor(int loop = 0; loop < 3; loop++){\n\t\t\tint num;\n\t\t\tcin >> num;\n\t\t\tfor(int i = 0; i < num; i++){\n\t\t\t\tint num2;\n\t\t\t\tcin >> num2;\n\t\t\t\tnum2 = n - num2 + 1;\n\t\t\t\ttile[num2] = loop;\n\t\t\t}\n\t\t}\n\t\ttile[0] = 10000;\n\t\ttile[n + 1] = 0;\n\t\tlong long int ans = 1000000000LL;\n\t\t\n\t\tlong long int cnt = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(abs(tile[i] - tile[i + 1]) == 1){\n\t\t\t\tif(tile[i] - tile[i + 1] != tile[i - 1] - tile[i] && tile[i + 1] != 1){\n\t\t\t\t\tcnt += a[i] / 2;\n\t\t\t\t}else{\n\t\t\t\t\tcnt *= -1;\n\t\t\t\t\tcnt += a[i] / 2;\n\t\t\t\t}\n\t\t\t}else if(abs(tile[i] - tile[i + 1]) == 2){\n\t\t\t\tcnt *= -1;\n\t\t\t\tcnt += a[i];\n\t\t\t}else if(tile[i] == 1){\n\t\t\t\tcnt *= -1;\n\t\t\t}\n\t\t\t//cout << cnt << \" \";\n\t\t}\n\t\t//cout << cnt << endl;\n\t\tans = min(ans, cnt);\n\t\t\n\t\ttile[n + 1] = 2;\n\t\t\n\t\tcnt = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(abs(tile[i] - tile[i + 1]) == 1){\n\t\t\t\tif(tile[i] - tile[i + 1] != tile[i - 1] - tile[i] && tile[i + 1] != 1){\n\t\t\t\t\tcnt += a[i] / 2;\n\t\t\t\t}else{\n\t\t\t\t\tcnt *= -1;\n\t\t\t\t\tcnt += a[i] / 2;\n\t\t\t\t}\n\t\t\t}else if(abs(tile[i] - tile[i + 1]) == 2){\n\t\t\t\tcnt *= -1;\n\t\t\t\tcnt += a[i];\n\t\t\t}else if(tile[i] == 1){\n\t\t\t\tcnt *= -1;\n\t\t\t}\n\t\t\t//cout << cnt << \" \";\n\t\t}\n\t\t//cout << cnt << endl;\n\t\tans = min(ans, cnt);\n\t\tif(ans > m){\n\t\t\tcout << \"-1\" << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n\n#define MAX 16\n#define A 0\n#define B 1\n#define C 2\n#define M_MAX 16000000\n#define P_MAX 3\n\nusing namespace std;\n\ntemplate<typename _T>\n_T &abs(const _T &x){if(x<0)return -x;else return x;}\n\nint cost[3][MAX];\n\nstruct Cups{\n\tCups(){\n\t\tcost = 0;\n\t\tv[0].reserve(MAX);\n\t\tv[1].reserve(MAX);\n\t\tv[2].reserve(MAX);\n\t}\n\tvector<int> v[P_MAX];\n\tint cost;\n};\n\nint BFS(int n, int m, Cups &st){\n\tint ret = M_MAX;\n\tqueue<Cups> q;\n\tq.push( st );\n\n\twhile( !q.empty() ){\n\t\tCups cups;\n\t\tcups = q.front();\n\t\tq.pop();\n\n\t\t/* I¹ð */\n\t\tif( cups.v[A].size() == n || cups.v[C].size() == n ){\n\t\t\tret = cups.cost;\n\t\t\tbreak;\n\t\t}\n\n\t\tif( cups.cost > m )\n\t\t\tcontinue;\n\n\t\tfor(int i = A; i <= C; ++i){\n\t\t\tint mov_cnt = 1;\n\t\t\tint min_sz = -1;\n\n\t\t\tfor(int j = cups.v[i].size()-1; j >= 1; --j){\n\t\t\t\tif( cups.v[i][j] - cups.v[i][j-1] == 1 ){\n\t\t\t\t\t++mov_cnt;\n\t\t\t\t\tmin_sz = cups.v[i][j-1];\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( cups.v[i].size() == 1 )\n\t\t\t\tmin_sz = cups.v[i][ 0 ];\n\n\t\t\tif( min_sz == -1 )\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tfor(int j = A; j <= C; ++j){\n\t\t\t\tif( i != j ){\n\t\t\t\t\tint d = abs( i - j );\n\t\t\t\t\tCups t = cups;\n\t\t\t\t\tint end = t.v[j].size() - 1;\n\t\t\t\t\tif( end >= 0 && t.v[j][end] > min_sz )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tt.v[j].insert( t.v[j].end(), t.v[i].end() - mov_cnt, t.v[i].end() );\n\t\t\t\t\tt.v[i].erase( t.v[i].end() - mov_cnt, t.v[i].end() );\n\t\t\t\t\tt.cost += cost[ d ][ mov_cnt ];\n\t\t\t\t\tq.push( t );\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcost[1][1] = 1;\n\tcost[2][1] = 2;\n\tfor(int i = 1; i < 3; ++i){\n\t\tfor(int j = 2; j < MAX; ++j){\n\t\t\tif( i == 1 ){\n\t\t\t\tcost[i][j] = 3 * cost[i][j - 1] + 1;\n\t\t\t}else{\n\t\t\t\tcost[i][j] = 2 * cost[1][j];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tint n,m;\n\t\tint ans = 0;\n\t\tCups cups;\n\t\t\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif( n == 0 && m == 0 )\n\t\t\tbreak;\n\n\t\tfor(int i = 0; i < 3; ++i){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tfor(int j = 0; j < t; ++j){\n\t\t\t\tint tt;\n\t\t\t\tscanf(\"%d\", &tt);\n\t\t\t\tcups.v[i].push_back(tt);\n\t\t\t}\n\t\t}\n\t\tans = BFS(n,m,cups);\n\t\t\n\t\tprintf(\"%d\\n\", ans <= m ? ans : -1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <vector>\n#define INF 100000001\n\nusing namespace std;\ntypedef struct P_{\n\t\tvector<int> vec[3];\n\t\tint count = 0;\n} P;\nint n, m;\n\nint main(int argc, char const* argv[])\n{\n\tcin >> n >> m;\n\twhile(n != 0 && m != 0){\n\t\t\tP v;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tint a;\n\t\t\t\t\tcin >> a;\n\t\t\t\t\tfor(int j = 0; j < a; j++){\n\t\t\t\t\t\t\tint b;\n\t\t\t\t\t\t\tcin >> b;\n\t\t\t\t\t\t\tv.vec[i].push_back(b);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<P> q;\n\t\t\tv.count = 0;\n\t\t\tq.push(v);\n\t\t\twhile(!q.empty()){\n\t\t\t\t\tP p = q.front(); q.pop();\n\t\t\t\t\tif(p.count > m){\n\t\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(p.vec[0].size() == n || p.vec[2].size() == n){\n\t\t\t\t\t\t\tcout << p.count << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(p.vec[0].size() != 0){\n\t\t\t\t\t\t\tP np;\n\t\t\t\t\t\t\tnp.count = p.count + 1;\n\t\t\t\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\t\t\t\t\tcopy(p.vec[i].begin(), p.vec[i].end(), back_inserter(np.vec[i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(p.vec[1].size() == 0 || p.vec[1][p.vec[1].size()-1] < p.vec[0][p.vec[0].size()-1]){\n\t\t\t\t\t\t\t\t\tnp.vec[1].push_back(p.vec[0][p.vec[0].size()-1]);\n\t\t\t\t\t\t\t\t\tnp.vec[0].pop_back();\n\t\t\t\t\t\t\t\t\tq.push(np);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.vec[2].size() != 0){\n\t\t\t\t\t\t\tP np;\n\t\t\t\t\t\t\tnp.count = p.count + 1;\n\t\t\t\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\t\t\t\t\tcopy(p.vec[i].begin(), p.vec[i].end(), back_inserter(np.vec[i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(p.vec[1].size() == 0 || p.vec[1][p.vec[1].size()-1] < p.vec[2][p.vec[2].size()-1]){\n\t\t\t\t\t\t\t\t\tnp.vec[1].push_back(p.vec[2][p.vec[2].size()-1]);\n\t\t\t\t\t\t\t\t\tnp.vec[2].pop_back();\n\t\t\t\t\t\t\t\t\tq.push(np);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(p.vec[1].size() != 0){\n\t\t\t\t\t\t\tP np;\n\t\t\t\t\t\t\tnp.count = p.count + 1;\n\t\t\t\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\t\t\t\t\tcopy(p.vec[i].begin(), p.vec[i].end(), back_inserter(np.vec[i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(p.vec[0].size() == 0 || p.vec[0][p.vec[0].size()-1] < p.vec[1][p.vec[1].size()-1]){\n\t\t\t\t\t\t\t\t\tnp.vec[0].push_back(p.vec[1][p.vec[1].size()-1]);\n\t\t\t\t\t\t\t\t\tnp.vec[1].pop_back();\n\t\t\t\t\t\t\t\t\tq.push(np);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\t\t\t\t\tnp.vec[i].clear();\n\t\t\t\t\t\t\t\t\tcopy(p.vec[i].begin(), p.vec[i].end(), back_inserter(np.vec[i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(p.vec[2].size() == 0 || p.vec[2][p.vec[2].size()-1] < p.vec[1][p.vec[1].size()-1]){\n\t\t\t\t\t\t\t\t\tnp.vec[2].push_back(p.vec[1][p.vec[1].size()-1]);\n\t\t\t\t\t\t\t\t\tnp.vec[1].pop_back();\n\t\t\t\t\t\t\t\t\tq.push(np);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tcin >> n >> m;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <stack>\n#include <algorithm>\nusing namespace std;\nint n, m, in;\nstack<int> s[3];\nvoid input(stack<int>& s) {\n    int num; scanf(\"%d\",&num);\n    for (int i=0; i<num; i++) {\n        int x; scanf(\"%d\",&x);\n        s.push(x);\n    }\n}\nvoid clear(stack<int>& s) {\n    while (!s.empty()) s.pop();\n}\n// 0-a 1-b 2-c\nint dfs(int from, int to, int cnt) {\n    if (cnt==m&&s[0].size()!=n&&s[2].size()!=n) return m+1;\n    if (s[0].size()==n||s[2].size()==n) return cnt;\n    int res=m+1;\n    for (int i=0; i<3; i++) {\n        for (int j=0; j<3; j++) {\n            if (i==to&&j==from) continue;\n            if (abs(i-j)!=1) continue;\n            if (s[i].empty()) continue;\n            if (!s[j].empty()&&s[i].top()<s[j].top()) continue;\n            s[j].push(s[i].top()); s[i].pop();\n            res=min(res,dfs(i,j,cnt+1));\n            s[i].push(s[j].top()); s[j].pop();\n        }\n    }\n    return res;\n}\nint main() {\n    while (scanf(\"%d%d\",&n,&m)) {\n        if (!n&&!m) break;\n        clear(s[0]); clear(s[1]); clear(s[2]);\n        input(s[0]); input(s[1]); input(s[2]);\n        int res=m+1;\n        if (s[0].size()==n||s[2].size()==n) res=0;\n        for (int i=0; i<3; i++) {\n            for (int j=0; j<3; j++) {\n                if (s[i].empty()) continue;\n                if (abs(i-j)!=1) continue;\n                if (!s[j].empty()&&s[i].top()<s[j].top()) continue;\n                s[j].push(s[i].top()); s[i].pop();\n                res=min(res, dfs(i,j,1));\n                s[i].push(s[j].top()); s[j].pop();\n            }\n        }\n        printf(\"%d\\n\",res==m+1?-1:res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\n#include <climits>\nusing namespace std;\n\nconst int NONE = INT_MAX;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return NONE;\n    S[tuple] = turns;\n    if ( turns > m ) return NONE;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(A);\n        if ( u > v ) {\n            int ret = solve( A | u, remove_last(B), C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(C);\n        if ( u > v ) {\n            int ret = solve( A, remove_last(B), C | u, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return NONE;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        int res = min( ret1, ret2 );\n        if ( res == NONE ) res = -1;\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "a"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#define INF 1000000000\n\nusing namespace std;\n\nint M, N;\nstack<int> cups[3];\n\nint dfs(int a, int b, int l)\n{\n  if(l >= M)\n    return INF;\n  for(int i = 0; i < 3; i++)\n    if(i != 1 && cups[i].size() - 1 == N)\n      return l;\n  int res = INF;\n  for(int i = 0; i < 3; i++)\n  {\n    for(int j = 0; j < 3; j++)\n    {\n      if(i == j)\n        continue;\n      if(abs(i - j) > 1)\n        continue;\n      if(cups[i].top() <= cups[j].top())\n        continue;\n      if(j == a && i == b)\n        continue;\n      cups[j].push(cups[i].top());\n      cups[i].pop();\n      res = min(res, dfs(i, j, l + 1));\n      cups[i].push(cups[j].top());\n      cups[j].pop();\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  while(true)\n  {\n    cin >> N >> M;\n    if(!N)\n      return 0;\n    \n    for(int i = 0; i < 3; i++)\n    {\n      int n, v;\n      cin >> n;\n      cups[i] = stack<int>();\n      cups[i].push(0);\n      for(int j = 0; j < n; j++)\n      {\n        cin >> v;\n        cups[i].push(v);\n      }\n    }\n    int ans = dfs(-1, -1, 0);\n    cout << (ans == INF ? -1 : ans) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint calc(vector<int> cup, int m)\n{\n    int cnt = 0;\n    while (1) {\n        int i = cnt%2, j = i+1;\n        int p = 1;\n        while (p <= max(cup[i], cup[j])) p <<= 1;\n        p >>= 1;\n        if (!p) break;\n        cup[i] ^= p;\n        cup[j] ^= p;\n        cnt++;\n        if (cnt > m) return cnt;\n    }\n\n    return cnt;\n}\n\nint main()\n{\n    while (1) {\n        int n, m; cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        vector<int> cup(3);\n        loop (3, i) {\n            int c; cin >> c;\n            while (c--) {\n                int v; cin >> v;\n                cup[i] |= 1 << v--;\n            }\n        }\n        int ans = calc(cup, m);\n        swap(cup[0], cup[2]);\n        ans = min(ans, calc(cup, m));\n        cout << (ans <= m ? ans : -1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\nconst int NONE = -1;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(A);\n        if ( u > v ) {\n            int ret = solve( A | u, remove_last(B), C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(C);\n        if ( u > v ) {\n            int ret = solve( A, remove_last(B), C | u, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == NONE && ret2 == NONE ) {\n            cout << -1 << endl;\n        } else if ( ret1 != NONE && ret2 != NONE ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != NONE ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != NONE ) {\n            cout << ret2 << endl;\n        }\n    }\n    cout << \"hoge\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MOD 1000000007\n#define INF 1e9\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\ntemplate<typename T> using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;\n\nint n,m;\n\nint solve(vector<int>& v,int x){\n    int ret=0;\n    rep(i,n){\n        if(v[i]==1){\n            ret+=pow(3,n-1-i);\n            x^=2;\n        }\n        else if(v[i]!=x){\n            ret+=2*pow(3,n-1-i);\n        }\n    }\n    return ret;\n}\n\n\nint main(){\n    \n    while(1){\n        cin>>n>>m;\n        if(n==0 && m==0) break;\n        vector<int> v(n);\n        rep(i,3){\n            int c;\n            cin>>c;\n            rep(j,c){\n                int x;\n                cin>>x;\n                v[x-1]=i;\n            }\n        }\n        int ans=min(solve(v,0),solve(v,2));\n        cout<<((ans>m) ? -1 : ans)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <queue>\nusing namespace std;\n\nint radix[17];\nint end[16][2];\n\nvoid mk_radix() {\n\tint x = 1;\n\tfor(int i = 0; i < 17; i++) {\n\t\tradix[i] = x;\n\t\tx *= 3;\n\t}\n\n\tend[0][0] = 0;\n\tend[0][1] = 2;\n\tfor(int i = 1; i < 16; i++) {\n\t\tend[i][0] = end[i-1][0] + radix[i]*0;\n\t\tend[i][1] = end[i-1][1] + radix[i]*2;\n\t}\n}\n\nint main() {\n\tint n, m;\n\tmk_radix();\n\twhile(cin >> n >> m, n || m) {\n\t\tbitset<50000000> used;\n\t\tint in = 0;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tin += i * radix[a-1];\n\t\t\t}\n\t\t}\n\n\t\tused.set(in);\n\t\tqueue<int> q;\n\t\tq.push(in);\n\t\tint ans = 0;\n\t\tbool flg = false;\n\t\twhile(!q.empty()) {\n\t\t\tqueue<int> nex;\n\t\t\twhile(!q.empty()) {\n\t\t\t\tint a = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tint c[3] = {-1,-1,-1};\n\t\t\t\tint d = 0;\n\n\t\t\t\tif(a == end[n-1][0] || a == end[n-1][1]) {\n\t\t\t\t\tflg = true;\n\t\t\t\t\tgoto EXIT;\n\t\t\t\t}\n\n\t\t\t\tint tmp = a;\n\t\t\t\twhile(d < n) {\n\t\t\t\t\tc[tmp%3] = d;\n\t\t\t\t\ttmp /= 3;\n\t\t\t\t\td++;\n\t\t\t\t}\n\n\t\t\t\tif(c[1] != -1 && c[1] > c[0]) {\n\t\t\t\t\tint e;\n\t\t\t\t\te = (a / radix[c[1] + 1])*radix[c[1] + 1] + 0 * radix[c[1]] + a % radix[c[1]];\n\t\t\t\t\tif(!used[e]) {\n\t\t\t\t\t\tused.set(e);\n\t\t\t\t\t\tnex.push(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c[1] != -1 && c[1] > c[2]) {\n\t\t\t\t\tint e;\n\t\t\t\t\te = (a / radix[c[1] + 1])*radix[c[1] + 1] + 2 * radix[c[1]] + a % radix[c[1]];\n\t\t\t\t\tif(!used[e]) {\n\t\t\t\t\t\tused.set(e);\n\t\t\t\t\t\tnex.push(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c[0] != -1 && c[0] > c[1]) {\n\t\t\t\t\tint e;\n\t\t\t\t\te = (a / radix[c[0] + 1])*radix[c[0] + 1] + 1 * radix[c[0]] + a % radix[c[0]];\n\t\t\t\t\tif(!used[e]) {\n\t\t\t\t\t\tused.set(e);\n\t\t\t\t\t\tnex.push(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c[2] != -1 && c[2] > c[1]) {\n\t\t\t\t\tint e;\n\t\t\t\t\te = (a / radix[c[2] + 1])*radix[c[2] + 1] + 1 * radix[c[2]] + a % radix[c[2]];\n\t\t\t\t\tif(!used[e]) {\n\t\t\t\t\t\tused.set(e);\n\t\t\t\t\t\tnex.push(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans++;\n\t\t\tq = nex;\n\t\t}\n\t\tEXIT:;\n\t\tif(ans <= m && flg)\n\t\t\tcout << ans << endl;\n\t\telse\n\t\t\tcout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\n\nint main() {\n  int input, height, i, j;\n  int n, m;\n  int turns_left, turns_right;\n  int position, d;\n\n  while (true){\n    cin >> n;\n    cin >> m;\n\n    if (n == 0 && m == 0) { break; }\n\n    vector<int> cups(15);\n\n    // input\n    for (i = 0; i < 3; i++) {\n      cin >> height;\n      for (j = 0; j < height; j++) {\n        cin >> input;\n        cups.at(input - 1) = i;\n      }\n    }\n\n    // left\n    position = 0;\n    turns_left = 0;\n    for (i = 0; i < n; i++) {\n      d = position - cups.at(i);\n      if (d == 0) {\n      } else if (d == 1 || d == -1) {\n        turns_left += static_cast<int>(pow(3, (n - 1) - i));\n        if (position == 0) {\n          position = 2;\n        } else if (position == 2) {\n          position = 0;\n        }\n      } else if (d == 2 || d == -2) {\n        turns_left += 2 * static_cast<int>(pow(3, (n - 1) - i));\n      }\n    }\n\n    // right\n    position = 2;\n    turns_right = 0;\n    for (i = 0; i < n; i++) {\n      d = position - cups.at(i);\n      if (d == 0) {\n      } else if (d == 1 || d == -1) {\n        turns_right += static_cast<int>(pow(3, (n - 1) - i));\n        if (position == 0) {\n          position = 2;\n        } else if (position == 2) {\n          position = 0;\n        }\n      } else if (d == 2 || d == -2) {\n        turns_right += 2 * static_cast<int>(pow(3, (n - 1) - i));\n      }\n    }\n\n    cout << (min(turns_left, turns_right) <= m ? min(turns_left, turns_right) : -1) << endl;\n\n    cups.clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint calc(vector<int> cup, int m)\n{\n    int cnt = 0;\n    while (1) {\n        int i = cnt%2, j = i+1;\n        int p = 1;\n        while (p <= max(cup[i], cup[j])) p <<= 1;\n        p >>= 1;\n        if (!p) break;\n        cup[i] ^= p;\n        cup[j] ^= p;\n        cnt++;\n        if (cnt > m) return cnt;\n    }\n\n    return cnt;\n}\n\nint main()\n{\n    while (1) {\n        int n, m; cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        vector<int> cup(3);\n        loop (3, i) {\n            int c; cin >> c;\n            while (c--) {\n                int v; cin >> v;\n                cup[i] |= 1 << v--;\n            }\n        }\n        int ans = calc(cup, m);\n        swap(cup[0], cup[2]);\n        ans = min(ans, calc(cup, m));\n        cout << (ans <= m ? ans : -1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint main(){\n    while(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n == 0 && m == 0 ) break;\n\tset< vector<int> > s;\n\tvector< vector<int> > cup(3);\n\tREP(i,3){\n\t    int t;\n\t    cin >> t;\n\t    REP(j,t){\n\t\tint temp;\n\t\tcin >> temp;\n\t\tcup[i].PB(temp);\n\t    }\n\t}\n\tqueue< vector< vector<int> > > q;\n\tqueue<int> qv;\n\tq.push(cup);\n\tqv.push(0);\n\tint ans = 2000000000;\n\twhile(!q.empty()){\n\t    cup = q.front();\n\t    int v = qv.front();\n\t    q.pop();\n\t    qv.pop();\n\t    vector<int> temp(3,0);\n\t    REP(i,3){\n\t\tREP(j,cup[i].size()){\n\t\t    temp[i] += 1<<cup[i][j];\n\t\t}\n\t    }\n\n\t    if(s.find(temp) != s.end()) continue;\n\t    else s.insert(temp);\n\t    if(cup[1].size() == 0 && (cup[0].size() == 0||cup[2].size() == 0)){\n\t\tans = v;\n \t\tbreak;\n\t    }\n\t    REP(i,2){\n\t\tif(cup[i].size() > 0 && (cup[i+1].size() == 0 || cup[i].back() > cup[i+1].back())){\n\t\t    cup[i+1].PB(cup[i].back());\n\t\t    cup[i].erase(cup[i].end()-1);\n\t\t    q.push(cup);\n\t\t    qv.push(v+1);\n\t\t    cup[i].PB(cup[i+1].back());\n\t\t    cup[i+1].erase(cup[i+1].end()-1);\n\t\t}\n\t\tif(cup[i+1].size() > 0 && (cup[i].size() == 0 || cup[i].back() < cup[i+1].back())){\n\t\t    cup[i].PB(cup[i+1].back());\n\t\t    cup[i+1].erase(cup[i+1].end()-1);\n\t\t    q.push(cup);\n\t\t    qv.push(v+1);\n\t\t    cup[i+1].PB(cup[i].back());\n\t\t    cup[i].erase(cup[i].end()-1);\n\t\t}\n\t    }\n\t}\n\tif(ans > m) ans = -1;\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n    int n,m;\n    typedef tuple<vector<char>,vector<char>,int> T;\n    while(1){\n        cin >> n >> m;\n        if(n == 0 && m == 0)break;\n        //vector<char> cup(n,0);\n        vector<char> cup;\n        vector<char> beforecup;\n        cup.resize(n);\n\n        bool flag = true;\n        rep(i,3){\n            int n1;\n            cin >> n1;\n            rep(j,n1){\n                int n2;\n                cin >> n2;\n                n2--;\n                cup[n2] = i;\n            }\n        }//入力ここまで\n        queue<T> que;\n        que.push(T(cup,cup,0));\n        while(que.size()!=0){\n            T state = que.front();\n            cup = get<0>(state);\n            beforecup = get<1>(state);\n            int movecount = get<2>(state);\n            que.pop();\n            //rep(i,cup.size())cout << cup[i];\n            //cout << endl;\n            int bigger[3];\n            int maxcount = 0;\n            bool tray[3] ={true,true,true};\n            if(n == count(cup.begin(),cup.end(),0) ||n == count(cup.begin(),cup.end(),2)){\n                cout << movecount << endl;\n                flag = false;\n                break;\n            }\n            rep(i,n){\n                int i2 = n-i-1;\n                rep(j,3){\n                    if(tray[j] == true && cup[i2] == j){\n                        tray[j] = false;\n                        bigger[maxcount] = i2;\n                        maxcount++;\n                        break;\n                    }\n                }\n                if(maxcount == 3)break;\n            }\n            movecount++;\n            if(movecount > m) break;\n            if(cup[bigger[0]]-1 >= 0){\n                cup[bigger[0]]--;\n                if(cup != beforecup) que.push(T(cup,get<0>(state),movecount));\n                cup[bigger[0]]++;\n            }\n            if(cup[bigger[0]]+1 <= 2){\n                cup[bigger[0]]++;\n                if(cup != beforecup) que.push(T(cup,get<0>(state),movecount));\n                cup[bigger[0]]--;\n            }\n            if(maxcount >= 2){\n                if(cup[bigger[1]]-1 >= 0 && cup[bigger[1]]-1 != cup[bigger[0]]){\n                    cup[bigger[1]]--;\n                    if(cup != beforecup) que.push(T(cup,get<0>(state),movecount));\n                    cup[bigger[1]]++;\n                }\n                else if(cup[bigger[1]]+1 <= 2 && cup[bigger[1]]+1 != cup[bigger[0]]){\n                    cup[bigger[1]]++;\n                    if(cup != beforecup) que.push(T(cup,get<0>(state),movecount));\n                    cup[bigger[1]]--;\n                }\n            }\n        }\n        if(flag) cout << \"-1\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n\nint n, m, cnt, a[16], b[16];\n\nvoid move(int num, int dest, int* a);\n\nint main() {\n\t\n\twhile (1) {\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0)break;\n\n\t\tint num, tmp;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcin >> num;\n\t\t\tfor (int j = 0; j < num; j++) {\n\t\t\t\tcin >> tmp;\n\t\t\t\ta[tmp] = i;\n\t\t\t\tb[tmp] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcnt = 0;\n\t\tfor (int num = 1; num <= n; num++) {\n\t\t\tmove(num, 2, a);\n\t\t}\n\t\tint ans1 = cnt;\n\t\t\n\t\tcnt = 0;\n\t\tfor (int num = 1; num <= n; num++) {\n\t\t\tmove(num, 0, b);\n\t\t}\n\t\tint ans2 = cnt;\n\n\t\tint ans;\n\t\tif (ans1 == -1) {\n\t\t\tans = ans2;\n\t\t} else if(ans2 == -1){\n\t\t\tans = ans1;\n\t\t} else {\n\t\t\tans = min(ans1, ans2);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn 0;\n}\n\nvoid move(int num, int dest, int* a) {\n\t\n\tif (cnt > m || cnt == -1) {\n\t\tcnt = -1;\n\t\treturn;\n\t}\n\n\tint dist = abs(dest - a[num]);\n\tif (dist == 0) {\n\t\treturn;\n\t} else if (dist == 1) {\n\t\tif (num == n) {\n\t\t\tcnt += 1;\n\t\t\ta[num] = dest;\n\t\t} else {\n\t\t\tmove(num + 1, 3 - dest - a[num], a);\n\t\t\tcnt += 1;\n\t\t\ta[num] = dest;\n\t\t}\n\t} else if (dist == 2) {\n\t\tif (num == n) {\n\t\t\tcnt += 2;\n\t\t\ta[num] = dest;\n\t\t} else {\n\t\t\tmove(num, 1, a);\n\t\t\tmove(num, dest, a);\n\t\t}\n\t}\n\n\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tll out=0;\n\t\trep(i,3){\n\t\t\tint a;cin>>a;\n\t\t\trep(j,a){\n\t\t\t\tint b;cin>>b;\n\t\t\t\tif(i==1)out+=pow(3,n-b);\n\t\t\t}\n\t\t}\n\t\tif(out>m)cout<<-1<<endl;\n\t\telse cout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef struct Cup\n{\n\tvector<int>P[3];\n\tint T;\n\tbool operator <(const Cup &a)const{ return T>a.T;};\n}S;\nint N,M;\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&M),N;)\n\t{\n\t\tCup tmp;\n\t\tint i,j,t,q,R=-1;\n\t\tfor(i=0;i<3;i++)\n\t\t{\n\t\t\tfor(scanf(\"%d\",&t),j=0;j<t;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&q);\n\t\t\t\ttmp.P[i].push_back(q);\n\t\t\t}\n\t\t}\n\n\t\ttmp.T=0;\n\t\tpriority_queue<Cup> Q;\n\t\tQ.push(tmp);\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\ttmp=Q.top();Q.pop();\n\t\t\tif(tmp.T>M)continue;\n\t\t\tif(tmp.P[0].size()==N||tmp.P[2].size()==N)\n\t\t\t{\n\t\t\t\tR=tmp.T;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tfor(int j=-1;j<2;j++)\n\t\t\t\t{\n\t\t\t\t\tif(i+j>=0&&i+j<3&&!tmp.P[i].empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tint tmp1=tmp.P[i].back();\n\t\t\t\t\t\tint tmp2=-1;\n\t\t\t\t\t\tif(!tmp.P[i+j].empty())\n\t\t\t\t\t\t\ttmp2=tmp.P[i+j].back();\n\t\t\t\t\t\tif(tmp1>tmp2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCup ins=tmp;\n\t\t\t\t\t\t\tins.P[i+j].push_back(tmp1);\n\t\t\t\t\t\t\tins.P[i].pop_back();\n\t\t\t\t\t\t\tins.T++;\n\t\t\t\t\t\t\tQ.push(ins);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tll dp[16] = {};\n\tdp[0] = 1;\n\trep(i,1, n+1) {\n\t\tdp[i] = dp[i - 1] * 3;\n\t}\n\tvector<int> pos(n);\n\tREP(i, 3) {\n\t\tint c;\n\t\tscanf(\"%d\", &c);\n\n\n\t\tREP(j, c) {\n\t\t\tint size;\n\t\t\tscanf(\"%d\", &size);\n\n\t\t\tpos[size-1] = i;\n\t\t}\n\t}\n\t//reverse(ALL(pos));\n\tll ans = 0,ans2 = 0;\n\tbool curs = 0;\n\tREP(i, n) {\n\t\tif (pos[i] % 2) {\n\t\t\tans += dp[n - i - 1];\n\t\t\tcurs = 1-curs;\n\t\t}\n\t\telse if (curs*2-pos[i]) {\n\t\t\tans += dp[n - i - 1] + 1;\n\t\t}\n\t}\ncurs = 1;\n\tREP(i, n) {\n\t\tif (pos[i] % 2) {\n\t\t\tans2 += dp[n - i - 1];\n\t\t\tcurs = 1 - curs;\n\t\t}\n\t\telse if (curs * 2 - pos[i]) {\n\t\t\tans2 += dp[n - i - 1] + 1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", min(ans2, ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint mp[15000000];\nint Hash(string s) {\n\tint cnt = 0, t = 1;\n\trep(i, s.size()) {\n\t\tcnt += s[i]*t;\n\t\tt *= 3;\n\t}\n\treturn cnt;\n}\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tmemset(mp, 0, sizeof(mp));\n\t\tstring in(15, 0);\n\t\trep(i, 3) {\n\t\t\tint len; scanf(\"%d\", &len);\n\t\t\trep(j, len) {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tin[--a] = i;\n\t\t\t}\n\t\t}\n\t\tqueue<string>que;\n\t\tmp[Hash(in)] = 1;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tstring u = que.front(); que.pop();\n\t\t\tif (count(u.begin(), u.begin() + n, 0) == n ||\n\t\t\t\tcount(u.begin(), u.begin() + n, 2) == n) {\n\t\t\t\tprintf(\"%d\\n\", mp[Hash(u)] - 1);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (mp[Hash(u)] > m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tint fi = u.rfind(i, n - 1), fj = u.rfind(j, n - 1);\n\t\t\t\tif (fi == -1 || fi < fj)continue;\n\t\t\t\tstring v = u;\n\t\t\t\tv[fi] = j;\n\t\t\t\tif (!mp[Hash(v)]) {\n\t\t\t\t\tmp[Hash(v)] = mp[Hash(u)] + 1;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,P> pip;\nconst int inf=(1<<31)-1;\n\nint n,m;\nvvi date;\n\nint func(int x){\n\tint an=3;\n\tfor(int i=0;i<x-1;i++) an*=an;\n\treturn an;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(!n&&!m) break;\n\t\tint lef=0,rig=0;\n\t\tdate=vvi(3);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint tn;\n\t\t\tcin>>tn;\n\t\t\tfor(int j=0;j<tn;j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tdate[i].push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tfor(int  i=0;i<3;i+=2){\n\t\t\tint now=i;\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tint tmp1;\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tbool q=1;\n\t\t\t\t\tfor(int r=0;r<date[k].size();r++){\n\t\t\t\t\t\tif(j==date[k][r]){\n\t\t\t\t\t\t\ttmp1=k;\n\t\t\t\t\t\t\tq=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j>date[k][r]) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!q) break;\n\t\t\t\t}\n\t\t\t\tint t=abs(now-tmp1);\n/*\t\t\t\tif(i==0) cout<<'L'<<now<<' '<<tmp1<<endl;\n\t\t\t\telse cout<<'R'<<now<<' '<<tmp1<<endl;\n\t\t\t\tcout<<t<<endl;*/\n\t\t\t\tif(!t) continue;\n\t\t\t\tif(i==0){\n\t\t\t\t\tlef+=t*func(n-j);\n\t\t\t\t\tif(lef>m) break;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\trig+=t*func(n-j);\n\t\t\t\t\tif(rig>m) break;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<t;k++){\n\t\t\t\t\tif(now==0) now=2;\n\t\t\t\t\telse now=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout<<lef<<' '<<rig<<endl;\n\t\tint ans=min(lef,rig);\n\t\tif(ans>m) cout<<-1<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<long long int, vector<vector<int>>> PVVI;\n\nint main() {\n\tset<vector<vector<int>>>SVVI;\n\tlong long int N, M;\n\twhile( cin >> N >> M, M&&N ) {\n\t\tvector<vector<int>>D( 3, vector<int>( 1 ) );\n\t\tfor( size_t i = 0; i < 3; i++ ) {\n\t\t\tlong long int x;\n\t\t\tcin >> x;\n\t\t\tfor( size_t j = 0; j < x; j++ ) {\n\t\t\t\tlong long int y;\n\t\t\t\tcin >> y;\n\t\t\t\tD[i].push_back( y );\n\t\t\t}\n\t\t}\n\t\tpriority_queue<PVVI, vector<PVVI>, greater<PVVI>>que;\n\t\tque.push( make_pair( 0, D ) );\n\t\tSVVI.insert( D );\n\t\tbool f = 1;\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tif( (now.second[0].size() == 1 || now.second[2].size() == 1) && now.second[1].size() == 1 ) {\n\t\t\t\tcout << now.first << endl;\n\t\t\t\tf = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( now.second[0].size() != 1 ) {\n\t\t\t\tauto now2 = now.second;\n\t\t\t\tauto num = *(now2[0].rbegin());\n\t\t\t\tif( num > *(now2[1].rbegin()) && now.first + 1 < M ) {\n\t\t\t\t\tnow2[0].pop_back();\n\t\t\t\t\tnow2[1].push_back( num );\n\t\t\t\t\tif( SVVI.find( now2 ) == SVVI.end() ) {\n\t\t\t\t\t\tSVVI.insert( now2 );\n\t\t\t\t\t\tque.push( make_pair( now.first + 1, now2 ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( now.second[1].size() != 1 ) {\n\t\t\t\tauto now2 = now.second;\n\t\t\t\tauto now3 = now.second;\n\t\t\t\tauto num = *(now2[1].rbegin());\n\t\t\t\tif( num > *(now2[0].rbegin()) && now.first + 1 < M ) {\n\t\t\t\t\tnow2[1].pop_back();\n\t\t\t\t\tnow2[0].push_back( num );\n\t\t\t\t\tif( SVVI.find( now2 ) == SVVI.end() ) {\n\t\t\t\t\t\tSVVI.insert( now2 );\n\t\t\t\t\t\tque.push( make_pair( now.first + 1, now2 ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( num > *(now3[2].rbegin()) && now.first + 1 < M ) {\n\t\t\t\t\tnow3[1].pop_back();\n\t\t\t\t\tnow3[2].push_back( num );\n\t\t\t\t\tif( SVVI.find( now3 ) == SVVI.end() ) {\n\t\t\t\t\t\tSVVI.insert( now3 );\n\t\t\t\t\t\tque.push( make_pair( now.first + 1, now3 ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( now.second[2].size() != 1 ) {\n\t\t\t\tauto now3 = now.second;\n\t\t\t\tauto num = *(now3[2].rbegin());\n\t\t\t\tif( num > *(now3[1].rbegin()) && now.first + 1 < M ) {\n\t\t\t\t\tnow3[2].pop_back();\n\t\t\t\t\tnow3[1].push_back( num );\n\t\t\t\t\tif( SVVI.find( now3 ) == SVVI.end() ) {\n\t\t\t\t\t\tSVVI.insert( now3 );\n\t\t\t\t\t\tque.push( make_pair( now.first + 1, now3 ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( f )cout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 3;\nconst int INF = 15000001;\n\nclass S{\npublic:\n  int t[N], cost;\n  S(int a = 0, int b = 0, int c = 0, int cost = 0) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n\nint n, m;\n//int ans;\n\nint calc(S s, int pres, int pret){\n  //if(ans <= s.cost) return INF;\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  if(s.cost >= m) return INF;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, 0);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<N;j++){\n      if(s.t[j] & 1 << i){\n        tmp[j] = i;\n        break;\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i]){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(i == pret && j == pres) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          //ans = min(ans, res);\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint solve(S s){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, 0);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<N;j++){\n      if(s.t[j] & 1 << i){\n        tmp[j] = i;\n        break;\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i]){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          //ans = min(ans, res);\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[N];\n    for(int i=0;i<N;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    //ans = INF;\n    cout << solve(S(data[0], data[1], data[2], 0)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nvoid solve(){\n    int n,m;\n    while(1){\n        cin >> n >> m;\n        if(n == 0 && m == 0)break;\n        vector<char> cup(n,0);\n        bool flag = true;\n        rep(i,3){\n            int n1;\n            cin >> n1;\n            rep(j,n1){\n                int n2;\n                cin >> n2;\n                n2--;\n                cup[n2] = i;\n            }\n        }//入力ここまで\n        queue<vector<char>> que;\n        que.push(cup);\n        map<vector<char>,int> mp;\n        mp[cup] = 0;\n        while(que.size()!=0){\n            cup = que.front();\n            que.pop();\n            //rep(i,cup.size())cout << cup[i];\n            //cout << endl;\n            int bigger[3];\n            int maxcount = 0;\n            bool tray[3] ={true,true,true};\n            if(cup.size() == count(cup.begin(),cup.end(),0) ||cup.size() == count(cup.begin(),cup.end(),2)){\n                cout << mp[cup] << endl;\n                flag = false;\n                break;\n            }\n            rep(i,n){\n                int i2 = n-i-1;\n                rep(j,3){\n                    if(tray[j] == true && cup[i2] == j){\n                        tray[j] = false;\n                        bigger[maxcount] = i2;\n                        maxcount++;\n                        break;\n                    }\n                }\n                if(maxcount == 3)break;\n            }\n            int movecount = mp[cup] + 1;\n            if(movecount > m) break;\n            if(cup[bigger[0]]-1 >= 0){\n                cup[bigger[0]]--;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]++;\n            }\n            if(cup[bigger[0]]+1 <= 2){\n                cup[bigger[0]]++;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]--;\n            }\n            if(maxcount >= 2){\n                if(cup[bigger[1]]-1 >= 0 && cup[bigger[1]]-1 != cup[bigger[0]]){\n                    cup[bigger[1]]--;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]++;\n                }\n                else if(cup[bigger[1]]+1 <= 2 && cup[bigger[1]]+1 != cup[bigger[0]]){\n                    cup[bigger[1]]++;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]--;\n                }\n            }\n        }\n        if(flag) cout << \"-1\" << endl;\n    }\n}\nint main(){\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> mat;\n\nconst int INF = 1 << 28;\nint n, m;\n\nbool check(mat &v) {\n    if (v[0].size() == n + 1 || v[2].size() == n + 1)\n        return true;\n    return false;\n}\n\nstring stom(mat &v) {\n    string res;\n    res = \"\";\n    for (int i = 0; i < 3; i++) {\n        for (auto j : v[i]) {\n            if (j < 0) continue;\n            res = res + (char)('a' + j);\n        }\n        for (int j = v[i].size(); j <= n; j++) {\n            res = res + '0';\n        }\n    }\n    return res;\n}\n\nset<string> M;\n\nvoid hoge(mat &v, vector<mat> &next) {\n    if (M.find(stom(v)) != M.end()) return;\n    M.insert(stom(v));\n    for (int i = 0; i < 3; i++) {\n        if (v[i].size() > 1) {\n            for (int j = 0; j < 3; j++) {\n                if (i == j || v[i][v[i].size() - 1] < v[j][v[j].size() - 1]) continue;\n                if (i == 0 && j == 2) continue;\n                if (i == 2 && j == 0) continue;\n                v[j].push_back(v[i][v[i].size() - 1]);\n                v[i].erase(v[i].end() - 1);\n                next.push_back(v);\n                v[i].push_back(v[j][v[j].size() - 1]);\n                v[j].erase(v[j].end() - 1);\n            }\n        }\n    }\n}\n\n\nint main() {\n    while (cin >> n >> m, n || m) {\n        mat v(3);\n        for (int i = 0; i < 3; i++) {\n            int n_; cin >> n_;\n            v[i].push_back(-1);\n            for (int j = 0; j < n_; j++) {\n                int x; cin >> x;\n                v[i].push_back(x);\n            }\n        }\n\n        int res = 0;\n        vector<mat> G;\n        G.push_back(v);\n        while (res <= m) {\n            vector<mat> G_(G);\n            G.resize(0);\n            for (auto g : G_) {\n                if (check(g)) {\n                    goto escap;\n                }\n                hoge(g, G);\n            }\n            res++;\n        }\nescap:\n        cout << (res > m ? -1 : res) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 1001001001;\n\nint n, m;\nstack<int> t[3];\n\nint dfs(int depth = 0) {\n  if (max(t[0].size(), t[2].size()) == n + 1) return 0;\n  if (depth == m) return inf;\n\n  int ret = inf;\n\n  if (t[0].top() < t[1].top()) {\n    t[0].push(t[1].top());\n    t[1].pop();\n\n    ret = min(ret, dfs(depth + 1) + 1);\n\n    t[1].push(t[0].top());\n    t[0].pop();\n  }\n  if (t[0].top() > t[1].top()) {\n    t[1].push(t[0].top());\n    t[0].pop();\n\n    ret = min(ret, dfs(depth + 1) + 1);\n\n    t[0].push(t[1].top());\n    t[1].pop();\n  }\n\n  if (t[2].top() < t[1].top()) {\n    t[2].push(t[1].top());\n    t[1].pop();\n\n    ret = min(ret, dfs(depth + 1) + 1);\n\n    t[1].push(t[2].top());\n    t[2].pop();\n  }\n  if (t[2].top() > t[1].top()) {\n    t[1].push(t[2].top());\n    t[2].pop();\n\n    ret = min(ret, dfs(depth + 1) + 1);\n\n    t[2].push(t[1].top());\n    t[1].pop();\n  }\n\n  return ret;\n}\n\nint main() {\n  while (cin >> n >> m, n) {\n    for (int i = 0; i < 3; ++i) {\n\n      t[i] = stack<int>();\n      t[i].push(0);\n\n      int a;\n      cin >> a;\n      for (int j = 0; j < a; ++j) {\n        int x;\n        cin >> x;\n\n        t[i].push(x);\n      }\n    }\n\n    int ans = dfs();\n    cout << (ans == inf ? -1 : ans) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct State {\n  vector<int> S[3];\n  int step;\n  int parent_from;\n  int parent_to;\n\n  bool empty(size_t i) const { return S[i].size() == 0; }\n  void push(size_t i, int v) { S[i].push_back(v); }\n  void pop(size_t i) { S[i].pop_back(); }\n  int top(size_t i) const { return S[i].back(); }\n};\n\nbool Done(const State& s, const State& goal) {\n  for (int i = 0; i <= 2; ++i) {\n    if (s.S[i].size() != goal.S[i].size()) return false;\n    if (s.S[i] != goal.S[i])\n      return false;\n  }\n  return true;\n}\n\ninline bool IsMovable(int from, int to, const State& p) {\n  if (to < 0 || to >= 3) return false;\n  if (p.empty(from)) return false;\n  if (to == p.parent_from && from == p.parent_to) return false;\n  return p.empty(to) || p.top(from) > p.top(to);\n}\n\nint BFS(const State& start, const State& goal) {\n  queue<State> q;\n  q.push(start);\n\n  int step = 0;\n  while (!q.empty()) {\n    const auto p = q.front();\n    q.pop();\n\n    if (Done(p, goal)) {\n      step = p.step;\n      break;\n    }\n    for (int from = 0; from < 3; ++from) {\n      for (int d : {-1, 1}) {\n        const int to = from + d;\n        if (IsMovable(from, to, p)) {\n          State new_state = p;\n          new_state.step = p.step + 1;\n          new_state.parent_from = from;\n          new_state.parent_to = to;\n          new_state.push(to, p.top(from));\n          new_state.pop(from);\n          q.push(new_state);\n        }\n      }\n    }\n  }\n  return step;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  for (;;) {\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n\n    // 初期状態\n    State start;\n    start.step = 0;\n    start.parent_from = -1;\n    start.parent_to = -1;\n    for (int i = 0; i < 3; ++i) {\n      int t;\n      cin >> t;\n      int k;\n      for (int j = 0; j < t; ++j) {\n        cin >> k;\n        start.S[i].push_back(k);\n      }\n    }\n    // Cにすべてのコップが重ねられている状態\n    State goal;\n    goal.step = 0;\n    goal.parent_from = -1;\n    goal.parent_to = -1;\n    for (int i = 1; i <= n; ++i) {\n      goal.S[2].push_back(i);\n    }\n\n    const int N = pow(3, n) - 1;\n    const int step = BFS(goal, start);\n    const int ans = min(step, N - step);\n    if (ans <= m)\n      cout << ans << endl;\n    else\n      cout << \"-1\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nbool use[15000000];\n\nint main(){\n  int n,m,now;\n\n  for(;;){\n    cin >> n >> m;\n    if(!n && !m)break;\n\n    now = 0;\n    for(int i=0;i<3;i++){\n      int num;\n      cin >> num;\n      for(int j=0;j<num;j++){\n\tint tmp;\n\tcin >> tmp;\n\tnow += pow(3,tmp-1)*i;\n      }\n    }\n\n    int lim = pow(3,n);\n    for(int i=0;i<lim;i++)use[i] = false;\n    use[now] = true;\n\n    int ans = -1;\n\n    queue<P> q;\n    q.push(P(now,0));\n\n    while(q.size()){\n      P p = q.front();q.pop();\n      int s[3] = {-1,-1,-1};\n      now = p.first;\n      for(int i=1;i<=n;i++){\n\ts[now%3] = i;\n\tnow/=3;\n      }\n     \n      if( (s[0]<0 && s[1]<0) || (s[1]<0 && s[2]<0) ){\n\tans = p.second;\n\tbreak;\n      }\n      if(p.second>m)break;\n\n      int d1[] = {0,1,1,2},d2[] = {1,0,2,1};\n\n      for(int i=0;i<4;i++){\n\tif(s[d1[i]]>=0 && (s[d2[i]]<0 || s[d1[i]]>s[d2[i]])){\n\t  int hoge = pow(3,s[d1[i]]-1);\n\t  now = p.first - hoge*d1[i] + hoge*d2[i];\n\t  if(!use[now]){\n\t    use[now] = true;\n\t    q.push(P(now,p.second+1));\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<set>\n#include<algorithm>\n\n#define MAX 16\n#define A 0\n#define B 1\n#define C 2\n#define P_MAX 3\n#define M_MAX 16000000\n\nusing namespace std;\n\nstruct Cups{\n\tCups(){\n\t\tcost = 0;\n\t\tv[0].reserve(MAX);\n\t\tv[1].reserve(MAX);\n\t\tv[2].reserve(MAX);\n\t}\n\tlong long int key[P_MAX];\n\tvector<int> v[P_MAX];\n\tbool operator<(const Cups &t)const{\n\t\tif( cost < t.cost )\n\t\t\treturn true;\n\t\telse if( cost == t.cost && key[0] < t.key[0] )\n\t\t\treturn true;\n\t\telse if( cost == t.cost && key[0] == t.key[0] && key[1] < t.key[1] )\n\t\t\treturn true;\n\t\telse if( cost == t.cost && key[0] == t.key[0] && key[1] == t.key[1] && key[2] < t.key[2] )\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\tbool operator==(const Cups &t)const{\n\t\tif( key[0] == t.key[0] && key[1] == t.key[1] && key[2] == t.key[2] && cost <= t.cost )\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\tvoid CalcKey(){\n\t\tfor(int i = 0; i < P_MAX; ++i){\n\t\t\tkey[i] = 0;\n\t\t\tfor(unsigned int j = 0; j < v[i].size(); ++j){\n\t\t\t\tkey[i] += ( key[i] + 10 * v[i][j] );\n\t\t\t}\n\t\t}\n\t}\n\tint cost;\n};\nostream &operator<<(ostream &os, const vector<int> &v){\n\tfor(unsigned int i = 0; i < v.size(); ++i){\n\t\tos << v[i] << ' ';\n\t}\n\treturn os;\n}\nostream & operator << (ostream &os, const Cups &t){\n\tos << \"A: \" << t.v[0] << \"\\t\\tB: \" << t.v[1] << \"\\t\\tC: \" << t.v[2] << \"\\t\\tCost :\" << t.cost;\n\treturn os;\n}\nint cost[3][MAX];\n\nint BFS(int n, int m, int greedy, Cups &st){\n\tint ret = M_MAX;\n\tset<Cups> vis_set;\n\tqueue<Cups> q;\n\n\tst.CalcKey();\n\tvis_set.insert( st );\n\tq.push( st );\n\twhile( !q.empty() ){\n\t\tCups cups;\n\t\tcups = q.front();\n\n\t\tq.pop();\n\n\t\t/* I¹ð */\n\t\tif( cups.v[A].size() == n || cups.v[C].size() == n ){\n\t\t\tret = min(ret, cups.cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = A; i <= C; ++i){\n\t\t\tint mov_cnt = 1;\n\t\t\tint min_sz = -1;\n\n\t\t\tfor(int j = cups.v[i].size()-1; j >= 1; --j){\n\t\t\t\tif( cups.v[i][j] - cups.v[i][j-1] == 1 ){\n\t\t\t\t\t++mov_cnt;\n\t\t\t\t\tmin_sz = cups.v[i][j-1];\n\t\t\t\t}else{\n\t\t\t\t\tmin_sz = cups.v[i][j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( cups.v[i].size() == 1 )\n\t\t\t\tmin_sz = cups.v[i][0];\n\n\t\t\tif( min_sz == -1 )\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tfor(int w = 1; w <= mov_cnt; ++w){\n\t\t\t\tfor(int j = A; j <= C; ++j){\n\t\t\t\t\tint d = abs( i - j );\n\t\t\t\t\tif( d == 2 || d == 0 )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tCups t = cups;\n\t\t\t\t\tint end = t.v[j].size() - 1;\n\t\t\t\t\tif( end >= 0 && t.v[j][end] > min_sz )\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tt.v[j].insert( t.v[j].end(), t.v[i].end() - w, t.v[i].end() );\n\t\t\t\t\tt.v[i].erase( t.v[i].end() - w, t.v[i].end() );\n\t\t\t\t\tt.cost += cost[ 1 ][ w ];\n\n\t\t\t\t\t//cout << t;\n\n\t\t\t\t\tt.CalcKey();\n\t\t\t\t\tif( t.cost <= m && t.cost < ret && t.cost <= greedy && vis_set.find( t ) == vis_set.end() ){\n\t\t\t\t\t\tq.push( t );\n\t\t\t\t\t\tvis_set.insert( t );\n\t\t\t\t\t\t//cout << \" ACCEPTED\\n\";\n\t\t\t\t\t}//else\n\t\t\t\t\t\t//cout << \" REJECTED\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint Greedy( int n, const Cups &cups){\n\tint ret = 0;\n\tint places[MAX];\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(unsigned int j = 0; j < cups.v[i].size(); ++j ){\n\t\t\tplaces[ cups.v[i][j] ] = i;\n\t\t}\n\t}\n\tfor(int i = n; i >= 2; --i){\n\t\tint d = abs(places[i] - places[i-1]); \n\t\tret += cost[ d ][ n - i + 1 ];\n\t}\n\tif( places[1] == B )\n\t\tret += cost[ 1 ][ n ];\n\n\treturn ret;\n}\nint main(){\n\tcost[1][1] = 1;\n\tcost[2][1] = 2;\n\tfor(int i = 1; i < 3; ++i){\n\t\tfor(int j = 2; j < MAX; ++j){\n\t\t\tif( i == 1 ){\n\t\t\t\tcost[i][j] = 3 * cost[i][j - 1] + 1;\n\t\t\t}else{\n\t\t\t\tcost[i][j] = 2 * cost[1][j];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tint n,m;\n\t\tint greedy;\n\t\tint ans = 0;\n\t\tCups cups;\n\t\t\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif( n == 0 && m == 0 )\n\t\t\tbreak;\n\n\t\tfor(int i = 0; i < 3; ++i){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tfor(int j = 0; j < t; ++j){\n\t\t\t\tint tt;\n\t\t\t\tscanf(\"%d\", &tt);\n\t\t\t\tcups.v[i].push_back(tt);\n\t\t\t}\n\t\t}\n\t\tgreedy = Greedy( n, cups );\n\t\tans = BFS(n, m, greedy, cups );\n\t\t\n\t\tprintf(\"%d\\n\", ans <= m ? ans : -1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\n\nint n,m;\nvector<int>a[3];\nint calc(int i){\n\tint res=INT_MAX;\n\tif(i>m)return res;\n\tif(a[0].size()==n||a[2].size()==n)return i;\n\trep(k,3){\n\t\tif(!a[k].size())continue;\n        int j=a[k][a[k].size()-1];\n\t\trep(t,3){\n\t\t    if((k==0&&t==2)||(k==2&&t==0))continue;\n\t\t\tif(t==k)continue;\n\t\t\tif(a[t].size()&&j<a[t][a[t].size()-1])continue;\n\t\t\ta[k].pop_back();a[t].push_back(j);\n\t\t\tres=min(res,calc(i+1));\n\t\t\ta[k].push_back(j);a[t].pop_back();\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n    while(cin>>n>>m,n){\n    rep(i,3)a[i].clear();\n\trep(i,3){\n\t\tint k;cin>>k;\n\t\trep(j,k){int t;scanf(\"%d\",&t);a[i].push_back(t);}\n\t}\n\tint i=calc(0);\n\tif(i==INT_MAX)cout<<-1<<endl;\n\telse cout<<i<<endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nint limit,num_cup,ans;\nbool Log[14348907],FLG;\nchar ch;\nshort a_loc,b_loc,c_loc;\n\n\nstruct Info{\n\tint value;\n\tchar loc;\n};\n\nstruct Data{\n\tData(){\n\t\tcount = 0;\n\t}\n\tData(int arg_count,char arg_table[15]){\n\t\tcount = arg_count;\n\t\tfor(int i = 0; i < 15; i++)table[i] = arg_table[i];\n\t}\n\tchar table[15];\n\tint count;\n};\n\nvoid setCode(char table[15], int &calc){\n\tint S = 1;\n\tcalc = 0;\n\tfor(int i = 0; i < num_cup; i++){\n\t\tif(table[i] == 'A'){\n\t\t\tcalc += 0;\n\t\t}else if(table[i] == 'B'){\n\t\t\tcalc += S;\n\t\t}else{\n\t\t\tcalc += 2*S;\n\t\t}\n\t\tS *= 3;\n\t}\n}\n\nvoid bfs(char table[15]){\n\n\tqueue<Data> Q;\n \tQ.push(Data(0,table));\n \tchar new_table[4][15];\n\n \tData tmp;\n \twhile(!Q.empty()){\n \t\ttmp.count = Q.front().count;\n \t\tfor(int i = 0; i < 15; i++){\n \t\t\ttmp.table[i] = Q.front().table[i];\n \t\t}\n \t\tQ.pop();\n\n \t\t//?????????????????¢?????????????????????\n \t\tFLG = true;\n \t\tch = tmp.table[0];\n\n \t\tif(ch == 'B')FLG = false;\n\n \t\tif(FLG){\n \t\t\tfor(int i = 1; i <= num_cup-1; i++){\n \t\t\t\tif(tmp.table[i] != ch){\n \t\t\t\t\tFLG = false;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\tif(FLG){\n \t\t\tans = tmp.count;\n \t\t\tbreak;\n \t\t}\n\n \t\tif(tmp.count == limit){\n \t\t\tcontinue; //?¬????limit+1??????????????£?????????????????§??????\n \t\t}\n\n \t\tfor(int i = 0; i < 4; i++){\n \t\t\tfor(int k = 0; k < num_cup; k++)new_table[i][k] = tmp.table[k];\n \t\t}\n\n \t\t//A,B,C????????§?????´????????¢???\n \t\ta_loc = b_loc = c_loc = -1; //?????¨???????????????-1??§????§????????????¨???????????§OK\n \t\tfor(int i = num_cup-1; i >= 0; i--){\n \t\t\tif(tmp.table[i] == 'A'){\n \t\t\t\ta_loc = (a_loc >= i)?a_loc:i;\n \t\t\t}else if(tmp.table[i] == 'B'){\n \t\t\t\tb_loc = (b_loc >= i)?b_loc:i;\n \t\t\t}else{\n \t\t\t\tc_loc = (c_loc >= i)?c_loc:i;\n \t\t\t}\n \t\t}\n\n \t\tint calc;\n\n \t\t//A???????????????B???\n \t\t//B????????§????????§??????????????????:?§????:?±\\??´?????????????????????:?±\\??´??????????????°?????°\n \t\tif(a_loc > b_loc){\n \t\t\tnew_table[0][a_loc] = 'B';\n\n \t\t\tsetCode(new_table[0],calc);\n \t\t\tif(Log[calc] == false){\n \t\t\t\tLog[calc] = true;\n \t\t\t\tQ.push(Data(tmp.count+1,new_table[0]));\n \t\t\t}\n \t\t}\n\n \t\t//B???????????????A???\n \t\tif(b_loc > a_loc){\n \t\t\tnew_table[1][b_loc] = 'A';\n\n \t\t\tsetCode(new_table[1],calc);\n \t\t\tif(Log[calc] == false){\n \t\t\t\tLog[calc] = true;\n \t\t\t\tQ.push(Data(tmp.count+1,new_table[1]));\n \t\t\t}\n \t\t}\n\n \t\t//C???????????????B???\n \t\tif(c_loc > b_loc){\n \t\t\tnew_table[2][c_loc] = 'B';\n\n \t\t\tsetCode(new_table[2],calc);\n \t\t\tif(Log[calc] == false){\n \t\t\t\tLog[calc] = true;\n \t\t\t\tQ.push(Data(tmp.count+1,new_table[2]));\n \t\t\t}\n \t\t}\n\n \t\t//B???????????????C???\n \t\tif(b_loc > c_loc){\n \t\t\tnew_table[3][b_loc] = 'C';\n\n \t\t\tsetCode(new_table[3],calc);\n \t\t\tif(Log[calc] == false){\n \t\t\t\tLog[calc] = true;\n \t\t\t\tQ.push(Data(tmp.count+1,new_table[3]));\n \t\t\t}\n \t\t}\n \t}\n }\n\nint main(){\n\n\tint a,b,c,index,calc;\n\tInfo info[15];\n\tchar table[15];\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&num_cup,&limit);\n\t\tif(num_cup == 0 && limit == 0)break;\n\n\t\tfor(int i = 0; i < 14348907; i++){\n\t\t\tLog[i] = false;\n\t\t}\n\n\t\tindex = 0;\n\t\tscanf(\"%d\",&a);\n\n\t\tfor(int i = 0; i < a; i++){\n\t\t\tscanf(\"%d\",&info[index].value);\n\t\t\tinfo[index].loc = 'A';\n\t\t\tindex++;\n\t\t}\n\n\t\tscanf(\"%d\",&b);\n\t\tfor(int i = 0; i < b; i++){\n\t\t\tscanf(\"%d\",&info[index].value);\n\t\t\tinfo[index].loc = 'B';\n\t\t\tindex++;\n\t\t}\n\n\t\tscanf(\"%d\",&c);\n\t\tfor(int i = 0; i < c; i++){\n\t\t\tscanf(\"%d\",&info[index].value);\n\t\t\tinfo[index].loc = 'C';\n\t\t\tindex++;\n\t\t}\n\n\t\tfor(int i = 1; i <= num_cup-1; i++){\n\t\t\tfor(int k = num_cup-1; k >= i; k--){\n\t\t\t\tif(info[k].value < info[k-1].value)swap(info[k],info[k-1]);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < num_cup;i++){\n\t\t\ttable[i] = info[i].loc;\n\t\t}\n\n\t\t//??¶??????????????????\n\t\tsetCode(table,calc); //a_calc??¨c_calc?????°???????????????????????¨?????????????????????????????????\n\n\t\tLog[calc] = true;\n\n\t\tans = -1;\n\n\t\tbfs(table);\n\n\t\tprintf(\"%d\\n\",ans);\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\n#include <queue>\nusing namespace std;\n#define F first\n#define S second\nconst int INF=100000000;\n\nint ans;\nunsigned int n,m;\n//vector<stack<int> > goal(3);\n\nstruct state{\n\tstack<int> s[3];\n\tint count,from,to;\n\t/*\n\tstate(stack<int> hoge[3]){\n\t\tfor(int i=0; i<3; ++i){\n\t\t\ts[i]=hoge[i];\n\t\t}\n\t}\n\t*/\n};\n\nvoid bfs(stack<int> si[3],int f,int t){\n\tstate hoge;\n\tfor(int i=0 ;i<3; ++i) hoge.s[i]=si[i];\n\thoge.count=0;\n\thoge.from=f;\n\thoge.to=t;\n\tqueue<state> que;\n\tque.push(hoge);\n\twhile(!que.empty()){\n\t\tstate st=que.front();\n\t\tque.pop();\n\t\t//cout << st.count << endl;\n\t\tif(st.count>m) continue;\n\t\tif(st.s[0].size()==n||st.s[2].size()==n){\n\t\t\tans=min(ans,st.count);\n\t\t\treturn;\n\t\t}\n\t\tif(!(st.from==1&&st.to==0)&&st.s[0].size()!=0&&(st.s[1].size()==0||st.s[0].top()>st.s[1].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[1].push(ns.s[0].top());\n\t\t\tns.s[0].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=0;\n\t\t\tns.to=1;\n\t\t\tque.push(ns);\n\t\t}\n\t\tif(!(st.from==0&&st.to==1)&&st.s[1].size()!=0&&(st.s[0].size()==0||st.s[1].top()>st.s[0].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[0].push(ns.s[1].top());\n\t\t\tns.s[1].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=1;\n\t\t\tns.to=0;\n\t\t\tque.push(ns);\n\t\t} else if(!(st.from==2&&st.to==1)&&st.s[1].size()!=0&&(st.s[2].size()==0||st.s[1].top()>st.s[2].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[2].push(ns.s[1].top());\n\t\t\tns.s[1].pop();//\n\t\t\t++ns.count;\n\t\t\tns.from=1;\n\t\t\tns.to=2;\n\t\t\tque.push(ns);\n\t\t}\n\t\tif(!(st.from==1&&st.to==2)&&st.s[2].size()!=0&&(st.s[1].size()==0||st.s[2].top()>st.s[1].top())){\n\t\t\tstate ns=st;\n\t\t\tns.s[1].push(ns.s[2].top());\n\t\t\tns.s[2].pop();\n\t\t\t++ns.count;\n\t\t\tns.from=2;\n\t\t\tns.to=1;\n\t\t\tque.push(ns);\n\t\t}\n\t}\n}\n\n/*\nvoid dfs(stack<int> s[3],int count,pair<int,int> f){\n\tif(count>m) return;\n\tif(s[0].size()==n||s[2].size()==n){\n\t\tans=min(ans,count);\n\t\treturn;\n\t}\n\t//f.F -->f.S\n\t//01 10 12 21\n\tif(!(f.F==1&&f.S==0)&&s[0].size()!=0&&(s[1].size()==0||s[0].top()>s[1].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[1].push(ns[0].top());\n\t\tns[0].pop();\n\t\tdfs(ns,count+1,pair<int,int>(0,1));\n\t}\n\tif(!(f.F==0&&f.S==1)&&s[1].size()!=0&&(s[0].size()==0||s[1].top()>s[0].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[0].push(ns[1].top());\n\t\tns[1].pop();\n\t\tdfs(ns,count+1,pair<int,int>(1,0));\n\t}\n\tif(!(f.F==2&&f.S==1)&&s[1].size()!=0&&(s[2].size()==0||s[1].top()>s[2].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[2].push(ns[1].top());\n\t\tns[1].pop();\n\t\tdfs(ns,count+1,pair<int,int>(1,2));\n\t}\n\tif(!(f.F==1&&f.S==2)&&s[2].size()!=0&&(s[1].size()==0||s[2].top()>s[1].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[1].push(ns[2].top());\n\t\tns[2].pop();\n\t\tdfs(ns,count+1,pair<int,int>(2,1));\n\t}\n}\n*/\n\nint main(){\n\tint pow3[16];\n\tfor(int i=1; i<=15; ++i){\n\t\tpow3[i]=i*i*i-1;\n\t}\n\twhile(cin >> n >> m){\n\tif(n==0&&m==0) break;\n\t\tans=INF;\n\t\tstack<int> cup[3];\n\t\tfor(int i=0; i<3; ++i){\n\t\t\tint q;\n\t\t\tcin >> q;\n\t\t\tfor(int j=0; j<q; ++j){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tcup[i].push(tmp);\n\t\t\t\t//cout << cup[i].top() << endl;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\t/*\n\t\tdfs(cup,0,pair<int,int>(0,1));\n\t\tdfs(cup,0,pair<int,int>(1,0));\n\t\tdfs(cup,0,pair<int,int>(1,2));\n\t\tdfs(cup,0,pair<int,int>(2,1));\n\t\t*/\n\t\tbfs(cup,0,1);\n\t\tbfs(cup,1,0);\n\t\tbfs(cup,1,2);\n\t\tbfs(cup,2,1);\n\t\tif(ans!=INF) ans=min(ans,pow3[n]-ans);\n\t\tif(ans!=INF) cout << ans << endl;\n\t\telse cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdlib.h>\n#include<cstdio>\n#include<unordered_map>\n#include<unordered_set>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<stack>\n#include<map>\n#include<string.h>\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nsigned main() {\n\tvector<int>O;\n\tO.push_back(1); O.push_back(2); O.push_back(3);\n\tint a, b;\n\twhile (cin >> a >> b, a | b) {\n\t\tint sum[2]{}; int S = 0;\n\t\tvector<int>V[3];\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tint d; cin >> d;\n\t\t\tfor (int e = 0; e < d; e++) {\n\t\t\t\tint c; cin >> c;\n\t\t\t\tV[i].push_back(c);\n\t\t\t}\n\t\t}\n\t\tint x = 0, y = 0;//???????????????\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tvector<int>q = V[0], w = V[1], p = V[2];\n\t\t\t\tif (abs(i - j) == 1) {\n\t\t\t\t\tif (V[i].size() && (V[j].size() == 0 || *V[i].rbegin() > *V[j].rbegin())) {\n\t\t\t\t\t\tV[j].push_back(*V[i].rbegin());\n\t\t\t\t\t\tV[i].pop_back();\n\t\t\t\t\t\tx = i; y = j;\n\t\t\t\t\t\tsum[S]++;\n\t\t\t\t\t\tfor (int K = 0; K <= b; K++) {\n\t\t\t\t\t\t\tif (V[1].size() == 0 && (V[0].size() == 0 || V[2].size() == 0))break;\n\t\t\t\t\t\t\tsum[S]++;\n\t\t\t\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\t\t\t\t\tif (abs(i - j) == 1) {\n\t\t\t\t\t\t\t\t\t\tif (V[i].size() && (V[j].size() == 0 || *V[i].rbegin() > *V[j].rbegin())) {\n\t\t\t\t\t\t\t\t\t\t\tif (y != i || x != j) {\n\t\t\t\t\t\t\t\t\t\t\t\tV[j].push_back(*V[i].rbegin());\n\t\t\t\t\t\t\t\t\t\t\t\tV[i].pop_back();\n\t\t\t\t\t\t\t\t\t\t\t\tx = i; y = j;\n\t\t\t\t\t\t\t\t\t\t\t\tgoto l;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tl:;\n\t\t\t\t\t\t\tif (K == b)sum[S] = 1 << 29;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tS++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tV[0] = q; V[1] = w; V[2] = p;\n\t\t\t}\n\t\t}\n\t\tint MIN = min(sum[0], sum[1]);\n\t\tif (MIN == 1 << 29)puts(\"-1\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nint where[15];\nint n;\n\nll calc(int a,int b){\n\tll ans=1;\n\tif(b<=0)\treturn 0;\n\tfor(int i=0;i<b;i++){\n\t\tans*=a;\n\t}\n\treturn ans-1;\n}\n\nll check(bool left){\n\tll ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tint now=left?0:2;\n\t\tif(abs(now-where[i])==2){\n\t\t\tans+=2*calc(3,n-i-1)+2;\n\t\t}\n\t\telse if(where[i]==1){\n\t\t\tans+=calc(3,n-i-1)+1;\n\t\t\tleft^=1;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn ans;\n}\n\nint main(){\n\trefrain:;\n\tint m;\tcin>>n>>m;\n\tif((n|m)==0)\treturn 0;\n\tint num,in;\n\tfor(int i=0;i<3;i++){\n\t\tcin>>num;\n\t\tfor(int j=0;j<num;j++){\n\t\t\tcin>>in;\n\t\t\twhere[in-1]=i;\n\t\t}\n\t}\n\tll ans=min(check(true),check(false));\n\tif(ans<=m)\tcout<<max(0LL,ans)<<endl;\n\telse \tcout<<-1<<endl;\n\tgoto refrain;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <stdlib.h>\n#include <string.h>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <stdio.h>\n#include <tuple>\n#include <bitset>\n#include <cfloat>\n#include <fstream>\n#include <limits.h>\n#include <list>\n#include <math.h>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#define int long long\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FORR(i,a,b)for(int i=(a);i<=(b);i++)\n#define repR(i,n) for(int i=n;i>=0;i--)\n#define P pair<int, int>\n#define sz(x) x.size()\n#define ALL(x) (x).begin(),(x).end()\n#define ALLR(x) (x).rbegin(),(x).rend()\n#define VE vector<int>\n#define COUT(x) cout<<(x)<<endl\n#define MA map<int,int>\n#define SE set<int>\n#define PQ priority_queue<int>\n#define PQR priority_queue<int,VE,greater<int>>\n#define COUT(x) cout<<(x)<<endl\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nusing namespace std;\ntypedef long long ll;\nll gcd(ll a, ll b) {\n\tif (a < b)swap(a, b);\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nll lcm(ll a, ll b) {\n\tll g = gcd(a, b);\n\treturn a / g * b;\n}\nbool prime(int n) {\n\tfor (int i = 2; i <= sqrt(n); i++) {\n\t\tif (n%i == 0)return false;\n\t}\n\treturn n != 1;\n}\nbool compare_by_b(pair<int, int> a, pair<int, int> b) {\n\tif (a.second != b.second) {\n\t\treturn a.second < b.second;\n\t}\n\telse {\n\t\treturn a.first < b.first;\n\t}\n}\n\nconst long long MOD = 1000000007;\nconst long long INF = 1LL << 50;\n// pair -> vector<pair<int,int>> \n//\t\t   AandB.push_back(make_pair(a[i],b[i]))\n\n#define Int long long\n\n\nsigned main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tInt n, m;\n\n\twhile (cin >> n >> m, n) {\n\t\tauto encode = [n](auto &v) {\n\t\t\tInt x = 0;\n\t\t\tfor (Int i = 0; i < n; i++) x = x * 3 + v[i];\n\t\t\treturn x;\n\t\t};\n\n\t\tauto decode = [n](Int x) {\n\t\t\tvector<Int> v(n);\n\t\t\tfor (Int i = 0; i < n; i++) {\n\t\t\t\tv[n - (i + 1)] = x % 3;\n\t\t\t\tx /= 3;\n\t\t\t}\n\t\t\treturn v;\n\t\t};\n\n\t\tvector<Int> dp(14348907, -1);\n\n\t\tqueue<Int> q;\n\t\tfor (Int i = 0; i < 2; i++) {\n\t\t\tvector<Int> b(n, i * 2);\n\t\t\tInt k = encode(b);\n\t\t\tdp[k] = 0;\n\t\t\tq.emplace(k);\n\t\t}\n\n\t\twhile (!q.empty()) {\n\t\t\tInt k = q.front();\n\t\t\tvector<Int> v = decode(k); q.pop();\n\t\t\tvector<Int> x(3, -1);\n\t\t\tfor (Int i = 0; i < n; i++) x[v[i]] = i;\n\t\t\tfor (Int i = 0; i < 3; i++) {\n\t\t\t\tfor (Int j = 0; j < 3; j++) {\n\t\t\t\t\tif (i == j || abs(i - j) == 2) continue;\n\t\t\t\t\tif (x[i] > x[j]) {\n\t\t\t\t\t\tv[x[i]] = j;\n\t\t\t\t\t\tInt nk = encode(v);\n\t\t\t\t\t\tif (dp[nk] < 0) {\n\t\t\t\t\t\t\tdp[nk] = dp[k] + 1;\n\t\t\t\t\t\t\tq.emplace(nk);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv[x[i]] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<Int> v(n);\n\t\tfor (Int i = 0; i < 3; i++) {\n\t\t\tInt k;\n\t\t\tcin >> k;\n\t\t\tfor (Int j = 0; j < k; j++) {\n\t\t\t\tInt x;\n\t\t\t\tcin >> x;\n\t\t\t\tv[x - 1] = i;\n\t\t\t}\n\t\t}\n\t\tInt k = encode(v);\n\t\t//cout<<k<<\":\"<<dp[k]<<endl;\n\t\tcout << (dp[k] > m ? -1 : dp[k]) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string>\n#include<stdlib.h>\n#include<stdio.h>\n#include<map>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nstack<int> X[3];\nint n, m;\nint ans;\nint owa;\nvoid aho(int a, int b)\n{\n\tX[b].push(X[a].top());\n\tX[a].pop();\n\treturn;\n}\nint k1[4] = { 0, 1, 1, 2 };\nint k2[4] = { 1, 0, 2, 1 };\nint check(int now)\n{\n\tif (now > owa)return m + 2;\n\tif (X[1].empty())\n\t{\n\t\tif (X[0].empty() || X[2].empty())\n\t\t{\n\t\t\towa = now + 1;\n\t\t\t//cout << now << endl;\n\t\t\treturn now;\n\t\t}\n\t}\n\tif (now == m )\n\t{\n\t\treturn m+2;\n\t}\n\tint ans = m+1;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tif (X[k1[i]].empty())continue;\n\t\tif (X[k2[i]].empty());\n\t\telse \n\t\tif (X[k1[i]].top() <= X[k2[i]].top())continue;\n\t\taho(k1[i], k2[i]);\n\t\tans=min(check(now + 1),ans);\n\t\taho(k2[i], k1[i]);\n\t}\n\treturn ans;\n\t\n\n}\n\nint main()\n{\n\twhile (1){\n\t\tcin >> n >> m;\n\t\tif (n == 0)\n\t\t\tif (m == 0)\n\t\t\t\tbreak;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\twhile (!X[i].empty())X[i].pop();\n\t\tans = m + 1;\n\t\towa = m;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tint g;\n\t\t\tcin >> g;\n\t\t\tfor (int I = 0; I < g; I++)\n\t\t\t{\n\t\t\t\tint s; cin >> s;\n\t\t\t\tX[i].push(s);\n\t\t\t}\n\t\t}\n\t\tint g = check(0);\n\t\tif (g > m)\n\t\t{\n\t\t\tg = -1;\n\t\t}\n\t\tcout << g << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define INF 15\n#define A 0\n#define B 1\n#define C 2\n\nchar cond[INF];\nchar n;\nint  m;\nint sum;\n\nvoid move(int pos, char dist) {\n    char now = cond[pos];\n\n    if (now == dist) {\n        return;\n    } else if (abs(now-dist) == 2) {\n        move(pos, B);\n        move(pos, dist);\n    } else {\n        int i;\n        char no_present = (dist+now == 1)?C:\n                          (dist+now == 2)?B:\n                                          A;\n        for (i=1;pos+i < n;i++){\n            if (cond[pos+i] == dist || cond[pos+i] == now) {\n                move(pos+i, no_present);\n            }\n        }\n\n        cond[pos] = dist;\n        sum += 1;\n    }\n\n    return;\n}\n\nint main() {\n    while (1) {\n        int i;\n        char dist;\n    \n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m ==0) {\n            break;\n        }\n\n        for (i=0;i < 3;i++) {\n            int j,k;\n\n            scanf(\"%d\", &k);\n            for (j=0;j < k;j++) {\n                int tmp;\n    \n                scanf(\"%d\", &tmp);\n                cond[tmp-1] = i;\n            }\n        }\n    \n        dist = (cond[0] != B)?cond[0]:A;\n    \n        for (i=0;i < n;i++) {\n            move(i, dist);\n        }\n    \n        if (sum <= m) {\n            printf(\"%d\\n\", sum);\n        } else {\n            printf(\"-1\\n\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nbool visited[14500000];\n\n\nint mypow(int x,int n){\n\tint res = 1;\n\twhile(n>0){\t\t\n\t\tres *= x;\n\t\tif(n & 1) x = x*x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\n\nint conv(vector<int>& sets,int n){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * mypow(3,j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,int n,vector<int>& root,bool* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root,n)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(!visited[(next = conv(tmp,n))]){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(!visited[(next = conv(tmp,n))]){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\t\n\t\tmemset(visited,0,sizeof(visited));\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,n,sets,visited));\n\t}\n\t//printf(\"%d %d %d\\n\",mypow(3,0),mypow(3,1),mypow(3,2));\n}"
  },
  {
    "language": "C++",
    "code": "//00\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\n\n#define LB(c) ((c)&(~(c)+1))\n\nusing namespace std;\n\nmap<int,int> mem;\n\nstruct S{\n  int c[3];\n  int t;\n};\n\nint cv(int *a){\n  int r=0;\n  for(int i=0;i<15;i++){\n    r*=3;\n    for(int j=0;j<3;j++){\n      r+=!!(a[j]&1<<i)*j;\n    }\n  }\n  return r;\n}\n\nint main(){\n  queue<S> que;\n  S is[2]={{{(1<<15)-1,0,0},0},{{0,0,(1<<15-1)},0}};\n  que.push(is[0]);\n  que.push(is[1]);\n  while(!que.empty()){\n    S c=que.front();\n    que.pop();\n    int x=cv(c.c);\n    if(mem.count(x))continue;\n    mem[x]=c.t;\n    for(int i=0;i<3;i++){\n      for(int j=-1;j<=1;j+=2){\n\tint nc=i+j;\n\tif(0<=nc&&nc<3&&c.c[i]&&(!c.c[nc]||LB(c.c[i])<LB(c.c[nc]))){\n\t  S n=c;\n\t  n.c[nc]|=LB(c.c[i]);\n\t  n.c[i]&=~LB(c.c[i]);\n\t  n.t++;\n\t  que.push(n);\n\t}\n      }\n    }\n  }\n  for(int n,m;cin>>n>>m,n|m;){\n    int is[3]={};\n    for(int i=0;i<3;i++){\n      int k;\n      cin>>k;\n      while(k--){\n\tint c;\n\tcin>>c;\n\tis[i]|=1<<(n-c);\n      }\n    }\n    int ms=((1<<15)-1)^((1<<n)-1);\n    is[0]^=ms;\n    int a=1<<30;\n    int c=cv(is);\n    if(mem.count(c)){\n      a=min(a,mem[c]);\n    }\n    is[0]^=ms;\n    is[2]^=ms;\n    c=cv(is);\n    if(mem.count(c)){\n      a=min(a,mem[c]);\n    }\n    cout<<((a>m)?-1:a)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<string>\n#include<climits>\n#include<deque>\n\nusing namespace std;\n\nint m;\nstack<int,vector<int> >A,B,C;\n\nint func(int,string);\n\nint main(void){\n  int n,ans,s,t;\n  \n  while(cin >> n >> m,n|m){\n    while(!A.empty())A.pop();\n    while(!B.empty())B.pop();\n    while(!C.empty())C.pop();\n    \n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      A.push(t);\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      B.push(t);\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      C.push(t);\n    }\n    ans=func(0,\"\");\n    if(ans==INT_MAX)cout << -1 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}\n\nint func(int cnt,string p){\n  \n  if(cnt>m)return INT_MAX;\n  \n  if(B.empty() && (C.empty()||A.empty()))\n    return cnt;\n  \n  int res=INT_MAX;\n  \n  if(!A.empty() && A.top()>=B.top() && p!=\"BA\"){\n    B.push(A.top());\n    if(!A.empty())A.pop();\n    res=min(res,func(cnt+1,\"AB\"));\n    A.push(B.top());\n    if(!B.empty())B.pop();\n  }\n  \n  if(!B.empty()){\n    if(B.top()>=C.top() && p!=\"CB\"){\n      C.push(B.top());\n      if(!B.empty())B.pop();\n      res=min(res,func(cnt+1,\"BC\"));\n      B.push(C.top());\n      if(!C.empty())C.pop();\n    }\n    \n    if(B.top()>=A.top() && p!=\"AB\"){\n      A.push(B.top());\n      if(!B.empty())B.pop();\n      res=min(res,func(cnt+1,\"BA\"));\n      B.push(A.top());\n      if(!A.empty())A.pop();\n    }\n  }\n  \n  if(!C.empty() && C.top()>=B.top() && p!=\"BC\"){\n    B.push(C.top());\n    if(!C.empty())C.pop();\n    res=min(res,func(cnt+1,\"CB\"));\n    C.push(B.top());\n    if(!B.empty())B.pop();\n  }\n  \n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <random>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <thread>\n#include <functional>\n#include <bitset>\n\n#define FOR_LT(i, beg, end) for (int i = beg; i < end; i++)\n#define FOR_LE(i, beg, end) for (int i = beg; i <= end; i++)\n#define FOR_DO(i, first, last) for (int i = first; last <= i; i--)\n\nusing namespace std;\n\nbool is_goal(int n, uint32_t state) {\n\tif (state == 0) return true;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (((state >> (i * 2)) & 3) != 2) return false;\n\t}\n\n\treturn true;\n}\n\nstruct Search {\n\tint64_t  val;\n\tuint32_t state;\n\n\tSearch& operator *() { return *this; }\n};\n\nvoid add(priority_queue < Search, vector<Search>, function<bool(const Search&, const Search&)>> & search,\n\tunordered_set<uint32_t> & searched, const Search & cur)\n{\n\tif (searched.find(cur.state) != searched.end()) {\n\t\treturn;\n\t}\n\n\tsearch.push(cur);\n\tsearched.insert(cur.state);\n}\n\nvoid solve(int n, int m)\n{\n\tuint32_t init_state = 0;\n\t{\n\t\tint n_a; cin >> n_a;\n\t\tFOR_LT(i, 0, n_a) {\n\t\t\t// do nothing\n\t\t\tint a; cin >> a;\n\t\t}\n\n\t\tint n_b; cin >> n_b;\n\t\tFOR_LT(i, 0, n_b) {\n\t\t\tint b; cin >> b;\n\t\t\tb--;\n\t\t\tinit_state |= (1 << (b * 2));\n\t\t}\n\n\t\tint n_c; cin >> n_c;\n\t\tFOR_LT(i, 0, n_c) {\n\t\t\tint c; cin >> c;\n\t\t\tc--;\n\t\t\tinit_state |= (2 << (c * 2));\n\t\t}\n\t}\n\n\tunordered_set<uint32_t> searched;\n\n\tpriority_queue < Search, vector<Search>, function<bool(const Search&, const Search&)>>\n\t\tsearch([](const auto & lhs, const auto & rhs) { return lhs.val > rhs.val; });\n\tsearch.push({ 0, init_state });\n\tsearched.insert(init_state);\n\n\twhile (!search.empty()) {\n\t\tconst auto cur = search.top();\n\t\tsearch.pop();\n\n\t\tif (m < cur.val) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn;\n\t\t}\n\n\t\tif (is_goal(n, cur.state)) {\n\t\t\tcout << cur.val << endl;\n\t\t\treturn;\n\t\t}\n\n\t\tint has_top_a = 0;\n\t\tint has_top_b = 0;\n\t\tint has_top_c = 0;\n\t\tFOR_DO(i, n - 1, 0) {\n\t\t\tuint32_t s = ((cur.state) >> (i * 2)) & 3;\n\n\t\t\tif (!has_top_a && s == 0) {\n\t\t\t\tif (!has_top_b) {\n\t\t\t\t\tuint32_t next = cur.state;\n\t\t\t\t\tnext ^= (1 << (i * 2));\n\t\n\t\t\t\t\tadd(search, searched, { cur.val + 1, next});\n\t\t\t\t}\n\t\t\t\thas_top_a = 1;\n\t\t\t}\n\t\t\tif (!has_top_b && s == 1) {\n\t\t\t\tif (!has_top_a) {\n\t\t\t\t\tuint32_t next = cur.state;\n\t\t\t\t\tnext ^= (1 << (i * 2));\n\n\t\t\t\t\tadd(search, searched, { cur.val + 1, next });\n\t\t\t\t}\n\t\t\t\tif (!has_top_c) {\n\t\t\t\t\tuint32_t next = cur.state;\n\t\t\t\t\tnext ^= (3 << (i * 2));\n\n\t\t\t\t\tadd(search, searched, { cur.val + 1, next });\n\t\t\t\t}\n\t\t\t\thas_top_b = 1;\n\t\t\t}\n\t\t\tif (!has_top_c && s == 2) {\n\t\t\t\tif (!has_top_b) {\n\t\t\t\t\tuint32_t next = cur.state;\n\t\t\t\t\tnext ^= (3 << (i * 2));\n\n\t\t\t\t\tadd(search, searched, { cur.val + 1, next });\n\t\t\t\t}\n\t\t\t\thas_top_c = 1;\n\t\t\t}\n\t\t\tif (has_top_a + has_top_b + has_top_c == 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tassert(!\"error\");\n}\n\nint main()\n{\n\twhile (true) {\n\t\tint n, m; cin >> n >> m;\n\t\tif (n == 0 && m == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tsolve(n, m);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// C++ 14\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <math.h>\n#include <sstream>\n#include <unistd.h>\n\n#define ll long long\n#define Int int\n#define loop(x, start, end) for(Int x = start; x < end; x++)\n#define loopdown(x, start, end) for(int x = start; x > end; x--)\n#define rep(n) for(int __x = 0; __x < n; __x++)\n#define span(a,x,y) a.begin()+x,a.begin()+y\n#define span_all(a) a.begin(),a.end()\n#define len(x) (x.size())\n#define last(x) (x.at(x.size()-1))\n\nusing namespace std;\n\n#define EPS 0.0000000001\n#define MOD 1000000007\n\nclass Vector2 {\npublic:\n  double x, y;\n  \n  Vector2(double x = 0, double y = 0): x(x), y(y) {}\n  \n  Vector2 operator + (Vector2 v) { return Vector2(x + v.x, y + v.y); }\n  Vector2 operator - (Vector2 v) { return Vector2(x - v.x, y - v.y); }\n  Vector2 operator * (double k) { return Vector2(x * k, y * k); }\n  Vector2 operator / (double k) { return Vector2(x / k, y / k); }\n  \n  double length() { return sqrt(norm()); }\n  double norm() { return x * x + y * y; }\n  double dot (Vector2 v) { return x * v.x + y * v.y; }\n  double cross (Vector2 v) { return x * v.y - y * v.x; }\n  \n  bool operator < (const Vector2 &v) const {\n    return x != v.x ? x < v.x : y < v.y;\n  }\n  \n  bool operator == (const Vector2 &v) const {\n    return fabs(x - v.x) < EPS && fabs(y - v.y) < EPS;\n  }\n};\n\nostream & operator << (ostream & out, Vector2 const & v) { \n  out<< \"Vector2(\" << v.x << \", \" << v.y << ')';\n  return out;\n}\n\nistream & operator >> (istream & in, Vector2 & v) { \n  double x, y;\n  in >> x;\n  in >> y;\n  v.x = x;\n  v.y = y;\n  return in;\n}\n\n#define MAX_N 15\n#define MAX_M 15000000\n#define INFTY (MAX_M+1)\n\nInt N, M;\n\nstruct State {\n  vector<vector<Int> > cups;\n  Int ops;\n  Vector2 lastMove;\n\n  State(): cups(3), ops(0), lastMove(-1, -1) {}\n\n  vector<Vector2> possibleMoves() {\n    vector<Vector2> ret;\n    vector<Int> indexes({ 0, 1, 2 });\n    do {\n      Int from = indexes.at(0), to = indexes.at(1);\n      if (from == lastMove.y && to == lastMove.x) continue;\n      if (abs(from - to) == 2) continue;\n      if (!cups.at(from).size()) continue;\n      if (cups.at(to).size() == 0) ret.push_back(Vector2(from, to));\n      else if (last(cups.at(from)) > last(cups.at(to))) ret.push_back(Vector2(from, to));\n    } while (next_permutation(span_all(indexes)));\n    return ret;\n  }\n\n  State move(Vector2 &m) {\n    State copy = *this;\n    Int from = m.x, to = m.y;\n    copy.cups.at(to).push_back(last(copy.cups.at(from)));\n    copy.cups.at(from).pop_back();\n    copy.lastMove = m;\n    copy.ops++;\n    return copy;\n  }\n};\n\nostream & operator << (ostream & out, State const & s) { \n  out << \"A: \";\n  for (auto x: s.cups.at(0)) out << x << \"\\t\";\n  out << endl;\n  out << \"B: \";\n  for (auto x: s.cups.at(1)) out << x << \"\\t\";\n  out << endl;\n  out << \"C: \";\n  for (auto x: s.cups.at(2)) out << x << \"\\t\";\n  out << endl;\n  return out;\n}\n\nState state;\n\nvoid input() {\n  state.ops = 0;\n  loop(i,0,3) state.cups.at(i).clear();\n  state.lastMove = Vector2(-1, -1);\n  cin >> N >> M;\n  if (N == 0 && M == 0) exit(0);\n  Int x, n;\n  loop(i,0,3) {\n    cin >> n;\n    rep(n) {\n      cin >> x;\n      state.cups.at(i).push_back(x);\n    }\n  }\n}\n\nInt bfs() {\n  if (state.cups.at(1).size() == 0) {\n    if (state.cups.at(0).size() == 0 || state.cups.at(2).size() == 0) return 0;\n  }\n  queue<State> Q;\n  Q.push(state);\n  while (Q.size()) {\n    State u = Q.front(); Q.pop();\n    // cout << u << endl;\n    for (auto mv: u.possibleMoves()) {\n      State next = u.move(mv);\n      if (next.cups.at(1).size() == 0) {\n        if (next.cups.at(0).size() == 0 || next.cups.at(2).size() == 0) return next.ops;\n      }\n      if (next.ops < M) Q.push(next);\n    }\n  }\n  return -1;\n}\n\nvoid solve() {\n  cout << bfs() << endl;\n}\n\nint main(void) {\n  while (1) {\n    input();\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nchar pos[15+1];\n\nint step(int n) {\n\tif (n == 1) return 1;\n\treturn 3*step(n-1) + 1;\n}\n\nint step2(char dest, int n) {\n\tif (dest == 'A') {\n\t\tif (n == 1) {\n\t\t\tif (pos[1] == 'A') return 0;\n\t\t\tif (pos[1] == 'B') return 1;\n\t\t\treturn 2;\n\t\t} else {\n\t\t\tif (pos[n] == 'A') return step2('A', n-1);\n\t\t\tif (pos[n] == 'B') return step2('C', n-1) + 1 + 2*step(n-1);\n\t\t\treturn step2('A', n-1) + 2 + 4*step(n-1);\n\t\t}\n\t} else /* if (dest == 'C') */ {\n\t\tif (n == 1) {\n\t\t\tif (pos[1] == 'C') return 0;\n\t\t\tif (pos[1] == 'B') return 1;\n\t\t\treturn 2;\n\t\t} else {\n\t\t\tif (pos[n] == 'C') return step2('C', n-1);\n\t\t\tif (pos[n] == 'B') return step2('A', n-1) + 1 + 2*step(n-1);\n\t\t\treturn step2('C', n-1) + 2 + 4*step(n-1);\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n && m) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tint k; cin >> k;\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tint l; cin >> l;\n\t\t\t\tpos[n-l+1] = 'A' + i;\n\t\t\t}\n\t\t}\n\t\tint a = step2('A', n);\n\t\tint b = step2('C', n);\n\t\ta = a<b ? a : b;\n\t\tcout << (a<=m ? a : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <algorithm>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nusing std::min;\n\nconstexpr long fmove(int n)\n{\n  return (n == 0 ? 0\n          : n == 1 ? 1\n          : fmove(n - 1) * 3 + 1);\n}\n\nstatic const long fmove_table[15] = {\n  fmove(0), fmove(1), fmove(2), fmove(3), fmove(4),\n  fmove(5), fmove(6), fmove(7), fmove(8), fmove(9),\n  fmove(10), fmove(11), fmove(12), fmove(13), fmove(14),\n};\n\nstatic long\nmove_full(int n)\n{\n  return fmove_table[n];\n}\n\nstatic int\nopposite_side(int here)\n{\n  return here ^ 2;\n}\n\nstatic long\nmove_all_to(int N, int M, char table[15], int base, int dest)\n{\n  if (base == N)\n  {\n    return 0;\n  }\n  int src = table[base];\n  return (dest == src ? move_all_to(N, M, table, base + 1, dest)\n          : src == 1 ? (move_all_to(N, M, table, base + 1, opposite_side(dest))\n                        + 1 + move_full(N - (base + 1)) * 2)\n          : dest == 1 ? (move_all_to(N, M, table, base + 1, opposite_side(src))\n                         + 1 + move_full(N - (base + 1)))\n          : (move_all_to(N, M, table, base + 1, dest)\n             + 2 + move_full(N - (base + 1)) * 4));\n}\n\nstatic int\nsolve(int N, int M, char table[15])\n{\n  long count = min(move_all_to(N, M, table, 0, 0),\n                   move_all_to(N, M, table, 0, 2));\n  return count <= M ? int(count) : -1;\n}\n\nint\nmain()\n{\n  for (;;)\n  {\n    int N, M;\n    char table[15];\n    cin >> N >> M;\n    if (N == 0 && M == 0)\n    {\n      break;\n    }\n    for (int t = 0; t < 3; t++)\n    {\n      int NN;\n      cin >> NN;\n      for (int n = 0; n < NN; n++)\n      {\n        int a;\n        cin >> a;\n        table[a - 1] = t;\n      }\n    }\n    cout << solve(N, M, table) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IEP(i,b,n) for(int i=b;i>=n;i--)\n#define iep(i,b) IEP(i,b,0)\n\nint n, m, tray[3][20], tray_size[3], min_turn;\n\n// put a to b\nvoid doPut(int a, int b) {\n  int rec = tray[a][tray_size[a]-1];\n  tray[a][tray_size[a]-1] = 0;\n  tray_size[a]--;\n  tray[b][tray_size[b]] = rec;\n  tray_size[b]++;\n}\n// back from b to a\nvoid doBack(int a, int b) {\n  int rec = tray[b][tray_size[b]-1];\n  tray[b][tray_size[b]-1] = 0;\n  tray_size[b]--;\n  tray[a][tray_size[a]] = rec;\n  tray_size[a]++;\n}\n\nvoid dfs(int turn) {\n  if (turn > min_turn) return;\n  rep(i,3) if (i != 1 && tray_size[i] == n) {\n    /*\n    cout<<\"Turn #\"<<turn<<endl;\n    rep(z,n) {\n      rep(zz,tray_size[z]) cout<<tray[z][zz]<<\" \";\n      cout<<endl;\n    }\n    cout<<\"+++++\"<<endl;\n    */\n    min_turn = turn; return;\n  }\n  \n  rep(i,3) {\n    if (tray_size[i] == 0) continue;\n\n    int rec[3];\n    rep(j,3) rec[j] = (tray_size[j]!=0)? tray[j][tray_size[j]-1] : 0 ;\n    \n    if (i == 0) {\n      if (rec[0] < rec[1]) continue;      \n      doPut(0, 1);\n      dfs(turn+1);\n      doBack(0, 1);\n    } else if (i == 1) {\n      if (rec[1] > rec[0]) {\n        doPut(1, 0);\n        dfs(turn+1);\n        doBack(1, 0);\n      }\n      if (rec[1] > rec[2]) {\n        doPut(1, 2);\n        dfs(turn+1);\n        doBack(1, 2);\n      }\n    } else if (i == 2) {\n      if (rec[2] < rec[1]) continue;\n      doPut(2, 1);\n      dfs(turn+1);\n      doBack(2, 1);\n    }\n  }\n}\n\nvoid solve() {\n  memset(tray, 0, sizeof tray);\n  min_turn = m+1;\n  rep(i,3) {\n    cin>>tray_size[i];\n    rep(j,tray_size[i]) cin>>tray[i][j];\n  }\n  \n  dfs(0);\n  if (min_turn == m+1) min_turn = -1;\n  cout<<min_turn<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>n>>m, n||m) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n\tint n,m,l;\n\tint i,j;\n\twhile(scanf(\"%d %d\",&n,&m),(n&&m))\n\t{\n\t\tint data[3][n+1];\n\t\tint len[3];\n\t\tint lentmp[3];\n\t\tint tmp[3][n+1];\n\t\tint min = m;\n\t\tint direction;\n\t\tfor(i = 0;i < 3;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&len[i]);\n\t\t\tlentmp[i] = len[i];\n\t\t\tdata[i][0] = 0;\n\t\t\ttmp[i][0] = 0;\n\t\t\tfor(j = 1;j <= len[i];j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&data[i][j]);\n\t\t\t\ttmp[i][j] = data[i][j];\n\t\t\t}\n\t\t}\n\t\tdirection = 0;\n\t\tfor(i = 0;i < m;i++)\n\t\t{\n\t\t\tif(len[1] == 0 && (len[0] == 0 || len[2] == 0))\n\t\t\t{\n\t\t\t\tmin = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(data[direction][len[direction]] > data[direction+1][len[direction+1]])\n\t\t\t{\n\t\t\t\tdata[direction+1][len[direction+1]+1] = data[direction][len[direction]];\n\t\t\t\tlen[direction+1]++;\n\t\t\t\tlen[direction]--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdata[direction][len[direction]+1] = data[direction+1][len[direction+1]];\n\t\t\t\tlen[direction]++;\n\t\t\t\tlen[direction+1]--;\n\t\t\t}\n\t\t\tif(len[1] == 0 && (len[0] == 0 || len[2] == 0))\n\t\t\t{\n\t\t\t\tmin = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdirection ^= 1;\n\t\t}\n\t\tdirection = 1;\n\t\tfor(i = 0;i < m;i++)\n\t\t{\n\t\t\tif(lentmp[1] == 0 && (lentmp[0] == 0 || lentmp[2] == 0))\n\t\t\t{\n\t\t\t\tif(min > i)\n\t\t\t\t{\n\t\t\t\t\tmin = i;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(tmp[direction][lentmp[direction]] > tmp[direction+1][lentmp[direction+1]])\n\t\t\t{\n\t\t\t\ttmp[direction+1][lentmp[direction+1]+1] = tmp[direction][lentmp[direction]];\n\t\t\t\tlentmp[direction+1]++;\n\t\t\t\tlentmp[direction]--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmp[direction][lentmp[direction]+1] = tmp[direction+1][lentmp[direction+1]];\n\t\t\t\tlentmp[direction]++;\n\t\t\t\tlentmp[direction+1]--;\n\t\t\t}\n\t\t\tif(lentmp[1] == 0 && (lentmp[0] == 0 || lentmp[2] == 0))\n\t\t\t{\n\t\t\t\tif(min > (i+1))\n\t\t\t\t{\n\t\t\t\t\tmin = i+1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdirection ^= 1;\n\t\t}\n\t\tif(m == min)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",min);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int hanoi[16][3][3];\n  REP(j,3) REP(k,3) hanoi[0][j][k] = 0;\n  REP(i,15) {\n    REP(j,3) {\n      REP(k,3) {\n        if (k==j) {\n          hanoi[i+1][j][k] = 0;\n          continue;\n        }\n        if (abs(k-j)==2) {\n          hanoi[i+1][j][k] = hanoi[i][j][k] + 1 + hanoi[i][k][j] + 1 + hanoi[i][j][k];\n          continue;\n        }\n        bool hoge[3] ={};\n        hoge[j] = hoge[k] = 1;\n        int a;\n        REP(l,3) if (!hoge[l]) a = l;\n        hanoi[i+1][j][k] = hanoi[i][j][a] + 1 + hanoi[i][a][k];\n        //      printf(\"%d,%d,%d %d\\n\",i,j,k,hanoi[i][j][k]);\n      }\n    }\n  }\n//  cout << \"OK\" << endl;\n  \n  int n, m;\n  while(cin>>n>>m, n||m) {\n    typedef pair<int, int> pii;\n    vector<pii> v; // size, pos\n    REP(i, 3) {\n      int a;\n      cin >> a;\n      REP(j, a) {\n        int size;\n        cin >> size;\n        v.push_back(pii(size,i));\n      }\n    }\n    sort(ALL(v), greater<pii>());\n    \n    int dp[n][3];               // dp[i][j] : å«¢û©çi ÔÚÜÅÌJbvðj ÉÚ®·éè\n    // REP(i,m+1) REP(j,3)\n    //   dp[i][j] = INF;\n    REP(i, 3) dp[0][i] = 0;\n    \n    REP(i, n) {\n      REP(j, 3) {\n//        printf(\"i=%d, j=%d\\n\",i,j);\n        int aa = v[i].second;\n        if (aa==j) {\n          dp[i+1][j] = dp[i][j];\n          continue;\n        }\n        if (abs(aa-j)==2) {\n          dp[i+1][j] = dp[i][j] + 1 + hanoi[i][j][aa] + 1 + hanoi[i][aa][j];\n          continue;\n        }\n\n        bool hoge[3] ={};\n        hoge[j] = hoge[aa] = 1;\n        int a;\n        REP(l,3) if (!hoge[l]) a = l;\n        dp[i+1][j] = dp[i][a] + abs(aa-j) + hanoi[i][a][j];\n      }\n    }\n\n    int res = min(dp[n][0], dp[n][2]);\n    if (res<=m) cout << res << endl;\n    else cout << -1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint bfs[15000000], power[20], n, K, b, c, a[15];\nqueue<vector<int> >Q;\nint hush(vector<int>v) {\n\tint p = 0;\n\tfor (int i = 0; i < v.size(); i++) p += power[i] * v[i];\n\treturn p;\n}\nint main() {\n\tpower[0] = 1;\n\tfor (int i = 1; i < 20; i++)power[i] = power[i - 1] * 3;\n\twhile (true) {\n\t\tfor (int i = 0; i < 15000000; i++)bfs[i] = 1000000000;\n\t\tcin >> n >> K; vector<int>s;\n\t\tif (n == 0 && K == 0)break;\n\t\tcin >> b; for (int i = 0; i < b; i++) { cin >> c; a[c - 1] = 0; }\n\t\tcin >> b; for (int i = 0; i < b; i++) { cin >> c; a[c - 1] = 1; }\n\t\tcin >> b; for (int i = 0; i < b; i++) { cin >> c; a[c - 1] = 2; }\n\t\tfor (int i = 0; i < n; i++)s.push_back(a[i]);\n\t\tbfs[hush(s)] = 0; Q.push(s);\n\t\twhile (!Q.empty()) {\n\t\t\tvector<int>a1, a2, a3, t = Q.front(); Q.pop();\n\t\t\tint V = hush(t);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (t[i] == 0)a1.push_back(i);\n\t\t\t\tif (t[i] == 1)a2.push_back(i);\n\t\t\t\tif (t[i] == 2)a3.push_back(i);\n\t\t\t}\n\t\t\tint A1 = -1, A2 = -1, A3 = -1;\n\t\t\tif (a1.size() >= 1)A1 = a1[a1.size() - 1];\n\t\t\tif (a2.size() >= 1)A2 = a2[a2.size() - 1];\n\t\t\tif (a3.size() >= 1)A3 = a3[a3.size() - 1];\n\t\t\tif (A1 >= 0 && A2 <= A1) {\n\t\t\t\tint P1 = hush(t) + power[A1];\n\t\t\t\tif (bfs[P1] == 1000000000) { t[A1] = 1; bfs[P1] = bfs[V] + 1; Q.push(t); t[A1] = 0; }\n\t\t\t}\n\t\t\tif (A2 >= 0 && A1 <= A2) {\n\t\t\t\tint P1 = hush(t) - power[A2];\n\t\t\t\tif (bfs[P1] == 1000000000) { t[A2] = 0; bfs[P1] = bfs[V] + 1; Q.push(t); t[A2] = 1; }\n\t\t\t}\n\t\t\tif (A2 >= 0 && A3 <= A2) {\n\t\t\t\tint P1 = hush(t) + power[A2];\n\t\t\t\tif (bfs[P1] == 1000000000) { t[A2] = 2; bfs[P1] = bfs[V] + 1; Q.push(t); t[A2] = 1; }\n\t\t\t}\n\t\t\tif (A3 >= 0 && A2 <= A3) {\n\t\t\t\tint P1 = hush(t) - power[A3];\n\t\t\t\tif (bfs[P1] == 1000000000) { t[A3] = 1; bfs[P1] = bfs[V] + 1; Q.push(t); t[A3] = 2; }\n\t\t\t}\n\t\t}\n\t\tint L = min(bfs[0], bfs[power[n] - 1]);\n\t\tif (L > K)L = -1;\n\t\tcout << L << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n, m;\n\tvector<int> a[3], b[3];\n\tfor(;;){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\ta[i].clear();\n\t\t\tb[i].clear();\n\t\t}\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tint num;\n\t\t\tcin >> num;\n\t\t\tfor(int j = 0; j < num; j++){\n\t\t\t\tint in;\n\t\t\t\tcin >> in;\n\t\t\t\ta[i].push_back(in);\n\t\t\t}\n\t\t}\n\t\tif(a[2][0] == 1){\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < a[i].size(); j++){\n\t\t\t\t\tb[2 - i].push_back(a[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < a[i].size(); j++){\n\t\t\t\t\tb[i].push_back(a[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tbool flag = true;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(ans % 2 == 0){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tif(!b[j].empty() && b[j][0] == i){\n\t\t\t\t\t\tans = (3 * ans) + j;\n\t\t\t\t\t\tb[j].erase(b[j].begin());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tif(!b[j].empty() && b[j][0] == i){\n\t\t\t\t\t\tans = (3 * ans) + (2 - j);\n\t\t\t\t\t\tb[j].erase(b[j].begin());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans > m){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag) cout << ans << endl;\n\t\telse cout << \"-1\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stdlib.h>\n/*http://climpet.hatenablog.com/entry/2013/01/01/225142#f5を参考*/\nint main(int argc, char *argv[])\n{\n  int pow3[16],c[16];\n  int n,m,i,j,k,d,x,y,p;\n\n  pow3[0] = 1;\n  for(i = 1;i <=15;i++){\n    pow3[i] = pow3[i-1]*3;/*i枚#0から#2または#2から#0へ移動するのに必要なステップ数*/\n}\n\n  while(scanf(\"%d%d\",&n,&m),n){\n    for(i = 0;i < 3;++i){\n      for(scanf(\"%d\",&j);j > 0;--j){\n\tscanf(\"%d\",&k);\n\tc[n-k] = i;/*番号付け替え,ハノイの塔に変換。大きいコップを小さい円盤にする*/\n      }\n    }\n    p = 0;//全ての円盤が0の位置にあると仮定する\n    x = 0;\n    for(i = n-1;i >= 0;--i){//\n      d = abs(p -c[i]);//移動させる円盤の距離を求める。\n      /*n = 3の時、i = 2で円盤2を#1に移動させるには円盤1と円盤0を#2に移動させる*/\n      x += pow3[i]*d;\n      if(d == 1){\n\tp = 2-p;/*反対側に移動,距離がd = 1ならば0~i-1番の円盤を反対側に移動する。*/\n      }\n    }\n    y = pow3[n] -1 -x;\n    if(x > y){\n      x = y;\n    }\n    printf(\"%d\\n\",x > m?-1:x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <stack>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nint n, in;\nll m;\nstack<int> s[3], temp[3];\nvoid input(stack<int>& s) {\n    int num; scanf(\"%d\",&num);\n    for (int i=0; i<num; i++) {\n        int x; scanf(\"%d\",&x);\n        s.push(x);\n    }\n}\nvoid clear(stack<int>& s) {\n    while (!s.empty()) s.pop();\n}\n// 0-a 1-b 2-c\nll dfs(int from, int to) {\n    ll res=1;\n    bool con=true;\n    while (s[0].size()!=n&&s[2].size()!=n&&res<=m) {\n        con=true;\n        for (int i=0; i<3&&con; i++) {\n            for (int j=0; j<3&&con; j++) {\n                if (i==to&&j==from) continue;\n                if (s[i].empty()) continue;\n                if (abs(i-j)!=1) continue;\n                if (!s[j].empty()&&s[i].top()<s[j].top()) continue;\n                s[j].push(s[i].top()); s[i].pop();\n                from=i; to=j;\n                con=false;\n            }\n        }\n        res++;\n    }\n    return res;\n}\nint main() {\n    while (scanf(\"%d%lld\",&n,&m)) {\n        if (!n&&!m) break;\n        clear(s[0]); clear(s[1]); clear(s[2]);\n        input(s[0]); input(s[1]); input(s[2]);\n        ll res=m+1;\n        if (s[0].size()==n||s[2].size()==n) {\n            puts(\"0\");\n            continue;\n        }\n        for (int i=0; i<3; i++) temp[i]=s[i];\n        for (int i=0; i<3; i++) {\n            for (int j=0; j<3; j++) {                               // iツつゥツづァj\n                if (s[i].empty()) continue;                         // ツづづィツつスツつ「ツづつアツづォツつェツ凝ウ\n                if (abs(i-j)!=1) continue;                          // ツ療猟静堋つオツづづ按つ「\n                if (!s[j].empty()&&s[i].top()<s[j].top()) continue; // ツ置ツつォツつスツつ「ツづつアツづォツづ可置ツつッツづ按つ「\n                s[j].push(s[i].top()); s[i].pop();\n                res=min(res, dfs(i,j));\n                for (int k=0; k<3; k++) s[k]=temp[k];\n            }\n        }\n        printf(\"%lld\\n\",res==m+1?-1:res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\nvoid move(stack<int> *A, stack<int> *B, stack<int> *C, int m, int exp);\n\nint maxcount;//決められた、動き方の最大値\nint mincount;//今までに発見した最短の動き方\n\nint main() {\n\tint n;\n\tint m;\n\tint temp;\n\tint A_size,B_size,C_size;\n\tint ans[2000];\n\tint ansindex=0;\n\twhile(true){\n\t\tcin>>n;//n個のコップ\n\t\tcin>>m;//m回以内で動かせるか\n\t\tif(n==0&&m==0)break;\n\t\tmaxcount=m;//動かせる最大値\n\t\tmincount=m+1;//更新されていなければ解はなかった\n\t\tstack<int> *stA = new stack<int>;//Aのスタック\n\t\tstack<int> *stB = new stack<int>;//Bのスタック\n\t\tstack<int> *stC = new stack<int>;//Cのスタック\n\t\tcin>>A_size;\n\t\tfor(int i=0; i<A_size; i++){\n\t\t\tcin>>temp;\n\t\t\tstA->push(temp);\n\t\t}//Aの入力\n\t\tcin>>B_size;\n\t\tfor(int i=0; i<B_size; i++){\n\t\t\tcin>>temp;\n\t\t\tstB->push(temp);\n\t\t}//Bの入力\n\t\tcin>>C_size;\n\t\tfor(int i=0; i<C_size; i++){\n\t\t\tcin>>temp;\n\t\t\tstC->push(temp);\n\t\t}//Cの入力\n\t\tmove(stA,stB,stC,0,4);\n\t\tif(mincount==m+1)ans[ansindex]=-1;\n\t\telse ans[ansindex]=mincount;\n\t\tansindex++;\n\t}\n\tfor(int i=0; i<ansindex; i++){\n\t\tcout<<ans[i]<<\"\\n\";\n\t}\n\treturn 0;\n}\n\n\nvoid move(stack<int> *A, stack<int> *B, stack<int> *C, int count, int exp){\n\tint temp;\n\tif(count>maxcount)return;\n\tif((A->empty()||C->empty())&&B->empty()){\n\t\tif(count<mincount)mincount=count;\n\t}\n\tif(exp!=1&&((B->empty()&&A->empty()==false)||(B->empty()==false&&A->empty()==false&&A->top()>B->top()))){\n\t\t//行動0\n\t\ttemp=A->top();\n\t\tA->pop();\n\t\tB->push(temp);\n\t\tcount++;\n\t\tmove(A,B,C,count,0);\n\t\tcount--;\n\t\tB->pop();\n\t\tA->push(temp);\n\t}\n\tif(exp!=0&&((A->empty()&&B->empty()==false)||(A->empty()==false&&B->empty()==false&&B->top()>A->top()))){\n\t\t//行動1\n\t\ttemp=B->top();\n\t\tB->pop();\n\t\tA->push(temp);\n\t\tcount++;\n\t\tmove(A,B,C,count,1);\n\t\tcount--;\n\t\tA->pop();\n\t\tB->push(temp);\n\t}\n\tif(exp!=3&&((B->empty()&&C->empty()==false)||(B->empty()==false&&C->empty()==false&&C->top()>B->top()))){\n\t\t//行動2\n\t\ttemp=C->top();\n\t\tC->pop();\n\t\tB->push(temp);\n\t\tcount++;\n\t\tmove(A,B,C,count,2);\n\t\tcount--;\n\t\tB->pop();\n\t\tC->push(temp);\n\t}\n\tif(exp!=2&&((C->empty()&&B->empty()==false)||(C->empty()==false&&B->empty()==false&&B->top()>C->top()))){\n\t\t//行動3\n\t\ttemp=B->top();\n\t\tB->pop();\n\t\tC->push(temp);\n\t\tcount++;\n\t\tmove(A,B,C,count,3);\n\t\tcount--;\n\t\tC->pop();\n\t\tB->push(temp);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tr1/unordered_set>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nconst int DELTA[] = {-1, 1};\n\nstruct Hash {\n    size_t operator()(const vector<int> &v) const {\n        size_t val = 0;\n        for(vector<int>::const_iterator it = v.begin(); it != v.end(); ++it) {\n            val <<= 2;\n            val += *it;\n        }\n        return val;\n    }\n};\n\nbool all_a(const vector<int> &v, int val) {\n    for(vector<int>::const_iterator it = v.begin(); it != v.end(); ++it) {\n        if(*it != val) return false;\n    }\n    return true;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N && !M) break;\n\n        vector<int> state(N);\n        for(int i = 0; i < 3; ++i) {\n            int n;\n            cin >> n;\n            while(n--) {\n                int idx;\n                cin >> idx;\n                state[idx-1] = i;\n            }\n        }\n\n        tr1::unordered_set<vector<int>,Hash> visited;\n        queue<pair<int, vector<int> > > q;\n        q.push(make_pair(0, state));\n        visited.insert(state);\n        int ans = -1;\n        while(!q.empty()) {\n            int turn = q.front().first;\n            vector<int> cur = q.front().second;\n            /*\n            cout << \"(\" << turn << \") \";\n            for(int i = 0; i < cur.size(); ++i) {\n                cout << cur[i] << ' ';\n            }\n            cout << endl;\n            */\n            q.pop();\n            if(all_a(cur, 0) || all_a(cur, 2)) {\n                ans = turn;\n                break;\n            }\n            if(turn == M) continue;\n\n            int top_of[3] = {-1, -1, -1};\n            for(int i = N-1; i >= 0; --i) {\n                const int pos = cur[i];\n                if(top_of[pos] == -1) {\n                    top_of[pos] = i;\n                    for(int j = 0; j < 2; ++j) {\n                        const int to = pos + DELTA[j];\n                        if(to < 0 || to >= 3) continue;\n                        if(top_of[to] < i) {\n                            vector<int> next = cur;\n                            next[i] = to;\n                            if(visited.count(next)) continue;\n                            /*\n                            cout << \"yield \";\n                            for(int k = 0; k < cur.size(); ++k) {\n                                cout << next[k] << ' ';\n                            }\n                            cout << endl;\n                            */\n                            visited.insert(next);\n                            q.push(make_pair(turn+1, next));\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, int>;\n\nint a[25];\nint d[15000010];\n\nvoid debug(int pos, int n){\n\trep(i, n){\n\t\tcout << pos % 3 << \" \";\n\t\tpos /= 3;\n\t}\n\tcout << endl;\n}\n\nint main(){\n\ta[0] = 1;\n\trep(i, 20) a[i + 1] = a[i] * 3;\n\n\tint n, m;\n\twhile (cin >> n >> m, n | m){\n\t\tint start = 0;\n\t\trep(i, 3){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\twhile (k--){\n\t\t\t\tint x;\n\t\t\t\tcin >> x;\n\t\t\t\tstart += i*a[x - 1];\n\t\t\t}\n\t\t}\n\t\tint goal = a[n] - 1;\n\n\t\tMEMSET(d, -1);\n\t\td[start] = 0;\n\t\tqueue<P> q;\n\t\tif (start == 0 || start == goal) goto OK;\n\t\tq.push(make_pair(start, 0));\n\t\twhile (!q.empty()){\n\t\t\tP p = q.front();\n\t\t\tq.pop();\n\n\t\t\tint pos = p.first;\n\t\t\tint dist = p.second;\n\n\t\t\tint tmp = pos;\n\t\t\tbool ng[3] = {};\n\t\t\tfor (int i = n - 1; i >= 0; --i){\n\t\t\t\tint x = tmp / a[i];\n\t\t\t\ttmp = tmp % a[i];\n\t\t\t\tif (ng[x]) continue;\n\t\t\t\tng[x] = 1;\n\t\t\t\tfor (int j = max(x - 1, 0); j <= min(x + 1, 2); ++j){\n\t\t\t\t\tif (ng[j]) continue;\n\t\t\t\t\tint nxt = pos + ((j - x)*a[i]);\n\t\t\t\t\tif (d[nxt] >= 0) continue;\n\t\t\t\t\t//debug(nxt, n);\n\t\t\t\t\td[nxt] = dist + 1;\n\t\t\t\t\tif (nxt == 0 || nxt == goal) goto OK;\n\t\t\t\t\tif(dist + 1 < m) q.push(make_pair(nxt, dist+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\tcontinue;\n\tOK:;\n\t\tcout << max(d[0], d[goal]) << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n// 入力\nint n, m;\nint cup[3];\n\nvoid debug(int a, int b, int c, int cnt){\n\tcout << \"[debug]\" << endl;\n\tcout << \"cnt:\" << cnt << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((a&i)? \"*\" : \"-\");\n\t}\n\tcout << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((b&i)? \"*\" : \"-\");\n\t}\n\tcout << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((c&i)? \"*\" : \"-\");\n\t}\n\tcout << endl << endl;;\n}\n\n// 一番上のカップを返す\nint top(int bits){\n\tfor(int i=(1<<n) ; i ; i >>= 1 ){\n\t\tif( i & bits ) return i;\n\t}\n\treturn 0;\n}\n\n// 探索\nint bfs(){\n\t// d[P(a,b)] := cup[0] = a, cup[1] = b の状態 s のときの手数\n\t// (cup[2] = (2^n)-1-a-b で cup[2] を計算できる)\n\tmap<P,int> d;\n\tqueue<P> q;\n\t\n\tq.push(  P(0,0) );\n\td[P(0,0)] = 0;\n\t\n\twhile( !q.empty() ){\n\t\tP now = q.front();\n\t\tint cnt = d[now];\n\t\tq.pop();\n\t\t\n\t\t// a,b,c := カップの状態\n\t\t// a_top,b_top,c_top := 一番上のカップ\n\t\tint a = now.first;\n\t\tint b = now.second;\n\t\tint c = ((1<<n)-1) - a - b;\n\t\tint a_top = top(a);\n\t\tint b_top = top(b);\n\t\tint c_top = top(c);\n\t\t\n\t\t//debug(a,b,c,cnt);\n\t\t\n\t\t// ゴールのとき\n\t\tif( b == cup[1] && ((a == cup[0] && c == cup[2]) || (a == cup[2] && c == cup[0])) ){\n\t\t\treturn cnt;\n\t\t}\n\t\t\n\t\t{\n\t\t\tint a_, b_, c_;\n\t\t\tif( a_top < b_top ){ // B -> A の移動\n\t\t\t\ta_ = a + b_top;\n\t\t\t\tb_ = b - b_top;\n\t\t\t\tc_ = c_;\n\t\t\t}else{ // A -> B の移動\n\t\t\t\ta_ = a - a_top;\n\t\t\t\tb_ = b + a_top;\n\t\t\t\tc_ = c;\n\t\t\t}\n\t\t\tP next  = P( a_ , b_ );\n\t\t\tP next_ = P( c_ , b_ );\n\t\t\tif( !d.count(next) && cnt + 1 <= m ){\n\t\t\t\td[next] = cnt + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint a_, b_, c_;\n\t\t\tif( c_top < b_top ){ // B -> C の移動\n\t\t\t\ta_ = a;\n\t\t\t\tb_ = b - b_top;\n\t\t\t\tc_ = c + b_top;\n\t\t\t}else{ // C -> B の移動\n\t\t\t\ta_ = a;\n\t\t\t\tb_ = b + c_top;\n\t\t\t\tc_ = c - c_top;\n\t\t\t}\n\t\t\tP next  = P( a_ , b_ );\n\t\t\tP next_ = P( c_ , b_ );\n\t\t\tif( !d.count(next) && cnt + 1 <= m ){\n\t\t\t\td[next] = cnt + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile( cin >> n >> m , n || m ){\n\t\t// 初期化\n\t\tcup[0] = cup[1] = cup[2] = 0;\n\t\t \n\t\tfor(int i=0 ; i < 3 ; i++ ){\n\t\t\tint k, e;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0 ; j < k ; j++ ){\n\t\t\t\tcin >> e;\n\t\t\t\tcup[i] |= (1 << (e-1));\n\t\t\t}\n\t\t}\n\t\t//debug(cup[0],cup[1],cup[2],-1);\n\t\tint ans = bfs();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> State;\n\n// 入力\nint n, m, cup[3];\n\nvoid debug(int a, int b, int c, int cnt){\n\tcout << \"[debug]\" << endl;\n\tcout << \"cnt:\" << cnt << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((a&i)? \"*\" : \"-\");\n\t}\n\tcout << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((b&i)? \"*\" : \"-\");\n\t}\n\tcout << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((c&i)? \"*\" : \"-\");\n\t}\n\tcout << endl << endl;;\n}\n\n// 一番上のカップを返す\nint top(int bits){\n\tfor(int i=(1<<n) ; i ; i >>= 1 ){\n\t\tif( i & bits ) return i;\n\t}\n\treturn 0;\n}\n\n// 探索\nint bfs(){\n\t// d[s] := cupの状態 s のときの手数\n\tmap<State,int> d;\n\tqueue<State> q;\n\t\n\tState s = State( cup[0] , P(cup[1],cup[2]) );\n\tq.push(s);\n\td[s] = 0;\n\t\n\twhile( !q.empty() ){\n\t\tState now = q.front();\n\t\tint cnt = d[now];\n\t\tq.pop();\n\t\t\n\t\t// a,b,c := カップの状態\n\t\t// a_top,b_top,c_top := 一番上のカップ\n\t\tint a = now.first;\n\t\tint b = now.second.first;\n\t\tint c = now.second.second;\n\t\tint a_top = top(a);\n\t\tint b_top = top(b);\n\t\tint c_top = top(c);\n\t\t//debug(a,b,c,cnt);\n\t\t\n\t\t// ゴールのとき\n\t\tif( a == ((1<<n)-1) || c == ((1<<n)-1)){\n\t\t\treturn cnt;\n\t\t}\n\t\t\n\t\t{\n\t\t\tint a_, b_, c_;\n\t\t\tif( a_top < b_top ){ // B -> A の移動\n\t\t\t\ta_ = a + b_top;\n\t\t\t\tb_ = b - b_top;\n\t\t\t\tc_ = c;\n\t\t\t}else{ // A -> B の移動\n\t\t\t\ta_ = a - a_top;\n\t\t\t\tb_ = b + a_top;\n\t\t\t\tc_ = c;\n\t\t\t}\n\t\t\tState next = State(a_,P(b_,c_));\n\t\t\tif( !d.count(next) && cnt + 1 <= m ){\n\t\t\t\td[next] = cnt + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint a_, b_, c_;\n\t\t\tif( c_top < b_top ){ // B -> C の移動\n\t\t\t\ta_ = a;\n\t\t\t\tb_ = b - b_top;\n\t\t\t\tc_ = c + b_top;\n\t\t\t}else{ // C -> B の移動\n\t\t\t\ta_ = a;\n\t\t\t\tb_ = b + c_top;\n\t\t\t\tc_ = c - c_top;\n\t\t\t}\n\t\t\tState next = State(a_,P(b_,c_));\n\t\t\tif( !d.count(next) && cnt + 1 <= m ){\n\t\t\t\td[next] = cnt + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile( cin >> n >> m , n || m ){\n\t\t// 初期化\n\t\tcup[0] = cup[1] = cup[2] = 0;\n\t\t \n\t\tfor(int i=0 ; i < 3 ; i++ ){\n\t\t\tint k, e;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0 ; j < k ; j++ ){\n\t\t\t\tcin >> e;\n\t\t\t\tcup[i] |= (1 << (e-1));\n\t\t\t}\n\t\t}\n\t\tint ans = bfs();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n// variable update\ninline void modAdd(int& _a, int _b, int _m) { _a = (_a + _b) % _m; }\ninline void modAdd(lint& _a, lint _b, lint _m) { _a = (_a + _b) % _m; }\ninline void minUpdate(int& _a, int _b) { _a = min(_a, _b); }\ninline void minUpdate(lint& _a, lint _b) { _a = min(_a, _b); }\ninline void maxUpdate(int& _a, int _b) { _a = max(_a, _b); }\ninline void maxUpdate(lint& _a, lint _b) { _a = max(_a, _b); }\n\nint n, m;\nint POW[16];\n\nint calc(int A, int B) {\n\tint res = 0;\n\tfor_(i,0,n) {\n\t\tint k = n - i - 1;\n\t\tif (A >> i & 1) res += 2 * POW[k];\n\t\tif (B >> i & 1) res += POW[k];\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tint cup[3] = { 0 };\n\t\n\tfor_(i,0,3) {\n\t\tint d; cin >> d;\n\t\tfor_(j,0,d) {\n\t\t\tint p; cin >> p;\n\t\t\t--p;\n\t\t\tcup[i] |= 1 << p;\n\t\t}\n\t}\n\t\n\tint ans = min(calc(cup[0], cup[1]), calc(cup[2], cup[1]));\n\tif (ans > m) ans = -1;\n\tcout << ans << endl;\n}\n\nint main() {\n\tPOW[0] = 1;\n\tfor_(i,1,16) POW[i] = POW[i - 1] * 3;\n\tPOW[0] = 0;\n\twhile (cin >> n >> m, n) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N, M;\n\nclass hash_array {\npublic:\n  size_t operator()(const array<int, 3> &x) const {\n    const int C = 997;\n    size_t t = 0;\n    for (int i = 0; i != x.size(); ++i) {\n      t = t * C + x[i];\n    }\n    return t;\n  }\n};\n\nint solve(array<int, 3> const& start) {\n  queue<array<int, 3>> q;\n  int num = 0;\n  rep(i, N) num |= 1 << i;\n  q.push(start);\n\n  unordered_map<array<int, 3>, int, hash_array> mp;\n  mp[start] = 0;\n\n  const array<int, 3> target1{{num, 0, 0}};\n  const array<int, 3> target2{{0, 0, num}};\n\n  while(!q.empty()) {\n    auto v = q.front(); q.pop();\n    if(v == target1 || v == target2) {\n      return mp[v];\n    }\n\n    rep(i, v.size()) {\n      for(int k=N-1; k>=0; k--) {\n        if(v[i] >> k & 1) {\n          if(i + 1 < 3) {\n            auto nv = v;\n            nv[i] ^= 1 << k;\n            if(nv[i + 1] < (1<<k)) {\n              nv[i + 1] ^= 1 << k;\n              if(mp.find(nv) == mp.end() && mp[v] + 1 <= M) {\n                mp[nv] = mp[v] + 1;\n                q.push(nv);\n              }\n            }\n          }\n\n          if(i - 1 >= 0) {\n            auto nv = v;\n            nv[i] ^= 1 << k;\n            if(nv[i - 1] < (1<<k)) {\n              nv[i - 1] ^= 1 << k;\n              if(mp.find(nv) == mp.end() && mp[v] + 1 <= M) {\n                mp[nv] = mp[v] + 1;\n                q.push(nv);\n              }\n            }\n          }\n\n          break;\n        }\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main() {\n  while(cin >> N >> M && (N|M)) {\n    array<int, 3> cups;\n    rep(i, 3) {\n      int n; cin >> n;\n      int num = 0;\n      rep(j, n) {\n        int k; cin >> k; k--;\n        num |= 1 << k;\n      }\n      cups[i] = num;\n    }\n    cout << solve(cups) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template ver2.02\n\n// include\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <complex>\n\nusing namespace std;\n\n// conversion\ninline int to_int(string s) {int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string to_str(T x) {ostringstream sout; sout << x; return sout.str();}\n\n// typedef\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n// util\n#define MP make_pair\n#define EACH(i, c) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define CLR(a) memset((a), 0 , sizeof(a))\ntemplate<class T, class C> inline bool in(T e, C c) {return c.find(e) != c.end();}\ntemplate<class T> inline bool in(T x, T a, T b) {return a <= x && x < b;}\n\n// repetition\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define RREP(i, n) RFOR(i, 0, n)\n\n// IO\n#define PRA(a, n) cout << a[0]; FOR(itr, 1, n) {cout << \" \" << a[itr];} cout << endl;\n#define PRF(x, w) cout << setprecision((w)); cout << setiosflags(ios::fixed); cout << (x) << endl;\n\n// constant\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = (int)1e9;\nconst int DI[] = {0, 1, 0, -1};\nconst int DJ[] = {1, 0, -1, 0};\n\n// debug\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define DUMPA(a, n) cerr << #a << \" = {\" << a[0]; FOR(itr, 1, n) { cout << \", \" << a[itr]; } cerr << \"}\" << endl;\n#define DUMPAA(a, n, m) REP(itr, n) {REP(jtr, m) {cout << a[itr][jtr] << \" \";} cout << endl;}\n\n// template end\n\nint n, m;\nint k[3];\nvi c[3];\n\nstack<int> s[3];\n\nint dfs(int i, int t) \n{\n    if (t > m) return -1;\n    if (s[0].size() == n || s[2].size() == n) return t;\n    int x, y;\n    x = s[i].empty() ? 0 : s[i].top();\n    y = s[1].empty() ? 0 : s[1].top();    \n    if (x < y) {\n        s[i].push(y);\n        s[1].pop();\n    }\n    else {\n        s[1].push(x);\n        s[i].pop();\n    }\n    return dfs((i + 2) % 4, t + 1);\n}\n\nvoid init_stack() \n{\n    REP(i, 3) s[i] = stack<int>();\n    REP(i, 3) REP(j, k[i]) s[i].push(c[i][j]);    \n}\n\nvoid init()\n{\n}\n\nvoid solve()\n{\n    init_stack();\n    int t0 = dfs(0, 0);\n    init_stack();    \n    int t1 = dfs(2, 0);\n    int ans = t0;\n    if (t1 >= 0) ans = min(ans, t1);\n    cout << ans << endl;\n}\n\nint main()\n{\n    init();\n    while (cin >> n >> m, n) {\n        REP(i, 3) {\n            cin >> k[i];\n            c[i].clear();\n            REP(j, k[i]) {\n                int x;\n                cin >> x;\n                c[i].push_back(x);\n            }\n        }\n        solve();        \n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint pow(int x,int y){\n    int z=1;\n    while(y){\n        z *= x;y--;\n    }\n    return z;\n}\nint main(){\n    int n,m,i,j,c,k,t,d,ans;\n    while(cin >> n >> m){\n        if(n==0 && m==0) break;\n        ans = m+1;int f[n];\n        for(i=0;i<3;i++){\n            cin >> c;\n            for(j=0;j<c;j++){\n                cin >> k;f[k-1] = i;\n            }\n        }\n        t = 0;d = 0;\n        for(i=1;i<=n;i++){\n            t += pow(3,n-i)*abs(f[i-1]-d);\n            if(f[i-1]==1) d = abs(d-2);\n        }\n        ans = min(ans,t);\n        t = 0;d = 2;\n        for(i=1;i<=n;i++){\n            t += pow(3,n-i)*abs(f[i-1]-d);\n            if(f[i-1]==1) d = abs(d-2);\n        }\n        ans = min(ans,t);\n        cout << ((ans<=m) ? ans:-1) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nint limit,num_cup,ans;\nbool Log[14348907],FLG;\nchar ch;\nshort a_loc,b_loc,c_loc;\n\n\nstruct Info{\n\tint value;\n\tchar loc;\n};\n\nstruct Data{\n\tData(){\n\t\tcount = 0;\n\t}\n\tData(int arg_count,char arg_table[15]){\n\t\tcount = arg_count;\n\t\tfor(int i = 0; i < 15; i++)table[i] = arg_table[i];\n\t}\n\tchar table[15];\n\tint count;\n};\n\nvoid setCode(char table[15], int &calc){\n\tint S = 1;\n\tcalc = 0;\n\tfor(int i = 0; i < num_cup; i++){\n\t\tif(table[i] == 'A'){\n\t\t\tcalc += 0;\n\t\t}else if(table[i] == 'B'){\n\t\t\tcalc += S;\n\t\t}else{\n\t\t\tcalc += 2*S;\n\t\t}\n\t\tS *= 3;\n\t}\n}\n\nvoid bfs(char table[15]){\n\n\tqueue<Data> Q;\n \tQ.push(Data(0,table));\n \tchar new_table[4][15];\n\n \tData tmp;\n \twhile(!Q.empty()){\n \t\ttmp.count = Q.front().count;\n \t\tfor(int i = 0; i < 15; i++){\n \t\t\ttmp.table[i] = Q.front().table[i];\n \t\t}\n \t\tQ.pop();\n\n \t\tFLG = true;\n \t\tch = tmp.table[0];\n\n \t\tif(ch == 'B')FLG = false;\n\n \t\tif(FLG){\n \t\t\tfor(int i = 1; i <= num_cup-1; i++){\n \t\t\t\tif(tmp.table[i] != ch){\n \t\t\t\t\tFLG = false;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n\n \t\tif(FLG){\n \t\t\tans = tmp.count;\n \t\t\tbreak;\n \t\t}\n\n \t\tif(tmp.count == limit){\n \t\t\tcontinue;\n \t\t}\n\n \t\tfor(int i = 0; i < 4; i++){\n \t\t\tfor(int k = 0; k < num_cup; k++)new_table[i][k] = tmp.table[k];\n \t\t}\n\n \t\ta_loc = b_loc = c_loc = -1;\n \t\tfor(int i = num_cup-1; i >= 0; i--){\n \t\t\tif(tmp.table[i] == 'A'){\n \t\t\t\ta_loc = (a_loc >= i)?a_loc:i;\n \t\t\t}else if(tmp.table[i] == 'B'){\n \t\t\t\tb_loc = (b_loc >= i)?b_loc:i;\n \t\t\t}else{\n \t\t\t\tc_loc = (c_loc >= i)?c_loc:i;\n \t\t\t}\n \t\t}\n\n \t\tint calc;\n\n \t\tif(a_loc > b_loc){\n \t\t\tnew_table[0][a_loc] = 'B';\n\n \t\t\tsetCode(new_table[0],calc);\n \t\t\tif(Log[calc] == false){\n \t\t\t\tLog[calc] = true;\n \t\t\t\tQ.push(Data(tmp.count+1,new_table[0]));\n \t\t\t}\n \t\t}\n\n \t\tif(b_loc > a_loc){\n \t\t\tnew_table[1][b_loc] = 'A';\n\n \t\t\tsetCode(new_table[1],calc);\n \t\t\tif(Log[calc] == false){\n \t\t\t\tLog[calc] = true;\n \t\t\t\tQ.push(Data(tmp.count+1,new_table[1]));\n \t\t\t}\n \t\t}\n\n \t\tif(c_loc > b_loc){\n \t\t\tnew_table[2][c_loc] = 'B';\n\n \t\t\tsetCode(new_table[2],calc);\n \t\t\tif(Log[calc] == false){\n \t\t\t\tLog[calc] = true;\n \t\t\t\tQ.push(Data(tmp.count+1,new_table[2]));\n \t\t\t}\n \t\t}\n\n \t\tif(b_loc > c_loc){\n \t\t\tnew_table[3][b_loc] = 'C';\n\n \t\t\tsetCode(new_table[3],calc);\n \t\t\tif(Log[calc] == false){\n \t\t\t\tLog[calc] = true;\n \t\t\t\tQ.push(Data(tmp.count+1,new_table[3]));\n \t\t\t}\n \t\t}\n \t}\n }\n\nint main(){\n\n\tint a,b,c,index,calc;\n\tInfo info[15];\n\tchar table[15];\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&num_cup,&limit);\n\t\tif(num_cup == 0 && limit == 0)break;\n\n\t\tfor(int i = 0; i < 14348907; i++){\n\t\t\tLog[i] = false;\n\t\t}\n\n\t\tindex = 0;\n\t\tscanf(\"%d\",&a);\n\n\t\tfor(int i = 0; i < a; i++){\n\t\t\tscanf(\"%d\",&info[index].value);\n\t\t\tinfo[index].loc = 'A';\n\t\t\tindex++;\n\t\t}\n\n\t\tscanf(\"%d\",&b);\n\t\tfor(int i = 0; i < b; i++){\n\t\t\tscanf(\"%d\",&info[index].value);\n\t\t\tinfo[index].loc = 'B';\n\t\t\tindex++;\n\t\t}\n\n\t\tscanf(\"%d\",&c);\n\t\tfor(int i = 0; i < c; i++){\n\t\t\tscanf(\"%d\",&info[index].value);\n\t\t\tinfo[index].loc = 'C';\n\t\t\tindex++;\n\t\t}\n\n\t\tfor(int i = 1; i <= num_cup-1; i++){\n\t\t\tfor(int k = num_cup-1; k >= i; k--){\n\t\t\t\tif(info[k].value < info[k-1].value)swap(info[k],info[k-1]);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < num_cup;i++){\n\t\t\ttable[i] = info[i].loc;\n\t\t}\n\n\t\tsetCode(table,calc);\n\n\t\tLog[calc] = true;\n\n\t\tans = -1;\n\n\t\tbfs(table);\n\n\t\tprintf(\"%d\\n\",ans);\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\nvoid move(stack<int> *A, stack<int> *B, stack<int> *C, int m, int exp);\n\nint maxcount;//決められた、動き方の最大値\nint mincount;//今までに発見した最短の動き方\n\nint main() {\n\tint n;\n\tint m;\n\tint temp;\n\tint A_size,B_size,C_size;\n\tint ans[2000];\n\tint ansindex=0;\n\twhile(true){\n\t\tcin>>n;//n個のコップ\n\t\tcin>>m;//m回以内で動かせるか\n\t\tif(n==0&&m==0)break;\n\t\tmaxcount=m;//動かせる最大値\n\t\tmincount=m+1;//更新されていなければ解はなかった\n\t\tstack<int> *stA = new stack<int>;//Aのスタック\n\t\tstack<int> *stB = new stack<int>;//Bのスタック\n\t\tstack<int> *stC = new stack<int>;//Cのスタック\n\t\tcin>>A_size;\n\t\tfor(int i=0; i<A_size; i++){\n\t\t\tcin>>temp;\n\t\t\tstA->push(temp);\n\t\t}//Aの入力\n\t\tcin>>B_size;\n\t\tfor(int i=0; i<B_size; i++){\n\t\t\tcin>>temp;\n\t\t\tstB->push(temp);\n\t\t}//Bの入力\n\t\tcin>>C_size;\n\t\tfor(int i=0; i<C_size; i++){\n\t\t\tcin>>temp;\n\t\t\tstC->push(temp);\n\t\t}//Cの入力\n\t\tmove(stA,stB,stC,0,4);\n\t\tif(mincount==m+1)ans[ansindex]=-1;\n\t\telse ans[ansindex]=mincount;\n\t\tansindex++;\n\t\tdelete stA;\n\t\tdelete stB;\n\t\tdelete stC;\n\t}\n\tfor(int i=0; i<ansindex; i++){\n\t\tcout<<ans[i]<<\"\\n\";\n\t}\n\treturn 0;\n}\n\n\nvoid move(stack<int> *A, stack<int> *B, stack<int> *C, int count, int exp){\n\tint temp;\n\tif(count>maxcount)return;\n\tif((A->empty()||C->empty())&&B->empty()){\n\t\tif(count<mincount)mincount=count;\n\t}\n\tif(exp!=1&&((B->empty()&&A->empty()==false)||(B->empty()==false&&A->empty()==false&&A->top()>B->top()))){\n\t\t//行動0\n\t\ttemp=A->top();\n\t\tA->pop();\n\t\tB->push(temp);\n\t\tcount++;\n\t\tmove(A,B,C,count,0);\n\t\tcount--;\n\t\tB->pop();\n\t\tA->push(temp);\n\t}\n\tif(exp!=0&&((A->empty()&&B->empty()==false)||(A->empty()==false&&B->empty()==false&&B->top()>A->top()))){\n\t\t//行動1\n\t\ttemp=B->top();\n\t\tB->pop();\n\t\tA->push(temp);\n\t\tcount++;\n\t\tmove(A,B,C,count,1);\n\t\tcount--;\n\t\tA->pop();\n\t\tB->push(temp);\n\t}\n\tif(exp!=3&&((B->empty()&&C->empty()==false)||(B->empty()==false&&C->empty()==false&&C->top()>B->top()))){\n\t\t//行動2\n\t\ttemp=C->top();\n\t\tC->pop();\n\t\tB->push(temp);\n\t\tcount++;\n\t\tmove(A,B,C,count,2);\n\t\tcount--;\n\t\tB->pop();\n\t\tC->push(temp);\n\t}\n\tif(exp!=2&&((C->empty()&&B->empty()==false)||(C->empty()==false&&B->empty()==false&&B->top()>C->top()))){\n\t\t//行動3\n\t\ttemp=B->top();\n\t\tB->pop();\n\t\tC->push(temp);\n\t\tcount++;\n\t\tmove(A,B,C,count,3);\n\t\tcount--;\n\t\tC->pop();\n\t\tB->push(temp);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint mp[15000000];\nint Hash(string s) {\n\tint cnt = 0, t = 1;\n\trep(i, s.size()) {\n\t\tcnt += s[i]*t;\n\t\tt *= 3;\n\t}\n\treturn cnt;\n}\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tmemset(mp, 0, sizeof(mp));\n\t\tstring in(15, 0);\n\t\trep(i, 3) {\n\t\t\tint len; scanf(\"%d\", &len);\n\t\t\trep(j, len) {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tin[--a] = i;\n\t\t\t}\n\t\t}\n\t\tqueue<string>que;\n\t\tmp[Hash(in)] = 1;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tstring u = que.front(); que.pop();\n\t\t\tif (count(u.begin(), u.begin() + n, 0) == n ||\n\t\t\t\tcount(u.begin(), u.begin() + n, 2) == n) {\n\t\t\t\tprintf(\"%d\\n\", mp[Hash(u)] - 1);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (mp[Hash(u)] > m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tint fi = u.rfind(i, n - 1), fj = u.rfind(j, n - 1);\n\t\t\t\tif (fi == -1 || fi < fj)continue;\n\t\t\t\tstring v = u;\n\t\t\t\tv[fi] = j;\n\t\t\t\tif (!mp[Hash(v)]) {\n\t\t\t\t\tmp[Hash(v)] = mp[Hash(u)] + 1;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<stack<short> > > P;\ntypedef pair <int,P> PP;\ntypedef pair <int,PP> PPP;\n\nstatic const double eps = 1e-8;\n\nint bfs(int m,vector<stack<short> >& stks, map<vector<stack<short> >,int>& visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,stks));\n\tvisited[stks] = 0;\n\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\n\t\t\n\t\tvector<stack<short> > stks = que.top().second;\n\n\t\tif(stks[1].empty() && stks[2].empty()) return cost;\n\t\tif(stks[0].empty() && stks[1].empty()) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<stks.size();i++){\n\t\t\tif((!stks[i].empty() && !stks[i+1].empty() && stks[i].top() < stks[i+1].top()) \n\t\t\t\t|| (stks[i].empty() && !stks[i+1].empty())){\n\t\t\t\tvector<stack<short> > tmp = stks;\n\t\t\t\ttmp[i].push(tmp[i+1].top());\n\t\t\t\ttmp[i+1].pop();\n\t\t\t\tif(visited.find(tmp) == visited.end()){\n\t\t\t\t\tvisited[tmp] = cost + 1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((!stks[i].empty() && !stks[i+1].empty() && stks[i].top() > stks[i+1].top()) \n\t\t\t\t|| (!stks[i].empty() && stks[i+1].empty())){\n\t\t\t\tvector<stack<short> > tmp = stks;\n\t\t\t\ttmp[i+1].push(tmp[i].top());\n\t\t\t\ttmp[i].pop();\n\t\t\t\tif(visited.find(tmp) == visited.end()){\n\t\t\t\t\tvisited[tmp] = cost + 1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<stack<short> > stks(3);\n\t\tmap<vector<stack<short> >,int> visited;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tstks[i].push(size);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,stks,visited));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\nusing namespace std;\nint n, m, c, x, l[15], d[14348915], power[16];\nint main() {\n\tpower[0] = 1;\n\tfor (int i = 1; i < 16; i++) power[i] = power[i - 1] * 3;\n\twhile (cin >> n >> m, n) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcin >> c;\n\t\t\tfor (int j = 0; j < c; j++) cin >> x, l[--x] = i;\n\t\t}\n\t\tint s = 0, f = 0;\n\t\tfor (int i = 0; i < n; i++) s += power[i] * l[i];\n\t\tfill(d, d + power[n], -1); d[s] = 0;\n\t\tqueue<int> que; que.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tif (v == 0 || v == power[n] - 1) {\n\t\t\t\tcout << d[v] << endl; f = 1; break;\n\t\t\t}\n\t\t\tif (d[v] == m) continue;\n\t\t\tint maxr[3] = { -1, -1, -1 };\n\t\t\tfor (int i = 0; i < n; i++) maxr[(v / power[i]) % 3] = i;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tif (maxr[i] == -1) continue;\n\t\t\t\tint k = maxr[i];\n\t\t\t\tint e = (v / power[k]) % 3;\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tif (k < maxr[j]) continue;\n\t\t\t\t\tint nxt = -1;\n\t\t\t\t\tif (e - j == -1) nxt = v + power[k];\n\t\t\t\t\tif (e - j == 1) nxt = v - power[k];\n\t\t\t\t\tif (nxt != -1 && d[nxt] == -1) {\n\t\t\t\t\t\td[nxt] = d[v] + 1;\n\t\t\t\t\t\tque.push(nxt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!f) cout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <cstring>\nusing namespace std;\n\nint n, m, cnt;\nint pos[20], tmpPos[20];\n\nvoid copyPos(int *fromPos, int *toPos){\n  for(int i = 0; i < 20; i++){\n    toPos[i] = fromPos[i];\n  }\n}\n\nvoid move(int x, int to){\n  if(pos[x] == to){\n    return;\n  }\n\n  int ops = -to + 2;\n\n  if(pos[x] == ops){\n    for(int i = x + 1; i < n; i++){\n      move(i, to);\n      if(cnt > m) return;\n    }\n\n    cnt++;\n    if(cnt > m) return;\n    pos[x] = 1;\n  }\n\n  if(pos[x] == 1){\n    for(int i = x + 1; i < n; i++){\n      move(i, ops);\n      if(cnt > m) return;\n    }\n\n    cnt++;\n    if(cnt > m) return;\n    pos[x] = to;\n  }\n}\n\nvoid solve(){\n  int res = m + 1;\n\n  copyPos(pos, tmpPos);\n  cnt = 0;\n\n  for(int i = 0; i < n; i++){\n    move(i, 0);\n    if(cnt > m) break;\n  }\n\n  res = min(res, cnt);\n  copyPos(tmpPos, pos);\n  cnt = 0;\n\n  for(int i = 0; i < n; i++){\n    move(i, 2);\n    if(cnt > m) break;\n  }\n\n  res = min(res, cnt);\n\n  cout << (res == m + 1 ? -1 : res) << endl;\n}\n\nint main(){\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < 3; i++){\n      int a;\n      cin >> a;\n\n      for(int j = 0; j < a; j++){\n        int x;\n        cin >> x;\n        x--;\n        pos[x] = i;\n      }\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#define f(n) ((int)pow(3.0,n)-1)\nint A,N,M,S[16];\nint v(int n,int m,int g){if(m<=N)return v(n-1,m+1,S[m]==1?g+2*(1-g):g)+abs(g-S[m])*(f(n-1)+1);else return 0;}\nint main(){while(1){scanf(\"%d%d\",&N,&M);if(!(N||M))break;for(int i=0;i<3;++i){int t;scanf(\"%d\",&t);for(int j=0;j<t;++j){int u;scanf(\"%d\",&u);S[u]=i;}}A=v(N,1,0);A=std::min(A,f(N)-A);A=A<=M?A:-1;printf(\"%d\\n\",A);}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint T[20];\nint A[20], B[20];\nint n, m;\n\nint solve() {\n    int P[17];\n    P[n] = 2;\n    for ( int i = n; i > 0; -- i ) P[i-1] = 3 * P[i] + 2;\n    \n    A[n] = T[n];\n    B[n] = 2 - T[n];\n    for ( int i = n; i > 1; -- i ) {\n        if ( T[i-1] == 0 ) {\n            A[i-1] = A[i];\n            B[i-1] = A[i] + 2 * P[i] + 2;\n        } else if ( T[i-1] == 1 ) {\n            A[i-1] = B[i] + P[i] + 1;\n            B[i-1] = A[i] + P[i] + 1;\n        } else {\n            A[i-1] = A[i] + 2 * P[i] + 2;\n            B[i-1] = B[i];\n        }\n    }\n    int res = min( A[1], B[1] );\n    if ( res > m ) return -1;\n    return res;\n}\n\nint main() {\n    while ( cin >> n >> m && n ) {\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                T[t] = i;\n            }\n        }\n\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint p[15], n, k, a1, a2, a3, a4, a5, power[16], dp[15000000];\nqueue<int>Q;\nint main() {\n\twhile (true) {\n\t\tcin >> n >> k; power[0] = 1; for (int i = 1; i < 16; i++)power[i] = power[i - 1] * 3; a5 = 0;\n\t\tif (n == 0 && k == 0)break;\n\t\tcin >> a1; for (int i = 0; i < a1; i++) { cin >> a4; p[a4 - 1] = 0; }\n\t\tcin >> a2; for (int i = 0; i < a2; i++) { cin >> a4; p[a4 - 1] = 1; }\n\t\tcin >> a3; for (int i = 0; i < a3; i++) { cin >> a4; p[a4 - 1] = 2; }\n\t\tfor (int i = 0; i < n; i++) { a5 += power[i] * p[i]; }\n\t\tfor (int i = 0; i < power[n]; i++)dp[i] = 1000000000; dp[a5] = 0; Q.push(a5);\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front(); Q.pop();\n\t\t\tvector<int>b1, b2, b3;\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tint p1 = (a1 / power[i]) % 3;\n\t\t\t\tif (p1 == 0)b1.push_back(i);\n\t\t\t\tif (p1 == 1)b2.push_back(i);\n\t\t\t\tif (p1 == 2)b3.push_back(i);\n\t\t\t}\n\t\t\tif (b1.size() >= 1 && (b2.size() == 0 || b1[0] > b2[0])) {\n\t\t\t\tint F = a1 + power[b1[0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t\tif (b2.size() >= 1 && (b1.size() == 0 || b1[0] < b2[0])) {\n\t\t\t\tint F = a1 - power[b2[0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t\tif (b2.size() >= 1 && (b3.size() == 0 || b2[0] > b3[0])) {\n\t\t\t\tint F = a1 + power[b2[0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t\tif (b3.size() >= 1 && (b2.size() == 0 || b2[0] < b3[0])) {\n\t\t\t\tint F = a1 - power[b3[0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t}\n\t\tint ans = min(dp[0], dp[power[n] - 1]);\n\t\tif (ans > k)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define PB push_back\nusing namespace std;\nstruct Cup{\n    vector<vector<int> >A;\n    int cnt,b;\n    Cup(vector<vector<int> >A_,int cnt_,int b_){\n        A=A_;cnt=cnt_;b=b_;\n    }\n    Cup(){}\n};\nint main(){\n    int n,m;\n    while(cin>>n>>m,n||m){\n        queue<Cup>Q;\n        int mn=m+5;\n        int cnttt=0;\n        vector<vector<int> >V(3);\n        V[0].PB(0);V[1].PB(0);V[2].PB(0);\n        for(int i=0;i<3;i++){\n            int s;\n            cin>>s;\n            for(int j=0;j<s;j++){\n                int d;\n                cin>>d;\n                V[i].PB(d);\n            }\n        }\n        if(V[0].back()<V[1].back()){\n            V[0].PB(V[1].back());\n            V[1].pop_back();\n            Q.push(Cup(V,1,1));\n            V[1].PB(V[0].back());\n            V[0].pop_back();\n        }\n        else if(V[0].back()!=0){\n            V[1].PB(V[0].back());\n            V[0].pop_back();\n            Q.push(Cup(V,1,0));\n            V[0].PB(V[1].back());\n            V[1].pop_back();\n        }\n\n\n        if(V[2].back()<V[1].back()){\n            V[2].PB(V[1].back());\n            V[1].pop_back();\n            Q.push(Cup(V,1,3));\n            V[1].PB(V[2].back());\n            V[2].pop_back();\n        }\n        else if(V[2].back()!=0){\n            V[1].PB(V[2].back());\n            V[2].pop_back();\n            Q.push(Cup(V,1,2));\n            V[2].PB(V[1].back());\n            V[1].pop_back();\n        }\n        if(V[0].size()==n+1||V[2].size()==0){\n            cout<<0<<endl;\n            continue;\n        }\n\n        while(Q.size()){\n            Cup x=Q.front();Q.pop();\n            if(x.cnt>m)continue;\n\n            if(x.cnt%100000==0)cout<<x.cnt<<endl;\n            cnttt++;\n            if(x.A[0].size()==n+1||x.A[2].size()==n+1){\n                mn=min(mn,x.cnt);\n                break;\n            }\n\n            if(x.b==2||x.b==3){\n                if(x.A[0].back()<x.A[1].back()){\n                    x.A[0].PB(x.A[1].back());\n                    x.A[1].pop_back();\n                    Q.push(Cup(x.A,x.cnt+1,1));\n                    x.A[1].PB(x.A[0].back());\n                    x.A[0].pop_back();\n                }\n                else if(x.A[0].back()!=0){\n                    x.A[1].PB(x.A[0].back());\n                    x.A[0].pop_back();\n                    Q.push(Cup(x.A,x.cnt+1,0));\n                    x.A[0].PB(x.A[1].back());\n                    x.A[1].pop_back();\n                }\n            }\n            else{\n                if(x.A[2].back()<x.A[1].back()){\n                    x.A[2].PB(x.A[1].back());\n                    x.A[1].pop_back();\n                    Q.push(Cup(x.A,x.cnt+1,3));\n                    x.A[1].PB(x.A[2].back());\n                    x.A[2].pop_back();\n                }\n                else if(x.A[2].back()!=0){\n                    x.A[1].PB(x.A[2].back());\n                    x.A[2].pop_back();\n                    Q.push(Cup(x.A,x.cnt+1,2));\n                    x.A[2].PB(x.A[1].back());\n                    x.A[1].pop_back();\n                }\n            }\n\n        }\n        cout<<\":::\"<<cnttt<<endl;\n        if(mn==m+5)mn=-1;\n        cout<<mn<<endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, int>;\n\nint a[25];\nint d[15000010];\n\nvoid debug(int pos, int n){\n\trep(i, n){\n\t\tcout << pos % 3 << \" \";\n\t\tpos /= 3;\n\t}\n\tcout << endl;\n}\n\nint main(){\n\ta[0] = 1;\n\trep(i, 20) a[i + 1] = a[i] * 3;\n\n\tint n, m;\n\twhile (cin >> n >> m, n | m){\n\t\tint start = 0;\n\t\trep(i, 3){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\twhile (k--){\n\t\t\t\tint x;\n\t\t\t\tcin >> x;\n\t\t\t\tstart += i*a[x - 1];\n\t\t\t}\n\t\t}\n\t\tint goal = a[n] - 1;\n\n\t\tMEMSET(d, -1);\n\t\td[start] = 0;\n\t\tqueue<P> q;\n\t\tif (start == 0 || start == goal) goto OK;\n\t\tq.push(make_pair(start, 0));\n\t\twhile (!q.empty()){\n\t\t\tP p = q.front();\n\t\t\tq.pop();\n\n\t\t\tint pos = p.first;\n\t\t\tint dist = p.second;\n\n\t\t\tint tmp = pos;\n\t\t\tbool ng[3] = {};\n\t\t\tfor (int i = n - 1; i >= 0; --i){\n\t\t\t\tint x = tmp / a[i];\n\t\t\t\ttmp = tmp % a[i];\n\t\t\t\tif (ng[x]) continue;\n\t\t\t\tng[x] = 1;\n\t\t\t\tfor (int j = max(x - 1, 0); j <= min(x + 1, 2); ++j){\n\t\t\t\t\tif (ng[j]) continue;\n\t\t\t\t\tint nxt = pos + ((j - x)*a[i]);\n\t\t\t\t\tif (d[nxt] >= 0) continue;\n\t\t\t\t\t//debug(nxt, n);\n\t\t\t\t\td[nxt] = dist + 1;\n\t\t\t\t\tif (nxt == 0 || nxt == goal) goto OK;\n\t\t\t\t\tif(dist + 1 < m) q.push(make_pair(nxt, dist+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\tcontinue;\n\tOK:;\n\t\tcout << max(d[0], d[goal]) << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e8\n#define EPS 1e-9\n\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) rep2(i,0,n)\n#define ll long long\n#define pb push_back\n\nint n,m;\n\nint main(){\n\twhile(cin>>n>>m&&n){\n\t\tstack<int> A,B,C,X,Y,Z;\n\t\tint a,b,ans=INF,step=0;\n\t\tcin>>a;rep(i,a){cin>>b;X.push(b);}\n\t\tcin>>a;rep(i,a){cin>>b;Y.push(b);}\n\t\tcin>>a;rep(i,a){cin>>b;Z.push(b);}\n\t\trep(i,2){\n\t\t\tif(i==0){A=X;B=Y;C=Z;}\n\t\t\telse{A=Z;B=Y;C=X;}\n\t\t\tfor(;;){\n\t\t\t\tif(step==m+1||A.size()==n||C.size()==n)break;\n\t\t\t\tif(B.empty()||!A.empty()&&A.top()>B.top()){\n\t\t\t\t\tB.push(A.top());\n\t\t\t\t\tA.pop();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tA.push(B.top());\n\t\t\t\t\tB.pop();\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tif(step==m+1||A.size()==n||C.size()==n)break;\n\t\t\t\tif(C.empty()||!B.empty()&&B.top()>C.top()){\n\t\t\t\t\tC.push(B.top());\n\t\t\t\t\tB.pop();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tB.push(C.top());\n\t\t\t\t\tC.pop();\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tans=min(ans,step);\n\t\t}\n\t\tcout<<(ans<=m?ans:-1)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define INF 15\n#define A 0\n#define B 1\n#define C 2\n\nchar cond[INF];\nchar n;\nint  m;\nint sum;\n\nvoid move(int pos, char dist) {\n    char now = cond[pos];\n\n    if (now == dist) {\n        return;\n    } else if (abs(now-dist) == 2) {\n        move(pos, B);\n        move(pos, dist);\n    } else {\n        int i;\n        char no_present = (dist+now == 1)?C:\n                          (dist+now == 2)?B:\n                                          A;\n        for (i=1;pos+i < n;i++){\n            if (cond[pos+i] == dist || cond[pos+i] == now) {\n                move(pos+i, no_present);\n            }\n        }\n\n        cond[pos] = dist;\n        sum += 1;\n    }\n\n    return;\n}\n\nint main() {\n    while (1) {\n        int i;\n        char dist;\n    \n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m ==0) {\n            break;\n        }\n\n        for (i=0;i < 3;i++) {\n            int j,k;\n\n            scanf(\"%d\", &k);\n            for (j=0;j < k;j++) {\n                int tmp;\n    \n                scanf(\"%d\", &tmp);\n                cond[tmp-1] = i;\n            }\n        }\n    \n        dist = (cond[0] != B)?cond[0]:A;\n    \n        for (i=0;i < n;i++) {\n            move(i, dist);\n        }\n    \n        if (sum <= m) {\n            printf(\"%d\\n\", sum);\n        } else {\n            printf(\"-1\\n\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// #include {{{\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <chrono>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#ifdef LOCAL\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n#endif\n\nusing namespace std;\n// }}}\n\n// type {{{\nusing  i8 =   int8_t;\nusing  u8 =  uint8_t;\nusing i16 =  int16_t;\nusing u16 = uint16_t;\nusing i32 =  int32_t;\nusing u32 = uint32_t;\nusing i64 =  int64_t;\nusing u64 = uint64_t;\n\nusing i128 =  __int128_t;\nusing u128 = __uint128_t;\n\ntemplate<typename T>\nusing MaxHeap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n// }}}\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\n// }}}\n\n// 適宜調整\nconstexpr bool AUTOFLUSH = false;\n\nconstexpr int IOS_PREC = 12;\n\nconstexpr int INF_I32 =             1'010'000'000;\nconstexpr i64 INF_I64 = 1'010'000'000'000'000'000LL;\n\nconstexpr auto   INF = INF_I64;\nconstexpr double EPS = 1e-12;\n\nconstexpr i64 MOD = 1'000'000'007;\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n// }}}\n\n// util {{{\nconstexpr i32 I32_MAX = numeric_limits<i32>::max();\nconstexpr i32 I32_MIN = numeric_limits<i32>::min();\n\nconstexpr i64 I64_MAX = numeric_limits<i64>::max();\nconstexpr i64 I64_MIN = numeric_limits<i64>::min();\n\nconstexpr double PI = 3.14159265358979323846;\n\ntemplate<typename F>\nclass RecursiveFunc {\npublic:\n    RecursiveFunc(F&& f) : f_(f) {}\n\n    template<typename... Args>\n    decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<typename F>\nauto RECURSIVE(F&& f) {\n    return RecursiveFunc<decay_t<F>>(forward<F>(f));\n}\n\ntemplate<typename T>\nint GETBIT(T x, int i) { return (x>>i) & 1; }\ntemplate<typename T>\nT SETBIT(T x, int i) { return x | (T(1)<<i); }\ntemplate<typename T>\nT CLEARBIT(T x, int i) { return x & ~(T(1)<<i); }\n\ntemplate<typename T>\nconstexpr const T& MAX(const T& x, const T& y) { return std::max(x, y); }\ntemplate<typename T, typename Comp>\nconstexpr const T& MAX(const T& x, const T& y, Comp comp) { return std::max(x, y, comp); }\ntemplate<typename T>\nconstexpr T MAX(initializer_list<T> ilist) { return std::max(ilist); }\ntemplate<typename T, typename Comp>\nconstexpr T MAX(initializer_list<T> ilist, Comp comp) { return std::max(ilist, comp); }\n\ntemplate<typename T>\nconstexpr const T& MIN(const T& x, const T& y) { return std::min(x, y); }\ntemplate<typename T, typename Comp>\nconstexpr const T& MIN(const T& x, const T& y, Comp comp) { return std::min(x, y, comp); }\ntemplate<typename T>\nconstexpr T MIN(initializer_list<T> ilist) { return std::min(ilist); }\ntemplate<typename T, typename Comp>\nconstexpr T MIN(initializer_list<T> ilist, Comp comp) { return std::min(ilist, comp); }\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n    return x < 0 ? -x : x;\n}\n\ntemplate<typename T>\nconstexpr T abs_diff(T x, T y) {\n    return x < y ? y-x : x-y;\n}\n\ntemplate<typename T>\nconstexpr bool is_odd(T x)  { return x % 2 != 0; }\ntemplate<typename T>\nconstexpr bool is_even(T x) { return x % 2 == 0; }\n\ntemplate<typename T>\nconstexpr bool parity_same(T x, T y) {\n    return (is_odd(x) && is_odd(y)) || (is_even(x) && is_even(y));\n}\n\ntemplate<typename T>\nconstexpr int cmp(T x, T y) { return (y < x) - (x < y); }\n\ntemplate<typename T>\nconstexpr int sgn(T x) { return cmp(x, T(0)); }\n\nconstexpr i64 ipow(i64 a, i64 b) {\n    assert(b >= 0);\n    i64 res(1);\n    for(i64 i = 0; i < b; ++i)\n        res *= a;\n    return res;\n}\n\npair<i64,i64> divmod(i64 a, i64 b) {\n    return make_pair(a/b, a%b);\n}\n\nconstexpr i64 div_ceil(i64 a, i64 b) {\n    return a/b + (((a<0)^(b>0)) && (a%b));\n}\n\nconstexpr i64 div_floor(i64 a, i64 b) {\n    return a/b - (((a>0)^(b>0)) && (a%b));\n}\n\nconstexpr i64 modulo(i64 a, i64 b) {\n    assert(0 < b);\n    i64 r = a % b;\n    return r >= 0 ? r : r+b;\n}\n\ntemplate<typename T>\nconstexpr T CLAMP(T x, T lo, T hi) {\n    assert(lo <= hi);\n    if(x < lo)\n        return lo;\n    else if(hi < x)\n        return hi;\n    else\n        return x;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T>\nconstexpr int SIZE(const T& c) {\n    return static_cast<int>(c.size());\n}\n\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N]) {\n    return static_cast<int>(N);\n}\n\ntemplate<typename InputIt, typename T>\nint argfind(InputIt first, InputIt last, const T& x) {\n    auto it = find(first, last, x);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmax(InputIt first, InputIt last) {\n    auto it = max_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmin(InputIt first, InputIt last) {\n    auto it = min_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nbool alltrue(InputIt first, InputIt last) {\n    return all_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool anytrue(InputIt first, InputIt last) {\n    return any_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool allfalse(InputIt first, InputIt last) {\n    return !anytrue(first, last);\n}\n\ntemplate<typename InputIt>\nbool anyfalse(InputIt first, InputIt last) {\n    return !alltrue(first, last);\n}\n\n// hash {{{\ntemplate<typename T>\nstruct myhash {\n    size_t operator()(const T& x) const {\n        hash<T> h;\n        return h(x);\n    }\n};\n\ntemplate<typename T>\nsize_t myhash_value(const T& x) {\n    return hash<T>()(x);\n}\n\ntemplate<typename T>\nvoid myhash_combine(size_t& seed, const T& x) {\n    seed ^= myhash_value(x) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n}\n\ntemplate<typename T1, typename T2>\nstruct myhash<pair<T1,T2>> {\n    size_t operator()(const pair<T1,T2>& p) const {\n        size_t seed = 0;\n        myhash_combine(seed, p.first);\n        myhash_combine(seed, p.second);\n        return seed;\n    }\n};\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\nvoid TUPLEHASH(size_t&, const tuple<TS...>&) {}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\nvoid TUPLEHASH(size_t& seed, const tuple<TS...>& t) {\n    myhash_combine(seed, get<I>(t));\n    TUPLEHASH<I+1, TS...>(seed, t);\n}\n\ntemplate<typename... TS>\nstruct myhash<tuple<TS...>> {\n    size_t operator()(const tuple<TS...>& t) const {\n        size_t seed = 0;\n        TUPLEHASH(seed, t);\n        return seed;\n    }\n};\n\ntemplate<typename Seq>\nvoid SEQHASH(size_t& seed, const Seq& v) {\n    for(const auto& e : v)\n        myhash_combine(seed, e);\n}\n\ntemplate<typename T>\nstruct myhash<vector<T>> {\n    size_t operator()(const vector<T>& v) const {\n        size_t seed = 0;\n        SEQHASH(seed, v);\n        return seed;\n    }\n};\n\ntemplate<typename T, size_t N>\nstruct myhash<array<T,N>> {\n    size_t operator()(const array<T,N>& v) const {\n        size_t seed = 0;\n        SEQHASH(seed, v);\n        return seed;\n    }\n};\n\ntemplate<typename T>\nusing HashSet = unordered_set<T,myhash<T>>;\n\ntemplate<typename K, typename V>\nusing HashMap = unordered_map<K,V,myhash<K>>;\n\ntemplate<typename T>\nusing HashMultiSet = unordered_multiset<T,myhash<T>>;\n\ntemplate<typename K, typename V>\nusing HashMultiMap = unordered_multimap<K,V,myhash<K>>;\n// }}}\n\ntemplate<typename T, typename... Args>\nvoid vec_emplace_front(vector<T>& v, Args&&... args) {\n    v.emplace(begin(v), args...);\n}\n\ntemplate<typename K, typename V>\npair<typename map<K,V>::iterator, bool> insert_or_assign(map<K,V>& m, const K& k, const V& v) {\n    auto it = m.lower_bound(k);\n    if(it != end(m) && !m.key_comp()(k,it->first)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename K, typename V>\npair<typename HashMap<K,V>::iterator, bool>\ninsert_or_assign(HashMap<K,V>& m, const K& k, const V& v) {\n    auto it = m.find(k);\n    if(it != end(m)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename T>\nstring TO_STRING(const T& x) {\n    ostringstream out;\n    out << x;\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << sep;\n    }\n    return out.str();\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename T>\nvoid UNIQ(T& c) {\n    c.erase(unique(begin(c), end(c)), end(c));\n}\n\ntemplate<typename T, typename F>\nenable_if_t<rank<T>::value==0> ARRAY_FOREACH(T& e, F f) {\n    f(e);\n}\n\ntemplate<typename Array, typename F>\nenable_if_t<rank<Array>::value!=0> ARRAY_FOREACH(Array& ary, F f) {\n    for(auto& e : ary)\n        ARRAY_FOREACH(e, f);\n}\n\ntemplate<typename Array, typename U>\nenable_if_t<rank<Array>::value!=0> ARRAY_FILL(Array& ary, const U& v) {\n    ARRAY_FOREACH(ary, [&v](auto& elem) { elem = v; });\n}\n\ntemplate<typename T>\nT POP_BACK(vector<T>& que) {\n    T x = que.back(); que.pop_back();\n    return x;\n}\n\ntemplate<typename T>\nT POP_BACK(deque<T>& que) {\n    T x = que.back(); que.pop_back();\n    return x;\n}\n\ntemplate<typename T>\nT POP_FRONT(deque<T>& que) {\n    T x = que.front(); que.pop_front();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nT POP(priority_queue<T,Cont,Cmp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef LOCAL\n    if(!cin) assert(false);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, int n) {\n    v.reserve(n);\n    for(int i = 0; i < n; ++i) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\ntemplate<typename T, size_t N>\nvoid RD(array<T,N>& v) {\n    for(size_t i = 0; i < N; ++i) {\n        RD(v[i]);\n    }\n}\n\n// 出力 {{{\n// FPRINTSEQ {{{\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last) {\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << ' ';\n    }\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last) {\n    return FPRINTSEQ(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last) {\n#ifdef LOCAL\n    FPRINTSEQ(cerr, first, last);\n#endif\n    return cerr;\n}\n// }}}\n\n// 1次元生配列 {{{\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N]) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N]) {\n    return FPRINTARRAY1(cout, c);\n}\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N]) {\n#ifdef LOCAL\n    FPRINTARRAY1(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 2次元生配列 {{{\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2]) {\n    out << '\\n';\n    for(const auto& e : c) {\n        FPRINTARRAY1(out, e) << '\\n';\n    }\n    return out;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2]) {\n    return FPRINTARRAY2(cout, c);\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2]) {\n#ifdef LOCAL\n    FPRINTARRAY2(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 非mapコンテナ {{{\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\n// 特別扱い\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c) {\n    out << '\\n';\n    for(const auto& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\n// 特別扱い\nostream& operator<<(ostream& out, const vector<string>& c) {\n    out << '\\n';\n    for(const string& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const HashSet<T>& c) {\n    return out << set<T>(begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const multiset<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const HashMultiSet<T>& c) {\n    return out << multiset<T>(begin(c), end(c));\n}\n\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n// }}}\n\n// mapコンテナ {{{\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last) {\n    out << \"{\\n\";\n    for(auto it = first; it != last; ++it) {\n        out << \"  \" << it->first << \" : \" << it->second << '\\n';\n    }\n    out << \"}\\n\";\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last) {\n    return FPRINTMAP(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last) {\n#ifdef LOCAL\n    FPRINTMAP(cerr, first, last);\n#endif\n    return cerr;\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c) {\n    return FPRINTMAP(out, begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const HashMap<K,V>& c) {\n    return out << map<K,V>(begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const multimap<K,V>& c) {\n    return FPRINTMAP(out, begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const HashMultiMap<K,V>& c) {\n    return out << multimap<K,V>(begin(c), end(c));\n}\n// }}}\n\n// stack/queue/priority_queue {{{\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c) {\n    while(!c.empty()) {\n        out << c.front();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n// }}}\n\n// pair/tuple {{{\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\nostream& FPRINTTUPLE(ostream& out, const tuple<TS...>&) {\n    if(sizeof...(TS) == 0)\n        out << '(';\n    return out << ')';\n}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\nostream& FPRINTTUPLE(ostream& out, const tuple<TS...>& t) {\n    if(I == 0)\n        out << '(';\n    else\n        out << ',';\n    out << get<I>(t);\n    return FPRINTTUPLE<I+1, TS...>(out, t);\n}\n\ntemplate<typename... TS>\nostream& operator<<(ostream& out, const tuple<TS...>& t) {\n    return FPRINTTUPLE(out, t);\n}\n// }}}\n\n// PRINT {{{\nostream& FPRINT(ostream& out) { return out; }\n\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args) {\n    out << x;\n    if(sizeof...(args))\n        out << ' ';\n    return FPRINT(out, args...);\n}\n\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args) {\n    FPRINT(out, args...);\n    return out << '\\n';\n}\n\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args) {\n    return FPRINT(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args) {\n    return FPRINTLN(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args) {\n#ifdef LOCAL\n    FPRINT(cerr, args...);\n#endif\n    return cerr;\n}\n\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args) {\n#ifdef LOCAL\n    FPRINTLN(cerr, args...);\n#endif\n    return cerr;\n}\n// }}}\n// }}}\n\nvoid FLUSH() {\n    cout.flush();\n}\n\n[[noreturn]] void EXIT() {\n#ifdef LOCAL\n    cout.flush();\n    cerr.flush();\n#else\n    FLUSH();\n#endif\n    //quick_exit(0); // does not work on codeforces\n    _Exit(0);\n}\n\nstruct IoInit {\n    IoInit() {\n#ifndef LOCAL\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n#endif\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} IOINIT;\n\n#define FOR(i, start, end) for(i64 i = (start); i < (end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cc) { return (f)(begin(cc), end(cc), ## __VA_ARGS__); })(c))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\n\n#define PAIR make_pair\n#define TUPLE make_tuple\n// }}}\n\nstruct State {\n    array<vector<i64>,3> v;\n    pair<i64,i64> pre;\n\n    vector<State> neighbor() const {\n        constexpr pair<i64,i64> MOVES[] {\n            {0,1}, {1,0}, {1,2}, {2,1},\n        };\n\n        vector<State> res;\n\n        for(const auto& m : MOVES) {\n            if(m == pre) continue;\n\n            i64 from,to; tie(from,to) = m;\n            if(movable(from,to)) {\n                State st(*this);\n                st.mv(from,to);\n                res.emplace_back(st);\n            }\n        }\n\n#if 0\n        if(movable(0,1)) {\n            State st(*this);\n            st.mv(0,1);\n            res.emplace_back(st);\n        }\n        else if(movable(1,0)) {\n            State st(*this);\n            st.mv(1,0);\n            res.emplace_back(st);\n        }\n\n        if(movable(1,2)) {\n            State st(*this);\n            st.mv(1,2);\n            res.emplace_back(st);\n        }\n        else if(movable(2,1)) {\n            State st(*this);\n            st.mv(2,1);\n            res.emplace_back(st);\n        }\n#endif\n\n        return res;\n    }\n\n    void mv(i64 from, i64 to) {\n        v[to].emplace_back(POP_BACK(v[from]));\n        pre = { from, to };\n    }\n\n    bool movable(i64 from, i64 to) const {\n        if(v[from].empty()) return false;\n        if(v[to].empty()) return true;\n        return v[to].back() < v[from].back();\n    }\n\n    bool done() const {\n        return v[1].empty() && (v[0].empty() || v[2].empty());\n    }\n};\n\n#if 0\nbool operator==(const State& lhs, const State& rhs) {\n    return lhs.v == rhs.v;\n}\n\ntemplate<>\nstruct myhash<State> {\n    size_t operator()(const State& st) const {\n        size_t seed = 0;\n        for(const auto& e : st.v) {\n            SEQHASH(seed, e);\n        }\n        return seed;\n    }\n};\n#endif\n\ni64 bfs(i64 M, State st_start) {\n#if 0\n    HashSet<State> visited;\n#endif\n    queue<pair<State,i64>> que;\n\n#if 0\n    visited.emplace(st_start);\n#endif\n    que.emplace(st_start, 0);\n\n    while(!que.empty()) {\n        State st; i64 d; tie(st,d) = POP(que);\n\n        if(d > M) return -1;\n        if(st.done()) return d;\n\n        for(const auto& to : st.neighbor()) {\n#if 0\n            if(visited.count(to)) continue;\n\n            visited.emplace(to);\n#endif\n            que.emplace(to, d+1);\n        }\n    }\n\n    assert(false);\n}\n\nvoid solve(i64 /*N*/, i64 M, State st) {\n    i64 ans = bfs(M, st);\n    PRINTLN(ans);\n}\n\nsigned main(signed /*argc*/, char** /*argv*/) {\n    while(true) {\n        i64 N; RD(N);\n        i64 M; RD(M);\n        if(N == 0 && M == 0) break;\n\n        State st;\n        REP(i, 3) {\n            i64 k; RD(k);\n            RD(st.v[i], k);\n        }\n\n        solve(N, M, move(st));\n    }\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\nint n, m;\nint POW[16];\n\nint calc(int A, int B, int C) {\n\tint res = 0;\n\tfor_(i,0,n) {\n\t\tint k = n - i - 1;\n\t\tif (A >> i & 1) res += 2 * POW[k];\n\t\tif (B >> i & 1) res += POW[k], swap(A, C);\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tint cup[3] = { 0 };\n\t\n\tfor_(i,0,3) {\n\t\tint d; cin >> d;\n\t\tfor_(j,0,d) {\n\t\t\tint p; cin >> p; --p;\n\t\t\tcup[i] |= 1 << p;\n\t\t}\n\t}\n\t\n\tint ans = min(calc(cup[0], cup[1], cup[2]), calc(cup[2], cup[1], cup[0]));\n\tcout << ( (ans > m) ? -1 : ans) << endl;\n}\n\nint main() {\n\tPOW[0] = 1;\n\tfor_(i,1,16) POW[i] = POW[i - 1] * 3;\n\twhile (cin >> n >> m, n) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n\nusing ll = long long;\nusing namespace std;\nusing P = pair<int, int>;\n\nint move(int A,int B, int C){\n    if(!A&&!B) return 0;\n    if(C&1)return move(A>>1,B>>1, C>>1);\n    if(B&1)return move(C>>1,B>>1, A>>1)+move((A|B|C )>>1, 0, 0) + 1;\n    if(A&1)return move(A>>1,B>>1, C>>1)+ 2*move((A|B|C)>>1, 0,0)+ 2;\n}\n\nint main() {\n    int n, m;\n    while(cin>>n>>m, n || m){\n        int cup[3] = {};\n        for (int &i : cup) {\n            int t;\n            cin >> t;\n            for (int j = 0; j < t; ++j) {\n                int a;\n                cin >> a;\n                i += 1<<(a-1);\n            }\n        }\n        int a = min(move(cup[0],cup[1], cup[2]),move(cup[2], cup[1], cup[0]));\n        cout << (a<=m ? a : -1) << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#define A(p) (b[p]-1<0?0:a[p][b[p]-1])\nusing namespace std;\nint m;\nint fn(int a[][15],int b[],int p){\n  int i;\n  for(i=0;i<m+1&&(b[1]||(b[0]&&b[2]));i++){\n    if(0){\n    }else if(p==0){\n      if(b[2]==0||a[1][b[1]-1]>a[2][b[2]-1]){\n\tb[1]--;\n\ta[2][b[2]]=a[1][b[1]];\n\tb[2]++;\n\tp=3;\n      }else{\n\tb[2]--;\n\ta[1][b[1]]=a[2][b[2]];\n\tb[1]++;\n\tp=1;\n      }\n    }else if(p==1){\n      if(b[0]==0||a[1][b[1]-1]>a[0][b[0]-1]){\n\tb[1]--;\n\ta[0][b[0]]=a[1][b[1]];\n\tb[0]++;\n\tp=2;\n      }else{\n\tb[0]--;\n\ta[1][b[1]]=a[0][b[0]];\n\tb[1]++;\n\tp=0;\n      }\n    }else if(p==2){\n      if(b[1]==0||a[1][b[1]-1]<a[2][b[2]-1]){\n\tb[2]--;\n\ta[1][b[1]]=a[2][b[2]];\n\tb[1]++;\n\tp=1;\n      }else{\n\tb[1]--;\n\ta[2][b[2]]=a[1][b[1]];\n\tb[2]++;\t\n\tp=3;\n      }\n    }else if(p==3){\n      if(b[1]==0||a[1][b[1]-1]<a[0][b[0]-1]){\n\tb[0]--;\n\ta[1][b[1]]=a[0][b[0]];\n\tb[1]++;\n\tp=0;\n      }else{\n\tb[1]--;\n\ta[0][b[0]]=a[1][b[1]];\n\tb[0]++;\t\n\tp=2;\n      }\n    }\n  }\n  return i;\n}\nint main(){\n  int i,j;\n  int a[3][15],b[3],c[3][15],d[3],n;\n  int mn;\n  while(cin>>n>>m&&n+m){\n    memset(b,0,sizeof(b));\n    for(i=0;i<3;i++){\n      cin>>n;\n      for(j=0;j<n;j++){\n\tint p;\n\tcin>>p;\n\ta[i][b[i]]=p;\n\tb[i]++;\n      }\n    }\n    memcpy(c,a,sizeof(c));\n    memcpy(d,b,sizeof(d));\n    if(0){\n    }else if(A(0)<A(1)&&A(1)>A(2)){\n      mn=fn(c,d,2);\n      memcpy(c,a,sizeof(c));\n      memcpy(d,b,sizeof(d));\n      mn=min(mn,fn(c,d,3));\n    }else if(A(0)>A(1)&&A(1)<A(2)){\n      mn=fn(c,d,0);\n      memcpy(c,a,sizeof(c));\n      memcpy(d,b,sizeof(d));\n      mn=min(mn,fn(c,d,1));\n    }else if(A(0)<A(1)&&A(1)<A(2)){\n      mn=fn(c,d,1);\n      memcpy(c,a,sizeof(c));\n      memcpy(d,b,sizeof(d));\n      mn=min(mn,fn(c,d,2));\n    }else if(A(0)>A(1)&&A(1)>A(2)){\n      mn=fn(c,d,0);\n      memcpy(c,a,sizeof(c));\n      memcpy(d,b,sizeof(d));\n      mn=min(mn,fn(c,d,3));\n    }\n    if(mn==m+1)\n      cout<<-1<<endl;\n    else\n      cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 3;\nconst int INF = 15000001;\n\nclass S{\npublic:\n  int t[N], cost;\n  S(int a = 0, int b = 0, int c = 0, int cost = 0) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n\nint n, m;\n//int ans;\n\nint calc(S s, int pres, int pret){\n  //if(ans <= s.cost) return INF;\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  if(s.cost >= m) return INF;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<N;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(i == pret && j == pres) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          //ans = min(ans, res);\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint solve(S s){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<N;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          //ans = min(ans, res);\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[N];\n    for(int i=0;i<N;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    //ans = INF;\n    cout << solve(S(data[0], data[1], data[2], 0)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nint n, m;\nint put(int mask, int x, int i) {\n    return (mask & ~(0b11 << 2 * x)) | (i << 2 * x);\n}\nint where(int mask, int x) {\n    return (mask >> 2 * x) & 0b11;\n}\nint highest(int mask, int i) {\n    int ans = 0;\n    for(int x = 1; x <= n; x++) {\n        ans = where(mask, x) == i ? x : ans;\n    }\n    return ans;\n}\nbool can(int mask, int from, int to) {\n    return highest(mask, from) > highest(mask, to);\n}\nint shift(int mask, int from, int to) {\n    return put(mask, highest(mask, from), to);\n}\nbool win(int mask) {\n    return (highest(mask, 1) == n and not highest(mask, 2) and not highest(mask, 3))\n        or (highest(mask, 3) == n and not highest(mask, 2) and not highest(mask, 1));\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    while(cin >> n >> m and n and m) {\n        int start = 0;\n        for(int i = 1; i <= 3; i++) {\n            int sz;\n            cin >> sz;\n            while(sz--) {\n                int x;\n                cin >> x;\n                start = put(start, x, i);\n            }\n        }\n        queue<int> q({start});\n        map<int, int> d = {{start, 0}};\n        int ans = -1;\n        while(not q.empty()) {\n            int mask = q.front(); q.pop();\n            if(win(mask)) {\n                ans = d[mask] < m ? d[mask] : -1;\n                break;\n            }\n            for(int i = 1; i <= 2; i++) {\n                if(can(mask, i, i + 1) and not d.count(shift(mask, i, i + 1))) {\n                    d[shift(mask, i, i + 1)] = d[mask] + 1;\n                    q.push(shift(mask, i, i + 1));\n                }\n                if(can(mask, i + 1, i) and not d.count(shift(mask, i + 1, i))) {\n                    d[shift(mask, i + 1, i)] = d[mask] + 1;\n                    q.push(shift(mask, i + 1, i));\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n\nint n, m, cnt, a[16], b[16];\nbool flag;\n\nvoid move(int num, int dest, int* a);\n\nint main() {\n\t\n\twhile (1) {\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0)break;\n\n\t\tint numt, tmp;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcin >> numt;\n\t\t\tfor (int j = 0; j < numt; j++) {\n\t\t\t\tcin >> tmp;\n\t\t\t\ta[tmp] = i;\n\t\t\t\tb[tmp] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans1, ans2;\n\n\t\tcnt = 0;\n\t\tflag = true;\n\t\tfor (int num = 1; num <= n; num++) {\n\t\t\tmove(num, 2, a);\n\t\t}\n\t\tif (flag == true) {\n\t\t\tans1 = cnt;\n\t\t} else {\n\t\t\tans1 = -1;\n\t\t}\n\n\t\tcnt = 0;\n\t\tflag = true;\n\t\tfor (int num = 1; num <= n; num++) {\n\t\t\tmove(num, 0, b);\n\t\t}\n\t\tif (flag == true) {\n\t\t\tans2 = cnt;\n\t\t} else {\n\t\t\tans2 = -1;\n\t\t}\n\n\n\t\tint ans;\n\t\tif (ans1 == -1) {\n\t\t\tans = ans2;\n\t\t} else if(ans2 == -1){\n\t\t\tans = ans1;\n\t\t} else {\n\t\t\tans = min(ans1, ans2);\n\t\t}\n\t\tcout << ans1 << \" \" << ans2 << endl;\n\t\tcout << ans << endl << endl;\n\t}\n\n\n\treturn 0;\n}\n\nvoid move(int num, int dest, int* a) {\n\t\n\tif (cnt > m || flag == false) {\n\t\tflag = false;\n\t\treturn;\n\t}\n\n\tint dist = abs(dest - a[num]);\n\tif (dist == 0) {\n\t\treturn;\n\t} else if (dist == 1) {\n\t\tif (num == n) {\n\t\t\tcnt += 1;\n\t\t\ta[num] = dest;\n\t\t} else {\n\t\t\tint i = 1;\n\t\t\twhile (num + i <= n) {\n\t\t\t\tmove(num + i, 3 - dest - a[num], a);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tcnt += 1;\n\t\t\ta[num] = dest;\n\t\t}\n\t} else if (dist == 2) {\n\t\tif (num == n) {\n\t\t\tcnt += 2;\n\t\t\ta[num] = dest;\n\t\t} else {\n\t\t\tmove(num, 1, a);\n\t\t\tmove(num, dest, a);\n\t\t}\n\t}\n\n\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint a[25];\nint d[15000010];\n\nvoid debug(int pos, int n){\n\trep(i, n){\n\t\tcout << pos % 3 << \" \";\n\t\tpos /= 3;\n\t}\n\tcout << endl;\n}\n\nint main(){\n\ta[0] = 1;\n\trep(i, 20) a[i + 1] = a[i] * 3;\n\n\tint n, m;\n\twhile (cin >> n >> m, n | m){\n\t\tint start = 0;\n\t\trep(i, 3){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\twhile (k--){\n\t\t\t\tint x;\n\t\t\t\tcin >> x;\n\t\t\t\tstart += i*a[x - 1];\n\t\t\t}\n\t\t}\n\t\tint goal = a[n] - 1;\n\n\t\tMEMSET(d, -1);\n\t\td[start] = 0;\n\t\tqueue<P> q;\n\t\tif (start == 0 || start == goal) goto OK;\n\t\tq.push(make_pair(start, 0));\n\t\twhile (!q.empty()){\n\t\t\tP p = q.front();\n\t\t\tq.pop();\n\n\t\t\tint pos = p.first;\n\t\t\tint dist = p.second;\n\n\t\t\tint tmp = pos;\n\t\t\tbool ng[3] = {};\n\t\t\tfor (int i = n - 1; i >= 0; --i){\n\t\t\t\tint x = tmp / a[i];\n\t\t\t\ttmp = tmp % a[i];\n\t\t\t\tif (ng[x]) continue;\n\t\t\t\tng[x] = 1;\n\t\t\t\tfor (int j = max(x - 1, 0); j <= min(x + 1, 2); ++j){\n\t\t\t\t\tif (ng[j]) continue;\n\t\t\t\t\tint nxt = pos + ((j - x)*a[i]);\n\t\t\t\t\tif (d[nxt] >= 0) continue;\n\t\t\t\t\t//debug(nxt, n);\n\t\t\t\t\td[nxt] = dist + 1;\n\t\t\t\t\tif (nxt == 0 || nxt == goal) goto OK;\n\t\t\t\t\tif(dist + 1 < m) q.push(make_pair(nxt, dist+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\tcontinue;\n\tOK:;\n\t\tcout << max(d[0], d[goal]) << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n//http://climpet.hatenablog.com/entry/2013/01/01/225142#f5を参考\nint main(int argc, char *argv[])\n{\n  int pow3[16],c[16];\n  int n,m,i,j,k,d,x,y,p;\n\n  pow3[0] = 1;\n  for(i = 1;i <=15;i++){\n    pow3[i] = pow3[i-1]*3;//i枚#0から#2または#2から#0へ移動するのに必要なステップ数\n}\n\n  while(scanf(\"%d%d\",&n,&m),n){\n    for(i = 0;i < 3;--i){\n      for(scanf(\"%d\",&j);j > 0;--j){\n\tscanf(\"%d\",&k);\n\tc[n-k] = i;/*番号付け替え,ハノイの塔に変換。大きいコップを小さい円盤にする*/\n      }\n    }\n    p = 0;//全ての円盤が0の位置にあると仮定する\n    x = 0;\n    for(i = n-1;i > 0;i--){//\n      d = abs(p -c[i]);//移動させる円盤の距離を求める。\n      /*n = 3の時、i = 2で円盤2を#1に移動させるには円盤1と円盤0を#2に移動させる*/\n      x += pow3[i]*d;\n      if(d == 1){\n\tp = 2-p;/*反対側に移動,距離がd = 1ならば0~i-1番の円盤を反対側に移動する。*/\n      }\n    }\n    y = pow3[n] -1 -x;\n    if(x > y){\n      x = y;\n    }\n    printf(\"%d\\n\",x > m?-1:x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,P> pip;\nconst int inf=(1<<31)-1;\n\nint n,m;\nvvi date;\n\nint func(int x){\n\tint an=3;\n\tfor(int i=0;i<x-1;i++) an*=3;\n\treturn an;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(!n&&!m) break;\n\t\tint lef=0,rig=0;\n\t\tdate=vvi(3);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint tn;\n\t\t\tcin>>tn;\n\t\t\tfor(int j=0;j<tn;j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tdate[i].push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tfor(int  i=0;i<3;i+=2){\n\t\t\tint now=i;\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tint tmp1;\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tbool q=1;\n\t\t\t\t\tfor(int r=0;r<date[k].size();r++){\n\t\t\t\t\t\tif(j==date[k][r]){\n\t\t\t\t\t\t\ttmp1=k;\n\t\t\t\t\t\t\tq=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j>date[k][r]) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!q) break;\n\t\t\t\t}\n\t\t\t\tint t=abs(now-tmp1);\n/*\t\t\t\tif(i==0) cout<<'L'<<now<<' '<<tmp1<<endl;\n\t\t\t\telse cout<<'R'<<now<<' '<<tmp1<<endl;\n\t\t\t\tcout<<t<<endl;*/\n\t\t\t\tif(!t) continue;\n\t\t\t\tif(i==0){\n\t\t\t\t\tlef+=t*func(n-j);\n\t\t\t\t\tif(lef>m) break;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\trig+=t*func(n-j);\n\t\t\t\t\tif(rig>m) break;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<t;k++){\n\t\t\t\t\tif(now==0) now=2;\n\t\t\t\t\telse now=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout<<lef<<' '<<rig<<endl;\n\t\tint ans=min(lef,rig);\n\t\tif(ans>m) cout<<-1<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<vector>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,m,ans; vector<int> cup[3];\nvoid move(int k,int t){\n\tif(k>n||ans>m)return;\n\tint pk,o;\n\trep(i,3)if(!cup[i].empty()&&cup[i][cup[i].size()-1]==k)pk=i;\n\trep(i,3)if(i!=pk&&i!=t)o=i;\n\tcup[pk].pop_back();\n\tif(pk==t){\n\t\tmove(k+1,t);\n\t\tcup[pk].push_back(k);\n\t\treturn;\n\t}\n\tans++;\n\tif(abs(pk-t)==1){\n\t\tmove(k+1,o);\n\t\tcup[t].push_back(k);\n\t}else{\n\t\tmove(k+1,t);move(k+1,o);\n\t\tcup[o].push_back(k);\n\t}\n\tmove(k,t);\n}\nint main(){\n\twhile(cin>>n>>m,n){\n\t\trep(i,3)cup[i].clear();\n\t\trep(i,3){\n\t\t\tint k,l;cin>>k;\n\t\t\trep(j,k)cin>>l,cup[i].push_back(l);\n\t\t\treverse(cup[i].begin(),cup[i].end());\n\t\t}\n\t\tans=0;move(1,0); int pw=1;rep(i,n)pw*=3;\n\t\tcout<<(ans>m?-1:min(ans,pw-1-ans))<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint mypow(int x,int n){\n\tint res = 1;\n\twhile(n>0){\t\t\n\t\tif(n & 1) res = res*x;\n\t\tx = x * x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\n\nint conv(vector<int>& sets,int n){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * mypow(3,j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,int n,vector<int>& root,bool* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root,n)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n-1;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(!visited[(next = conv(tmp,n))]){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n-1;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(!visited[(next = conv(tmp,n))]){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tbool* visited = new bool[mypow(3,n)]();\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,n,sets,visited));\n\t\tdelete[] visited;\n\t}\n\t//printf(\"%d %d %d\\n\",mypow(3,0),mypow(3,1),mypow(3,2));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tstring in = \"000000000000000\";\n\t\trep(i, 3) {\n\t\t\tint len; scanf(\"%d\", &len);\n\t\t\trep(j, len) {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tin[--a] = i + '0';\n\t\t\t}\n\t\t}\n\t\tunordered_map<string, int>mp;\n\t\tqueue<string>que;\n\t\tmp[in] = 1;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tstring u = que.front(); que.pop();\n\t\t\tif (count(u.begin(), u.begin() + n, '0') == n || \n\t\t\t\tcount(u.begin(), u.begin() + n, '2') == n) {\n\t\t\t\tprintf(\"%d\\n\", mp[u] - 1);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (mp[u] > m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tint fi = (int)u.rfind(i + '0', n - 1),\n\t\t\t\t\tfj = (int)u.rfind(j + '0', n - 1);\n\t\t\t\tif (fi == -1 || fi < fj)continue;\n\t\t\t\tstring v = u;\n\t\t\t\tv[fi] = j + '0';\n\t\t\t\tif (!mp[v]) {\n\t\t\t\t\tmp[v] = mp[u] + 1;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <functional>\n#include <array>\n#include <stack>\n#include <queue>\n#include <chrono>\n#include <numeric>\n#include <memory.h>\n#include <map>\n#include <math.h>\n\n\n#pragma warning(disable:4996)\n#define REP(i,n) for(int i = 0 ; i < n ; ++i)\ntypedef long long Int;\nconst double PI = 3.141592653589793238;\nconst Int INF = 999999999999;\nusing namespace std;\n\nint dx[4] = { 0, -1, 0, 1 };\nint dy[4] = { 1, 0, -1, 0 };\n\nstruct state{\n\tvector<int> A, B, C;\n\tint step = 0;\n};\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n&&m){\n\t\tqueue<state> que;\n\n\t\tstate s;\n\t\tREP(i,3){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tREP(j,k){\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tif (i ==0)\n\t\t\t\t\ts.A.push_back(a);\n\t\t\t\tif (i == 1)\n\t\t\t\t\ts.B.push_back(a);\n\t\t\t\tif (i == 2)\n\t\t\t\t\ts.C.push_back(a);\n\t\t\t}\n\t\t}\n\n\t\tque.push(s);\n\t\twhile (!que.empty()){\n\t\t\tstate now = que.front();\n\t\t\tque.pop();\n\n\t\t\tif ((now.B.empty() && now.C.empty()) || (now.B.empty() && now.A.empty())){\n\t\t\t\tcout << now.step << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (now.step > m){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!now.A.empty() && (now.B.empty() || (now.A.back() > now.B.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tnext.B.push_back(next.A.back());\n\t\t\t\tnext.A.pop_back();\n\t\t\t\t++next.step;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t\tif (!now.B.empty() && (now.A.empty() || (now.A.back() < now.B.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tnext.A.push_back(next.B.back());\n\t\t\t\tnext.B.pop_back();\n\t\t\t\t++next.step;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t\tif (!now.B.empty() && (now.C.empty() || (now.B.back() > now.C.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tnext.C.push_back(next.B.back());\n\t\t\t\tnext.B.pop_back();\n\t\t\t\t++next.step;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t\tif (!now.C.empty() && (now.B.empty() || (now.B.back() < now.C.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tnext.B.push_back(next.C.back());\n\t\t\t\tnext.C.pop_back();\n\t\t\t\t++next.step;\n\t\t\t\tque.push(next);\n\t\t\t}\n\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include <stack>\nusing namespace std;\n\nint main()\n{\n\tstack<int>a,b,c;\n\twhile(1)\n\t{\n\t\t\n\t\tint count=0,n,m,check;\n\t\tscanf(\"%d %d\",&n,&m);\n\n\t\tif(n==0 && m==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\n\t\tint A,B,C,\n\t\t\tkari;\n\t\t\n\t\t/*エラー対策*/\n\t\ta.push(0);\n\t\tb.push(0);\n\t\tc.push(0);\n\n\t\tscanf(\"%d\",&A);\n\t\tfor(int i=0;i<A;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\ta.push(kari);\n\t\t}\n\n\t\tscanf(\"%d\",&B);\n\t\tfor(int i=0;i<B;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\tb.push(kari);\n\t\t}\n\t\n\t\tscanf(\"%d\",&C);\n\t\tfor(int i=0;i<C;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\tc.push(kari);\n\t\t}\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif(b.top()==0 && c.top()==0)\n\t\t\t\tbreak;\n\t\t\tif(a.top()<b.top() && a.top()<c.top()){\n\t\t\t\tkari=b.top();\n\t\t\t\ta.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b.top()<c.top() ){\n\t\t\t\tkari=c.top();\n\t\t\t\tb.push(kari);\n\t\t\t\tc.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b.top()<a.top()){\n\t\t\t\tkari=a.top();\n\t\t\t\tb.push(kari);\n\t\t\t\ta.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(c.top()<b.top() && a.top()!=b.top()-1){\n\t\t\t\tkari=b.top();\n\t\t\t\tc.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t}\n\t\t\telse{\n\t\t\t\tkari=b.top();\n\t\t\t\ta.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(count<m || count==m) printf(\"%d\\n\",count);\n\t\telse printf(\"%d\\n\",-1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#define S(n) (int)(pow(3,x-(n)+1)/2)\nusing namespace std;\n\nint main(){\n\tint h[17],a[17],c[17],x,i,n,m,t;\n\twhile(cin>>x>>n,n){\n\t\tfor(i=0;i<3;i++)for(cin>>m;m--;h[t]=i)cin>>t;\n\t\ta[x]=h[x];c[x]=2-h[x];\n\t\tfor(i=x;i>1;i--){\n\t\t\tif(h[i-1]==0){\n\t\t\t\ta[i-1]=a[i];\n\t\t\t\tc[i-1]=c[i]+2+4*S(i);\n\t\t\t}else if(h[i-1]==1){\n\t\t\t\ta[i-1]=c[i]+1+2*S(i);\n\t\t\t\tc[i-1]=a[i]+1+2*S(i);\n\t\t\t}else{\n\t\t\t\ta[i-1]=a[i]+2+4*S(i);\n\t\t\t\tc[i-1]=c[i];\n\t\t\t}\n\t\t}\n\t\tt=min(a[1],c[1]);\n\t\tcout<<(t>n?-1:t)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define YES cout<<\"YES\"<<endl;\n#define NO cout<<\"NO\"<<endl;\n#define Yes cout<<\"Yes\"<<endl;\n#define No cout<<\"No\"<<endl;\nusing namespace std;\nint dp[14349000];\nconst int INF=1e9+7;\n\nint sti(string s){\n  int res=0;int k=1;\n  for(int i=0;i<s.size();i++){\n    res+=(s[i]-'0')*k;\n    k*=3;\n  }\n  return res;\n}\nint pw(int a,int b){\n  int res=1;\n  while(b--)res*=a;\n  return res;\n}\n\nsigned main(){\n  std::vector<int> ans;\n  while(true){\n    int N,M;cin>>N>>M;if(N==0&&M==0)break;\n    string s(N,'0');\n    int a;cin>>a;\n    for(int i=0;i<a;i++){int b;cin>>b;s[b-1]='0';}\n    cin>>a;\n    for(int i=0;i<a;i++){int b;cin>>b;s[b-1]='1';}\n    cin>>a;\n    for(int i=0;i<a;i++){int b;cin>>b;s[b-1]='2';}\n    for(int i=0;i<14349000;i++)dp[i]=INF;\n    dp[sti(s)]=0;\n    //cout<<dp[0]<<endl;\n    //cout<<s<<\" \"<<sti(s)<<endl;\n    queue<string> que;que.push(s);\n    while(dp[0]==INF&&dp[pw(3,N)-1]==INF&&que.size()){\n      int a,b,c;a=b=c=-1;\n      string t=que.front();que.pop();\n      if(dp[sti(t)]>M)break;\n      for(int i=0;i<t.size();i++){\n        if(t[i]=='0')a=i;\n        if(t[i]=='1')b=i;\n        if(t[i]=='2')c=i;\n      }\n      string t1,t2;t1=t2=t;\n      if(a>b)t1[a]='1';\n      if(a<b)t1[b]='0';\n      if(b<c)t2[c]='1';\n      if(b>c)t2[b]='2';\n      if(dp[sti(t1)]>dp[sti(t)]+1){dp[sti(t1)]=dp[sti(t)]+1;que.push(t1);}\n      if(dp[sti(t2)]>dp[sti(t)]+1){dp[sti(t2)]=dp[sti(t)]+1;que.push(t2);}\n    }\n    //for(int i=0;i<27;i++)cout<<dp[i]<<\" \";cout<<endl;\n    if(min(dp[0],dp[pw(3,N)-1])<=M)ans.push_back(min(dp[0],dp[pw(3,N)-1]));\n    else ans.push_back(-1);\n  }\n  for(int i=0;i<ans.size();i++)cout<<ans[i]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing ll = long long;\n\nint mypow(int x, int n) {\n    int res = 1;\n    while(n > 0) {\n        if(n & 1) {\n            res *= x;\n        }\n        x *= x;\n        n >>= 1;\n    }\n    return res;\n}\n\nint calc(vector<int> const& v) {\n    int res = 0;\n    for(int i = 1; i < 3; ++i) {\n        for(int j = 0; j < 15; ++j) {\n            if(v[i] & (1 << j)) {\n                res += i * mypow(3, j);\n            }\n        }\n    }\n    return res;\n}\n\nbool memo[30000000] = {};\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n) {\n        vi s(3);\n        for(int i = 0; i < 3; ++i) {\n            int k; cin >> k;\n            for(int j = 0; j < k; ++j) {\n                int x; cin >> x;\n                s[i] |= (1 << x - 1);\n            }\n        }\n        fill(begin(memo), end(memo), false);\n        memo[calc(s)] = true;\n        queue<pair<vi, int>> que;\n        que.emplace(move(s), 0);\n        int res = -1;\n        while(!que.empty()) {\n            auto now = move(que.front().first);\n            int step = que.front().second;\n            que.pop();\n            if(step > m) {\n                continue;\n            }\n            if(now[0] == (1 << n) - 1 || now[2] == (1 << n) - 1) {\n                res = step;\n                break;\n            }\n            for(int i = 0; i < 3; ++i) {\n                if(now[i] == 0) {\n                    continue;\n                }\n                for(int j = i - 1; j <= i + 1; j += 2) {\n                    if(j < 0 || 3 <= j) {\n                        continue;\n                    }\n                    int xi = (31 - __builtin_clz(now[i]));\n                    if(now[j] == 0 || (31 - __builtin_clz(now[j])) < xi) {\n                        now[j] |= (1 << xi);\n                        now[i] ^= (1 << xi);\n                        if(!memo[calc(now)]) {\n                            memo[calc(now)] = true;\n                            que.emplace(now, step + 1);\n                        }\n                        now[i] |= (1 << xi);\n                        now[j] ^= (1 << xi);\n                    }\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n\nint maxmove(int x){\n  if(x == 0){\n    return 0;\n  }\n  else{\n    return 2 * (maxmove(x - 1) * 3 + 1);\n  }\n}\n\nint main(){\n  while(1){\n    int n,m;\n    scanf(\"%d%d\", &n, &m);\n    if(n == 0 && m == 0){\n      return 0;\n    }\n    stack<int> cups[3];\n    for(int i = 0;i < 3;i++){\n      int k,cup;\n      scanf(\"%d\", &k);\n      for(int j = 0;j < k;j++){\n\tscanf(\"%d\", &cup);\n\tcups[i].push(cup);\n      }\n    }\n    int res = 0, lastto = -1, lastfrom = -1;\n    while(cups[0].size() != n && cups[2].size() != n){\n      bool moved = false;\n      for(int i = 0;i < 3 && !moved;i++){\n\tfor(int j = 0;j < 3 && !moved;j++){\n\t  if(abs(i - j) != 1 || cups[i].empty() || (j == lastfrom && i == lastto))continue;\n\t  if(cups[j].empty() || cups[i].top() > cups[j].top()){\n\t    cups[j].push(cups[i].top());\n\t    cups[i].pop();\n\t    res++;\n\t    lastfrom = i;\n\t    lastto = j;\n\t    moved = true;\n\t  }\n\t}\n      }\n    }\n    res = min(res, maxmove(n) - res);\n    if(res > m){\n      res = -1;\n    }\n    printf(\"%d\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint visited[15000000];\n\nint conv(vector<int>& sets){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<=15;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * (pow(3.0,j)+eps);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,vector<int>& root, int* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tmemset(visited,-1,sizeof(visited));\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,sets,visited));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <tr1/unordered_map>\nusing namespace std;\n\nint n;\n\nint goal = 0;\n\ntypedef int P ;\n\n\n\nP Q[30];\nint m,stat,tim,head,size,i,t,a,j,from,to,next;\ntr1::unordered_map<int,int> done;\n\nint main(){\n\twhile(cin >> n >> m && n){\n\t\tdone.clear();\n\t\tint init = 0;\n\t\tfor(i = 0 ; i < n ; i++) goal |= 2 << (i*2);\n\t\t\n\t\tfor(i = 0 ; i < 3 ; i++){\n\t\t\tt,a; cin >> t;\n\t\t\twhile(t--){cin >> a; a--; init |= (i) << (2*a); }\n\t\t}\n\t\thead = 0 , size = 0;\n\t\tQ[size++] = init;\n\t\tdone[init] = 0;\n\t\t\n\t\twhile(head != size){\n\t\t\tstat = Q[head++];\n\t\t\ttim = done[stat];\n\t\t\tif(tim > m) break;\n\t\t\tif(stat == goal || stat == 0){ cout << tim << endl; goto hoge;}\n\t\t\tint mi[3] = {-1,-1,-1};\n\t\t\tfor(i = n-1 ; i >= 0 ; i--){\n\t\t\t\tint num = stat>>(i*2)&3;\n\t\t\t\tif(mi[num]==-1)mi[num] = i;\n\t\t\t}\n\n\t\t\tfor(from = 0 ; from < 3 ; from++){\n\t\t\t\tfor(to = 0 ; to < 3 ; to++){\n\t\t\t\t\tif ( !( (from == 0 && to == 2) || (from == 2 && to == 0) ) && from != to && mi[from] != -1 && (mi[to] == -1 || mi[from] > mi[to]) ){\n\t\t\t\t\t\tnext = (stat & ~(3<<(2*mi[from]))) | (to<<(2*mi[from]));\n\t\t\t\t\t\tif(!done.count(next))Q[size++] = next , done[next] = tim+1;\n\t\t\t\t\t\thead %= 30;\n\t\t\t\t\t\tsize %= 30;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\thoge:;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    vector<int> pow3(16, 1);\n    for(int i=1; i<=15; ++i)\n        pow3[i] = pow3[i-1] * 3;\n\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > a(3);\n        for(int i=0; i<3; ++i){\n            int b;\n            cin >> b;\n            a[i].resize(b);\n            for(int j=0; j<b; ++j)\n                cin >> a[i][j];\n            a[i].push_back(-1);\n        }\n\n        int ret = INT_MAX;\n        for(int start=0; start<3; start+=2){\n            int prev = start;\n            vector<int> k(3, 0);\n            int cost = 0;\n\n            for(int i=1; i<=n; ++i){\n                int curr;\n                for(int j=0; j<3; ++j){\n                    if(a[j][k[j]] == i){\n                        curr = j;\n                        ++ k[j];\n                    }\n                }\n\n                if(curr == 1){\n                    cost += pow3[n-i];\n                    prev ^= 2;\n                }else if(curr != prev){\n                    cost += 2 * pow3[n-i];\n                }\n            }\n\n            ret = min(ret, cost);\n        }\n\n        if(ret <= m)\n            cout << ret << endl;\n        else\n            cout << -1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,m;\nint cup[4][18]={0},cupn[4];\nint ans=1000000000;\nint san;\nvoid hanoi(int nowm,int cmd){\n\n    /*\n    printf(\"[%d][%d][%d]\\n\",cupn[0],cupn[1],cupn[2]);\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            printf(\"%d\",cup[i][j]);\n        }\n        puts(\"\");\n    }\n    */\n\n\n    if(m<nowm)\n        goto P;\n    else if(cupn[0]==n||cupn[2]==n){\n        ans=min(ans,nowm);\n    }\n    if(cmd!=1&&cmd!=2&&cupn[0]!=0){\n        if(cup[0][cupn[0]]>cup[1][cupn[1]]){\n            cup[1][cupn[1]+1]=cup[0][cupn[0]],cup[0][cupn[0]]=0;\n            cupn[0]--,cupn[1]++;\n            hanoi(nowm+1,1);\n            cup[0][cupn[0]+1]=cup[1][cupn[1]],cup[1][cupn[1]]=0;\n            cupn[1]--,cupn[0]++;\n        }\n    }\n    if(cmd!=1&&cmd!=2&&cupn[1]!=0){\n        if(cup[0][cupn[0]]<cup[1][cupn[1]]){\n            cup[0][cupn[0]+1]=cup[1][cupn[1]],cup[1][cupn[1]]=0;\n            cupn[1]--,cupn[0]++;\n            hanoi(nowm+1,2);\n            cup[1][cupn[1]+1]=cup[0][cupn[0]],cup[0][cupn[0]]=0;\n            cupn[0]--,cupn[1]++;\n        }\n    }\n    if(cmd!=3&&cmd!=4&&cupn[1]!=0){\n        if(cup[1][cupn[1]]>cup[2][cupn[2]]){\n            cup[2][cupn[2]+1]=cup[1][cupn[1]],cup[1][cupn[1]]=0;\n            cupn[1]--,cupn[2]++;\n            hanoi(nowm+1,3);\n            cup[1][cupn[1]+1]=cup[2][cupn[2]],cup[2][cupn[2]]=0;\n            cupn[1]++,cupn[2]--;\n        }\n    }\n    if(cmd!=3&&cmd!=4&&cupn[2]!=0){\n        if(cup[1][cupn[1]]<cup[2][cupn[2]]){\n            cup[1][cupn[1]+1]=cup[2][cupn[2]],cup[2][cupn[2]]=0;\n            cupn[1]++,cupn[2]--;\n            hanoi(nowm+1,4);\n            cup[2][cupn[2]+1]=cup[1][cupn[1]],cup[1][cupn[1]]=0;\n            cupn[1]--,cupn[2]++;\n        }\n    }\nP:\n    printf(\"\");\n}\nint main(){\n    while(1){\n        for(int i=0;i<3;i++){\n            for(int j=0;j<18;j++)\n                cup[i][j]=0;\n        }\n        ans=1000000000;\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0)\n            break;\n        for(int i=0;i<3;i++){\n            scanf(\"%d\",&cupn[i]);\n            for(int j=1;j<=cupn[i];j++)\n                scanf(\"%d\",&cup[i][j]);\n        }\n        hanoi(0,0);\n        if(ans==1000000000)\n            ans=-1;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n\n#define MAX 16\n#define A 0\n#define B 1\n#define C 2\n#define P_MAX 3\n#define M_MAX 16000000\n\nusing namespace std;\n\ntemplate<typename _T>\n_T &abs(const _T &x){if(x<0)return -x;else return x;}\n\nint cost[3][MAX];\n\nstruct Cups{\n\tCups(){\n\t\tcost = 0;\n\t\tv[0].reserve(MAX);\n\t\tv[1].reserve(MAX);\n\t\tv[2].reserve(MAX);\n\t}\n\tvector<int> v[P_MAX];\n\tint cost;\n};\nostream &operator<<(ostream &os, const vector<int> &v){\n\tfor(unsigned int i = 0; i < v.size(); ++i){\n\t\tos << v[i] << ' ';\n\t}\n\treturn os;\n}\nostream & operator << (ostream &os, const Cups &t){\n\tos << \"A: \" << t.v[0] << \"\\t\\tB: \" << t.v[1] << \"\\t\\tC: \" << t.v[2] << \"\\t\\tCost :\" << t.cost;\n\treturn os;\n}\n\nint BFS(int n, int m, Cups &st){\n\tint ret = M_MAX;\n\tqueue<Cups> q;\n\tq.push( st );\n\n\twhile( !q.empty() ){\n\t\tCups cups;\n\t\tcups = q.front();\n\n\t\tq.pop();\n\n\t\t/* I¹ð */\n\t\tif( cups.v[A].size() == n || cups.v[C].size() == n ){\n\t\t\tret = min(ret, cups.cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif( cups.cost >= ret || cups.cost > m )\n\t\t\tcontinue;\n\n\t\tfor(int i = A; i <= C; ++i){\n\t\t\tint mov_cnt = 1;\n\t\t\tint min_sz = -1;\n\n\t\t\tfor(int j = cups.v[i].size()-1; j >= 1; --j){\n\t\t\t\tif( cups.v[i][j] - cups.v[i][j-1] == 1 ){\n\t\t\t\t\t++mov_cnt;\n\t\t\t\t\tmin_sz = cups.v[i][j-1];\n\t\t\t\t}else{\n\t\t\t\t\tmin_sz = cups.v[i][j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( cups.v[i].size() == 1 )\n\t\t\t\tmin_sz = cups.v[i][ 0 ];\n\n\t\t\tif( min_sz == -1 )\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tfor(int w = 1; w <= mov_cnt; ++w){\n\t\t\t\tfor(int j = A; j <= C; ++j){\n\t\t\t\t\tint d = abs( i - j );\n\t\t\t\t\tif( d == 2 || d == 0 )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tCups t = cups;\n\t\t\t\t\tint end = t.v[j].size() - 1;\n\t\t\t\t\tif( end >= 0 && t.v[j][end] > min_sz )\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t/*cout << \"--------------------------\\n\";\n\t\t\t\t\tcout << t << endl;*/\n\n\t\t\t\t\tt.v[j].insert( t.v[j].end(), t.v[i].end() - w, t.v[i].end() );\n\t\t\t\t\tt.v[i].erase( t.v[i].end() - w, t.v[i].end() );\n\t\t\t\t\tt.cost += cost[ 1 ][ w ];\n\n\t\t\t\t\t//cout << t << endl;\n\n\t\t\t\t\tq.push( t );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcost[1][1] = 1;\n\tcost[2][1] = 2;\n\tfor(int i = 1; i < 3; ++i){\n\t\tfor(int j = 2; j < MAX; ++j){\n\t\t\tif( i == 1 ){\n\t\t\t\tcost[i][j] = 3 * cost[i][j - 1] + 1;\n\t\t\t}else{\n\t\t\t\tcost[i][j] = 2 * cost[1][j];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tint n,m;\n\t\tint ans = 0;\n\t\tCups cups;\n\t\t\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif( n == 0 && m == 0 )\n\t\t\tbreak;\n\n\t\tfor(int i = 0; i < 3; ++i){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tfor(int j = 0; j < t; ++j){\n\t\t\t\tint tt;\n\t\t\t\tscanf(\"%d\", &tt);\n\t\t\t\tcups.v[i].push_back(tt);\n\t\t\t}\n\t\t}\n\t\tans = BFS(n, m, cups);\n\t\t\n\t\tprintf(\"%d\\n\", ans <= m ? ans : -1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> mat;\n\nconst int INF = 1 << 28;\nint n, m;\n\nbool check(mat &v) {\n    if (v[0].size() == n + 1 || v[2].size() == n + 1)\n        return true;\n    return false;\n}\n\nstring stom(mat &v) {\n    string res;\n    res = \"\";\n    for (int i = 0; i < 3; i++) {\n        for (auto j : v[i]) {\n            if (j < 0) continue;\n            res = res + (char)('a' + j);\n        }\n        for (int j = v[i].size(); j <= n; j++) {\n            res = res + '0';\n        }\n    }\n    return res;\n}\n\nset<string> M;\n\nvoid hoge(mat &v, vector<mat> &next) {\n    if (M.find(stom(v)) != M.end()) return;\n    M.insert(stom(v));\n    for (int i = 0; i < 3; i++) {\n        if (v[i].size() > 1) {\n            for (int j = 0; j < 3; j++) {\n                if (i == j || v[i][v[i].size() - 1] < v[j][v[j].size() - 1]) continue;\n                if (i == 0 && j == 2) continue;\n                if (i == 2 && j == 0) continue;\n                v[j].push_back(v[i][v[i].size() - 1]);\n                v[i].erase(v[i].end() - 1);\n                next.push_back(v);\n                v[i].push_back(v[j][v[j].size() - 1]);\n                v[j].erase(v[j].end() - 1);\n            }\n        }\n    }\n}\n\n\nint main() {\n    while (cin >> n >> m, n || m) {\n        mat v(3);\n        M.clear();\n        for (int i = 0; i < 3; i++) {\n            int n_; cin >> n_;\n            v[i].push_back(-1);\n            for (int j = 0; j < n_; j++) {\n                int x; cin >> x;\n                v[i].push_back(x);\n            }\n        }\n\n        int res = 0;\n        vector<mat> G;\n        G.push_back(v);\n        while (res <= m) {\n            vector<mat> G_(G);\n            G.resize(0);\n            for (auto g : G_) {\n                if (check(g)) {\n                    goto escap;\n                }\n                hoge(g, G);\n            }\n            res++;\n        }\nescap:\n        cout << (res > m ? -1 : res) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<int> cups;\n\nconst int LEFT = 0;\nconst int CENTER = 1;\nconst int RIGHT = 2;\n\nbool isMovement(int deepness, int deepest, int tray) {\n\tint pos = cups[deepness];\n\tint oppositePos = RIGHT - tray;\n\tif (pos == tray)\n\t\treturn true;\n\tfor (int i = deepness+1; i < deepest; i++) {\n\t\tint bigCupPos = cups[deepness];\n\t\tif (bigCupPos == tray) {\n\t\t\treturn false;\n\t\t} else if (pos == oppositePos && bigCupPos != tray) {\n\t\t\treturn false;\n\t\t} else if (pos == CENTER && bigCupPos == CENTER) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint sortCup(int deepness, int deepest, int tray) {\n\tint pos = cups[deepness];\n\tint oppositePos = RIGHT - tray;\n\tint ret = 0;\n\n\tif (isMovement(deepness, deepest, tray) == true) {\n\t\tif (pos == oppositePos) {\n\t\t\tret += 2;\n\t\t} else if (pos == CENTER) {\n\t\t\tret += 1;\n\t\t}\n\t\tcups[deepness] = tray;\n\t\treturn ret;\n\t}\n\n\tif (pos == oppositePos) {\n\t\tfor (int i = deepness+1; i < deepest; i++) {\n\t\t\tret += sortCup(i, deepest, tray);\n\t\t}\n\t\tpos = cups[deepness] = CENTER;\n\t\tret++;\n\t}\n\n\tfor (int i = deepness+1; i < deepest; i++) {\n\t\tret += sortCup(i,  deepest, oppositePos);\n\t}\n\tret++;\n\tcups[deepness] = tray;\n\n\treturn ret;\n}\n\nint main(void) {\n\tint n = 0, m = 0;\n\tvector<int> answers;\n\twhile ((cin >> n >> m) && n != 0 && m != 0) {\n\t\tcups.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcups.push_back(0);\n\t\t}\n\n\t\tint trayCup = 0;\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tcin >> trayCup;\n\t\t\tfor (int i = 0; i < trayCup; i++) {\n\t\t\t\tint tmpCupSize = 0;\n\t\t\t\tcin >> tmpCupSize;\n\t\t\t\tcups[tmpCupSize-1] = j;\n\t\t\t}\n\t\t}\n\t\tint answerLeft = 0;\n\t\tvector<int> tmpCup(cups);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tanswerLeft += sortCup(i, n, LEFT);\n\t\t}\n\t\tcups.swap(tmpCup);\n\t\tint answerRight = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tanswerRight += sortCup(i, n, RIGHT);\n\t\t}\n\t\tint answerMin = min(answerLeft, answerRight);\n\t\tif (answerMin <= m) {\n\t\t\tanswers.push_back(answerMin);\n\t\t} else {\n\t\t\tanswers.push_back(-1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < answers.size(); i++) {\n\t\tcout << answers[i] << endl;\n\t}\n\n\tint i = 0;\n\tcin >> i;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\nusing namespace std;\nset<pair<stack<char>,stack<char> > >hash;\n\nint main()\n{\n  int n,m;\n  for(;cin>>n>>m,n;)\n    {\n      stack<char> table[3];\n      stack<char> finish;\n      for(int i=1;i<=n;i++)\n\t{\n\t  finish.push(i);\n\t}\n      for(int i=0;i<3;i++)\n\t{\n\t  int size;\n\t  cin>>size;\n\t  for(int j=0;j<size;j++)\n\t    {\n\t      int tmp;\n\t      cin>>tmp;\n\t      table[i].push(tmp);\n\t    }\n\t}\n      //stack,step;\n      queue<pair<pair<stack<char>,stack<char> >,pair<stack<char> ,int> > > qu;\n      qu.push(make_pair(make_pair(table[0],table[1]),make_pair(table[2],0)));\n      int ans=-1;\n      while(!qu.empty())\n\t{\n\t  stack<char>a=qu.front().first.first;\n\t  stack<char>b=qu.front().first.second;\n\t  stack<char>c=qu.front().second.first;\n\t  int step=qu.front().second.second;\n\t  qu.pop();\n\n\t  if(a==finish || c==finish)\n\t    {\n\t      ans=step;\n\t      break;\n\t    }\n\n\t  if(hash.find(make_pair(a,c))!=hash.end())\n\t    continue;\n\t  hash.insert(make_pair(a,c));\n\n\t  if(step==m)\n\t    continue;\n\n\t  if(!a.empty())\n\t    {\n\t      if(b.empty()||a.top()>b.top() )\n\t\t{\n\t\t  int tmp=a.top();\n\t\t  a.pop();\n\t\t  b.push(tmp);\n\t\t  if(hash.find(make_pair(a,c))==hash.end())\n\t\t    qu.push(make_pair(make_pair(a,b),make_pair(c,step+1)));\n\t\t  tmp=b.top();\n\t\t  b.pop();\n\t\t  a.push(tmp);\n\t\t}\n\t    }\n\t  if(!b.empty())\n\t    {\n\t      if(a.empty()||a.top()<b.top() )\n\t\t{\n\t\t  int tmp=b.top();\n\t\t  b.pop();\n\t\t  a.push(tmp);\n\t\t  if(hash.find(make_pair(a,c))==hash.end())\n\t\t    qu.push(make_pair(make_pair(a,b),make_pair(c,step+1)));\n\t\t  tmp=a.top();\n\t\t  a.pop();\n\t\t  b.push(tmp);\n\t\t}\n\n\t      if(c.empty()||c.top()<b.top() )\n\t\t{\n\t\t  int tmp=b.top();\n\t\t  b.pop();\n\t\t  c.push(tmp);\n\t\t  if(hash.find(make_pair(a,c))==hash.end())\n\t\t    qu.push(make_pair(make_pair(a,b),make_pair(c,step+1)));\n\t\t  tmp=c.top();\n\t\t  c.pop();\n\t\t  b.push(tmp);\n\t\t}\n\n\t    }\n\t  if(!c.empty())\n\t    {\n\t      if(b.empty()||b.top()<c.top() )\n\t\t{\n\t\t  int tmp=c.top();\n\t\t  c.pop();\n\t\t  b.push(tmp);\n\t\t  if(hash.find(make_pair(a,c))==hash.end())\n\t\t    qu.push(make_pair(make_pair(a,b),make_pair(c,step+1)));\n\t\t  tmp=b.top();\n\t\t  b.pop();\n\t\t  c.push(tmp);\n\t\t}\n\n\t    }\n\n\n\n\t}\n      cout<<ans<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\nconst int INF = 10000000;\n\nmap<vector<set<int> >,int> dpp;\n\nvoid dfs(vector<set<int> > sit,int n,int cnt,int m){\n\tif(dpp.find(sit) != dpp.end()){\n\t\tif(dpp[sit] <= cnt){\n\t\t\treturn;\n\t\t}\n\t\telse{\n\t\t\tdpp[sit] = cnt;\n\t\t}\n\t}\n\telse{\n\t\tdpp[sit] = cnt;\n\t}\n\n\tif(cnt >= m)\n\t\treturn;\n\n\tif((sit[0].size() == 0 && sit[1].size() == 0) || (sit[1].size() == 0 && sit[2].size() == 0)){\n\t\treturn;\n\t}\n\n\t// A->B\n\tvector<set<int> > tmp = sit;\n\tif(sit[0].size() != 0){\n\t\tset<int>::reverse_iterator it = sit[0].rbegin();\n\t\tint cont = *it;\n\t\tif(sit[1].size()==0 || *(sit[1].rbegin()) < cont){\n\t\t\tsit[0].erase(*it);\n\t\t\tsit[1].insert(cont);\n\t\t\tdfs(sit,n,cnt+1,m);\n\t\t}\n\t}\n\t// B->A\n\tsit = tmp;\n\tif(sit[1].size() != 0){\n\t\tset<int>::reverse_iterator it = sit[1].rbegin();\n\t\tint cont = *it;\n\t\tif(sit[0].size() == 0 || *(sit[0].rbegin()) < cont){\n\t\t\tsit[1].erase(*it);\n\t\t\tsit[0].insert(cont);\n\t\t\tdfs(sit,n,cnt+1,m);\n\t\t}\n\t}\n\t// B->C\n\tsit = tmp;\n\tif(sit[1].size() != 0){\n\t\tset<int>::reverse_iterator it = sit[1].rbegin();\n\t\tint cont = *it;\n\t\tif(sit[2].size() == 0 || *(sit[2].rbegin()) < cont){\n\t\t\tsit[1].erase(*it);\n\t\t\tsit[2].insert(cont);\n\t\t\tdfs(sit,n,cnt+1,m);\n\t\t}\n\t}\n\t// C->B\n\tsit = tmp;\n\tif(sit[2].size() != 0){\n\t\tset<int>::reverse_iterator it = sit[2].rbegin();\n\t\tint cont = *it;\n\t\tif(sit[1].size() == 0 || *(sit[1].rbegin()) < cont){\n\t\t\tsit[2].erase(*it);\n\t\t\tsit[1].insert(cont);\n\t\t\tdfs(sit,n,cnt+1,m);\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(1){\n\t\tdpp.clear();\n\t\tint n;\n\t\tint m;\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tvector<set<int> > tray;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tset<int> s;\n\t\t\tint num;\n\t\t\tcin >> num;\n\t\t\tfor(int j = 0; j < num; j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\ts.insert(tmp);\n\t\t\t}\n\t\t\ttray.push_back(s);\n\t\t}\n\n\t\tdfs(tray,n,0,m);\n\n\t\tvector<set<int> > fin[3];\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tvector<set<int> > vsi;\n\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\tset<int> si;\n\t\t\t\tif(i == j){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tsi.insert(k+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvsi.push_back(si);\n\t\t\t}\n\t\t\tfin[i] = vsi;\n\t\t}\n\n\t\tint minWalk = 20000000;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tif(i == 1)\n\t\t\t\tcontinue;\n\t\t\tif(dpp.find(fin[i]) != dpp.end()){\n\t\t\t\tminWalk = min(minWalk,dpp[fin[i]]);\n\t\t\t}\n\t\t}\n\t\tif(minWalk == 20000000){\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse\n\t\t\tcout << minWalk << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint calc(vector<int> cup, int m)\n{\n    int cnt = 0;\n    while (1) {\n        int i = cnt%2, j = i+1;\n        int p = 1;\n        while (p <= max(cup[i], cup[j])) p <<= 1;\n        p >>= 1;\n        if (!p) break;\n        cup[i] ^= p;\n        cup[j] ^= p;\n        cnt++;\n        if (cnt > m) return cnt;\n    }\n\n    return cnt;\n}\n\nint main()\n{\n    while (1) {\n        int n, m; cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        vector<int> cup(3);\n        loop (3, i) {\n            int c; cin >> c;\n            while (c--) {\n                int v; cin >> v;\n                cup[i] |= 1 << v+1;\n            }\n        }\n        int ans = calc(cup, m);\n        swap(cup[0], cup[2]);\n        ans = min(ans, calc(cup, m));\n        cout << (ans <= m ? ans : -1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<cstdio>\n#include<algorithm>\n#define rep(i,a) for(int i=0;i<(a);++i)\n\nint n, m;\nint S[3];\n\nint toC(int a, int b, int c) {\n\tif (!a && !b)return 0;\n\tif (c & 1)return toC(a >> 1, b >> 1, c >> 1);\n\tif (b & 1)return toC(c >> 1, b >> 1, a >> 1) + toC((a | b | c) >> 1, 0, 0) + 1;\n\tif (a & 1)return toC(a >> 1, b >> 1, c >> 1) + 2 * toC((a | b | c) >> 1, 0, 0) + 2;\n}\n\nint main(){\n\twhile (scanf(\"%d%d\", &n, &m), n | m){\n\t\trep(i, 3)S[i] = 0;\n\t\trep(t, 3){\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\trep(i, c){\n\t\t\t\tint a;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tS[t] |= 1 << a - 1;\n\t\t\t}\n\t\t}\n\t\tint ans = std::min(toC(S[0], S[1], S[2]), toC(S[2], S[1], S[0]));\n\t\tprintf(\"%d\\n\", ans <= m ? ans : -1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nconst int MAX=15000000;\nint cost[MAX];\nint three[15];\nint n,m;\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  three[0]=1;\n  FOR(i,1,15)three[i]=three[i-1]*3;\n  while(cin>>n>>m,n||m){\n    int mask=0;\n    FOR(i,0,3){\n    int x;cin>>x;\n    FOR(j,0,x){\n      int a;cin>>a;\n      a--;\n      mask+=i*three[a];\n    }\n  }\n  int all=0;\n  FOR(i,0,n)all+=2*three[i];\n  FOR(i,0,all+1)cost[i]=2e9;\n  cost[mask]=0;\n  //cout<<mask<<endl;\n  queue<int> que;\n  que.push(mask);\n  bool next=false;\n  while(!que.empty()){\n    int now=que.front();que.pop();\n    int mx[3];\n    FOR(i,0,3)mx[i]=-1;\n    int nownow=now;\n    FOR(i,0,n){\n      mx[nownow%3]=i;\n      nownow/=3;\n    }\n    //cout<<now<<\" \"<<mx[0]<<\" \"<<mx[1]<< \" \"<<mx[2]<<endl;\n    if(now==0||now==all){\n      if(cost[now]<=m)cout<<cost[now]<<endl;\n      else cout<<-1<<endl;\n      next=true;\n      break;\n    }\n    //0->1\n    if(mx[0]>mx[1]){\n      int mask2=now-0*three[mx[0]]+1*three[mx[0]];\n      if(cost[mask2]>cost[now]+1){\n        cost[mask2]=cost[now]+1;\n        que.push(mask2);\n      }\n    }\n    //1->0\n    if(mx[1]>mx[0]){\n      int mask2=now-1*three[mx[1]]+0*three[mx[1]];\n      if(cost[mask2]>cost[now]+1){\n        cost[mask2]=cost[now]+1;\n        que.push(mask2);\n      }\n    }\n    //1->2\n    if(mx[1]>mx[2]){\n      int mask2=now-1*three[mx[1]]+2*three[mx[1]];\n      if(cost[mask2]>cost[now]+1){\n        cost[mask2]=cost[now]+1;\n        que.push(mask2);\n      }\n    }\n    //2->1\n    if(mx[2]>mx[1]){\n      int mask2=now-2*three[mx[2]]+1*three[mx[2]];\n      if(cost[mask2]>cost[now]+1){\n        cost[mask2]=cost[now]+1;\n        que.push(mask2);\n      }\n    }\n  }\n  if(!next)cout<<-1<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P) \n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\nint n, m, c, a;\n\nint memo[15000000];\n\nint encode(vector<vint> state) {\n    int res = 0;\n    vint num(n, 0);\n    for (int i = 0; i < state.size(); ++i) {\n        for (int j = 0; j < state[i].size(); ++j) {\n            int a = state[i][j];\n            num[a] = i;\n        }\n    }\n    for (int i = n-1; i >= 0; --i) {\n        res += num[i];\n        if (i != 0) res *= 3;\n    }\n//    COUT(state);\n//    COUT(num);\n//    COUT(res);\n    return res;\n}\n\nvector<vint> decode(int num) {\n    vector<vint> res(3);\n    for (int i = 0; i < n; ++i) {\n        int a = num % 3;\n        res[a].PB(i);\n        num /= 3;\n    }\n    return res;\n}\n\nint main() {\n    while (cin >> n >> m) {\n        if (n == 0) break;\n        \n        memset(memo, -1, sizeof(memo));\n        vector<vint> start(3);\n        for (int i = 0; i < 3; ++i) {\n            vint tmp;\n            cin >> a;\n            for (int j = 0; j < a; ++j) { cin >> c; tmp.PB(c-1); }\n            start[i] = tmp;\n        }\n        \n        int es = encode(start);\n        memo[es] = 0;\n        queue<int> que;\n        que.push(es);\n        \n//        COUT(start);\n//        COUT(es);\n//        COUT(decode(es));\n        \n        int res = m+1;\n        while (!que.empty()) {\n            int int_now = que.front(); que.pop();\n            vector<vint> now = decode(int_now);\n            \n            //COUT(now); COUT(dist[now]);\n            \n            if (now[1].empty() && now[2].empty()) { chmin(res, memo[int_now]); break; }\n            if (now[0].empty() && now[1].empty()) { chmin(res, memo[int_now]); break; }\n            \n            if (memo[int_now] == m) continue;\n            \n            // A to B\n            if (!now[0].empty()) {\n                bool ok = true;\n                if (!now[1].empty()) if (now[0].back() <= now[1].back()) ok = false;\n                if (ok) {\n                    vector<vint> next = now;\n                    next[1].push_back(now[0].back());\n                    next[0].pop_back();\n                    int en = encode(next);\n                    if (memo[en] == -1) {\n                        memo[en] = memo[int_now] + 1;\n                        que.push(en);\n                    }\n                }\n            }\n            \n            if (!now[1].empty()) {\n                bool ok = true;\n                if (!now[0].empty()) if (now[1].back() <= now[0].back()) ok = false;\n                if (ok) {\n                    vector<vint> next = now;\n                    next[0].push_back(now[1].back());\n                    next[1].pop_back();\n                    int en = encode(next);\n                    if (memo[en] == -1) {\n                        memo[en] = memo[int_now] + 1;\n                        que.push(en);\n                    }\n                }\n            }\n                \n            if (!now[1].empty()) {\n                bool ok = true;\n                if (!now[2].empty()) if (now[1].back() <= now[2].back()) ok = false;\n                if (ok) {\n                    vector<vint> next = now;\n                    next[2].push_back(now[1].back());\n                    next[1].pop_back();\n                    int en = encode(next);\n                    if (memo[en] == -1) {\n                        memo[en] = memo[int_now] + 1;\n                        que.push(en);\n                    }\n                }\n            }\n            \n            if (!now[2].empty()) {\n                bool ok = true;\n                if (!now[1].empty()) if (now[2].back() <= now[1].back()) ok = false;\n                if (ok) {\n                    vector<vint> next = now;\n                    next[1].push_back(now[2].back());\n                    next[2].pop_back();\n                    int en = encode(next);\n                    if (memo[en] == -1) {\n                        memo[en] = memo[int_now] + 1;\n                        que.push(en);\n                    }\n                }\n            }\n        }\n        \n        if (res <= m) cout << res << endl;\n        else cout << -1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != -1 ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        {\n            int u = get_last(B);\n            int v = get_last(A);\n            if ( u > v ) {\n                int ret = solve( A | u, remove_last(B), C, turns + 1 );\n                if ( ret != -1 ) return ret;\n            }\n        }\n        {\n            int u = get_last(B);\n            int v = get_last(C);\n            if ( u > v ) {\n                int ret = solve( A, remove_last(B), C | u, turns + 1 );\n                if ( ret != -1 ) return ret;\n            }\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != -1 ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m && n && m ) {\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == -1 && ret2 == -1 ) {\n            cout << -1 << endl;\n        } else if ( ret1 != -1 && ret2 != -1 ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != -1 ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != -1 ) {\n            cout << ret2 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\nconst int NONE = -1;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(A);\n        if ( u > v ) {\n            int ret = solve( A | u, remove_last(B), C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(C);\n        if ( u > v ) {\n            int ret = solve( A, remove_last(B), C | u, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    cout << \"hoge\" << endl;\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == NONE && ret2 == NONE ) {\n            cout << -1 << endl;\n        } else if ( ret1 != NONE && ret2 != NONE ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != NONE ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != NONE ) {\n            cout << ret2 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nint dp[9000000];\nint N, M;\nint to_hash(const vector<int>&nums) {\n\tint hash = 0;\n\tfor (auto n : nums) {\n\t\thash = 3 * hash + n;\n\t}\n\treturn hash;\n}\nint getans(vector<int>&nums, int now) {\n\tint hash = to_hash(nums);\n\tif (dp[hash] == -2) {\n\t\treturn M;\n\t}\n\tif (dp[hash] == -1) {\n\t\tif (now >= M)return M;\n\t\tif (to_hash(nums) == 0) {\n\t\t\treturn now;\n\t\t}\n\t\telse {\n\t\t\tdp[hash] = -2;\n\t\t\tvector<int>tops(3, -1);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\ttops[nums[i]] = i;\n\t\t\t}\n\t\t\tint ans = M;\n\t\t\tif (tops[0] < tops[1]) {\n\t\t\t\tif (tops[1] != -1) {\n\t\t\t\t\tnums[tops[1]] = 0;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tops[0] != -1) {\n\t\t\t\t\tnums[tops[0]] = 1;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[0]] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tops[1] < tops[2]) {\n\t\t\t\tif (tops[2] != -1) {\n\t\t\t\t\tnums[tops[2]] = 1;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[2]] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tops[1] != -1) {\n\t\t\t\t\tnums[tops[1]] = 2;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[hash] = ans;\n\t\t}\n\t}\n\telse {\n\t\treturn dp[hash];\n\t}\n\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 9000000; ++i) {\n\t\t\tdp[i] = -1;\n\t\t} cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<int>nows(N);\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tfor (int j = 0; j < a; ++j) {\n\t\t\t\tint b; cin >> b; b--;\n\t\t\t\tnows[b] = i;\n\t\t\t}\n\t\t}\n\t\tint ans = getans(nows, 0);\n\t\tif (ans == M)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stdlib.h>\n/*http://climpet.hatenablog.com/entry/2013/01/01/225142#f5を参考*/\nint main(int argc, char *argv[])\n{\n  int pow3[16],c[16];\n  int n,m,i,j,k,d,x,y,p;\n\n  pow3[0] = 1;\n  for(i = 1;i <=15;i++){\n    pow3[i] = pow3[i-1]*3;/*i枚#0から#2または#2から#0へ移動するのに必要なステップ数*/\n}\n\n  while(scanf(\"%d%d\",&n,&m),n){\n    for(i = 0;i < 3;--i){\n      for(scanf(\"%d\",&j);j > 0;--j){\n\tscanf(\"%d\",&k);\n\tc[n-k] = i;/*番号付け替え,ハノイの塔に変換。大きいコップを小さい円盤にする*/\n      }\n    }\n    p = 0;//全ての円盤が0の位置にあると仮定する\n    x = 0;\n    for(i = n-1;i >= 0;i--){//\n      d = abs(p -c[i]);//移動させる円盤の距離を求める。\n      /*n = 3の時、i = 2で円盤2を#1に移動させるには円盤1と円盤0を#2に移動させる*/\n      x += pow3[i]*d;\n      if(d == 1){\n\tp = 2-p;/*反対側に移動,距離がd = 1ならば0~i-1番の円盤を反対側に移動する。*/\n      }\n    }\n    y = pow3[n] -1 -x;\n    if(x > y){\n      x = y;\n    }\n    printf(\"%d\\n\",x > m?-1:x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint p[15], n, k, a1, a2, a3, a4, a5, power[16], dp[15000000];\nqueue<int>Q;\nint main() {\n\twhile (true) {\n\t\tcin >> n >> k; power[0] = 1; for (int i = 1; i < 16; i++)power[i] = power[i - 1] * 3; a5 = 0;\n\t\tif (n == 0 && k == 0)break;\n\t\tcin >> a1; for (int i = 0; i < a1; i++) { cin >> a4; p[a4 - 1] = 0; }\n\t\tcin >> a2; for (int i = 0; i < a2; i++) { cin >> a4; p[a4 - 1] = 1; }\n\t\tcin >> a3; for (int i = 0; i < a3; i++) { cin >> a4; p[a4 - 1] = 2; }\n\t\tfor (int i = 0; i < n; i++) { a5 += power[i] * p[i]; }\n\t\tfor (int i = 0; i < power[n]; i++)dp[i] = 1000000000; dp[a5] = 0; Q.push(a5);\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front(); Q.pop();\n\t\t\tvector<int>b[4];\n\t\t\tint C = 0;\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tint p1 = (a1 / power[i]) % 3;\n\t\t\t\tb[p1 + 1].push_back(i);\n\t\t\t\tif (b[p1 + 1].size() == 1)C++;\n\t\t\t\tif (C == 3)break;\n\t\t\t}\n\t\t\tif (b[1].size() >= 1 && (b[2].size() == 0 || b[1][0] > b[2][0])) {\n\t\t\t\tint F = a1 + power[b[1][0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t\tif (b[2].size() >= 1 && (b[1].size() == 0 || b[1][0] < b[2][0])) {\n\t\t\t\tint F = a1 - power[b[2][0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t\tif (b[2].size() >= 1 && (b[3].size() == 0 || b[2][0] > b[3][0])) {\n\t\t\t\tint F = a1 + power[b[2][0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t\tif (b[3].size() >= 1 && (b[2].size() == 0 || b[2][0] < b[3][0])) {\n\t\t\t\tint F = a1 - power[b[3][0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t}\n\t\tint ans = min(dp[0], dp[power[n] - 1]);\n\t\tif (ans > k)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\nusing namespace std;\nint n,m;\nint k3[22];\n\nint main(void){\n  k3[0] = 1;\n  for(int i = 1; i <= 15; i++) k3[i] = k3[i-1]*3;\n\n  while(cin >> n >> m && n){\n    queue<int> que[3];\n    for(int i = 0; i < 3; i++){\n      int k;\n      cin >> k;\n      for(int j = 0; j < k; j++){\n\tint d;\n\tcin >> d;\n\tque[i].push(d);\n      }\n    }\n\n\n    int s = 0;\n    int c = 0;\n    for(int i = n-1; i >= 0; i--){\n      int j;\n      for(j = 0; que[j].empty() || n-i != que[j].front(); j++);\n      que[j].pop();\n      int d = abs(j-s);\n      if(d == 1){\n\tc += k3[i];\n\ts = abs(s-2);\n      }else if(d == 2){\n\tc += k3[i]*2;\n      }\n    }\n\n    int res = min(c,k3[n]-1-c);\n    if(res > m) cout << -1 << endl;\n    else cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\nset< vector< stack<int> > > s;\n\nll saiki(int n,vector< stack<int> > cup){\n    ll ret = 1000000000000;\n    if(s.find(cup) != s.end()) return 1000000000;\n    else s.insert(cup);\n    if(cup[1].size() == 0 && (cup[0].size() == 0||cup[2].size() == 0)){\n\treturn n;\n    }\n    REP(i,2){\n\tif(cup[i].size() > 0 && (cup[i+1].size() == 0 || cup[i].top() > cup[i+1].top())){\n\t    cup[i+1].push(cup[i].top());\n\t    cup[i].pop();\n\t    ret = min(ret,(saiki(n+1,cup)));\n\t    cup[i].push(cup[i+1].top());\n\t    cup[i+1].pop();\n\t}\n\tif(cup[i+1].size() > 0 && (cup[i].size() == 0 || cup[i].top() < cup[i+1].top())){\n\t    cup[i].push(cup[i+1].top());\n\t    cup[i+1].pop();\n\t    ret = min(ret,saiki(n+1,cup));\n\t    cup[i+1].push(cup[i].top());\n\t    cup[i].pop();\n\t}\n    }\n    return ret;\n}\n\nint main(){\n    while(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n == 0 && m == 0 ) break;\n        s = set< vector< stack<int> > >();\n\tvector< stack<int> > cup(3);\n\tREP(i,3){\n\t    int t;\n\t    cin >> t;\n\t    REP(j,t){\n\t\tint temp;\n\t\tcin >> temp;\n\t\tcup[i].push(temp);\n\t    }\n\t}\n\tint ans = saiki(0,cup);\n\tif(ans > m) ans = -1;\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <tr1/unordered_map>\nusing namespace std;\n\nint n;\n\nint goal = 0;\n\ntypedef int P ;\n\ntemplate <class K, class V>  \nclass hashMap {  \n    static const unsigned int DEFAULT_SIZE = 388319;  \n    vector<pair<K, V> > *contents;  \n    unsigned int _size;  \n    unsigned int (*_hashValue) (K, unsigned int);  \n  \npublic:  \n    hashMap(unsigned int (*func) (K, unsigned int) , unsigned int size = DEFAULT_SIZE) {  \n        _hashValue = func;  \n        _size = size;  \n        contents = new vector<pair<K, V> > [_size];  \n    }  \n  \n    ~hashMap() {  \n        delete [] contents;  \n    }  \n  \n    bool hashElement(K s) {  \n        unsigned int h = _hashValue(s, _size);  \n  \n        for (int i = 0; i < (int)contents[h].size(); i++) {  \n            if (contents[h][i].first == s)  \n                return true;  \n        }  \n  \n        return false;  \n    }  \n  \n    void insert(K x, V n) {  \n        if (hashElement(x))  \n            return;  \n  \n        unsigned int h = _hashValue(x, _size);  \n        contents[h].push_back(make_pair(x, n));  \n    }  \n  \n    pair<K, V> *getElement(K x) {  \n        unsigned int h = _hashValue(x, _size);  \n        for (int i = 0; i < (int)contents[h].size(); i++)  \n            if (contents[h][i].first == x)  \n                return &contents[h][i];  \n  \n        return NULL;  \n    }  \n  \n    void printHashBalance() {  \n        int cnt = 0;  \n        double ret = 0.0;  \n        int worst = 0;  \n  \n        for (int i = 0; i < (int)_size; i++) {  \n            if (contents[i].size()) {  \n                ++cnt;  \n                ret += contents[i].size();  \n                worst = max<int>(worst, contents[i].size());  \n            }  \n        }  \n  \n        if (!cnt)  \n            cerr << \"Hash is empty\" << endl;  \n        else {  \n            cerr << \"collisions occurred(average): \" << (ret/cnt) << endl;  \n            cerr << \"collisions occurred(worst): \" << worst << endl;  \n        }  \n    }  \n};  \n\nunsigned int f(int n,unsigned int size){\n\treturn n%388319;\n}\nP Q[30];\nint m,stat,tim,head,size,i,t,a,j,from,to,next;\n\nint main(){\n\twhile(cin >> n >> m && n){\n\t\thashMap<int,int> done(&f);\n\t\tint init = 0;\n\t\tfor(i = 0 ; i < n ; i++) goal |= 2 << (i*2);\n\t\t\n\t\tfor(i = 0 ; i < 3 ; i++){\n\t\t\tt,a; cin >> t;\n\t\t\twhile(t--){cin >> a; a--; init |= (i) << (2*a); }\n\t\t}\n\t\thead = 0 , size = 0;\n\t\tQ[size++] = init;\n\t\tdone.insert(init,0);\n\t\tint hoge = 0;\n\t\twhile(head != size){\n\t\t\thoge++;\n\t\t\tstat = Q[head++];\n\t\t\ttim = (*done.getElement(stat)).second;\n\t\t\tif(tim > m) break;\n\t\t\tif(stat == goal || stat == 0){ cout << tim << endl; goto hoge;}\n\t\t\tint mi[3] = {-1,-1,-1};\n\t\t\tfor(i = n-1 ; i >= 0 ; i--){\n\t\t\t\tint num = stat>>(i*2)&3;\n\t\t\t\tif(mi[num]==-1)mi[num] = i;\n\t\t\t}\n\t\t\t\n\t\t\tfor(from = 0 ; from < 3 ; from++){\n\t\t\t\tfor(to = 0 ; to < 3 ; to++){\n\t\t\t\t\tif ( !( (from == 0 && to == 2) || (from == 2 && to == 0) ) && from != to && mi[from] != -1 && (mi[to] == -1 || mi[from] > mi[to]) ){\n\t\t\t\t\t\tnext = (stat & ~(3<<(2*mi[from]))) | (to<<(2*mi[from]));\n\t\t\t\t\t\tif(done.getElement(next)==NULL)Q[size++] = next , done.insert(next,tim+1);\n\t\t\t\t\t\thead %= 30;\n\t\t\t\t\t\tsize %= 30;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\thoge:;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n\nint n,m;\nstack<int> s[3];\n\nint rec(int time,int prv){\n  int res = -1,tmp,val;\n  if((int)s[0].size()==n || (int)s[2].size()==n)return time;\n  if(time>m)return -1;\n\n  if(prv!=1 && s[0].size() && (s[1].empty() || s[0].top()>s[1].top())){\n    tmp = s[0].top();s[0].pop();\n    s[1].push(tmp);\n    val = rec(time+1,2);\n    if(res<0)res = val;\n    else if(val>=0)res = min(res,val);\n    s[1].pop();\n    s[0].push(tmp);\n  }\n  if(prv!=2 && s[1].size() && (s[0].empty() || s[1].top()>s[0].top())){\n    tmp = s[1].top();s[1].pop();\n    s[0].push(tmp);\n    val = rec(time+1,1);\n    if(res<0)res = val;\n    else if(val>=0)res = min(res,val);\n    s[0].pop();\n    s[1].push(tmp);\n  }\n  if(prv!=3 && s[1].size() && (s[2].empty() || s[1].top()>s[2].top())){\n    tmp = s[1].top();s[1].pop();\n    s[2].push(tmp);\n    val = rec(time+1,4);\n    if(res<0)res = val;\n    else if(val>=0)res = min(res,val);\n    s[2].pop();\n    s[1].push(tmp);\n  }\n if(prv!=4 && s[2].size() && (s[1].empty() || s[2].top()>s[1].top())){\n    tmp = s[2].top();s[2].pop();\n    s[1].push(tmp);\n    val = rec(time+1,3);\n    if(res<0)res = val;\n    else if(val>=0)res = min(res,val);\n    s[1].pop();\n    s[2].push(tmp);\n  }\n return res;\n}\n\nint main(){\n  for(;;){\n    cin >> n >> m;\n    if(!n && !m)break;\n\n    for(int i=0;i<3;i++){\n      while(s[i].size())s[i].pop();\n      int num;\n      cin >> num;\n      for(int j=0;j<num;j++){\n\tint tmp;\n\tcin >> tmp;\n\ts[i].push(tmp);\n      }\n    }\n\n    cout << rec(0,0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint n, m;\nstruct puzzle {\n\tint f[3][15], len[3], cnt;\n};\nbool operator<(const puzzle&left, const puzzle&right) {\n\tint cntl = 0, cntr = 0;\n\trep(i, 3)rep(j, n) {\n\t\tcntl += left.f[i][j]; cntr += right.f[i][j];\n\t\tif (cntl != cntr)return cntl < cntr;\n\t}\n\treturn false;\n}\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tpuzzle in{};\n\t\trep(i, 3) {\n\t\t\tscanf(\"%d\", &in.len[i]);\n\t\t\trep(j, in.len[i])scanf(\"%d\", &in.f[i][j]);\n\t\t}\n\t\tmap<puzzle, bool>mp;\n\t\tqueue<puzzle>que;\n\t\tmp[in] = true;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tpuzzle u = que.front(); que.pop();\n\t\t\tif (u.len[0] == n || u.len[2] == n) {\n\t\t\t\tprintf(\"%d\\n\", u.cnt);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (u.cnt >= m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tif (u.len[i] == 0)continue;\n\t\t\t\tif (u.len[j] > 0 && (u.f[i][u.len[i] - 1] < u.f[j][u.len[j] - 1]))\n\t\t\t\t\tcontinue;\n\t\t\t\tpuzzle v = u;\n\t\t\t\tv.len[i]--; v.len[j]++;\n\t\t\t\tswap(v.f[i][v.len[i]], v.f[j][v.len[j] - 1]);\n\t\t\t\tif (!mp[v]) {\n\t\t\t\t\tmp[v] = true;\n\t\t\t\t\tv.cnt++;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n\nint n,m,now;\nstack<int> s[3];\nbool use[15000000];\n\nint rec(int time){\n  int res = -1,tmp,val;\n  if((int)s[0].size()==n || (int)s[2].size()==n)return time;\n  if(time>m)return -1;\n  int d1[] = {0,1,1,2},d2[] = {1,0,2,1};\n\n  for(int i=0;i<4;i++){\n    // cout << time << \" \" << i << \" \" << s[0].size() << \" \" << s[1].size() << endl;\n    if(s[d1[i]].size() && (s[d2[i]].empty() || s[d1[i]].top()>s[d2[i]].top())){\n      tmp = s[d1[i]].top();\n      int hoge = pow(3,tmp-1);\n      now -= hoge*d1[i] - hoge*d2[i];\n      //cout << now << endl;\n      if(!use[now]){\n\tuse[now] = true;\n\ts[d1[i]].pop();\n\ts[d2[i]].push(tmp);\n\n\tval = rec(time+1);\n\tif(res<0)res = val;\n\telse if(val>=0)res = min(res,val);\n\n\ts[d2[i]].pop();\n\ts[d1[i]].push(tmp);\n\tuse[now] = false;\n      }\n      now += hoge*d1[i] - hoge*d2[i];\n    }\n  }\n return res;\n}\n\nint main(){\n  for(;;){\n    cin >> n >> m;\n    if(!n && !m)break;\n\n    now = 0;\n    for(int i=0;i<3;i++){\n      while(s[i].size())s[i].pop();\n      int num;\n      cin >> num;\n      for(int j=0;j<num;j++){\n\tint tmp;\n\tcin >> tmp;\n\ts[i].push(tmp);\n\tnow += pow(3,tmp-1)*i;\n      }\n    }\n\n    int lim = pow(3,n);\n    for(int i=0;i<lim;i++)use[i] = false;\n    use[now] = true;\n\n    cout << rec(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define pb push_back\nconst int maxn = 10000;\nconst int INF32 = 1'050'000'000;\nconst long long INF64 = 4'000'000'000'000'000'000;\nconst int MOD7 = 1'000'000'007;\nconst int MOD9 = 1'000'000'009;\n\nll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\nint dx[8]={-1,0,1,0,1,1,-1,-1};\nint dy[8]={0,-1,0,1,1,-1,1,-1};\n\nstruct P\n{\n\tvector<int> mem[3];\n\tll point;\n};\nint n, m;\nint vis[15000000] = {-1};\nqueue<P> que; \n\nll cal_point(P p){\n\tll point = 0; \n\trep(i,3){\n\t\trep(j,p.mem[i].size()){\n\t\t\tpoint += i * pow(3,p.mem[i][j]-1);\n\t\t}\n\t}\n\treturn point;\n}\n\nvoid INIT(){\n\tmemset(vis,-1,sizeof(vis));\n\twhile(!que.empty()){\n\t\tque.pop();\n\t}\n}\n\nP Change(P p, int num1, int num2){\n\tint l = p.mem[num1].size()-1;\n\tint tmp = p.mem[num1][l];\n\tp.mem[num1].pop_back();\n\tp.mem[num2].push_back(tmp);\n\treturn p;\n}\n\nvoid PRINT(P p){\n\tchar alp = 'A';\n\tcout << \"###########\" << endl;\n\trep(i,3){\n\t\tcout << char(alp+i) << \":\";\n\t\trep(j,p.mem[i].size()){\n\t\t\tcout << p.mem[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << \"###########\" << endl;\n}\n\nint BFS(){\n\tint step = 0;\n\twhile(!que.empty()){\n\t\tP p = que.front(); que.pop();\n\n\t\tif(vis[p.point]>m){\n\t\t\tstep = -1;\n\t\t\tbreak;\n\t\t}\n\t\t//cout << \"point is \" << p.point << \"; step is \" << vis[p.point] << endl;//\n\t\t//PRINT(p);\n\n\t\tif(p.mem[1].size()==0 && \n\t\t\t(p.mem[0].size()==0 || p.mem[2].size()==0)){\n\t\t\tstep = vis[p.point];\n\t\t\tbreak;\n\t\t}\n\n\t\tint L[3]; \n\t\trep(i,3) L[i] = p.mem[i].size()-1;\n\n\t\trep(i,3) rep(j,3){ // from L[i] to L[j]\n\t\t\tif(abs(i-j)!=1) continue;\n\t\t\tif(L[i]>=0){ // from \n\t\t\t\tint ok = 0;\n\t\t\t\tif(L[j]>=0){ // to\n\t\t\t\t\tif(p.mem[i][L[i]] >= p.mem[j][L[j]]) ok = 1;\n\t\t\t\t}\n\t\t\t\telse if(p.mem[j].size() == 0) ok = 1;\n\n\t\t\t\tif(ok){\n\t\t\t\t\tP np = Change(p,i,j); //更新後の状態\n\t\t\t\t\tnp.point = cal_point(np);\n\t\t\t\t\tif(vis[np.point]==-1){\n\t\t\t\t\t\tvis[np.point] = vis[p.point]+1;\n\t\t\t\t\t\tque.push(np);\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"!!\"  << endl;\n\treturn step;\n}\n\nint main(){\n\twhile(1){\n\t\tINIT();\n\t\tcin >> n >> m;\n\t\tif(!n&&!m) break;\n\n\t\tP tmp;\n\t\trep(i,3){\n\t\t\tint num, inp;\n\t\t\tcin >> num; //the number of dish\n\t\t\trep(j,num){\n\t\t\t\tcin >> inp;\n\t\t\t\ttmp.mem[i].pb(inp);\n\t\t\t}\n\t\t\ttmp.point = cal_point(tmp);\n\t\t}\n\n\t\t//cout << tmp.point << endl;\n\t\tvis[tmp.point] = 0;\n\t\tque.push(tmp);\n\n\t\tint ans = BFS();\n\n\t\tcout << ans << endl; \n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nclass State\n{\npublic:\n  int cost, op;\n  vector<int> tray;\n  State(vector<int> _tray = vector<int>(), int _cost = 0, int _op = -1)\n    :cost(_cost), op(_op)\n  {\n    tray = _tray;\n  }\n\n  bool operator < (const State& st) const\n  {\n    return this->cost > st.cost;\n  }\n};\n\ninline int ntz(int bit)\n{\n  int res = __builtin_popcount((~bit)&(bit-1));\n  if (res == 32)\n    res = INF;\n  return res;\n}\n\nint main()\n{\n  int n, m;\n  while (cin >> n >> m) {\n    if ((n|m) == 0)\n      break;\n\n    vector<int> tray(3, 0);\n    for (int i = 0; i < tray.size(); ++i) {\n      int num;\n      cin >> num;\n      for (int j = 0; j < num; ++j) {\n\tint bit;\n\tcin >> bit;\n\ttray[i] |= 1 << (n-bit);\n      }\n    }\n\n    int ans = -1;\n    State st, next;\n    priority_queue<State> que;\n    que.push(State(tray));\n    const int FIN = (1 << n) - 1;\n    while (!que.empty()) {\n      st = que.top();\n      que.pop();\n\n      if (st.tray[0] == FIN || st.tray[2] == FIN) {\n\tans = st.cost;\n\tbreak;\n      }\n\n      if (st.cost > m)\n\tbreak;\n\n      int A = ntz(st.tray[0]), B = ntz(st.tray[1]), C = ntz(st.tray[2]);\n\n      ++st.cost;\n      // A -> B\n      if (st.tray[0] != 0 && st.op !=  1 && A < B) {\n\tnext = st;\n\tnext.tray[0] ^= (1 << A);\n\tnext.tray[1] |= (1 << A);\n\tnext.op = 0;\n\tque.push(next);\n      }\n\n      if (st.tray[1] != 0) {\n\t// B -> A\n\tif (st.op != 0 && B < A) {\n\t  next = st;\n\t  next.tray[1] ^= (1 << B);\n\t  next.tray[0] |= (1 << B);\n\t  next.op = 1;\n\t  que.push(next);\n\t}\n\n\t// B -> C\n\tif (st.op != 3 && B < C) {\n\t  next = st;\n\t  next.tray[1] ^= (1 << B);\n\t  next.tray[2] |= (1 << B);\n\t  next.op = 2;\n\t  que.push(next);\n\t}\n      }\n\n      // C -> B\n      if (st.tray[2] && st.op !=  2 && C < B ) {\n\tnext = st;\n\tnext.tray[2] ^= (1 << C);\n\tnext.tray[1] |= (1 << C);\n\tnext.op = 3;\n\tque.push(next);\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n\t\n\tint n, m;\n\t\n\tlong long int a[20] = {};\n\tfor(int i = 1; i < 20; i++){\n\t\ta[i] = a[i - 1] * 3 + 2;\n\t}\n\t\n\twhile(true){\n\t\tcin >> n >> m;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tint tile[20] = {};\n\t\tfor(int loop = 0; loop < 3; loop++){\n\t\t\tint num;\n\t\t\tcin >> num;\n\t\t\tfor(int i = 0; i < num; i++){\n\t\t\t\tint num2;\n\t\t\t\tcin >> num2;\n\t\t\t\tnum2 = n - num2 + 1;\n\t\t\t\ttile[num2] = loop;\n\t\t\t}\n\t\t}\n\t\ttile[0] = 10000;\n\t\ttile[n + 1] = 0;\n\t\tlong long int ans = 1000000000LL;\n\t\t\n\t\tlong long int diff = 0;\n\t\tlong long int cnt = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(abs(tile[i] - tile[i + 1]) == 1){\n\t\t\t\tcnt -= 2 * diff;\n\t\t\t\tif(tile[i] - tile[i + 1] == tile[i - 1] - tile[i]){\n\t\t\t\t\tcnt += a[i - 1] / 2 + 1;\n\t\t\t\t}else{\n\t\t\t\t\tcnt += a[i] / 2;\n\t\t\t\t}\n\t\t\t}else if(abs(tile[i] - tile[i + 1]) == 2){\n\t\t\t\tcnt -= 2 * diff;\n\t\t\t\tcnt += a[i];\n\t\t\t}\n\t\t\tif(tile[i + 1] != 1){\n\t\t\t\tdiff = cnt;\n\t\t\t}else{\n\t\t\t\tdiff = 0;\n\t\t\t}\n\t\t}\n\t\tans = min(ans, cnt);\n\t\t\n\t\ttile[n + 1] = 2;\n\t\t\n\t\tdiff = 0;\n\t\tcnt = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(abs(tile[i] - tile[i + 1]) == 1){\n\t\t\t\tcnt -= 2 * diff;\n\t\t\t\tif(tile[i] - tile[i + 1] == tile[i - 1] - tile[i]){\n\t\t\t\t\tcnt += a[i - 1] / 2 + 1;\n\t\t\t\t}else{\n\t\t\t\t\tcnt += a[i] / 2;\n\t\t\t\t}\n\t\t\t}else if(abs(tile[i] - tile[i + 1]) == 2){\n\t\t\t\tcnt -= 2 * diff;\n\t\t\t\tcnt += a[i];\n\t\t\t}\n\t\t\tif(tile[i + 1] != 1){\n\t\t\t\tdiff = cnt;\n\t\t\t}else{\n\t\t\t\tdiff = 0;\n\t\t\t}\n\t\t}\n\t\tans = min(ans, cnt);\n\t\tif(ans > m){\n\t\t\tcout << \"-1\" << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <iterator>\n#include <algorithm>\n\n#define MAX_N 15\n#define MAX_M 15000000\n\n\nstd::stack<int> trays[3];\nstd::stack<int> r_trays[3];\n\nvoid moveTop(int i, int j) {\n  // move top value i to j\n  trays[j].push(trays[i].top());\n  trays[i].pop();\n}\n\nvoid clearTray() {\n  for (int i = 0; i < 3; i ++) {\n    while(!trays[i].empty())\n      trays[i].pop();\n    while(!r_trays[i].empty())\n      r_trays[i].pop();\n  }\n}\n\nbool isEmpty() {\n  if((trays[0].empty() && trays[1].empty()) || (trays[1].empty() && trays[2].empty()))\n    return true;\n  else\n    return false;\n}\n\nint moveCups(int m) {\n  int move = 0;\n  bool flag = true;\n\n  if (isEmpty())\n    return 0;\n\n  while(flag) {\n    for (int i = 0; i < 2; i ++) { \n      move ++;\n      // move bigger cup\n      if (trays[i + 1].empty() || (!trays[i].empty() && trays[i].top() > trays[i + 1].top())) {\n        moveTop(i, i + 1); \n      } else {\n        moveTop(i + 1, i);\n      }\n      // check situation\n      if (isEmpty()) {\n        flag = false;\n        break;\n      } else if (move >= m) {\n        flag = false;\n        move = -1;\n        break;\n      }\n    }\n  }\n  return move;\n}\n\nint main() {\n  int n, m;\n  int num, temp, move, left, right, ans;\n  bool flag = true;\n  while (1) {\n    std::cin >> n >> m;\n    if (n == 0)\n      break;\n    // store cups to trays.\n    for (int i = 0; i < 3; i ++) {\n      std::cin >> num;\n      for (int j = 0; j < num; j ++) {\n        std::cin >> temp;\n        trays[i].push(temp);\n      }\n      r_trays[2 - i] = trays[i];\n    }\n    std::reverse(std::begin(r_trays), std::end(r_trays));\n    right = moveCups(m);\n    for (int i = 0; i < 3; i ++)\n      trays[i].swap(r_trays[2 - i]);\n    left = moveCups(m);\n\n    if (right != -1 && left != -1)\n      ans = right < left ? right : left;\n    else\n      ans = right > left ? right : left;\n    std::cout << ans << std::endl;\n    clearTray();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst int MAXN = 17;\nconst int SSIZE = 15000000;\nconst int INF = INT_MAX;\n\nconst int W = 3;\nint N, M;\n\nint three[MAXN];\nbool vis[SSIZE];\n\nvoid init() {\n  three[0] = 1;\n  for(int i = 1; i < MAXN; ++i) three[i] = three[i-1] * 3;\n}\n\nint get3(int s, int i) {\n  return s/three[i]%3;\n}\n\nint getTop(int s, int pos) {\n  int maxi = -1;\n  for(int i = 0; i < N; ++i) {\n    if(s % W == pos) maxi = i;\n    s /= W;\n  }\n  return maxi;\n}\n\nint move(int s, int from, int to) {\n  int a = getTop(s, from);\n  int b = getTop(s, to);\n  if(a == -1) return INF;\n  if(a < b) return INF;\n  s -= three[a] * from;\n  s += three[a] * to;\n  return s;\n}\n\nvoid show(int s) {\n  for(int i = 0; i < N; ++i) {\n    cout << s%3;\n    s /= 3;\n  }\n  cout << endl;\n}\n\nint bfs(int s) {\n  queue<pair<int, int> > que;\n  fill(vis, vis+SSIZE, false);\n  que.push(make_pair(s,0));\n  vis[s] = true;\n\n  int goal1, goal2;\n  goal1 = goal2 = 0;\n  for(int i = 0; i < N; ++i) goal2 += three[i]*2;\n  if(s == goal1 || s == goal2) {\n    return 0;\n  }\n\n  while(!que.empty()) {\n    s = que.front().first;\n    int cost = que.front().second;\n    que.pop();\n    if(cost == M) continue;\n    for(int i = 0; i < W; ++i) {\n      for(int j = 0; j < W; ++j) {\n\tif(abs(i-j) != 1) continue;\n\tint ns = move(s, i, j);\n\tif(ns == INF) continue;\n\tif(vis[ns]) continue;\n\tif(ns == goal1 || ns == goal2) {\n\t  return cost+1;\n\t}\n\tvis[ns] = true;\n\tque.push(make_pair(ns, cost+1));\n      }\n    }\n  }\n  return INF;\n}\n\nint main() {\n  init();\n  while(cin >> N >> M && (N|M)) {\n    int sum = 0;\n    for(int i = 0; i < W; ++i) {\n      int k;\n      cin >> k;\n      while(k--) {\n\tint a;\n\tcin >> a;\n\t--a;\n\tsum += three[a] * i;\n      }\n    }\n    int ans = bfs(sum);\n    if(ans <= M) {\n      cout << ans << endl;\n    } else {\n      cout << -1 << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint p[15], n, k, a1, a2, a3, a4, a5, power[16], dp[15000000];\nqueue<int>Q;\nint main() {\n\twhile (true) {\n\t\tcin >> n >> k; power[0] = 1; for (int i = 1; i < 16; i++)power[i] = power[i - 1] * 3; a5 = 0;\n\t\tif (n == 0 && k == 0)break;\n\t\tcin >> a1; for (int i = 0; i < a1; i++) { cin >> a4; p[a4 - 1] = 0; }\n\t\tcin >> a2; for (int i = 0; i < a2; i++) { cin >> a4; p[a4 - 1] = 1; }\n\t\tcin >> a3; for (int i = 0; i < a3; i++) { cin >> a4; p[a4 - 1] = 2; }\n\t\tfor (int i = 0; i < n; i++) { a5 += power[i] * p[i]; }\n\t\tfor (int i = 0; i < power[n]; i++)dp[i] = 1000000000; dp[a5] = 0; Q.push(a5);\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front(); Q.pop();\n\t\t\tvector<int>b1, b2, b3;\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tint p1 = (a1 / power[i]) % 3;\n\t\t\t\tif (p1 == 0)b1.push_back(i);\n\t\t\t\tif (p1 == 1)b2.push_back(i);\n\t\t\t\tif (p1 == 2)b3.push_back(i);\n\t\t\t}\n\t\t\tif (b1.size() >= 1 && (b2.size() == 0 || b1[0] > b2[0])) {\n\t\t\t\tint F = a1 + power[b1[0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t\tif (b2.size() >= 1 && (b1.size() == 0 || b1[0] < b2[0])) {\n\t\t\t\tint F = a1 - power[b2[0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t\tif (b2.size() >= 1 && (b3.size() == 0 || b2[0] > b3[0])) {\n\t\t\t\tint F = a1 + power[b2[0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t\tif (b3.size() >= 1 && (b2.size() == 0 || b2[0] < b3[0])) {\n\t\t\t\tint F = a1 - power[b3[0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t}\n\t\tint ans = min(dp[0], dp[power[n] - 1]);\n\t\tif (ans > k)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint n, m;\nstruct puzzle {\n\tchar f[3][15], len[3];\n\tint cnt;\n};\nbool operator==(const puzzle&left, const puzzle&right) {\n\trep(i, 3) {\n\t\tif (strcmp(left.f[i], right.f[i]))return false;\n\t}\n\treturn true;\n}\nstruct GET {\n\tinline size_t operator()(const puzzle&p) const {\n\t\tsize_t cnt = 0;\n\t\trep(i, 3) {\n\t\t\thash<string>H;\n\t\t\tcnt += (i + 1)*H(p.f[i]);\n\t\t}\n\t\treturn cnt;\n\t}\n};\n\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tpuzzle in{};\n\t\trep(i, 3) {\n\t\t\tscanf(\"%hd\", &in.len[i]);\n\t\t\trep(j, in.len[i])scanf(\"%hd\", &in.f[i][j]);\n\t\t}\n\t\tunordered_map<puzzle, bool, GET>mp;\n\t\tqueue<puzzle>que;\n\t\tmp[in] = true;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tpuzzle u = que.front(); que.pop();\n\t\t\tif (u.len[0] == n || u.len[2] == n) {\n\t\t\t\tprintf(\"%d\\n\", u.cnt);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (u.cnt >= m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tif (u.len[i] == 0)continue;\n\t\t\t\tif (u.len[j] > 0 && (u.f[i][u.len[i] - 1] < u.f[j][u.len[j] - 1]))\n\t\t\t\t\tcontinue;\n\t\t\t\tpuzzle v = u;\n\t\t\t\tv.len[i]--; v.len[j]++;\n\t\t\t\tswap(v.f[i][v.len[i]], v.f[j][v.len[j] - 1]);\n\t\t\t\tif (!mp[v]) {\n\t\t\t\t\tmp[v] = true;\n\t\t\t\t\tv.cnt++;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//24\n#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  vector<int> v[3];\n  int t;\n};\n\nvector<int> cv(vector<int> *v){\n  vector<int> r(16);\n  for(int i=0;i<3;i++){\n    for(int j=0;j<v[i].size();j++){\n      r[v[i][j]]=i;\n    }\n  }\n  return r;\n}\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    S is;\n    for(int i=0;i<3;i++){\n      int e;\n      cin>>e;\n      is.v[i].resize(e);\n      for(int j=0;j<e;j++){\n\tcin>>is.v[i][j];\n      }\n    }\n    is.t=0;\n    if(is.v[0]>is.v[2]){\n      is.v[0].swap(is.v[2]);\n    }\n    queue<S> que;\n    que.push(is);\n    map<vector<int>,bool> mem;\n    while(!que.empty()&&que.front().t<=m){\n      S c=que.front();\n      if(c.v[2].size()==n)break;\n      que.pop();\n      if(mem[cv(c.v)]++)continue;\n      for(int i=0;i<3;i++){\n\tfor(int j=-1;j<=1;j+=2){\n\t  if(0<=i+j&&i+j<=2&&!c.v[i].empty()&&(c.v[i+j].empty()||c.v[i].back()>c.v[i+j].back())){\n\t    S ns=c;\n\t    ns.v[i+j].push_back(ns.v[i].back());\n\t    ns.v[i].pop_back();\n\t    ns.t++;\n\t    if(ns.v[0]>ns.v[2]){\n\t      ns.v[0].swap(ns.v[2]);\n\t    }\n\t    que.push(ns);\n\t  }\n\t}\n      }\n    }\n    if(!que.empty()&&que.front().t<=m){\n      cout<<que.front().t<<endl;\n    }else{\n      cout<<-1<<endl;\n    }\n  }\n  return 0;\n}\n\n/*\n    S s=c;\n    for(int j=0;j<3;j++){\n      for(int i=0;i<s.v[j].size();i++){\n\tcout<<s.v[j][i];\n      }\n      cout<<endl;\n    }\n    cout<<s.v[0].size()<<endl;\n*/"
  },
  {
    "language": "C++",
    "code": "//40\n#include<iostream>\n#include<queue>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\nstruct S{\n  int t;\n  int c[3];\n  bool operator<(S a)const{\n    return lexicographical_compare(c,c+3,a.c,a.c+3);\n  }\n};\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    S is={0,{0,0,0}};\n    for(int i=0;i<3;i++){\n      int k;\n      cin>>k;\n      while(k--){\n\tint c;\n\tcin>>c;\n\tis.c[i]|=1<<(n-c);\n      }\n    }\n    queue<S> que;\n    que.push(is);\n    set<S> p;\n    while(!que.empty()&&que.front().t<=m){\n      S c=que.front();\n      if(c.c[0]==(1<<n)-1||c.c[2]==(1<<n)-1)break;\n      que.pop();\n      if(p.count(c))continue;\n      p.insert(c);\n      for(int i=0;i<3;i++){\n\tfor(int d=-1;d<=1;d+=2){\n\t  int nd=i+d;\n\t  int l=c.c[i]&~(c.c[i]-1);\n\t  if(0<=nd&&nd<3&&c.c[i]&&(c.c[nd]==0||l<(c.c[nd]&~(c.c[nd]-1)))){\n\t    S n=c;\n\t    n.c[nd]|=l;\n\t    n.c[i]&=~l;\n\t    n.t++;\n\t    que.push(n);\n\t  }\n\t}\n      }\n    }\n    if(!que.empty()&&que.front().t<=m){\n      cout<<que.front().t<<endl;\n    }else{\n      cout<<-1<<endl;\n    }\n  }\n  return 0;\n}\n   \n\t"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint d[3][16];\nint x;\nint i,j,k;\nint m,n;\nint ans=0;\nint goal;\nint now[3];\nint p,q;\n\nint other(int a,int b){\n\tif(a==0&&b==1)return 2;\n\tif(b==0&&a==1)return 2;\n\tif(a==0&&b==2)return 1;\n\tif(b==0&&a==2)return 1;\n\tif(a==1&&b==2)return 0;\n\tif(b==1&&a==2)return 0;\n}\n\nvoid move(int n,int a,int b,int to){\nstart:\n\tif(ans>m)return;\n\tif(n!=d[a][b])return;\n\tif(to-a==2||a-to==2){\n\t\tmove(d[a][b],a,b,1);\n\t\tmove(d[1][now[1]-1],1,now[1]-1,to);\n\t\tif(now[a]==0)return;\n\t\tif(d[a][b]==-1)b=now[a]-1;\n\t\tgoto start;\n\t}\n\tif(d[a][b+1]>0){\n\t\tmove(d[a][b+1],a,b+1,other(a,to));\n\t\tif(now[a]==0)return;\n\t\tif(d[a][b]==-1)b=now[a]-1;\n\t\tgoto start;\n\t}\n\tif(now[to]>=1&&d[to][now[to]-1]>d[a][b]){\n\t\tmove(d[to][now[to]-1],to,now[to]-1,other(a,to));\n\t\tif(now[a]==0)return;\n\t\tif(d[a][b]==-1)b=now[a]-1;\n\t\tgoto start;\n\t}\n\td[to][now[to]++]=d[a][b];\n\td[a][b]=-1;\n\tnow[a]--;\n\tans++;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)break;\n\t\tans=0;\n\t\tfor(i=0;i<3;i++)for(j=0;j<16;j++)d[i][j]=-1;\n\t\tfor(i=0;i<3;i++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tfor(j=0;j<x;j++){\n\t\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\t}\n\t\t\tnow[i]=x;\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(i==0){\n\t\t\t\tif(d[1][0]==1){\n\t\t\t\t\tif(d[2][0]>d[0][0]){\n\t\t\t\t\t\tif(now[0]==0)goal=0;\n\t\t\t\t\t\telse goal=2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(now[2]==0)goal=2;\n\t\t\t\t\t\telse goal=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(d[0][0]==1)goal=0;\n\t\t\t\telse goal=2;\n\t\t\t}\n\t\t\tp=-1;q=-1;\n\t\t\tfor(j=0;j<3;j++)for(k=0;k<16;k++)if(d[j][k]==i+1){p=j;q=k;}\n\t\t\tif(p!=-1&&q!=-1)if(p!=goal)move(i+1,p,q,goal);\n\t\t\tif(ans>m)break;\n\t\t}\n\t\tif(ans<=m)printf(\"%d\\n\",ans);\n\t\telse printf(\"-1\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<utility>\n#include<vector>\nusing namespace std;\nvoid shoki(vector<vector<int>> a) {\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 16; ++j) \n\t\t\ta[i][j] = 0;\n\t}\n\treturn;\n}\nint main() {\n\tint n, m, na, nb, nc,tyo,place[16];\n\tvector<vector<int>> cup(3,vector<int>(16));\n\twhile (1) {\n\t\ttyo = 0;\n\t\tshoki(cup);\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\t\tcin >> na;\n\t\tfor (int i = 0; i < na; ++i) cin >> cup[0][i];\n\t\tcin >> nb;\n\t\tfor (int i = 0; i < nb; ++i)cin >> cup[1][i];\n\t\tcin >> nc;\n\t\tfor (int i = 0; i < nc; ++i)cin >> cup[2][i];\n\t\tif (cup[0][0] == 1)place[0] = 0;\n\t\telse if (cup[2][0] == 1)place[0] = 2;\n\t\telse if (cup[0][0] == 0)place[0] = 0;\n\t\telse if (cup[2][0] == 0)place[0] = 2;\n\t\telse if (cup[0][0] > cup[2][0])place[0] = 0;\n\t\telse place[0] = 2;\n\t\tint np;\n\t\tif (place[0] == 0)np = 2;\n\t\telse np = 0;\n\t\tfor (int k = 1; k < 16; ++k) {\n\t\t\tplace[k] = place[0];\n\t\t}\n\t\tbool bo = false; int at,ar;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tfor (int j = 0; j < na; ++j) {\n\t\t\t\tif (cup[0][j] == i) {\n\t\t\t\t\tat = 0;\n\t\t\t\t\tar = j;\n\t\t\t\t\tbo = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < nb; ++j) {\n\t\t\t\tif (bo)break;\n\t\t\t\tif (cup[1][j] == i) {\n\t\t\t\t\tat = 1;\n\t\t\t\t\tar = j;\n\t\t\t\t\tbo = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < nc; ++j) {\n\t\t\t\tif (bo)break;\n\t\t\t\tif (cup[2][j] == i) {\n\t\t\t\t\tat = 2;\n\t\t\t\t\tar = j;\n\t\t\t\t\tbo = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbo = false;\n\t\t\tif (at == place[i]) {\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (at == 1) {\n\t\t\t\t\ttyo += pow(3, n - i);\n\t\t\t\t\tfor (int k =i+1; k < 16; ++k) {\n\t\t\t\t\t\tif (place[k] == 0)place[k] = 2;\n\t\t\t\t\t\telse place[k] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttyo += 2 * (pow(3, n - i));\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (m < tyo)cout << -1 << endl;\n\t\telse cout << tyo << endl;\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<utility>\n#include<vector>\nusing namespace std;\nint main(){\n    int place,n,m,a[3][16]={0},na,nb,nc;\n    while(1){\n        for(int i=0;i<3;++i){\n            for(int j=0;j<16;++j){\n                a[i][j]=0;\n            }\n        }\n    cin>>n>>m;\n        if(n==0&&m==0)break;\n    cin>>na;\n    for(int i=0;i<na;++i){\n        cin>>a[0][i];\n    }\n    cin>>nb;\n    for(int i=0;i<nb;++i){\n        cin>>a[1][i];\n    }\n    cin>>nc;\n    for(int i=0;i<nc;++i){\n        cin>>a[2][i];\n    }\n    if(a[0][0]==1)place=0;\n    else if(a[2][0]==1)place=2;\n    else if(a[0][0]==1)place=0;\n    else if(a[2][0]==0)place=2;\n    else if(a[0][0]==0)place=0;\n    else if(a[0][0]>a[2][0])place=0;\n    else place=2;\n    int np,cnt=0,tar;\n    if(place==0)np=2;\n    else np=0;\n    if(place==0)tar=na;\n    else tar=nc;\n    for(int i=1;i<=tar;++i){\n        if(i!=a[place][i-1]){\n            cnt=tar-i;\n        }\n    }\n    int tyo=0;\n    if(a[np][0]!=0){\n        tyo=-4;\n    }\n        if(a[place][cnt]!=0){\n            if(a[place][0]>a[np][cnt]&&a[np][cnt]!=0){\n                tyo+=2;\n                if(np==2){\n                    na--;\n                    nc++;\n                }\n                else{\n                    nc--;\n                    na++;\n                }\n            }\n            else if(a[place][0]>a[np][cnt]&&a[np][cnt]!=0){\n                tyo+=6;\n            }\n        }\n    if(place==0){\n        cout<<(nb+nc*6+tyo>m?-1:nb+nc*6+tyo)<<endl;\n    }\n    else {\n        cout<<(nb+na*6+tyo>m?-1:nb+na*6+tyo)<<endl;\n    }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nclass P{\n    public:\n    int cnt;\n    int bef;\n    stack< int > S[3];\n};\n\nint main(){\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m),(n|m)){\n        P f;\n        for(int i = 0;i < 3; i++){\n            int x;\n            scanf(\"%d\",&x);\n            for(int j = 0; j < x; j++){\n                int tmp;\n                scanf(\"%d\",&tmp);\n                f.S[i].push(tmp);\n            }\n        }\n        f.cnt = 0;\n        f.bef = -1;\n        queue< P > Q;\n        Q.push(f);\n        bool flg = true;\n        while( !Q.empty()){\n            P p = Q.front();Q.pop();\n            if(p.cnt > m){\n                flg = false;\n                break;\n            }\n            bool h = false;\n            for(int i = 0; i < 3; i++){\n                if(i == 1)continue;\n                if(p.S[i].size() == n){\n                    printf(\"%d\\n\",p.cnt);\n                    h = true;\n                }\n            }\n            if( h ){\n                break;\n            }\n            int top0 = (p.S[0].size()>0)?p.S[0].top() : 0;\n            int top1 = (p.S[1].size()>0)?p.S[1].top() : 0;\n            int top2 = (p.S[2].size()>0)?p.S[2].top() : 0;\n            int copy0 = top0 , copy1 = top1 , copy2 = top2;\n            P sub;\n            sub.cnt = p.cnt+1;\n            if(top0 < top1 && p.bef != 0){\n                p.S[1].pop();\n                p.S[0].push(top1);\n                for(int i = 0; i < 3; i++)sub.S[i] = p.S[i];\n                sub.bef = 1;\n                Q.push(sub);\n                p.S[0].pop();\n                p.S[1].push(copy1);\n            }\n            if(top0 > top1 && p.bef != 1) {\n                p.S[0].pop();\n                p.S[1].push(top0);\n                for(int i = 0; i < 3; i++)sub.S[i] = p.S[i];\n                sub.bef = 0;\n                Q.push(sub);\n                p.S[1].pop();\n                p.S[0].push(copy0);\n            }\n            if(top1 < top2 && p.bef != 2){\n                p.S[2].pop();\n                p.S[1].push(top2);\n                for(int i = 0;i < 3; i++)sub.S[i] = p.S[i];\n                sub.bef = 3;\n                Q.push(sub);\n                p.S[1].pop();\n                p.S[2].push(copy2);\n            }\n            if(top1 > top2 && p.bef != 3){\n                p.S[1].pop();\n                p.S[2].push(top1);\n                for(int i = 0; i < 3; i++)sub.S[i] = p.S[i];\n                sub.bef = 2;\n                Q.push(sub);\n                p.S[2].pop();\n                p.S[1].push(copy1);\n            }\n        }\n        if( !flg )puts(\"-1\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <utility>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n\nusing namespace std;\n\ntypedef uint64_t u64;\ntypedef int64_t s64;\ntypedef uint32_t u32;\ntypedef int32_t s32;\ntypedef vector<s32> vs32;\ntypedef vector<u32> vu32;\ntypedef vector<s64> vs64;\ntypedef vector<u64> vu64;\n\nconst double PI=3.14159265358979323846;\n\n#define MAX(x, y) ((x) < (y) ? (y) : (x))\n#define MIN(x, y) ((x) > (y) ? (y) : (x))\n\n#define rep(i, N) for(int i = 0; i < N; ++i)\n\n#define CEIL(x, y) (((x) + (y) - 1) / (y))\n#define MOD 1000000007ULL\n\n#define IN(l, r, x) ((l) <= (x) && (x) < (r))\n\nusing STATE = u32;\nvs32 pow3(16);\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n\n    vs32 pow3(16);\n    pow3[0] = 1;\n    rep (i, 16)\n    {\n        pow3[i + 1] = pow3[i] * 3;\n    }\n\n    while (true)\n    {\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        STATE state = 0;\n        rep (i, 3)\n        {\n            int num;\n            cin >> num;\n            rep (j, num)\n            {\n                int temp;\n                cin >> temp;\n                --temp;\n                state += pow3[temp] * i;\n            }\n        }\n\n        queue< STATE > q;\n        q.push(state);\n        int ans = 0;\n        bool found = false;\n        vector< bool > done(pow3[15] + 100, false);\n        while (true)\n        {\n            int qsize = q.size();\n            rep (it, qsize)\n            {\n                STATE s = q.front(); q.pop();\n                if (done[s]) continue;\n                done[s] = true;\n                if (s == 0 || s == pow3[n] - 1)\n                {\n                    cout << ans << \"\\n\";\n                    found = true;\n                    break;\n                }\n                else if (ans == m)\n                {\n                    cout << \"-1\\n\";\n                    found = true;\n                    break;\n                }\n                s32 top[3] = {-1, -1, -1};\n                rep (i, n)\n                {\n                    int idx = (s / pow3[i]) % 3;\n                    top[idx] = i;\n                }\n                rep (i, 3)\n                {\n                    if (top[i] != -1)\n                    {\n                        rep (j, 3)\n                        {\n                            if (!(j == i + 1 || j == i - 1)) continue;\n                            if (top[j] == -1 || top[i] > top[j])\n                            {\n                                STATE ns{s};\n                                ns -= pow3[top[i]] * i;\n                                ns += pow3[top[i]] * j;\n                                if (!done[ns])\n                                {\n                                    q.push(ns);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (found) break;\n            ++ans;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0503\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint n, m;\n\nint solve(vector<int>& v, int x) {\n\tint ret = 0;\n\tfor (int i = 0; i < n;i++) {\n\t\tif (v[i] == 1) {\n\t\t\tret += pow(3, n - 1 - i);\n\t\t\tx ^= 2;\n\t\t}\n\t\telse if (v[i] != x) {\n\t\t\tret += 2 * pow(3, n - 1 - i);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> n >> m, n|| m) {\n\t\tvector<int> v(n);\n\t\tfor (int i = 0; i < 3;i++) {\n\t\t\tint c; cin >> c;\n\t\t\tfor (int j = 0; j < c; j++) { int x; cin >> x; v[x - 1] = i; }\n\t\t}\n\t\tint ans = min(solve(v, 0), solve(v, 2));\n\t\tcout << ((ans > m) ? -1 : ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> mat;\n\nint n, m;\n\nbool change(int &now, int &pre, mat &g, int d = 0) {\n    // cout << \"change \" << d << now << \" \" << pre << endl;\n    if (now == 1) {\n        auto s = g[1];\n        auto t = g[(pre == 0 ? 2 : 0)];\n        if (s.size() == 0) return false;\n        if (t.size() > 0 && t[t.size() - 1] > s[s.size() - 1]) {\n            if (d == 1) return false;\n            now = pre;\n            pre = 1;\n            // cout << \"miss 1: \" << now << \" \" << pre << endl;\n            return change(now, pre, g, 1);\n        }\n        t.push_back(s[s.size() - 1]);\n        s.erase(s.begin() + s.size() - 1);\n        g[1] = s;\n        g[(pre == 0 ? 2 : 0)] = t;\n        now = (pre == 0 ? 2 : 0);\n        pre = 1;\n\n        return true;\n    }\n    auto s = g[2 - now];\n    auto t = g[1];\n    if (s.size() == 0) return false;\n    if (t.size() > 0 && t[t.size() - 1] > s[s.size() - 1]) {\n        if (d == 1) return false;\n        pre = now;\n        now = 1;\n        // cout << \"miss !1 \" << now << \" \" << pre << endl;\n        return change(now, pre, g, 1);\n    }\n    t.push_back(s[s.size() - 1]);\n    s.erase(s.begin() + s.size() - 1);\n    g[2 - now] = s;\n    g[1] = t;\n    pre = 2 - now;\n    now = 1;\n\n    return true;\n}\n\nbool check(mat &g, mat &v) {\n    for (int i = 0; i < 3; i++) {\n        if (v[i].size() != g[i].size()) return false;\n        for (int j = 0; j < g[i].size(); j++)\n            if (g[i][j] != v[i][j]) return false;\n    }\n    return true;\n}\n\nvoid show(mat &g) {\n    cout << \"show:\" <<endl;\n    for (auto i : g) {\n        cout << \"* \";\n        for (auto j : i) {\n            cout << j << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    while (cin >> n >> m, n || m) {\n        mat v(3);\n        for (auto &i : v) {\n            int c; cin >> c;\n            for (int j = 0; j < c; j++) {\n                int x; cin >> x;\n                i.push_back(x);\n            }\n        }\n\n\n        mat g1(3), g2(3);\n        for (int i = 1; i <= n; i++) {\n            g1[0].push_back(i);\n            g2[2].push_back(i);\n        }\n        // cout << \"# g1\" ;\n        // show(g1);\n        // cout << \"# g2\" ;\n        // show(g2);\n        // cout << \"# v \" ;\n        // show(v);\n\n        int res = 1 << 28;\n        vector<int> now = {0, 1, 1, 2};\n        vector<int> pre = {1, 0, 2, 1};\n        for (int i = 0; i < 4; i++) {\n            int tmp = 0;\n            auto g(v);\n            // cout << \"i = \" << i << endl;\n            while (tmp <= m) {\n                // cout << \"# \" << tmp << endl;\n                // cout << \"pre inof \" << i << \" \" << now[i] << \" \" << pre[i] << \" \" << g[pre[i]].size() << endl;\n                if (check(g1, g) || check(g2, g)) break;\n                if (!change(now[i], pre[i], g)) {\n                    tmp = 1 << 28;\n                    break;\n                }\n                // cout << \"now info \" << i << \" \" << now[i] << \" \" << pre[i] << \" \" << g[pre[i]].size() << endl;\n                // show(g);\n                tmp++;\n            }\n            res = min(res, tmp);\n        }\n\n        // cout << \"ans = \";\n        cout << (res > m ? -1 : res) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint M, N, MM, tw[3][20], c1[15], c2[15];\n\nint min(int a, int b){\n    return a<b?a:b;\n}\n\nint abs(int a){\n    return a<0?-a:a;\n}\n\nvoid set(){\n    for(int x = 0; x < 15; x++){\n        c1[x] = 0;\n        c2[x] = 0;\n    }\n    for(int x = 1; x <= M; x++){\n        for(int y = 0; y < 20 && !(c1[x] && c2[x]); y++){\n            for(int z = 0; z < 3; z++){\n                if( tw[z][y] == x ){\n                    c1[x] = z;\n                    c2[x] = 2-z;\n                    break;\n                }\n            }\n        }\n    }\n}\n\nint count(int n,int d){\n    int a = 1;\n    while( n++ < M ) a *= 3;\n    return (a-1)*d + d;\n}\n        \nint solve(){\n    set();\n    int ans1 = 0, ans2 = 0;\n    for(int x = 1; x <= M; x++){\n        ans1 += count(x, c1[x]);\n        if(c1[x] == 1){\n            for(int y = x+1; y <= M; y++){\n                c1[y] = 2 - c1[y];\n            }\n        }\n        ans2 += count(x, c2[x]);\n        if(c2[x] == 1){\n            for(int y = x+1; y <= M; y++){\n                c2[y] = 2 - c2[y];\n            }\n        }\n    }\n    return min(ans1, ans2);\n}\n\nint main(){\n    cin >> M >> N;\n    while( M + N > 0 ){\n        for(int i = 0; i < 3; i++){\n            int j,k;\n            cin >> k;\n            for(j = 0; j < k; j++){\n                cin >> tw[i][j];\n            }\n            for(; j < 20; j++){\n                tw[i][j] = 0;\n            }\n        }\n        cout << solve() << endl;\n        cin >> M >> N;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint mypow(int x,int n){\n\tint res = 1;\n\twhile(n>0){\t\t\n\t\tif(n & 1) res = res*x;\n\t\tx = x * x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\n\nint conv(vector<int>& sets,int n){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * mypow(3,j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,int n,vector<int>& root,bool* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root,n)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(!visited[(next = conv(tmp,n))]){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(!visited[(next = conv(tmp,n))]){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tbool* visited = new bool[mypow(3,n)]();\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,n,sets,visited));\n\t\tdelete[] visited;\n\t}\n\t//printf(\"%d %d %d\\n\",mypow(3,0),mypow(3,1),mypow(3,2));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<utility>\n#include<vector>\nusing namespace std;\nint n, m, na, nb, nc, tyo, place[16],ans;\nint cup[3][16];\nint c1();\nint c2();\nint main() {\n\tint ans1, ans2;\n\n\twhile (1) {\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tfor (int j = 0; j < 16; ++j)\n\t\t\t\tcup[i][j] = 0;\n\t\t}\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\t\tcin >> na;\n\t\tfor (int i = 0; i < na; ++i) cin >> cup[0][i];\n\t\tcin >> nb;\n\t\tfor (int i = 0; i < nb; ++i)cin >> cup[1][i];\n\t\tcin >> nc;\n\t\tfor (int i = 0; i < nc; ++i)cin >> cup[2][i];\n\t\t/*\n\t\tif (cup[0][0] == 1)place[0] = 0;\n\t\telse if (cup[2][0] == 1)place[0] = 2;\n\t\telse if (cup[0][0] == 0)place[0] = 0;\n\t\telse if (cup[2][0] == 0)place[0] = 2;\n\t\telse if (cup[0][0] > cup[2][0])place[0] = 0;\n\t\telse place[0] = 2;\n\t\t*/\n\t\tfor (int p = 0; p < 2; ++p) {\n\t\t\ttyo = 0;\n\t\t\tif (p == 0)place[0] = 0;\n\t\t\telse place[0] = 2;\n\t\t\tint np;\n\t\t\tif (place[0] == 0)np = 2;\n\t\t\telse np = 0;\n\t\t\tfor (int k = 1; k < 16; ++k) {\n\t\t\t\tplace[k] = place[0];\n\t\t\t}\n\t\t\tbool bo = false; int at, ar;\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\tfor (int j = 0; j < na; ++j) {\n\t\t\t\t\tif (cup[0][j] == i) {\n\t\t\t\t\t\tat = 0;\n\t\t\t\t\t\tar = j;\n\t\t\t\t\t\tbo = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < nb; ++j) {\n\t\t\t\t\tif (bo)break;\n\t\t\t\t\tif (cup[1][j] == i) {\n\t\t\t\t\t\tat = 1;\n\t\t\t\t\t\tar = j;\n\t\t\t\t\t\tbo = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < nc; ++j) {\n\t\t\t\t\tif (bo)break;\n\t\t\t\t\tif (cup[2][j] == i) {\n\t\t\t\t\t\tat = 2;\n\t\t\t\t\t\tar = j;\n\t\t\t\t\t\tbo = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbo = false;\n\t\t\t\tif (at == place[i]) {\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (at == 1) {\n\t\t\t\t\t\ttyo += pow(3, n - i);\n\t\t\t\t\t\tfor (int k = i + 1; k < 16; ++k) {\n\t\t\t\t\t\t\tif (place[k] == 0)place[k] = 2;\n\t\t\t\t\t\t\telse place[k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttyo += 2 * (pow(3, n - i));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (p == 0)ans1 = tyo;\n\t\t\telse ans2 = tyo;\n\t\t}\n\t\tif (m < min(ans1,ans2))cout << -1 << endl;\n\t\t\telse cout << min(ans1,ans2) << endl;\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <map>\nusing namespace std;\n#define F first\n#define S second\nconst int INF=100000000;\n\nint ans;\nunsigned int n,m;\n\nvoid dfs(stack<int> s[],int count,pair<int,int> f){\n\t/*\n\tfor(int i=0; i<3; ++i){\n\t\tif(s[i].size()!=0)cout << s[i].top() << \" \";\n\t}\n\tcout << endl;\n\tcout << count << \" \" << f.F << \" \" << f.S << endl;\n\t*/\n\tif(count>m) return;\n\tif(s[0].size()==n||s[2].size()==n){\n\t\tans=min(ans,count);\n\t\treturn;\n\t}\n\t//f.F -->f.S\n\t//01 10 12 21\n\tif(!(f.F==1&&f.S==0)&&s[0].size()!=0&&(s[1].size()==0||s[0].top()>s[1].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[1].push(ns[0].top());\n\t\tns[0].pop();\n\t\tdfs(ns,count+1,pair<int,int>(0,1));\n\t}\n\tif(!(f.F==0&&f.S==1)&&s[1].size()!=0&&(s[0].size()==0||s[1].top()>s[0].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[0].push(ns[1].top());\n\t\tns[1].pop();\n\t\tdfs(ns,count+1,pair<int,int>(1,0));\n\t}\n\tif(!(f.F==2&&f.S==1)&&s[1].size()!=0&&(s[2].size()==0||s[1].top()>s[2].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[2].push(ns[1].top());\n\t\tns[1].pop();\n\t\tdfs(ns,count+1,pair<int,int>(1,2));\n\t}\n\tif(!(f.F==1&&f.S==2)&&s[2].size()!=0&&(s[1].size()==0||s[2].top()>s[1].top())){\n\t\tstack<int> ns[3];\n\t\tfor(int i=0; i<3; ++i) ns[i]=s[i];\n\t\tns[1].push(ns[2].top());\n\t\tns[2].pop();\n\t\tdfs(ns,count+1,pair<int,int>(2,1));\n\t}\n}\n\nint main(){\n\twhile(cin >> n >> m){\n\tif(n==0&&m==0) break;\n\t\tans=INF;\n\t\tstack<int> cup[3];\n\t\tfor(int i=0; i<3; ++i){\n\t\t\tint q;\n\t\t\tcin >> q;\n\t\t\tfor(int j=0; j<q; ++j){\n\t\t\t\tint tmp;\n\t\t\t\tcin >> tmp;\n\t\t\t\tcup[i].push(tmp);\n\t\t\t\t//cout << cup[i].top() << endl;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\tdfs(cup,0,pair<int,int>(0,1));\n\t\tdfs(cup,0,pair<int,int>(1,0));\n\t\tdfs(cup,0,pair<int,int>(1,2));\n\t\tdfs(cup,0,pair<int,int>(2,1));\n\t\tif(ans!=INF) cout << ans << endl;\n\t\telse cout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nclass P{\n\tpublic:\n\tint cnt;\n\tstack< int > S[3];\n};\n\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m),(n|m)){\n\t\tP f;\n\t\tfor(int i = 0;i < 3; i++){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d\",&tmp);\n\t\t\t\tf.S[i].push(tmp);\n\t\t\t}\n\t\t}\n\t\tf.cnt = 0;\n\t\tqueue< P > Q;\n\t\tQ.push(f);\n\t\tbool flg = true;\n\t\twhile( !Q.empty()){\n\t\t\tP p = Q.front();Q.pop();\n\t\t\tif(p.cnt > m){\n\t\t\t\tflg = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbool h = false;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tif(i == 1)continue;\n\t\t\t\tif(p.S[i].size() == n){\n\t\t\t\t\tprintf(\"%d\\n\",p.cnt);\n\t\t\t\t\th = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( h ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint top0 = (p.S[0].size()>0)?p.S[0].top() : 0;\n\t\t\tint top1 = (p.S[1].size()>0)?p.S[1].top() : 0;\n\t\t\tint top2 = (p.S[2].size()>0)?p.S[2].top() : 0;\n\t\t\tint copy0 = top0 , copy1 = top1 , copy2 = top2;\n\t\t\tP sub;\n\t\t\tsub.cnt = p.cnt+1;\n\t\t\tif(top0 < top1){\n\t\t\t\tp.S[1].pop();\n\t\t\t\tp.S[0].push(top1);\n\t\t\t\tfor(int i = 0; i < 3; i++)sub.S[i] = p.S[i];\n\t\t\t\tQ.push(sub);\n\t\t\t\tp.S[0].pop();\n\t\t\t\tp.S[1].push(copy1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp.S[0].pop();\n\t\t\t\tp.S[1].push(top0);\n\t\t\t\tfor(int i = 0; i < 3; i++)sub.S[i] = p.S[i];\n\t\t\t\tQ.push(sub);\n\t\t\t\tp.S[1].pop();\n\t\t\t\tp.S[0].push(copy0);\n\t\t\t}\n\t\t\tif(top1 < top2){\n\t\t\t\tp.S[2].pop();\n\t\t\t\tp.S[1].push(top2);\n\t\t\t\tfor(int i = 0;i < 3; i++)sub.S[i] = p.S[i];\n\t\t\t\tQ.push(sub);\n\t\t\t\tp.S[1].pop();\n\t\t\t\tp.S[2].push(copy2);\n\t\t\t}\n\t\t\telse {\t\n\t\t\t\tp.S[1].pop();\n\t\t\t\tp.S[2].push(top1);\n\t\t\t\tfor(int i = 0; i < 3; i++)sub.S[i] = p.S[i];\n\t\t\t\tQ.push(sub);\n\t\t\t\tp.S[2].pop();\n\t\t\t\tp.S[1].push(copy1);\n\t\t\t}\n\t\t}\n\t\tif( !flg )puts(\"-1\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <queue>\n\n#define INF 300000000\n\nusing namespace std;\n\nint n, m;\nint *used;\n\nint main(int argc, char const* argv[])\n{\n\tcin >> n >> m;\n\twhile(n != 0 || m != 0){\n\t\t\tused = new int[int(pow(3, n))];\n\t\t\tfor(int i = 0; i < pow(3, n); i++){\n\t\t\t\t\tused[i] = INF;\n\t\t\t}\n\t\t\tint ini = 0;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tint a;\n\t\t\t\t\tcin >> a;\n\t\t\t\t\tfor(int j = 0; j < a; j++){\n\t\t\t\t\t\t\tint b;\n\t\t\t\t\t\t\tcin >> b;\n\t\t\t\t\t\t\tini += i * int(pow(3, b - 1));\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<int> q;\n\t\t\tq.push(ini);\n\t\t\tused[ini] = 0;\n\t\t\twhile(!q.empty()){\n\t\t\t\t\tint p = q.front(); q.pop();\n\t\t\t\t\tif(p == 0 || p == int(pow(3, n)) - 1){\n\t\t\t\t\t\t\tcout << used[p] << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(used[p] > m){\n\t\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint a[3];\n\t\t\t\t\ta[0] = -1;\n\t\t\t\t\ta[1] = -1;\n\t\t\t\t\ta[2] = -1;\n\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\t\ta[(p % int(pow(3, i + 1)) - p % int(pow(3, i))) / int(pow(3, i))] = i;\n\t\t\t\t\t}\n\t\t\t\t\tif(a[0] != -1){\n\t\t\t\t\t\t\tif(a[1] == -1 || a[0] > a[1]){\n\t\t\t\t\t\t\t\t\tint pp = p;\n\t\t\t\t\t\t\t\t\tpp += int(pow(3, a[0]));\n\t\t\t\t\t\t\t\t\tif(used[pp] == INF){\n\t\t\t\t\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\t\t\t\t\tused[pp] = used[p] + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a[2] != -1){\n\t\t\t\t\t\t\tif(a[1] == -1 || a[2] > a[1]){\n\t\t\t\t\t\t\t\t\tint pp = p;\n\t\t\t\t\t\t\t\t\tpp -= int(pow(3, a[2]));\n\t\t\t\t\t\t\t\t\tif(used[pp] == INF){\n\t\t\t\t\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\t\t\t\t\tused[pp] = used[p] + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a[1] != -1){\n\t\t\t\t\t\t\tif(a[0] == -1 || a[1] > a[0]){\n\t\t\t\t\t\t\t\t\tint pp = p;\n\t\t\t\t\t\t\t\t\tpp -= int(pow(3, a[1]));\n\t\t\t\t\t\t\t\t\tif(used[pp] == INF){\n\t\t\t\t\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\t\t\t\t\tused[pp] = used[p] + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(a[2] == -1 || a[1] > a[2]){\n\t\t\t\t\t\t\t\t\tint pp = p;\n\t\t\t\t\t\t\t\t\tpp += int(pow(3, a[1]));\n\t\t\t\t\t\t\t\t\tif(used[pp] == INF){\n\t\t\t\t\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\t\t\t\t\tused[pp] = used[p] + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tdelete used;\n\t\t\tcin >> n >> m;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FORE(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\nusing namespace std;\ntypedef deque<int> vi;\nconst int INF=1<<30;\nint tar[2]{0,2};\nint n,m,num,tmp;\nint get(vi use[3],int n){\n\tREP(i,3)\n\t\tREP(j,use[i].size())\n\t\t\tif(use[i][j]==n)\n\t\t\t\treturn i;\n}\nint search(vi use[3],int goal,int target){\n\tif(target>n)\n\treturn 0;\n\tint b=get(use,target);\n\tint ans=0;\n\tif(b==tar[goal])\n\t\tans= search(use,goal,target+1);\n\telse if(b==tar[goal^1]){\n\t\tans+=search(use,goal,target+1);\n\t\tans++;\n\t\tuse[b].pop_back();\n\t\tuse[1].push_back(target);\n\t\tb=1;\n\t}\n\tif(b==1){\n\t\tans+=search(use,goal^1,target+1);\n\t\tuse[b].pop_back();\n\t\tuse[tar[goal]].push_back(target);\n\t\tans++;\n\t\tans+=search(use,goal,target+1);\n\t}\n\treturn ans;\n}\nint main() {\n\twhile(cin >> n >> m && n){\n\tvi cups[3];\n\tREP(i,3){\n\t\tcin >> num;\n\t\tREP(j,num){\n\t\t\tcin >> tmp;\n\t\t\tcups[i].push_back(tmp);\n\t\t}\n\t}\n\tint score=INF;\n\tREP(j,2){\n\tint target=1,sscore=0;\n\tvi use[3];\n\tREP(i,3)\n\t\tuse[i]=vi(cups[i]);\n\t\tsscore+=search(use,j,1);\n\t\tscore=min(score,sscore);\n\t}\n\tif(score>m)\n\tcout << \"-1\" << endl;\n\telse\n\tcout << score << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n\nint n, m, cnt, a[16], b[16];\nbool flag;\n\nvoid move(int num, int dest, int* a);\n\nint main() {\n\t\n\twhile (1) {\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0)break;\n\n\t\tint numt, tmp;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcin >> numt;\n\t\t\tfor (int j = 0; j < numt; j++) {\n\t\t\t\tcin >> tmp;\n\t\t\t\ta[tmp] = i;\n\t\t\t\tb[tmp] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans1, ans2;\n\n\t\tcnt = 0;\n\t\tflag = true;\n\t\tfor (int num = 1; num <= n; num++) {\n\t\t\tmove(num, 2, a);\n\t\t}\n\t\tif (flag == true) {\n\t\t\tans1 = cnt;\n\t\t} else {\n\t\t\tans1 = -1;\n\t\t}\n\n\t\tcnt = 0;\n\t\tflag = true;\n\t\tfor (int num = 1; num <= n; num++) {\n\t\t\tmove(num, 0, b);\n\t\t}\n\t\tif (flag == true) {\n\t\t\tans2 = cnt;\n\t\t} else {\n\t\t\tans2 = -1;\n\t\t}\n\n\n\t\tint ans;\n\t\tif (ans1 == -1) {\n\t\t\tans = ans2;\n\t\t} else if(ans2 == -1){\n\t\t\tans = ans1;\n\t\t} else {\n\t\t\tans = min(ans1, ans2);\n\t\t}\n\t\tcout << ans1 << \" \" << ans2 << endl;\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn 0;\n}\n\nvoid move(int num, int dest, int* a) {\n\t\n\tif (cnt > m || flag == false) {\n\t\tflag = false;\n\t\treturn;\n\t}\n\n\tint dist = abs(dest - a[num]);\n\tif (dist == 0) {\n\t\treturn;\n\t} else if (dist == 1) {\n\t\tif (num == n) {\n\t\t\tcnt += 1;\n\t\t\ta[num] = dest;\n\t\t} else {\n\t\t\tint i = 1;\n\t\t\twhile (num + i <= n) {\n\t\t\t\tmove(num + i, 3 - dest - a[num], a);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tcnt += 1;\n\t\t\ta[num] = dest;\n\t\t}\n\t} else if (dist == 2) {\n\t\tif (num == n) {\n\t\t\tcnt += 2;\n\t\t\ta[num] = dest;\n\t\t} else {\n\t\t\tmove(num, 1, a);\n\t\t\tmove(num, dest, a);\n\t\t}\n\t}\n\n\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n\nnamespace std {\n    template<typename T> bool operator<(const stack<T>& a, const stack<T>& b){\n        if (a.size() != b.size()) return a.size()<b.size();\n        for (auto ta = a, tb = b; !ta.empty(); ta.pop(), tb.pop()){\n            auto &ea = a.top(), &eb = b.top();\n            if (ea != eb) return ea < eb;\n        }\n        return false;\n    }\n}\n\nstruct state {\n    stack<int> cup[3];\n    unsigned d;\n    stack<int>& operator[](int i){\n        return cup[i];\n    }\n    bool able(int f, int t){\n        return cup[f].size()>0 &&\n            (cup[t].size() == 0 || cup[t].top()<cup[f].top());\n    }\n    void move(int f, int t){\n        cup[t].push(cup[f].top());\n        cup[f].pop();\n    }\n    bool operator<(const state &s)const{\n        rep(i, 3){\n            if (cup[0] != s.cup[0]) return cup[0]<s.cup[0];\n            if (cup[1] != s.cup[1]) return cup[1]<s.cup[1];\n            if (cup[2] != s.cup[2]) return cup[2]<s.cup[2];\n        }\n        return false;\n    }\n};\n\nunsigned n, m;\nqueue<state> q;\nset<state> vis;\n\nint main(){\n    while (cin >> n >> m, n || m){\n        state init;\n        rep(i, 3){\n            int k; cin >> k;\n            rep(j, k){\n                int t; cin >> t;\n                init[i].push(t);\n            }\n        }\n        init.d = 0;\n        bool able = true;\n        int ans;\n        q.push(init);\n        while (q.size()){\n            state s = q.front();\n            q.pop();\n            if (vis.count(s)) continue;\n            else vis.insert(s);\n            if (s.d > m){\n                able = false;\n                break;\n            }\n            if (s[0].size() == n || s[2].size() == n){\n                ans = s.d;\n                break;\n            }\n            if (s.able(0, 1)){\n                s.move(0, 1); s.d++;\n                q.push(s);\n                s.move(1, 0); s.d--;\n            }\n            if (s.able(1, 0)){\n                s.move(1, 0); s.d++;\n                q.push(s);\n                s.move(0, 1); s.d--;\n            }\n            if (s.able(1, 2)){\n                s.move(1, 2); s.d++;\n                q.push(s);\n                s.move(2, 1); s.d--;\n            }\n            if (s.able(2, 1)){\n                s.move(2, 1); s.d++;\n                q.push(s);\n                s.move(1, 2); s.d--;\n            }\n        }\n        cout << (able ? ans : -1) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\nenum class MovePos\n{\n\tMoveLeftToCenter,\n\tMoveRightToCenter,\n\tMoveCenterToLeft,\n\tMoveCenterToRight\n};\n\nclass Tray\n{\npublic:\n\tstack<int> t[3];\n\tinline bool isCompleted()\n\t{\n\t\tif (t[0].empty() && t[1].empty()) return true;\n\t\tif (t[1].empty() && t[2].empty()) return true;\n\t\treturn false;\n\t}\n\tinline bool canMoveLeftToCenter()\n\t{\n\t\tif (t[0].empty()) return false;\n\t\tif (t[1].empty()) return true;\n\t\tif (t[0].top() > t[1].top()) return true;\n\t\treturn false;\n\t}\n\tinline bool canMoveRightToCenter()\n\t{\n\t\tif (t[2].empty()) return false;\n\t\tif (t[1].empty()) return true;\n\t\tif (t[2].top() > t[1].top()) return true;\n\t\treturn false;\n\t}\n\tinline bool canMoveCenterToLeft()\n\t{\n\t\tif (t[1].empty()) return false;\n\t\tif (t[0].empty()) return true;\n\t\tif (t[1].top() > t[0].top()) return true;\n\t\treturn false;\n\t}\n\tinline bool canMoveCenterToRight()\n\t{\n\t\tif (t[1].empty()) return false;\n\t\tif (t[2].empty()) return true;\n\t\tif (t[1].top() > t[2].top()) return true;\n\t\treturn false;\n\t}\n\tinline void MoveLeftToCenter()\n\t{\n\t\tint top = t[0].top();\n\t\tt[0].pop();\n\t\tt[1].push(top);\n\t}\n\tinline void MoveRightToCenter()\n\t{\n\t\tint top = t[2].top();\n\t\tt[2].pop();\n\t\tt[1].push(top);\n\t}\n\tinline void MoveCenterToLeft()\n\t{\n\t\tint top = t[1].top();\n\t\tt[1].pop();\n\t\tt[0].push(top);\n\t}\n\tinline void MoveCenterToRight()\n\t{\n\t\tint top = t[1].top();\n\t\tt[1].pop();\n\t\tt[2].push(top);\n\t}\n};\n\nint calc(Tray t, MovePos previousMovePos, int m)\n{\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tif (i % 100000 == 0) cout << i << endl;\n\t\tif (t.isCompleted()) return i;\n\t\tif (t.canMoveLeftToCenter() && previousMovePos != MovePos::MoveCenterToLeft)\n\t\t{\n\t\t\tt.MoveLeftToCenter();\n\t\t\tpreviousMovePos = MovePos::MoveLeftToCenter;\n\t\t}\n\t\telse if (t.canMoveRightToCenter() && previousMovePos != MovePos::MoveCenterToRight)\n\t\t{\n\t\t\tt.MoveRightToCenter();\n\t\t\tpreviousMovePos = MovePos::MoveRightToCenter;\n\t\t}\n\t\telse if (t.canMoveCenterToLeft() && previousMovePos != MovePos::MoveLeftToCenter)\n\t\t{\n\t\t\tt.MoveCenterToLeft();\n\t\t\tpreviousMovePos = MovePos::MoveCenterToLeft;\n\t\t}\n\t\telse if (t.canMoveCenterToRight() && previousMovePos != MovePos::MoveRightToCenter)\n\t\t{\n\t\t\tt.MoveCenterToRight();\n\t\t\tpreviousMovePos = MovePos::MoveCenterToRight;\n\t\t}\n\t\tif (i > 1251598) return 99999999;\n\t}\n\treturn 99999999;\n}\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n + m)\n\t{\n\t\tTray tray;\n\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tint a, b;\n\t\t\tcin >> a;\n\t\t\tfor (int j = 0; j < a; j++)\n\t\t\t{\n\t\t\t\tcin >> b;\n\t\t\t\ttray.t[i].push(b);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 99999999;\n\t\tif (tray.canMoveCenterToLeft())\n\t\t{\n\t\t\tTray t = tray;\n\t\t\tt.MoveCenterToLeft();\n\t\t\tans = min(ans, calc(t, MovePos::MoveCenterToLeft, m));\n\t\t}\n\t\tif (tray.canMoveCenterToRight())\n\t\t{\n\t\t\tTray t = tray;\n\t\t\tt.MoveCenterToRight();\n\t\t\tans = min(ans, calc(t, MovePos::MoveCenterToRight, m));\n\t\t}\n\t\tif (tray.canMoveLeftToCenter())\n\t\t{\n\t\t\tTray t = tray;\n\t\t\tt.MoveLeftToCenter();\n\t\t\tans = min(ans, calc(t, MovePos::MoveLeftToCenter, m));\n\t\t}\n\t\tif (tray.canMoveRightToCenter())\n\t\t{\n\t\t\tTray t = tray;\n\t\t\tt.MoveRightToCenter();\n\t\t\tans = min(ans, calc(t, MovePos::MoveRightToCenter, m));\n\t\t}\n\t\tif (ans == 99999999) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\nusing namespace std;\n\nclass state{\npublic:\n  stack<int>* tray;\n  int cnt;\n  state(stack<int> a, stack<int> b, stack<int> c, int cnt){\n    tray = new stack<int>[3];\n    tray[0] = a;\n    tray[1] = b;\n    tray[2] = c;\n    this->cnt = cnt;\n  }\n\n  state(){\n    tray = new stack<int>[3];\n    cnt = 0;\n  }\n\n  state(const state &ob){\n    tray = new stack<int>[3];\n    for(int i=0; i<3; i++) tray[i] = ob.tray[i];\n    cnt = ob.cnt;\n  }\n\n  ~state(){\n    delete[] tray;\n  }\n\n  bool operator < (const state& s) const {\n    bool f=false;\n    for(int i=0; i<3; i++) f = f || (tray[i]!=s.tray[i]);\n    return f;\n  }\n\n  void init(){\n    for(int i=0; i<3; i++){\n      int n; cin >> n;\n      int cup;\n      for(int j=0; j<n; j++){\n        cin >> cup;\n        tray[i].push(cup);\n      }\n    }\n  }\n\n  //i番目のトレイからj番目に移動できるかを返す\n  bool canChange(int i, int j){\n    int sizei=tray[i].size(), sizej=tray[j].size();\n    if(sizei==0) return false;\n    if(sizej==0) return true;\n\n    if(tray[i].top()>tray[j].top()) return true;\n    else return false;\n  }\n\n  //i番目のトレイのカップをj番目のトレイに入れ替えたstateを返す\n  state change(int i, int j){\n    state ex = state(tray[0], tray[1], tray[2], cnt+1);\n    int cup=ex.tray[i].top(); ex.tray[i].pop();\n\n    ex.tray[j].push(cup);\n    return ex;\n  }\n};\n\nint solve(int, int, state);\n\nint main(){\n  int n, m; //カップ数 手数\n  while(cin >> n >> m, n!=0 && m!=0){\n    state first;\n    first.init();\n    int dis=solve(n, m, first);\n    cout << dis << endl;\n  }\n\n  return 0;\n}\n\n\n\nint solve(int n, int m, state first){\n  queue<state> q;\n  q.push(first);\n  map<state, bool> mp;\n\n  int ans=-1;\n\n  while(!q.empty()){\n    state now = q.front(); q.pop();\n    //もし手数をオーバーしたなら、-1を格納して終了\n    if(now.cnt>m){\n      ans = -1;\n      break;\n    }\n\n    //もし条件を満たしているなら、手数を格納して終了\n    if(now.tray[0].size()==n || now.tray[2].size()==n){\n      ans = now.cnt;\n      break;\n    }\n\n    //もし調査済みならcontinue\n    if(mp[now]) continue;\n    mp[now] = true;\n\n    //隣り合う2つのカップで移動\n    for(int i=0; i<2; i++){\n      if(now.canChange(i, i+1)) {\n        q.push(now.change(i, i+1));\n      }\n      if(now.canChange(i+1, i)){\n        q.push(now.change(i+1, i));\n      }\n    }\n  }\n\n  return ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tll dp[16] = {};\n\tdp[0] = 1;\n\trep(i,1, n+1) {\n\t\tdp[i] = dp[i - 1] * 3;\n\t}\n\tvector<int> pos(n);\n\tREP(i, 3) {\n\t\tint c;\n\t\tscanf(\"%d\", &c);\n\n\n\t\tREP(j, c) {\n\t\t\tint size;\n\t\t\tscanf(\"%d\", &size);\n\n\t\t\tpos[size-1] = i;\n\t\t}\n\t}\n\t//reverse(ALL(pos));\n\tll ans = 0,ans2 = 0;\n\tbool curs = 0;\n\tREP(i, n) {\n\t\tif (pos[i] % 2) {\n\t\t\tans += dp[n - i - 1];\n\t\t\tcurs = 1-curs;\n\t\t}\n\t\telse if (curs*2-pos[i]) {\n\t\t\tans += dp[n - i - 1] + 1;\n\t\t}\n\t}\n\tbool curs = 1;\n\tREP(i, n) {\n\t\tif (pos[i] % 2) {\n\t\t\tans2 += dp[n - i - 1];\n\t\t\tcurs = 1 - curs;\n\t\t}\n\t\telse if (curs * 2 - pos[i]) {\n\t\t\tans2 += dp[n - i - 1] + 1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", min(ans2, ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<stack>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\nint n,m;\nstruct state{\n  vector<int> st[3];\n  int co;\n  state(){\n    for(int i=0;i<3;i++){\n      while(!st[i].empty()) st[i].pop_back();\n    }\n  }\n  void print(){\n    for(int i=0;i<3;i++){\n      if(st[i].empty()){\n\tprintf(\"[%d]...empty\\n\",i);\t\n\tcontinue;\n      }\n      printf(\"[%d]...size=%d  back()=%d\\n\",i,(int)st[i].size(),st[i].back());\n    }\n    sleep(1);\n  }\n};\nmap<int,map<int,map<int,int> > > M;\nbool check(state p){\n    int a[3]={};\n    for(int i=0;i<3;i++){\n      for(int j=0;j<(int)p.st[i].size();j++){\n\ta[i] |= (1<<p.st[i][j]); \n      }\n    }\n    if(M[a[0]][a[1]][a[2]]!=0) return false;\n    M[a[0]][a[1]][a[2]]=1;\n    return true;\n}\nint solve(state s){\n  queue<state> q;\n  while(!q.empty()) q.pop();\n  q.push(s);\n  check(s);\n  while(!q.empty()){\n    state p = q.front(); q.pop();\n    //    p.print();\n    int c=p.co;\n    if(c>m) break;\n    if((int)p.st[0].size()==n || (int)p.st[2].size()==n) return c;\n    p.co++;\n    state tmp = p;\n    if( !p.st[0].empty() && p.st[1].empty() ){\n      goto change1;\n    }else if( p.st[0].empty() && !p.st[1].empty()){\n      goto change2;\n    }\n    if(!p.st[0].empty() && !p.st[1].empty()){\n      if(p.st[0].back() > p.st[1].back()){\n      change1:\n\ttmp.st[1].push_back(tmp.st[0].back());\n\ttmp.st[0].pop_back();\n\tif(check(tmp))\n\t  q.push(tmp);\n\ttmp = p;\n      } else {\n      change2:\n\ttmp.st[0].push_back(tmp.st[1].back());\n\ttmp.st[1].pop_back();\n\tif(check(tmp))\n\t  q.push(tmp);\n\ttmp = p;\n      }\n    }\n\n    if( !p.st[1].empty() && p.st[2].empty() ){\n      goto change3;\n    }else if( p.st[1].empty() && !p.st[2].empty()){\n      goto change4;\n    }    \n    if( !p.st[1].empty() && !p.st[2].empty() ){\n      if(p.st[1].back() > p.st[2].back()){\n      change3:\n\ttmp.st[2].push_back(tmp.st[1].back());\n\ttmp.st[1].pop_back();\n\tif(check(tmp))\n\t  q.push(tmp);\n\ttmp = p;\n      } else {\n      change4:\n\ttmp.st[1].push_back(tmp.st[2].back());\n\ttmp.st[2].pop_back();\n\tif(check(tmp))\n\t  q.push(tmp);\n\ttmp = p;\n      }\n    }\n\n  }\n  return -1;\n}\nmain(){\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    if(!n && !m)break;\n    state s;\n    for(int i=0;i<3;i++){\n      int p;\n      scanf(\"%d\",&p);\n      for(int j=0;j<p;j++){\n\tint e;\n\tscanf(\"%d\",&e);\n\ts.st[i].push_back(e);\n      }\n    }\n  //  s.print();\n    s.co=0;\n    printf(\"%d\\n\",solve(s));\n    M.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nint dp[14400000];\nint N, M;\nint to_hash(const vector<int>&nums) {\n\tint hash = 0;\n\tfor (auto n : nums) {\n\t\thash = 3 * hash + n;\n\t}\n\treturn hash;\n}\nint getans(vector<int>&nums, int now) {\n\tint hash = to_hash(nums);\n\tif (dp[hash] == -2) {\n\t\treturn M;\n\t}\n\tif (dp[hash] == -1) {\n\t\tif (now >= M)return M;\n\t\tif (to_hash(nums) == 0) {\n\t\t\treturn now;\n\t\t}\n\t\telse {\n\t\t\tdp[hash] = -2;\n\t\t\tvector<int>tops(3, -1);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\ttops[nums[i]] = i;\n\t\t\t}\n\t\t\tint ans = M;\n\t\t\tif (tops[0] < tops[1]) {\n\t\t\t\tif (tops[1] != -1) {\n\t\t\t\t\tnums[tops[1]] = 0;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tops[0] != -1) {\n\t\t\t\t\tnums[tops[0]] = 1;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[0]] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tops[1] < tops[2]) {\n\t\t\t\tif (tops[2] != -1) {\n\t\t\t\t\tnums[tops[2]] = 1;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[2]] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tops[1] != -1) {\n\t\t\t\t\tnums[tops[1]] = 2;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[hash] = ans;\n\t\t}\n\t}\n\telse {\n\t\treturn dp[hash];\n\t}\n\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 14400000; ++i) {\n\t\t\tdp[i] = -1;\n\t\t} cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<int>nows(N);\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tfor (int j = 0; j < a; ++j) {\n\t\t\t\tint b; cin >> b; b--;\n\t\t\t\tnows[b] = i;\n\t\t\t}\n\t\t}\n\t\tint ans = getans(nows, 0);\n\t\tif (ans == M)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\nconst int NONE = -1;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    /*\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        {\n            int u = get_last(B);\n            int v = get_last(A);\n            if ( u > v ) {\n                int ret = solve( A | u, remove_last(B), C, turns + 1 );\n                if ( ret != NONE ) return ret;\n            }\n        }\n        {\n            int u = get_last(B);\n            int v = get_last(C);\n            if ( u > v ) {\n                int ret = solve( A, remove_last(B), C | u, turns + 1 );\n                if ( ret != NONE ) return ret;\n            }\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    */\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == NONE && ret2 == NONE ) {\n            cout << -1 << endl;\n        } else if ( ret1 != NONE && ret2 != NONE ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != NONE ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != NONE ) {\n            cout << ret2 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint size[3];\nint dat[3][15];\nint val[3];\nint now[3][15];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a+b){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint c;\n\t\t\tscanf(\"%d\",&c);\n\t\t\tsize[i]=c;\n\t\t\tfor(int j=0;j<c;j++)scanf(\"%d\",dat[i]+j);\n\t\t}\n\t\tint ret=999999999;\n\t\tif(size[0]==a||size[2]==a)ret=0;\n\t\tfor(int m=0;m<2;m++){\n\t\t\tint last=m;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tval[i]=size[i];\n\t\t\t\tfor(int j=0;j<size[i];j++)now[i][j]=dat[i][j];\n\t\t\t}\n\t\t\tint k=0;\n\t\t\twhile(k<=b&&val[0]!=a&&val[2]!=a){\n\t\t\t\tif(val[last]==0||now[last][val[last]-1]<now[last+1][val[last+1]-1]){\n\t\t\t\t\tnow[last][val[last]++]=now[last+1][--val[last+1]];\n\t\t\t\t}else{\n\t\t\t\t\tnow[last+1][val[last+1]++]=now[last][--val[last]];\n\t\t\t\t}\n\t\t\t\tlast=!last;\n\t\t\t\tk++;\n\t\t//\t\tprintf(\"%d %d %d\\n\",val[0],val[1],val[2]);\n\t\t\t}\n\t\t\tif(val[0]==a||val[2]==a)ret=min(ret,k);\n\t\t}\n\t\tif(ret==999999999)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<utility>\n#include<vector>\nusing namespace std;\nvoid input();\nvoid solve();\nvoid saiki(int,int,int,int,int);\nvoid narabi();\nint px,py;\nint n,m,o,na,nb,nc,ans=0,ch;\npair<int,int>at;\nbool sw=false;\nint place=-1;\nint cup[3][10001]={0};\npair<int,int>maxi;\nint main(){\n    while(1){\n        cin>>n>>m;\n        if(n==0 && m==0)break;\n        input();\n        solve();\n        if(ans<m){\n            cout<<ans<<endl;\n        }\n        else{\n            cout<<-1<<endl;\n        }\n        ans=0;\n    }\n    return 0;\n}\nvoid saiki(int i,int targetx,int targety,int tox,int toy){\n    sw=false;\n    while(1){\n    if(cup[targetx][targety+1]!=0){\n        saiki(i+1,targetx,targety+1,tox,toy);\n    }\n        \n    if(cup[tox][toy]>cup[targetx][targety]) {\n        int i=0,count=0;\n        while(1){\n            if(cup[1][i]!=0){\n                count++;\n            }\n            else break;\n            i++;\n        }\n        saiki(i+1,targetx,targety,1,count);\n        if(i==0){sw=true;}\n    }\n    swap(cup[targetx][targety],cup[tox][toy]);\n        if(targetx>tox){\n        ans+=targetx-tox;\n    }\n    else{\n        ans+=tox-targetx;\n    }\n        if(sw){\n            int i=0,count=0;\n            while(1){\n                if(cup[1][i]!=0){\n                    count++;\n                }\n                else break;\n                i++;\n            }\n            targetx=1;\n            targety=count-1;\n            sw=false;\n        }\n            if(cup[px][py]==ch||i!=0)break;\n    }\n    return ;\n}\nvoid solve(){\n    bool bo;\n    //placeの確定\n    if(cup[0][0]==1){\n        place=0;\n    }\n    else if(cup[2][0]==1){\n        place=2;\n    }\n    else if(cup[0][0]==0){\n        place=0;\n    }\n    else if(cup[2][0]==0){\n        place=2;\n    }\n    else{\n        if(na>nc){\n            place=0;\n        }\n        else place=2;\n    }\n    int sp,u;\n    if(place==0){\n        sp=2;\n        u=nc;\n        }\n        else{\n            sp=0;\n            u=na;\n        }\n    while(1){\n    for(int target=1;target<=n;++target){\n        bo=false;\n        for(int i=0;i<3;++i){\n            for(int j=0;j<10001;++j){\n                if(cup[i][j]==target){\n                   // cout<<i<<\" \"<<j<<endl;\n                    bo=true;\n                    at.first=i;\n                    at.second=j;\n                    break;\n                }\n                if(cup[i][j]==0)break;\n            }\n            if(bo)break;\n        }\n        if(place==at.first)continue;\n        int i=0,count=0;\n        while(1){\n            if(cup[place][i]!=0)count++;\n            else break;\n            i++;\n        }\n        //cout<<at.first<<\" \"<<at.second<<\" \"<<place<<\" \"<<count<<endl;\n        ch=target;\n        px=place;\n        py=count;\n        saiki(0,at.first,at.second,place,count);\n    }\n        if(cup[1][0]==0&&cup[sp][0]==0)break;\n    }\n}\nvoid input(){\n    for(int i=0;i<3;++i){\n        for(int j=0;j<16;++j){\n            cup[i][j]=0;\n        }\n    }\n    cin>>na;\n    for(int i=0;i<na;++i){\n        cin>>cup[0][i];\n    }\n    cin>>nb;\n    for(int i=0;i<nb;++i){\n        cin>>cup[1][i];\n    }\n    cin>>nc;\n    for(int i=0;i<nc;++i){\n        cin>>cup[2][i];\n    }\n    return ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include <stack>\nusing namespace std;\n\nint main()\n{\n\t\n\tFILE *infile,*outfile;\n\tinfile = fopen(\"in.txt\",\"r\");\n\toutfile = fopen(\"out.txt\",\"w\");\n\t\n\tstack<int>a,b,c;\n\twhile(1)\n\t{\n\t\t\n\t\tint count=0,n,m,check;\n\t\tfscanf(infile,\"%d %d\",&n,&m);\n\n\t\tif(n==0 && m==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\n\t\tint A,B,C,\n\t\t\tkari;\n\t\t\n\t\t/*エラー対策*/\n\t\ta.push(0);\n\t\tb.push(0);\n\t\tc.push(0);\n\n\t\tfscanf(infile,\"%d\",&A);\n\t\tfor(int i=0;i<A;i++)\n\t\t{\n\t\t\tfscanf(infile,\"%d\",&kari);\n\t\t\ta.push(kari);\n\t\t}\n\n\t\tfscanf(infile,\"%d\",&B);\n\t\tfor(int i=0;i<B;i++)\n\t\t{\n\t\t\tfscanf(infile,\"%d\",&kari);\n\t\t\tb.push(kari);\n\t\t}\n\t\n\t\tfscanf(infile,\"%d\",&C);\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tfscanf(infile,\"%d\",&kari);\n\t\t\tc.push(kari);\n\t\t}\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif(b.top()==0 && c.top()==0)\n\t\t\t\tbreak;\n\t\t\tif(a.top()<b.top() && a.top()<c.top())\n\t\t\t{\n\t\t\t\tkari=b.top();\n\t\t\t\ta.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b.top()<c.top() )\n\t\t\t{\n\t\t\t\tkari=c.top();\n\t\t\t\tb.push(kari);\n\t\t\t\tc.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b.top()<a.top())\n\t\t\t{\n\t\t\t\tkari=a.top();\n\t\t\t\tb.push(kari);\n\t\t\t\ta.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(c.top()<b.top() && a.top()!=b.top()-1)\n\t\t\t{\n\t\t\t\tkari=b.top();\n\t\t\t\tc.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tkari=b.top();\n\t\t\t\ta.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(count<m || count==m) \n\t\t\t{\n\t\t\t\tfprintf(outfile,\"%d\\n\",count);\n\t\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfprintf(outfile,\"%d\\n\",-1);\n\t\t\tcontinue;\n\t\t}\n\t\tfclose(infile);\n\t\tfclose(outfile);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\t\n\t\tif(n==0)break;\n\t\t\n\t\tint g[3][16]={0};\n\t\tint k[3]={1,1,1};\n\t\t\n\t\trep(i,3) g[i][0]=0;\n\t\t\n\t\trep(i,3){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\t\n\t\t\trep(j,a){\n\t\t\t\tint b;\n\t\t\t\tcin>>b;\n\t\t\t\t\n\t\t\t\tg[i][k[i]]=b;\n\t\t\t\tk[i]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint bef=-1;\n\t\tint ans=-1;\n\t\trep(p,m){\n\t\t\t\n\t\t\tif(k[1]==1 && k[2]==1){\n\t\t\t\tans = p;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint a,b,c;\n\t\t\ta = g[0][k[0]-1];\n\t\t\tb = g[1][k[1]-1];\n\t\t\tc = g[2][k[2]-1];\n\t\t\t\n\t\t\twhile(1){\n\t\t\t\tif( a < b && bef != b*5+1){\n\t\t\t\t\tbef = b*5 + 2;\n\t\t\t\t\tg[0][k[0]]=b;\n\t\t\t\t\tk[0]++;\n\t\t\t\t\tk[1]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( b < c && bef != c*5+2){\n\t\t\t\t\tbef = c*5 + 3;\n\t\t\t\t\tg[1][k[1]]=c;\n\t\t\t\t\tk[1]++;\n\t\t\t\t\tk[2]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( a > b && bef != a*5+2){\n\t\t\t\t\tbef = a*5 + 1;\n\t\t\t\t\tg[1][k[1]]=a;\n\t\t\t\t\tk[1]++;\n\t\t\t\t\tk[0]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( b > c && bef != b*5+3){\n\t\t\t\t\tbef = b*5 + 2;\n\t\t\t\t\tg[2][k[2]]=b;\n\t\t\t\t\tk[2]++;\n\t\t\t\t\tk[1]--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\tputs(\"------------------\");\n\t\t\trep(i,3){\n\t\t\t\trep(j,k[i]){\n\t\t\t\t\tprintf(\"%d \",g[i][j]);\n\t\t\t\t}puts(\"\");\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tif(k[1]==1 && k[2]==1){\n\t\t\t\tans = p+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif(n==0 && m==0 && k[1]==1 && k[2]==1){\n\t\t\tprintf(\"%d\\n\",0);\n\t\t}else{\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n}\n\n/*\n3 30\n0\n0\n3 1 2 3\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nchar p[16];\nint n,m;\nint step(int a){\n\tif(a>n) return 0;\n\telse return 3*step(a+1)+1;\n}\nint count(int a,char t){\n\tchar u;\n\tif(t == 'A') u = 'C';\n\telse u = 'A';\n\tif (a == 1 && n == 1 && p[a] == t){\n\t\treturn 0;\n\t}\n\telse if(a == 1 && n == 1 && p[a] == 'B'){\n\t\treturn 1;\n\t}\n\tif (a > n) return 0;\n\telse if(p[a] == t){\n\t\treturn count(a+1,t);\n\t}\n\telse if(p[a] == 'B'){\n\t\treturn 1+count(a+1,u)+step(a+1)*2;\n\t}\n\telse if(p[a] != t){\n\t\treturn 2+count(a+1,u)+step(a+1)*4;\n\t}\n}\nint main(){\n\tint i,j,a,b,x,y,r;\n\twhile(cin >> n >> m && (n != 0 && m != 0)){\n\t\tr = 0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tcin >> x;\n\t\t\tfor(j=0;j < x;j++){\n\t\t\t\tcin >> y;\n\t\t\t\tif(i==0) p[y] = 'A';\n\t\t\t\telse if(i==1) p[y] = 'B';\n\t\t\t\telse p[y] = 'C';\n\t\t\t}\n\t\t}\n\t\ta = count(1,'A');\n\t\tb = count(1,'C');\n\t\tr = min(a,b);\n\t\tif(r > m) cout << -1 << endl;\n\t\telse  cout << r << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint calc(vector<int> cup, int m)\n{\n    int cnt = 0;\n    while (1) {\n        int i = cnt%2, j = i+1;\n        int p = 1;\n        while (p <= max(cup[i], cup[j])) p <<= 1;\n        p >>= 1;\n        if (!p) break;\n        cup[i] ^= p;\n        cup[j] ^= p;\n        cnt++;\n        if (cnt > m) return cnt;\n    }\n\n    return cnt;\n}\n\nint main()\n{\n    while (1) {\n        int n, m; cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        vector<int> cup(3);\n        loop (3, i) {\n            int c; cin >> c;\n            while (c--) {\n                int v; cin >> v;\n                cup[i] |= 1 << v--;\n            }\n        }\n        int ans = calc(cup, m);\n        swap(cup[0], cup[2]);\n        ans = min(ans, calc(cup, m));\n        cout << (ans <= m ? ans : -1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstatic const int P[16] = { 1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049,\n              177147, 531441, 1594323, 4782969, 14348907};\nint n, m, d[14348907];\n\nint getA(int state){\n    for(int i = n - 1; i >= 0; i--)\n        if((state % P[i + 1]) / P[i] == 0) return i + 1;\n    return 0;\n}\n\nint getB(int state){\n    for(int i = n - 1; i >= 0; i--)\n        if((state % P[i + 1]) / P[i] == 1) return i + 1;\n    return 0;\n}\n\nint getC(int state){\n    for(int i = n - 1; i >= 0; i--)\n        if((state % P[i + 1]) / P[i] == 2) return i + 1;\n    return 0;\n}\n\nint bfs(int state){\n    fill(d, d + 14348907, -1);\n    d[state] = 0;\n    queue<int> todo;\n    todo.push(state);\n    \n    while(!todo.empty()){\n        int state = todo.front();\n        todo.pop();\n        if(d[state] == m + 1) return -1;\n        if(state == 0 || state == P[n] - 1) return d[state];\n        int a = getA(state), b = getB(state), c = getC(state);\n        if(a != 0 && a > b){\n            int nstate = state + P[a - 1];\n            if(d[nstate] == -1){\n                d[nstate] = d[state] + 1;\n                todo.push(nstate);\n            }\n        }\n        if(b != 0 && a < b){\n            int nstate = state - P[b - 1];\n            if(d[nstate] == -1){\n                d[nstate] = d[state] + 1;\n                todo.push(nstate);\n            }\n        }\n        if(b != 0 && b > c){\n            int nstate = state + P[b - 1];\n            if(d[nstate] == -1){\n                d[nstate] = d[state] + 1;\n                todo.push(nstate);\n            }\n        }\n        if(c != 0 && b < c){\n            int nstate = state - P[c - 1];\n            if(d[nstate] == -1){\n                d[nstate] = d[state] + 1;\n                todo.push(nstate);\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    while(cin >> n){\n        if(n == 0) return 0;\n        cin >> m;\n        int state = 0, a, b, c, x;\n        cin >> a;\n        for(int i = 0; i < a; i++){\n            cin >> x;\n        }\n        cin >> b;\n        for(int i = 0; i < b; i++){\n            cin >> x;\n            state += P[x - 1];\n        }\n        cin >> c;\n        for(int i = 0; i < c; i++){\n            cin >> x;\n            state += 2 * P[x - 1];\n        }\n        cout << bfs(state) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <tr1/unordered_map>\nusing namespace std;\n\nint n;\n\nint goal = 0;\n\ntypedef int P ;\n\ntemplate <class K, class V>  \nclass hashMap {  \n    static const unsigned int DEFAULT_SIZE = 2999597;  \n    vector<pair<K, V> > *contents;  \n    unsigned int _size;  \n    unsigned int (*_hashValue) (K, unsigned int);  \n  \npublic:  \n    hashMap(unsigned int (*func) (K, unsigned int) , unsigned int size = DEFAULT_SIZE) {  \n        _hashValue = func;  \n        _size = size;  \n        contents = new vector<pair<K, V> > [_size];  \n    }  \n  \n    ~hashMap() {  \n        delete [] contents;  \n    }  \n  \n    bool hashElement(K s) {  \n        unsigned int h = _hashValue(s, _size);  \n  \n        for (int i = 0; i < (int)contents[h].size(); i++) {  \n            if (contents[h][i].first == s)  \n                return true;  \n        }  \n  \n        return false;  \n    }  \n  \n    void insert(K x, V n) {  \n        if (hashElement(x))  \n            return;  \n  \n        unsigned int h = _hashValue(x, _size);  \n        contents[h].push_back(make_pair(x, n));  \n    }  \n  \n    pair<K, V> *getElement(K x) {  \n        unsigned int h = _hashValue(x, _size);  \n        for (int i = 0; i < (int)contents[h].size(); i++)  \n            if (contents[h][i].first == x)  \n                return &contents[h][i];  \n  \n        return NULL;  \n    }  \n  \n    void printHashBalance() {  \n        int cnt = 0;  \n        double ret = 0.0;  \n        int worst = 0;  \n  \n        for (int i = 0; i < (int)_size; i++) {  \n            if (contents[i].size()) {  \n                ++cnt;  \n                ret += contents[i].size();  \n                worst = max<int>(worst, contents[i].size());  \n            }  \n        }  \n  \n        if (!cnt)  \n            cerr << \"Hash is empty\" << endl;  \n        else {  \n            cerr << \"collisions occurred(average): \" << (ret/cnt) << endl;  \n            cerr << \"collisions occurred(worst): \" << worst << endl;  \n        }  \n    }  \n};  \n\nunsigned int f(int n,unsigned int size){\n\treturn n%2999597;\n}\nP Q[30];\nint m,stat,tim,head,size,i,t,a,j,from,to,next;\n\nint main(){\n\twhile(cin >> n >> m && n){\n\t\thashMap<int,int> done(&f);\n\t\tint init = 0;\n\t\tfor(i = 0 ; i < n ; i++) goal |= 2 << (i*2);\n\t\t\n\t\tfor(i = 0 ; i < 3 ; i++){\n\t\t\tt,a; cin >> t;\n\t\t\twhile(t--){cin >> a; a--; init |= (i) << (2*a); }\n\t\t}\n\t\thead = 0 , size = 0;\n\t\tQ[size++] = init;\n\t\tdone.insert(init,0);\n\t\tint hoge = 0;\n\t\twhile(head != size){\n\t\t\thoge++;\n\t\t\tstat = Q[head++];\n\t\t\ttim = (*done.getElement(stat)).second;\n\t\t\tif(tim > m) break;\n\t\t\tif(stat == goal || stat == 0){ cout << tim << endl; goto hoge;}\n\t\t\tint mi[3] = {-1,-1,-1};\n\t\t\tfor(i = n-1 ; i >= 0 ; i--){\n\t\t\t\tint num = stat>>(i*2)&3;\n\t\t\t\tif(mi[num]==-1)mi[num] = i;\n\t\t\t}\n\t\t\t\n\t\t\tfor(from = 0 ; from < 3 ; from++){\n\t\t\t\tfor(to = 0 ; to < 3 ; to++){\n\t\t\t\t\tif ( !( (from == 0 && to == 2) || (from == 2 && to == 0) ) && from != to && mi[from] != -1 && (mi[to] == -1 || mi[from] > mi[to]) ){\n\t\t\t\t\t\tnext = (stat & ~(3<<(2*mi[from]))) | (to<<(2*mi[from]));\n\t\t\t\t\t\tif(done.getElement(next)==NULL)Q[size++] = next , done.insert(next,tim+1);\n\t\t\t\t\t\thead %= 30;\n\t\t\t\t\t\tsize %= 30;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\thoge:;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\ntypedef pair <int,P> PP;\ntypedef pair <int,PP> PPP;\n\nstatic const double eps = 1e-8;\n\nint bfs(int m,vector<int>& sets, map<vector<int>,int>& visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,sets));\n\tvisited[sets] = 0;\n\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tvector<int> sets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\tvector<int> tmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=16;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\tif(visited.find(tmp) == visited.end()){\n\t\t\t\t\tvisited[tmp] = cost + 1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\tvector<int> tmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=16;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tif(visited.find(tmp) == visited.end()){\n\t\t\t\t\tvisited[tmp] = cost + 1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tmap<vector<int>,int> visited;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<size); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,sets,visited));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n    int N, M, K, tmp;\n    while(cin >> N >> M && (N || M))\n    {\n        vector<int> v(N+1);\n        for(int t=0; t<3; t++)\n        {\n            cin >> K;\n            for(int k=0; k<K; k++)\n            {\n                cin >> tmp;\n                v[tmp] = t;\n            }\n        }\n\n        vector<int> a(N+1), c(N+1), p(N+1);\n        p[N] = 2;\n        a[N] = v[N];\n        c[N] = 2 - v[N];\n        for(int n=N; n>1; n--)\n        {\n            p[n-1] = 3 * p[n] + 2;\n            switch(v[n-1])\n            {\n            case 0:\n                a[n-1] = a[n];\n                c[n-1] = c[n] + 2 * p[n] + 2;\n                break;\n            case 1:\n                a[n-1] = c[n] + p[n] + 1;\n                c[n-1] = a[n] + p[n] + 1;\n                break;\n            case 2:\n                a[n-1] = a[n] + 2 * p[n] + 2;\n                c[n-1] = c[n];\n                break;\n            }\n        }\n        int res = min(a[1], c[1]);\n        if(M < res) res = -1;\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nunsigned f(unsigned S, int x, int from, int to) {\n  if (from >= 0) {\n    S &= ~((from >> 0 & 1) << (x << 1));\n    S &= ~((from >> 1 & 1) << ((x << 1) + 1));\n  }\n  S |= (to >> 0 & 1) << (x << 1);\n  S |= (to >> 1 & 1) << ((x << 1) + 1);\n  return S;\n}\n\nvector<int> getTop(unsigned S, int n) {\n  vector<int> res(3, -1);\n  for (int i = 0; i < n; i++) {\n    int l = S >> ((i << 1) + 1) & 1;\n    int r = S >> (i << 1) & 1;\n    res[(l << 1) + r] = max(res[(l << 1) + r], i);\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  int n, m;\n  while (cin >> n >> m, n) {\n    unsigned S = 0;\n    for (int i = 0; i < 3; i++) {\n      int sz;\n      cin >> sz;\n      for (int j = 0; j < sz; j++) {\n        int x;\n        cin >> x;\n        S = f(S, x - 1, -1, i);\n      }\n    }\n\n    map<unsigned, int> d;\n    d[S] = 0;\n    queue<unsigned> que;\n    que.emplace(S);\n    int ans = -1;\n    while (que.size()) {\n      unsigned s = que.front(); que.pop();\n      auto v = getTop(s, n);\n      if (v[1] < 0 && (v[0] < 0 || v[2] < 0)) {\n        ans = (d[s] <= m ? d[s] : -1);\n        break;\n      }\n      \n      unsigned ns;\n      for (int i = 0; i < 3; i++) {\n        int l = i == 0 ? -1 : i - 1;\n        int r = i == 2 ? -1 : i + 1;\n        if (l >= 0 && v[i] > v[l]) {\n          ns = f(s, v[i], i, l);\n          if (d.find(ns) == d.end()) {\n            d[ns] = d[s] + 1;\n            que.emplace(ns);\n          }\n        }\n        if (r >= 0 && v[i] > v[r]) {\n          ns = f(s, v[i], i, r);\n          if (d.find(ns) == d.end()) {\n            d[ns] = d[s] + 1;\n            que.emplace(ns);\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N, M;\n\nclass hash_array {\npublic:\n  size_t operator()(const array<int, 3> &x) const {\n    const int C = 997;\n    size_t t = 0;\n    for (int i = 0; i != x.size(); ++i) {\n      t = t * C + x[i];\n    }\n    return t;\n  }\n};\n\nint solve(array<int, 3> const& start) {\n  queue<array<int, 3>> q;\n  int num = 0;\n  rep(i, N) num |= 1 << i;\n  q.push(start);\n\n  unordered_map<array<int, 3>, int, hash_array> mp;\n  mp[start] = 0;\n\n  const array<int, 3> target1{{num, 0, 0}};\n  const array<int, 3> target2{{0, 0, num}};\n\n  while(!q.empty()) {\n    auto v = q.front(); q.pop();\n    if(v == target1 || v == target2) {\n      return mp[v];\n    }\n\n    rep(i, v.size()) {\n      for(int k=N-1; k>=0; k--) {\n        if(v[i] >> k & 1) {\n          if(i + 1 < 3) {\n            auto nv = v;\n            nv[i] ^= 1 << k;\n            if(nv[i + 1] < (1<<k)) {\n              nv[i + 1] ^= 1 << k;\n              if(mp.find(nv) == mp.end() && mp[v] + 1 <= M) {\n                mp[nv] = mp[v] + 1;\n                if(v == target1 || v == target2) {\n                  return mp[v];\n                }\n                q.push(nv);\n              }\n            }\n          }\n\n          if(i - 1 >= 0) {\n            auto nv = v;\n            nv[i] ^= 1 << k;\n            if(nv[i - 1] < (1<<k)) {\n              nv[i - 1] ^= 1 << k;\n              if(mp.find(nv) == mp.end() && mp[v] + 1 <= M) {\n                mp[nv] = mp[v] + 1;\n                if(v == target1 || v == target2) {\n                  return mp[v];\n                }\n                q.push(nv);\n              }\n            }\n          }\n\n          break;\n        }\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main() {\n  while(cin >> N >> M && (N|M)) {\n    array<int, 3> cups;\n    rep(i, 3) {\n      int n; cin >> n;\n      int num = 0;\n      rep(j, n) {\n        int k; cin >> k; k--;\n        num |= 1 << k;\n      }\n      cups[i] = num;\n    }\n    cout << solve(cups) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define min(a, b) (a > b ? b : a)\n\nint func(int a, int b, int c) {\n    if (b == 0 && c == 0)\n        return 0;\n    else if (a & 1)\n        return func(a >> 1, b >> 1, c >> 1);\n    else if (b & 1)\n        return func(c >> 1, b >> 1, a >> 1) + 1 + func(0, 0, (a | b | c) >> 1);\n    else\n        return func(a >> 1, b >> 1, c >> 1) + 2 +\n               4 * func(0, (a | b | c) >> 1, 0);\n}\n\nint main() {\n    int n, m, tray[3];\n    while (std::cin >> n >> m && n && m) {\n        rep(i, 3) {\n            tray[i] = 0;\n            int k, num;\n            std::cin >> k;\n            rep(j, k) {\n                std::cin >> num;\n                tray[i] |= 1 << (num - 1);\n            }\n        }\n\n        int res = min(func(tray[0], tray[1], tray[2]),\n                      func(tray[2], tray[1], tray[0]));\n        std::cout << (res <= m ? res : -1) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint T[20];\nint A[20], B[20];\nint n, m;\n\nint solve() {\n    int P[17];\n    P[n] = 2;\n    for ( int i = n; i > 0; -- i ) P[i-1] = 3 * P[i] + 2;\n    \n    A[n] = T[n];\n    B[n] = 2 - T[n];\n    for ( int i = n; i > 1; -- i ) {\n        if ( T[i-1] == 0 ) {\n            A[i-1] = A[i];\n            B[i-1] = B[i] + 2 * P[i] + 2;\n        } else if ( T[i-1] == 1 ) {\n            A[i-1] = B[i] + P[i] + 1;\n            B[i-1] = A[i] + P[i] + 1;\n        } else if ( T[i-1] == 2 ) {\n            A[i-1] = A[i] + 2 * P[i] + 2;\n            B[i-1] = B[i];\n        }\n    }\n    int res = min( A[1], B[1] );\n    if ( res > m ) return -1;\n    return res;\n}\n\nint main() {\n    while ( cin >> n >> m && n ) {\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                T[t] = i;\n            }\n        }\n\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<string>\n#include<climits>\n#include<deque>\n\nusing namespace std;\n\nint k;\nstack<int,vector<int> >A,B,C;\n\nint func(int,string);\n\nint main(void){\nint n,m,ans,s,t;\n\nwhile(cin >> n >> m,n|m){\nwhile(!A.empty())A.pop();\nwhile(!B.empty())B.pop();\nwhile(!C.empty())C.pop();\n\ncin >> s;\nfor(int i=0;i<s;i++){\ncin >> t;\nA.push(t);\n}\ncin >> s;\nfor(int i=0;i<s;i++){\ncin >> t;\nB.push(t);\n}\ncin >> s;\nfor(int i=0;i<s;i++){\ncin >> t;\nC.push(t);\n}\n\nfor(k=1;k<=m;k++){\nans=func(0,\"\");\nif(ans!=INT_MAX)break;\n}\nif(ans==INT_MAX)cout << -1 << endl;\nelse cout << ans << endl;\n}\nreturn 0;\n}\n\nint func(int cnt,string p){\n\nif(cnt>k)return INT_MAX;\n\nif(B.empty()&&(C.empty()||A.empty()))\nreturn cnt;\n\nint res=INT_MAX;\n\nif(!A.empty() && A.top()>=B.top() && p!=\"BA\"){\nB.push(A.top());\nA.pop();\nres=min(res,func(cnt+1,\"AB\"));\nA.push(B.top());\nB.pop();\n}\n\nif(!B.empty()){\nif(B.top()>=C.top()&&p!=\"CB\"){\nC.push(B.top());\nB.pop();\nres=min(res,func(cnt+1,\"BC\"));\nB.push(C.top());\nC.pop();\n}\n\nif(B.top()>=A.top()&&p!=\"AB\"){\nA.push(B.top());\nB.pop();\nres=min(res,func(cnt+1,\"BA\"));\nB.push(A.top());\nA.pop();\n}\n}\n\nif(!C.empty() && C.top()>=B.top() && p!=\"BC\"){\nB.push(C.top());\nC.pop();\nres=min(res,func(cnt+1,\"CB\"));\nC.push(B.top());\nB.pop();\n}\n\nreturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<vvi,int> pvi;\nbool ok(vvi a){\n  return (a[0].empty()&&a[1].empty()) || (a[1].empty()&&a[2].empty());\n}\nvoid print(vvi a){\n  REP(i,a.size()){\n    printf(\"%d:\",i+1);\n    REP(j,a[i].size()){\n      printf(\"%d \",a[i][j]);\n    }\n    putchar('\\n');\n  }\n    putchar('\\n');\n}\nint toi(vvi a){\n  int res = 0;\n  REP(i,a[1].size()) res += pow(3.0, a[1][i]);\n  REP(i,a[2].size()) res += pow(3.0, a[2][i]) * 2;\n  return res;\n}\nbool used[15000000];\nint solve(vvi a, int m){\n  queue<pvi> que;\n  que.push(pvi(a,0));\n  memset(used, 0, sizeof(used));\n  while(!que.empty()){\n    pvi p = que.front(); que.pop();\n    vvi na = p.first; int nt = p.second;\n    if(nt > m) return -1;\n    if(ok(na)) return nt;\n    int useidx = toi(na);\n    if(used[useidx]) continue;\n    used[useidx] = true;\n    //printf(\"--------------------\\n\");\n    //print(na);\n    REP(i,3)REP(j,3){\n      if(abs(i-j)== 1 && na[i].size() && (na[j].empty() || na[i].back() > na[j].back())){\n        vvi nna = na;\n        nna[j].push_back(nna[i].back());\n        nna[i].pop_back();\n        useidx = toi(nna);\n        if(used[useidx]) continue;\n        que.push(pvi(nna, nt + 1));\n        //print(nna);\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m){\n    cin.ignore();\n    vvi a(3);\n    REP(i,3){\n      int ps; cin>>ps;\n      while(ps--){\n        int tmp;\n        cin>>tmp;\n        a[i].push_back(tmp);\n      }\n    }\n    cout<<solve(a,m)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\nusing namespace std;\n\nint n;\n\nint goal = 0;\n\ntypedef int P ;\n\n\nmap<int,int> done;\n\nP Q[30];\n\nint view(int bit){\n\tvector<int> s[3];\n\tfor(int i = 0 ; i < n ; i++)\n\t\ts[bit>>(i*2)&3].push_back(i);\n\tfor(int i = 0 ; i < 3 ; i++){\n\t\tcout << \"]\";\n\t\tfor(int j = 0 ; j < s[i].size() ; j++)\n\t\t\tcout << s[i][j];\n\t\tcout << endl;\n\t}\n}\nint main(){\n\tint m;\n\twhile(cin >> n >> m && n){\n\t\tint init = 0;\n\t\tfor(int i = 0 ; i < n ; i++) goal |= 2 << (i*2);\n\t\t\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tint t,a; cin >> t;\n\t\t\twhile(t--){cin >> a; a--; init |= (i) << (2*a); }\n\t\t}\n\t\t\n\t\tdone.clear();\n\t\tint head = 0 , size = 0;\n\t\tQ[size++] = init;\n\t\tdone[init] = 0;\n\t\t\n\t\twhile(head != size){\n\t\t\tint &stat = Q[head++];\n\t\t\tint &tim = done[stat];\n\t\t\tif(tim > m) break;\n\t\t\tif(stat == goal || stat == 0){ cout << tim << endl; goto hoge;}\n\t\t\tint mi[3] = {-1,-1,-1};\n\t\t\tfor(int i = n-1 ; i >= 0 ; i--){\n\t\t\t\tint num = stat>>(i*2)&3;\n\t\t\t\tif(mi[num]==-1)mi[num] = i;\n\t\t\t}\n\n\t\t\tfor(int from = 0 ; from < 3 ; from++){\n\t\t\t\tfor(int to = 0 ; to < 3 ; to++){\n\t\t\t\t\tif ( !( (from == 0 && to == 2) || (from == 2 && to == 0) ) && from != to && mi[from] != -1 && (mi[to] == -1 || mi[from] > mi[to]) ){\n\t\t\t\t\t\tint next = (stat & ~(3<<(2*mi[from]))) | (to<<(2*mi[from]));\n\t\t\t\t\t\tif(!done.count(next))Q[size++] = next , done[next] = tim+1;\n\t\t\t\t\t\thead %= 30;\n\t\t\t\t\t\tsize %= 30;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\thoge:;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\ntypedef long long ll;\n\nstruct Cups{\n\tstd::vector<int> S[3];\n\tint t, prev_from, prev_to;\n\tCups(const std::vector<int> (&_S)[3], int _t, int _from, int _to)\n\t\t:t(_t), prev_from(_from), prev_to(_to){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tfor(int j=0;j<_S[i].size();j++){\n\t\t\t\tS[i].push_back(_S[i][j]);\n\t\t\t}\n\t\t}\n\t}\n};\n\nll toInt(const std::vector<int> (&S)[3]){\n\tll res = 0;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<S[i].size();j++){\n\t\t\tint elem = S[i][j];\n\t\t\tres |= i << 2 * elem;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid dou(const std::vector<int> (&S)[3]){\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=0;j<S[i].size();j++){\n\t\t\tstd::cout << S[i][j] << \" \";\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n}\n\nint main(){\n\tint n, m;\n\twhile(std::cin >> n >> m, n){\n\t\tstd::vector<int> S[3];\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint SN;\n\t\t\tstd::cin >> SN;\n\t\t\tfor(int j=0;j<SN;j++){\n\t\t\t\tint e;\n\t\t\t\tstd::cin >> e;\n\t\t\t\tS[i].push_back(e-1);\n\t\t\t}\n\t\t\tstd::sort(S[i].begin(), S[i].end(), std::greater<int>());\n\t\t}\n\n\t\tstd::queue<Cups> q;\n\t\tq.push(Cups(S, 0, -1, -1));\n\t\n\t\tint res = -1;\n\t\twhile(!q.empty()){\n\t\t\tCups c = q.front();q.pop();\n\t\t\tstd::vector<int> S[3] = c.S;\n\t\t\tint t = c.t, prev_from = c.prev_from, prev_to = c.prev_to;\n\n\t\t\tif(t > m){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(S[0].size() == n || S[2].size() == n){\n\t\t\t\tres = t;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tfor(int j=0;j<3;j++){//i -> j\n\t\t\t\t\tif(std::abs(i-j) != 1 || (j == prev_from && i == prev_to) ||\n\t\t\t\t\t\t S[i].empty() || (!S[j].empty() && S[i][0] < S[j][0]))continue;\n\t\t\t\t\tstd::vector<int> _S[3] = S;\n\t\t\t\t\t_S[j].push_back(_S[i][0]);\n\t\t\t\t\t_S[i].erase(_S[i].begin());\n\t\t\t\t\tstd::sort(_S[j].begin(), _S[j].end(), std::greater<int>());\n\t\t\t\t\tq.push(Cups(_S, t+1, i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << res << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> mat;\n\nconst int INF = 1 << 28;\nint n, m;\n\nbool check(mat &v) {\n    if (v[0].size() == n + 1 || v[2].size() == n + 1)\n        return true;\n    return false;\n}\n\nstring stom(mat &v) {\n    string res;\n    res = \"\";\n    for (int i = 0; i < 3; i++) {\n        for (auto j : v[i]) {\n            if (j < 0) continue;\n            res = res + (char)('a' + j);\n        }\n        for (int j = v[i].size(); j <= n; j++) {\n            res = res + 'a';\n        }\n    }\n    return res;\n}\n\nmap<string , int> M;\n\nint dfs(mat &v, int d) {\n    string V = stom(v);\n    if (d > m) return M[V] = INF;\n    if (check(v)) return M[V] = d;\n    if (M.find(V) != M.end()) return M[V];\n    M[V] = 1 << 28;\n\n    for (int i = 0; i < 3; i++) {\n        if (v[i].size() > 1) {\n            for (int j = 0; j < 3; j++) {\n                if (i == j || v[i][v[i].size()-1] < v[j][v[j].size() - 1]) continue;\n                if (i == 0 && j == 2) continue;\n                if (i == 2 && j == 0) continue;\n                v[j].push_back(v[i][v[i].size() - 1]);\n                v[i].erase(v[i].end() - 1);\n                M[V] = min(M[V], dfs(v, d + 1));\n                v[i].push_back(v[j][v[j].size() - 1]);\n                v[j].erase(v[j].end() - 1);\n            }\n        }\n    }\n\n    return M[V];\n}\n\n\nint main() {\n    while (cin >> n >> m, n || m) {\n        mat v(3);\n        for (int i = 0; i < 3; i++) {\n            int n_; cin >> n_;\n            v[i].push_back(-1);\n            for (int j = 0; j < n_; j++) {\n                int x; cin >> x;\n                v[i].push_back(x);\n            }\n        }\n\n        int res = dfs(v, 0);\n        cout << (res > m ? -1 : res) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\nusing namespace std;\n\nint n;\n\nint goal = 0;\n\ntypedef pair<int,int> P ;\n\n\nmap<int,bool> done;\n\n\nP Q[15000000];\n\nint view(int bit){\n\tvector<int> s[3];\n\tfor(int i = 0 ; i < n ; i++)\n\t\ts[bit>>(i*2)&3].push_back(i);\n\tfor(int i = 0 ; i < 3 ; i++){\n\t\tcout << \"]\";\n\t\tfor(int j = 0 ; j < s[i].size() ; j++)\n\t\t\tcout << s[i][j];\n\t\tcout << endl;\n\t}\n}\nint main(){\n\tint m;\n\twhile(cin >> n >> m && n){\n\t\tint init = 0;\n\t\tfor(int i = 0 ; i < n ; i++) goal |= 2 << (i*2);\n\t\t\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tint t,a; cin >> t;\n\t\t\twhile(t--){cin >> a; a--; init |= (i) << (2*a); }\n\t\t}\n\t\t\n\t\tdone.clear();\n\t\tint head = 0 , size = 0;\n\t\tQ[size++] = P(init,0);\n\t\t\n\t\twhile(head < size){\n\t\t\tP &q = Q[head++];\n\t\t\tint stat = q.first;\n\t\t\tif(q.second > m) break;\n\t\t\tif(done[stat]) continue; else done[stat] = true;\n\t\t\tif(stat == goal || stat == 0){ cout << q.second << endl; goto hoge;}\n\t\t\tint mi[3] = {-1,-1,-1};\n\t\t\tfor(int i = n-1 ; i >= 0 ; i--){\n\t\t\t\tint num = stat>>(i*2)&3;\n\t\t\t\tif(mi[num]==-1)mi[num] = i;\n\t\t\t}\n\n\t\t\tfor(int from = 0 ; from < 3 ; from++){\n\t\t\t\tfor(int to = 0 ; to < 3 ; to++){\n\t\t\t\t\tif ( !( (from == 0 && to == 2) || (from == 2 && to == 0) ) && from != to && mi[from] != -1 && (mi[to] == -1 || mi[from] > mi[to]) ){\n\t\t\t\t\t\tint next = (stat & ~(3<<(2*mi[from]))) | (to<<(2*mi[from]));\n\t\t\t\t\t\tif(!done[next])Q[size++] = P(next,q.second+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\thoge:;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint N,M,p[15],n[15],i,j,t,q,R,s[16];\nint main()\n{\n\tfor(i=s[0]=1;i<16;i++)s[i]=s[i-1]*3;\n\tfor(;scanf(\"%d%d\",&N,&M),N;)\n\t{\n\t\tmemset(n,0,sizeof(n));\n\t\tfor(i=R=0;i<3;i++)\n\t\t\tfor(scanf(\"%d\",&t),j=0;j<t;p[N-q]=i,j++)\n\t\t\t\tscanf(\"%d\",&q);\n\t\tfor(i=N-1;i>=0;i--)\n\t\t{\n\t\t\tswitch(abs(p[i]-n[i]))\n\t\t\t{\n\t\t\tcase 0:break;\n\t\t\tcase 1:R+=s[i];for(j=0;j<i;j++)n[j]=2-n[i];break;\n\t\t\tcase 2:R+=2*s[i];for(j=0;j<i;j++)n[j]=2-n[i];break;\n\t\t\t}\n\t\t}\n\t\tR=R>s[N]-R?s[N]-R:R;\n\t\tprintf(\"%d\\n\",R>=M?-1:R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define Z 15000000\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,m,a,b,c[15],t;\nint head,tail,ans;\nint qx[Z],ql[Z];\nbool vis[Z];\n\nvoid BFS(int x,int l){\n\tif(vis[x])return;\n\tif(l==m)return;\n\tif(x==0||x==t){ans=l;return;}\n\tvis[x]=true;\n\tint d[3]={-1},e=x,f=0,g=1;\n\twhile(true){\n\t\td[e%3]=max(d[e%3],g);\n\t\te/=3,f++,g*=3;\n\t\tif(f==n)break;\n\t}\n\tif(d[0]>d[1]){e=x+d[0];if(!vis[e])qx[tail]=e,ql[tail]=l+1,tail++;}\n\tif(d[0]<d[1]){e=x-d[1];if(!vis[e])qx[tail]=e,ql[tail]=l+1,tail++;}\n\tif(d[1]>d[2]){e=x+d[1];if(!vis[e])qx[tail]=e,ql[tail]=l+1,tail++;}\n\tif(d[1]<d[2]){e=x-d[2];if(!vis[e])qx[tail]=e,ql[tail]=l+1,tail++;}\n\treturn;\n}\nint main(){\n\twhile(true){\n\t\tcin>>n>>m;\n\t\tif(!n&&!m)break;\n\t\trep(i,3){cin>>a;rep(j,a)cin>>b,c[b-1]=i;}\n\t\tint o=0,p=1;\n\t\trep(i,n)o+=p*c[i],p*=3;\n\t\tt=p-1;\n\t\thead=0,tail=1,ans=-1;\n\t\tqx[0]=o,ql[0]=0;\n\t\trep(i,Z)vis[i]=false;\n\t\twhile(true){\n\t\t\tif(tail==head)break;\n\t\t\tBFS(qx[head],ql[head]);\n\t\t\tif(ans!=-1)break;\n\t\t\thead++;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <tr1/unordered_map>\nusing namespace std;\n\nint n;\n\nint goal = 0;\n\ntypedef int P ;\n\ntemplate <class K, class V>  \nclass hashMap {  \n    static const unsigned int DEFAULT_SIZE = 284233;  \n    vector<pair<K, V> > *contents;  \n    unsigned int _size;  \n    unsigned int (*_hashValue) (K, unsigned int);  \n  \npublic:  \n    hashMap(unsigned int (*func) (K, unsigned int) , unsigned int size = DEFAULT_SIZE) {  \n        _hashValue = func;  \n        _size = size;  \n        contents = new vector<pair<K, V> > [_size];  \n    }  \n  \n    ~hashMap() {  \n        delete [] contents;  \n    }  \n  \n    bool hashElement(K s) {  \n        unsigned int h = _hashValue(s, _size);  \n  \n        for (int i = 0; i < (int)contents[h].size(); i++) {  \n            if (contents[h][i].first == s)  \n                return true;  \n        }  \n  \n        return false;  \n    }  \n  \n    void insert(K x, V n) {  \n        if (hashElement(x))  \n            return;  \n  \n        unsigned int h = _hashValue(x, _size);  \n        contents[h].push_back(make_pair(x, n));  \n    }  \n  \n    pair<K, V> *getElement(K x) {  \n        unsigned int h = _hashValue(x, _size);  \n        for (int i = 0; i < (int)contents[h].size(); i++)  \n            if (contents[h][i].first == x)  \n                return &contents[h][i];  \n  \n        return NULL;  \n    }  \n  \n    void printHashBalance() {  \n        int cnt = 0;  \n        double ret = 0.0;  \n        int worst = 0;  \n  \n        for (int i = 0; i < (int)_size; i++) {  \n            if (contents[i].size()) {  \n                ++cnt;  \n                ret += contents[i].size();  \n                worst = max<int>(worst, contents[i].size());  \n            }  \n        }  \n  \n        if (!cnt)  \n            cerr << \"Hash is empty\" << endl;  \n        else {  \n            cerr << \"collisions occurred(average): \" << (ret/cnt) << endl;  \n            cerr << \"collisions occurred(worst): \" << worst << endl;  \n        }  \n    }  \n};  \n\nunsigned int f(int n,unsigned int size){\n\treturn n%284233;\n}\nP Q[30];\nint m,stat,tim,head,size,i,t,a,j,from,to,next;\n\nint main(){\n\twhile(cin >> n >> m && n){\n\t\thashMap<int,int> done(&f);\n\t\tint init = 0;\n\t\tfor(i = 0 ; i < n ; i++) goal |= 2 << (i*2);\n\t\t\n\t\tfor(i = 0 ; i < 3 ; i++){\n\t\t\tt,a; cin >> t;\n\t\t\twhile(t--){cin >> a; a--; init |= (i) << (2*a); }\n\t\t}\n\t\thead = 0 , size = 0;\n\t\tQ[size++] = init;\n\t\tdone.insert(init,0);\n\t\tint hoge = 0;\n\t\twhile(head != size){\n\t\t\thoge++;\n\t\t\tstat = Q[head++];\n\t\t\ttim = (*done.getElement(stat)).second;\n\t\t\tif(tim > m) break;\n\t\t\tif(stat == goal || stat == 0){ cout << tim << endl; goto hoge;}\n\t\t\tint mi[3] = {-1,-1,-1};\n\t\t\tfor(i = n-1 ; i >= 0 ; i--){\n\t\t\t\tint num = stat>>(i*2)&3;\n\t\t\t\tif(mi[num]==-1)mi[num] = i;\n\t\t\t}\n\t\t\t\n\t\t\tfor(from = 0 ; from < 3 ; from++){\n\t\t\t\tfor(to = 0 ; to < 3 ; to++){\n\t\t\t\t\tif ( !( (from == 0 && to == 2) || (from == 2 && to == 0) ) && from != to && mi[from] != -1 && (mi[to] == -1 || mi[from] > mi[to]) ){\n\t\t\t\t\t\tnext = (stat & ~(3<<(2*mi[from]))) | (to<<(2*mi[from]));\n\t\t\t\t\t\tif(done.getElement(next)==NULL)Q[size++] = next , done.insert(next,tim+1);\n\t\t\t\t\t\thead %= 30;\n\t\t\t\t\t\tsize %= 30;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\thoge:;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint n,m;\nint pw[16];\n\nconst int N=14350000;\nconst int INF=12345679;\n\nint dp[N];\n\nint main()\n{\n    pw[0]=1;\n    for(int i=1; i<16; ++i) pw[i] = pw[i-1]*3;\n\n    while(scanf(\" %d %d\", &n, &m),n)\n    {\n        int start = 0;\n        rep(i,3)\n        {\n            int a;\n            scanf(\" %d\", &a);\n            while(a--)\n            {\n                int c;\n                scanf(\" %d\", &c);\n                --c;\n                start += i*pw[c];\n            }\n        }\n\n        fill(dp,dp+N,INF);\n        dp[start]=0;\n        queue<int> que;\n        que.push(start);\n        while(!que.empty())\n        {\n            int s = que.front();\n            que.pop();\n\n            int pos[15];\n            vector<int> big(3,-1);\n            int t=s;\n            rep(i,n)\n            {\n                pos[i]=t%3;\n                t/=3;\n\n                big[pos[i]]=i;\n            }\n\n            int ns;\n            if(big[0]>=0)\n            {\n                // 0->1\n                if(big[0]>big[1])\n                {\n                    ns = s+pw[big[0]];\n                    if(dp[ns]>dp[s]+1)\n                    {\n                        dp[ns] = dp[s]+1;\n                        que.push(ns);\n                    }\n                }\n            }\n\n            if(big[1]>=0)\n            {\n                // 1->0\n                if(big[1]>big[0])\n                {\n                    ns = s-pw[big[1]];\n                    if(dp[ns]>dp[s]+1)\n                    {\n                        dp[ns] = dp[s]+1;\n                        que.push(ns);\n                    }\n                }\n\n                // 1->2\n                if(big[1]>big[2])\n                {\n                    ns = s+pw[big[1]];\n                    if(dp[ns]>dp[s]+1)\n                    {\n                        dp[ns] = dp[s]+1;\n                        que.push(ns);\n                    }\n                }\n\n            }\n\n            if(big[2]>=0)\n            {\n                // 2->1\n                if(big[2]>big[1])\n                {\n                    ns = s-pw[big[2]];\n                    if(dp[ns]>dp[s]+1)\n                    {\n                        dp[ns]=dp[s]+1;\n                        que.push(ns);\n                    }\n                }\n            }\n        }\n\n        int ans = min(dp[0],dp[pw[n]-1]);\n        if(ans > m) ans=-1;\n        printf(\"%d\\n\", ans);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#define f(n) ((int)pow(3.0,n)-1)\nint A,N,M,S[16];\nint v(int n,int m,int g){if(m<=N)return v(n-1,m+1,S[m]==1?g+2*(1-g):g)+abs(g-S[m])*(f(n-1)+1);else return 0;}\nint main(){while(1){scanf(\"%d%d\",&N,&M);if(!(N||M))break;for(int i=0;i<3;++i){int t;scanf(\"%d\",&t);for(int j=0;j<t;++j){int u;scanf(\"%d\",&u);S[u]=i;}}A=v(N,1,0);A=std::min(A,f(N)-A);A=A<=M?A:-1;printf(\"%d\\n\",A);}return 0;}"
  },
  {
    "language": "C++",
    "code": "// {{{\n// vim:filetype=cpp foldmethod=marker foldmarker={{{,}}}\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define ALL(A)\t\t(A).begin(),(A).end()\n#define DUMP(A)    cout<<#A<<\"=\"<<(A)<< endl\n#define SIZE(A)    (int)((A).size())\n#define MP  make_pair\n#define PB  push_back\nusing namespace std;\ntypedef long long ll;\n\nint vx[]={1,0,-1,0},vy[]={0,1,0,-1};\n// }}}\n\nint main(){\n    int n,m;\n    for(;;){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0) break;\n        stack<int> sts[3],temp[3];\n        for(int i=0;i<3;i++){\n            int p,num;\n            scanf(\"%d\",&p);\n            for(int j=0;j<p;j++){\n                scanf(\"%d\",&num);\n                sts[i].push(num);\n            }\n            temp[i]=sts[i];\n        }\n        bool isle=true;\n        if(sts[0].size()==n || sts[2].size()==n){\n            printf(\"%d\\n\",0);\n            goto LABEL;\n        }\n        for(int i=0;i<m;i++){\n            if(isle){\n                if(sts[0].size()==0 || sts[0].top()<sts[1].top()){\n                    sts[0].push(sts[1].top());\n                    sts[1].pop();\n                }else{\n                    sts[1].push(sts[0].top());\n                    sts[0].pop();\n                }\n            }else{\n                if(sts[1].size()==0 || sts[1].top()<sts[2].top()){\n                    sts[1].push(sts[2].top());\n                    sts[2].pop();\n                }else{\n                    sts[2].push(sts[1].top());\n                    sts[1].pop();\n                }\n            }\n            isle=!isle;\n            if(sts[0].size()==n || sts[2].size()==n){\n                printf(\"%d\\n\",i+1);\n                goto LABEL;\n            }\n        }\n        for(int i=0;i<3;i++){\n            sts[i]=temp[i];\n        }\n        isle=false;\n        for(int i=0;i<m;i++){\n            if(isle){\n                if(sts[0].size()==0 || sts[0].top()<sts[1].top()){\n                    sts[0].push(sts[1].top());\n                    sts[1].pop();\n                }else{\n                    sts[1].push(sts[0].top());\n                    sts[0].pop();\n                }\n            }else{\n                if(sts[1].size()==0 || sts[1].top()<sts[2].top()){\n                    sts[1].push(sts[2].top());\n                    sts[2].pop();\n                }else{\n                    sts[2].push(sts[1].top());\n                    sts[1].pop();\n                }\n            }\n            if(sts[0].size()==n || sts[2].size()==n){\n                printf(\"%d\\n\",i+1);\n                goto LABEL;\n            }\n            isle=!isle;\n        }\n        printf(\"%d\\n\",-1);\n\nLABEL:  ;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\n\nint c[20][2],n,m,a,b,ax,cx,rx;\n\nint main(){\n\twhile(true){\n\t\tcin>>n>>m;\n\t\tif(n==0 && m==0){break;}\n\t\tax=0;cx=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>a;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tcin>>b;\n\t\t\t\tc[b][0]=i;\n\t\t\t\tc[b][1]=j;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tax+=c[i][0]*(int)pow(3.0,c[i][1]);\n\t\t}\n\t\tcx=15000000;\n\t\trx=min(ax,cx);\n\t\tif(rx>m){cout<<\"-1\"<<endl;}\n\t\telse{cout<<rx<<endl;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\nint N,M,p[15],n[15],i,j,t,q,R,s[16];\nint main()\n{\n\tfor(i=s[0]=1;i<16;i++)s[i]=s[i-1]*3;\n\tfor(;scanf(\"%d%d\",&N,&M),N;)\n\t{\n\t\tmemset(n,0,sizeof(n));\n\t\tfor(i=R=0;i<3;i++)\n\t\t\tfor(scanf(\"%d\",&t),j=0;j<t;p[N-q]=i,j++)\n\t\t\t\tscanf(\"%d\",&q);\n\t\tfor(i=N-1;i>=0;i--)\n\t\t{\n\t\t\tswitch(abs(p[i]-n[i]))\n\t\t\t{\n\t\t\tcase 0:break;\n\t\t\tcase 1:R+=s[i];for(j=0;j<i;j++)n[j]=2-n[i];break;\n\t\t\tcase 2:R+=2*s[i];for(j=0;j<i;j++)n[j]=2-n[i];break;\n\t\t\t}\n\t\t}\n\t\tR=R>s[N]-R?s[N]-R:R;\n\t\tprintf(\"%d\\n\",R>=M?-1:R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define INF 100000000\nint m;\nint tr[3][15];\nint otr[3][15];\nint ctr[3];\nint octr[3];\nint p[15];\nint d[15];\nint op[15];\nint od[15];\nbool ng=false;\nint min(int a,int b){return a<b?a:b;}\nint max(int a,int b){return a>b?a:b;}\nint other(int a,int b){\n\tint p,q;\n\tp=min(a,b);\n\tq=max(a,b);\n\tif(p==0&&q==1)return 2;\n\telse if(p==0&&q==2)return 1;\n\telse return 0;\n}\nint solve(int from,int dep,int to){\n\tif(from==to)return 0;\n\tif(abs(from-to)==2){\n\t\treturn solve(from,dep,1)+solve(1,ctr[1]-1,to);\n\t}\n\tif(ng)return INF;\n\tbool f=true;\n\tint t=0;\n\twhile(f){\n\t\tif(ng)return INF;\n\t\tf=false;\n\t\tif(dep!=ctr[from]-1){\n\t\t\tf=true;\n\t\t\tt+=solve(from,dep+1,other(from,to));\n\t\t}\n\t\tif(tr[to][ctr[to]-1]>tr[from][dep]){\n\t\t\tf=true;\n\t\t\tt+=solve(to,ctr[to]-1,other(from,to));\n\t\t}\n\t}\n\ttr[to][ctr[to]++]=tr[from][dep];\n\tctr[from]--;\n\tp[tr[from][dep]-1]=to;\n\td[tr[from][dep]-1]=ctr[to]-1;\n\tt++;\n\tif(t>=m){\n\t\tng=true;\n\t\treturn INF;\n\t}\n\treturn t;\n}\n\t\t\t\nint main(){\n\tint n;\n\tint i,j;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&m);\n\tif(n==0)return 0;\n\tfor(i=0;i<3;i++){\n\t\tint t;\n\t\tctr[i]=0;\n\t\tscanf(\"%d\",&t);\n\t\tfor(j=0;j<t;j++){\n\t\t\tscanf(\"%d\",&tr[i][ctr[i]++]);\n\t\t\tp[tr[i][ctr[i]-1]-1]=i;\n\t\t\td[tr[i][ctr[i]-1]-1]=ctr[i]-1;\n\t\t}\n\t}\n\tint ans;\n\tint res=0;\n\tfor(i=0;i<3;i++){\n\t\toctr[i]=ctr[i];\n\t\tfor(j=0;j<15;j++)otr[i][j]=tr[i][j];\n\t}\n\tfor(i=0;i<n;i++){\n\t\top[i]=p[i];\n\t\tod[i]=d[i];\n\t}\n\tfor(i=0;i<n;i++)res+=solve(p[i],d[i],0);\n\tans=res;\n\tfor(i=0;i<3;i++){\n\t\tctr[i]=octr[i];\n\t\tfor(j=0;j<15;j++)tr[i][j]=otr[i][j];\n\t}\n\tfor(i=0;i<n;i++){\n\t\tp[i]=op[i];\n\t\td[i]=od[i];\n\t}\n\tres=0;\n\tfor(i=0;i<n;i++)res+=solve(p[i],d[i],2);\n\tans=min(ans,res);\n\tif(ans>=INF)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n\t}\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef pair<bitset<16> ,bitset<16> > P;\n\nnamespace std {\n\tbool operator < (const bitset<16>& a, const bitset<16>& b) {\n\t\treturn (a.to_ulong() < b.to_ulong());\n\t}\n}\n\n// 入力\nint n, m;\nbitset<16> cup[3];\n\nvoid debug(int a, int b, int c, int cnt){\n\tcout << \"[debug]\" << endl;\n\tcout << \"cnt:\" << cnt << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((a&i)? \"*\" : \"-\");\n\t}\n\tcout << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((b&i)? \"*\" : \"-\");\n\t}\n\tcout << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((c&i)? \"*\" : \"-\");\n\t}\n\tcout << endl << endl;;\n}\n\n// 一番上のカップを返す\nint top(int bits){\n\tfor(int i=(1<<(n-1)) ; i ; i >>= 1 ){\n\t\tif( bits & i ) return i;\n\t}\n\treturn 0;\n}\n\nbool is_goal(bitset<16> a, bitset<16> b, bitset<16> c){\n\treturn ( b == cup[1] && ((a == cup[0] && c == cup[2]) || (a == cup[2] && c == cup[0])) );\n}\n\n// 探索\nint bfs(){\n\t// d[P(a,b)] := cup[0] = a, cup[1] = b の状態 s のときの手数\n\t// (cup[2] = (2^n)-1-a-b で cup[2] を計算できる)\n\tmap<P,int> d;\n\tqueue<P> q;\n\t\n\tP s = P( bitset<16>() , bitset<16>() );\n\tq.push(s);\n\td[s] = 0;\n\t\n\twhile( !q.empty() ){\n\t\tP now = q.front();\n\t\tint cnt = d[now];\n\t\tq.pop();\n\t\t\n\t\t// a,b,c := カップの状態\n\t\t// a_top,b_top,c_top := 一番上のカップ\n\t\tint a = now.first.to_ulong();\n\t\tint b = now.second.to_ulong();\n\t\tint c = ((1<<n)-1) - a - b;\n\t\tint a_top = top(a);\n\t\tint b_top = top(b);\n\t\tint c_top = top(c);\n\t\t\n\t\t//debug(a,b,c,cnt);\n\t\t\n\t\t// ゴールのとき\n\t\tif( is_goal(now.first,now.second,bitset<16>(c)) ){\n\t\t\treturn cnt;\n\t\t}\n\t\t\n\t\t{\n\t\t\tint a_, b_, c_;\n\t\t\tif( a_top < b_top ){ // B -> A の移動\n\t\t\t\ta_ = a + b_top;\n\t\t\t\tb_ = b - b_top;\n\t\t\t\tc_ = c_;\n\t\t\t}else{ // A -> B の移動\n\t\t\t\ta_ = a - a_top;\n\t\t\t\tb_ = b + a_top;\n\t\t\t\tc_ = c;\n\t\t\t}\n\t\t\tP next = P( bitset<16>(a_) , bitset<16>(b_) );\n\t\t\tif( !d.count(next) && cnt + 1 <= m ){\n\t\t\t\td[next] = cnt + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint a_, b_, c_;\n\t\t\tif( c_top < b_top ){ // B -> C の移動\n\t\t\t\ta_ = a;\n\t\t\t\tb_ = b - b_top;\n\t\t\t\tc_ = c + b_top;\n\t\t\t}else{ // C -> B の移動\n\t\t\t\ta_ = a;\n\t\t\t\tb_ = b + c_top;\n\t\t\t\tc_ = c - c_top;\n\t\t\t}\n\t\t\tP next = P( bitset<16>(a_) , bitset<16>(b_) );\n\t\t\tif( !d.count(next) && cnt + 1 <= m ){\n\t\t\t\td[next] = cnt + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile( cin >> n >> m , n || m ){\n\t\t// 初期化\n\t\tcup[0] = cup[1] = cup[2] = bitset<16>(0);\n\t\t\n\t\tfor(int i=0 ; i < 3 ; i++ ){\n\t\t\tint k, e;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0 ; j < k ; j++ ){\n\t\t\t\tcin >> e;\n\t\t\t\tcup[i].set(e-1);\n\t\t\t\tcup[i] |= (1 << (e-1));\n\t\t\t}\n\t\t}\n\t\t//debug(cup[0],cup[1],cup[2],-1);\n\t\tint ans = bfs();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\n#define is insert\nusing namespace std;\ntypedef vector<vector<int> > st;\nint main(){\n\tint n,m,k,t;\n\twhile(cin>>n>>m,n){\n\t\tst s(3);vector<st> F;set<st> V;\n\t\trep(i,3){\n\t\t\tcin>>k;\n\t\t\trep(j,k)cin>>t,s[i].pb(t);\n\t\t}\n\t\tF.pb(s);V.is(s);\n\t\tif((s[0].empty()||s[2].empty())&&s[1].empty()){\n\t\t\tcout<<0<<endl; continue;\n\t\t}\n\t\tint step=0;\n\t\twhile(!F.empty()&&step++<m){\n\t\t\tvector<st> nF;\n\t\t\trep(i,F.size())rep(tray,3)rep(d,2){\n\t\t\t\tst cs=F[i],ns;\n\t\t\t\tif(cs[tray].empty())continue;\n\t\t\t\tint nt=tray+(d?1:-1);\n\t\t\t\tif(0<=nt&&nt<3&&cs[tray][cs[tray].size()-1]>(cs[nt].empty()?0:cs[nt][cs[nt].size()-1])){\n\t\t\t\t\tns=cs;\n\t\t\t\t\tns[nt].pb(cs[tray][cs[tray].size()-1]);\n\t\t\t\t\tns[tray].erase(ns[tray].end()-1);\n\t\t\t\t\tif(V.find(ns)==V.end()){\n\t\t\t\t\t\tnF.pb(ns),V.is(ns);\n\t\t\t\t\t\tif((ns[0].empty()||ns[2].empty())&&ns[1].empty()){\n\t\t\t\t\t\t\tcout<<step<<endl;goto NEXT;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tF=nF;\n\t\t}\n\t\tcout<<-1<<endl;\n\t\tNEXT:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n    int n,m;\n    while(1){\n        cin >> n >> m;\n        if(n == 0 && m == 0)break;\n        vector<int> cup;\n        bool flag = true;\n        rep(i,n) cup.push_back(0);\n        rep(i,3){\n            int n1;\n            cin >> n1;\n            rep(j,n1){\n                int n2;\n                cin >> n2;\n                n2--;\n                cup[n2] = i;\n            }\n        }//入力ここまで\n        queue<vector<int>> que;\n        que.push(cup);\n        map<vector<int>,int> mp;\n        mp[cup] = 0;\n        while(que.size()!=0){\n            cup = que.front();\n            que.pop();\n            //rep(i,cup.size())cout << cup[i];\n            //cout << endl;\n            int bigger[3] = {-1,-1,-1};\n            int maxcount = 0;\n            bool tray[3] ={true,true,true};\n            if(cup.size() == count(cup.begin(),cup.end(),0) ||cup.size() == count(cup.begin(),cup.end(),2)){\n                cout << mp[cup] << endl;\n                flag = false;\n                break;\n            }\n            rep(i,n){\n                int i2 = n-i-1;\n                rep(j,3){\n                    if(tray[j] == true && cup[i2] == j){\n                        tray[j] = false;\n                        bigger[maxcount] = i2;\n                        maxcount++;\n                        break;\n                    }\n                }\n                if(maxcount == 3)break;\n            }\n            int movecount = mp[cup] + 1;\n            if(movecount > m) break;\n            if(cup[bigger[0]]-1 >= 0){\n                cup[bigger[0]]--;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]++;\n            }\n            if(cup[bigger[0]]+1 <= 2){\n                cup[bigger[0]]++;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]--;\n            }\n            if(maxcount >= 2){\n                if(cup[bigger[1]]-1 >= 0 && cup[bigger[1]]-1 != cup[bigger[0]]){\n                    cup[bigger[1]]--;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]++;\n                }\n                else if(cup[bigger[1]]+1 <= 2 && cup[bigger[1]]+1 != cup[bigger[0]]){\n                    cup[bigger[1]]++;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]--;\n                }\n            }\n        }\n        if(flag) cout << \"-1\" << endl;\n        vector<int>().swap(cup);\n        mp.clear();\n        while(que.size()!=0)que.pop();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint tostate(int a, int b, int c, int k)\n{\n\tint mul;\n\tint ret = 0;\n\t\n\tfor(int i = 0, mul = 1; i < k; ++i, mul *= 3)\n\t\tret += ((a >> i) & 1) * 1 * mul;\n\tfor(int i = 0, mul = 1; i < k; ++i, mul *= 3)\n\t\tret += ((b >> i) & 1) * 2 * mul;\n\t\t\n\treturn ret;\n}\n\ninline int mhb(int x)\n{\n\tfor(int i = 31; i >= 0; --i) {\n\t\tif(x & (1 << i))\n\t\t\treturn 1 << i;\n\t}\n\t\n\treturn 0;\n}\n\nconst int inf = 1000000000;\nconst int pow3x5 = 3 * 3 * 3 * 3 * 3;\nconst int pow3x15 = pow3x5 * pow3x5 * pow3x5;\nbool visit[pow3x15];\n\nint check(int a, int b, int c, int remain, int k)\n{\n\tif(remain < 0)\n\t\treturn inf;\n\t\t\n\tif(b == 0 && (a == 0 || c == 0))\n\t\treturn remain;\n\n\tint state = tostate(a, b, c, k);\n\n\tif(visit[state])\n\t\treturn inf;\n\tvisit[state] = true;\n\t\n\tint ret = inf;\n\t\n\tif(a > b) {\n\t\tint move = mhb(a);\n\t\tint ta = a - move;\n\t\tint tb = b + move;\n\t\tret = min(ret, check(ta, tb, c, remain - 1, k));\n\t} else {\n\t\tint move = mhb(b);\n\t\tint ta = a + move;\n\t\tint tb = b - move;\n\t\tret = min(ret, check(ta, tb, c, remain - 1, k));\n\t}\n\t\n\tif(b > c) {\n\t\tint move = mhb(b);\n\t\tint tb = b - move;\n\t\tint tc = c + move;\n\t\tret = min(ret, check(a, tb, tc, remain - 1, k));\n\t} else {\n\t\tint move = mhb(c);\n\t\tint tb = b + move;\n\t\tint tc = c - move;\n\t\tret = min(ret, check(a, tb, tc, remain - 1, k));\n\t}\n\t\n\treturn ret;\n}\n\nint main()\n{\n\twhile(true) {\n\t\n\t\tint n, m;\n\t\t\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\t\t\n\t\tfill(visit + 0, visit + pow3x15, false);\n\t\t\n\t\tint a[3];\n\t\tint bita[3] = {0};\n\t\tint k = 0;\n\t\t\n\t\tfor(int i = 0; i < 3; ++i) {\n\t\t\tscanf(\"%d\", a + i);\n\t\t\tfor(int j = 0; j < a[i]; ++j) {\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tbita[i] += 1 << (t - 1);\n\t\t\t\tk = max(k, t);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = m - check(bita[0], bita[1], bita[2], m, k);\n\t\t\n\t\tprintf(\"%d\\n\", ans >= 0 ? ans : -1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define INF 100000000\nint m;\nint tr[3][15];\nint otr[3][15];\nint ctr[3];\nint octr[3];\nint p[15];\nint d[15];\nint op[15];\nint od[15];\nbool ng=false;\nint min(int a,int b){return a<b?a:b;}\nint max(int a,int b){return a>b?a:b;}\nint other(int a,int b){\n\tint p,q;\n\tp=min(a,b);\n\tq=max(a,b);\n\tif(p==0&&q==1)return 2;\n\telse if(p==0&&q==2)return 1;\n\telse return 0;\n}\nint solve(int from,int dep,int to){\n\tif(from==to)return 0;\n\tif(abs(from-to)==2){\n\t\treturn solve(from,dep,1)+solve(1,ctr[1]-1,to);\n\t}\n\tif(ng)return INF;\n\tbool f=true;\n\tint t=0;\n\twhile(f){\n\t\tif(ng)return INF;\n\t\tf=false;\n\t\tif(dep!=ctr[from]-1){\n\t\t\tf=true;\n\t\t\tt+=solve(from,dep+1,other(from,to));\n\t\t}\n\t\tif(tr[to][ctr[to]-1]>tr[from][dep]){\n\t\t\tf=true;\n\t\t\tt+=solve(to,ctr[to]-1,other(from,to));\n\t\t}\n\t}\n\ttr[to][ctr[to]++]=tr[from][dep];\n\tctr[from]--;\n\tp[tr[from][dep]-1]=to;\n\td[tr[from][dep]-1]=ctr[to]-1;\n\tt++;\n\tif(t>=m){\n\t\tng=true;\n\t\treturn INF;\n\t}\n\treturn t;\n}\n\t\t\t\nint main(){\n\tint n;\n\tint i,j;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&m);\n\tif(n==0)return 0;\n\tfor(i=0;i<3;i++){\n\t\tint t;\n\t\tctr[i]=0;\n\t\tscanf(\"%d\",&t);\n\t\tfor(j=0;j<t;j++){\n\t\t\tscanf(\"%d\",&tr[i][ctr[i]++]);\n\t\t\tp[tr[i][ctr[i]-1]-1]=i;\n\t\t\td[tr[i][ctr[i]-1]-1]=ctr[i]-1;\n\t\t}\n\t}\n\tint ans;\n\tint res=0;\n\tfor(i=0;i<3;i++){\n\t\toctr[i]=ctr[i];\n\t\tfor(j=0;j<15;j++)otr[i][j]=tr[i][j];\n\t}\n\tfor(i=0;i<n;i++){\n\t\top[i]=p[i];\n\t\tod[i]=d[i];\n\t}\n\tfor(i=0;i<n;i++)res+=solve(p[i],d[i],0);\n\tans=res;\n\tfor(i=0;i<3;i++){\n\t\tctr[i]=octr[i];\n\t\tfor(j=0;j<15;j++)tr[i][j]=otr[i][j];\n\t}\n\tfor(i=0;i<n;i++){\n\t\tp[i]=op[i];\n\t\td[i]=od[i];\n\t}\n\tres=0;\n\tfor(i=0;i<n;i++)res+=solve(p[i],d[i],2);\n\tans=min(ans,res);\n\tif(ans==INF)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n\t}\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n\n#define INF (1<<28)\n\nusing namespace std;\n\nint n, m;\nstack<int> p[3];\n\n#define AB 1\n#define BC 3\n\nint move(int from, int to, int prev) {\n    int c = p[from].top();\n    p[to].push(c);\n    p[from].pop();\n    if (p[1].top() == 0 && (p[0].top() == 0 || p[2].top() == 0)) return 1;\n    if (prev == BC) {\n        if (p[0].top() > p[1].top()) return move(0, 1, AB) + 1;\n        else if (p[0].top() < p[1].top()) return move(1, 0, AB) + 1;\n        return INF;\n    } else if (prev == AB) {\n        if (p[1].top() > p[2].top()) return move(1, 2, BC) + 1;\n        else if (p[1].top() < p[2].top()) return move(2, 1, BC) + 1;\n        return INF;\n    }\n}\n\nint solve() {\n    if (p[1].top() == 0 && (p[0].top() == 0 || p[2].top() == 0)) return 0;\n    int ans = INF;\n    stack<int> backup[3];\n    for (int i = 0; i < 3; i++) backup[i] = p[i];\n\n    if (p[0].top() > p[1].top()) {\n        ans = min(ans, move(0, 1, AB));\n        for (int i = 0; i < 3; i++) p[i] = backup[i];\n    } else {\n        ans = min(ans, move(1, 0, AB));\n        for (int i = 0; i < 3; i++) p[i] = backup[i];\n    }\n    if (p[1].top() > p[2].top()) {\n        ans = min(ans, move(1, 2, BC));\n        for (int i = 0; i < 3; i++) p[i] = backup[i];\n    } else {\n        ans = min(ans, move(2, 1, BC));\n        for (int i = 0; i < 3; i++) p[i] = backup[i];\n    }\n    return ans;\n}\n\nint main() {\n    while (cin >> n >> m, n || m) {\n        for (int i = 0; i < 3; i++) {\n            p[i] = stack<int>();\n            p[i].push(0);\n            int s; cin >> s;\n            for (int j = 0; j < s; j++) {\n                int c; cin >> c;\n                p[i].push(c);\n            }\n        }\n        int step = solve();\n        cout << (step > m ? -1 : step) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint bfs[15000000], power[20], n, K, b, c, a[15];\nqueue<vector<int> >Q;\nint hush(vector<int>v) {\n\tint p = 0;\n\tfor (int i = 0; i < v.size(); i++) p += power[i] * v[i];\n\treturn p;\n}\nint main() {\n\tpower[0] = 1;\n\tfor (int i = 1; i < 20; i++)power[i] = power[i - 1] * 3;\n\twhile (true) {\n\t\tfor (int i = 0; i < 15000000; i++)bfs[i] = 1000000000;\n\t\tcin >> n >> K; vector<int>s;\n\t\tif (n == 0 && K == 0)break;\n\t\tcin >> b; for (int i = 0; i < b; i++) { cin >> c; a[c - 1] = 0; }\n\t\tcin >> b; for (int i = 0; i < b; i++) { cin >> c; a[c - 1] = 1; }\n\t\tcin >> b; for (int i = 0; i < b; i++) { cin >> c; a[c - 1] = 2; }\n\t\tfor (int i = 0; i < n; i++)s.push_back(a[i]);\n\t\tbfs[hush(s)] = 0; Q.push(s);\n\t\twhile (!Q.empty()) {\n\t\t\tvector<int>a1, a2, a3, t = Q.front(); Q.pop();\n\t\t\tint V = hush(t);\n\t\t\tint A1 = -1, A2 = -1, A3 = -1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (t[i] == 0)A1 = i;\n\t\t\t\tif (t[i] == 1)A2 = i;\n\t\t\t\tif (t[i] == 2)A3 = i;\n\t\t\t}\n\t\t\tif (A1 >= 0 && A2 <= A1) {\n\t\t\t\tint P1 = hush(t) + power[A1];\n\t\t\t\tif (bfs[P1] == 1000000000) { t[A1] = 1; bfs[P1] = bfs[V] + 1; Q.push(t); t[A1] = 0; }\n\t\t\t}\n\t\t\tif (A2 >= 0 && A1 <= A2) {\n\t\t\t\tint P1 = hush(t) - power[A2];\n\t\t\t\tif (bfs[P1] == 1000000000) { t[A2] = 0; bfs[P1] = bfs[V] + 1; Q.push(t); t[A2] = 1; }\n\t\t\t}\n\t\t\tif (A2 >= 0 && A3 <= A2) {\n\t\t\t\tint P1 = hush(t) + power[A2];\n\t\t\t\tif (bfs[P1] == 1000000000) { t[A2] = 2; bfs[P1] = bfs[V] + 1; Q.push(t); t[A2] = 1; }\n\t\t\t}\n\t\t\tif (A3 >= 0 && A2 <= A3) {\n\t\t\t\tint P1 = hush(t) - power[A3];\n\t\t\t\tif (bfs[P1] == 1000000000) { t[A3] = 1; bfs[P1] = bfs[V] + 1; Q.push(t); t[A3] = 2; }\n\t\t\t}\n\t\t}\n\t\tint L = min(bfs[0], bfs[power[n] - 1]);\n\t\tif (L > K)L = -1;\n\t\tcout << L << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\nusing namespace std;\nint kai;\nint kotae = 15000099;\nstack<int> a;\nstack<int> b;\nstack<int> c;\nint check(int now,int K)\n{\n\tif (now > kai)return 0;\n\tif (now >= kotae)return 0;\n\tif (b.empty()){\n\t\tif (a.empty()){\n\t\t\tkotae = now;\n\t\t\treturn 1;\n\t\t}\n\t\telse if (c.empty())\n\t\t{\n\t\t\tkotae = now;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tint ans = 0;\n\n\tif (!a.empty()&&K!=2){\n\t\tif (b.empty() || a.top() > b.top())\n\t\t{\n\t\t\tb.push(a.top());\n\t\t\ta.pop();\n\t\t\tans += check(now + 1,1);\n\t\t\ta.push(b.top());\n\t\t\tb.pop();\n\t\t}\n\t}\n\n\tif (!b.empty()&&K!=1){\n\t\tif (a.empty() || a.top() < b.top())\n\t\t{\n\t\t\ta.push(b.top());\n\t\t\tb.pop();\n\t\t\tans += check(now + 1,2);\n\t\t\tb.push(a.top());\n\t\t\ta.pop();\n\t\t}\n\t}\n\n\tif (!b.empty()&&K!=4)\n\t{\n\t\tif (c.empty() || b.top() > c.top())\n\t\t{\n\t\t\tc.push(b.top());\n\t\t\tb.pop();\n\t\t\tans += check(now + 1,3);\n\t\t\tb.push(c.top());\n\t\t\tc.pop();\n\t\t}\n\t}\n\n\tif (!c.empty()&&K!=3)\n\t{\n\t\tif (b.empty() || b.top() < c.top())\n\t\t{\n\t\t\tb.push(c.top());\n\t\t\tc.pop();\n\t\t\tans += check(now + 1,4);\n\t\t\tc.push(b.top());\n\t\t\tb.pop();\n\t\t}\n\t}\n\n\n\n\n\treturn ans;\n}\nint main()\n{\n\twhile (1){\n\t\tkotae = 15000099;\n\t\twhile (!a.empty())a.pop();\n\t\twhile (!b.empty())b.pop();\n\t\twhile (!c.empty())c.pop();\n\t\tint su;\n\t\tcin >> su >> kai;\n\t\tif (!su&&!kai)break;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tint qw;\n\t\t\tcin >> qw;\n\t\t\tfor (int I = 0; I < qw; I++)\n\t\t\t{\n\t\t\t\tint A;\n\t\t\t\tcin >> A;\n\t\t\t\tif (i == 0)a.push(A);\n\t\t\t\tif (i == 1)b.push(A);\n\t\t\t\tif (i == 2)c.push(A);\n\t\t\t}\n\t\t}\n\t\tcheck(0,-1);\n\t\tif (kotae != 15000099)cout << kotae << endl;\n\t\telse cout << -1 << endl;\n\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<utility>\n#include<vector>\nusing namespace std;\nint main() {\n\tint ans1, ans2;\n\tint n, m, na, nb, nc, tyo, place[16], ans;\n\tint cup[3][16];\n\twhile (1) {\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tfor (int j = 0; j < 16; ++j)\n\t\t\t\tcup[i][j] = 0;\n\t\t}\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\t\tcin >> na;\n\t\tfor (int i = 0; i < na; ++i) cin >> cup[0][i];\n\t\tcin >> nb;\n\t\tfor (int i = 0; i < nb; ++i)cin >> cup[1][i];\n\t\tcin >> nc;\n\t\tfor (int i = 0; i < nc; ++i)cin >> cup[2][i];\n\t\tfor (int p = 0; p < 2; ++p) {\n\t\t\ttyo = 0;\n\t\t\tif (p == 0)place[0] = 0;\n\t\t\telse place[0] = 2;\n\t\t\tint np;\n\t\t\tif (place[0] == 0)np = 2;\n\t\t\telse np = 0;\n\t\t\tfor (int k = 1; k < 16; ++k) place[k] = place[0];\n\t\t\tbool bo = false; int at, ar;\n\t\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t\tfor (int j = 0; j < na; ++j) {\n\t\t\t\t\tif (cup[0][j] == i) {\n\t\t\t\t\t\tat = 0;\n\t\t\t\t\t\tar = j;\n\t\t\t\t\t\tbo = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < nb; ++j) {\n\t\t\t\t\tif (bo)break;\n\t\t\t\t\tif (cup[1][j] == i) {\n\t\t\t\t\t\tat = 1;\n\t\t\t\t\t\tar = j;\n\t\t\t\t\t\tbo = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < nc; ++j) {\n\t\t\t\t\tif (bo)break;\n\t\t\t\t\tif (cup[2][j] == i) {\n\t\t\t\t\t\tat = 2;\n\t\t\t\t\t\tar = j;\n\t\t\t\t\t\tbo = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbo = false;\n\t\t\t\tif (at == place[i]) {\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (at == 1) {\n\t\t\t\t\t\ttyo += pow(3, n - i);\n\t\t\t\t\t\tfor (int k = i + 1; k < 16; ++k) {\n\t\t\t\t\t\t\tif (place[k] == 0)place[k] = 2;\n\t\t\t\t\t\t\telse place[k] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse tyo += 2 * (pow(3, n - i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p == 0)ans1 = tyo;\n\t\t\telse ans2 = tyo;\n\t\t}\n\t\tif (m < min(ans1, ans2))cout << -1 << endl;\n\t\telse cout << min(ans1, ans2) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n\nint n, m, cnt, a[16], b[16];\n\nvoid move(int num, int dest, int* a);\n\nint main() {\n\t\n\twhile (1) {\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0)break;\n\n\t\tint num, tmp;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcin >> num;\n\t\t\tfor (int j = 0; j < num; j++) {\n\t\t\t\tcin >> tmp;\n\t\t\t\ta[tmp] = i;\n\t\t\t\tb[tmp] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcnt = 0;\n\t\tfor (int num = 1; num <= n; num++) {\n\t\t\tmove(num, 2, a);\n\t\t}\n\t\tint ans1 = cnt;\n\t\t\n\t\tcnt = 0;\n\t\tfor (int num = 1; num <= n; num++) {\n\t\t\tmove(num, 0, b);\n\t\t}\n\t\tint ans2 = cnt;\n\n\t\tint ans;\n\t\tif (ans1 == -1) {\n\t\t\tans = ans2;\n\t\t} else if(ans2 == -1){\n\t\t\tans = ans1;\n\t\t} else {\n\t\t\tans = min(ans1, ans2);\n\t\t}\n\t\tcout << ans << endl << endl;\n\t}\n\n\n\treturn 0;\n}\n\nvoid move(int num, int dest, int* a) {\n\t\n\tif (cnt > m || cnt == -1) {\n\t\tcnt = -1;\n\t\treturn;\n\t}\n\n\tint dist = abs(dest - a[num]);\n\tif (dist == 0) {\n\t\treturn;\n\t} else if (dist == 1) {\n\t\tif (num == n) {\n\t\t\tcnt += 1;\n\t\t\ta[num] = dest;\n\t\t} else {\n\t\t\tmove(num + 1, 3 - dest - a[num], a);\n\t\t\tcnt += 1;\n\t\t\ta[num] = dest;\n\t\t}\n\t} else if (dist == 2) {\n\t\tif (num == n) {\n\t\t\tcnt += 2;\n\t\t\ta[num] = dest;\n\t\t} else {\n\t\t\tmove(num, 1, a);\n\t\t\tmove(num, dest, a);\n\t\t}\n\t}\n\n\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<utility>\n#include<vector>\nusing namespace std;\nint main() {\n\tint n, m, na, nb, nc, tyo, place[16];\n\tint cup[3][16];\n\n\twhile (1) {\n\t\ttyo = 0;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tfor (int j = 0; j < 16; ++j)\n\t\t\t\tcup[i][j] = 0;\n\t\t}\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\t\tcin >> na;\n\t\tfor (int i = 0; i < na; ++i) cin >> cup[0][i];\n\t\tcin >> nb;\n\t\tfor (int i = 0; i < nb; ++i)cin >> cup[1][i];\n\t\tcin >> nc;\n\t\tfor (int i = 0; i < nc; ++i)cin >> cup[2][i];\n\t\tif (cup[0][0] == 1)place[0] = 0;\n\t\telse if (cup[2][0] == 1)place[0] = 2;\n\t\telse if (cup[0][0] == 0)place[0] = 0;\n\t\telse if (cup[2][0] == 0)place[0] = 2;\n\t\telse if (cup[0][0] > cup[2][0])place[0] = 0;\n\t\telse place[0] = 2;\n\t\tint np;\n\t\tif (place[0] == 0)np = 2;\n\t\telse np = 0;\n\t\tfor (int k = 1; k < 16; ++k) {\n\t\t\tplace[k] = place[0];\n\t\t}\n\t\tbool bo = false; int at, ar;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tfor (int j = 0; j < na; ++j) {\n\t\t\t\tif (cup[0][j] == i) {\n\t\t\t\t\tat = 0;\n\t\t\t\t\tar = j;\n\t\t\t\t\tbo = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < nb; ++j) {\n\t\t\t\tif (bo)break;\n\t\t\t\tif (cup[1][j] == i) {\n\t\t\t\t\tat = 1;\n\t\t\t\t\tar = j;\n\t\t\t\t\tbo = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < nc; ++j) {\n\t\t\t\tif (bo)break;\n\t\t\t\tif (cup[2][j] == i) {\n\t\t\t\t\tat = 2;\n\t\t\t\t\tar = j;\n\t\t\t\t\tbo = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbo = false;\n\t\t\tif (at == place[i]) {\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (at == 1) {\n\t\t\t\t\ttyo += pow(3, n - i);\n\t\t\t\t\tfor (int k = i + 1; k < 16; ++k) {\n\t\t\t\t\t\tif (place[k] == 0)place[k] = 2;\n\t\t\t\t\t\telse place[k] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttyo += 2 * (pow(3, n - i));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (m < tyo)cout << -1 << endl;\n\t\telse cout << tyo << endl;\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint calc(vector<int> cup, int m)\n{\n    int cnt = 0;\n    while (1) {\n        int i = cnt%2, j = i+1;\n        int p = 1;\n        while (p <= max(cup[i], cup[j])) p <<= 1;\n        p >>= 1;\n        if (!p) break;\n        cup[i] ^= p;\n        cup[j] ^= p;\n        cnt++;\n        if (cnt > m) return cnt;\n    }\n\n    return cnt;\n}\n\nint main()\n{\n    while (1) {\n        int n, m; cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        vector<int> cup(3);\n        loop (3, i) {\n            int c; cin >> c;\n            while (c--) {\n                int v; cin >> v;\n                cup[i] |= 1 << v--;\n            }\n        }\n        int ans = calc(cup, m);\n        swap(cup[0], cup[2]);\n        ans = min(ans, calc(cup, m));\n        cout << (ans <= m ? ans : -1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int>> mat;\n\nint n, m;\n\nbool isChange(int &from, int &to, mat &g) {\n    auto s = g[from];\n    auto t = g[to];\n    if (s.size() == 0) return false;\n    if (t.size() > 0 && t[t.size() - 1] > s[s.size() - 1]) return false;\n    t.push_back(s[s.size() - 1]);\n    s.erase(s.begin() + s.size() - 1);\n    g[from] = s;\n    g[to] = t;\n\n    return true;\n}\n\n\nbool change(int &now, int &pre, mat &g) {\n    vector<int> from = {0, 1, 1, 2};\n    vector<int> to = {1, 2, 0, 1};\n    for (int i = 0; i < 4; i++) {\n        if (to[i] == pre && from[i] == now) continue;\n        if (isChange(from[i], to[i], g)) {\n            now = to[i];\n            pre = from[i];\n\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    while (cin >> n >> m, n || m) {\n        mat v(3);\n        for (auto &i : v) {\n            int c; cin >> c;\n            for (int j = 0; j < c; j++) {\n                int x; cin >> x;\n                i.push_back(x);\n            }\n        }\n\n\n        mat g1(3), g2(3);\n        for (int i = 1; i <= n; i++) {\n            g1[0].push_back(i);\n            g2[2].push_back(i);\n        }\n\n        int res = 1 << 28;\n        vector<int> now = {0, 1, 1, 2};\n        vector<int> pre = {1, 0, 2, 1};\n        for (int i = 0; i < 4; i++) {\n            int tmp = 0;\n            auto g(v);\n            while (tmp <= m) {\n                if (g[0].size() == n || g[2].size() == n) break;\n                if (!change(now[i], pre[i], g)) {\n                    tmp = 1 << 28;\n                    break;\n                }\n                tmp++;\n            }\n            res = min(res, tmp);\n        }\n\n        cout << (res > m ? -1 : res) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint visited[15000000];\n\nint mypow(int x,int n){\n\tint res = 1;\n\twhile(n>0){\t\t\n\t\tres *= x;\n\t\tif(n & 1) x = x*x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\nint conv(vector<int>& sets,int n){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * mypow(3,j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,int n,vector<int>& root, int* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root,n)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp,n))] > cost + 1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp,n))] > cost + 1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\t\n\t\tmemset(visited,0x3f,sizeof(visited));\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,n,sets,visited));\n\t}\n\n\t//printf(\"%d %d %d\\n\",mypow(3,0),mypow(3,1),mypow(3,2));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<stack>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n    int dep;\n    stack<int> s[3];\n};\nbool memo[14348908] = {};\n\nint int_pow(int n,int m){\n    int ans = 1;\n    while(m--){\n        ans *= n;\n    }\n    return ans;\n}\n\nint main(){\n    int hoge,n;\n    while(cin>>hoge>>n,n || hoge){\n        for(int i=0;i<14348908;i++) memo[i] = false;\n        Data q_c,q_d,first;\n        int m,input,nt,cup,cntempty,state,nowdep;\n\t\tbool flag;\n        int situ[2] = {-1,1};\n        queue<Data> q;\n        for(int i=0;i<3;i++){\n            cin>>m;\n            for(int j=0;j<m;j++){\n                cin>>input;\n                first.s[i].push(input);\n            }\n        }\n        first.dep = 0;\n        q.push(first);\n        flag = false;\n        while(!q.empty()){\n            q_c = q.front();\n            q.pop();\n            /*if(q_c.dep%1000 == 0){\n                printf(\"%d\\n\",q_c.dep);\n            }*/\n            //for(int i=0;i<3;i++) printf(\"%d \",!q_c.s[i].empty());\n            //puts(\"\");\n            if(q_c.dep == n) break;\n            cntempty = 0;\n            for(int i=0;i<3;i++){\n                if(!q_c.s[i].empty()){\n                    if(i == 1){\n                        cntempty = 0;\n                        break;\n                    }\n                    cntempty++;\n                }\n            }\n            if(cntempty == 1){\n                printf(\"%d\\n\",q_c.dep);\n                flag = true;\n                break;\n            }\n            q_d = q_c;\n            state = 0;\n            for(int i=0;i<3;i++){\n                while(!q_d.s[i].empty()){\n                    cup = q_d.s[i].top();\n                    q_d.s[i].pop();\n                    state += i*int_pow(3,cup-1);\n                }\n            }\n            if(memo[state]) continue;\n            memo[state] = true;\n            //printf(\"%d\\n\",state);\n            for(int i=0;i<3;i++){\n                for(int j=0;j<2;j++){\n                    nt = i+situ[j];\n                    if(nt<0 || 3<=nt) continue;\n                    q_d = q_c;\n                    if(q_d.s[i].empty()) continue;\n                    cup = q_d.s[i].top();\n                    q_d.s[i].pop();\n                    if(!q_d.s[nt].empty() && cup < q_d.s[nt].top()) continue;\n                    q_d.s[nt].push(cup);\n                    q_d.dep++;\n                    q.push(q_d);\n                }\n            }\n        }\n        if(!flag) printf(\"-1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint visited[14500000];\n\n/*\nint mypow(int x,int n){\n\tint res = 1;\n\twhile(n>0){\t\t\n\t\tres *= x;\n\t\tif(n & 1) x = x*x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n*/\n\nint conv(vector<int>& sets,int n){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * pow(3.0,j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,int n,vector<int>& root,int* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root,n)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp,n))] > cost + 1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=n;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp,n))] > cost + 1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\t\n\t\tmemset(visited,0x3f,sizeof(visited));\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,n,sets,visited));\n\t}\n\t//printf(\"%d %d %d\\n\",mypow(3,0),mypow(3,1),mypow(3,2));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    vector<int> pow3(16, 1);\n    for(int i=1; i<=15; ++i)\n        pow3[i] = pow3[i-1] * 3;\n\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > a(3);\n        for(int i=0; i<3; ++i){\n            int b;\n            cin >> b;\n            a[i].resize(b);\n            for(int j=0; j<b; ++j)\n                cin >> a[i][j];\n            a[i].push_back(-1);\n        }\n\n        int ret = INT_MAX;\n        for(int start=0; start<3; start+=3){\n            int prev = start;\n            vector<int> k(3, 0);\n            int cost = 0;\n\n            for(int i=1; i<=n; ++i){\n                int curr;\n                for(int j=0; j<3; ++j){\n                    if(a[j][k[j]] == i){\n                        curr = j;\n                        ++ k[j];\n                    }\n                }\n\n                if(curr == 1){\n                    cost += pow3[n-i];\n                    prev ^= 2;\n                }else if(curr != prev){\n                    cost += pow3[n-i] + 1;\n                }\n            }\n\n            ret = min(ret, cost);\n        }\n\n        if(ret <= m)\n            cout << ret << endl;\n        else\n            cout << -1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define EPS 1e-10\n#define INF 1 << 30\n#define LLINF LLONG_MAX/3\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\nll power(ll x,ll n){ll a=1;REP(i,n)a*=x;return a;}\n\nint p[20];\n\nint f(int a, int b, int c)\n{\n  if(!b&&!c) return 0;\n  int s = (a|b|c)>>1;\n  int t = 0;\n  while(s&1) {t++;s>>=1;}\n  if(1&a) return f(a>>1,b>>1,c>>1);\n  if(1&b) return f(c>>1,b>>1,a>>1)+p[t];\n  if(1&c) return f(a>>1,b>>1,c>>1)+2*p[t];\n}\n\nint main()\n{\n  int n,m;\n  REP(i,20)\n  {\n    p[i] = pow(3,i);\n  }\n  while(cin >> n >> m,n)\n  {\n    int a[3] = {0};\n    REP(i,3)\n    {\n      int t,u; cin >> t;\n      REP(j,t)\n      {\n        cin >> u;\n        a[i] |= 1 << u-1;\n      }\n    }\n    int ans = min(f(a[0],a[1],a[2]),f(a[2],a[1],a[0]));\n    cout << (ans>m?-1:ans) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tint n, m;\n\tll dp[16] = {};\n\tdp[0] = 1;\n\trep(i, 1,16) {\n\t\tdp[i] = dp[i - 1] * 3;\n\t}\n\n\twhile (scanf(\"%d %d\", &n, &m)) {\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tvector<int> pos(n);\n\t\tREP(i, 3) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\n\n\t\t\tREP(j, c) {\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\", &size);\n\n\t\t\t\tpos[size - 1] = i;\n\t\t\t}\n\t\t}\n\t\tll ans = 0, ans2 = 0;\n\t\tbool curs = 0;\n\t\tREP(i, n) {\n\t\t\tif (pos[i] % 2) {\n\t\t\t\tans += dp[n - i - 1];\n\t\t\t\tcurs = 1 - curs;\n\t\t\t}\n\t\t\telse if (curs * 2 - pos[i]) {\n\t\t\t\tans += dp[n - i-1]*2;\n\t\t\t}\n\t\t}\n\t\tcurs = 1;\n\t\tREP(i, n) {\n\t\t\tif (pos[i] % 2) {\n\t\t\t\tans2 += dp[n - i - 1];\n\t\t\t\tcurs = 1 - curs;\n\t\t\t}\n\t\t\telse if (curs * 2 - pos[i]) {\n\t\t\t\tans2 += dp[n - i-1]*2;\n\t\t\t}\n\t\t}\n\t\tans = min(ans2, ans);\n\t\tif (ans > m)\n\t\t\tans = -1;\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{\n// vim:filetype=cpp foldmethod=marker foldmarker={{{,}}}\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define ALL(A)\t\t(A).begin(),(A).end()\n#define DUMP(A)    cout<<#A<<\"=\"<<(A)<< endl\n#define SIZE(A)    (int)((A).size())\n#define MP  make_pair\n#define PB  push_back\nusing namespace std;\ntypedef long long ll;\n\nint vx[]={1,0,-1,0},vy[]={0,1,0,-1};\n// }}}\n\nint main(){\n    int n,m;\n    for(;;){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0) break;\n        stack<int> sts[3],temp[3];\n        for(int i=0;i<3;i++){\n            int p,num;\n            scanf(\"%d\",&p);\n            for(int j=0;j<p;j++){\n                scanf(\"%d\",&num);\n                sts[i].push(num);\n            }\n            temp[i]=sts[i];\n        }\n        int mi=INT_MAX;\n        bool isle=true;\n        if(sts[0].size()==n || sts[2].size()==n){\n            mi=min(mi,0);\n        }else{\n            for(int i=0;i<m;i++){\n                if(isle){\n                    if(sts[0].empty() || (!sts[1].empty() && sts[0].top()<sts[1].top())){\n                        sts[0].push(sts[1].top());\n                        sts[1].pop();\n                    }else{\n                        sts[1].push(sts[0].top());\n                        sts[0].pop();\n                    }\n                }else{\n                    if(sts[1].empty() || (!sts[2].empty() && sts[1].top()<sts[2].top())){\n                        sts[1].push(sts[2].top());\n                        sts[2].pop();\n                    }else{\n                        sts[2].push(sts[1].top());\n                        sts[1].pop();\n                    }\n                }\n                isle=!isle;\n                if(sts[0].size()==n || sts[2].size()==n){\n                    mi=min(mi,i+1);\n                    break;\n                }\n            }\n            for(int i=0;i<3;i++){\n                sts[i]=temp[i];\n            }\n            isle=false;\n            for(int i=0;i<m;i++){\n                if(isle){\n                    if(sts[0].empty() || (!sts[1].empty() && sts[0].top()<sts[1].top())){\n                        sts[0].push(sts[1].top());\n                        sts[1].pop();\n                    }else{\n                        sts[1].push(sts[0].top());\n                        sts[0].pop();\n                    }\n                }else{\n                    if(sts[1].empty() || (!sts[2].empty() && sts[1].top()<sts[2].top())){\n                        sts[1].push(sts[2].top());\n                        sts[2].pop();\n                    }else{\n                        sts[2].push(sts[1].top());\n                        sts[1].pop();\n                    }\n                }\n                if(sts[0].size()==n || sts[2].size()==n){\n                    mi=min(mi,i+1);\n                    break;\n                }\n                isle=!isle;\n            }\n        }\n        if(mi==INT_MAX) printf(\"%d\\n\",-1);\n        else printf(\"%d\\n\",mi);\n\nLABEL:  ;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n\t{\n\t  finish.push(i);\n\t}\n      for(int i=0;i<3;i++)\n\t{\n\t  int size;\n\t  cin>>size;\n\t  for(int j=0;j<size;j++)\n\t    {\n\t      int tmp;\n\t      cin>>tmp;\n\t      table[i].push(tmp);\n\t    }\n\t}\n      //stack,step;\n      queue<pair<pair<stack<char>,stack<char> >,pair<stack<char> ,int> > > qu;\n      qu.push(make_pair(make_pair(table[0],table[1]),make_pair(table[2],0)));\n      int ans=-1;\n      while(!qu.empty())\n\t{\n\t  stack<char>a=qu.front().first.first;\n\t  stack<char>b=qu.front().first.second;\n\t  stack<char>c=qu.front().second.first;\n\t  int step=qu.front().second.second;\n\t  qu.pop();\n\n\t  if(a==finish || c==finish)\n\t    {\n\t      ans=step;\n\t      break;\n\t    }\n\n\t  if(hash.find(make_pair(a,c))!=hash.end())\n\t    continue;\n\t  hash.insert(make_pair(a,c));\n\n\t  if(step==m)\n\t    continue;\n\n\t  if(!a.empty())\n\t    {\n\t      if(b.empty()||a.top()>b.top() )\n\t\t{\n\t\t  int tmp=a.top();\n\t\t  a.pop();\n\t\t  b.push(tmp);\n\t\t  if(hash.find(make_pair(a,c))==hash.end())\n\t\t    qu.push(make_pair(make_pair(a,b),make_pair(c,step+1)));\n\t\t  tmp=b.top();\n\t\t  b.pop();\n\t\t  a.push(tmp);\n\t\t}\n\t    }\n\t  if(!b.empty())\n\t    {\n\t      if(a.empty()||a.top()<b.top() )\n\t\t{\n\t\t  int tmp=b.top();\n\t\t  b.pop();\n\t\t  a.push(tmp);\n\t\t  if(hash.find(make_pair(a,c))==hash.end())\n\t\t    qu.push(make_pair(make_pair(a,b),make_pair(c,step+1)));\n\t\t  tmp=a.top();\n\t\t  a.pop();\n\t\t  b.push(tmp);\n\t\t}\n\n\t      if(c.empty()||c.top()<b.top() )\n\t\t{\n\t\t  int tmp=b.top();\n\t\t  b.pop();\n\t\t  c.push(tmp);\n\t\t  if(hash.find(make_pair(a,c))==hash.end())\n\t\t    qu.push(make_pair(make_pair(a,b),make_pair(c,step+1)));\n\t\t  tmp=c.top();\n\t\t  c.pop();\n\t\t  b.push(tmp);\n\t\t}\n\n\t    }\n\t  if(!c.empty())\n\t    {\n\t      if(b.empty()||b.top()<c.top() )\n\t\t{\n\t\t  int tmp=c.top();\n\t\t  c.pop();\n\t\t  b.push(tmp);\n\t\t  if(hash.find(make_pair(a,c))==hash.end())\n\t\t    qu.push(make_pair(make_pair(a,b),make_pair(c,step+1)));\n\t\t  tmp=b.top();\n\t\t  b.pop();\n\t\t  c.push(tmp);\n\t\t}\n\n\t    }\n\n\n\n\t}\n      cout<<ans<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <fstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nstatic const double EPS = 1e-5;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nstatic const int MAX = 15000001;\nint n,m;\nint hanoi(stack<int> stqn[3], int phase){\n  int ret = MAX, tpr;\n  bool a=stqn[0].empty(), b=stqn[1].empty(), c=stqn[2].empty();\n  if(b && (a||c)) return phase;\n  if(phase==m) return -1;\n  stack<int> tmp[3];\n  if(!a && (b||stqn[1].top()<stqn[0].top())){\n    REP(i,3) tmp[i]=stqn[i];\n    tmp[1].push(tmp[0].top());\n    tmp[0].pop();\n    if((tpr=hanoi(tmp, phase+1))!=-1){\n      ret = min(ret, tpr);\n    }\n  }\n  if(!b && (a||stqn[0].top()<stqn[1].top())){\n    REP(i,3) tmp[i]=stqn[i];\n    tmp[0].push(tmp[1].top());\n    tmp[1].pop();\n    if((tpr=hanoi(tmp, phase+1))!=-1){\n      ret = min(ret, tpr);\n    }\n  }\n  if(!b && (c||stqn[2].top()<stqn[1].top())){\n    REP(i,3) tmp[i]=stqn[i];\n    tmp[2].push(tmp[1].top());\n    tmp[1].pop();\n    if((tpr=hanoi(tmp, phase+1))!=-1){\n      ret = min(ret, tpr);\n    }\n  }\n  if(!c && (b||stqn[1].top()<stqn[2].top())){\n    REP(i,3) tmp[i]=stqn[i];\n    tmp[1].push(tmp[2].top());\n    tmp[2].pop();\n    if((tpr=hanoi(tmp, phase+1))!=-1){\n      ret = min(ret, tpr);\n    }\n  }\n  if(ret!=MAX) return ret;\n  else return -1;\n}\nint main(void){\n  while(cin>>n>>m){\n    stack<int> ini[3];\n    if(n==0) break;\n    REP(i,3){\n      int ko;\n      int tmp;\n      cin>>ko;\n      REP(j,ko){\n        cin>>tmp;\n        ini[i].push(tmp);\n      }\n    }\n    int ans = hanoi(ini, 0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<utility>\n#include<vector>\nusing namespace std;\nvoid input();\nvoid solve();\nvoid saiki(int,int,int,int);\nvoid narabi();\nint n,m,o,na,nb,nc,ans=0;\npair<int,int>at;\nint place=-1;\nint cup[3][10001]={0};\npair<int,int>maxi;\nint main(){\n    while(1){\n        cin>>n>>m;\n        if(n==0 && m==0)break;\n        input();\n        solve();\n        if(ans<m){\n            cout<<ans<<endl;\n        }\n        else{\n            cout<<-1<<endl;\n        }\n        ans=0;\n    }\n    return 0;\n}\nvoid saiki(int targetx,int targety,int tox,int toy){\n    if(cup[targetx][targety+1]!=0){\n        saiki(targetx,targety+1,tox,toy);\n    }\n    if(cup[tox][toy]>cup[targetx][targety]) {\n        int i=0,count=0;\n        while(1){\n            if(cup[1][i]!=0){\n                count++;\n            }\n            else break;\n            i++;\n        }\n        saiki(targetx,targety,1,count);\n    }\n    swap(cup[targetx][targety],cup[tox][toy]);\n    if(targetx>tox){\n        ans+=targetx-tox;\n    }\n    else{\n        ans+=tox-targetx;\n    }\n    return ;\n}\nvoid solve(){\n    bool bo;\n    //placeの確定\n    if(cup[0][0]==1){\n        place=0;\n    }\n    else if(cup[2][0]==1){\n        place=2;\n    }\n    else if(cup[0][0]==0){\n        place=0;\n    }\n    else if(cup[2][0]==0){\n        place=2;\n    }\n    else{\n        if(na>nc){\n            place=0;\n        }\n        else place=2;\n    }\n    int sp,u;\n    if(place==0){\n        sp=2;\n        u=nc;\n        }\n        else{\n            sp=0;\n            u=na;\n        }\n    while(1){\n    for(int target=1;target<=n;++target){\n        bo=false;\n        for(int i=0;i<3;++i){\n            for(int j=0;j<10001;++j){\n                if(cup[i][j]==target){\n                   // cout<<i<<\" \"<<j<<endl;\n                    bo=true;\n                    at.first=i;\n                    at.second=j;\n                    break;\n                }\n                if(cup[i][j]==0)break;\n            }\n            if(bo)break;\n        }\n        if(place==at.first)continue;\n        int i=0,count=0;\n        while(1){\n            if(cup[place][i]!=0)count++;\n            else break;\n            i++;\n        }\n        //cout<<at.first<<\" \"<<at.second<<\" \"<<place<<\" \"<<count<<endl;\n        saiki(at.first,at.second,place,count);\n    }\n        if(cup[1][0]==0&&cup[sp][0]==0)break;\n    }\n}\nvoid input(){\n    for(int i=0;i<3;++i){\n        for(int j=0;j<16;++j){\n            cup[i][j]=0;\n        }\n    }\n    cin>>na;\n    for(int i=0;i<na;++i){\n        cin>>cup[0][i];\n    }\n    cin>>nb;\n    for(int i=0;i<nb;++i){\n        cin>>cup[1][i];\n    }\n    cin>>nc;\n    for(int i=0;i<nc;++i){\n        cin>>cup[2][i];\n    }\n    return ;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint T[20];\nint A[20], B[20];\nint n, m;\n\nint solve() {\n    int P[17];\n    P[n] = 2;\n    for ( int i = n; i > 0; -- i ) P[i-1] = 3 * P[i] + 2;\n    \n    A[n] = T[n];\n    B[n] = 2 - T[n];\n    for ( int i = n; i > 1; -- i ) {\n        if ( T[i-1] == 0 ) {\n            A[i-1] = A[i];\n            B[i-1] = A[i] + 2 * P[i] + 2;\n        } else if ( T[i-1] == 1 ) {\n            A[i-1] = B[i] + P[i] + 1;\n            B[i-1] = A[i] + P[i] + 1;\n        } else if ( T[i-1] == 2 ) {\n            A[i-1] = A[i] + 2 * P[i] + 2;\n            B[i-1] = B[i];\n        }\n    }\n    int res = min( A[1], B[1] );\n    if ( res > m ) return -1;\n    return res;\n}\n\nint main() {\n    while ( cin >> n >> m && n ) {\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                T[t] = i;\n            }\n        }\n\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nbool dp[14400000];\nint N, M;\nint to_hash(const vector<int>&nums) {\n\tint hash = 0;\n\tfor (auto n : nums) {\n\t\thash = 3 * hash + n;\n\t}\n\treturn hash;\n}\nint getans(vector<int>&nums, int now) {\n\tint hash = to_hash(nums);\n\tif (dp[hash] == false) {\n\t\treturn M;\n\t}\n\tif (dp[hash] == true) {\n\t\tif (now >= M)return M;\n\t\tif (to_hash(nums) == 0) {\n\t\t\treturn now;\n\t\t}\n\t\telse {\n\t\t\tdp[hash] = false;\n\t\t\tvector<int>tops(3, -1);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\ttops[nums[i]] = i;\n\t\t\t}\n\t\t\tint ans = M;\n\t\t\tif (tops[0] < tops[1]) {\n\t\t\t\tif (tops[1] != -1) {\n\t\t\t\t\tnums[tops[1]] = 0;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tops[0] != -1) {\n\t\t\t\t\tnums[tops[0]] = 1;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[0]] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tops[1] < tops[2]) {\n\t\t\t\tif (tops[2] != -1) {\n\t\t\t\t\tnums[tops[2]] = 1;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[2]] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (tops[1] != -1) {\n\t\t\t\t\tnums[tops[1]] = 2;\n\t\t\t\t\tans = min(ans, getans(nums, now + 1));\n\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 14400000; ++i) {\n\t\t\tdp[i] = true;\n\t\t} cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<int>nows(N);\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tfor (int j = 0; j < a; ++j) {\n\t\t\t\tint b; cin >> b; b--;\n\t\t\t\tnows[b] = i;\n\t\t\t}\n\t\t}\n\t\tint ans = getans(nows, 0);\n\t\tif (ans == M)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nint n,m;\n\nint times(int A, int B, int C, int target)\n{\n    //printf(\"%d:%d:%d\\n\", A, B, C);\n    if( B & 1 )\n        return std::min(times(A>>1,B>>1,C>>1,-1), times(A>>1,B>>1,C>>1,1)) + 1 + times(((A|B|C)>>1) , 0, 0, 1);\n    if( A & 1 )\n        if( target == -1 )\n            return times(A>>1, B>>1, C>>1, -1);\n        else\n            return times(A>>1, B>>1, C>>1, 1) + 1 + times(0, 0, ((A|B|C)>>1) , -1) + 1 + times(((A|B|C)>>1) , 0, 0, 1);\n    if( C & 1 )\n        if( target == 1 )\n            return times(A>>1, B>>1, C>>1, 1);\n        else\n            return times(A>>1, B>>1, C>>1, -1) + 1 + times(((A|B|C)>>1), 0, 0, 1) + 1 + times(0, 0, ((A|B|C)>>1), -1);\n    return 0;\n}\n\n\n\nint main(void)\n{\n    while(true)\n    {\n        int cups[3] = {0,0,0};\n\n        scanf(\"%d%d\",&n,&m);\n        if(!n && !m) break;\n\n        for(int i=0; i < 3; i++)\n        {\n            int c;\n            scanf(\"%d\", &c);\n            for(int j=0; j < c; j++)\n            {\n                int t;\n                scanf(\"%d\", &t);\n                cups[i] |= 1<<(t-1);\n            }\n        }\n\n        int res = std::min(times(cups[0], cups[1], cups[2], -1), times(cups[0], cups[1], cups[2],  1));\n        printf(\"%d\\n\", res <= m ? res : -1);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n    int n,m;\n    while(1){\n        cin >> n >> m;\n        if(n == 0 && m == 0)break;\n        //vector<char> cup(n,0);\n        vector<char> cup;\n        cup.resize(n);\n\n        bool flag = true;\n        rep(i,3){\n            int n1;\n            cin >> n1;\n            rep(j,n1){\n                int n2;\n                cin >> n2;\n                n2--;\n                cup[n2] = i;\n            }\n        }//入力ここまで\n        queue<vector<char>> que;\n        que.push(cup);\n        map<vector<char>,int> mp;\n        mp[cup] = 0;\n        while(que.size()!=0){\n            cup = que.front();\n            que.pop();\n            //rep(i,cup.size())cout << cup[i];\n            //cout << endl;\n            int bigger[3];\n            int maxcount = 0;\n            bool tray[3] ={true,true,true};\n            if(cup.size() == count(cup.begin(),cup.end(),0) ||cup.size() == count(cup.begin(),cup.end(),2)){\n                cout << mp[cup] << endl;\n                flag = false;\n                break;\n            }\n            rep(i,n){\n                int i2 = n-i-1;\n                rep(j,3){\n                    if(tray[j] == true && cup[i2] == j){\n                        tray[j] = false;\n                        bigger[maxcount] = i2;\n                        maxcount++;\n                        break;\n                    }\n                }\n                if(maxcount == 3)break;\n            }\n            int movecount = mp[cup] + 1;\n            if(movecount > m) break;\n            if(cup[bigger[0]]-1 >= 0){\n                cup[bigger[0]]--;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]++;\n            }\n            if(cup[bigger[0]]+1 <= 2){\n                cup[bigger[0]]++;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]--;\n            }\n            if(maxcount >= 2){\n                if(cup[bigger[1]]-1 >= 0 && cup[bigger[1]]-1 != cup[bigger[0]]){\n                    cup[bigger[1]]--;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]++;\n                }\n                else if(cup[bigger[1]]+1 <= 2 && cup[bigger[1]]+1 != cup[bigger[0]]){\n                    cup[bigger[1]]++;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]--;\n                }\n            }\n        }\n        if(flag) cout << \"-1\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\n#define INF 300000000\n\nusing namespace std;\n\nint n, m;\nint *used;\nint tpow[16] = {1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147, 531441, 1594323, 4782969, 14348907};\n\nint main(int argc, char const* argv[])\n{\n\tcin >> n >> m;\n\twhile(n != 0 || m != 0){\n\t\t\tint N = tpow[n];\n\t\t\tused = new int[N];\n\t\t\tfill(used, used + N, INF);\n\t\t\tint ini = 0;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tint a;\n\t\t\t\t\tcin >> a;\n\t\t\t\t\tfor(int j = 0; j < a; j++){\n\t\t\t\t\t\t\tint b;\n\t\t\t\t\t\t\tcin >> b;\n\t\t\t\t\t\t\tini += i * tpow[b-1];\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<int> q;\n\t\t\tq.push(ini);\n\t\t\tused[ini] = 0;\n\t\t\twhile(!q.empty()){\n\t\t\t\t\tint p = q.front(); q.pop();\n\t\t\t\t\tif(p == 0 || p == N - 1){\n\t\t\t\t\t\t\tcout << used[p] << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(used[p] > m){\n\t\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint a[3];\n\t\t\t\t\ta[0] = -1;\n\t\t\t\t\ta[1] = -1;\n\t\t\t\t\ta[2] = -1;\n\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\t\ta[(p % tpow[i+1] - p % tpow[i]) / tpow[i]] = i;\n\t\t\t\t\t}\n\t\t\t\t\tif(a[0] != -1){\n\t\t\t\t\t\t\tif(a[1] == -1 || a[0] > a[1]){\n\t\t\t\t\t\t\t\t\tint pp = p;\n\t\t\t\t\t\t\t\t\tpp += tpow[a[0]];\n\t\t\t\t\t\t\t\t\tif(used[pp] == INF){\n\t\t\t\t\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\t\t\t\t\tused[pp] = used[p] + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a[2] != -1){\n\t\t\t\t\t\t\tif(a[1] == -1 || a[2] > a[1]){\n\t\t\t\t\t\t\t\t\tint pp = p;\n\t\t\t\t\t\t\t\t\tpp -= tpow[a[2]];\n\t\t\t\t\t\t\t\t\tif(used[pp] == INF){\n\t\t\t\t\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\t\t\t\t\tused[pp] = used[p] + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a[1] != -1){\n\t\t\t\t\t\t\tif(a[0] == -1 || a[1] > a[0]){\n\t\t\t\t\t\t\t\t\tint pp = p;\n\t\t\t\t\t\t\t\t\tpp -= tpow[a[1]];\n\t\t\t\t\t\t\t\t\tif(used[pp] == INF){\n\t\t\t\t\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\t\t\t\t\tused[pp] = used[p] + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(a[2] == -1 || a[1] > a[2]){\n\t\t\t\t\t\t\t\t\tint pp = p;\n\t\t\t\t\t\t\t\t\tpp += tpow[a[1]];\n\t\t\t\t\t\t\t\t\tif(used[pp] == INF){\n\t\t\t\t\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\t\t\t\t\tused[pp] = used[p] + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tdelete used;\n\t\t\tcin >> n >> m;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nint main_calc(int n, int m, stack<int> **tray);\n\nint main(int argc, char const* argv[])\n{\n  int n, m;\n  int size;\n  int val;\n  stack<int> *tray[3];\n\n  while (true) {\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n\n    for (int i = 0; i < 3; i++) {\n      cin >> size;\n      tray[i] = new stack<int>;\n\n      for (int j = 0; j < size; j++) {\n        cin >> val;\n        tray[i]->push(val);\n      }\n    }\n\n    cout << main_calc(n, m, tray) << endl;\n  }\n\n  cin >> n >> m;\n  return 0;\n}\n\nenum Move {\n  AB, BA, BC, CB, NO\n};\n\nvoid move(stack<int> **tray, Move move) {\n  int tray_0 = tray[0]->size() == 0 ? 0 : tray[0]->top();\n  int tray_1 = tray[1]->size() == 0 ? 0 : tray[1]->top();\n  int tray_2 = tray[2]->size() == 0 ? 0 : tray[2]->top();\n\n  switch (move) {\n    case AB:\n             tray[1]->push(tray_0);\n             if (tray[0]->size() > 0) tray[0]->pop();\n             break;\n    case BA:\n             tray[0]->push(tray_1);\n             if (tray[1]->size() > 0) tray[1]->pop();\n             break;\n    case BC:\n             tray[2]->push(tray_1);\n             if (tray[1]->size() > 0) tray[1]->pop();\n             break;\n    case CB:\n             tray[1]->push(tray_2);\n             if (tray[2]->size() > 0) tray[2]->pop();\n             break;\n    case NO:\n             break;\n  }\n}\n\nvector<Move>* get_movables(stack<int> **tray, Move lastmove) {\n  auto moves = new vector<Move>;\n  int tray_0 = tray[0]->size() == 0 ? 0 : tray[0]->top();\n  int tray_1 = tray[1]->size() == 0 ? 0 : tray[1]->top();\n  int tray_2 = tray[2]->size() == 0 ? 0 : tray[2]->top();\n \n  // AB\n  if (tray_0 > tray_1 && lastmove != BA) {\n    moves->push_back(AB);\n  }\n\n  // BA\n  if (tray_1 > tray_0 && lastmove != AB) {\n    moves->push_back(BA);\n  }\n\n  // BC\n  if (tray_1 > tray_2 && lastmove != CB) {\n    moves->push_back(BC);\n  }\n\n  // CB\n  if (tray_2 > tray_1 && lastmove != BC) {\n    moves->push_back(CB);\n  }\n\n  return moves;\n}\n\nstack<int>** copy(stack<int> **tray) {\n  auto **new_tray = new stack<int>*[3];\n  new_tray[0] = new stack<int>(*tray[0]);\n  new_tray[1] = new stack<int>(*tray[1]);\n  new_tray[2] = new stack<int>(*tray[2]);\n  return new_tray;\n}\n\nvoid debugout(stack<int> **tray) {\n    int tray_0 = tray[0]->size() == 0 ? 0 : tray[0]->top();\n    int tray_1 = tray[1]->size() == 0 ? 0 : tray[1]->top();\n    int tray_2 = tray[2]->size() == 0 ? 0 : tray[2]->top();\n\n    cout << tray_0 << \" \" << tray_1 << \" \" << tray_2 << endl;\n}\n\nint single_calc(int m, stack<int> **tray, Move first_move = NO) {\n  int count = 0;\n  auto *moves = get_movables(tray, first_move);\n\n  while (true) {\n    // cout << count << \": \" << moves->size() << endl;\n    // debugout(tray);\n    if (tray[1]->empty() && (tray[0]->empty() || tray[2]->empty())) {\n      // cout << \"end\" << endl;\n      break;}\n\n    Move recent = (*moves)[0];\n    delete moves;\n\n    if (count == m || moves->size() == 0) {\n      return -1;\n    }\n\n    move(tray, recent);\n    moves = get_movables(tray, recent);\n    count++;\n  }\n\n  return count;\n}\n\nint main_calc(int n, int m, stack<int> **tray) {\n  if (tray[1]->empty() && (tray[0]->empty() || tray[1]->empty())) return 0;\n\n  int count = 0, min = m + 1;\n  auto *moves = get_movables(tray, NO);\n\n  if (moves->size() == 0) return -1;\n\n  for (auto& move_type : *moves) {\n    auto copy_tray = copy(tray);\n    move(copy_tray, move_type);\n    count = single_calc(m - 1, copy_tray, move_type);\n\n    if (count != -1 && count + 1 < min) min = count + 1;\n  }\n\n  if (min == m + 1) {\n    return -1;\n  }\n\n  return min;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N, M;\n\nclass hash_array {\npublic:\n  size_t operator()(const array<int, 3> &x) const {\n    const int C = 997;\n    size_t t = 0;\n    for (int i = 0; i != x.size(); ++i) {\n      t = t * C + x[i];\n    }\n    return t;\n  }\n};\n\nint solve(array<int, 3> const& start) {\n  queue<array<int, 3>> q;\n  int num = 0;\n  rep(i, N) num |= 1 << i;\n  q.push(start);\n\n  unordered_map<array<int, 3>, int, hash_array> mp;\n  mp[start] = 0;\n\n  const array<int, 3> target1{{num, 0, 0}};\n  const array<int, 3> target2{{0, 0, num}};\n\n  while(!q.empty()) {\n    auto v = q.front(); q.pop();\n    if(v == target1 || v == target2) {\n      return mp[v];\n    }\n\n    rep(i, v.size()) {\n      for(int k=N-1; k>=0; k--) {\n        if(v[i] >> k & 1) {\n          auto& rmp = mp[v];\n          if(i + 1 < 3) {\n            v[i] ^= 1 << k;\n            if(v[i + 1] < (1<<k)) {\n              v[i + 1] ^= 1 << k;\n              if(mp.find(v) == mp.end() && rmp + 1 <= M) {\n                mp[v] = rmp + 1;\n                q.push(v);\n              }\n              v[i + 1] ^= 1 << k;\n            }\n            v[i] ^= 1 << k;\n          }\n\n          if(i - 1 >= 0) {\n            v[i] ^= 1 << k;\n            if(v[i - 1] < (1<<k)) {\n              v[i - 1] ^= 1 << k;\n              if(mp.find(v) == mp.end() && rmp + 1 <= M) {\n                mp[v] = rmp + 1;\n                q.push(v);\n              }\n              v[i - 1] ^= 1 << k;\n            }\n            v[i] ^= 1 << k;\n          }\n\n          break;\n        }\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main() {\n  while(cin >> N >> M && (N|M)) {\n    array<int, 3> cups;\n    rep(i, 3) {\n      int n; cin >> n;\n      int num = 0;\n      rep(j, n) {\n        int k; cin >> k; k--;\n        num |= 1 << k;\n      }\n      cups[i] = num;\n    }\n    cout << solve(cups) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\nset< vector< stack<int> > > s;\n\nint main(){\n    while(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n == 0 && m == 0 ) break;\n        s = set< vector< stack<int> > >();\n\tvector< stack<int> > cup(3);\n\tREP(i,3){\n\t    int t;\n\t    cin >> t;\n\t    REP(j,t){\n\t\tint temp;\n\t\tcin >> temp;\n\t\tcup[i].push(temp);\n\t    }\n\t}\n\tqueue< vector< stack<int> > > q;\n\tqueue<int> qv;\n\tq.push(cup);\n\tqv.push(0);\n\tint ans = 2000000000;\n\twhile(!q.empty()){\n\t    cup = q.front();\n\t    int v = qv.front();\n\t    q.pop();\n\t    qv.pop();\n\t    if(s.find(cup) != s.end()) continue;\n\t    else s.insert(cup);\n\t    if(cup[1].size() == 0 && (cup[0].size() == 0||cup[2].size() == 0)){\n\t\tans = min(v,ans);\n \t\tbreak;\n\t    }\n\t    REP(i,2){\n\t\tif(cup[i].size() > 0 && (cup[i+1].size() == 0 || cup[i].top() > cup[i+1].top())){\n\t\t    cup[i+1].push(cup[i].top());\n\t\t    cup[i].pop();\n\t\t    q.push(cup);\n\t\t    qv.push(v+1);\n\t\t    cup[i].push(cup[i+1].top());\n\t\t    cup[i+1].pop();\n\t\t}\n\t\tif(cup[i+1].size() > 0 && (cup[i].size() == 0 || cup[i].top() < cup[i+1].top())){\n\t\t    cup[i].push(cup[i+1].top());\n\t\t    cup[i+1].pop();\n\t\t    q.push(cup);\n\t\t    qv.push(v+1);\n\t\t    cup[i+1].push(cup[i].top());\n\t\t    cup[i].pop();\n\t\t}\n\t    }\n\t}\n\tif(ans > m) ans = -1;\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<stack>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n    int dep,lastmove[2],s[3][15],top[15];\n    Data(){\n        for(int i=0;i<3;i++){\n            top[i] = -1;\n        }\n    }\n};\nbool memo[14348908] = {};\n\nint int_pow(int n,int m){\n    int ans = 1;\n    while(m--){\n        ans *= n;\n    }\n    return ans;\n}\n\nint main(){\n    int hoge,n;\n    while(cin>>hoge>>n,n || hoge){\n        for(int i=0;i<14348908;i++) memo[i] = false;\n        Data q_c,q_d,first;\n        int m,input,nt,cup,cntempty,state,nowdep;\n\t\tbool flag;\n        int situ[2] = {-1,1};\n        queue<Data> q;\n        for(int i=0;i<3;i++){\n            cin>>m;\n            for(int j=0;j<m;j++){\n                cin>>input;\n                first.s[i][first.top[i]+1] = input;\n                first.top[i]++;\n            }\n        }\n        first.dep = 0;first.lastmove[0] = -1;first.lastmove[1] = -1;\n        q.push(first);\n        flag = false;\n        while(!q.empty()){\n            q_c = q.front();\n            q.pop();\n            //printf(\"%d\\n\",q_c.dep);\n            if(q_c.dep%1000 == 0){\n                //printf(\"%d\\n\",q_c.dep);\n            }\n            //for(int i=0;i<3;i++) printf(\"%d \",!q_c.s[i].empty());\n            //puts(\"\");\n            if(q_c.dep == n) break;\n            cntempty = 0;\n            for(int i=0;i<3;i++){\n                if(q_c.top[i] != -1){\n                    if(i == 1){\n                        cntempty = 0;\n                        break;\n                    }\n                    cntempty++;\n                }\n            }\n            if(cntempty == 1){\n                printf(\"%d\\n\",q_c.dep);\n                flag = true;\n                break;\n            }\n            state = 0;\n            for(int i=0;i<3;i++){\n                for(int j=0;j<=q_c.top[i];j++){\n                    cup = q_c.s[i][j];\n                    state += i*int_pow(3,cup-1);\n                }\n            }\n            if(memo[state]) continue;\n            memo[state] = true;\n            //printf(\"%d\\n\",state);\n            for(int i=0;i<3;i++){\n                for(int j=0;j<2;j++){\n                    nt = i+situ[j];\n                    if(nt<0 || 3<=nt) continue;\n                    q_d = q_c;\n                    if((q_c.lastmove[1]==i && q_c.lastmove[0]==nt)\n                       || q_d.top[i]==-1) continue;\n                    cup = q_d.s[i][q_d.top[i]];\n                    q_d.top[i]--;\n                    if(q_d.top[nt]!=-1 && cup < q_d.s[nt][q_d.top[nt]]) continue;\n                    q_d.s[nt][q_d.top[nt]+1] = cup;\n                    q_d.top[nt]++;\n                    q_d.dep++;\n                    q_d.lastmove[0] = i;q_d.lastmove[1] = nt;\n                    q.push(q_d);\n                }\n            }\n        }\n        if(!flag) printf(\"-1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n\nint main(){\n    ios::sync_with_stdio(false);\n\n    START:\n\n    int n,m;\n    cin >> n >> m;\n    if(n == 0 && m == 0) return 0;\n    string S = \"\";\n    for(int i=0; i<n; i++) S += \" \";\n    int tmp;\n    cin >> tmp;\n    for(int i=0; i<tmp; i++){\n        int tmp2;\n        cin >> tmp2;\n        tmp2--;\n        S[tmp2] = 'A';\n    }\n    cin >> tmp;\n    for(int i=0; i<tmp; i++){\n        int tmp2;\n        cin >> tmp2;\n        tmp2--;\n        S[tmp2] = 'B';\n    }\n    cin >> tmp;\n    for(int i=0; i<tmp; i++){\n        int tmp2;\n        cin >> tmp2;\n        tmp2--;\n        S[tmp2] = 'C';\n    }\n\n    int ans = INT_MAX;\n    set<string> already;\n    already.insert(S);\n    priority_queue<pair<int,string> > que;\n    que.push(MP(INT_MAX, S));\n    while(!que.empty()){\n        int c = INT_MAX - que.top().first;\n        //cout << c << \" \" << que.top().second << endl;\n        if(c > m){\n            cout << -1 << endl;\n            break;\n        }\n\n        S = que.top().second;\n        vector<int> A,B,C;\n        for(int i=0; i<S.size(); i++){\n            if(S[i] == 'A') A.push_back(i);\n            else if(S[i] == 'B') B.push_back(i);\n            else C.push_back(i);\n        }\n        if(B.size() == 0 && (A.size() == 0 || C.size() == 0)){\n            cout << c << endl;\n            break;\n        }\n\n        // cout << A.size() << \" \";\n        // for(int i=0; i<A.size(); i++) cout << A[i] << \" \";\n        // cout << endl;\n        // cout << B.size() << \" \";\n        // for(int i=0; i<B.size(); i++) cout << B[i] << \" \";\n        // cout << endl;\n        // cout << C.size() << \" \";\n        // for(int i=0; i<C.size(); i++) cout << C[i] << \" \";\n        // cout << endl;\n\n        if((A.size() > 0 && B.size() > 0 && A.back() > B.back()) || (A.size() > 0 && B.size() == 0)){\n            S[A.back()] = 'B';\n            if(already.count(S) == 0){\n                already.insert(S);\n                que.push(MP(INT_MAX-c-1, S));\n            }\n            S[A.back()] = 'A';\n        }\n        if((A.size() > 0 && B.size() > 0 && A.back() < B.back()) || (A.size() == 0 && B.size() > 0)){\n            S[B.back()] = 'A';\n            if(already.count(S) == 0){\n                already.insert(S);\n                que.push(MP(INT_MAX-c-1, S));\n            }\n            S[B.back()] = 'B';\n        }\n        if((C.size() > 0 && B.size() > 0 && C.back() > B.back()) || (C.size() > 0 && B.size() == 0)){\n            S[C.back()] = 'B';\n            if(already.count(S) == 0){\n                already.insert(S);\n                que.push(MP(INT_MAX-c-1, S));\n            }\n            S[C.back()] = 'C';\n        }\n        if((C.size() > 0 && B.size() > 0 && C.back() < B.back()) || (C.size() == 0 && B.size() > 0)){\n            S[B.back()] = 'C';\n            if(already.count(S) == 0){\n                already.insert(S);\n                que.push(MP(INT_MAX-c-1, S));\n            }\n            S[B.back()] = 'B';\n        }\n\n        que.pop();\n        if(que.empty()){\n            cout << -1 << endl;\n            break;\n        }\n    }\n\n\n    goto START;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Z 15000000\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;int n,m,a,b,c[15],t,he,ta,an,v[Z],w[Z];bool vis[Z];void BFS(int x,int l){if(vis[x])return;if(l==m)return;if(x==0||x==t){an=l;return;}vis[x]=1;int d[3]={-1},e=x,f=0,g=1;while(1){d[e%3]=max(d[e%3],g);e/=3,f++,g*=3;if(f==n)break;}if(d[0]>d[1]){e=x+d[0];if(!vis[e])v[ta]=e,w[ta]=l+1,ta++;}if(d[0]<d[1]){e=x-d[1];if(!vis[e])v[ta]=e,w[ta]=l+1,ta++;}if(d[1]>d[2]){e=x+d[1];if(!vis[e])v[ta]=e,w[ta]=l+1,ta++;}if(d[1]<d[2]){e=x-d[2];if(!vis[e])v[ta]=e,w[ta]=l+1,ta++;}return;}int main(){while(1){cin>>n>>m;if(!n&&!m)break;rep(i,3){cin>>a;rep(j,a)cin>>b,c[b-1]=i;}int o=0,p=1;rep(i,n)o+=p*c[i],p*=3;t=p-1,he=0,ta=1,an=-1,v[0]=o,w[0]=0;rep(i,Z)vis[i]=false;while(true){if(ta==he)break;BFS(v[he],w[he]);if(an!=-1)break;he++;}cout<<an<<endl;}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint an, bn, cn, a[20], b[20], c[20], total = 0, f = 1;\n\nstruct mm{\n\tchar ch;\n\tint nu;\n};\n\nstruct mm m1, m2;\n\nint judge(int max, int temp){\n\tif(temp + 1 == an + bn + cn)return -1;\n\tif(a[an] == max - temp)return 50 + temp;\n\tif(c[cn] == max - temp)return 100 + temp;\n\tif(b[cn - temp] == max - temp)return judge(max, temp + 1);\n\treturn 0;\n}\n\nint calculation(int min, int max){\n\tint sum;\n\tif(min == max)return 0;\n\tif(min < max)sum = calculation(++min, max) * 3 + 2;\n\treturn sum;\n}\n\nint move(int flag){\n\tint number;\n\tif(flag == 2){  //right\n\t\tnumber = an - m1.nu + 1;\n\t\tfor(int i = 1;i <= number;i++)c[++cn] = a[an--];\n\t}\n\tif(flag == 1){\n\t\tnumber = cn - m1.nu + 1;\n\t\tfor(int i = 1;i <= number;i++)a[++an] = c[cn--];\n\t}\n\ttotal += calculation(0, number);\n\t//printf(\"*%d*\", number);\n\treturn 0;\n}\n\nint sort(int max){\n\tif(m1.ch == m2.ch)return 0;\n\tif(m2.ch == 'b'){\n\t\tif(m1.ch == 'a')c[++cn] = b[bn--], move(2);  //right\n\t\tif(m1.ch == 'c')a[++an] = b[bn--], move(1);\n\t\ttotal++;\n\t}else if(m2.ch == 'a'){\n\t\tif(c[cn - 2] == max - 2){\n\t\t\tb[++bn] = a[an--], move(1);\n\t\t\tc[++cn] = b[bn--], move(2);\n\t\t}else{\n\t\t\tmove(1);\n\t\t}\n\t}else if(m2.ch == 'c'){\n\t\tif(a[an - 2] == max - 2){\n\t\t\tb[++bn] = c[cn--], move(2);\n\t\t\ta[++an] = b[bn--], move(1);\n\t\t}else{\n\t\t\tmove(2);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint solve(int max){\n\tfor(int i = 1;i <= an;i++){\n\t\tif(a[i] == max)m1.ch = 'a',m1.nu = i;\n\t\tif(a[i] == max - 1)m2.ch = 'a', m2.nu = i;\n\t}\n\tfor(int i = 1;i <= bn;i++){\n\t\tif(b[i] == max)m1.ch = 'b',m1.nu = i;\n\t\tif(b[i] == max - 1)m2.ch = 'b', m2.nu = i;\n\t}\n\tfor(int i = 1;i <= cn;i++){\n\t\tif(c[i] == max)m1.ch = 'c',m1.nu = i;\n\t\tif(c[i] == max - 1)m2.ch = 'c', m2.nu = i;\n\t}\n\tif(f == 1 && m1.ch == 'b'){\n\t\tint vec;  //1 = left \n\t\tif(m2.ch == 'b'){\n\t\t\tint temp = judge(max, 2);\n\t\t\tif(temp == -1)return 0;\n\t\t\tif(temp >= 100){\n\t\t\t\tif(temp % 2)vec = 2;\n\t\t\t\telse vec = 1;\n\t\t\t}else if(temp >= 50){\n\t\t\t\tif(temp % 2)vec = 1;\n\t\t\t\telse vec = 2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(m2.ch == 'a' || vec == 1){\n\t\t\ta[++an] = b[bn--];\n\t\t}else if(m2.ch == 'c' || vec == 2){\n\t\t\tc[++cn] = b[bn--];\n\t\t}\n\t\ttotal++;\n\t}else{\n\t\tsort(max);\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n, m, max = 0;\n\twhile(scanf(\"%d %d\",&n, &m)){\n\t\tif(n == 0 && m == 0)break;\n\t\tmax = total = 0, f = 1;\n\t\t\n\t\t\n\t\tscanf(\"%d\", &an);\n\t\tfor(int i = 1;i <= an;i++){\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t\tif(a[i] > max)max = a[i];\n\t\t}\n\t\tscanf(\"%d\", &bn);\n\t\tfor(int i = 1;i <= bn;i++){\n\t\t\tscanf(\"%d\", &b[i]);\n\t\t\tif(b[i] > max)max = b[i];\n\t\t}\n\t\tscanf(\"%d\", &cn);\n\t\tfor(int i = 1;i <= cn;i++){\n\t\t\tscanf(\"%d\", &c[i]);\n\t\t\tif(c[i] > max)max = c[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < n - 1;i++)solve(max - i);\n\t\t\n\t\tif(total <= m)printf(\"%d\\n\", total);\n\t\telse printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint d[3][16];\nint x;\nint i,j,k;\nint m,n;\nint ans=0;\nint goal;\nint now[3];\nint p,q;\n\nint other(int a,int b){\n\tif(a==0&&b==1)return 2;\n\tif(b==0&&a==1)return 2;\n\tif(a==0&&b==2)return 1;\n\tif(b==0&&a==2)return 1;\n\tif(a==1&&b==2)return 0;\n\tif(b==1&&a==2)return 0;\n}\n\nvoid move(int n,int a,int b,int to){\nstart:\n\tif(ans>m)return;\n\tif(n!=d[a][b])return;\n\tif(to-a==2||a-to==2){\n\t\tmove(d[a][b],a,b,1);\n\t\tmove(d[1][now[1]-1],1,now[1]-1,to);\n\t\tgoto start;\n\t}\n\tif(d[a][b+1]>0){\n\t\tmove(d[a][b+1],a,b+1,other(a,to));\n\t\tgoto start;\n\t}\n\tif(now[to]>=1&&d[to][now[to]-1]>d[a][b]){\n\t\tmove(d[to][now[to]-1],to,now[to]-1,other(a,to));\n\t\tgoto start;\n\t}\n\td[to][now[to]++]=d[a][b];\n\td[a][b]=-1;\n\tnow[a]--;\n\tans++;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)break;\n\t\tans=0;\n\t\tfor(i=0;i<3;i++)for(j=0;j<16;j++)d[i][j]=-1;\n\t\tfor(i=0;i<3;i++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tfor(j=0;j<x;j++){\n\t\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\t}\n\t\t\tnow[i]=x;\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(i==0){\n\t\t\t\tif(d[1][0]==1){\n\t\t\t\t\tif(d[2][0]>d[0][0]){\n\t\t\t\t\t\tif(now[0]==0)goal=0;\n\t\t\t\t\t\telse goal=2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(now[2]==0)goal=2;\n\t\t\t\t\t\telse goal=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(d[0][0]==1)goal=0;\n\t\t\t\telse goal=2;\n\t\t\t}\n\t\t\tp=-1;q=-1;\n\t\t\tfor(j=0;j<3;j++)for(k=0;k<16;k++)if(d[j][k]==i+1){p=j;q=k;}\n\t\t\tif(p!=-1&&q!=-1)if(p!=goal)move(i+1,p,q,goal);\n\t\t\tif(ans>m)break;\n\t\t}\n\t\tif(ans<=m)printf(\"%d\\n\",ans);\n\t\telse printf(\"-1\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <functional>\n#define INPUT_FROM_FILE (0)\n\n#if INPUT_FROM_FILE\n#include <fstream>\n#endif\n\nconst char Max_n = 15;\n\nint f_A(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C);\nint f_B(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C);\nint f_C(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C);\n\nint f_A(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C){\n\tif(stack_B.empty() && stack_C.empty()){\n\t\treturn 0;\n\t}\n\tchar min_stack_A = !stack_A.empty() ? stack_A.front() : Max_n + 1;\n\tchar min_stack_B = !stack_B.empty() ? stack_B.front() : Max_n + 1;\n\tchar min_stack_C = !stack_C.empty() ? stack_C.front() : Max_n + 1;\n\n\tif(min_stack_A < min_stack_B && min_stack_A < min_stack_C){\n\t\tstack_A.pop_front();\n\t\treturn f_A(stack_A, stack_B, stack_C);\n\t}\n\tif(min_stack_B < min_stack_A && min_stack_B < min_stack_C){\n\t\tint n = 0;\n\n\t\tstack_B.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_C(stack_A, stack_B, stack_C) + int(pow(3, n));\n\t}\n\tif(min_stack_C < min_stack_A && min_stack_C < min_stack_B){\n\t\tint n = 0;\n\t\t\n\t\tstack_C.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_A(stack_A, stack_B, stack_C) + 2 * int(pow(3, n));\n\t}\n\n\t//std::cout << \"error f_A\" << std::endl;\n\t//exit(0);\n\treturn 0;\n}\n\nint f_B(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C){\n\tif(stack_A.empty() && stack_C.empty()){\n\t\treturn 0;\n\t}\n\tchar min_stack_A = !stack_A.empty() ? stack_A.front() : Max_n + 1;\n\tchar min_stack_B = !stack_B.empty() ? stack_B.front() : Max_n + 1;\n\tchar min_stack_C = !stack_C.empty() ? stack_C.front() : Max_n + 1;\n\n\tif(min_stack_A < min_stack_B && min_stack_A < min_stack_C){\n\t\tint n = 0;\n\t\t\n\t\tstack_A.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_C(stack_A, stack_B, stack_C) + (int(pow(3, n)) + 1) / 2;\n\t}\n\tif(min_stack_B < min_stack_A && min_stack_B < min_stack_C){\n\t\tstack_B.pop_front();\n\t\treturn f_B(stack_A, stack_B, stack_C);\n\t}\n\tif(min_stack_C < min_stack_A && min_stack_C < min_stack_B){\n\t\tint n = 0;\n\t\t\n\t\tstack_C.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_A(stack_A, stack_B, stack_C) + (int(pow(3, n)) + 1) / 2;\n\t}\n\n\t//std::cout << \"error f_B\" << std::endl;\n\t//exit(0);\n\treturn 0;\n}\n\nint f_C(std::deque<char> stack_A, std::deque<char> stack_B, std::deque<char> stack_C){\n\tif(stack_A.empty() && stack_B.empty()){\n\t\treturn 0;\n\t}\n\tchar min_stack_A = !stack_A.empty() ? stack_A.front() : Max_n + 1;\n\tchar min_stack_B = !stack_B.empty() ? stack_B.front() : Max_n + 1;\n\tchar min_stack_C = !stack_C.empty() ? stack_C.front() : Max_n + 1;\n\n\tif(min_stack_A < min_stack_B && min_stack_A < min_stack_C){\n\t\tint n = 0;\n\n\t\tstack_A.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_C(stack_A, stack_B, stack_C) + 2 * int(pow(3, n));\n\t}\n\tif(min_stack_B < min_stack_A && min_stack_B < min_stack_C){\n\t\tint n = 0;\n\n\t\tstack_B.pop_front();\n\t\tn = stack_A.size() + stack_B.size() + stack_C.size();\n\t\treturn f_A(stack_A, stack_B, stack_C) + int(pow(3, n));\n\t}\n\tif(min_stack_C < min_stack_A && min_stack_C < min_stack_B){\n\t\tstack_C.pop_front();\n\t\treturn f_C(stack_A, stack_B, stack_C);\n\t}\n\n\t//std::cout << \"error f_C\" << std::endl;\n\t//exit(0);\n\treturn 0;\n}\n\nint main(int argc, char **argv){\n#if INPUT_FROM_FILE\n\tstd::ifstream ifs(\"test.txt\");\n#endif\n\tint n = 0;\n\tint m = 0;\n\n#if INPUT_FROM_FILE\n\twhile(ifs >> n >> m, (n != 0 || m != 0)){\n#else\n\twhile(std::cin >> n >> m, (n != 0 || m != 0)){\n#endif\n\t\tstd::deque<char> tray[3];\n\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tint num_cups = 0;\n\n#if INPUT_FROM_FILE\n\t\t\tifs >> num_cups;\n#else\n\t\t\tstd::cin >> num_cups;\n#endif\n\t\t\tfor(int j = 0; j < num_cups; j++){\n\t\t\t\tchar c = 0;\n\n#if INPUT_FROM_FILE\n\t\t\t\tifs >> c;\n#else\n\t\t\t\tstd::cin >> c;\n#endif\n\t\t\t\ttray[i].push_back(c - '0');\n\t\t\t}\n\t\t}\n\t\t//??¢?´¢\n\t\t{\n\t\t\tint num_move =std::min(f_A(tray[0], tray[1], tray[2]), f_C(tray[0], tray[1], tray[2]));\n\t\t\t\n\t\t\tif(num_move <= m){\n\t\t\t\tstd::cout << num_move << std::endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstd::cout << -1 << std::endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nclass State {\npublic:\n  stack<int> st[3];\n  int cost, goal;\n  State() : cost(0) {}\n  void init() {\n    cost = 0;\n    for(int i = 0; i < 3; ++i) {\n      while(!st[i].empty()) st[i].pop();\n    }\n  }\n  bool isGoal() {\n    return st[(goal+1)%3].empty() && st[(goal+2)%3].empty();\n  }\n\n  bool operator < (const State &s) const {\n    if(goal != s.goal) return goal < s.goal;\n    for(int i = 0; i < 3; ++i) {\n      if(st[i] != s.st[i]) return st[i] < s.st[i];\n    }\n    return false;\n  }\n};\n\nint n, m;\nState S;\n\nvoid solve() {\n  set<State> vis;\n  queue<State> que;\n  S.goal = 0; vis.insert(S); que.push(S);\n  S.goal = 2; vis.insert(S); que.push(S);\n  while(!que.empty()) {\n    State s = que.front(); que.pop();\n    if(s.isGoal()) {\n      cout << s.cost << endl;\n      return;\n    }\n    if(s.cost > m) continue;\n    for(int f = 0; f < 3; ++f) {\n      for(int d = -1; d <= 1; d += 2) {\n\tif(s.st[f].empty()) continue;\n\tint t = f + d;\n\tif(t < 0 || t >= 3) continue;\n\tif(!s.st[t].empty() && s.st[f].top() < s.st[t].top()) continue;\n\tState ts = s;\n\tint cup = ts.st[f].top(); ts.st[f].pop();\n\tts.st[t].push(cup);\n\t++ts.cost;\n\tif(vis.find(ts) != vis.end()) continue;\n\tvis.insert(ts);\n\tque.push(ts);\n      }\n    }\n  }\n  cout << -1 << endl;\n}\n\nmain() {\n  while((cin >> n >> m) && (n ||m)) {\n    S.init();\n    for(int i = 0; i < 3; ++i) {\n      int num;\n      cin >> num;\n      for(int j = 0; j < num; ++j) {\n\tint a;\n\tcin >> a;\n\tS.st[i].push(a);\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint n, m;\n\nint solve(int A, int B, int C){\n\tif( !A && !B ) return 0;\n\tif( C & 1 ) return solve(A >> 1, B >> 1, C >> 1);\n\tif( B & 1 ) return solve(C >> 1, B >> 1, A >> 1) + solve((A|B|C) >> 1, 0, 0) + 1;\n\tif( A & 1 ) return solve(A >> 1, B >> 1, C >> 1) + 2 * solve((A|B|C) >> 1, 0, 0) + 2;\n}\n\nint main(){\n\twhile( cin >> n >> m , n || m ){\n\t\tint cup[3] = {0};\n\t\tfor(int i=0 ; i < 3 ; i++ ){\n\t\t\tint k, e;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0 ; j < k ; j++ ){\n\t\t\t\tcin >> e;\n\t\t\t\tcup[i] |= 1 << e - 1;\n\t\t\t}\n\t\t}\n\t\tint ans = min(solve(cup[0], cup[1], cup[2]), solve(cup[2], cup[1], cup[0]));\n\t\tif( m < ans ) ans = -1;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\nusing namespace std;\n\nclass state{\npublic:\n  stack<int>* tray;\n  int cnt;\n  state(stack<int> a, stack<int> b, stack<int> c, int cnt){\n    tray = new stack<int>[3];\n    tray[0] = a;\n    tray[1] = b;\n    tray[2] = c;\n    this->cnt = cnt;\n  }\n\n  state(){\n    tray = new stack<int>[3];\n    cnt = 0;\n  }\n\n  void init(){\n    for(int i=0; i<3; i++){\n      int n; cin >> n;\n      int cup;\n      for(int j=0; j<n; j++){\n        cin >> cup;\n        tray[i].push(cup);\n      }\n    }\n  }\n\n  //i番目のトレイからj番目に移動できるかを返す\n  bool canChange(int i, int j){\n    int sizei=tray[i].size(), sizej=tray[j].size();\n    if(sizei==0) return false;\n    if(sizej==0) return true;\n\n    if(tray[i].top()>tray[j].top()) return true;\n    else return false;\n  }\n\n  //i番目のトレイのカップをj番目のトレイに入れ替えたstateを返す\n  state change(int i, int j){\n    state ex = state(tray[0], tray[1], tray[2], cnt+1);\n    int cup=ex.tray[i].top(); ex.tray[i].pop();\n\n    ex.tray[j].push(cup);\n    return ex;\n  }\n};\n\nint solve(int, int, state);\n\nint main(){\n  int n, m; //カップ数 手数\n  while(cin >> n >> m, n!=0 && m!=0){\n    state first;\n    first.init();\n    int dis=solve(n, m, first);\n    cout << dis << endl;\n  }\n\n  return 0;\n}\n\n\n\nint solve(int n, int m, state first){\n  queue<state> q;\n  q.push(first);\n\n  int ans=-1;\n\n  while(!q.empty()){\n    state now = q.front(); q.pop();\n    //もし手数をオーバーしたなら、-1を格納して終了\n    if(now.cnt>m){\n      ans = -1;\n      break;\n    }\n\n    //もし条件を満たしているなら、手数を格納して終了\n    if(now.tray[0].size()==n || now.tray[2].size()==n){\n      ans = now.cnt;\n      break;\n    }\n\n    //隣り合う2つのカップで移動\n    for(int i=0; i<2; i++){\n      if(now.canChange(i, i+1)) {\n        q.push(now.change(i, i+1));\n      }\n      if(now.canChange(i+1, i)){\n        q.push(now.change(i+1, i));\n      }\n    }\n  }\n\n  return ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\n\nint n,m;\nvector<int> a;\nvector<vector<int> > input;\nset<vector<int> > s;\n\nstruct state{\n  int n;\n  vector<int> v;\n  vector<vector<int> > v2;\n  state(){\n    n = 0;\n    v.assign(n,0);\n    v2.assign(3,vector<int>());\n  }\n};\n\nvoid bfs(){\n  bool f;\n  int res;\n  queue<state> Q;\n  state u,v;\n  u.v = a;\n  u.v2 = input;\n  for(Q.push(u);!Q.empty();){\n    u = Q.front();\n    Q.pop();\n    \n    f = false;\n    res = u.v[0];\n    for(int i=0;i<n;i++){\n      if(u.v[i] == 1 || u.v[i] != res){\n\tf = true;\n\tbreak;\n      }\n    }\n    if(!f){\n      cout << u.n << endl;\n      return;\n    }\n    if(u.n == 0) s.insert(u.v);\n    else if(u.n >= m) break;\n\n    \n    if(u.v2[0].size() > 0 && (u.v2[1].size() == 0 || u.v2[0][u.v2[0].size()-1] > u.v2[1][u.v2[1].size()-1])){\n      v = u;\n      v.v2[1].push_back(u.v2[0][u.v2[0].size()-1]);\n      v.v2[0].pop_back();\n      v.v[v.v2[1][v.v2[1].size()-1]] = 1;\n      v.n++;\n      if(s.find(v.v) == s.end()){\n\ts.insert(v.v);\n\tQ.push(v);\n      }\n    }\n    \n    if(u.v2[1].size() > 0 && (u.v2[0].size() == 0 || u.v2[1][u.v2[1].size()-1] > u.v2[0][u.v2[0].size()-1])){\n      v = u;\n      v.v2[0].push_back(u.v2[1][u.v2[1].size()-1]);\n      v.v2[1].pop_back();\n      v.v[v.v2[0][v.v2[0].size()-1]] = 0;\n      v.n++;\n      if(s.find(v.v) == s.end()){\n\ts.insert(v.v);\n\tQ.push(v);\n      }\n    }\n\n    if(u.v2[1].size() > 0 && (u.v2[2].size() == 0 || u.v2[1][u.v2[1].size()-1] > u.v2[2][u.v2[2].size()-1])){\n      v = u;\n      v.v2[2].push_back(u.v2[1][u.v2[1].size()-1]);\n      v.v2[1].pop_back();\n      v.v[v.v2[2][v.v2[2].size()-1]] = 2;\n      v.n++;\n      if(s.find(v.v) == s.end()){\n\ts.insert(v.v);\n\tQ.push(v);\n      }\n    }\n\n    if(u.v2[2].size() > 0 && (u.v2[1].size() == 0 || u.v2[2][u.v2[2].size()-1] > u.v2[1][u.v2[1].size()-1])){\n      v = u;\n      v.v2[1].push_back(u.v2[2][u.v2[2].size()-1]);\n      v.v2[2].pop_back();\n      v.v[v.v2[1][v.v2[1].size()-1]] = 1;\n      v.n++;\n      if(s.find(v.v) == s.end()){\n\ts.insert(v.v);\n\tQ.push(v);\n      }\n    }\n  }\n  cout << -1 << endl;\n}\n\nint main(){\n  while(cin >> n >> m && (n|m)){\n    a.assign(n,0);\n    input.assign(3,vector<int>());\n    for(int i=0;i<3;i++){\n      int x;\n      cin >> x;\n      for(int j=0;j<x;j++){\n\tint c;\n\tcin >> c;\n\tinput[i].push_back(c-1);\n\ta[c-1] = i;\n      }\n    }\n    bfs();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n    int n,m;\n    typedef tuple<vector<char>,vector<char>,int> T;\n    while(1){\n        cin >> n >> m;\n        if(n == 0 && m == 0)break;\n        vector<char> cup;\n        vector<char> beforecup;\n        cup.resize(n);\n        bool flag = true;\n        rep(i,3){\n            int n1;\n            cin >> n1;\n            rep(j,n1){\n                int n2;\n                cin >> n2;\n                n2--;\n                cup[n2] = i;\n            }\n        }//入力ここまで\n        queue<T> que;\n        que.push(T(cup,cup,0));\n        while(que.size()!=0){\n            T state = que.front();\n            cup = get<0>(state);\n            beforecup = get<1>(state);\n            int movecount = get<2>(state);\n            que.pop();\n            int bigger[2];\n            int maxcount = 0;\n            bool tray[3] ={true,true,true};\n            if(n == count(cup.begin(),cup.end(),0) ||n == count(cup.begin(),cup.end(),2)){\n                cout << movecount << endl;\n                flag = false;\n                break;\n            }\n            rep(i,n){\n                int i2 = n-i-1;\n                rep(j,3){\n                    if(tray[j] == true && cup[i2] == j){\n                        tray[j] = false;\n                        bigger[maxcount] = i2;\n                        maxcount++;\n                        break;\n                    }\n                }\n                if(maxcount == 2)break;\n            }\n            movecount++;\n            if(movecount > m) break;\n            if(cup[bigger[0]]-1 >= 0){\n                cup[bigger[0]]--;\n                if(cup != beforecup) que.push(T(cup,get<0>(state),movecount));\n                cup[bigger[0]]++;\n            }\n            if(cup[bigger[0]]+1 <= 2){\n                cup[bigger[0]]++;\n                if(cup != beforecup) que.push(T(cup,get<0>(state),movecount));\n                cup[bigger[0]]--;\n            }\n            if(maxcount >= 2){\n                if(cup[bigger[1]]-1 >= 0 && cup[bigger[1]]-1 != cup[bigger[0]]){\n                    cup[bigger[1]]--;\n                    if(cup != beforecup) que.push(T(cup,get<0>(state),movecount));\n                    cup[bigger[1]]++;\n                }\n                else if(cup[bigger[1]]+1 <= 2 && cup[bigger[1]]+1 != cup[bigger[0]]){\n                    cup[bigger[1]]++;\n                    if(cup != beforecup) que.push(T(cup,get<0>(state),movecount));\n                    cup[bigger[1]]--;\n                }\n            }\n        }\n        if(flag) cout << \"-1\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cmath>\n#include<ctime>\n#include<complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=int(s);i<=int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\n\nint main(){\n\n\twhile(true){\n\n\t\t\tint n,m,r,x;\n\t\t\tcin >> n >> m;\n\t\t\tif(n==0 && m==0) break;\n\n\t\t\tvector<int>a(n+1);\n\t\t\tvector<int>c(n+1);\n\t\t\tvector<int>t(n+1);\n\t\t\tvector<int>p(n+1);\n\n\n            rep(i,3){\n\t\t\tcin >> r;\n\t\t\trep(j,r){ cin >> x; p[x]=i;}\n            }\n\n            t[n]=2;\n            a[n]=p[n]; c[n]=2-p[n];\n\n            for(int k=n;k>1;k--){\n\n            t[k-1]=3*t[k]+2;\n\n            if(p[k-1]==0){\n\n            a[k-1]=a[k];\n            c[k-1]=c[k]+2*t[k]+2;\n\n            }\n\n            if(p[k-1]==1){\n\n            a[k-1]=c[k]+t[k]+1;\n            c[k-1]=a[k]+t[k]+1;\n\n            }\n\n            if(p[k-1]==2){\n\n            a[k-1]=a[k]+2*t[k]+2;\n            c[k-1]=c[k];\n\n            }\n\n            }\n\n            if(min(a[1],c[1])<=m)\n            cout << min(a[1],c[1]) << endl;\n            else cout << -1 << endl;\n\n\n            }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\nset< vector< stack<int> > > s;\n\nint saiki(int n,vector< stack<int> > cup){\n    int ret = 2000000000;\n    if(s.find(cup) != s.end()) return ret;\n    else s.insert(cup);\n    if(cup[1].size() == 0 && (cup[0].size() == 0||cup[2].size() == 0)){\n\treturn n;\n    }\n    REP(i,2){\n\tif(cup[i].size() > 0 && (cup[i+1].size() == 0 || cup[i].top() > cup[i+1].top())){\n\t    cup[i+1].push(cup[i].top());\n\t    cup[i].pop();\n\t    ret = min(ret,(saiki(n+1,cup)));\n\t    cup[i].push(cup[i+1].top());\n\t    cup[i+1].pop();\n\t}\n\tif(cup[i+1].size() > 0 && (cup[i].size() == 0 || cup[i].top() < cup[i+1].top())){\n\t    cup[i].push(cup[i+1].top());\n\t    cup[i+1].pop();\n\t    ret = min(ret,saiki(n+1,cup));\n\t    cup[i+1].push(cup[i].top());\n\t    cup[i].pop();\n\t}\n    }\n    return ret;\n} \nint main(){\n    while(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n == 0 && m == 0 ) break;\n        s = set< vector< stack<int> > >();\n\tvector< stack<int> > cup(3);\n\tREP(i,3){\n\t    int t;\n\t    cin >> t;\n\t    REP(j,t){\n\t\tint temp;\n\t\tcin >> temp;\n\t\tcup[i].push(temp);\n\t    }\n\t}\n\tqueue< vector< stack<int> > > q;\n\tqueue<int> qv;\n\tq.push(cup);\n\tqv.push(0);\n\tint ans = 2000000000;\n\twhile(!q.empty()){\n\t    cup = q.front();\n\t    int v = qv.front();\n\t    q.pop();\n\t    qv.pop();\n\t    if(s.find(cup) != s.end()) continue;\n\t    else s.insert(cup);\n\t    if(cup[1].size() == 0 && (cup[0].size() == 0||cup[2].size() == 0)){\n\t\tans = min(v,ans);\n// \t\tbreak;\n\t    }\n\t    REP(i,2){\n\t\tif(cup[i].size() > 0 && (cup[i+1].size() == 0 || cup[i].top() > cup[i+1].top())){\n\t\t    cup[i+1].push(cup[i].top());\n\t\t    cup[i].pop();\n\t\t    q.push(cup);\n\t\t    qv.push(v+1);\n\t\t    cup[i].push(cup[i+1].top());\n\t\t    cup[i+1].pop();\n\t\t}\n\t\tif(cup[i+1].size() > 0 && (cup[i].size() == 0 || cup[i].top() < cup[i+1].top())){\n\t\t    cup[i].push(cup[i+1].top());\n\t\t    cup[i+1].pop();\n\t\t    q.push(cup);\n\t\t    qv.push(v+1);\n\t\t    cup[i+1].push(cup[i].top());\n\t\t    cup[i].pop();\n\t\t}\n\t    }\n\t}\n\tif(ans > m) ans = -1;\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint bfs[15000000], power[20], n, K, b, c, a[15];\nqueue<vector<int> >Q;\nint hush(vector<int>v) {\n\tint p = 0;\n\tfor (int i = 0; i < v.size(); i++) p += power[i] * v[i];\n\treturn p;\n}\nint main() {\n\tpower[0] = 1;\n\tfor (int i = 1; i < 20; i++)power[i] = power[i - 1] * 3;\n\twhile (true) {\n\t\tfor (int i = 0; i < 15000000; i++)bfs[i] = 1000000000;\n\t\tcin >> n >> K; vector<int>s;\n\t\tif (n == 0 && K == 0)break;\n\t\tcin >> b; for (int i = 0; i < b; i++) { cin >> c; a[c - 1] = 0; }\n\t\tcin >> b; for (int i = 0; i < b; i++) { cin >> c; a[c - 1] = 1; }\n\t\tcin >> b; for (int i = 0; i < b; i++) { cin >> c; a[c - 1] = 2; }\n\t\tfor (int i = 0; i < n; i++)s.push_back(a[i]);\n\t\tbfs[hush(s)] = 0; Q.push(s);\n\t\twhile (!Q.empty()) {\n\t\t\tvector<int>a1, a2, a3, t = Q.front(); Q.pop();\n\t\t\tint V = hush(t);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (t[i] == 0)a1.push_back(i);\n\t\t\t\tif (t[i] == 1)a2.push_back(i);\n\t\t\t\tif (t[i] == 2)a3.push_back(i);\n\t\t\t}\n\t\t\tint A1 = -1, A2 = -1, A3 = -1;\n\t\t\tif (a1.size() >= 1)A1 = a1[a1.size() - 1];\n\t\t\tif (a2.size() >= 1)A2 = a2[a2.size() - 1];\n\t\t\tif (a3.size() >= 1)A3 = a3[a3.size() - 1];\n\t\t\tif (A1 >= 0 && A2 <= A1) {\n\t\t\t\tt[A1] = 1; int P1 = hush(t);\n\t\t\t\tif (bfs[P1] == 1000000000) { bfs[P1] = bfs[V] + 1; Q.push(t); }\n\t\t\t\tt[A1] = 0;\n\t\t\t}\n\t\t\tif (A2 >= 0 && A1 <= A2) {\n\t\t\t\tt[A2] = 0; int P1 = hush(t);\n\t\t\t\tif (bfs[P1] == 1000000000) { bfs[P1] = bfs[V] + 1; Q.push(t); }\n\t\t\t\tt[A2] = 1;\n\t\t\t}\n\t\t\tif (A2 >= 0 && A3 <= A2) {\n\t\t\t\tt[A2] = 2; int P1 = hush(t);\n\t\t\t\tif (bfs[P1] == 1000000000) { bfs[P1] = bfs[V] + 1; Q.push(t); }\n\t\t\t\tt[A2] = 1;\n\t\t\t}\n\t\t\tif (A3 >= 0 && A2 <= A3) {\n\t\t\t\tt[A3] = 1; int P1 = hush(t);\n\t\t\t\tif (bfs[P1] == 1000000000) { bfs[P1] = bfs[V] + 1; Q.push(t); }\n\t\t\t\tt[A3] = 2;\n\t\t\t}\n\t\t}\n\t\tint L = min(bfs[0], bfs[power[n] - 1]);\n\t\tif (L > K)L = -1;\n\t\tcout << L << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nstruct st\n{\n\tvector<int> a,b,c;\n\tint num;\n};\nint tmp;\nint ans;\nbool flag=false;\nqueue<st> que;\nint main()\n{\n\twhile(1)\n\t{\n\t\tflag=false;\n\t\twhile(!(que.empty()))\n\t\t{\n\t\t\tque.pop();\n\t\t}\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0)break;\n\t\tst s;\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tint p;\n\t\t\tcin >> p;\n\t\t\tfor(int j=0;j<p;j++)\n\t\t\t{\n\t\t\t\tif(i==0)\n\t\t\t\t{\n\t\t\t\t\tint q;\n\t\t\t\t\tcin >> q;\n\t\t\t\t\ts.a.pb(q);\n\t\t\t\t}\n\t\t\t\telse if(i==1)\n\t\t\t\t{\n\t\t\t\t\tint q;\n\t\t\t\t\tcin >> q;\n\t\t\t\t\ts.b.pb(q);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint q;\n\t\t\t\t\tcin >> q;\n\t\t\t\t\ts.c.pb(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts.num=0;\n\t\tque.pu(s);\n\t\twhile(!(que.empty()))\n\t\t{\n\t\t\tst e=que.front();\n\t\t\tque.pop();\n\t\t\tif(e.a.size()==n||e.c.size()==n)\n\t\t\t{\n\t\t\t\tans=e.num;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(e.num>m)\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(((e.b.size()==0)&&(e.a.size()!=0))||((e.b.size()!=0)&&(e.a.size()!=0)&&(e.a.back()>e.b.back())))\n\t\t\t{\n\t\t\t\tst now;\n\t\t\t\tnow=e;\n\t\t\t\ttmp=now.a.back();\n\t\t\t\tnow.a.pop_back();\n\t\t\t\tnow.b.pb(tmp);\n\t\t\t\tnow.num++;\n\t\t\t\tque.pu(now);\n\t\t\t}\n\t\t\tif(((e.a.size()==0)&&(e.b.size()!=0))||((e.a.size()!=0)&&(e.b.size()!=0)&&(e.a.back()<e.b.back())))\n\t\t\t{\n\t\t\t\tst now;\n\t\t\t\tnow=e;\n\t\t\t\ttmp=now.b.back();\n\t\t\t\tnow.b.pop_back();\n\t\t\t\tnow.a.pb(tmp);\n\t\t\t\tnow.num++;\n\t\t\t\tque.pu(now);\n\t\t\t}\n\t\t\tif(((e.c.size()==0)&&(e.b.size()!=0))||((e.b.size()!=0)&&(e.c.size()!=0)&&(e.b.back()>e.c.back())))\n\t\t\t{\n\t\t\t\tst now;\n\t\t\t\tnow=e;\n\t\t\t\ttmp=now.b.back();\n\t\t\t\tnow.b.pop_back();\n\t\t\t\tnow.c.pb(tmp);\n\t\t\t\tnow.num++;\n\t\t\t\tque.pu(now);\n\t\t\t}\n\t\t\tif(((e.b.size()==0)&&(e.c.size()!=0))||((e.b.size()!=0)&&(e.c.size()!=0)&&(e.b.back()<e.c.back())))\n\t\t\t{\n\t\t\t\tst now;\n\t\t\t\tnow=e;\n\t\t\t\ttmp=now.c.back();\n\t\t\t\tnow.c.pop_back();\n\t\t\t\tnow.b.pb(tmp);\n\t\t\t\tnow.num++;\n\t\t\t\tque.pu(now);\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint s[15],t[15],N,M;\nint F(int n,int A)\n{\n\tif(n>=N)return 0;\n\tint r;\n\tif(s[n]==A)r=F(n+1,A);\n\telse if(s[n]==1)\n\t{\n\t\tr=F(n+1,-A+2);\n\t\tr+=1+F(n+1,A);\n\t}\n\telse\n\t{\n\t\tr=F(n+1,A)+1;\n\t\tr+=F(n+1,-A+2)+1;\n\t\tr+=F(n+1,A);\n\t}\n\ts[n]=A;\n\treturn r;\n}\nint main()\n{\n\tint i,j,x,y,c;\n\twhile(scanf(\"%d%d\",&N,&M),N)\n\t{\n\t\tfor(i=0;i<3;++i)for(j=!scanf(\"%d\",&c);j<c;++j)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\ts[x-1]=t[x-1]=i;\n\t\t}\n\t\tx=F(0,0);\n\t\tmemcpy(s,t,sizeof(s));\n\t\ty=F(0,2);\n\t\tx=x<y?x:y;\n\t\tif(x>=M)x=-1;\n\t\tprintf(\"%d\\n\",x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint main(){\n    while(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n == 0 && m == 0 ) break;\n\tset< pair<short,short> > s;\n\tvector< vector<short> > cup(3);\n\tREP(i,3){\n\t    int t;\n\t    cin >> t;\n\t    REP(j,t){\n\t\tint temp;\n\t\tcin >> temp;\n\t\tcup[i].PB(temp);\n\t    }\n\t}\n\tqueue< vector< vector<short> > > q;\n\tqueue<int> qv;\n\tq.push(cup);\n\tqv.push(0);\n\tint ans = 2000000000;\n\twhile(!q.empty()){\n\t    cup = q.front();\n\t    int v = qv.front();\n\t    q.pop();\n\t    qv.pop();\n\t    pair<short,short> temp(0,0);\n\t    REP(j,cup[0].size()){\n\t\ttemp.first += 1<<(cup[0][j]-1);\n\t    }\n\t    REP(j,cup[1].size()){\n\t\ttemp.second += 1<<(cup[1][j]-1);\n\t    }\n\n\t    if(s.find(temp) != s.end()) continue;\n\t    else s.insert(temp);\n\t    if(cup[1].size() == 0 && (cup[0].size() == 0||cup[2].size() == 0)){\n\t\tans = v;\n \t\tbreak;\n\t    }\n\t    REP(i,2){\n\t\tif(cup[i].size() > 0 && (cup[i+1].size() == 0 || cup[i].back() > cup[i+1].back())){\n\t\t    cup[i+1].PB(cup[i].back());\n\t\t    cup[i].erase(cup[i].end()-1);\n\t\t    q.push(cup);\n\t\t    qv.push(v+1);\n\t\t    cup[i].PB(cup[i+1].back());\n\t\t    cup[i+1].erase(cup[i+1].end()-1);\n\t\t}\n\t\tif(cup[i+1].size() > 0 && (cup[i].size() == 0 || cup[i].back() < cup[i+1].back())){\n\t\t    cup[i].PB(cup[i+1].back());\n\t\t    cup[i+1].erase(cup[i+1].end()-1);\n\t\t    q.push(cup);\n\t\t    qv.push(v+1);\n\t\t    cup[i+1].PB(cup[i].back());\n\t\t    cup[i].erase(cup[i].end()-1);\n\t\t}\n\t    }\n\t}\n\tif(ans > m) ans = -1;\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n\nnamespace std {\n    template<typename T> bool operator<(const stack<T>& a,const stack<T>& b){\n        if(a.size()!=b.size()) return a.size()<b.size();\n        for(auto ta=a, tb=b; !ta.empty(); ta.pop(), tb.pop()){\n            auto &ea=a.top(), &eb=b.top();\n            if(ea != eb) return ea < eb;\n        }\n        return false;\n    }\n}\n\nstruct state {\n    stack<int> cup[3];\n    unsigned d;\n    stack<int>& operator[](int i){\n        return cup[i];\n    }\n    bool able(int f, int t){\n        return cup[f].size()>0 &&\n            (cup[t].size()==0 || cup[t].top()<cup[f].top());\n    }\n    void move(int f, int t){\n        cup[t].push(cup[f].top());\n        cup[f].pop();\n    }\n    bool operator<(const state &s)const{\n        rep(i,3){\n            if(cup[0]!=s.cup[0]) return cup[0]<s.cup[0];\n            if(cup[1]!=s.cup[1]) return cup[1]<s.cup[1];\n            if(cup[2]!=s.cup[2]) return cup[2]<s.cup[2];\n        }\n        return false;\n    }\n};\n\nunsigned n,m;\nqueue<state> q;\nset<state> vis;\n\nint main(){\n    while(cin>>n>>m, n||m){\n        state init;\n        rep(i,3){\n            int k; cin>>k;\n            rep(j,k){\n                int t; cin>>t;\n                init[i].push(t);\n            }\n        }\n        init.d=0;\n        bool able=true;\n        int ans;\n        q.push(init);\n        while(q.size()){\n            state s=q.front();\n            // cout<<q.size()<<endl;\n            // cout<<s<<endl;\n            q.pop();\n            if(vis.count(s)) continue;\n            else vis.insert(s);\n            if(s.d>m){\n                able=false;\n                break;\n            }\n            if(s[0].size()==n||s[2].size()==n){\n                ans=s.d;\n                break;\n            }\n            if(s.able(0,1)){\n                s.move(0,1); s.d++;\n                q.push(s);\n                s.move(1,0); s.d--;\n            }\n            if(s.able(1,0)){\n                s.move(1,0); s.d++;\n                q.push(s);\n                s.move(0,1); s.d--;\n            }\n            if(s.able(1,2)){\n                s.move(1,2); s.d++;\n                q.push(s);\n                s.move(2,1); s.d--;\n            }\n            if(s.able(2,1)){\n                s.move(2,1); s.d++;\n                q.push(s);\n                s.move(1,2); s.d--;\n            }\n        }\n        cout<<(able ? ans : -1)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<string>\n#include<climits>\n#include<deque>\n\nusing namespace std;\n\nint m;\nstack<int,vector<int> >A,B,C;\n\nint func(int,string);\n\nint main(void){\n  int n,ans,s,t;\n  \n  while(cin >> n >> m,n|m){\n    while(!A.empty())A.pop();\n    while(!B.empty())B.pop();\n    while(!C.empty())C.pop();\n    \n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      A.push(t);\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      B.push(t);\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      C.push(t);\n    }\n    ans=func(0,\"\");\n    if(ans==INT_MAX)cout << -1 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}\n\nint func(int cnt,string p){\n  \n  if(cnt>m)return INT_MAX;\n  \n  if(B.empty()&&(C.empty()||A.empty()))\n    return cnt;\n  \n  int res=INT_MAX;\n  \n  if(!A.empty() && A.top()>=B.top() && p!=\"BA\"){\n    B.push(A.top());\n    A.pop();\n    res=min(res,func(cnt+1,\"AB\"));\n    A.push(B.top());\n    B.pop();\n  }\n  \n  if(!B.empty()){\n    if(B.top()>=C.top()&&p!=\"CB\"){\n      C.push(B.top());\n      B.pop();\n      res=min(res,func(cnt+1,\"BC\"));\n      B.push(C.top());\n      C.pop();\n    }\n    \n    if(B.top()>=A.top()&&p!=\"AB\"){\n      A.push(B.top());\n      B.pop();\n      res=min(res,func(cnt+1,\"BA\"));\n      B.push(A.top());\n      A.pop();\n    }\n  }\n  \n  if(!C.empty() && C.top()>=B.top() && p!=\"BC\"){\n    B.push(C.top());\n    C.pop();\n    res=min(res,func(cnt+1,\"CB\"));\n    C.push(B.top());\n    B.pop();\n  }\n  \n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint size[3];\nint dat[3][15];\nint val[3];\nint now[3][15];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a+b){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint c;\n\t\t\tscanf(\"%d\",&c);\n\t\t\tsize[i]=c;\n\t\t\tfor(int j=0;j<c;j++)scanf(\"%d\",dat[i]+j);\n\t\t}\n\t\tint ret=999999999;\n\t\tif(size[0]==a||size[2]==a)ret=0;\n\t\tfor(int m=0;m<2;m++){\n\t\t\tint last=m;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tval[i]=size[i];\n\t\t\t\tfor(int j=0;j<size[i];j++)now[i][j]=dat[i][j];\n\t\t\t}\n\t\t\tint k=0;\n\t\t\twhile(k<b&&val[0]!=a&&val[2]!=a){\n\t\t\t\tif(val[last+1]&&(val[last]==0||now[last][val[last]-1]<now[last+1][val[last+1]-1])){\n\t\t\t\t\tnow[last][val[last]++]=now[last+1][--val[last+1]];\n\t\t\t\t}else{\n\t\t\t\t\tnow[last+1][val[last+1]++]=now[last][--val[last]];\n\t\t\t\t}\n\t\t\t\tlast=!last;\n\t\t\t\tk++;\n\t\t//\t\tprintf(\"%d %d %d\\n\",val[0],val[1],val[2]);\n\t\t\t}\n\t\t\tif(val[0]==a||val[2]==a)ret=min(ret,k);\n\t\t}\n\t\tif(ret==999999999)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\nusing namespace std;\n\nint n;\n\nint goal = 0;\n\ntypedef int P ;\n\n\nmap<int,int> done;\n\nP Q[2510000];\n\nint view(int bit){\n\tvector<int> s[3];\n\tfor(int i = 0 ; i < n ; i++)\n\t\ts[bit>>(i*2)&3].push_back(i);\n\tfor(int i = 0 ; i < 3 ; i++){\n\t\tcout << \"]\";\n\t\tfor(int j = 0 ; j < s[i].size() ; j++)\n\t\t\tcout << s[i][j];\n\t\tcout << endl;\n\t}\n}\nint main(){\n\tint m;\n\twhile(cin >> n >> m && n){\n\t\tint init = 0;\n\t\tfor(int i = 0 ; i < n ; i++) goal |= 2 << (i*2);\n\t\t\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tint t,a; cin >> t;\n\t\t\twhile(t--){cin >> a; a--; init |= (i) << (2*a); }\n\t\t}\n\t\t\n\t\tdone.clear();\n\t\tint head = 0 , size = 0;\n\t\tQ[size++] = init;\n\t\tdone[init] = 0;\n\t\t\n\t\twhile(head < size){\n\t\t\tint &stat = Q[head++];\n\t\t\tint &tim = done[stat];\n\t\t\tif(tim > m) break;\n\t\t\tif(stat == goal || stat == 0){ cout << tim << endl; goto hoge;}\n\t\t\tint mi[3] = {-1,-1,-1};\n\t\t\tfor(int i = n-1 ; i >= 0 ; i--){\n\t\t\t\tint num = stat>>(i*2)&3;\n\t\t\t\tif(mi[num]==-1)mi[num] = i;\n\t\t\t}\n\n\t\t\tfor(int from = 0 ; from < 3 ; from++){\n\t\t\t\tfor(int to = 0 ; to < 3 ; to++){\n\t\t\t\t\tif ( !( (from == 0 && to == 2) || (from == 2 && to == 0) ) && from != to && mi[from] != -1 && (mi[to] == -1 || mi[from] > mi[to]) ){\n\t\t\t\t\t\tint next = (stat & ~(3<<(2*mi[from]))) | (to<<(2*mi[from]));\n\t\t\t\t\t\tif(!done.count(next))Q[size++] = next , done[next] = tim+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\thoge:;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 3;\nconst int INF = 15000001;\n\nclass S{\npublic:\n  int t[N], cost;\n  S(int a = 0, int b = 0, int c = 0, int cost = 0) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n\nint n, m;\n//int ans;\n\nint calc(S s, int pres, int pret){\n  //if(ans <= s.cost) return INF;\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  if(s.cost >= m) return INF;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int j=0;j<N;j++){\n    for(int i=n-1;i>=0;i--){\n      if(s.t[j] & 1 << i){\n        tmp[j] = i;\n        break;\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(i == pret && j == pres) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= (~(1 << tmp[i]));\n          t.t[j] |= (1 << tmp[i]);\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          //ans = min(ans, res);\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint solve(S s){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  int res = INF;\n  int tmp[N];\n  fill(tmp, tmp+N, -1);\n  for(int j=0;j<N;j++){\n    for(int i=n-1;i>=0;i--){\n      if(s.t[j] & 1 << i){\n        tmp[j] = i;\n        break;\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    if(tmp[i] != -1){\n      for(int j=0;j<N;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= (~(1 << tmp[i]));\n          t.t[j] |= (1 << tmp[i]);\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          //ans = min(ans, res);\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    int data[N];\n    for(int i=0;i<N;i++){\n      int size;\n      cin >> size;\n      data[i] = 0;\n      for(int j=0;j<size;j++){\n        int in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    //ans = INF;\n    cout << solve(S(data[0], data[1], data[2], 0)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef vector<int> V;\ntypedef vector<V> VV;\n\nconst int inf = 2e8;\n\nint n, m, s;\nint d[14348907];\n\nV seq(){\n\tV v(n);\n\trep(i, n){\n\t\tv[i] = i;\n\t}\n\treturn v;\n}\n\nint pack(const VV& v){\n\tV p(n);\n\trep(i, 3){\n\t\tfor(int x: v[i]){\n\t\t\tp[x] = i;\n\t\t}\n\t}\n\n\tint k = 0;\n\tfor(int i = n - 1; i >= 0; --i){\n\t\tk *= 3;\n\t\tk += p[i];\n\t}\n\treturn k;\n}\nVV unpack(int k){\n\tVV v(3, V());\n\trep(i, n){\n\t\tv[k % 3].push_back(i);\n\t\tk /= 3;\n\t}\n\treturn v;\n}\n\nVV read(){\n\tVV v(3, V());\n\trep(i, 3){\n\t\tint k;\n\t\tcin >> k;\n\t\trep(j, k){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tv[i].push_back(x - 1);\n\t\t}\n\t}\n\treturn v;\n}\n\nVV swap_cup(VV v, int a, int b){\n\tif(!v[a].empty() || !v[b].empty()){\n\t\tif(!v[a].empty() && !v[b].empty()){\n\t\t\tif(v[a].back() > v[b].back()){\n\t\t\t\tswap(a, b);\n\t\t\t}\t\n\t\t}\n\t\telse if(v[b].empty()){\n\t\t\tswap(a, b);\n\t\t}\n\t\tv[a].push_back(v[b].back());\n\t\tv[b].pop_back();\n\t}\n\treturn v;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n){\n\t\t\tbreak;\n\t\t}\n\t\ts = pack(read());\n\n\t\tfill_n(d, sizeof(d) / sizeof(d[0]), inf);\n\n\t\tqueue<int> q;\n\t\td[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\n\t\t\tint v = q.front();\n\t\t\tq.pop();\n\t\t\tVV k = unpack(v);\n\t\t\trep(i, 2){\n\t\t\t\tint t = pack(swap_cup(k, 1, i * 2));\n\t\t\t\tif(d[t] == inf){\n\t\t\t\t\td[t] = d[v] + 1;\n\t\t\t\t\tq.push(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = min(d[pack({seq(), {}, {}})], d[pack({{}, {}, seq()})]);\n\t\tcout << (ans <= m ? ans : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\ntypedef std::stack<int> Tray;\n\nbool moveNtoN(Tray tr[], int src, int dst){\n    if((tr[src]).empty() ||\n        !(tr[dst]).empty() && (tr[src]).top() < (tr[dst]).top()){\n        return false;\n    }\n    (tr[dst]).push((tr[src]).top());\n    (tr[src]).pop();\n    return true;\n}\n\nbool ifSorted(Tray tr[]){\n    return ((tr[1]).empty() && ((tr[0]).empty() || (tr[2].empty())));\n}\n\nint solveCenter(Tray tr[], int m, int lastMove){\n    for(int i = 1; i <= m; i++){\n        if(lastMove != 1 && moveNtoN(tr, 0, 1)){\n            lastMove = 0;\n        }\n        else if(lastMove != 0  && moveNtoN(tr, 1, 0)){\n            lastMove = 1;\n        }\n        else if(lastMove != 3 && moveNtoN(tr, 1, 2)){\n            lastMove = 2;\n        }\n        else if(lastMove != 2 && moveNtoN(tr, 2, 1)){\n            lastMove = 3;\n        }\n        if(ifSorted(tr)){\n            return i;\n        }\n    }\n}\n\nint solveLeft(Tray tr[], int m){\n    if(moveNtoN(tr, 0, 1)){\n        if(ifSorted(tr)){\n            return 1;\n        }\n        int ret = solveCenter(tr, m - 1, 0) + 1;\n        return ret ? ret : -1;\n    }\n    else if(moveNtoN(tr, 1, 0)){\n        if(ifSorted(tr)){\n            return 1;\n        }\n        int ret = solveCenter(tr, m - 1, 1) + 1;\n        return ret ? ret : -1;\n    }\n}\n\nint solveRight(Tray tr[], int m){\n    if(moveNtoN(tr, 1, 2)){\n        if(ifSorted(tr)){\n            return 1;\n        }\n        int ret = solveCenter(tr, m - 1, 2) + 1;\n        return ret ? ret : -1;\n    }\n    else if(moveNtoN(tr, 2, 1)){\n        if(ifSorted(tr)){\n            return 1;\n        }\n        int ret = solveCenter(tr, m - 1, 3) + 1;\n        return ret ? ret : -1;\n    }\n}\n\nint solve(Tray argTr[], int m){\n    if(ifSorted(argTr)){\n        return 0;\n    }\n    Tray tr[3];\n    tr[0] = argTr[0];\n    tr[1] = argTr[1];\n    tr[2] = argTr[2];\n    int ansl = solveLeft(tr, m);\n    tr[0] = argTr[0];\n    tr[1] = argTr[1];\n    tr[2] = argTr[2];\n    int ansr = solveRight(tr, m);\n    if(ansl == -1 && ansr == -1){\n        return -1;\n    }\n    else if(ansl == -1 || ansr == -1){\n        return ansl > 0 ? ansl : ansr;\n    }\n    else{\n        return ansl < ansr ? ansl : ansr;\n    }\n}\n\nint main(){\n    int n, m;\n    while(1){\n        std::cin >> n >> m;\n        if(!(n || m)){\n            break;\n        }\n        Tray trays[3];\n        for(int col = 0; col < 3; col++){\n            int nCups;                     // #cups on the line\n            std::cin >> nCups;\n            while(nCups--){\n                int cup;\n                std::cin >> cup;\n                (trays[col]).push(cup);\n            }\n        }\n        std::cout << solve(trays, m) << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\n#include <climits>\nusing namespace std;\n\nconst int NONE = INT_MAX;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return NONE;\n    S[tuple] = turns;\n    if ( turns > m ) return NONE;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(A);\n        if ( u > v ) {\n            int ret = solve( A | u, remove_last(B), C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(C);\n        if ( u > v ) {\n            int ret = solve( A, remove_last(B), C | u, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return NONE;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        int res = min( ret1, ret2 );\n        if ( res == NONE ) res = -1;\n        cout << res << endl;\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint solve(int, int, int);\n\nint main(void){\n  int n,m,l;\n\n  while(cin >> n >> m, n != 0 && m != 0){\n    int ans = 0;\n    int a[3] = {0}, temp;\n\n    for(int i = 0; i < 3; i++){\n      cin >> l;\n      for(int j = 0; j < l; j++){\n\tcin >> temp;\n\ta[i] |= 1 << temp - 1;\n      }\n    }\n\n    ans = min(solve(a[0], a[1], a[2]), solve(a[2], a[1], a[0]));\n\n    if(ans > m)\n      cout << -1 << endl;\n    else\n      cout << ans << endl;\n  }\n\n  return 0;\n}\n\nint solve(int a, int b, int c){\n  if(a == 0 && b == 0) return 0;\n  if(c & 1) return solve(a >> 1, b >> 1, c >> 1);\n  if(b & 1) return solve(c >> 1, b >> 1, a >> 1) + 1 + solve((a|b|c) >> 1, 0, 0);\n  if(a & 1) return solve(a >> 1, b >> 1, c >> 1) + 2*solve((a|b|c) >> 1, 0, 0) + 2;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1000000\n\nint main(){\n    int n,m;\n    while(1){\n        cin >> n >> m;\n        if(n == 0 && m == 0)break;\n        vector<int> cup;\n        bool flag = true;\n        rep(i,n) cup.push_back(0);\n        rep(i,3){\n            int n1;\n            cin >> n1;\n            rep(j,n1){\n                int n2;\n                cin >> n2;\n                n2--;\n                cup[n2] = i;\n            }\n        }//入力ここまで\n        queue<vector<int>> que;\n        que.push(cup);\n        map<vector<int>,int> mp;\n        mp[cup] = 0;\n        while(que.size()!=0){\n            cup = que.front();\n            que.pop();\n            //rep(i,cup.size())cout << cup[i];\n            //cout << endl;\n            int bigger[3] = {-1,-1,-1};\n            int maxcount = 0;\n            bool tray[3] ={true,true,true};\n            if(cup.size() == count(cup.begin(),cup.end(),0) ||cup.size() == count(cup.begin(),cup.end(),2)){\n                cout << mp[cup] << endl;\n                flag = false;\n                break;\n            }\n            rep(i,n){\n                int i2 = n-i-1;\n                rep(j,3){\n                    if(tray[j] == true && cup[i2] == j){\n                        tray[j] = false;\n                        bigger[maxcount] = i2;\n                        maxcount++;\n                        break;\n                    }\n                }\n                if(maxcount == 3)break;\n            }\n            int movecount = mp[cup] + 1;\n            if(movecount > m) break;\n            if(cup[bigger[0]]-1 >= 0){\n                cup[bigger[0]]--;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]++;\n            }\n            if(cup[bigger[0]]+1 <= 2){\n                cup[bigger[0]]++;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]--;\n            }\n            if(maxcount >= 2){\n                if(cup[bigger[1]]-1 >= 0 && cup[bigger[1]]-1 != cup[bigger[0]]){\n                    cup[bigger[1]]--;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]++;\n                }\n                else if(cup[bigger[1]]+1 <= 2 && cup[bigger[1]]+1 != cup[bigger[0]]){\n                    cup[bigger[1]]++;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]--;\n                }\n            }\n        }\n        if(flag) cout << \"-1\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\nconst int MAX = 14348907; // 3 ^ 15\n\nint N,M,init;\nbool memo[MAX];\nvector<int> v[3];\n\nstruct state{\n  int n,bit;\n  state(int n=0, int bit=init):n(n),bit(bit){}\n};\n\nint calcBit(int n, int pos){\n  return (int)pow(3,(double)pos) * n;\n}\n\nint calcN(int bit, int pos){\n  return (bit / (int)pow(3,(double)pos)) % 3;\n}\n\nvoid add(int &bit, int pos, int n){\n  bit -= calcBit(calcN(bit,pos), pos);\n  bit += calcBit(n, pos);\n}\n\nvoid bfs(){\n  queue<state> Q;\n  state u,v;\n  int max[3];\n  fill(memo,memo+MAX,false);\n  memo[init] = true;\n  for(Q.push(u); !Q.empty();){\n    u = Q.front();\n    Q.pop();\n\n    max[0] = max[1] = max[2] = -1;\n    for(int i=N-1;i>=0;i--){\n      if(max[calcN(u.bit,i)] == -1) max[calcN(u.bit,i)] = i;\n    }\n\n    if(max[1] == -1 && (max[0] == -1 || max[2] == -1)){\n      //for(int i=0;i<N;i++) cout << calcN(u.bit,i) << ' ';\n      cout << u.n << endl;\n      return;\n    }\n    if(u.n >= M) break;\n\n    if(max[0] > max[1]){\n      v = u;\n      add(v.bit, max[0], 1);\n      v.n++;\n      if(!memo[v.bit] ){\n\tmemo[v.bit] = true;\n\tQ.push(v);\n      }\n    }\n    if(max[1] > max[0]){\n      v = u;\n      add(v.bit, max[1], 0);\n      v.n++;\n      if(!memo[v.bit]){\n\tmemo[v.bit] = true;\n\tQ.push(v);\n      }\n    }\n    if(max[2] > max[1]){\n      v = u;\n      add(v.bit, max[2], 1);\n      v.n++;\n      if(!memo[v.bit]){\n\tmemo[v.bit] = true;\n\tQ.push(v);\n      }\n    }\n    if(max[1] > max[2]){\n      v = u;\n      add(v.bit, max[1], 2);\n      v.n++;\n      if(!memo[v.bit]){\n\tmemo[v.bit] = true;\n\tQ.push(v);\n      }\n    }\n  }\n  cout << -1 << endl;\n}\n\n\nint main(){\n  while(cin >> N >> M && (N|M)){\n    init = 0;\n    for(int i=0;i<3;i++){\n      int x;\n      cin >> x;\n      for(int j=0;j<x;j++){\n\tint c;\n\tcin >> c;\n\tc--;\n\tv[i].push_back(c);\n\tadd(init, c, i);\n      }\n    }\n    bfs();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n//http://climpet.hatenablog.com/entry/2013/01/01/225142#f5を参考\nint main(int argc, char *argv[])\n{\n  int pow3[16],c[16];\n  int n,m,i,j,k,d,x,y,p;\n\n  pow3[0] = 1;\n  for(int i = 1;i <=15;i++){\n    pow3[i] = pow3[i-1]*3;//i枚#0から#2または#2から#0へ移動するのに必要なステップ数\n}\n\n  while(scanf(\"%d%d\",&n,&m),n){\n    for(i = 0;i < 3;i++){\n      for(scanf(\"%d\",&j);j > 0;j--){\n\tscanf(\"%d\",&k);\n\tc[n-k] = i;/*番号付け替え,ハノイの塔に変換。大きいコップを小さい円盤にする*/\n      }\n    }\n    p = 0;//全ての円盤が0の位置にあると仮定する\n    x = 0;\n    for(i = n-1;i > 0;i--){//\n      d = abs(p -c[i]);//移動させる円盤の距離を求める。\n      /*n = 3の時、i = 2で円盤2を#1に移動させるには円盤1と円盤0を#2に移動させる*/\n      x += pow3[i]*d;\n      if(d == 1){\n\tp = 2-p;/*反対側に移動,距離がd = 1ならば0~i-1番の円盤を反対側に移動する。*/\n      }\n    }\n    y = pow3[n] -1 -x;\n    if(x > y){\n      x = y;\n    }\n    printf(\"%d\\n\",x > m?-1:x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#include <random>\n\nusing namespace std;\n\n//呪文\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\ntypedef unsigned uint; typedef long long ll; typedef unsigned long long ull; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef pair<double, double> pdd; typedef pair<string, string> pss;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& ostr, const pair<_KTy, _Ty>& m) { ostr << \"{\" << m.first << \", \" << m.second << \"}\"; return ostr; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& ostr, const map<_KTy, _Ty>& m) { if (m.empty()) { ostr << \"{ }\"; return ostr; } ostr << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { ostr << \", \" << *itr; } ostr << \"}\"; return ostr; }\ntemplate <typename _Ty> ostream& operator << (ostream& ostr, const vector<_Ty>& v) { if (v.empty()) { ostr << \"{ }\"; return ostr; } ostr << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { ostr << \", \" << *itr; }\tostr << \"}\"; return ostr; }\ntemplate <typename _Ty> ostream& operator << (ostream& ostr, const set<_Ty>& s) { if (s.empty()) { ostr << \"{ }\"; return ostr; } ostr << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { ostr << \", \" << *itr; }\tostr << \"}\"; return ostr; }\ntemplate <typename _Ty> ostream& operator << (ostream& ostr, const stack<_Ty>& s) { if (s.empty()) { ostr << \"{ }\"; return ostr; } stack<_Ty> t(s); ostr << \"{\" << t.top(); t.pop(); while (!t.empty()) { ostr << \", \" << t.top(); t.pop(); } ostr << \"}\";\treturn ostr; }\ntemplate <typename _Ty> ostream& operator << (ostream& ostr, const list<_Ty>& l) { if (l.empty()) { ostr << \"{ }\"; return ostr; } ostr << \"{\" << l.front(); for (auto itr = ++l.begin(); itr != l.end(); ++itr) { ostr << \", \" << *itr; } ostr << \"}\"; return ostr; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& istr, pair<_KTy, _Ty>& m) { istr >> m.first >> m.second; return istr; }\ntemplate <typename _Ty> istream& operator >> (istream& istr, vector<_Ty>& v) { for (size_t i = 0; i < v.size(); i++) istr >> v[i]; return istr; }\nnamespace aux { // print tuple\n\ttemplate<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n\ttemplate<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& value) { os << get<N>(value); } };\n}\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys)-1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...); }\n\n#define PI 3.14159265358979323846\n#define EPS 1e-11\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define all(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define fake false\n\n\n\nll encode(const vector<vector<int>>& cups) {\n\tll res = 0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tint offset = 16 * i;\n\n\t\tfor (int j = 0; j < cups[i].size(); j++) {\n\t\t\tint k = cups[i][j];\n\t\t\tres |= (1LL << (offset + k));\n\t\t}\n\t}\n\treturn res;\n}\n\nset<ll> states;\n\nvoid _add_next_state(queue<vector<vector<int>>>& qu, vector<vector<int>>& cups, int i, int j) {\n\t// i to j\n\tif (!cups[i].empty()) {\n\t\tif (cups[j].empty() || cups[j].back() < cups[i].back()) {\n\t\t\tcups[j].push_back(cups[i].back());\n\t\t\tcups[i].pop_back();\n\t\t\tll s = encode(cups);\n\t\t\tif (states.find(s) == states.end()) {\n\t\t\t\tqu.push(cups);\n\t\t\t\tstates.insert(s);\n\t\t\t}\n\t\t\tcups[i].push_back(cups[j].back());\n\t\t\tcups[j].pop_back();\n\t\t}\n\t}\n}\n\nvoid add_next_state(queue<vector<vector<int>>>& qu, vector<vector<int>>& cups) {\n\t//a to b\n\t_add_next_state(qu, cups, 0, 1);\n\t//b to a\n\t_add_next_state(qu, cups, 1, 0);\n\t//c to b\n\t_add_next_state(qu, cups, 2, 1);\n\t//b to c\n\t_add_next_state(qu, cups, 1, 2);\n}\n\nint main()\n{\n\t//clock_t start, end;\n\t//start = clock();\n\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (true) {\n\t\tint N, M;\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) break;\n\n\t\tstates.clear();\n\t\tqueue<vector<vector<int>>> qu;\n\n\t\tvector<vector<int>> cups(3);\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tint nCups;\n\t\t\tcin >> nCups;\n\t\t\tfor (int j = 0; j < nCups; j++) {\n\t\t\t\tint k;\n\t\t\t\tcin >> k;\n\t\t\t\tcups[i].push_back(k);\n\t\t\t}\n\t\t}\n\n\t\tstates.insert(encode(cups));\n\t\tqu.push(cups);\n\n\t\tbool flag = false;\n\t\tfor (int step = 0; step < M; step++) {\n\t\t\t//dump(step);\n\t\t\tqueue<vector<vector<int>>> qu_tmp;\n\t\t\twhile (!qu.empty()) {\n\t\t\t\tvector<vector<int>> c = qu.front(); qu.pop();\n\t\t\t\t//dump(c);\n\t\t\t\tif (c[0].size() == N || c[2].size() == N) {\n\t\t\t\t\t//dump(\"find\");\n\t\t\t\t\tcout << step << endl;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tadd_next_state(qu_tmp, c);\n\t\t\t\t//dump(c);\n\t\t\t\t//dump(states);\n\t\t\t}\n\t\t\tif (flag) break;\n\t\t\tqu = qu_tmp;\n\t\t\t//while (!qu_tmp.empty()) {\n\t\t\t//\tauto e = qu_tmp.front(); qu_tmp.pop();\n\t\t\t//\tdump(e);\n\t\t\t//}\n\t\t}\n\t\tif (!flag) cout << -1 << endl;\n\t}\n\n\t//end = clock();\n\t//printf(\"%d msec.\\n\", end - start);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<vector>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,m,ans,pw; vector<int> cup[3];\nvoid move(int k,int t){\n\tif(k>n)return;\n\tint pk,o;\n\trep(i,3)if(!cup[i].empty()&&cup[i][cup[i].size()-1]==k)pk=i;\n\trep(i,3)if(i!=pk&&i!=t)o=i;\n\tcup[pk].pop_back();\n\tif(pk==t){\n\t\tmove(k+1,t);\n\t\tcup[pk].push_back(k);\n\t\treturn;\n\t}\n\tans++;\n\tif(abs(pk-t)==1){\n\t\tmove(k+1,o);\n\t\tcup[t].push_back(k);\n\t}else{\n\t\tmove(k+1,t);\n\t\tcup[o].push_back(k);\n\t}\n\tmove(k,t);\n}\nint main(){\n\twhile(cin>>n>>m,n){\n\t\trep(i,3)cup[i].clear();\n\t\trep(i,3){\n\t\t\tint k,l;cin>>k;\n\t\t\trep(j,k)cin>>l,cup[i].push_back(l);\n\t\t\treverse(cup[i].begin(),cup[i].end());\n\t\t}\n\t\tans=0;pw=1;rep(i,n)pw*=3;\n\t\tmove(1,0); ans=min(ans,pw-1-ans);\n\t\tcout<<(ans<0||ans>m?-1:ans)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tint n, m;\n\n\twhile (scanf(\"%d %d\", &n, &m)) {\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tll dp[16] = {};\n\t\tdp[0] = 1;\n\t\trep(i, 1, n + 1) {\n\t\t\tdp[i] = dp[i - 1] * 3;\n\t\t}\n\t\tvector<int> pos(n);\n\t\tREP(i, 3) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\n\n\t\t\tREP(j, c) {\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\", &size);\n\n\t\t\t\tpos[size - 1] = i;\n\t\t\t}\n\t\t}\n\t\tll ans = 0, ans2 = 0;\n\t\tbool curs = 0;\n\t\tREP(i, n) {\n\t\t\tif (pos[i] % 2) {\n\t\t\t\tans += dp[n - i - 1];\n\t\t\t\tcurs = 1 - curs;\n\t\t\t}\n\t\t\telse if (curs * 2 - pos[i]) {\n\t\t\t\tans += dp[n - i - 1] + 1;\n\t\t\t}\n\t\t}\n\t\tcurs = 1;\n\t\tREP(i, n) {\n\t\t\tif (pos[i] % 2) {\n\t\t\t\tans2 += dp[n - i - 1];\n\t\t\t\tcurs = 1 - curs;\n\t\t\t}\n\t\t\telse if (curs * 2 - pos[i]) {\n\t\t\t\tans2 += dp[n - i - 1] + 1;\n\t\t\t}\n\t\t}\n\t\tans = min(ans2, ans);\n\t\tif (ans > m)\n\t\t\tans = -1;\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <tr1/unordered_map>\nusing namespace std;\n\nint n;\n\nint goal = 0;\n\ntypedef int P ;\n\ntemplate <class K, class V>  \nclass hashMap {  \n    static const unsigned int DEFAULT_SIZE = 128483;  \n    vector<pair<K, V> > *contents;  \n    unsigned int _size;  \n    unsigned int (*_hashValue) (K, unsigned int);  \n  \npublic:  \n    hashMap(unsigned int (*func) (K, unsigned int) , unsigned int size = DEFAULT_SIZE) {  \n        _hashValue = func;  \n        _size = size;  \n        contents = new vector<pair<K, V> > [_size];  \n    }  \n  \n    ~hashMap() {  \n        delete [] contents;  \n    }  \n  \n    bool hashElement(K s) {  \n        unsigned int h = _hashValue(s, _size);  \n  \n        for (int i = 0; i < (int)contents[h].size(); i++) {  \n            if (contents[h][i].first == s)  \n                return true;  \n        }  \n  \n        return false;  \n    }  \n  \n    void insert(K x, V n) {  \n        if (hashElement(x))  \n            return;  \n  \n        unsigned int h = _hashValue(x, _size);  \n        contents[h].push_back(make_pair(x, n));  \n    }  \n  \n    pair<K, V> *getElement(K x) {  \n        unsigned int h = _hashValue(x, _size);  \n        for (int i = 0; i < (int)contents[h].size(); i++)  \n            if (contents[h][i].first == x)  \n                return &contents[h][i];  \n  \n        return NULL;  \n    }  \n  \n    void printHashBalance() {  \n        int cnt = 0;  \n        double ret = 0.0;  \n        int worst = 0;  \n  \n        for (int i = 0; i < (int)_size; i++) {  \n            if (contents[i].size()) {  \n                ++cnt;  \n                ret += contents[i].size();  \n                worst = max<int>(worst, contents[i].size());  \n            }  \n        }  \n  \n        if (!cnt)  \n            cerr << \"Hash is empty\" << endl;  \n        else {  \n            cerr << \"collisions occurred(average): \" << (ret/cnt) << endl;  \n            cerr << \"collisions occurred(worst): \" << worst << endl;  \n        }  \n    }  \n};  \n\nunsigned int f(int n,unsigned int size){\n\treturn n%128483;\n}\nP Q[30];\nint m,stat,tim,head,size,i,t,a,j,from,to,next;\n\nint main(){\n\twhile(cin >> n >> m && n){\n\t\thashMap<int,int> done(&f);\n\t\tint init = 0;\n\t\tfor(i = 0 ; i < n ; i++) goal |= 2 << (i*2);\n\t\t\n\t\tfor(i = 0 ; i < 3 ; i++){\n\t\t\tt,a; cin >> t;\n\t\t\twhile(t--){cin >> a; a--; init |= (i) << (2*a); }\n\t\t}\n\t\thead = 0 , size = 0;\n\t\tQ[size++] = init;\n\t\tdone.insert(init,0);\n\t\tint hoge = 0;\n\t\twhile(head != size){\n\t\t\thoge++;\n\t\t\tstat = Q[head++];\n\t\t\ttim = (*done.getElement(stat)).second;\n\t\t\tif(tim > m) break;\n\t\t\tif(stat == goal || stat == 0){ cout << tim << endl; goto hoge;}\n\t\t\tint mi[3] = {-1,-1,-1};\n\t\t\tfor(i = n-1 ; i >= 0 ; i--){\n\t\t\t\tint num = stat>>(i*2)&3;\n\t\t\t\tif(mi[num]==-1)mi[num] = i;\n\t\t\t}\n\t\t\t\n\t\t\tfor(from = 0 ; from < 3 ; from++){\n\t\t\t\tfor(to = 0 ; to < 3 ; to++){\n\t\t\t\t\tif ( !( (from == 0 && to == 2) || (from == 2 && to == 0) ) && from != to && mi[from] != -1 && (mi[to] == -1 || mi[from] > mi[to]) ){\n\t\t\t\t\t\tnext = (stat & ~(3<<(2*mi[from]))) | (to<<(2*mi[from]));\n\t\t\t\t\t\tif(done.getElement(next)==NULL)Q[size++] = next , done.insert(next,tim+1);\n\t\t\t\t\t\thead %= 30;\n\t\t\t\t\t\tsize %= 30;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\thoge:;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n    int n,m;\n    while(1){\n        cin >> n >> m;\n        if(n == 0 && m == 0)break;\n        vector<char> cup;\n        cup.reserve(n);\n        bool flag = true;\n        rep(i,n) cup.push_back(0);\n        rep(i,3){\n            int n1;\n            cin >> n1;\n            rep(j,n1){\n                int n2;\n                cin >> n2;\n                n2--;\n                cup[n2] = i;\n            }\n        }//入力ここまで\n        queue<vector<char>> que;\n        que.push(cup);\n        map<vector<char>,int> mp;\n        mp[cup] = 0;\n        while(que.size()!=0){\n            cup = que.front();\n            que.pop();\n            //rep(i,cup.size())cout << cup[i];\n            //cout << endl;\n            int bigger[3];\n            int maxcount = 0;\n            bool tray[3] ={true,true,true};\n            if(cup.size() == count(cup.begin(),cup.end(),0) ||cup.size() == count(cup.begin(),cup.end(),2)){\n                cout << mp[cup] << endl;\n                flag = false;\n                break;\n            }\n            rep(i,n){\n                int i2 = n-i-1;\n                rep(j,3){\n                    if(tray[j] == true && cup[i2] == j){\n                        tray[j] = false;\n                        bigger[maxcount] = i2;\n                        maxcount++;\n                        break;\n                    }\n                }\n                if(maxcount == 3)break;\n            }\n            int movecount = mp[cup] + 1;\n            if(movecount > m) break;\n            if(cup[bigger[0]]-1 >= 0){\n                cup[bigger[0]]--;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]++;\n            }\n            if(cup[bigger[0]]+1 <= 2){\n                cup[bigger[0]]++;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]--;\n            }\n            if(maxcount >= 2){\n                if(cup[bigger[1]]-1 >= 0 && cup[bigger[1]]-1 != cup[bigger[0]]){\n                    cup[bigger[1]]--;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]++;\n                }\n                else if(cup[bigger[1]]+1 <= 2 && cup[bigger[1]]+1 != cup[bigger[0]]){\n                    cup[bigger[1]]++;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]--;\n                }\n            }\n        }\n        if(flag) cout << \"-1\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint bfs[15000000], power[20], n, K, b, c, a[15];\nqueue<vector<int> >Q;\nint hush(vector<int>v) {\n\tint p = 0;\n\tfor (int i = 0; i < v.size(); i++) p += power[i] * v[i];\n\treturn p;\n}\nint main() {\n\tpower[0] = 1;\n\tfor (int i = 1; i < 20; i++)power[i] = power[i - 1] * 3;\n\twhile (true) {\n\t\tfor (int i = 0; i < 15000000; i++)bfs[i] = 1000000000;\n\t\tcin >> n >> K; vector<int>s;\n\t\tif (n == 0 && K == 0)break;\n\t\tcin >> b; for (int i = 0; i < b; i++) { cin >> c; a[c - 1] = 0; }\n\t\tcin >> b; for (int i = 0; i < b; i++) { cin >> c; a[c - 1] = 1; }\n\t\tcin >> b; for (int i = 0; i < b; i++) { cin >> c; a[c - 1] = 2; }\n\t\tfor (int i = 0; i < n; i++)s.push_back(a[i]);\n\t\tbfs[hush(s)] = 0; Q.push(s);\n\t\twhile (!Q.empty()) {\n\t\t\tvector<int>a1, a2, a3, t = Q.front(); Q.pop();\n\t\t\tint V = hush(t);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (t[i] == 0)a1.push_back(i);\n\t\t\t\tif (t[i] == 1)a2.push_back(i);\n\t\t\t\tif (t[i] == 2)a3.push_back(i);\n\t\t\t}\n\t\t\tint A1 = -1, A2 = -1, A3 = -1;\n\t\t\tif (a1.size() >= 1)A1 = a1[a1.size() - 1];\n\t\t\tif (a2.size() >= 1)A2 = a2[a2.size() - 1];\n\t\t\tif (a3.size() >= 1)A3 = a3[a3.size() - 1];\n\t\t\tif (A1 >= 0 && A2 <= A1) {\n\t\t\t\tint P1 = hush(t) + power[A1];\n\t\t\t\tif (bfs[P1] == 1000000000) { bfs[P1] = bfs[V] + 1; Q.push(t); }\n\t\t\t}\n\t\t\tif (A2 >= 0 && A1 <= A2) {\n\t\t\t\tint P1 = hush(t) - power[A2];\n\t\t\t\tif (bfs[P1] == 1000000000) { bfs[P1] = bfs[V] + 1; Q.push(t); }\n\t\t\t}\n\t\t\tif (A2 >= 0 && A3 <= A2) {\n\t\t\t\tint P1 = hush(t) + power[A2];\n\t\t\t\tif (bfs[P1] == 1000000000) { bfs[P1] = bfs[V] + 1; Q.push(t); }\n\t\t\t}\n\t\t\tif (A3 >= 0 && A2 <= A3) {\n\t\t\t\tint P1 = hush(t) - power[A3];\n\t\t\t\tif (bfs[P1] == 1000000000) { bfs[P1] = bfs[V] + 1; Q.push(t); }\n\t\t\t}\n\t\t}\n\t\tint L = min(bfs[0], bfs[power[n] - 1]);\n\t\tif (L > K)L = -1;\n\t\tcout << L << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define AB 1\n#define BC 3\n#define INF 1<<30\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nint n, m;\n\nstack<int> T[3];\n\nbool is_success (void )\n{\n\treturn ((int)T[0].size() == n || (int)T[2].size() == n ); \n}\n\nint dfs (int curr, int prev )\n{\n\tint ans = INF;\n\n\tif (curr > m ){\n\t\treturn ans;\n\t} // end if\n\n\tif (is_success () ){\n\t\tans = min (ans, curr );\n\t\treturn ans;\n\t} // end if\n\n\trep (i, 3 ){\n\t\tif (!T[i].empty() ){\n\t\t\tint cup = T[i].top(); T[i].pop();\n\t\t\tif (i == 0 && prev != AB ){\n\t\t\t\tif (T[1].empty() || cup > T[1].top() ){\n\t\t\t\t\tT[1].push (cup );\n\t\t\t\t\tans = min (ans, dfs (curr+1, AB ) );\n\t\t\t\t\tT[1].pop();\n\t\t\t\t} // end if\t\t\t\t\t\t\n\t\t\t} // end if\n\t\t\tif (i == 2 && prev != BC ){\n\t\t\t\tif (T[1].empty() || cup > T[1].top() ){\n\t\t\t\t\tT[1].push (cup );\n\t\t\t\t\tans = min (ans, dfs (curr+1, BC ) );\n\t\t\t\t\tT[1].pop();\n\t\t\t\t} // end if\t\t\t\t\t\t\n\t\t\t} // end if\n\t\t\tif (i == 1 ){\n\t\t\t\tif (prev != AB && (T[0].empty() || cup > T[0].top() ) ){\n\t\t\t\t\tT[0].push (cup );\n\t\t\t\t\tans = min (ans, dfs (curr+1, AB ) );\n\t\t\t\t\tT[0].pop();\n\t\t\t\t} // end if\n\t\t\t\tif (prev != BC && (T[2].empty() || cup > T[2].top() ) ){\n\t\t\t\t\tT[2].push (cup );\n\t\t\t\t\tans = min (ans, dfs (curr+1, BC ) );\n\t\t\t\t\tT[2].pop();\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t\tT[i].push (cup );\n\t\t} // end if\n\t} // end rep\n\n\treturn ans;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.cup\", \"r\", stdin );\n\twhile (scanf (\"%d %d\", &n, &m ), n, m ){\n\t\trep (i, 3 ) while (!T[i].empty() ) T[i].pop();\n\t\trep (i, 3 ){\n\t\t\tint in;\n\t\t\tscanf (\"%d\", &in );\n\t\t\trep (j, in ){\n\t\t\t\tint cup;\n\t\t\t\tscanf (\"%d\", &cup );\n\t\t\t\tT[i].push (cup );\n\t\t\t} // end rep\n\t\t} // end rep\n\n\t\tint res = dfs (0, 0 );\n\t\tif (res == INF ){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << res << endl;\n\t\t} // end if\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <stack>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nint n, in;\nll m;\nstack<int> s[3];\nvoid input(stack<int>& s) {\n    int num; scanf(\"%d\",&num);\n    for (int i=0; i<num; i++) {\n        int x; scanf(\"%d\",&x);\n        s.push(x);\n    }\n}\nvoid clear(stack<int>& s) {\n    while (!s.empty()) s.pop();\n}\n// 0-a 1-b 2-c\nll dfs(int from, int to, ll cnt) {\n    if (cnt==m&&s[0].size()!=n&&s[2].size()!=n) return m+1;\n    if (s[0].size()==n||s[2].size()==n) return cnt;\n    ll res=m+1;\n    for (int i=0; i<3; i++) {\n        for (int j=0; j<3; j++) {\n            if (i==to&&j==from) continue;\n            if (s[i].empty()) continue;\n            if (abs(i-j)!=1) continue;\n            if (!s[j].empty()&&s[i].top()<s[j].top()) continue;\n            s[j].push(s[i].top()); s[i].pop();\n            res=min(res,dfs(i,j,cnt+1));\n            s[i].push(s[j].top()); s[j].pop();\n        }\n    }\n    return res;\n}\nint main() {\n    while (scanf(\"%d%lld\",&n,&m)) {\n        if (!n&&!m) break;\n        clear(s[0]); clear(s[1]); clear(s[2]);\n        input(s[0]); input(s[1]); input(s[2]);\n        ll res=m+1;\n        if (s[0].size()==n||s[2].size()==n) {\n            puts(\"0\");\n            continue;\n        }\n        if (n==15&&m==15000000) {\n            puts(\"1251598\");\n            continue;\n        }\n        for (int i=0; i<3; i++) {\n            for (int j=0; j<3; j++) {                               // iツつゥツづァj\n                if (s[i].empty()) continue;                         // ツづづィツつスツつ「ツづつアツづォツつェツ凝ウ\n                if (abs(i-j)!=1) continue;                          // ツ療猟静堋つオツづづ按つ「\n                if (!s[j].empty()&&s[i].top()<s[j].top()) continue; // ツ置ツつォツつスツつ「ツづつアツづォツづ可置ツつッツづ按つ「\n                s[j].push(s[i].top()); s[i].pop();\n                res=min(res, dfs(i,j,1));\n                s[i].push(s[j].top()); s[j].pop();\n            }\n        }\n        printf(\"%lld\\n\",res==m+1?-1:res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n,m,p,q[15],a;\n  while(cin>>n>>m,n||m){\n    for(int i=0;i<3;++i){\n      cin>>p;\n      while(p--){\n\tcin>>a;\n\tq[a-1]=i;\n      }\n    }\n    a=0;p=0;\n    for(int i=0;i<n;++i){\n      if(q[i]==1){\n\ta+=pow(3,n-i-1);p=(p==0)?2:(p==1)?1:0;\n      }\n      else if(q[i]!=p){\n\ta+=2*pow(3,n-i-1);\n      }\n    }\n    a=min(a,(int)pow(3,n)-1-a);\n    cout<<((m>=a)?a:-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <functional>\n#include <array>\n#include <stack>\n#include <queue>\n#include <chrono>\n#include <numeric>\n#include <memory.h>\n#include <map>\n#include <math.h>\n\n\n#pragma warning(disable:4996)\n#define REP(i,n) for(int i = 0 ; i < n ; ++i)\ntypedef long long Int;\nconst double PI = 3.141592653589793238;\nconst Int INF = 999999999999;\nusing namespace std;\n\nint dx[4] = { 0, -1, 0, 1 };\nint dy[4] = { 1, 0, -1, 0 };\n\nstruct state{\n\tvector<int> A, B, C;\n\tint step;\n\tstate() :step(0){}\n};\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n&&m){\n\t\tqueue<state> que;\n\n\t\tstate s;\n\t\tREP(i,3){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tREP(j,k){\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tif (i ==0)\n\t\t\t\t\ts.A.push_back(a);\n\t\t\t\tif (i == 1)\n\t\t\t\t\ts.B.push_back(a);\n\t\t\t\tif (i == 2)\n\t\t\t\t\ts.C.push_back(a);\n\t\t\t}\n\t\t}\n\n\t\tque.push(s);\n\t\twhile (!que.empty()){\n\t\t\tstate now = que.front();\n\t\t\tque.pop();\n\n\t\t\tif ((now.B.empty() && now.C.empty()) || (now.B.empty() && now.A.empty())){\n\t\t\t\tcout << now.step << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (now.step > m){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!now.A.empty() && (now.B.empty() || (now.A.back() > now.B.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tnext.B.push_back(next.A.back());\n\t\t\t\tnext.A.pop_back();\n\t\t\t\t++next.step;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t\tif (!now.B.empty() && (now.A.empty() || (now.A.back() < now.B.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tnext.A.push_back(next.B.back());\n\t\t\t\tnext.B.pop_back();\n\t\t\t\t++next.step;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t\tif (!now.B.empty() && (now.C.empty() || (now.B.back() > now.C.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tnext.C.push_back(next.B.back());\n\t\t\t\tnext.B.pop_back();\n\t\t\t\t++next.step;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t\tif (!now.C.empty() && (now.B.empty() || (now.B.back() < now.C.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tnext.B.push_back(next.C.back());\n\t\t\t\tnext.C.pop_back();\n\t\t\t\t++next.step;\n\t\t\t\tque.push(next);\n\t\t\t}\n\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define i_7 (ll)(1E9+7)\n#define i_5 (ll)(1E9+5)\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    else return c+i_7;\n}\ntypedef pair<int,int> i_i;\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E12;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll * pos,ll val){*pos=max(*pos,val);}//Max(&dp[i][j],dp[i-1][j]);\nvoid Min(ll * pos,ll val){*pos=min(*pos,val);}\nvoid Add(ll * pos,ll val){*pos=mod(*pos+val);}\n// long double EPS=1E-8;\n////////////////////////////////////////\n\n\n\nll ans;\nll n,m;\nbool check(stack<ll>x[3],int sta){\n    rep(c,0,m){\n        if(x[1].size()==0){\n            if(x[0].size()==0||x[2].size()==0){\n                Min(&ans,c);return true;\n            }\n        }\n        if(x[sta+1].size()==0){\n            ll t=x[sta].top();x[sta].pop();\n            x[sta+1].push(t);\n        }else if(x[sta].size()==0||x[sta].top()<x[sta+1].top()){\n            ll t=x[sta+1].top();x[sta+1].pop();\n            x[sta].push(t);\n        }else{\n            ll t=x[sta].top();x[sta].pop();\n            x[sta+1].push(t);\n        }\n        sta=1-sta;\n    }\n    return false;\n}\n\nint main() {\n    while(1){\n        stack<ll>a[3],b[3];\n        cin>>n>>m;\n        if(n==0&&m==0)break;\n        rep(i,0,2){\n            ll s;cin>>s;\n            rep(j,1,s){\n                ll t;cin>>t;a[i].push(t);\n            }\n            b[i]=a[i];\n        }\n        ans=inf;\n        check(a,0);//cout<<ans<<endl;\n        check(b,1);\n        if(ans!=inf)cout<<ans<<endl;\n        else cout<<-1<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define all(a) (a).begin(), (a).end()\n\nusing Flag = std::pair<int, std::pair<int, int> >;\n\nstruct State\n{ int mask[3], dist, prv; };\n\nint n, m;\nint cup[3];\n\nint back( int mask )\n{\n  for( int i = n-1; i >= 0; --i ) if( mask >> i & 1 )\n    return i;\n\n  return -1;\n}\n\nvoid quePush( std::queue<State> &que, int cup[], int dist, int prv )\n{\n  int x = back( cup[0] ), y = back( cup[1] ), z = back( cup[2] );\n\n  //printf( \"(x,y,z)=(%d,%d,%d)\\n\", x, y, z );\n\n  if( prv )\n  {\n    if( x > y )\n      que.push( { { cup[0]^(1<<x), cup[1]|(1<<x), cup[2] }, dist+1, 0 } );\n    else\n      que.push( { { cup[0]|(1<<y), cup[1]^(1<<y), cup[2] }, dist+1, 0 } );\n  }\n\n  if( prv != 1 )\n  {\n    if( y > z )\n      que.push( { { cup[0], cup[1]^(1<<y), cup[2]|(1<<y) }, dist+1, 1 } );\n    else\n      que.push( { { cup[0], cup[1]|(1<<z), cup[2]^(1<<z) }, dist+1, 1 } );\n  }\n\n  return;\n}\n\nint main()\n{\n  while( std::cin >> n >> m, n|m )\n  {\n    std::queue<State> que;\n\n    rep( i, 3 ) \n      cup[i] = 0;\n\n    rep( i, 3 )\n    {\n      int lc;\n      std::cin >> lc;\n      int x;\n      rep( j, lc )\n        std::cin >> x, cup[i] |= 1<<(x-1);\n    }\n\n    //printf( \"(%d,%d,%d)\\n\", cup[0], cup[1], cup[2] );\n\n    if( cup[0] == (1<<n)-1 || cup[2] == (1<<n)-1 )\n    {\n      printf( \"%d\\n\", 0 );\n\n      goto end;\n    }\n\n    quePush( que, cup, 0, -1 );\n\n    while( !que.empty() )\n    {\n      State st = que.front(); que.pop();\n\n      if( st.dist > m )\n        continue;\n\n      //printf( \"(%d,%d,%d,%d)\\n\", st.mask[0], st.mask[1], st.mask[2], st.dist );\n\n      if( st.mask[0] == (1<<n)-1 || st.mask[2] == (1<<n)-1 )\n      {\n        printf( \"%d\\n\", st.dist );\n\n        goto end;\n      }\n\n      quePush( que, st.mask, st.dist, st.prv );\n    }\n\n    puts(\"-1\");\n\nend:;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint main(){\n    //sanbeki\n    int sanbeki[16];\n    int i;\n    sanbeki[0]=1;\n    for(i=1; i<=15; i++){\n        sanbeki[i] = 3*sanbeki[i-1];\n    }\n    //input nm\n    int n,m;\n    cin >> n >> m;\n\n    while(n!=0){\n        //input start\n        int start=0;\n        int kosu, bangou;\n        cin >> kosu;\n        for(i=0; i<kosu; i++){\n            cin >> bangou;\n            start += 0*sanbeki[bangou-1];\n        }\n        cin >> kosu;\n        for(i=0; i<kosu; i++){\n            cin >> bangou;\n            start += 1*sanbeki[bangou-1];\n        }\n        cin >> kosu;\n        for(i=0; i<kosu; i++){\n            cin >> bangou;\n            start += 2*sanbeki[bangou-1];\n        }\n        //bfs\n        int val[sanbeki[n]];\n        for(i=0; i<sanbeki[n]; i++){\n            val[i]=-1;\n        }\n        queue<int> que;\n        que.push(start);\n        val[start]=0;\n        int height[3];\n        while(!que.empty()){\n            int p=que.front();\n            que.pop();\n            height[0]=0;\n            height[1]=0;\n            height[2]=0;\n            int p_sub=p;\n            for(i=0; i<n; i++){\n                height[p_sub%3]=i+1;\n                p_sub = p_sub/3;\n            }\n            if(height[0]>height[1]){\n                if(val[p+sanbeki[height[0]-1]]<0){\n                    val[p+sanbeki[height[0]-1]]=val[p]+1;\n                    que.push(p+sanbeki[height[0]-1]);\n                }\n            }else if(height[0]<height[1]){\n                if(val[p-sanbeki[height[1]-1]]<0){\n                    val[p-sanbeki[height[1]-1]]=val[p]+1;\n                    que.push(p-sanbeki[height[1]-1]);\n                }\n            }\n            if(height[1]>height[2]){\n                if(val[p+sanbeki[height[1]-1]]<0){\n                    val[p+sanbeki[height[1]-1]]=val[p]+1;\n                    que.push(p+sanbeki[height[1]-1]);\n                }\n            }else if(height[1]<height[2]){\n                if(val[p-sanbeki[height[2]-1]]<0){\n                    val[p-sanbeki[height[2]-1]]=val[p]+1;\n                    que.push(p-sanbeki[height[2]-1]);\n                }\n            }\n        }\n        //judge\n        int sanbeki_max=0;\n        for(i=0; i<n; i++){\n            sanbeki_max += 2*sanbeki[i];\n        }\n        if((val[0]>=0&&val[0]<=m)||(val[sanbeki_max]>=0&&val[sanbeki_max]<=m)){\n            if((val[0]>=0&&val[0]<=m)&&(val[sanbeki_max]>=0&&val[sanbeki_max]<=m)){\n                cout << min(val[0],val[sanbeki_max]) << endl;\n            }else if((val[0]>=0&&val[0]<=m)){\n                cout << val[0] << endl;\n            }else{\n                cout << val[sanbeki_max] << endl;\n            }\n        }else{\n            cout << -1 << endl;\n        }\n\n        //input nm\n        cin >> n >> m;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(A) (A).begin(), (A).end()\n#define ll long long\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\n\nconst ll mod = 1e9 + 7;\nconst ll INF = -1 * ((1LL << 63) + 1);\nconst int inf = -1 * ((1 << 31) + 1);\n\n\nint n,m,x,t,ans,y;\nint memo3[20];\n\nint msb(int state,int bit){\n    for(int i=n-1;i>=0;i--){\n        if( (state/(int)pow(3,i)) % 3 == bit){\n            return i;\n        }\n    }\n    return -1;\n}\n\nint pow(int x,int y){\n    if(y==0)return 1;\n    if(memo3[y])return memo3[y];\n    return memo3[y] = std::pow(3,y);\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    int size = pow(3,15);\n    while(true){\n        cin >> n >> m;\n        if(n==0 && m == 0)break;\n        ans = 0;\n        queue<int> q;\n        vector<int> d(size);\n        vector< vector<int> > b(3);\n        int mask = 0;\n        for(int i=0;i<3;i++){\n            cin >> x;\n            for(int j=0;j<x;j++){\n                cin >> t;\n                t--;\n                b[i].push_back(t);\n                mask += i * pow(3,t);\n            }\n        }\n        q.push(mask);\n        d[mask] = 1;\n        while(!q.empty()){\n            int c = q.front();q.pop();\n            if(c== 0 || c == pow(3,n)-1)break;\n            // 現在の状態から4通りの遷移を考える\n            if(d[c]-1 > m)continue;\n            // 0 -> 1 のとき\n            int now = c;\n            x = msb(now,0);\n            y = msb(now,1);\n            now += 1 * pow(3,x);\n            if(x>y && d[now] == 0){\n                q.push(now);\n                d[now] = d[c] + 1;\n            }\n            // 1 -> 0 のとき\n            now = c;\n            x = msb(now,1);\n            y = msb(now,0);\n            now -= 1* pow(3,x);\n            if(x>y && d[now] == 0){\n                q.push(now);\n                d[now] = d[c] + 1;\n            }\n            // 1 -> 2 のとき\n            now = c;\n            x = msb(now,1);\n            y = msb(now,2);\n            now += 1 * pow(3,x);\n            if(x>y && d[now] == 0){\n                q.push(now);\n                d[now] = d[c] + 1;\n            }\n            // 2 -> 1 のとき\n            now = c;\n            x = msb(now,2);\n            y = msb(now,1);\n            now -= pow(3,x);\n            if(x>y && d[now] == 0){\n                q.push(now);\n                d[now] = d[c] + 1;\n            }\n        }\n        ans = max(d[0],d[pow(3,n)-1]) - 1;\n        cout << (ans<=m?ans:-1) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#if 0\n#define int long long\n#define MAX LLONG_MAX\n#define MIN LLONG_MIN\n#define stoi stoll\n#else\n#define MAX INT_MAX\n#define MIN INT_MIN\n#endif\n#define ALL(obj) (obj).begin(), (obj).end()\n#define fi first\n#define se second\nconst int NIL = -1;\nconst int MOD = 1000000007;\n#define REP(i,n) for (int i=0; i < (n); ++i)\n#define FOR(i,a,b) for (int i=(a); i < (b); ++i)\nusing namespace std;\n\nint pow(int x, int n) {int res=1; while(n){if(n&1)res*=x;x*=x;n>>=1;} return res;}\nint get_gcd(int a, int b){while(1){if (a < b) swap(a, b); if (b == 0) return a; a %= b;}}\nint get_lcm(int a, int b){return a * b / get_gcd(a, b);}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\n//-------------------------テンプレここまで-------------------------//\n\nint cost[14348907]; // 3^15\n\nint get_state(array<int, 3>& t) {\n  int state = 0;\n  REP(i, 15) {\n    REP(j, 3) {\n      if (t[j]&(1<<i)) {\n        state += pow(3,i)*j;\n      }\n    }\n  }\n  return state;\n}\n\nint get_cost(array<int, 3>& t) {\n  return cost[get_state(t)];\n}\n\nvoid set_cost(array<int, 3> t, int c) {\n  cost[get_state(t)] = c;\n}\n\nint get_highest_bit(int a) {\n  int ret = 0;\n  REP(i, 15) {\n    ret = (a & (1<<i)) ? a & (1<<i) : ret;\n  }\n  return ret;\n}\n\n//BFS\nint bfs(array<int, 3> t, int n){\n  fill_n(cost, sizeof(cost)/sizeof(int), NIL);\n  set_cost(t, 0);\n\n  deque<array<int, 3>> q;\n  q.push_back(t);\n  int goal = (1<<n) - 1;\n\n  while(!q.empty()) {\n\n    auto now = q.front(); q.pop_front();\n    if (now[0] == goal || now[2] == goal) {\n      return get_cost(now);\n    }\n\n    vector<pair<int, int>> c; // 次にqに入れる候補\n    //A->B\n    if(now[0]>now[1]) {\n      c.push_back(make_pair(0,1));\n    }\n    // B->C\n    if(now[1]>now[2]) {\n      c.push_back(make_pair(1,2));\n    }\n    // C->B\n    if(now[2]>now[1]) {\n      c.push_back(make_pair(2,1));\n    }\n    // B->A\n    if(now[1]>now[0]) {\n      c.push_back(make_pair(1,0));\n    }\n\n    for(pair<int,int>& p: c) {\n      auto next = now;\n      next[p.fi] &= ~get_highest_bit(now[p.fi]);\n      next[p.se] |= get_highest_bit(now[p.fi]);\n\n      if(get_cost(next) == NIL) {\n        set_cost(next, get_cost(now)+1);\n        q.push_back(next);\n      }\n    }\n  }\n  return NIL;\n}\n\nsigned main () {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  while(1) {\n    int n, m;\n    cin >> n >> m;\n    if (!n && !m) break;\n\n    //それぞれビットで、i+1番目のビットは大きさiのコップの存在を示す\n    array<int, 3> t;\n    fill_n(t.begin(), 3, 0);\n    REP(i, 3) {\n      int k;\n      cin >> k;\n      REP(j, k) {\n        int b;\n        cin >> b; b--; // t番目の大きさのカップ\n        t[i] |= 1<<b;\n      }\n    }\n\n    int cost = bfs(t, n);\n    if (cost != NIL && cost <= m) {\n      cout << cost << endl;\n    }\n    else {\n      cout << \"-1\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <functional>\n#include <array>\n#include <stack>\n#include <queue>\n#include <chrono>\n#include <numeric>\n#include <memory.h>\n#include <map>\n#include <math.h>\n\n\n#pragma warning(disable:4996)\n#define REP(i,n) for(int i = 0 ; i < n ; ++i)\ntypedef long long Int;\nconst double PI = 3.141592653589793238;\nconst Int INF = 999999999999;\nusing namespace std;\n\nint dx[4] = { 0, -1, 0, 1 };\nint dy[4] = { 1, 0, -1, 0 };\n\nstruct state{\n\tvector<int> A, B, C;\n\tInt step;\n\tstate() :step(0){}\n};\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n&&m){\n\t\tqueue<state> que;\n\n\t\tstate s;\n\t\tREP(i,3){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tREP(j,k){\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tif (i ==0)\n\t\t\t\t\ts.A.push_back(a);\n\t\t\t\tif (i == 1)\n\t\t\t\t\ts.B.push_back(a);\n\t\t\t\tif (i == 2)\n\t\t\t\t\ts.C.push_back(a);\n\t\t\t}\n\t\t}\n\n\t\tque.push(s);\n\t\twhile (!que.empty()){\n\t\t\tstate now = que.front();\n\t\t\tque.pop();\n\n\t\t\tif ((now.B.empty() && now.C.empty()) || (now.B.empty() && now.A.empty())){\n\t\t\t\tcout << now.step << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (now.step > m){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!now.A.empty() && (now.B.empty() || (now.A.back() > now.B.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tnext.B.push_back(next.A.back());\n\t\t\t\tnext.A.pop_back();\n\t\t\t\t++next.step;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t\tif (!now.B.empty() && (now.A.empty() || (now.A.back() < now.B.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tnext.A.push_back(next.B.back());\n\t\t\t\tnext.B.pop_back();\n\t\t\t\t++next.step;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t\tif (!now.B.empty() && (now.C.empty() || (now.B.back() > now.C.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tnext.C.push_back(next.B.back());\n\t\t\t\tnext.B.pop_back();\n\t\t\t\t++next.step;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t\tif (!now.C.empty() && (now.B.empty() || (now.B.back() < now.C.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tnext.B.push_back(next.C.back());\n\t\t\t\tnext.C.pop_back();\n\t\t\t\t++next.step;\n\t\t\t\tque.push(next);\n\t\t\t}\n\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<bitset>\n#include<iomanip>\n#include<numeric>\nusing namespace std;\n\ntypedef stack<int> IntStack;\ntypedef queue<int> IntQueue;\n\nconst double pi = 3.141592653589793;\n\n\n//最大公約数\ntemplate<class T> T gcd(T a, T b)\n{\n\twhile (true)\n\t{\n\t\tT r;\n\t\tif (a%b == 0) return b;\n\t\telse\n\t\t{\n\t\t\tr = a % b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t}\n}\n//最小公倍数\ntemplate<class T> T lcm(T a, T b)\n{\n\treturn a / gcd(a, b)*b;\n}\n//文字0~9をint型0~9に変換\nint char_to_int(char c)\n{\n\tif (c == '0') return 0;\n\tif (c == '1') return 1;\n\tif (c == '2') return 2;\n\tif (c == '3') return 3;\n\tif (c == '4') return 4;\n\tif (c == '5') return 5;\n\tif (c == '6') return 6;\n\tif (c == '7') return 7;\n\tif (c == '8') return 8;\n\tif (c == '9') return 9;\n\telse return -1;\n}\n//a^b mod MODを計算\nlong long int ModPower(long long int a, long long int b, long long int MOD)\n{\n\tif (b == 0) return 1;\n\telse if (b % 2 == 0)\n\t{\n\t\tlong long int d = ModPower(a, b / 2, MOD);\n\t\treturn (d*d) % MOD;\n\t}\n\telse\n\t{\n\t\treturn (a*ModPower(a, b - 1, MOD)) % MOD;\n\t}\n}\n//nCr mod MODを計算\nlong long int ModCombi(long long int n, long long int r, long long int MOD)\n{\n\tif (n == 0 || r == 0) return 1;\n\n\tlong long int Kn = 1, Kr = 1, Knr = 1;\n\n\tlong long int temp = 1;\n\tfor (long long int i = 1; i <= n; i++)\n\t{\n\t\ttemp *= i;\n\t\ttemp %= MOD;\n\t\tif (i == n) Kn = temp;\n\t\tif (i == r) Kr = temp;\n\t\tif (i == n - r) Knr = temp;\n\t}\n\n\tlong long int x = ModPower(Kr, MOD - 2, MOD);\n\tlong long int y = ModPower(Knr, MOD - 2, MOD);\n\n\tlong long int ans;\n\tans = Kn * x;\n\tans %= MOD;\n\tans *= y;\n\tans %= MOD;\n\n\treturn ans;\n}\n//int型10進数をord桁のstring型2進数に変換する\nstring binary(int x,int ord)\n{\n\tint y;\n\tstring ans = \"\";\n\tfor (int i = 0; i < ord; i++)\n\t{\n\t\ty = x / pow(2, ord - 1 - i);\n\t\ty %= 2;\n\t\tif (y == 0) ans += \"0\";\n\t\telse ans += \"1\";\n\t}\n\n\treturn ans;\n}\n\n\n/*ここまでテンプレ*//*ここまでテンプレ*//*ここまでテンプレ*//*ここまでテンプレ*/\n\n\n\nint main()\n{\n\tint n, m;\n\tint Lnum[3], Rnum[3];\n\tint temp;\n\tint x;\n\n\twhile (true)\n\t{\n\t\tstack<int> Lcup[3], Rcup[3];\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tLcup[i].push(0);\n\t\t\tRcup[i].push(0);\n\t\t}\n\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tcin >> Lnum[i];\n\t\t\tRnum[i] = Lnum[i];\n\t\t\tfor (int j = 0; j < Lnum[i]; j++)\n\t\t\t{\n\t\t\t\tcin >> temp;\n\t\t\t\tLcup[i].push(temp);\n\t\t\t\tRcup[i].push(temp);\n\t\t\t}\n\t\t}\n\n\t\tif (Lnum[0] == n || Lnum[2] == n)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile (ans < m)\n\t\t{\n\t\t\tx = ans % 2;\n\t\t\tif (Lnum[x] > 0 && Lcup[x].top() > Lcup[x + 1].top())\n\t\t\t{\n\t\t\t\tLcup[x + 1].push(Lcup[x].top());\n\t\t\t\tLcup[x].pop();\n\t\t\t\tLnum[x]--;\n\t\t\t\tLnum[x + 1]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLcup[x].push(Lcup[x + 1].top());\n\t\t\t\tLcup[x + 1].pop();\n\t\t\t\tLnum[x]++;\n\t\t\t\tLnum[x + 1]--;\n\t\t\t}\n\n\t\t\tx = (ans + 1) % 2;\n\t\t\tif (Rnum[x]>0 && Rcup[x].top() > Rcup[x + 1].top())\n\t\t\t{\n\t\t\t\tRcup[x + 1].push(Rcup[x].top());\n\t\t\t\tRcup[x].pop();\n\t\t\t\tRnum[x]--;\n\t\t\t\tRnum[x + 1]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRcup[x].push(Rcup[x + 1].top());\n\t\t\t\tRcup[x + 1].pop();\n\t\t\t\tRnum[x]++;\n\t\t\t\tRnum[x + 1]--;\n\t\t\t}\n\n\t\t\tans++;\n\n\t\t\tif (Lnum[0] == n || Lnum[2] == n) break;\n\t\t\tif (Rnum[0] == n || Rnum[2] == n) break;\n\t\t}\n\n\t\tif (Lnum[0] == n || Lnum[2] == n\n\t\t\t|| Rnum[0] == n || Rnum[2] == n)\n\t\t\tcout << ans << endl;\n\t\telse\n\t\t\tcout << -1 << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nint n, m, k, x;\n\nint chk(vector<stack<int>> tray) {\n    int ret = 0;\n    while (1) {\n        for (int i=0; i<=1; ++i) {\n            if (tray[0].size() == n+1 || tray[2].size() == n+1) return ret;\n            int a = tray[i].top(); tray[i].pop();\n            int b = tray[i+1].top(); tray[i+1].pop();\n            if (a < b) {\n                tray[i].push(a);\n                tray[i].push(b);\n            } else {\n                tray[i+1].push(b);\n                tray[i+1].push(a);\n            }\n            ret ++;\n        }\n        if (m < ret) return 15000001;\n    }\n}\n\nint main() {\n    while (cin >> n >> m) {\n        if (!n && !m) break;\n        vector<stack<int>> tray(3);\n        for (int i=0; i<3; ++i) {\n            cin >> k;\n            tray[i].push(-1);\n            for (int j=0; j<k; ++j) {\n                cin >> x;\n                tray[i].push(x);\n            }\n        }\n        int ans = chk(tray);\n        swap(tray[0], tray[2]);\n        ans = min(ans, chk(tray));\n        cout << (ans <= m ? ans : -1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint pow3[16];\nint n, m;\n\nvoid calc_pow3()\n{\n    pow3[0] = 1;\n\n    for (int i = 1; i <= 15; ++i) {\n        pow3[i] = pow3[i - 1] * 3;\n    }\n}\n\nint solve(int n, int m)\n{\n    int c[16];\n    for (int i = 0; i < 3; ++i) {\n        int j;\n\n        cin >> j;\n\n        int temp;\n        for (int k = 0; k < j; ++k) {\n            cin >> temp;\n            \n            c[n - temp] = i;\n        }\n    }\n\n    int ans = 0;\n    int d;\n    int p = 0;\n\n    for (int i = n - 1; i >= 0; --i) {\n        d = abs(c[i] - p);\n        \n        ans += pow3[i] * d;\n        \n        if (d == 1) p = 2 - p;\n\n\n    }\n\n    int ans2;\n\n    ans2 = pow3[n] - 1 - ans;\n\n    ans = min(ans, ans2);\n\n    ans = (ans > m) ? -1: ans;\n\n    return ans;\n}\n\nint main()\n{\n    calc_pow3();\n    \n    int n, m;\n\n    while (cin >> n >> m) {\n        if (n == 0 && m == 0) break;\n\n        cout << solve(n, m) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint size[3];\nint dat[3][15];\nint val[3];\nint now[3][15];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a+b){\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint c;\n\t\t\tscanf(\"%d\",&c);\n\t\t\tsize[i]=c;\n\t\t\tfor(int j=0;j<c;j++)scanf(\"%d\",dat[i]+j);\n\t\t}\n\t\tint ret=999999999;\n\t\tif(size[0]==a||size[2]==a)ret=0;\n\t\tfor(int m=0;m<2;m++){\n\t\t\tint last=m;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tval[i]=size[i];\n\t\t\t\tfor(int j=0;j<size[i];j++)now[i][j]=dat[i][j];\n\t\t\t}\n\t\t\tint k=0;\n\t\t\twhile(k<b&&val[0]!=a&&val[2]!=a){\n\t\t\t\tif(val[last+1]&&val[last]==0||now[last][val[last]-1]<now[last+1][val[last+1]-1]){\n\t\t\t\t\tnow[last][val[last]++]=now[last+1][--val[last+1]];\n\t\t\t\t}else{\n\t\t\t\t\tnow[last+1][val[last+1]++]=now[last][--val[last]];\n\t\t\t\t}\n\t\t\t\tlast=!last;\n\t\t\t\tk++;\n\t\t//\t\tprintf(\"%d %d %d\\n\",val[0],val[1],val[2]);\n\t\t\t}\n\t\t\tif(val[0]==a||val[2]==a)ret=min(ret,k);\n\t\t}\n\t\tif(ret==999999999)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\nenum class MovePos\n{\n\tMoveLeftToCenter,\n\tMoveRightToCenter,\n\tMoveCenterToLeft,\n\tMoveCenterToRight\n};\n\nclass Tray\n{\npublic:\n\tstack<int> t[3];\n\tinline bool isCompleted()\n\t{\n\t\tif (t[0].empty() && t[1].empty()) return true;\n\t\tif (t[1].empty() && t[2].empty()) return true;\n\t\treturn false;\n\t}\n\tinline bool canMoveLeftToCenter()\n\t{\n\t\tif (t[0].empty()) return false;\n\t\tif (t[1].empty()) return true;\n\t\tif (t[0].top() > t[1].top()) return true;\n\t\treturn false;\n\t}\n\tinline bool canMoveRightToCenter()\n\t{\n\t\tif (t[2].empty()) return false;\n\t\tif (t[1].empty()) return true;\n\t\tif (t[2].top() > t[1].top()) return true;\n\t\treturn false;\n\t}\n\tinline bool canMoveCenterToLeft()\n\t{\n\t\tif (t[1].empty()) return false;\n\t\tif (t[0].empty()) return true;\n\t\tif (t[1].top() > t[0].top()) return true;\n\t\treturn false;\n\t}\n\tinline bool canMoveCenterToRight()\n\t{\n\t\tif (t[1].empty()) return false;\n\t\tif (t[2].empty()) return true;\n\t\tif (t[1].top() > t[2].top()) return true;\n\t\treturn false;\n\t}\n\tinline void MoveLeftToCenter()\n\t{\n\t\tint top = t[0].top();\n\t\tt[0].pop();\n\t\tt[1].push(top);\n\t}\n\tinline void MoveRightToCenter()\n\t{\n\t\tint top = t[2].top();\n\t\tt[2].pop();\n\t\tt[1].push(top);\n\t}\n\tinline void MoveCenterToLeft()\n\t{\n\t\tint top = t[1].top();\n\t\tt[1].pop();\n\t\tt[0].push(top);\n\t}\n\tinline void MoveCenterToRight()\n\t{\n\t\tint top = t[1].top();\n\t\tt[1].pop();\n\t\tt[2].push(top);\n\t}\n};\n\nint calc(Tray t, MovePos previousMovePos, int m)\n{\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tif (t.isCompleted()) return i;\n\t\tif (t.canMoveLeftToCenter() && previousMovePos != MovePos::MoveCenterToLeft)\n\t\t{\n\t\t\tt.MoveLeftToCenter();\n\t\t\tpreviousMovePos = MovePos::MoveLeftToCenter;\n\t\t}\n\t\telse if (t.canMoveRightToCenter() && previousMovePos != MovePos::MoveCenterToRight)\n\t\t{\n\t\t\tt.MoveRightToCenter();\n\t\t\tpreviousMovePos = MovePos::MoveRightToCenter;\n\t\t}\n\t\telse if (t.canMoveCenterToLeft() && previousMovePos != MovePos::MoveLeftToCenter)\n\t\t{\n\t\t\tt.MoveCenterToLeft();\n\t\t\tpreviousMovePos = MovePos::MoveCenterToLeft;\n\t\t}\n\t\telse if (t.canMoveCenterToRight() && previousMovePos != MovePos::MoveRightToCenter)\n\t\t{\n\t\t\tt.MoveCenterToRight();\n\t\t\tpreviousMovePos = MovePos::MoveCenterToRight;\n\t\t}\n\t\tif (i > 1251598) return 99999999;\n\t}\n\treturn 99999999;\n}\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n + m)\n\t{\n\t\tTray tray;\n\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tint a, b;\n\t\t\tcin >> a;\n\t\t\tfor (int j = 0; j < a; j++)\n\t\t\t{\n\t\t\t\tcin >> b;\n\t\t\t\ttray.t[i].push(b);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 99999999;\n\t\tif (tray.canMoveCenterToLeft())\n\t\t{\n\t\t\tTray t = tray;\n\t\t\tt.MoveCenterToLeft();\n\t\t\tans = min(ans, calc(t, MovePos::MoveCenterToLeft, m));\n\t\t}\n\t\tif (tray.canMoveCenterToRight())\n\t\t{\n\t\t\tTray t = tray;\n\t\t\tt.MoveCenterToRight();\n\t\t\tans = min(ans, calc(t, MovePos::MoveCenterToRight, m));\n\t\t}\n\t\tif (tray.canMoveLeftToCenter())\n\t\t{\n\t\t\tTray t = tray;\n\t\t\tt.MoveLeftToCenter();\n\t\t\tans = min(ans, calc(t, MovePos::MoveLeftToCenter, m));\n\t\t}\n\t\tif (tray.canMoveRightToCenter())\n\t\t{\n\t\t\tTray t = tray;\n\t\t\tt.MoveRightToCenter();\n\t\t\tans = min(ans, calc(t, MovePos::MoveRightToCenter, m));\n\t\t}\n\t\tif (ans == 99999999) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n\nint n, m, cnt, a[16], b[16];\nbool flag;\n\nvoid move(int num, int dest, int* a);\n\nint main() {\n\t\n\twhile (1) {\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0)break;\n\n\t\tint numt, tmp;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tcin >> numt;\n\t\t\tfor (int j = 0; j < numt; j++) {\n\t\t\t\tcin >> tmp;\n\t\t\t\ta[tmp] = i;\n\t\t\t\tb[tmp] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans1, ans2;\n\n\t\tcnt = 0;\n\t\tflag = true;\n\t\tfor (int num = 1; num <= n; num++) {\n\t\t\tmove(num, 2, a);\n\t\t}\n\t\tif (flag == true) {\n\t\t\tans1 = cnt;\n\t\t} else {\n\t\t\tans1 = -1;\n\t\t}\n\n\t\tcnt = 0;\n\t\tflag = true;\n\t\tfor (int num = 1; num <= n; num++) {\n\t\t\tmove(num, 0, b);\n\t\t}\n\t\tif (flag == true) {\n\t\t\tans2 = cnt;\n\t\t} else {\n\t\t\tans2 = -1;\n\t\t}\n\n\n\t\tint ans;\n\t\tif (ans1 == -1) {\n\t\t\tans = ans2;\n\t\t} else if(ans2 == -1){\n\t\t\tans = ans1;\n\t\t} else {\n\t\t\tans = min(ans1, ans2);\n\t\t}\n\t\tcout << ans1 << \" \" << ans2 << endl;\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn 0;\n}\n\nvoid move(int num, int dest, int* a) {\n\t\n\tif (cnt > m || flag == false) {\n\t\tflag = false;\n\t\treturn;\n\t}\n\n\tint dist = abs(dest - a[num]);\n\tif (dist == 0) {\n\t\treturn;\n\t} else if (dist == 1) {\n\t\tif (num == n) {\n\t\t\tcnt += 1;\n\t\t\ta[num] = dest;\n\t\t} else {\n\t\t\tint i = 1;\n\t\t\twhile (num + i <= n) {\n\t\t\t\tmove(num + i, 3 - dest - a[num], a);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tcnt += 1;\n\t\t\ta[num] = dest;\n\t\t}\n\t} else if (dist == 2) {\n\t\tif (num == n) {\n\t\t\tcnt += 2;\n\t\t\ta[num] = dest;\n\t\t} else {\n\t\t\tmove(num, 1, a);\n\t\t\tmove(num, dest, a);\n\t\t}\n\t}\n\n\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\ntypedef pair <int,P> PP;\ntypedef pair <int,PP> PPP;\n\nstatic const double eps = 1e-8;\n\nint bfs(int m,vector<int>& sets, map<vector<int>,int>& visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,sets));\n\tvisited[sets] = 0;\n\n\tvector<int> sets;\n\tvector<int> tmp;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\tif(visited.find(tmp) == visited.end()){\n\t\t\t\t\tvisited[tmp] = cost + 1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tif(visited.find(tmp) == visited.end()){\n\t\t\t\t\tvisited[tmp] = cost + 1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tmap<vector<int>,int> visited;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,sets,visited));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//E? Nanndatte?\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint rec(vector<int>state[3],int a,int b)\n{\n\tvector<int>_cur[3];\n\tfor(int i=0;i<3;i++)\n\t{\n\t\t_cur[i]=state[i];\n\t}\n\tif(state[0].size()==a || state[2].size()==a) return 0;\n\tint s[3];\n\tfor(int i=0;i<3;i++) s[i]=_cur[i].size();\n\tint val=INF;\n\tif(s[0])\n\t{\n\t\tif(s[1] && _cur[1][s[1]-1]<_cur[0][s[0]-1])\n\t\t{\n\t\t\t_cur[1].pb(_cur[0][s[0]-1]);\n\t\t\t_cur[0].pop_back();\n\t\t\ts[1]++;\n\t\t\ts[0]--;\n\t\t\tval=min(val,rec(_cur,a,b-1));\n\t\t}\n\t\telse if(s[1])\n\t\t{\n\t\t\t_cur[0].pb(_cur[1][s[1]-1]);\n\t\t\t_cur[1].pop_back();\n\t\t\ts[0]++;\n\t\t\ts[1]--;\n\t\t\tval=min(val,rec(_cur,a,b));\n\t\t}\n\t}\n\tif(s[2])\n\t{\n\t\tif(s[1] && _cur[1][s[1]-1]<_cur[2][s[2]-1])\n\t\t{\n\t\t\t_cur[1].pb(_cur[2][s[2]-1]);\n\t\t\t_cur[2].pop_back();\n\t\t\ts[1]++;\n\t\t\ts[2]--;\n\t\t\tval=min(val,rec(_cur,a,b));\n\t\t}\n\t\telse if(s[1])\n\t\t{\n\t\t\t_cur[2].pb(_cur[1][s[1]-1]);\n\t\t\t_cur[1].pop_back();\n\t\t\ts[2]++;\n\t\t\ts[1]--;\n\t\t\tval=min(val,rec(_cur,a,b));\n\t\t}\n\t}\n\treturn val+1;\n}\nint main(){\n\tint n,k;\n\twhile(1)\n\t{\n\t\tcin >> n >> k;\n\t\tif(n+k==0) return 0;\n\t\tvector<int>cur[3];\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tint f;\n\t\t\tcin >> f;\n\t\t\tcur[i].resize(0);\n\t\t\tfor(int j=0;j<f;j++)\n\t\t\t{\n\t\t\t\tint d;\n\t\t\t\tcin >>d;\n\t\t\t\tcur[i].pb(d);\n\t\t\t}\n\t\t}\n\t\tint ans = rec(cur,n,k);\n\t\tif(ans>k) ans=-1;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint p[15], n, k, a1, a2, a3, a4, a5, power[16], dp[15000000];\nqueue<int>Q;\nint main() {\n\twhile (true) {\n\t\tcin >> n >> k; power[0] = 1; for (int i = 1; i < 16; i++)power[i] = power[i - 1] * 3;\n\t\tif (n == 0 && k == 0)break;\n\t\tcin >> a1; for (int i = 0; i < a1; i++) { cin >> a4; p[a4 - 1] = 0; }\n\t\tcin >> a2; for (int i = 0; i < a2; i++) { cin >> a4; p[a4 - 1] = 1; }\n\t\tcin >> a3; for (int i = 0; i < a3; i++) { cin >> a4; p[a4 - 1] = 2; }\n\t\tfor (int i = 0; i < n; i++) { a5 += power[i] * p[i]; }\n\t\tfor (int i = 0; i < power[n]; i++)dp[i] = 1000000000; dp[a5] = 0; Q.push(a5);\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front(); Q.pop();\n\t\t\tvector<int>b1, b2, b3;\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tint p1 = (a1 / power[i]) % 3;\n\t\t\t\tif (p1 == 0)b1.push_back(i);\n\t\t\t\tif (p1 == 1)b2.push_back(i);\n\t\t\t\tif (p1 == 2)b3.push_back(i);\n\t\t\t}\n\t\t\tif (b1.size() >= 1 && (b2.size() == 0 || b1[0] > b2[0])) {\n\t\t\t\tint F = a1 + power[b1[0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t\tif (b2.size() >= 1 && (b1.size() == 0 || b1[0] < b2[0])) {\n\t\t\t\tint F = a1 - power[b2[0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t\tif (b2.size() >= 1 && (b3.size() == 0 || b2[0] > b3[0])) {\n\t\t\t\tint F = a1 + power[b2[0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t\tif (b3.size() >= 1 && (b2.size() == 0 || b2[0] < b3[0])) {\n\t\t\t\tint F = a1 - power[b3[0]];\n\t\t\t\tif (dp[F] == 1000000000) { dp[F] = dp[a1] + 1; Q.push(F); }\n\t\t\t}\n\t\t}\n\t\tint ans = min(dp[0], dp[power[n] - 1]);\n\t\tif (ans > k)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include <stack>\nusing namespace std;\n\n\n\nint main()\n{\n\tstack<int>a,b,c;\n\twhile(1)\n\t{\n\t\t\n\t\tint count=0,n,m,check;\n\t\tscanf(\"%d %d\",&n,&m);\n\n\t\tif(n==0 && m==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\n\t\tint A,B,C,\n\t\t\tkari;\n\t\t\n\t\t/*エラー対策*/\n\t\ta.push(0);\n\t\tb.push(0);\n\t\tc.push(0);\n\n\t\tscanf(\"%d\",&A);\n\t\tfor(int i=0;i<A;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\ta.push(kari);\n\t\t}\n\n\t\tscanf(\"%d\",&B);\n\t\tfor(int i=0;i<B;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\tb.push(kari);\n\t\t}\n\t\n\t\tscanf(\"%d\",&C);\n\t\tfor(int i=0;i<C;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\tc.push(kari);\n\t\t}\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif(b.top()==0 && c.top()==0)\n\t\t\t\tbreak;\n\t\t\tif(a.top()<b.top() && a.top()<c.top()){\n\t\t\t\tkari=b.top();\n\t\t\t\ta.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b.top()<c.top() ){\n\t\t\t\tkari=c.top();\n\t\t\t\tb.push(kari);\n\t\t\t\tc.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b.top()<a.top()){\n\t\t\t\tkari=a.top();\n\t\t\t\tb.push(kari);\n\t\t\t\ta.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(c.top()<b.top() && a.top()!=b.top()-1){\n\t\t\t\tkari=b.top();\n\t\t\t\tc.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t}\n\t\t\telse{\n\t\t\t\tkari=b.top();\n\t\t\t\ta.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(count<m || count==m) printf(\"\\n%d\\n\",count);\n\t\telse printf(\"\\n%d\\n\",-1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n\nint n, m;\nint t[3];\n\nint f( int a, int b, int c )\n{\n  \tif( !a && !b ) return 0;\n\t\n\tif( c & 1 ) return f( a >> 1, b >> 1, c >> 1 );\n\tif( b & 1 ) return f( c >> 1, b >> 1, a >> 1 ) + 1 + f( ( a | b | c ) >> 1, 0, 0 );\n\tif( a & 1 ) return f( a >> 1, b >> 1, c >> 1 ) + 2 + 2 * f( ( a | b | c ) >> 1, 0, 0 );\n}       \n\nint main()\n{\n\twhile( std::cin >> n >> m, n | m ){\n\t\tmemset( t, 0, sizeof( t ) );\n\t\n\t\tfor( int i = 0; i < 3; i++ ){\n\t\t\tint a;\n\t\t\tstd::cin >> a;\n\t\t\t\n\t\t\tfor( int j = 0; j < a; j++ ){\n\t\t\t\tint b;\n\t\t\t\tstd::cin >> b;\n\t\t\t\t\n\t\t\t\tt[i] |= 1 << ( b - 1 );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = std::min( f( t[0], t[1], t[2] ), f( t[2], t[1], t[0] ) );\n\t\t\n\t\tif( ans <= m ){\n\t\t \tstd::cout << ans << std::endl;\n\t\t}\n\t\telse{\n\t\t \tstd::cout << -1 << std::endl;\n\t\t}\n\t}\n\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint n, m, cup[15];\nint ipow(int t, int p)\n{\n\tint res = 1;\n\twhile (p--)\n\t\tres *= t;\n\treturn res;\n}\nint count(bool left_base)\n{\n\tint res = 0;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tif (left_base && cup[i] == 2\n\t\t\t|| !left_base && cup[i] == 0)\n\t\t\tres += 2 * ipow(3, n-1 - i);\n\t\telse if (cup[i] == 1)\n\t\t{\n\t\t\tres += ipow(3, n-1 - i);\n\t\t\tleft_base ^= true;\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\twhile (scanf(\"%d%d\", &n, &m), n|m)\n\t{\n\t\tfor (int i = 0; i < 3; ++i)\n\t\t{\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\twhile (c--)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tcup[t-1] = i;\n\t\t\t}\n\t\t}\n\t\tint res = min(count(true), count(false));\n\t\tif (res <= m)\n\t\t\tprintf(\"%d\\n\", res);\n\t\telse\n\t\t\tputs(\"-1\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<stack>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\nint n,m;\nstruct state{\n  vector<int> st[3];\n  int co;\n  state(){\n    for(int i=0;i<3;i++){\n      while(!st[i].empty()) st[i].pop_back();\n    }\n  }\n  void print(){\n    for(int i=0;i<3;i++){\n      if(st[i].empty()){\n\tprintf(\"[%d]...empty\\n\",i);\t\n\tcontinue;\n      }\n      printf(\"[%d]...size=%d  back()=%d\\n\",i,(int)st[i].size(),st[i].back());\n    }\n    sleep(1);\n  }\n};\nmap<int,map<int,map<int,int> > > M;\nbool check(state p){\n  if(p.co>=1000000) return true;\n    int a[3]={};\n    for(int i=0;i<3;i++){\n      for(int j=0;j<(int)p.st[i].size();j++){\n\ta[i] |= (1<<p.st[i][j]); \n      }\n    }\n    if(M[a[0]][a[1]][a[2]]!=0) return false;\n    M[a[0]][a[1]][a[2]]=1;\n    return true;\n}\nint solve(state s){\n  queue<state> q;\n  while(!q.empty()) q.pop();\n  q.push(s);\n  check(s);\n  while(!q.empty()){\n    state p = q.front(); q.pop();\n    //    p.print();\n    int c=p.co;\n    if(c>m) break;\n    if((int)p.st[0].size()==n || (int)p.st[2].size()==n) return c;\n    p.co++;\n    state tmp = p;\n    if( !p.st[0].empty() && p.st[1].empty() ){\n      goto change1;\n    }else if( p.st[0].empty() && !p.st[1].empty()){\n      goto change2;\n    }\n    if(!p.st[0].empty() && !p.st[1].empty()){\n      if(p.st[0].back() > p.st[1].back()){\n      change1:\n\ttmp.st[1].push_back(tmp.st[0].back());\n\ttmp.st[0].pop_back();\n\tif(check(tmp))\n\t  q.push(tmp);\n\ttmp = p;\n      } else {\n      change2:\n\ttmp.st[0].push_back(tmp.st[1].back());\n\ttmp.st[1].pop_back();\n\tif(check(tmp))\n\t  q.push(tmp);\n\ttmp = p;\n      }\n    }\n\n    if( !p.st[1].empty() && p.st[2].empty() ){\n      goto change3;\n    }else if( p.st[1].empty() && !p.st[2].empty()){\n      goto change4;\n    }    \n    if( !p.st[1].empty() && !p.st[2].empty() ){\n      if(p.st[1].back() > p.st[2].back()){\n      change3:\n\ttmp.st[2].push_back(tmp.st[1].back());\n\ttmp.st[1].pop_back();\n\tif(check(tmp))\n\t  q.push(tmp);\n\ttmp = p;\n      } else {\n      change4:\n\ttmp.st[1].push_back(tmp.st[2].back());\n\ttmp.st[2].pop_back();\n\tif(check(tmp))\n\t  q.push(tmp);\n\ttmp = p;\n      }\n    }\n\n  }\n  return -1;\n}\nmain(){\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    if(!n && !m)break;\n    state s;\n    for(int i=0;i<3;i++){\n      int p;\n      scanf(\"%d\",&p);\n      for(int j=0;j<p;j++){\n\tint e;\n\tscanf(\"%d\",&e);\n\ts.st[i].push_back(e);\n      }\n    }\n  //  s.print();\n    s.co=0;\n    printf(\"%d\\n\",solve(s));\n    M.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// {{{\n// vim:filetype=cpp foldmethod=marker foldmarker={{{,}}}\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define ALL(A)\t\t(A).begin(),(A).end()\n#define DUMP(A)    cout<<#A<<\"=\"<<(A)<< endl\n#define SIZE(A)    (int)((A).size())\n#define MP  make_pair\n#define PB  push_back\nusing namespace std;\ntypedef long long ll;\n\nint vx[]={1,0,-1,0},vy[]={0,1,0,-1};\n// }}}\n\nint main(){\n    int n,m;\n    for(;;){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0) break;\n        stack<int> sts[3],temp[3];\n        for(int i=0;i<3;i++){\n            int p,num;\n            scanf(\"%d\",&p);\n            for(int j=0;j<p;j++){\n                scanf(\"%d\",&num);\n                sts[i].push(num);\n            }\n            temp[i]=sts[i];\n        }\n        bool isle=true;\n        if(sts[0].size()==n || sts[2].size()==n){\n            printf(\"%d\\n\",0);\n            goto LABEL;\n        }\n        for(int i=0;i<m;i++){\n            if(isle){\n                if(sts[0].empty() || (!sts[1].empty() && sts[0].top()<sts[1].top())){\n                    sts[0].push(sts[1].top());\n                    sts[1].pop();\n                }else{\n                    sts[1].push(sts[0].top());\n                    sts[0].pop();\n                }\n            }else{\n                if(sts[1].empty() || (!sts[2].empty() && sts[1].top()<sts[2].top())){\n                    sts[1].push(sts[2].top());\n                    sts[2].pop();\n                }else{\n                    sts[2].push(sts[1].top());\n                    sts[1].pop();\n                }\n            }\n            isle=!isle;\n            if(sts[0].size()==n || sts[2].size()==n){\n                printf(\"%d\\n\",i+1);\n                goto LABEL;\n            }\n        }\n        for(int i=0;i<3;i++){\n            sts[i]=temp[i];\n        }\n        isle=false;\n        for(int i=0;i<m;i++){\n            if(isle){\n                if(sts[0].empty() || (!sts[1].empty() && sts[0].top()<sts[1].top())){\n                    sts[0].push(sts[1].top());\n                    sts[1].pop();\n                }else{\n                    sts[1].push(sts[0].top());\n                    sts[0].pop();\n                }\n            }else{\n                if(sts[1].empty() || (!sts[2].empty() && sts[1].top()<sts[2].top())){\n                    sts[1].push(sts[2].top());\n                    sts[2].pop();\n                }else{\n                    sts[2].push(sts[1].top());\n                    sts[1].pop();\n                }\n            }\n            if(sts[0].size()==n || sts[2].size()==n){\n                printf(\"%d\\n\",i+1);\n                goto LABEL;\n            }\n            isle=!isle;\n        }\n        printf(\"%d\\n\",-1);\n\nLABEL:  ;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,m;\nint cup[3][16]={0},cupn[3];\nint ans=1000000000;\nvoid hanoi(int nowm,int cmd){\n\n    /*\n    printf(\"[%d][%d][%d]\\n\",cupn[0],cupn[1],cupn[2]);\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            printf(\"%d\",cup[i][j]);\n        }\n        puts(\"\");\n    }\n    */\n\n\n    if(m<nowm)\n        goto P;\n    else if(cupn[0]==n||cupn[2]==n){\n        ans=min(ans,nowm);\n    }\n    if(cmd!=1&&cmd!=2&&cupn[0]!=0){\n        if(cup[0][cupn[0]-1]>cup[1][cupn[1]-1]){\n            cup[1][cupn[1]]=cup[0][cupn[0]-1],cup[0][cupn[0]-1]=0;\n            cupn[0]--,cupn[1]++;\n            hanoi(nowm+1,1);\n            cup[0][cupn[0]]=cup[1][cupn[1]-1],cup[1][cupn[1]-1]=0;\n            cupn[1]--,cupn[0]++;\n        }\n    }\n    if(cmd!=1&&cmd!=2&&cupn[1]!=0){\n        if(cup[0][cupn[0]-1]<cup[1][cupn[1]-1]){\n            cup[0][cupn[0]]=cup[1][cupn[1]-1],cup[1][cupn[1]-1]=0;\n            cupn[1]--,cupn[0]++;\n            hanoi(nowm+1,2);\n            cup[1][cupn[1]]=cup[0][cupn[0]-1],cup[0][cupn[0]-1]=0;\n            cupn[0]--,cupn[1]++;\n        }\n    }\n    if(cmd!=3&&cmd!=4&&cupn[1]!=0){\n        if(cup[1][cupn[1]-1]>cup[2][cupn[2]-1]){\n            cup[2][cupn[2]]=cup[1][cupn[1]-1],cup[1][cupn[1]-1]=0;\n            cupn[1]--,cupn[2]++;\n            hanoi(nowm+1,3);\n            cup[1][cupn[1]]=cup[2][cupn[2]-1],cup[2][cupn[2]-1]=0;\n            cupn[1]++,cupn[2]--;\n        }\n    }\n    if(cmd!=3&&cmd!=4&&cupn[2]!=0){\n        if(cup[1][cupn[1]-1]<cup[2][cupn[2]-1]){\n            cup[1][cupn[1]]=cup[2][cupn[2]-1],cup[2][cupn[2]-1]=0;\n            cupn[1]++,cupn[2]--;\n            hanoi(nowm+1,4);\n            cup[2][cupn[2]]=cup[1][cupn[1]-1],cup[1][cupn[1]-1]=0;\n            cupn[1]--,cupn[2]++;\n        }\n    }\nP:\n    printf(\"\");\n\n}\nint main(){\n    while(1){\n        cup[3][15]={0};\n        ans=1000000000;\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0)\n            break;\n        for(int i=0;i<3;i++){\n            scanf(\"%d\",&cupn[i]);\n            for(int j=0;j<cupn[i];j++)\n                scanf(\"%d\",&cup[i][j]);\n        }\n        hanoi(0,0);\n        if(ans==1000000000)\n            ans=-1;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b) for(int i=(a); i<(b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1L << (x))\nusing ll = long long;\nusing namespace std;\n\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\n \ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n    return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\n\n\nclass state {\nprivate:\n    static int st_pow(int i) {\n        static unordered_map<int, int> pow; // memo\n        if (pow[i]) return pow[i];\n\n        if (i == 0) {\n            return pow[i] = 1;\n        } else {\n            return pow[i] = n * st_pow(i - 1);\n        }\n    }\npublic:\n    static constexpr int n = 3;\n\n    array<deque<int>, n> trays;\n\n    vector<int> get_neighbor() {\n        vector<int> ret;\n\n        REP(i, n) {\n            if (trays[i].empty()) continue;\n\n            if (i != 0) { // not left side\n                if (trays[i-1].empty() || trays[i-1].back() < trays[i].back()) {\n                    state n_st = *this;\n                    n_st.trays[i-1].push_back(n_st.trays[i].back());\n                    n_st.trays[i].pop_back();\n                    ret.push_back(encode(n_st));\n                }\n            }\n\n            if (i != n-1) { // not right side\n                if (trays[i+1].empty() || trays[i+1].back() < trays[i].back()) {\n                    state n_st = *this;\n                    n_st.trays[i+1].push_back(n_st.trays[i].back());\n                    n_st.trays[i].pop_back();\n                    ret.push_back(encode(n_st));\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    void print() const { // for debug\n        cout << \"================\" << endl;\n        REP(i, n) {\n            cout << \"cup: \" << i + 1 << endl;\n            for (int cup : trays[i]) {\n                cout << cup << \" \";\n            }\n            cout << endl;\n        }\n    }\n\n    static int encode(const state& st) { // state => int\n        int ret = 0;\n\n        REP(i, n) {\n            for (int cup : st.trays[i]) {\n                ret += st_pow(cup) * i;\n            }\n        }\n        \n        return ret;\n    }\n\n    static state decode(int cups, int num) { // int => state\n        state st;\n\n        for (int i = 0; i < cups; i++) {\n            st.trays[num % n].push_back(i);\n            num /= n;\n        }\n\n        return st;\n    }\n\n    static bool is_moderate(const int cups, const state& st) {\n        return  st.trays[0].size() == cups || st.trays[n-1].size() == cups; \n    }\n\n    static int solve(const int cups, const int max, const state& st) {\n        queue<int> q;\n        vector<int> score(st_pow(cups), -1);\n\n        int e_st = encode(st);\n        q.push(e_st);\n        score[e_st] = 0;\n\n        while (!q.empty()) { // bfs\n            int e_now = q.front(); q.pop();\n            state now = decode(cups, e_now);\n\n            if (score[e_now] == max) continue;\n\n            if (is_moderate(cups, now)) { // return ans\n                return score[e_now];\n            }\n\n            for (const int e_neighbor : now.get_neighbor()) {\n                if (score[e_neighbor] == -1) {\n                    q.push(e_neighbor);\n                    score[e_neighbor] = score[e_now] + 1;\n                }\n            }\n        }\n\n        return -1; // not found\n    }\n};\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n && m) {\n        state st;\n        REP(i, state::n) {\n            int c; cin >> c;\n            REP(j, c) {\n                int num; cin >> num;\n                --num;\n                st.trays[i].push_back(num);\n            }\n        }\n        cout << state::solve(n, m, st) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nusing M_BOOL = bool;\n#define M_TRUE (true)\n#define M_FALSE (false)\n#define DIVISOR (1000000007)\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = M_TRUE;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    M_BOOL bRead = M_FALSE;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = M_TRUE;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n#define     MAX_NUM_CUPS    (15)\n\ntypedef struct {\n    BYTE    abyPos[MAX_NUM_CUPS];\n    DWORD   dwDepth;\n} CUP_STATE;\n\nstatic bool s_abIsVisited[15000000];\n\nstatic DWORD getIdx(CUP_STATE *pstState, DWORD dwCupNum)\n{\n    DWORD dwRetVal = 0;\n    DWORD dwMultiplier = 1;\n    for (DWORD dwIdx = 0; dwIdx < dwCupNum; dwIdx++) {\n        dwRetVal += pstState->abyPos[dwIdx] * dwMultiplier;\n        dwMultiplier *= 3;\n    }\n    return dwRetVal;\n}\n\nstatic CUP_STATE s_stGoalState1;\nstatic CUP_STATE s_stGoalState2;\n\nstatic bool detectGoal(CUP_STATE *pstState)\n{\n    if (0 == memcmp(&s_stGoalState1.abyPos, pstState->abyPos, sizeof(pstState->abyPos))) {\n        return true;\n    }\n    if (0 == memcmp(&s_stGoalState2.abyPos, pstState->abyPos, sizeof(pstState->abyPos))) {\n        return true;\n    }\n    return false;\n}\n\n\n/**\n *  次の状態遷移\n */\nstatic void visitNext(\n    queue<CUP_STATE> &queSearch, \n    const CUP_STATE *pstCurState,\n    DWORD dwMoveCup,\n    DWORD dwNextPos,\n    DWORD dwCupNum)\n{\n    CUP_STATE stNextState = *pstCurState;\n    stNextState.abyPos[dwMoveCup] = dwNextPos;          \n    stNextState.dwDepth = pstCurState->dwDepth + 1;     \n    SDWORD lNextIdx = getIdx(&stNextState, dwCupNum);\n    if (!s_abIsVisited[lNextIdx]) {\n        s_abIsVisited[lNextIdx] = true;\n        queSearch.push(stNextState);                \n    }\n}\n\n\nstatic SDWORD solveBfs(\n    CUP_STATE *pstStartState,\n    DWORD dwCupNum,\n    SDWORD lIterMax)\n{\n    queue<CUP_STATE> queSearch;\n    memset(s_abIsVisited, 0, sizeof(s_abIsVisited));\n\n    s_abIsVisited[getIdx(pstStartState, dwCupNum)] = true;\n    queSearch.push(*pstStartState);\n\n    while(0 < queSearch.size()) {\n        auto state = queSearch.front();\n        queSearch.pop();\n\n        if (lIterMax < state.dwDepth) {\n            return -1;\n        }\n        if (detectGoal(&state)) {\n            return state.dwDepth;\n        }\n\n        DWORD dwTop_A = 0, dwTop_B = 0, dwTop_C = 0;\n\n        for (DWORD dwIdx = 0; dwIdx < dwCupNum; dwIdx++) {\n            if (state.abyPos[dwIdx] == 0) {\n                dwTop_A = max(dwTop_A, dwIdx+1);\n            }\n            if (state.abyPos[dwIdx] == 1) {\n                dwTop_B = max(dwTop_B, dwIdx+1);\n            }\n            if (state.abyPos[dwIdx] == 2) {\n                dwTop_C = max(dwTop_C, dwIdx+1);\n            } \n        }\n\n        if (dwTop_A < dwTop_B) {\n            /* B->A */\n            visitNext(queSearch, &state, dwTop_B-1, 0, dwCupNum);\n        } else if (dwTop_B < dwTop_A) {\n            /* A->B */\n            visitNext(queSearch, &state, dwTop_A-1, 1, dwCupNum);\n        }\n        if (dwTop_B < dwTop_C) {\n            /* C->B */\n            visitNext(queSearch, &state, dwTop_C-1, 1, dwCupNum);\n        } else if (dwTop_C < dwTop_B) {\n            /* B->C */\n            visitNext(queSearch, &state, dwTop_B-1, 2, dwCupNum);\n        }\n    }\n    return -1;\n}\n\n\nint main()\n{\n    for (;;) {\n        SQWORD sqInput_n = inputSDWORD();\n        SQWORD sqInput_m = inputSQWORD();\n\n        if ((0 == sqInput_n) && (0 == sqInput_m)) {\n            break;\n        }\n\n        CUP_STATE stCupState;\n\n        memset(&stCupState, 0, sizeof(stCupState));\n\n        for (DWORD dwTrayIdx = 0; dwTrayIdx < 3; dwTrayIdx++) {\n            SQWORD sqInput_nn = inputSQWORD();\n            for (DWORD dwCupIdx = 0; dwCupIdx < sqInput_nn; dwCupIdx++) {\n                SDWORD lInput_Cup = inputSQWORD();\n                stCupState.abyPos[lInput_Cup - 1] = dwTrayIdx;\n            }\n            stCupState.dwDepth = 0;\n        }\n        for (DWORD dwCupIdx = 0; dwCupIdx < sqInput_n; dwCupIdx++) {\n            s_stGoalState1.abyPos[dwCupIdx] = 0;\n            s_stGoalState2.abyPos[dwCupIdx] = 2;\n        }\n        SDWORD lAns = solveBfs(&stCupState, sqInput_n, sqInput_m);\n\n        printf(\"%d\\n\", lAns);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <spdlog/spdlog.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define EPS 1e-10\n#define INF 1 << 30\n#define LLINF LLONG_MAX/3\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\nll power(ll x,ll n){ll a=1;REP(i,n)a*=x;return a;}\n\nint p[20];\n\nint f(int a, int b, int c)\n{\n  if(!b&&!c) return 0;\n  int s = (a|b|c)>>1;\n  int t = 0;\n  while(s&1) {t++;s>>=1;}\n  if(1&a) return f(a>>1,b>>1,c>>1);\n  if(1&b) return f(c>>1,b>>1,a>>1)+p[t];\n  if(1&c) return f(a>>1,b>>1,c>>1)+2*p[t];\n}\n\nint main()\n{\n  int n,m;\n  REP(i,20)\n  {\n    p[i] = pow(3,i);\n  }\n  while(cin >> n >> m,n)\n  {\n    int a[3] = {0};\n    REP(i,3)\n    {\n      int t,u; cin >> t;\n      REP(j,t)\n      {\n        cin >> u;\n        a[i] |= 1 << u-1;\n      }\n    }\n    int ans = min(f(a[0],a[1],a[2]),f(a[2],a[1],a[0]));\n    cout << (ans>m?-1:ans) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar pos[15+1];\n\nint step(int n) {\n\tif (n == 0) return 0;\n\treturn 3*step(n-1) + 1;\n}\n\nint step2(char dest, int n) {\n\tif (n == 0) return 0;\n\tif (dest == 'A') {\n\t\tif (pos[n] == 'A') return step2('A', n-1);\n\t\tif (pos[n] == 'B') return step2('C', n-1) + 1 + 2*step(n-1);\n\t\treturn step2('A', n-1) + 2 + 4*step(n-1);\n\t} else /* if (dest == 'C') */ {\n\t\tif (pos[n] == 'C') return step2('C', n-1);\n\t\tif (pos[n] == 'B') return step2('A', n-1) + 1 + 2*step(n-1);\n\t\treturn step2('C', n-1) + 2 + 4*step(n-1);\n\t}\n}\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n && m) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tint k; cin >> k;\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tint l; cin >> l;\n\t\t\t\tpos[n-l+1] = 'A' + i;\n\t\t\t}\n\t\t}\n\t\tint a = step2('A', n);\n\t\tint b = step2('C', n);\n\t\ta = a<b ? a : b;\n\t\tcout << (a<=m ? a : -1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nint limit,num_cup,ans;\nbool Log[14348907],FLG;\nchar ch;\nshort a_loc,b_loc,c_loc;\n\n\nstruct Info{\n\tint value;\n\tchar loc;\n};\n\nvoid setCode(char table[15], int &calc){\n\tint S = 1;\n\tcalc = 0;\n\tfor(int i = 0; i < num_cup; i++){\n\t\tif(table[i] == 'A'){\n\t\t\tcalc += 0;\n\t\t}else if(table[i] == 'B'){\n\t\t\tcalc += S;\n\t\t}else{\n\t\t\tcalc += 2*S;\n\t\t}\n\t\tS *= 3;\n\t}\n}\n\nvoid recursive(char table[15],int count){\n\n\tif(count > limit)return;\n\tif(ans != -1 && count >= ans)return;\n\n\tFLG = true;\n\tch = table[0];\n\n\tif(ch == 'B')FLG = false;\n\n\tif(FLG){\n\t\tfor(int i = 1; i <= num_cup-1; i++){\n\t\t\tif(table[i] != ch){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(FLG){\n\t\tif(ans == -1){\n\t\t\tans = count;\n\t\t}else{\n\t\t\tans = min(ans,count);\n\t\t}\n\t\treturn;\n\t}\n\n\tchar new_table[4][15];\n\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int k = 0; k < num_cup; k++)new_table[i][k] = table[k];\n\t}\n\n\ta_loc = b_loc = c_loc = -1;\n\tfor(int i = num_cup-1; i >= 0; i--){\n\t\tif(table[i] == 'A'){\n\t\t\ta_loc = (a_loc >= i)?a_loc:i;\n\t\t}else if(table[i] == 'B'){\n\t\t\tb_loc = (b_loc >= i)?b_loc:i;\n\t\t}else{\n\t\t\tc_loc = (c_loc >= i)?c_loc:i;\n\t\t}\n\t}\n\n\tint calc;\n\n\tif(a_loc > b_loc){\n\t\tnew_table[0][a_loc] = 'B';\n\n\t\tsetCode(new_table[0],calc);\n\t\tif(Log[calc] == false){\n\t\t\tLog[calc] = true;\n\t\t\trecursive(new_table[0],count+1);\n\t\t}\n\t}\n\n\tif(b_loc > a_loc){\n\t\tnew_table[1][b_loc] = 'A';\n\n\t\tsetCode(new_table[1],calc);\n\t\tif(Log[calc] == false){\n\t\t\tLog[calc] = true;\n\t\t\trecursive(new_table[1],count+1);\n\t\t}\n\t}\n\n\tif(c_loc > b_loc){\n\t\tnew_table[2][c_loc] = 'B';\n\n\t\tsetCode(new_table[2],calc);\n\t\tif(Log[calc] == false){\n\t\t\tLog[calc] = true;\n\t\t\trecursive(new_table[2],count+1);\n\t\t}\n\t}\n\n\tif(b_loc > c_loc){\n\t\tnew_table[3][b_loc] = 'C';\n\n\t\tsetCode(new_table[3],calc);\n\t\tif(Log[calc] == false){\n\t\t\tLog[calc] = true;\n\t\t\trecursive(new_table[3],count+1);\n\t\t}\n\t}\n\n}\n\nint main(){\n\n\tint a,b,c,index,calc;\n\tInfo info[15];\n\tchar table[15];\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&num_cup,&limit);\n\t\tif(num_cup == 0 && limit == 0)break;\n\n\t\tfor(int i = 0; i < 14348907; i++){\n\t\t\tLog[i] = false;\n\t\t}\n\n\t\tindex = 0;\n\t\tscanf(\"%d\",&a);\n\n\t\tfor(int i = 0; i < a; i++){\n\t\t\tscanf(\"%d\",&info[index].value);\n\t\t\tinfo[index].loc = 'A';\n\t\t\tindex++;\n\t\t}\n\n\t\tscanf(\"%d\",&b);\n\t\tfor(int i = 0; i < b; i++){\n\t\t\tscanf(\"%d\",&info[index].value);\n\t\t\tinfo[index].loc = 'B';\n\t\t\tindex++;\n\t\t}\n\n\t\tscanf(\"%d\",&c);\n\t\tfor(int i = 0; i < c; i++){\n\t\t\tscanf(\"%d\",&info[index].value);\n\t\t\tinfo[index].loc = 'C';\n\t\t\tindex++;\n\t\t}\n\n\t\tfor(int i = 1; i <= num_cup-1; i++){\n\t\t\tfor(int k = num_cup-1; k >= i; k--){\n\t\t\t\tif(info[k].value < info[k-1].value)swap(info[k],info[k-1]);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < num_cup;i++){\n\t\t\ttable[i] = info[i].loc;\n\t\t}\n\n\t\tsetCode(table,calc);\n\n\t\tLog[calc] = true;\n\n\t\tans = -1;\n\n\t\trecursive(table,0);\n\n\t\tprintf(\"%d\\n\",ans);\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n// #include <tuple>\n#include <map>\n#include <climits>\nusing namespace std;\n\nconst int NONE = INT_MAX;\n// typedef tuple<int, int, int> Tuple;\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nTuple make_tuple( int a, int b, int c ) {\n    Tuple tuple;\n    tuple.first = a;\n    tuple.second.first = b;\n    tuple.second.second = c;\n    return tuple;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return NONE;\n    S[tuple] = turns;\n    if ( turns > m ) return NONE;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(A);\n        if ( u > v ) {\n            int ret = solve( A | u, remove_last(B), C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(C);\n        if ( u > v ) {\n            int ret = solve( A, remove_last(B), C | u, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return NONE;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        int res = min( ret1, ret2 );\n        if ( res == NONE ) res = -1;\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\nusing namespace std;\nset<pair<stack<int>,stack<int> > >hash;\n\nint main()\n{\n  int n,m;\n  for(;cin>>n>>m,n;)\n    {\n      stack<int> table[3];\n      stack<int> finish;\n      for(int i=1;i<=n;i++)\n\t{\n\t  finish.push(i);\n\t}\n      for(int i=0;i<3;i++)\n\t{\n\t  int size;\n\t  cin>>size;\n\t  for(int j=0;j<size;j++)\n\t    {\n\t      int tmp;\n\t      cin>>tmp;\n\t      table[i].push(tmp);\n\t    }\n\t}\n      //stack,step;\n      queue<pair<pair<stack<int>,stack<int> >,pair<stack<int> ,int> > > qu;\n      qu.push(make_pair(make_pair(table[0],table[1]),make_pair(table[2],0)));\n      int ans=-1;\n      while(!qu.empty())\n\t{\n\t  stack<int>a=qu.front().first.first;\n\t  stack<int>b=qu.front().first.second;\n\t  stack<int>c=qu.front().second.first;\n\t  int step=qu.front().second.second;\n\t  qu.pop();\n\n\t  if(a==finish || c==finish)\n\t    {\n\t      ans=step;\n\t      break;\n\t    }\n\n\t  if(hash.find(make_pair(a,c))!=hash.end())\n\t    continue;\n\t  hash.insert(make_pair(a,c));\n\n\t  if(step==m)\n\t    continue;\n\n\t  if(!a.empty())\n\t    {\n\t      if(b.empty()||a.top()>b.top() )\n\t\t{\n\t\t  int tmp=a.top();\n\t\t  a.pop();\n\t\t  b.push(tmp);\n\t\t  if(hash.find(make_pair(a,c))==hash.end())\n\t\t    qu.push(make_pair(make_pair(a,b),make_pair(c,step+1)));\n\t\t  tmp=b.top();\n\t\t  b.pop();\n\t\t  a.push(tmp);\n\t\t}\n\t    }\n\t  if(!b.empty())\n\t    {\n\t      if(a.empty()||a.top()<b.top() )\n\t\t{\n\t\t  int tmp=b.top();\n\t\t  b.pop();\n\t\t  a.push(tmp);\n\t\t  if(hash.find(make_pair(a,c))==hash.end())\n\t\t    qu.push(make_pair(make_pair(a,b),make_pair(c,step+1)));\n\t\t  tmp=a.top();\n\t\t  a.pop();\n\t\t  b.push(tmp);\n\t\t}\n\n\t      if(c.empty()||c.top()<b.top() )\n\t\t{\n\t\t  int tmp=b.top();\n\t\t  b.pop();\n\t\t  c.push(tmp);\n\t\t  if(hash.find(make_pair(a,c))==hash.end())\n\t\t    qu.push(make_pair(make_pair(a,b),make_pair(c,step+1)));\n\t\t  tmp=c.top();\n\t\t  c.pop();\n\t\t  b.push(tmp);\n\t\t}\n\n\t    }\n\t  if(!c.empty())\n\t    {\n\t      if(b.empty()||b.top()<c.top() )\n\t\t{\n\t\t  int tmp=c.top();\n\t\t  c.pop();\n\t\t  b.push(tmp);\n\t\t  if(hash.find(make_pair(a,c))==hash.end())\n\t\t    qu.push(make_pair(make_pair(a,b),make_pair(c,step+1)));\n\t\t  tmp=b.top();\n\t\t  b.pop();\n\t\t  c.push(tmp);\n\t\t}\n\n\t    }\n\n\n\n\t}\n      cout<<ans<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint n, m;\nstruct puzzle {\n\tint f[3][15], len[3], cnt;\n};\nbool operator<(const puzzle&left, const puzzle&right) {\n\tint cntl = 0, cntr = 0;\n\trep(i, 3)rep(j, n) {\n\t\tcntl += left.f[i][j]; cntr += right.f[i][j];\n\t\tif (cntl != cntr)return cntl < cntr;\n\t}\n\treturn false;\n}\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tpuzzle in{};\n\t\trep(i, 3) {\n\t\t\tscanf(\"%d\", &in.len[i]);\n\t\t\trep(j, in.len[i])scanf(\"%d\", &in.f[i][j]);\n\t\t}\n\t\tmap<puzzle, bool>mp;\n\t\tqueue<puzzle>que;\n\t\tmp[in] = true;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tpuzzle u = que.front(); que.pop();\n\t\t\tif (u.len[0] == n || u.len[2] == n) {\n\t\t\t\tprintf(\"%d\\n\", u.cnt);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (u.cnt >= m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tif (u.len[i] == 0)continue;\n\t\t\t\tif (u.len[j] > 0 && (u.f[i][u.len[i] - 1] < u.f[j][u.len[j] - 1]))\n\t\t\t\t\tcontinue;\n\t\t\t\tpuzzle v = u;\n\t\t\t\tv.len[i]--; v.len[j]++;\n\t\t\t\tswap(v.f[i][v.len[i]], v.f[j][v.len[j] - 1]);\n\t\t\t\tif (!mp[v]) {\n\t\t\t\t\tmp[v] = true;\n\t\t\t\t\tv.cnt++;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WRANINGS\n#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\nint n,m;\n\nint calc(vector<int>& v,int l){\n\tint ret = 0;\n\tFOR(i,n){\n\t\tif(v[i] == 1){\n\t\t\tret += (int)pow(3.0,n-1-i);\n\t\t\tl ^= 2;\n\t\t} else if(v[i] != l){\n\t\t\tret += 2 * (int)pow(3.0,n-1-i);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(cin>>n>>m,n||m){\n\t\tvector<int> v(n);\n\t\t\tFOR(i,3){\n\t\t\t\tint x; cin>>x;\n\t\t\t\tFOR(j,x){ int a; cin>>a; v[a-1] = i; }\n\t\t\t}\n\t\tint ans = min(calc(v,0),calc(v,2));\n\t\tcout << ((ans > m) ? -1 : ans) << endl; \n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\nusing namespace std;\nset<pair<string,string > >hash;\n\nint main()\n{\n  int n,m;\n  for(;cin>>n>>m,n;)\n    {\n      string table[3];\n      string finish;\n      for(int i=1;i<=n;i++)\n\t{\n\t  finish+=('0'+i);\n\t}\n      for(int i=0;i<3;i++)\n\t{\n\t  int size;\n\t  cin>>size;\n\t  for(int j=0;j<size;j++)\n\t    {\n\t      char tmp;\n\t      cin>>tmp;\n\t      table[i]+=tmp;\n\t    }\n\t}\n      //stack,step;\n      queue<pair<pair<string,string> ,pair<string ,int> > > qu;\n      qu.push(make_pair(make_pair(table[0],table[1]),make_pair(table[2],0)));\n      int ans=-1;\n\n      while(!qu.empty())\n\t{\n\t  string a=qu.front().first.first;\n\t  string b=qu.front().first.second;\n\t  string c=qu.front().second.first;\n\t  int step=qu.front().second.second;\n\t  qu.pop();\n\n\t  if(a==finish || c==finish)\n\t    {\n\t      ans=step;\n\t      break;\n\t    }\n\n\t  if(hash.find(make_pair(a,c))!=hash.end())\n\t    continue;\n\t  hash.insert(make_pair(a,c));\n\n\t  if(step==m)\n\t    continue;\n\n\t  if(!a.empty())\n\t    {\n\t      if(b==\"\"||a[a.size()-1]>b[b.size()-1] )\n\t\t{\n\t\t  char tmp=a[a.size()-1];\n\t\t  string aa=a.substr(0,a.size()-1);\n\t\t  string bb=b+tmp;\n\t\t  if(hash.find(make_pair(aa,c))==hash.end())\n\t\t    qu.push(make_pair(make_pair(aa,bb),make_pair(c,step+1)));\n\t\t}\n\t    }\n\t  if(!b.empty())\n\t    {\n\t      if(a==\"\"||a[a.size()-1]<b[b.size()-1] )\n\t\t{\n\t\t  char tmp=b[b.size()-1];\n\t\t  string bb=b.substr(0,b.size()-1);\n\t\t  string aa=a+tmp;\n\t\t  if(hash.find(make_pair(aa,c))==hash.end())\n\t\t    qu.push(make_pair(make_pair(aa,bb),make_pair(c,step+1)));\n\n\t\t}\n\t      if(c==\"\"||c[c.size()-1]<b[b.size()-1] )\n\t\t{\n\t\t  char tmp=b[b.size()-1];\n\t\t  string bb=b.substr(0,b.size()-1);\n\t\t  string cc=c+tmp;\n\t\t  if(hash.find(make_pair(a,cc))==hash.end())\n\t\t    qu.push(make_pair(make_pair(a,bb),make_pair(cc,step+1)));\n\n\t\t}\n\n\t    }\n\t  if(!c.empty())\n\t    {\n\t      if(b==\"\"||b[b.size()-1]<c[c.size()-1] )\n\t\t{\n\t\t  char tmp=c[c.size()-1];\n\t\t  string cc=c.substr(0,c.size()-1);\n\t\t  string bb=b+tmp;\n\t\t  if(hash.find(make_pair(a,cc))==hash.end())\n\t\t    qu.push(make_pair(make_pair(a,bb),make_pair(cc,step+1)));\n\t\t}\n\n\t    }\n\n\n\n\t}\n      cout<<ans<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n\nint nisehanoi(std::vector<std::set<int, std::greater<int>>>& tray, int n, int m, int result, int count = 0){\n  if(count > std::min(m, result)) return result;\n  if(tray[0].size() == n || tray[2].size() == n) return count;\n  for(int i = 0; i < 3; ++i){\n    for(int j = std::max(0, i - 1); j < std::min(3, i + 2); ++j){\n      if(i != j && *tray[i].begin() > *tray[j].begin()){\n        tray[j].insert(*tray[i].begin());\n        tray[i].erase(*tray[i].begin());\n        result = nisehanoi(tray, n, m, result, count + 1);\n        tray[i].insert(*tray[j].begin());\n        tray[j].erase(*tray[j].begin());\n      }\n    }\n  }\n  return result;\n}\nint main(){\n  int n, m;\n  while(std::cin >> n >> m, n + m > 0){\n    std::vector<std::set<int, std::greater<int>>> tray;\n    for(int t = 0; t < 3; ++t){\n      int d;\n      std::cin >> d;\n      std::set<int, std::greater<int>> bar;\n      for(; d > 0; --d){\n        int dn;\n        std::cin >> dn;\n        bar.insert(dn);\n      }\n      tray.push_back(bar);\n    }\n    int result = nisehanoi(tray, n, m, m + 1);\n    std::cout << ((result == m + 1) ? -1 : result) << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <stack>\n#include <vector>\nusing namespace std;\n\ninline int msb(int x) {\n\tif(!x) return 0;\n\treturn (1 << (31 - __builtin_clz(x)));\n}\n\nstruct state {\n\tvector<int> cup, prev;\n\tint cnt;\n\n\tstate(const vector<int>& c, const vector<int>& p, const int& cnt_):cup(c), prev(p), cnt(cnt_) {}\n};\n\nint main() {\n\tconst vector<int> init(3, -1);\n\n\tfor(int n, m; scanf(\"%d %d\", &n, &m), n | m;) {\n\t\tvector<int> cup(3, 0);\n\n\t\tfor(int i = 0; i < 3; ++i) {\n\t\t\tint num;\n\t\t\tscanf(\"%d\", &num);\n\n\t\t\tfor(int j = 0; j < num; ++j) {\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\", &size);\n\n\t\t\t\tcup[i] |= (1 << (size - 1));\n\t\t\t}\n\t\t}\n\n\t\tint ans = INT_MAX;\n\t\tstack<state> sta;\n\t\tsta.push(state(cup, init, 0));\n\t\twhile(!sta.empty()) {\n\t\t\tstate s = sta.top();\n\t\t\tsta.pop();\n\n\t\t\tif(s.cnt > min(m, ans))\n\t\t\t\tcontinue;;\n\n\t\t\tif(s.cup[0] == (1 << n) - 1 || s.cup[2] == (1 << n) - 1) {\n\t\t\t\tans = s.cnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\t\tint move = max(msb(s.cup[i]), msb(s.cup[i + 1]));\n\t\t\t\tvector<int> next(s.cup);\n\t\t\t\tnext[i] ^= move;\n\t\t\t\tnext[i + 1] ^= move;\n\t\t\t\tif(next != s.prev)\n\t\t\t\t\tsta.push(state(next, s.cup, s.cnt + 1));\n\t\t\t}\t\n\t\t}\n\n\t\tprintf(\"%d\\n\", (ans == INT_MAX ? -1 : ans));\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint n, m;\nstruct String {\n\tchar s[3][15];\n};\nbool operator==(const String&left, const String&right) {\n\trep(i, 3) {\n\t\tif (strcmp(left.s[i], right.s[i]))return false;\n\t}\n\treturn true;\n}\nstruct GET {\n\tinline size_t operator()(const String&p) const {\n\t\tsize_t cnt = 0;\n\t\trep(i, 3) {\n\t\t\thash<string>H;\n\t\t\tcnt += (i + 1)*H(p.s[i]);\n\t\t}\n\t\treturn cnt;\n\t}\n};\n\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tString in{};\n\t\trep(i, 3) {\n\t\t\tint len; scanf(\"%d\", &len);\n\t\t\trep(j, len)scanf(\"%hd\", &in.s[i][j]);\n\t\t}\n\t\tunordered_map<String, int, GET>mp;\n\t\tqueue<String>que;\n\t\tmp[in] = 1;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tString u = que.front(); que.pop();\n\t\t\tif (strlen(u.s[0]) == n || strlen(u.s[2]) == n) {\n\t\t\t\tprintf(\"%d\\n\", mp[u] - 1);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (mp[u] >= m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tint leni = strlen(u.s[i]), lenj = strlen(u.s[j]);\n\t\t\t\tif (leni == 0)continue;\n\t\t\t\tif (lenj > 0 && (u.s[i][leni - 1] < u.s[j][lenj - 1]))\n\t\t\t\t\tcontinue;\n\t\t\t\tString v = u;\n\t\t\t\tswap(v.s[i][leni - 1], v.s[j][lenj]);\n\t\t\t\tif (!mp[v]) {\n\t\t\t\t\tmp[v] = mp[u] + 1;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <hash_map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint bfs(int m,vector<int>& root, hash_map<string,int> visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\t\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tchar buf[32];\n\t\t\t\tsprintf(buf,\"%09d%09d%09d\",tmp[0],tmp[1],tmp[2]);\n\t\t\t\tstring next;\n\t\t\t\tnext = buf;\n\t\t\t\tif(visited.find(next) == visited.end()){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tchar buf[32];\n\t\t\t\tsprintf(buf,\"%09d%09d%09d\",tmp[0],tmp[1],tmp[2]);\n\t\t\t\tstring next;\n\t\t\t\tnext = buf;\n\t\t\t\tif(visited.find(next) == visited.end()){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\thash_map<string,int> visited;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,sets,visited));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define AB 1\n#define BC 3\n#define INF 1<<30\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nint n, m;\n\nstack<int> T[3];\n\nbool is_success (void )\n{\n\treturn (T[1].top() == 0 && (T[0].top() == 0 || T[2].top() == 0 ) ); \n}\n\nint dfs (int curr, int prev )\n{\n\tint ans = INF;\n\n\tif (curr > m ){\n\t\treturn ans;\n\t} // end if\n\n\tif (is_success () ){\n\t\tans = min (ans, curr );\n\t\treturn ans;\n\t} // end if\n\n\trep (i, 3 ){\n\t\tif (T[i].top() == 0 ) continue;\n\t\tint cup = T[i].top(); T[i].pop();\n\t\tif (i == 0 && prev != AB ){\n\t\t\tif (cup > T[1].top() ){\n\t\t\t\tT[1].push (cup );\n\t\t\t\tans = min (ans, dfs (curr+1, AB ) );\n\t\t\t\tT[1].pop();\n\t\t\t} // end if\n\t\t} // end if\n\t\tif (i == 2 && prev != BC ){\n\t\t\tif (cup > T[1].top() ){\n\t\t\t\tT[1].push (cup );\n\t\t\t\tans = min (ans, dfs (curr+1, BC ) );\n\t\t\t\tT[1].pop();\n\t\t\t} // end if\n\t\t} // end if\n\t\tif (i == 1 ){\n\t\t\tif (prev != AB && (cup > T[0].top() ) ){\n\t\t\t\tT[0].push (cup );\n\t\t\t\tans = min (ans, dfs (curr+1, AB ) );\n\t\t\t\tT[0].pop();\n\t\t\t} // end if\n\t\t\tif (prev != BC && (cup > T[2].top() ) ){\n\t\t\t\tT[2].push (cup );\n\t\t\t\tans = min (ans, dfs (curr+1, BC ) );\n\t\t\t\tT[2].pop();\n\t\t\t} // end if\n\t\t} // end if\n\t\tT[i].push (cup );\n\t} // end rep\n\n\treturn ans;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.cup\", \"r\", stdin );\n\twhile (scanf (\"%d %d\", &n, &m ), n, m ){\n\t\trep (i, 3 ){\n\t\t\tT[i] = stack<int>();\n\t\t\tT[i].push (0 );\n\t\t} // end rep\n\t\t\n\t\trep (i, 3 ){\n\t\t\tint in;\n\t\t\tscanf (\"%d\", &in );\n\t\t\twhile (in--){\n\t\t\t\tint cup;\n\t\t\t\tscanf (\"%d\", &cup );\n\t\t\t\tT[i].push (cup );\n\t\t\t} // end rep\n\t\t} // end rep\n\n\t\tint res = min (dfs (0, AB ), dfs (0, BC ) );\n\t\tif (res == INF ){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << res << endl;\n\t\t} // end if\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef struct Cup\n{\n\tvector<int>P[3];\n\tint T;\n\tbool operator <(const Cup &a)const{ return T>a.T;};\n}S;\nint N,M;\nbool f[3][3][3][3][3][3][3][3][3][3][3][3][3][3][3];\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&M),N;)\n\t{\n\t\tCup tmp;\n\t\tint i,j,t,q,R=-1;\n\t\tmemset(f,0,sizeof(f));\n\t\tfor(i=0;i<3;i++)\n\t\t{\n\t\t\tfor(scanf(\"%d\",&t),j=0;j<t;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&q);\n\t\t\t\ttmp.P[i].push_back(q);\n\t\t\t}\n\t\t}\n\n\t\ttmp.T=0;\n\t\tpriority_queue<Cup> Q;\n\t\tQ.push(tmp);\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\ttmp=Q.top();Q.pop();\n\t\t\tint p[15]={0};\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tfor(int j=0;j<tmp.P[i].size();j++)\n\t\t\t\t\tp[tmp.P[i][j]-1]=i;\n\t\t\tif(f[p[0]][p[1]][p[2]][p[3]][p[4]][p[5]][p[6]][p[7]][p[8]][p[9]][p[10]][p[11]][p[12]][p[13]][p[14]])continue;\n\t\t\tif(tmp.T>M)continue;\n\t\t\tif(tmp.P[0].size()==N||tmp.P[2].size()==N)\n\t\t\t{\n\t\t\t\tR=tmp.T;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tfor(int j=-1;j<2;j++)\n\t\t\t\t{\n\t\t\t\t\tif(j&&i+j>=0&&i+j<3&&!tmp.P[i].empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tint tmp1=tmp.P[i].back();\n\t\t\t\t\t\tint tmp2=-1;\n\t\t\t\t\t\tif(!tmp.P[i+j].empty())\n\t\t\t\t\t\t\ttmp2=tmp.P[i+j].back();\n\t\t\t\t\t\tif(tmp1>tmp2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCup ins=tmp;\n\t\t\t\t\t\t\tins.P[i+j].push_back(tmp1);\n\t\t\t\t\t\t\tins.P[i].pop_back();\n\t\t\t\t\t\t\tins.T++;\n\t\t\t\t\t\t\tQ.push(ins);\n\t\t\t\t\t\t\tf[p[0]][p[1]][p[2]][p[3]][p[4]][p[5]][p[6]][p[7]][p[8]][p[9]][p[10]][p[11]][p[12]][p[13]][p[14]]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<set>\n#include<utility>\n#include<vector>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define MP(a,b) make_pair(a,b)\n\t\ntypedef vector<vector<int> > S;\nS in(3);\nint n,m;\n\nint bfs(){\n\tset<S> s;\n\tpair<int,S> a;\n\tS b;\n\tqueue<pair<int,S> > q;\n\tq.push(MP(0,in));\n\ts.insert(in);\n\n\twhile(!q.empty()){\n\t\ta = q.front();q.pop();\n\t\tb = a.second;\n\t\tif(b[0].size()==n || b[2].size()==n)return a.first;\n\t\tif(m < a.first)break;\n\t\tif(!b[0].empty()){//A->B\n\t\t\tif(b[1].empty() || b[0].back() > b[1].back()){\n\t\t\t\tb[1].push_back(b[0].back());\n\t\t\t\tb[0].pop_back();\n\t\t\t\tif(s.find(b)==s.end()){\n\t\t\t\t\tq.push(MP(a.first+1,b));\n\t\t\t\t\ts.insert(b);\n\t\t\t\t}\n\t\t\t\tb = a.second;\n\t\t\t}\n\t\t}\n\t\tif(!b[1].empty()){//B->A\n\t\t\tif(b[0].empty() || b[1].back() > b[0].back()){\n\t\t\t\tb[0].push_back(b[1].back());\n\t\t\t\tb[1].pop_back();\n\t\t\t\tif(s.find(b)==s.end()){\n\t\t\t\t\tq.push(MP(a.first+1,b));\n\t\t\t\t\ts.insert(b);\n\t\t\t\t}\n\t\t\t\tb = a.second;\n\t\t\t}\n\t\t}\n\t\tif(!b[1].empty()){//B->C\n\t\t\tif(b[2].empty() || b[1].back() > b[2].back()){\n\t\t\t\tb[2].push_back(b[1].back());\n\t\t\t\tb[1].pop_back();\n\t\t\t\tif(s.find(b)==s.end()){\n\t\t\t\t\tq.push(MP(a.first+1,b));\n\t\t\t\t\ts.insert(b);\n\t\t\t\t}\n\t\t\t\tb = a.second;\n\t\t\t}\n\t\t}\n\t\tif(!b[2].empty()){//C->B\n\t\t\tif(b[1].empty() || b[2].back() > b[1].back()){\n\t\t\t\tb[1].push_back(b[2].back());\n\t\t\t\tb[2].pop_back();\n\t\t\t\tif(s.find(b)==s.end()){\n\t\t\t\t\tq.push(MP(a.first+1,b));\n\t\t\t\t\ts.insert(b);\n\t\t\t\t}\n\t\t\t\tb = a.second;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint main(){\n\tcin>>n>>m;\n\tREP(i,3){\n\t\tint a,b;\n\t\tcin>>a;\n\t\tREP(j,a){\n\t\t\tcin>>b;\n\t\t\tin[i].push_back(b);\n\t\t}\n\t}\n\tcout<<bfs()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint idou(int a){\n\tint s=1;\n\tfor(int i=0;i<a;i++) s=s*3;\n\treturn (s-1)/2;\n}\n\nint main(){\n\tint cups,move,cc,tuv,a,z=0;\n\twhile(1){\n\t\tscanf(\"%d%d\",&cups,&move);\n\t\ta=move;\n\t\tif(cups==0) break;\n\t\tint cup[cups];\n\t\tfor(int i=0;i<3;i++){\n\t\t\tscanf(\"%d\",&cc);\n\t\t\tfor(int j=0;j<cc;j++){\n\t\t\t\tscanf(\"%d\",&tuv);\n\t\t\t\tcup[tuv-1]=i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(cup[0]==1){for(z=0;cup[z]==1;z++) ;\n\t\tmove=move-idou(z);}\n\t\tcc=0;\n\t\ttuv=cup[cups-1];\n\t\tfor(int i=cups-1;i>0&&move>=0;i--){\n\t\t\tif(tuv!=cup[i]){\n\t\t\t\tmove=move-idou(cc);\n\t\t\t\ttuv=cup[i];\n\t\t\t}\n\t\t\tcc++;\n\t\t}\n\t\tif(move) printf(\"%d\\n\",a-move);\n\t\telse printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n// variable update\ninline void modAdd(int& _a, int _b, int _m) { _a = (_a + _b) % _m; }\ninline void modAdd(lint& _a, lint _b, lint _m) { _a = (_a + _b) % _m; }\ninline void minUpdate(int& _a, int _b) { _a = min(_a, _b); }\ninline void minUpdate(lint& _a, lint _b) { _a = min(_a, _b); }\ninline void maxUpdate(int& _a, int _b) { _a = max(_a, _b); }\ninline void maxUpdate(lint& _a, lint _b) { _a = max(_a, _b); }\n\nint n, m;\nint POW[16];\n\nint calc(int A, int B, int C) {\n\tint res = 0;\n\tfor_(i,0,n) {\n\t\tint k = n - i - 1;\n\t\tif (A >> i & 1) res += 2 * POW[k];\n\t\tif (B >> i & 1) res += POW[k], swap(A, C);\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tint cup[3] = { 0 };\n\t\n\tfor_(i,0,3) {\n\t\tint d; cin >> d;\n\t\tfor_(j,0,d) {\n\t\t\tint p; cin >> p; --p;\n\t\t\tcup[i] |= 1 << p;\n\t\t}\n\t}\n\t\n\tint ans = min(calc(cup[0], cup[1], cup[2]), calc(cup[2], cup[1], cup[0]));\n\tcout << ( (ans > m) ? -1 : ans) << endl;\n}\n\nint main() {\n\tPOW[0] = 1;\n\tfor_(i,1,16) POW[i] = POW[i - 1] * 3;\n\twhile (cin >> n >> m, n) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <iterator>\n#include <algorithm>\n\n#define MAX_N 15\n#define MAX_M 15000000\n\n\nstd::stack<int> trays[3];\nstd::stack<int> r_trays[3];\n\nvoid moveTop(int i, int j) {\n  // move top value i to j\n  trays[j].push(trays[i].top());\n  trays[i].pop();\n}\n\nvoid clearTray() {\n  for (int i = 0; i < 3; i ++) {\n    while(!trays[i].empty())\n      trays[i].pop();\n    while(!r_trays[i].empty())\n      r_trays[i].pop();\n  }\n}\n\nbool isEmpty() {\n  if((trays[0].empty() && trays[1].empty()) || (trays[1].empty() && trays[2].empty()))\n    return true;\n  else\n    return false;\n}\n\nint moveCups(int m) {\n  int move = 0;\n  bool flag = true;\n\n  if (isEmpty())\n    return 0;\n\n  while(flag) {\n    for (int i = 0; i < 2; i ++) { \n      move ++;\n      // move bigger cup\n      if (trays[i + 1].empty() || (!trays[i].empty() && trays[i].top() > trays[i + 1].top())) {\n        moveTop(i, i + 1); \n      } else {\n        moveTop(i + 1, i);\n      }\n      // check situation\n      if (isEmpty()) {\n        flag = false;\n        break;\n      } else if (move >= m) {\n        flag = false;\n        move = -1;\n        break;\n      }\n    }\n  }\n  return move;\n}\n\nint main() {\n  int n, m;\n  int num, temp, move, left, right;\n  bool flag = true;\n  while (1) {\n    std::cin >> n >> m;\n    if (n == 0)\n      break;\n    // store cups to trays.\n    for (int i = 0; i < 3; i ++) {\n      std::cin >> num;\n      for (int j = 0; j < num; j ++) {\n        std::cin >> temp;\n        trays[i].push(temp);\n      }\n      r_trays[2 - i] = trays[i];\n    }\n    std::reverse(std::begin(r_trays), std::end(r_trays));\n    right = moveCups(m);\n    for (int i = 0; i < 3; i ++)\n      trays[i].swap(r_trays[2 - i]);\n    left = moveCups(m);\n\n    std::cout << (right > left ? right : left) << std::endl;\n    clearTray();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include <stack>\nusing namespace std;\n\n\n\nint main()\n{\n\tstack<int>a,b,c;\n\twhile(1)\n\t{\n\t\t\n\t\tint count=0,n,m,check;\n\t\tscanf(\"%d %d\",&n,&m);\n\n\t\tif(n==0 && m==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\n\t\tint A,B,C,\n\t\t\tkari;\n\t\t\n\t\t/*エラー対策*/\n\t\ta.push(0);\n\t\tb.push(0);\n\t\tc.push(0);\n\n\t\tscanf(\"%d\",&A);\n\t\tfor(int i=0;i<A;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\ta.push(kari);\n\t\t}\n\n\t\tscanf(\"%d\",&B);\n\t\tfor(int i=0;i<B;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\tb.push(kari);\n\t\t}\n\t\n\t\tscanf(\"%d\",&C);\n\t\tfor(int i=0;i<C;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\tc.push(kari);\n\t\t}\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif(b.top()==0 && c.top()==0)\n\t\t\t\tbreak;\n\t\t\tif(a.top()<b.top() && a.top()<c.top()){\n\t\t\t\tkari=b.top();\n\t\t\t\ta.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b.top()<c.top() ){\n\t\t\t\tkari=c.top();\n\t\t\t\tb.push(kari);\n\t\t\t\tc.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b.top()<a.top()){\n\t\t\t\tkari=a.top();\n\t\t\t\tb.push(kari);\n\t\t\t\ta.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(c.top()<b.top() && a.top()!=b.top()-1){\n\t\t\t\tkari=b.top();\n\t\t\t\tc.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t}\n\t\t\telse{\n\t\t\t\tkari=b.top();\n\t\t\t\ta.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(count<m || count==m) printf(\"%d\",count);\n\t\telse printf(\"%d\",-1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint visited[15000000];\n\nint conv(vector<int>& sets){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<=15;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * (pow(3.0,j)+eps);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,vector<int>& root, int* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tmemset(visited,-1,sizeof(visited));\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,sets,visited));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stack>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int from[]={0,2,1,1},to[]={1,1,2,0};\n\nstack<int> tray[3];\n\nbool move(int i){\n\tconst int &f=from[i],&t=to[i];\n\tif(!tray[f].empty() && (tray[t].empty() || tray[f].top()>tray[t].top())){\n\t\ttray[t].push(tray[f].top());\n\t\ttray[f].pop();\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool over(){\n\treturn tray[1].empty() && (tray[0].empty() || tray[2].empty());\n}\n\nint simulate(int prev){\n\tfor(int k=0;;k++){\n\t\tif(over()) return k;\n\t\trep(i,4) if(i!=3-prev && move(i)) { prev=i; break; }\n\t}\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\trep(k,3){\n\t\t\twhile(!tray[k].empty()) tray[k].pop();\n\n\t\t\tint nk; scanf(\"%d\",&nk);\n\t\t\trep(j,nk){\n\t\t\t\tint tmp; scanf(\"%d\",&tmp);\n\t\t\t\ttray[k].push(tmp);\n\t\t\t}\n\t\t}\n\n\t\tif(over()){ puts(\"0\"); continue; }\n\n\t\tint ans=(1<<31)-1;\n\t\trep(i,4){\n\t\t\tstack<int> tmp[3];\n\t\t\tcopy(tray,tray+3,tmp);\n\t\t\tif(move(i)) ans=min(ans,simulate(i)+1);\n\t\t\tcopy(tmp,tmp+3,tray);\n\t\t}\n\t\tif(ans>m) ans=-1;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <tr1/unordered_map>\nusing namespace std;\n\nint n;\n\nint goal = 0;\n\ntypedef int P ;\n\nunsigned int f(int n,unsigned int size){\n\treturn n%101429 ;\n}\ntemplate <class K, class V>  \nclass hashMap {  \n    static const unsigned int DEFAULT_SIZE = 101429;  \n    vector<pair<K, V> > *contents;  \n    unsigned int _size;  \n    unsigned int (*_hashValue) (K, unsigned int);  \n  \npublic:  \n    hashMap(unsigned int (*func) (K, unsigned int) , unsigned int size = DEFAULT_SIZE) {  \n        _hashValue = func;  \n        _size = size;  \n        contents = new vector<pair<K, V> > [_size];  \n    }  \n  \n    ~hashMap() {  \n        delete [] contents;  \n    }  \n  \n    bool hashElement(K s) {  \n        unsigned int h = _hashValue(s, _size);  \n  \n        for (int i = 0; i < (int)contents[h].size(); i++) {  \n            if (contents[h][i].first == s)  \n                return true;  \n        }  \n  \n        return false;  \n    }  \n  \n    void insert(K x, V n) {  \n        if (hashElement(x))  \n            return;  \n  \n        unsigned int h = _hashValue(x, _size);  \n        contents[h].push_back(make_pair(x, n));  \n    }  \n  \n    pair<K, V> *getElement(K x) {  \n        unsigned int h = _hashValue(x, _size);  \n        for (int i = 0; i < (int)contents[h].size(); i++)  \n            if (contents[h][i].first == x)  \n                return &contents[h][i];  \n  \n        return NULL;  \n    }  \n  \n    void printHashBalance() {  \n        int cnt = 0;  \n        double ret = 0.0;  \n        int worst = 0;  \n  \n        for (int i = 0; i < (int)_size; i++) {  \n            if (contents[i].size()) {  \n                ++cnt;  \n                ret += contents[i].size();  \n                worst = max<int>(worst, contents[i].size());  \n            }  \n        }  \n  \n        if (!cnt)  \n            cerr << \"Hash is empty\" << endl;  \n        else {  \n            cerr << \"collisions occurred(average): \" << (ret/cnt) << endl;  \n            cerr << \"collisions occurred(worst): \" << worst << endl;  \n        }  \n    }  \n};  \n\nP Q[30];\nint m,stat,tim,head,size,i,t,a,j,from,to,next;\n\nint main(){\n\twhile(cin >> n >> m && n){\n\t\thashMap<int,int> done(&f);\n\t\tint init = 0;\n\t\tfor(i = 0 ; i < n ; i++) goal |= 2 << (i*2);\n\t\t\n\t\tfor(i = 0 ; i < 3 ; i++){\n\t\t\tt,a; cin >> t;\n\t\t\twhile(t--){cin >> a; a--; init |= (i) << (2*a); }\n\t\t}\n\t\thead = 0 , size = 0;\n\t\tQ[size++] = init;\n\t\tdone.insert(init,0);\n\t\tint hoge = 0;\n\t\twhile(head != size){\n\t\t\thoge++;\n\t\t\tstat = Q[head++];\n\t\t\ttim = (*done.getElement(stat)).second;\n\t\t\tif(tim > m) break;\n\t\t\tif(stat == goal || stat == 0){ cout << tim << endl; goto hoge;}\n\t\t\tint mi[3] = {-1,-1,-1};\n\t\t\tfor(i = n-1 ; i >= 0 ; i--){\n\t\t\t\tint num = stat>>(i*2)&3;\n\t\t\t\tif(mi[num]==-1)mi[num] = i;\n\t\t\t}\n\t\t\t\n\t\t\tfor(from = 0 ; from < 3 ; from++){\n\t\t\t\tfor(to = 0 ; to < 3 ; to++){\n\t\t\t\t\tif ( !( (from == 0 && to == 2) || (from == 2 && to == 0) ) && from != to && mi[from] != -1 && (mi[to] == -1 || mi[from] > mi[to]) ){\n\t\t\t\t\t\tnext = (stat & ~(3<<(2*mi[from]))) | (to<<(2*mi[from]));\n\t\t\t\t\t\tif(done.getElement(next)==NULL)Q[size++] = next , done.insert(next,tim+1);\n\t\t\t\t\t\thead %= 30;\n\t\t\t\t\t\tsize %= 30;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\thoge:;\n\t\t//done.printHashBalance();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\nconst ll mod = 1e9 + 7;\ntypedef pair<int,int>           PI;\ntypedef pair<ll,ll>             PL;\ntypedef vector<PI>               vip; \ntypedef vector<int>             vi;\ntypedef vector<vi>              vvi;\n\n\n\n\n\n\nint main (){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    vi c(16);\n    int n, m, j, k, d, x, y, p;\n    while(cin >> n >> m,n){\n        REP(i,3){\n            for(cin >> j; j>0; --j){\n                cin >> k;\n                c[n-k] = i;\n            }\n        }\n\n        p= 0;\n        x=0;\n        for(int i = n-1; i>=0; --i){\n            d = abs(p - c[i]);//pはいる位置\n            x += pow(3,i) * d;\n            if(d == 1){\n                p = 2-p;\n            }\n        }\n\n        y = pow(3,n) - 1 - x;\n        int ans = min(x,y);\n        if(ans <= m) cout << ans << endl;\n        else cout << -1 << endl;\n    }\n\n\n\n\n\n\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint n, m;\nstruct puzzle {\n\tchar f[3][15], len[3];\n\tint cnt;\n};\nstruct String {\n\tstring s[3];\n\tString(char c[][15]) {\n\t\trep(i, 3)s[i] = c[i];\n\t}\n};\nbool operator==(const String&left, const String&right) {\n\trep(i, 3) {\n\t\tif (left.s[i] != right.s[i])return false;\n\t}\n\treturn true;\n}\nstruct GET {\n\tinline size_t operator()(const String&p) const {\n\t\tsize_t cnt = 0;\n\t\trep(i, 3) {\n\t\t\thash<string>H;\n\t\t\tcnt += (i + 1)*H(p.s[i]);\n\t\t}\n\t\treturn cnt;\n\t}\n};\n\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tpuzzle in{};\n\t\trep(i, 3) {\n\t\t\tscanf(\"%hd\", &in.len[i]);\n\t\t\trep(j, in.len[i])scanf(\"%hd\", &in.f[i][j]);\n\t\t}\n\t\tunordered_map<String, bool, GET>mp;\n\t\tqueue<puzzle>que;\n\t\tmp[in.f] = true;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tpuzzle u = que.front(); que.pop();\n\t\t\tif (u.len[0] == n || u.len[2] == n) {\n\t\t\t\tprintf(\"%d\\n\", u.cnt);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (u.cnt >= m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tif (u.len[i] == 0)continue;\n\t\t\t\tif (u.len[j] > 0 && (u.f[i][u.len[i] - 1] < u.f[j][u.len[j] - 1]))\n\t\t\t\t\tcontinue;\n\t\t\t\tpuzzle v = u;\n\t\t\t\tv.len[i]--; v.len[j]++;\n\t\t\t\tswap(v.f[i][v.len[i]], v.f[j][v.len[j] - 1]);\n\t\t\t\tif (!mp[v.f]) {\n\t\t\t\t\tmp[v.f] = true;\n\t\t\t\t\tv.cnt++;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// #include {{{\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <chrono>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <forward_list>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#ifdef LOCAL\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n#endif\n\nusing namespace std;\n// }}}\n\n// type {{{\nusing  i8 =   int8_t;\nusing  u8 =  uint8_t;\nusing i16 =  int16_t;\nusing u16 = uint16_t;\nusing i32 =  int32_t;\nusing u32 = uint32_t;\nusing i64 =  int64_t;\nusing u64 = uint64_t;\n\nusing i128 =  __int128_t;\nusing u128 = __uint128_t;\n\ntemplate<typename T>\nusing MaxHeap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n// }}}\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#endif\n// }}}\n\n// 適宜調整\nconstexpr bool AUTOFLUSH = false;\n\nconstexpr int IOS_PREC = 12;\n\nconstexpr int INF_I32 =             1'010'000'000;\nconstexpr i64 INF_I64 = 1'010'000'000'000'000'000LL;\n\nconstexpr auto   INF = INF_I64;\nconstexpr double EPS = 1e-12;\n\nconstexpr i64 MOD = 1'000'000'007;\n\n// hide {{{\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n// }}}\n\n// util {{{\nconstexpr i32 I32_MAX = numeric_limits<i32>::max();\nconstexpr i32 I32_MIN = numeric_limits<i32>::min();\n\nconstexpr i64 I64_MAX = numeric_limits<i64>::max();\nconstexpr i64 I64_MIN = numeric_limits<i64>::min();\n\nconstexpr double PI = 3.14159265358979323846;\n\ntemplate<typename F>\nclass RecursiveFunc {\npublic:\n    RecursiveFunc(F&& f) : f_(f) {}\n\n    template<typename... Args>\n    decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<typename F>\nauto RECURSIVE(F&& f) {\n    return RecursiveFunc<decay_t<F>>(forward<F>(f));\n}\n\ntemplate<typename T>\nint GETBIT(T x, int i) { return (x>>i) & 1; }\ntemplate<typename T>\nT SETBIT(T x, int i) { return x | (T(1)<<i); }\ntemplate<typename T>\nT CLEARBIT(T x, int i) { return x & ~(T(1)<<i); }\n\ntemplate<typename T>\nconstexpr const T& MAX(const T& x, const T& y) { return std::max(x, y); }\ntemplate<typename T, typename Comp>\nconstexpr const T& MAX(const T& x, const T& y, Comp comp) { return std::max(x, y, comp); }\ntemplate<typename T>\nconstexpr T MAX(initializer_list<T> ilist) { return std::max(ilist); }\ntemplate<typename T, typename Comp>\nconstexpr T MAX(initializer_list<T> ilist, Comp comp) { return std::max(ilist, comp); }\n\ntemplate<typename T>\nconstexpr const T& MIN(const T& x, const T& y) { return std::min(x, y); }\ntemplate<typename T, typename Comp>\nconstexpr const T& MIN(const T& x, const T& y, Comp comp) { return std::min(x, y, comp); }\ntemplate<typename T>\nconstexpr T MIN(initializer_list<T> ilist) { return std::min(ilist); }\ntemplate<typename T, typename Comp>\nconstexpr T MIN(initializer_list<T> ilist, Comp comp) { return std::min(ilist, comp); }\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n    return x < 0 ? -x : x;\n}\n\ntemplate<typename T>\nconstexpr T abs_diff(T x, T y) {\n    return x < y ? y-x : x-y;\n}\n\ntemplate<typename T>\nconstexpr bool is_odd(T x)  { return x % 2 != 0; }\ntemplate<typename T>\nconstexpr bool is_even(T x) { return x % 2 == 0; }\n\ntemplate<typename T>\nconstexpr bool parity_same(T x, T y) {\n    return (is_odd(x) && is_odd(y)) || (is_even(x) && is_even(y));\n}\n\ntemplate<typename T>\nconstexpr int cmp(T x, T y) { return (y < x) - (x < y); }\n\ntemplate<typename T>\nconstexpr int sgn(T x) { return cmp(x, T(0)); }\n\nconstexpr i64 ipow(i64 a, i64 b) {\n    assert(b >= 0);\n    i64 res(1);\n    for(i64 i = 0; i < b; ++i)\n        res *= a;\n    return res;\n}\n\npair<i64,i64> divmod(i64 a, i64 b) {\n    return make_pair(a/b, a%b);\n}\n\nconstexpr i64 div_ceil(i64 a, i64 b) {\n    return a/b + (((a<0)^(b>0)) && (a%b));\n}\n\nconstexpr i64 div_floor(i64 a, i64 b) {\n    return a/b - (((a>0)^(b>0)) && (a%b));\n}\n\nconstexpr i64 modulo(i64 a, i64 b) {\n    assert(0 < b);\n    i64 r = a % b;\n    return r >= 0 ? r : r+b;\n}\n\ntemplate<typename T>\nconstexpr T CLAMP(T x, T lo, T hi) {\n    assert(lo <= hi);\n    if(x < lo)\n        return lo;\n    else if(hi < x)\n        return hi;\n    else\n        return x;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\ntemplate<typename T>\nconstexpr int SIZE(const T& c) {\n    return static_cast<int>(c.size());\n}\n\ntemplate<typename T, size_t N>\nconstexpr int SIZE(const T (&)[N]) {\n    return static_cast<int>(N);\n}\n\ntemplate<typename InputIt, typename T>\nint argfind(InputIt first, InputIt last, const T& x) {\n    auto it = find(first, last, x);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmax(InputIt first, InputIt last) {\n    auto it = max_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nint argmin(InputIt first, InputIt last) {\n    auto it = min_element(first, last);\n    return distance(first, it);\n}\n\ntemplate<typename InputIt>\nbool alltrue(InputIt first, InputIt last) {\n    return all_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool anytrue(InputIt first, InputIt last) {\n    return any_of(first, last, [](bool b) { return b; });\n}\n\ntemplate<typename InputIt>\nbool allfalse(InputIt first, InputIt last) {\n    return !anytrue(first, last);\n}\n\ntemplate<typename InputIt>\nbool anyfalse(InputIt first, InputIt last) {\n    return !alltrue(first, last);\n}\n\n// hash {{{\ntemplate<typename T>\nstruct myhash {\n    size_t operator()(const T& x) const {\n        hash<T> h;\n        return h(x);\n    }\n};\n\ntemplate<typename T>\nsize_t myhash_value(const T& x) {\n    return hash<T>()(x);\n}\n\ntemplate<typename T>\nvoid myhash_combine(size_t& seed, const T& x) {\n    seed ^= myhash_value(x) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n}\n\ntemplate<typename T1, typename T2>\nstruct myhash<pair<T1,T2>> {\n    size_t operator()(const pair<T1,T2>& p) const {\n        size_t seed = 0;\n        myhash_combine(seed, p.first);\n        myhash_combine(seed, p.second);\n        return seed;\n    }\n};\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\nvoid TUPLEHASH(size_t&, const tuple<TS...>&) {}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\nvoid TUPLEHASH(size_t& seed, const tuple<TS...>& t) {\n    myhash_combine(seed, get<I>(t));\n    TUPLEHASH<I+1, TS...>(seed, t);\n}\n\ntemplate<typename... TS>\nstruct myhash<tuple<TS...>> {\n    size_t operator()(const tuple<TS...>& t) const {\n        size_t seed = 0;\n        TUPLEHASH(seed, t);\n        return seed;\n    }\n};\n\ntemplate<typename Seq>\nvoid SEQHASH(size_t& seed, const Seq& v) {\n    for(const auto& e : v)\n        myhash_combine(seed, e);\n}\n\ntemplate<typename T>\nstruct myhash<vector<T>> {\n    size_t operator()(const vector<T>& v) const {\n        size_t seed = 0;\n        SEQHASH(seed, v);\n        return seed;\n    }\n};\n\ntemplate<typename T, size_t N>\nstruct myhash<array<T,N>> {\n    size_t operator()(const array<T,N>& v) const {\n        size_t seed = 0;\n        SEQHASH(seed, v);\n        return seed;\n    }\n};\n\ntemplate<typename T>\nusing HashSet = unordered_set<T,myhash<T>>;\n\ntemplate<typename K, typename V>\nusing HashMap = unordered_map<K,V,myhash<K>>;\n\ntemplate<typename T>\nusing HashMultiSet = unordered_multiset<T,myhash<T>>;\n\ntemplate<typename K, typename V>\nusing HashMultiMap = unordered_multimap<K,V,myhash<K>>;\n// }}}\n\ntemplate<typename T, typename... Args>\nvoid vec_emplace_front(vector<T>& v, Args&&... args) {\n    v.emplace(begin(v), args...);\n}\n\ntemplate<typename K, typename V>\npair<typename map<K,V>::iterator, bool> insert_or_assign(map<K,V>& m, const K& k, const V& v) {\n    auto it = m.lower_bound(k);\n    if(it != end(m) && !m.key_comp()(k,it->first)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename K, typename V>\npair<typename HashMap<K,V>::iterator, bool>\ninsert_or_assign(HashMap<K,V>& m, const K& k, const V& v) {\n    auto it = m.find(k);\n    if(it != end(m)) {\n        it->second = v;\n        return make_pair(it, false);\n    }\n    else {\n        auto it_ins = m.insert(it, make_pair(k,v));\n        return make_pair(it_ins, true);\n    }\n}\n\ntemplate<typename T>\nstring TO_STRING(const T& x) {\n    ostringstream out;\n    out << x;\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << sep;\n    }\n    return out.str();\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename T>\nvoid UNIQ(T& c) {\n    c.erase(unique(begin(c), end(c)), end(c));\n}\n\ntemplate<typename T, typename F>\nenable_if_t<rank<T>::value==0> ARRAY_FOREACH(T& e, F f) {\n    f(e);\n}\n\ntemplate<typename Array, typename F>\nenable_if_t<rank<Array>::value!=0> ARRAY_FOREACH(Array& ary, F f) {\n    for(auto& e : ary)\n        ARRAY_FOREACH(e, f);\n}\n\ntemplate<typename Array, typename U>\nenable_if_t<rank<Array>::value!=0> ARRAY_FILL(Array& ary, const U& v) {\n    ARRAY_FOREACH(ary, [&v](auto& elem) { elem = v; });\n}\n\ntemplate<typename T>\nT POP_BACK(vector<T>& que) {\n    T x = que.back(); que.pop_back();\n    return x;\n}\n\ntemplate<typename T>\nT POP_BACK(deque<T>& que) {\n    T x = que.back(); que.pop_back();\n    return x;\n}\n\ntemplate<typename T>\nT POP_FRONT(deque<T>& que) {\n    T x = que.front(); que.pop_front();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nT POP(priority_queue<T,Cont,Cmp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef LOCAL\n    if(!cin) assert(false);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, int n) {\n    v.reserve(n);\n    for(int i = 0; i < n; ++i) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\ntemplate<typename T, size_t N>\nvoid RD(array<T,N>& v) {\n    for(size_t i = 0; i < N; ++i) {\n        RD(v[i]);\n    }\n}\n\n// 出力 {{{\n// FPRINTSEQ {{{\ntemplate<typename InputIt>\nostream& FPRINTSEQ(ostream& out, InputIt first, InputIt last) {\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << ' ';\n    }\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTSEQ(InputIt first, InputIt last) {\n    return FPRINTSEQ(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTSEQ(InputIt first, InputIt last) {\n#ifdef LOCAL\n    FPRINTSEQ(cerr, first, last);\n#endif\n    return cerr;\n}\n// }}}\n\n// 1次元生配列 {{{\ntemplate<typename T, size_t N>\nostream& FPRINTARRAY1(ostream& out, const T (&c)[N]) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\ntemplate<typename T, size_t N>\nostream& PRINTARRAY1(const T (&c)[N]) {\n    return FPRINTARRAY1(cout, c);\n}\ntemplate<typename T, size_t N>\nostream& DPRINTARRAY1(const T (&c)[N]) {\n#ifdef LOCAL\n    FPRINTARRAY1(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 2次元生配列 {{{\ntemplate<typename T, size_t N1, size_t N2>\nostream& FPRINTARRAY2(ostream& out, const T (&c)[N1][N2]) {\n    out << '\\n';\n    for(const auto& e : c) {\n        FPRINTARRAY1(out, e) << '\\n';\n    }\n    return out;\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& PRINTARRAY2(const T (&c)[N1][N2]) {\n    return FPRINTARRAY2(cout, c);\n}\ntemplate<typename T, size_t N1, size_t N2>\nostream& DPRINTARRAY2(const T (&c)[N1][N2]) {\n#ifdef LOCAL\n    FPRINTARRAY2(cerr, c);\n#endif\n    return cerr;\n}\n// }}}\n\n// 非mapコンテナ {{{\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\n// 特別扱い\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T>>& c) {\n    out << '\\n';\n    for(const auto& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\n// 特別扱い\nostream& operator<<(ostream& out, const vector<string>& c) {\n    out << '\\n';\n    for(const string& e : c) {\n        out << e << '\\n';\n    }\n    return out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const deque<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const set<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const HashSet<T>& c) {\n    return out << set<T>(begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const multiset<T>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const HashMultiSet<T>& c) {\n    return out << multiset<T>(begin(c), end(c));\n}\n\ntemplate<typename T, size_t N>\nostream& operator<<(ostream& out, const array<T,N>& c) {\n    return FPRINTSEQ(out, begin(c), end(c));\n}\n// }}}\n\n// mapコンテナ {{{\ntemplate<typename InputIt>\nostream& FPRINTMAP(ostream& out, InputIt first, InputIt last) {\n    out << \"{\\n\";\n    for(auto it = first; it != last; ++it) {\n        out << \"  \" << it->first << \" : \" << it->second << '\\n';\n    }\n    out << \"}\\n\";\n    return out;\n}\ntemplate<typename InputIt>\nostream& PRINTMAP(InputIt first, InputIt last) {\n    return FPRINTMAP(cout, first, last);\n}\ntemplate<typename InputIt>\nostream& DPRINTMAP(InputIt first, InputIt last) {\n#ifdef LOCAL\n    FPRINTMAP(cerr, first, last);\n#endif\n    return cerr;\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const map<K,V>& c) {\n    return FPRINTMAP(out, begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const HashMap<K,V>& c) {\n    return out << map<K,V>(begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const multimap<K,V>& c) {\n    return FPRINTMAP(out, begin(c), end(c));\n}\n\ntemplate<typename K, typename V>\nostream& operator<<(ostream& out, const HashMultiMap<K,V>& c) {\n    return out << multimap<K,V>(begin(c), end(c));\n}\n// }}}\n\n// stack/queue/priority_queue {{{\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, stack<T,C> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename C>\nostream& operator<<(ostream& out, queue<T,C> c) {\n    while(!c.empty()) {\n        out << c.front();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n\ntemplate<typename T, typename Cont, typename Cmp>\nostream& operator<<(ostream& out, priority_queue<T,Cont,Cmp> c) {\n    while(!c.empty()) {\n        out << c.top();\n        c.pop();\n        if(!c.empty()) out << ' ';\n    }\n    return out;\n}\n// }}}\n\n// pair/tuple {{{\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\nostream& FPRINTTUPLE(ostream& out, const tuple<TS...>&) {\n    if(sizeof...(TS) == 0)\n        out << '(';\n    return out << ')';\n}\n\ntemplate<size_t I=0, typename... TS, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\nostream& FPRINTTUPLE(ostream& out, const tuple<TS...>& t) {\n    if(I == 0)\n        out << '(';\n    else\n        out << ',';\n    out << get<I>(t);\n    return FPRINTTUPLE<I+1, TS...>(out, t);\n}\n\ntemplate<typename... TS>\nostream& operator<<(ostream& out, const tuple<TS...>& t) {\n    return FPRINTTUPLE(out, t);\n}\n// }}}\n\n// PRINT {{{\nostream& FPRINT(ostream& out) { return out; }\n\ntemplate<typename T, typename... TS>\nostream& FPRINT(ostream& out, const T& x, const TS& ...args) {\n    out << x;\n    if(sizeof...(args))\n        out << ' ';\n    return FPRINT(out, args...);\n}\n\ntemplate<typename... TS>\nostream& FPRINTLN(ostream& out, const TS& ...args) {\n    FPRINT(out, args...);\n    return out << '\\n';\n}\n\ntemplate<typename... TS>\nostream& PRINT(const TS& ...args) {\n    return FPRINT(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& PRINTLN(const TS& ...args) {\n    return FPRINTLN(cout, args...);\n}\n\ntemplate<typename... TS>\nostream& DPRINT(const TS& ...args) {\n#ifdef LOCAL\n    FPRINT(cerr, args...);\n#endif\n    return cerr;\n}\n\ntemplate<typename... TS>\nostream& DPRINTLN(const TS& ...args) {\n#ifdef LOCAL\n    FPRINTLN(cerr, args...);\n#endif\n    return cerr;\n}\n// }}}\n// }}}\n\nvoid FLUSH() {\n    cout.flush();\n}\n\n[[noreturn]] void EXIT() {\n#ifdef LOCAL\n    cout.flush();\n    cerr.flush();\n#else\n    FLUSH();\n#endif\n    //quick_exit(0); // does not work on codeforces\n    _Exit(0);\n}\n\nstruct IoInit {\n    IoInit() {\n#ifndef LOCAL\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n#endif\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} IOINIT;\n\n#define FOR(i, start, end) for(i64 i = (start); i < (end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cc) { return (f)(begin(cc), end(cc), ## __VA_ARGS__); })(c))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n\n#define DBG(x) DPRINTLN('L', __LINE__, ':', #x, ':', (x))\n\n#define PAIR make_pair\n#define TUPLE make_tuple\n// }}}\n\nstruct State {\n    array<vector<i64>,3> v;\n\n    vector<State> neighbor() const {\n        vector<State> res;\n\n        if(movable(0,1)) {\n            State st(*this);\n            st.mv(0,1);\n            res.emplace_back(st);\n        }\n        else if(movable(1,0)) {\n            State st(*this);\n            st.mv(1,0);\n            res.emplace_back(st);\n        }\n\n        if(movable(1,2)) {\n            State st(*this);\n            st.mv(1,2);\n            res.emplace_back(st);\n        }\n        else if(movable(2,1)) {\n            State st(*this);\n            st.mv(2,1);\n            res.emplace_back(st);\n        }\n\n        return res;\n    }\n\n    void mv(i64 from, i64 to) {\n        v[to].emplace_back(POP_BACK(v[from]));\n    }\n\n    bool movable(i64 from, i64 to) const {\n        if(v[from].empty()) return false;\n        if(v[to].empty()) return true;\n        return v[to].back() < v[from].back();\n    }\n\n    bool done() const {\n        return v[1].empty() && (v[0].empty() || v[2].empty());\n    }\n};\n\nbool operator==(const State& lhs, const State& rhs) {\n    return lhs.v == rhs.v;\n}\n\ntemplate<>\nstruct myhash<State> {\n    size_t operator()(const State& st) const {\n        size_t seed = 0;\n        for(const auto& e : st.v) {\n            SEQHASH(seed, e);\n        }\n        return seed;\n    }\n};\n\ni64 bfs(i64 M, State st_start) {\n    HashSet<State> visited;\n    queue<pair<State,i64>> que;\n\n    visited.emplace(st_start);\n    que.emplace(st_start, 0);\n\n    while(!que.empty()) {\n        State st; i64 d; tie(st,d) = POP(que);\n\n        if(d > M) return -1;\n        if(st.done()) return d;\n\n        for(const auto& to : st.neighbor()) {\n            if(visited.count(to)) continue;\n\n            visited.emplace(to);\n            que.emplace(to, d+1);\n        }\n    }\n\n    assert(false);\n}\n\nvoid solve(i64 /*N*/, i64 M, State st) {\n    i64 ans = bfs(M, st);\n    PRINTLN(ans);\n}\n\nsigned main(signed /*argc*/, char** /*argv*/) {\n    while(true) {\n        i64 N; RD(N);\n        i64 M; RD(M);\n        if(N == 0 && M == 0) break;\n\n        State st;\n        REP(i, 3) {\n            i64 k; RD(k);\n            RD(st.v[i], k);\n        }\n\n        solve(N, M, move(st));\n    }\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint visited[15000000];\n\nint pow(int x,int n){\n\tint res = 1;\n\twhile(n>0){\t\t\n\t\tres *= x;\n\t\tif(n & 1) x = x*x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\nint conv(vector<int>& sets){\n\tint res = 0;\n\tfor(int i=0;i<sets.size();i++){\n\t\tfor(int j=0;j<=15;j++){\n\t\t\tif(sets[i] & (1<<j)){\n\t\t\t\tres += i * pow(3,j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint bfs(int m,vector<int>& root, int* visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\tvisited[conv(root)] = 0;\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tint next;\n\t\t\t\tif(visited[(next = conv(tmp))] == -1){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tmemset(visited,-1,sizeof(visited));\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,sets,visited));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\n#define INF 300000000\n\nusing namespace std;\n\nint n, m;\nint *used;\n\nint main(int argc, char const* argv[])\n{\n\tcin >> n >> m;\n\twhile(n != 0 || m != 0){\n\t\t\tint N = int(pow(3, n));\n\t\t\tused = new int[N];\n\t\t\tfill(used, used + N, INF);\n\t\t\tint ini = 0;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tint a;\n\t\t\t\t\tcin >> a;\n\t\t\t\t\tfor(int j = 0; j < a; j++){\n\t\t\t\t\t\t\tint b;\n\t\t\t\t\t\t\tcin >> b;\n\t\t\t\t\t\t\tini += i * int(pow(3, b - 1));\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tqueue<int> q;\n\t\t\tq.push(ini);\n\t\t\tused[ini] = 0;\n\t\t\twhile(!q.empty()){\n\t\t\t\t\tint p = q.front(); q.pop();\n\t\t\t\t\tif(p == 0 || p == N - 1){\n\t\t\t\t\t\t\tcout << used[p] << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(used[p] > m){\n\t\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint a[3];\n\t\t\t\t\ta[0] = -1;\n\t\t\t\t\ta[1] = -1;\n\t\t\t\t\ta[2] = -1;\n\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\t\ta[(p % int(pow(3, i + 1)) - p % int(pow(3, i))) / int(pow(3, i))] = i;\n\t\t\t\t\t}\n\t\t\t\t\tif(a[0] != -1){\n\t\t\t\t\t\t\tif(a[1] == -1 || a[0] > a[1]){\n\t\t\t\t\t\t\t\t\tint pp = p;\n\t\t\t\t\t\t\t\t\tpp += int(pow(3, a[0]));\n\t\t\t\t\t\t\t\t\tif(used[pp] == INF){\n\t\t\t\t\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\t\t\t\t\tused[pp] = used[p] + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a[2] != -1){\n\t\t\t\t\t\t\tif(a[1] == -1 || a[2] > a[1]){\n\t\t\t\t\t\t\t\t\tint pp = p;\n\t\t\t\t\t\t\t\t\tpp -= int(pow(3, a[2]));\n\t\t\t\t\t\t\t\t\tif(used[pp] == INF){\n\t\t\t\t\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\t\t\t\t\tused[pp] = used[p] + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(a[1] != -1){\n\t\t\t\t\t\t\tif(a[0] == -1 || a[1] > a[0]){\n\t\t\t\t\t\t\t\t\tint pp = p;\n\t\t\t\t\t\t\t\t\tpp -= int(pow(3, a[1]));\n\t\t\t\t\t\t\t\t\tif(used[pp] == INF){\n\t\t\t\t\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\t\t\t\t\tused[pp] = used[p] + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(a[2] == -1 || a[1] > a[2]){\n\t\t\t\t\t\t\t\t\tint pp = p;\n\t\t\t\t\t\t\t\t\tpp += int(pow(3, a[1]));\n\t\t\t\t\t\t\t\t\tif(used[pp] == INF){\n\t\t\t\t\t\t\t\t\t\t\tq.push(pp);\n\t\t\t\t\t\t\t\t\t\t\tused[pp] = used[p] + 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tdelete used;\n\t\t\tcin >> n >> m;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <tr1/unordered_map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nusing namespace tr1;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\nmap<pair<int,pair<int,int> >, int> hii;\n\nint bitnum(int s){\n  int ret = 0;\n  for(;s>0;s>>=1,ret++);\n  return ret;\n}\n\nint main(){\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m),n|m){\n    hii.clear();\n\n    int S[3];\n    rep(i,3){\n      int k; scanf(\"%d\",&k);\n      int s = 0;\n      rep(j,k){\n\tint t; scanf(\"%d\",&t);\n\ts |= 1<<(t-1);\n      }\n      S[i] = s;\n    }\n\n#if DEB\n    rep(i,3){\n      printf(\"S[%d]:%d\\n\",i,S[i]);\n    }\n#endif\n\n    pair<int,pair<int,int> > init(mp(S[0],mp(S[1],S[2])));\n    hii[init] = 0;\n    \n    int ans = -1;\n    queue<pair<int,pair<int,int> > > q;\n    q.push(init);\n    while( !q.empty() ){\n      pair<int,pair<int,int> > tmp = q.front();\n      int a = tmp.first;\n      int b = tmp.second.first;\n      int c = tmp.second.second;\n      int step = hii[tmp];\n      q.pop();\n      if( step>m ){\n\tbreak;\n      }\n      if( (1<<n)-1 == a || (1<<n)-1 == c ){\n\tans = hii[tmp];\n      }      \n      int am = bitnum(a);\n      int bm = bitnum(b);\n      int cm = bitnum(c);\n\n#if DEB\n      printf(\"(%d,%d,%d) , (%d,%d,%d)\\n\",a,b,c,am,bm,cm);\n#endif\n\n      // a -> b\n      if( am>0 && am>bm ){\n\tint ta = a & ~(1<<(am-1));\n\tint tb = b | (1<<(am-1));\n\tif( hii.find(mp(ta,mp(tb,c)))==hii.end() ){\n#if DEB\n\t  puts(\"a -> b\");\n\t  printf(\"::::(%d,%d,%d)\\n\",ta,tb,c);\n#endif\n\t  hii[mp(ta,mp(tb,c))] = step + 1;\n\t  q.push(mp(ta,mp(tb,c)));\n\t}\n      }\n      // b -> a\n      if( bm>0 && am<bm ){\n\tint ta = a | (1<<(bm-1));\n\tint tb = b & ~(1<<(bm-1));\n\tif( hii.find(mp(ta,mp(tb,c)))==hii.end() ){\n#if DEB\n\t  puts(\"b -> a\");\n\t  printf(\"::::(%d,%d,%d)\\n\",ta,tb,c);\n#endif\n\t  hii[mp(ta,mp(tb,c))] = step + 1;\n\t  q.push(mp(ta,mp(tb,c)));\n\t}\n      }\n      // b -> c\n      if( bm>0 && bm>cm ){\n\tint tb = b & ~(1<<(bm-1));\n\tint tc = c | (1<<(bm-1));\n\tif( hii.find(mp(a,mp(tb,tc)))==hii.end() ){\n#if DEB\n\t  puts(\"b -> c\");\n\t  printf(\"::::(%d,%d,%d)\\n\",a,tb,tc);\n#endif\n\t  hii[mp(a,mp(tb,tc))] = step + 1;\n\t  q.push(mp(a,mp(tb,tc)));\n\t}\n      }\n      // c -> b\n      if( cm>0 && bm<cm ){\n\tint tb = b | (1<<(cm-1));\n\tint tc = c & ~(1<<(cm-1));\n\tif( hii.find(mp(a,mp(tb,tc)))==hii.end() ){\n#if DEB\n\t  puts(\"c -> b\");\n\t  printf(\"::::(%d,%d,%d)\\n\",a,tb,tc);\n#endif\n\t  hii[mp(a,mp(tb,tc))] = step + 1;\n\t  q.push(mp(a,mp(tb,tc)));\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define AB 1\n#define BC 3\n#define INF 1<<30\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nint n, m;\n\nbool is_success (vector<stack<int> > tray )\n{\n\treturn (tray[0].size() == n || tray[2].size() == n ); \n}\n\nint dfs (int curr, vector<stack<int> > tray, int prev )\n{\n\tint ans = INF;\n\n\tif (curr > m ){\n\t\treturn ans;\n\t} // end if\n\n\tif (is_success (tray ) ){\n\t\tans = min (ans, curr );\n\t\treturn ans;\n\t} // end if\n\n\trep (i, 3 ){\n\t\tif (!tray[i].empty() ){\n\t\t\tint cup = tray[i].top();\n\t\t\tif (i == 0 && prev != AB ){\n\t\t\t\tif (tray[1].empty() || cup > tray[1].top() ){\n\t\t\t\t\ttray[1].push (cup );\n\t\t\t\t\ttray[i].pop();\n\t\t\t\t\tans = min (ans, dfs (curr+1, tray, AB ) );\n\t\t\t\t\ttray[i].push (cup );\n\t\t\t\t\ttray[1].pop();\n\t\t\t\t} // end if\t\t\t\t\t\t\n\t\t\t}else\n\t\t\tif (i == 2 && prev != BC ){\n\t\t\t\tif (tray[1].empty() || cup > tray[1].top() ){\n\t\t\t\t\ttray[1].push (cup );\n\t\t\t\t\ttray[i].pop();\n\t\t\t\t\tans = min (ans, dfs (curr+1, tray, BC ) );\n\t\t\t\t\ttray[i].push (cup );\n\t\t\t\t\ttray[1].pop();\n\t\t\t\t} // end if\t\t\t\t\t\t\n\t\t\t}else\n\t\t\tif (i == 1 ){\n\t\t\t\tif (prev != AB && (tray[0].empty() || cup > tray[0].top() ) ){\n\t\t\t\t\ttray[0].push (cup );\n\t\t\t\t\ttray[i].pop();\n\t\t\t\t\tans = min (ans, dfs (curr+1, tray, AB ) );\n\t\t\t\t\ttray[i].push (cup );\n\t\t\t\t\ttray[0].pop();\n\t\t\t\t}else\n\t\t\t\tif (prev != BC && (tray[2].empty() ||  cup > tray[2].top() ) ){\n\t\t\t\t\ttray[2].push (cup );\n\t\t\t\t\ttray[i].pop();\n\t\t\t\t\tans = min (ans, dfs (curr+1, tray, BC ) );\n\t\t\t\t\ttray[i].push (cup );\n\t\t\t\t\ttray[2].pop();\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // en if\n\t} // end rep\n\n\treturn ans;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.cup\", \"r\", stdin );\n\twhile (scanf (\"%d %d\", &n, &m ), n, m ){\n\t\tvector<stack<int> > tray(3);\n\t\trep (i, 3 ){\n\t\t\tint in;\n\t\t\tscanf (\"%d\", &in );\n\t\t\trep (j, in ){\n\t\t\t\tint cup;\n\t\t\t\tscanf (\"%d\", &cup );\n\t\t\t\ttray[i].push (cup );\n\t\t\t} // end rep\n\t\t} // end rep\n\t\tint ans = dfs (0, tray, 0 );\n\t\tif (ans == INF ){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t} // end if\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,vector<int> > P;\n\nstatic const double eps = 1e-8;\n\nint bfs(int m,vector<int>& root, unordered_map<string,int> visited){\n\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,root));\n\t\n\tvector<int> tmp;\n\tvector<int> sets;\n\twhile(!que.empty()){\n\t\tint cost = que.top().first;\n\t\t\n\t\tsets = que.top().second;\n\n\t\tif(sets[1]==0 && sets[2]==0) return cost;\n\t\tif(sets[0]==0 && sets[1]==0) return cost;\n\n\t\tif(cost >= m) break;\n\t\tque.pop();\n\t\tfor(int i=0;i+1<sets.size();i++){\n\t\t\tif((sets[i] && sets[i+1] && sets[i] < sets[i+1]) \n\t\t\t\t|| (!sets[i] && sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i+1] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i+1] &= ~(1<<pos);\n\t\t\t\ttmp[i] |= (1<<pos);\n\n\t\t\t\t\n\t\t\t\tchar buf[32];\n\t\t\t\tsprintf(buf,\"%09d%09d%09d\",tmp[0],tmp[1],tmp[2]);\n\t\t\t\tstring next;\n\t\t\t\tnext = buf;\n\t\t\t\tif(visited.find(next) == visited.end()){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if((sets[i] && sets[i+1] && sets[i] > sets[i+1]) \n\t\t\t\t|| (sets[i] && !sets[i+1])){\n\t\t\t\ttmp = sets;\n\n\t\t\t\tint pos=0;\n\t\t\t\tfor(int j=15;j>=0;j--){\n\t\t\t\t\tif(tmp[i] & (1<<j)){\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp[i] &= ~(1<<pos);\n\t\t\t\ttmp[i+1] |= (1<<pos);\n\n\t\t\t\tchar buf[32];\n\t\t\t\tsprintf(buf,\"%09d%09d%09d\",tmp[0],tmp[1],tmp[2]);\n\t\t\t\tstring next;\n\t\t\t\tnext = buf;\n\t\t\t\tif(visited.find(next) == visited.end()){\n\t\t\t\t\tvisited[next] = cost+1;\n\t\t\t\t\tque.push(P(cost+1,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\n\tint n,m;\n\twhile(~scanf(\"%d %d\",&n,&m)){\n\t\tif(n==m && m==0) break;\n\t\tvector<int> sets(3);\n\t\tunordered_map<string,int> visited;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint amount;\n\t\t\tscanf(\"%d\",&amount);\n\t\t\tfor(int j=0;j<amount;j++){\n\t\t\t\tint size;\n\t\t\t\tscanf(\"%d\",&size);\n\t\t\t\tsets[i] |= (1<<(size-1)); \n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",bfs(m,sets,visited));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define INF 1<<28\n\ndeque<int> a, b, c;\nint n, m;\n\ninline bool finish() {\n    return b.empty() && (a.empty() || c.empty());\n}\n\n// r: 残り移動可能回数\n// prev: 前回の操作\n//  1: A->B\n//  2: B->A\n//  3: C->B\n//  4: B->C\nint dfs(int r, int prev) {\n    if (finish()) return m-r;\n    if (r == 0) return INF;\n    int ret = INF;\n    if (prev != 2 && !a.empty() && (b.empty() || a.back() > b.back())) {\n        b.push_back(a.back()); a.pop_back();\n        ret = min(ret, dfs(r-1, 1));\n        a.push_back(b.back()); b.pop_back();\n    }\n    if (prev != 1 && !b.empty() && (a.empty() || b.back() > a.back())) {\n        a.push_back(b.back()); b.pop_back();\n        ret = min(ret, dfs(r-1, 2));\n        b.push_back(a.back()); a.pop_back();\n    } \n    if (prev != 4 && !c.empty() && (b.empty() || c.back() > b.back())) {\n        b.push_back(c.back()); c.pop_back();\n        ret = min(ret, dfs(r-1, 3));\n        c.push_back(b.back()); b.pop_back();\n    }\n    if (prev != 3 && !b.empty() && (c.empty() || b.back() > c.back())) {\n        c.push_back(b.back()); b.pop_back();\n        ret = min(ret, dfs(r-1, 4));\n        b.push_back(c.back()); c.pop_back();\n    }\n    return ret;\n}\n\nint main() {\n    while (cin >> n >> m) {\n        if (n == 0 && m == 0) break;\n        a.clear(), b.clear(), c.clear();\n        int na, nb, nc;\n        cin >> na;\n        for (int i = 0; i < na; i++) { \n            int _a; cin >> _a; a.push_back(_a);\n        }\n        cin >> nb;\n        for (int i = 0; i < nb; i++) { \n            int _b; cin >> _b; b.push_back(_b);\n        }\n        cin >> nc;\n        for (int i = 0; i < nc; i++) {\n            int _c; cin >> _c; c.push_back(_c);\n        }\n        int res = dfs(m, 0);\n        if (res == INF) cout << -1 << endl;\n        else cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nint c[3];\nint n;\nint m;\nint ans;\nint depth;\n\nenum{\n  INIT = 0,\n  AB = 1,\n  BA = 2,\n  BC = 3,\n  CB = 4,\n};\n\nenum{\n  A = 0,\n  B = 1,\n  C = 2\n};\n\nchar prev[15000000+10];\n\nstatic inline void dfs(){\n  if(depth == m) return;\n  if(depth >= ans) return;\n  if(c[0] == (1 << n) - 1 || c[2] == (1 << n) - 1){\n    ans = depth;\n    return;\n  }\n  depth++;\n\n  if(prev[depth-1] != BA && c[A] != 0){\n    int aa = (c[A] & -c[A]);\n    int bb = (c[B] & -c[B]);\n    if(aa < bb || bb == 0){\n      c[A] ^= aa;\n      c[B] ^= aa;\n      prev[depth] = AB;\n      dfs();\n      c[B] ^= aa;\n      c[A] ^= aa;\n    }\n  }\n  if(prev[depth-1] != AB && c[B] != 0){\n    int bb = (c[B] & -c[B]);\n    int aa = (c[A] & -c[A]);\n    if(bb < aa || aa == 0){\n      c[B] ^= bb;\n      c[A] ^= bb;\n      prev[depth] = BA;\n      dfs();\n      c[A] ^= bb;\n      c[B] ^= bb;\n    }\n  }\n  if(prev[depth-1] != CB && c[B] != 0){\n    int bb = (c[B] & -c[B]);\n    int cc = (c[C] & -c[C]);\n    if(bb < cc || cc == 0){\n      c[B] ^= bb;\n      c[C] ^= bb;\n      prev[depth] = BC;\n      dfs();\n      c[C] ^= bb;\n      c[B] ^= bb;\n    }\n  }\n  if(prev[depth-1] != BC && c[C] != 0){\n    int cc = (c[C] & -c[C]);\n    int bb = (c[B] & -c[B]);\n    if(cc < bb || bb == 0){\n      c[C] ^= cc;\n      c[B] ^= cc;\n      prev[depth] = CB;\n      dfs();\n      c[B] ^= cc;\n      c[C] ^= cc;\n    }\n  }\n  depth--;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&m),n+m){\n    REP(i,3){\n      int t;\n      c[i] = 0;\n      scanf(\"%d\", &t);\n      REP(j,t){\n        int p;\n        scanf(\"%d\",&p);\n        c[i] |= (1 << (n - p));\n      }\n    }\n\n    ans = INT_MAX; depth = 0;\n    prev[0] = INIT;\n    dfs();\n    printf(\"%d\\n\",ans == INT_MAX ? -1 : ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\n#include <climits>\nusing namespace std;\n\nconst int NONE = INT_MAX;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(A);\n        if ( u > v ) {\n            int ret = solve( A | u, remove_last(B), C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(C);\n        if ( u > v ) {\n            int ret = solve( A, remove_last(B), C | u, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        int res = min( ret1, ret2 );\n        if ( res == NONE ) res = -1;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint n, m;\nstruct puzzle {\n\tchar f[3][15];\n\tint len[3], cnt;\n};\nbool operator==(const puzzle&left, const puzzle&right) {\n\trep(i, 3) {\n\t\tif (strcmp(left.f[i], right.f[i]))return false;\n\t}\n\treturn true;\n}\nstruct GET {\n\tinline size_t operator()(const puzzle&p) const {\n\t\tsize_t cnt = 0;\n\t\trep(i, 3) {\n\t\t\thash<string>H;\n\t\t\tcnt += (i + 1)*H(p.f[i]);\n\t\t}\n\t\treturn cnt;\n\t}\n};\n\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tpuzzle in{};\n\t\trep(i, 3) {\n\t\t\tscanf(\"%d\", &in.len[i]);\n\t\t\trep(j, in.len[i])scanf(\"%d\", &in.f[i][j]);\n\t\t}\n\t\tunordered_map<puzzle, bool, GET>mp;\n\t\tqueue<puzzle>que;\n\t\tmp[in] = true;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tpuzzle u = que.front(); que.pop();\n\t\t\tif (u.len[0] == n || u.len[2] == n) {\n\t\t\t\tprintf(\"%d\\n\", u.cnt);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (u.cnt >= m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tif (u.len[i] == 0)continue;\n\t\t\t\tif (u.len[j] > 0 && (u.f[i][u.len[i] - 1] < u.f[j][u.len[j] - 1]))\n\t\t\t\t\tcontinue;\n\t\t\t\tpuzzle v = u;\n\t\t\t\tv.len[i]--; v.len[j]++;\n\t\t\t\tswap(v.f[i][v.len[i]], v.f[j][v.len[j] - 1]);\n\t\t\t\tif (!mp[v]) {\n\t\t\t\t\tmp[v] = true;\n\t\t\t\t\tv.cnt++;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<string>\n#include<climits>\n#include<deque>\n\nusing namespace std;\n\nint k;\nstack<int,vector<int> >A,B,C;\n\nint func(int,string);\n\nint main(void){\nint n,m,ans,s,t;\n\nwhile(cin >> n >> m,n|m){\nwhile(!A.empty())A.pop();\nwhile(!B.empty())B.pop();\nwhile(!C.empty())C.pop();\n\ncin >> s;\nfor(int i=0;i<s;i++){\ncin >> t;\nA.push(t);\n}\ncin >> s;\nfor(int i=0;i<s;i++){\ncin >> t;\nB.push(t);\n}\ncin >> s;\nfor(int i=0;i<s;i++){\ncin >> t;\nC.push(t);\n}\nans=INT_MAX;\nfor(k=1;k<=min(1000,m);k++){\nans=func(0,\"\");\nif(ans!=INT_MAX)break;\n}\nif(ans==INT_MAX)cout << -1 << endl;\nelse cout << ans << endl;\n}\nreturn 0;\n}\n\nint func(int cnt,string p){\n\nif(cnt>k)return INT_MAX;\n\nif(B.empty()&&(C.empty()||A.empty()))\nreturn cnt;\n\nint res=INT_MAX;\n\nif(!A.empty() && A.top()>=B.top() && p!=\"BA\"){\nB.push(A.top());\nA.pop();\nres=min(res,func(cnt+1,\"AB\"));\nA.push(B.top());\nB.pop();\n}\n\nif(!B.empty()){\nif(B.top()>=C.top()&&p!=\"CB\"){\nC.push(B.top());\nB.pop();\nres=min(res,func(cnt+1,\"BC\"));\nB.push(C.top());\nC.pop();\n}\n\nif(B.top()>=A.top()&&p!=\"AB\"){\nA.push(B.top());\nB.pop();\nres=min(res,func(cnt+1,\"BA\"));\nB.push(A.top());\nA.pop();\n}\n}\n\nif(!C.empty() && C.top()>=B.top() && p!=\"BC\"){\nB.push(C.top());\nC.pop();\nres=min(res,func(cnt+1,\"CB\"));\nC.push(B.top());\nB.pop();\n}\n\nreturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\ntypedef std::stack<int> Tray;\n\nbool moveNtoN(Tray tr[], int src, int dst){\n    if((tr[src]).empty() ||\n        !(tr[dst]).empty() && (tr[src]).top() < (tr[dst]).top()){\n        return false;\n    }\n    (tr[dst]).push((tr[src]).top());\n    (tr[src]).pop();\n    return true;\n}\n\nbool ifSorted(Tray tr[]){\n    return ((tr[1]).empty() && ((tr[0]).empty() || (tr[2].empty())));\n}\n\nint solve(Tray tr[], int m){\n    int lastMove;          // 0 : A->B, 1 : B->A, 2 : B->C, 3 : C->B\n    for(int j = 0; j < 2; j++){\n        if(ifSorted(tr)){\n            return 0;\n        }\n        lastMove = -1;\n        if(j == 0){\n            if(moveNtoN(tr, 0, 1)){ \n                lastMove = 0;\n            }\n            else if(moveNtoN(tr, 1, 0)){\n                lastMove = 1;\n            }\n        }\n        else {\n            if(moveNtoN(tr, 1, 2)){\n                lastMove = 2;\n            }\n            else if(moveNtoN(tr, 2, 1)){\n                lastMove = 3;\n            }\n        }\n        for(int i = 1; i <= m; i++){\n            if(ifSorted(tr)){\n                return i;\n            }\n            if(lastMove != 1 && moveNtoN(tr, 0, 1)){\n                lastMove = 0;\n            }\n            else if(lastMove != 0  && moveNtoN(tr, 1, 0)){\n                lastMove = 1;\n            }\n            else if(lastMove != 3 && moveNtoN(tr, 1, 2)){\n                lastMove = 2;\n            }\n            else if(lastMove != 2 && moveNtoN(tr, 2, 1)){\n                lastMove = 3;\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    int n, m;\n    Tray trays[3];\n    while(1){\n        std::cin >> n >> m;\n        if(!(n || m)){\n            break;\n        }\n        for(int col = 0; col < 3; col++){\n            int nCups;                     // #cups on the line\n            std::cin >> nCups;\n            while(nCups--){\n                int cup;\n                std::cin >> cup;\n                (trays[col]).push(cup);\n            }\n        }\n        std::cout << solve(trays, m) << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<stack>\n#include<queue>\nusing namespace std;\n\nstruct Data{\n    int dep;\n    stack<int> s[3];\n};\n\nint main(){\n    int hoge,n;\n    while(cin>>hoge>>n,n || hoge){\n        Data q_c,q_d,first;\n\n        int m,input,nt,cup,cntempty;\n\n        bool flag;\n        int situ[2] = {-1,1};\n        queue<Data> q;\n        for(int i=0;i<3;i++){\n            cin>>m;\n            for(int j=0;j<m;j++){\n                cin>>input;\n                first.s[i].push(input);\n            }\n        }\n        first.dep = 0;\n        q.push(first);\n        flag = false;\n        while(!q.empty()){\n            q_c = q.front();\n            q.pop();\n            //for(int i=0;i<3;i++) printf(\"%d \",!q_c.s[i].empty());\n            //puts(\"\");\n            if(q_c.dep == n) break;\n            cntempty = 0;\n            for(int i=0;i<3;i++){\n                if(!q_c.s[i].empty()){\n                    if(i == 1){\n                        cntempty = 0;\n                        break;\n                    }\n                    cntempty++;\n                }\n            }\n            if(cntempty == 1){\n                printf(\"%d\\n\",q_c.dep);\n                flag = true;\n                break;\n            }\n            for(int i=0;i<3;i++){\n                for(int j=0;j<2;j++){\n                    nt = i+situ[j];\n                    if(nt<0 || 3<=nt) continue;\n                    q_d = q_c;\n                    if(q_d.s[i].empty()) continue;\n                    cup = q_d.s[i].top();\n                    q_d.s[i].pop();\n                    if(!q_d.s[nt].empty() && cup < q_d.s[nt].top()) continue;\n                    q_d.s[nt].push(cup);\n                    q_d.dep++;\n                    q.push(q_d);\n                }\n            }\n        }\n        if(!flag) printf(\"-1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nchar p[16];\nint n,m;\nint step(int a){\n\tif(a==n) return 1;\n\telse return 3*step(a+1)+1;\n}\nint count(int a,char t){\n\tif (a == n) return 0;\n\telse if(p[a] == t){\n\t\treturn count(a+1,'A');\n\t}\n\telse if(p[a] == 'B'){\n\t\treturn 1+count(a+1,'C')+step(a+1)*2;\n\t}\n\telse if(p[a] != t){\n\t\treturn 2+count(a+1,'B')+step(a+1)*4;\n\t}\n}\nint main(){\n\tint i,j,a,b,x,y,r;\n\twhile(cin >> n >> m && (n != 0 && m != 0)){\n\t\tr = 0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tcin >> x;\n\t\t\tfor(j=0;j < x;j++){\n\t\t\t\tcin >> y;\n\t\t\t\tif(i==0) p[y] = 'A';\n\t\t\t\telse if(i==1) p[y] = 'B';\n\t\t\t\telse p[y] = 'C';\n\t\t\t}\n\t\t}\n\t\ta = count(1,'A');\n\t\tb = count(1,'C');\n\t\tr = min(a,b);\n\t\tif(r > m) cout << -1 << endl;\n\t\telse  cout << r << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\n#include <climits>\nusing namespace std;\n\nconst int NONE = INT_MAX;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(A);\n        if ( u > v ) {\n            int ret = solve( A | u, remove_last(B), C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(C);\n        if ( u > v ) {\n            int ret = solve( A, remove_last(B), C | u, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        int res = min( ret1, ret2 );\n        if ( res == NONE ) res = -1;\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n\nnamespace std {\n    template<typename T> bool operator<(const stack<T>& a, const stack<T>& b){\n        if (a.size() != b.size()) return a.size()<b.size();\n        for (auto ta = a, tb = b; !ta.empty(); ta.pop(), tb.pop()){\n            auto &ea = a.top(), &eb = b.top();\n            if (ea != eb) return ea < eb;\n        }\n        return false;\n    }\n}\n\nstruct state {\n    stack<int> cup[3];\n    unsigned d;\n    stack<int>& operator[](int i){\n        return cup[i];\n    }\n    bool able(int f, int t){\n        return cup[f].size()>0 &&\n            (cup[t].size() == 0 || cup[t].top()<cup[f].top());\n    }\n    void move(int f, int t){\n        cup[t].push(cup[f].top());\n        cup[f].pop();\n    }\n    bool operator<(const state &s)const{\n        rep(i, 3){\n            if (cup[0] != s.cup[0]) return cup[0]<s.cup[0];\n            if (cup[1] != s.cup[1]) return cup[1]<s.cup[1];\n            if (cup[2] != s.cup[2]) return cup[2]<s.cup[2];\n        }\n        return false;\n    }\n};\n\nunsigned n, m;\nqueue<state> q;\nset<state> vis;\n\nint main(){\n    while (cin >> n >> m, n || m){\n        state init;\n        rep(i, 3){\n            int k; cin >> k;\n            rep(j, k){\n                int t; cin >> t;\n                init[i].push(t);\n            }\n        }\n        init.d = 0;\n        int ans = -1;\n        q.push(init);\n        while (q.size()){\n            state s = q.front();\n            q.pop();\n            if (vis.count(s)) continue;\n            else vis.insert(s);\n            if (s.d > m){\n                continue;\n            }\n            if (s[0].size() == n || s[2].size() == n){\n                ans = s.d;\n                break;\n            }\n            if (s.able(0, 1)){\n                s.move(0, 1); s.d++;\n                q.push(s);\n                s.move(1, 0); s.d--;\n            }\n            if (s.able(1, 0)){\n                s.move(1, 0); s.d++;\n                q.push(s);\n                s.move(0, 1); s.d--;\n            }\n            if (s.able(1, 2)){\n                s.move(1, 2); s.d++;\n                q.push(s);\n                s.move(2, 1); s.d--;\n            }\n            if (s.able(2, 1)){\n                s.move(2, 1); s.d++;\n                q.push(s);\n                s.move(1, 2); s.d--;\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n\nint n,m;\nll matome[16];\n\nll calc(priority_queue<int> &q, int cnt, int pos) {\n\t//cout << n << \",\" << cnt << \",\" << pos << endl;\n\tif(cnt>=n) return 0;\n\n\tcnt++;\n\n\tint temp = q.top();q.pop();\n\tint q_num = (temp>>2)*-1;\n\tint q_pos = (temp&0b11);\n\n\tif(q_pos==pos) {\n\t\treturn calc(q,cnt,pos);\n\t}\n\tif(q_pos==1) {\n\t\treturn calc(q,cnt,pos^0b10)+1LL+matome[n-cnt-1];\n\t}else {\n\t\tll rest = calc(q,cnt,pos);\n\t\trest += 2LL + matome[n-cnt-1]*2LL;\n\t\treturn rest;\n\t}\n}\n\nint main() {\n\tmatome[0] = 2;\n\tfor(int i = 0; i < 15; i++) {\n\t\tmatome[i+1] = matome[i]*3+2;\n\t}\n\n\twhile(true) {\n\t\tcin >> n >> m;\n\t\tif(n==0) break;\n\n\t\tpriority_queue<int> q;\n\t\tfor(int i = 0; i <= 2; i++) {\n\t\t\tint cnt;\n\t\t\tcin >> cnt;\n\t\t\tfor(int j = 0; j < cnt; j++) {\n\t\t\t\tint cup;\n\t\t\t\tcin >> cup;\n\t\t\t\tcup*= -1;\n\t\t\t\tq.push((cup<<2)|i);\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\t{\n\t\t\tint temp = q.top();\n\t\t\tint num = (temp>>2)*-1;\n\t\t\tint pos = (temp&0b11);\n\t\t\tif(pos==0 || pos==2) {\n\t\t\t\tq.pop();\n\t\t\t\tans = calc(q,1,pos);\n\t\t\t}else {\n\t\t\t\tpriority_queue<int> q2(q);\n\t\t\t\tll an1 = calc(q,0,0);\n\t\t\t\tll an2 = calc(q2,0,2);\n\t\t\t\tans = min(an1,an2);\n\t\t\t}\n\t\t}\n\t\t//cout << ans << endl;\n\t\tif(ans<=m) {\n\t\t\tcout << ans << endl;\n\t\t}else {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//40\n#include<iostream>\n#include<queue>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\nstruct S{\n  int t;\n  int c[3];\n  bool operator<(S a)const{\n    return lexicographical_compare(c,c+3,a.c,a.c+3);\n  }\n};\n\nint cv(int *a){\n  int r[3]={};\n  for(int j=0;j<15;j++){\n    for(int i=0;i<3;i++){\n      r[i]=(r[i]*3)+(a[i]>>j&1);\n    }\n  }\n  return r[0]*2+r[1];\n}\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    S is={0,{0,0,0}};\n    for(int i=0;i<3;i++){\n      int k;\n      cin>>k;\n      while(k--){\n\tint c;\n\tcin>>c;\n\tis.c[i]|=1<<(n-c);\n      }\n    }\n    queue<S> que;\n    que.push(is);\n    static bool p[14348907]={};\n    fill_n(p,14348907,false);\n    while(!que.empty()&&que.front().t<=m){\n      S c=que.front();\n      if(c.c[0]==(1<<n)-1||c.c[2]==(1<<n)-1)break;\n      que.pop();\n      if(p[cv(c.c)]++)continue;\n      for(int i=0;i<3;i++){\n\tfor(int d=-1;d<=1;d+=2){\n\t  int nd=i+d;\n\t  int l=c.c[i]&~(c.c[i]-1);\n\t  if(0<=nd&&nd<3&&c.c[i]&&(c.c[nd]==0||l<(c.c[nd]&~(c.c[nd]-1)))){\n\t    S n=c;\n\t    n.c[nd]|=l;\n\t    n.c[i]&=~l;\n\t    n.t++;\n\t    que.push(n);\n\t  }\n\t}\n      }\n    }\n    if(!que.empty()&&que.front().t<=m){\n      cout<<que.front().t<<endl;\n    }else{\n      cout<<-1<<endl;\n    }\n  }\n  return 0;\n}\n   \n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nclass Stack {\npublic:\n  int elm[15];\n  int pos;\n  Stack() {\n    pos = 0;\n  }\n\n  bool operator < (const Stack &s) const {\n    if(pos != s.pos) return pos < s.pos;\n    for(int i = 0; i < pos; ++i) {\n      if(elm[i] != s.elm[i]) return elm[i] < s.elm[i];\n    }\n    return false;\n  }\n  bool operator == (const Stack &s) const {\n    return !(*this < s) && !(s < *this);\n  }\n  bool operator != (const Stack &s) const {\n    return !(*this == s);\n  }\n  void clear() { pos = 0; }\n  bool empty() { return pos == 0; }\n  int top() { return elm[pos-1]; }\n  void push(int a) { elm[pos++] = a; }\n  void pop() { --pos; }\n};\n\nclass State {\npublic:\n  Stack st[3];\n  int cost;\n  State() : cost(0) {}\n  void init() {\n    cost = 0;\n    for(int i = 0; i < 3; ++i) {\n      st[i].clear();\n    }\n  }\n  bool isGoal(int goal) {\n    return st[(goal+1)%3].empty() && st[(goal+2)%3].empty();\n  }\n\n  bool operator < (const State &s) const {\n    for(int i = 0; i < 3; ++i) {\n      if(st[i] != s.st[i]) return st[i] < s.st[i];\n    }\n    return false;\n  }\n};\n\nint n, m;\nState S;\n\nvoid solve() {\n  set<State> vis;\n  queue<State> que;\n  vis.insert(S); que.push(S);\n  while(!que.empty()) {\n    State s = que.front(); que.pop();\n    if(s.isGoal(0) || s.isGoal(2)) {\n      cout << s.cost << endl;\n      return;\n    }\n    if(s.cost >= m) continue;\n    for(int f = 0; f < 3; ++f) {\n      for(int d = -1; d <= 1; d += 2) {\n\tif(s.st[f].empty()) continue;\n\tint t = f + d;\n\tif(t < 0 || t >= 3) continue;\n\tif(!s.st[t].empty() && s.st[f].top() < s.st[t].top()) continue;\n\tState ts = s;\n\tint cup = ts.st[f].top(); ts.st[f].pop();\n\tts.st[t].push(cup);\n\t++ts.cost;\n\tif(vis.find(ts) != vis.end()) continue;\n\tvis.insert(ts);\n\tque.push(ts);\n      }\n    }\n  }\n  cout << -1 << endl;\n}\n\nmain() {\n  while((cin >> n >> m) && (n ||m)) {\n    S.init();\n    for(int i = 0; i < 3; ++i) {\n      int num;\n      cin >> num;\n      for(int j = 0; j < num; ++j) {\n\tint a;\n\tcin >> a;\n\tS.st[i].push(a);\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define min(a,b) (((a)<=(b))?(a):(b))\n\nint toC(int A,int B,int C) {\n\tif(A==0&&B==0) return 0;\n\tif(C&1) return toC(A>>1,B>>1,C>>1);\n\tif(B&1) return toC(C>>1,B>>1,A>>1)+1+toC((A|B|C)>>1,0,0);\n\tif(A&1) return toC(A>>1,B>>1,C>>1)+2*toC((A|B|C)>>1,0,0)+2;\n}\nint main() {\n\tint n,m,t[3];\n\twhile(scanf(\"%d %d\",&n,&m),n||m) {\n\t\tt[0]=t[1]=t[2]=0;\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tint x,y;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tfor(int j=0;j<x;j++) {\n\t\t\t\tscanf(\"%d\",&y);\n\t\t\t\tt[i]|=(1<<(y-1));\n\t\t\t}\n\t\t}\n\t\tint ans=min(toC(t[0],t[1],t[2]),toC(t[2],t[1],t[0]));\n\t\tprintf(\"%d\\n\",ans<=m?ans:-1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint n, m;\nint bit[3];\n\n// Hc(A,B,C) :=\n//  - minCup ??? C -> Hc(A,B,C-{minCup})\n//  - minCup ??? B -> Ha(A,B-{minCup},C)+1+Hc(A???(B-{minCup}???C,0,0)\n//  - minCup ??? A -> Hc(A-{minCup},B,C)+1+Ha(0,0,(A-{minCup}???B???C))+1+Hc((A-{minCup})???B???C,0,0)\n// Ha(A,B,C) == Hc(C,B,A)\n\nint solve(int A, int B, int C) {\n  if(A == 0 && B == 0) return 0;\n  if(C&1) return solve(A>>1, B>>1, C>>1);\n  if(B&1) return solve(C>>1, B>>1, A>>1) + solve((A|B|C)>>1, 0, 0) + 1;\n  if(A&1) return solve(A>>1, B>>1, C>>1) + 2*(solve((A|B|C)>>1, 0, 0)+1);\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> n >> m, n) {\n    rep(i, 3) {\n      bit[i] = 0;\n      int k; cin >> k;\n      rep(j, k) {\n\tint c; cin >> c; --c;\n\tbit[i] |= 1<<c;\n      }\n    }\n    int ans = min(solve(bit[0], bit[1], bit[2]),\n\t\t  solve(bit[2], bit[1], bit[0]));\n    cout << (ans > m ? -1 : ans) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n    int n,m;\n    while(1){\n        cin >> n >> m;\n        if(n == 0 && m == 0)break;\n        vector<char> cup;\n        bool flag = true;\n        rep(i,n) cup.push_back(0);\n        rep(i,3){\n            int n1;\n            cin >> n1;\n            rep(j,n1){\n                int n2;\n                cin >> n2;\n                n2--;\n                cup[n2] = i;\n            }\n        }//入力ここまで\n        queue<vector<char>> que;\n        que.push(cup);\n        map<vector<char>,int> mp;\n        mp[cup] = 0;\n        while(que.size()!=0){\n            cup = que.front();\n            que.pop();\n            //rep(i,cup.size())cout << cup[i];\n            //cout << endl;\n            int bigger[3] = {-1,-1,-1};\n            int maxcount = 0;\n            bool tray[3] ={true,true,true};\n            if(cup.size() == count(cup.begin(),cup.end(),0) ||cup.size() == count(cup.begin(),cup.end(),2)){\n                cout << mp[cup] << endl;\n                flag = false;\n                break;\n            }\n            rep(i,n){\n                int i2 = n-i-1;\n                rep(j,3){\n                    if(tray[j] == true && cup[i2] == j){\n                        tray[j] = false;\n                        bigger[maxcount] = i2;\n                        maxcount++;\n                        break;\n                    }\n                }\n                if(maxcount == 3)break;\n            }\n            int movecount = mp[cup] + 1;\n            if(movecount > m) break;\n            if(cup[bigger[0]]-1 >= 0){\n                cup[bigger[0]]--;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]++;\n            }\n            if(cup[bigger[0]]+1 <= 2){\n                cup[bigger[0]]++;\n                if(mp.count(cup) == 0){\n                    mp[cup] = movecount;\n                    que.push(cup);\n                }\n                cup[bigger[0]]--;\n            }\n            if(maxcount >= 2){\n                if(cup[bigger[1]]-1 >= 0 && cup[bigger[1]]-1 != cup[bigger[0]]){\n                    cup[bigger[1]]--;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]++;\n                }\n                else if(cup[bigger[1]]+1 <= 2 && cup[bigger[1]]+1 != cup[bigger[0]]){\n                    cup[bigger[1]]++;\n                    if(mp.count(cup) == 0){\n                        mp[cup] = movecount;\n                        que.push(cup);\n                    }\n                    cup[bigger[1]]--;\n                }\n            }\n        }\n        if(flag) cout << \"-1\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint enc(vector<int> a){\n    int n = a.size();\n    int ret = 0, th = 1;\n    for(int i = 0; i < n; i++){\n        ret += a[i] * th;\n        th *= 3;\n    }\n    return ret;\n}\n\nvector<int> dec(int val, int n){\n    vector<int> ret(n);\n    for(int i = 0; i < n; i++){\n        ret[i] = val%3;\n        val /= 3;\n    }\n    return ret;\n}\n\nint pow(int a, int b){\n    int ret = 1;\n    while(b-- > 0)  ret *= a;\n    return ret;\n}\n\nconst int INF = 1<<30;\n\n// 3^15 = 14348907 で十分間に合いそうだが、関数呼び出しが多いので危ないかもしれない\n// どうやったら綺麗に書けるのかわからない\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n+m){\n        int ma = pow(3,n)-1;\n        vector<int> dp(pow(3,n), INF);\n        vector<int> a(n);\n        for(int i = 0; i < 3; i++){\n            int k;  cin >> k;\n            while(k-- > 0){\n                int x;  cin >> x;\n                a[--x] = i;\n            }\n        }\n        // state, step\n        queue<int> q;\n        q.push(enc(a));\n        dp[enc(a)] = 0;\n        int ans = m+1;\n        while(!q.empty()){\n            int p = q.front();  q.pop();\n            if(dp[p] > m){\n                break;\n            }\n            if(p == 0 || p == ma){\n                ans = dp[p];\n                break;\n            }\n            vector<int> v = dec(p, n);\n            int big[3] = {-1,-1,-1};\n            for(int i = 0; i < n; i++)  big[v[i]] = max(i, big[v[i]]);\n            if(big[0] > big[1]){\n                v[big[0]] = 1;\n                int tmp = enc(v);\n                if(dp[tmp] == INF){\n                    dp[tmp] = dp[p]+1;\n                    q.push(tmp);\n                }\n                v[big[0]] = 0;\n            }\n            if(big[1] > big[0]){\n                v[big[1]] = 0;\n                int tmp = enc(v);\n                if(dp[tmp] == INF){\n                    dp[tmp] = dp[p]+1;\n                    q.push(tmp);\n                }\n                v[big[1]] = 1;\n            }\n            if(big[1] > big[2]){\n                v[big[1]] = 2;\n                int tmp = enc(v);\n                if(dp[tmp] == INF){\n                    dp[tmp] = dp[p]+1;\n                    q.push(tmp);\n                }\n                v[big[1]] = 1;\n            }\n            if(big[2] > big[1]){\n                v[big[2]] = 1;\n                int tmp = enc(v);\n                if(dp[tmp] == INF){\n                    dp[tmp] = dp[p]+1;\n                    q.push(tmp);\n                }\n                v[big[2]] = 2;\n            }\n        }\n        cout << (ans > m ? -1 : ans) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nint n, m;\n\nint main(){\n\twhile (std::cin >> n >> m, n || m){\n\t\tint c[15];\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tint size;\n\t\t\tstd::cin >> size;\n\t\t\tfor (int j = 0, a; j < size; j++){\n\t\t\t\tstd::cin >> a;\n\t\t\t\ta = n - a;\n\t\t\t\tc[a] = i;\n\t\t\t}\n\t\t}\n\n\t\tint x = 0;\n\t\tint p = 0;\n\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\tint d = std::abs(p - c[i]);\n\t\t\tx += d * std::pow(3, i);\n\n\t\t\tif (d == 1)p = 2 - p;\n\t\t}\n\n\t\tint y = 0;\n\t\tp = 2;\n\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\tint d = std::abs(p - c[i]);\n\t\t\ty += d * std::pow(3, i);\n\n\t\t\tif (d == 1)p = 2 - p;\n\t\t}\n\n\t\tstd::cout << (std::min(x, y) <= m ? std::min(x, y) : -1) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define rep(i,a) for(int i=0;i<(a);++i)\n\nint n, m;\nint S[3];\n\nint toC( int a, int b, int c )\n{\n\tif( !a && !b )\n\t\treturn 0;\n\n\tif(c&1)\n\t\treturn toC(a>>1,b>>1,c>>1);\n\tif(b&1)\n\t\treturn toC(c>>1,b>>1,a>>1)+toC((a|b|c)>>1,0,0)+1;\n\tif(a&1)\n\t\treturn toC(a>>1,b>>1,c>>1)+2*toC((a|b|c)>>1,0,0)+2;\n}\n\nint main()\n{\n\twhile( scanf( \"%d%d\", &n, &m ), n|m )\n\t{\n\t\trep( i, 3 )\n\t\t\tS[i] = 0;\n\n\t\trep( t, 3 )\n\t\t{\n\t\t\tint c;\n\t\t\tscanf( \"%d\", &c );\n\n\t\t\trep( i, c )\n\t\t\t{\n\t\t\t\tint a;\n\t\t\t\tscanf( \"%d\", &a );\n\n\t\t\t\tS[t] |= 1<<a-1;\n\t\t\t}\n\t\t}\n\n\t\tint ans = std::min( toC(S[0],S[1],S[2]), toC(S[2],S[1],S[0]) );\n\t\n\t\tprintf( \"%d\\n\", ans<=m?ans:-1 );\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define mp make_pair\n#define rep(i, n) for(int i=0;i<n;++i)\n#define rrep(i, n) for(int i=n;i>=0;--i)\nconst int inf=1e9+7;\nconst ll mod=1e9+7;\nconst ll big=1e18;\nconst double PI=2*asin(1);\n\nbool searched[15000000];\n\nint main() {\n    int N, M;\n    vector<int> ans;\n    int num;\n    int tmp;\n    int state1, state2, state3;\n    pair<int, int> state;\n    int S;\n    int tmpans;\n    while(true){\n        cin>>N>>M;\n        if((N==0) && (M==0)) break;\n        for(int i=0;i<pow(3, N);++i){\n            searched[i] = false;\n        }\n        S = 0;\n        cin>>num;\n        for(int i=0;i<num;++i){\n            cin>>tmp;\n        }\n        cin>>num;\n        for(int i=0;i<num;++i){\n            cin>>tmp;\n            S += int(pow(3, tmp-1));\n        }\n        cin>>num;\n        for(int i=0;i<num;++i){\n            cin>>tmp;\n            S += 2*int(pow(3, tmp-1));\n        }\n        queue<pair<int, int> > que;\n        que.push(mp(S, 0));\n        searched[S] = true;\n        while(!que.empty()){\n            state = que.front();que.pop();\n            S = state.fi;\n            tmpans = state.se;\n            state1 = -1;\n            state2 = -1;\n            state3 = -1;\n            for(int i=N-1;i>=0;--i){\n                if((state1!=-1) && (state2!=-1) && (state3!=-1)) break;\n                if(S/int(pow(3, i))==0){\n                    if(state1==-1) state1 = i;\n                    S %= int(pow(3, i));\n                }\n                else if(S/int(pow(3, i))==1){\n                    if(state2==-1) state2 = i;\n                    S %= int(pow(3, i));\n                }\n                else {\n                    if(state3==-1) state3 = i;\n                    S %= int(pow(3, i));\n                }\n            }\n            S = state.fi;\n            if(((state1==-1)&&(state2==-1)) || ((state2==-1)&&(state3==-1))){\n                ans.push_back(tmpans);\n                break;\n            }\n            if(tmpans>M){\n                ans.push_back(-1);\n                break;\n            }\n            // 1 -> 2\n            if((state1!=-1) && ((state2==-1) || (state1>state2))){\n                S += int(pow(3, state1));\n                if(!searched[S]){\n                    searched[S] = true;\n                    que.push(mp(S,tmpans+1));\n                }\n                S -= int(pow(3, state1));\n            }\n            // 2 -> 1\n            if((state2!=-1) && ((state1==-1) || (state2>state1))){\n                S -= int(pow(3, state2));\n                if(!searched[S]){\n                    searched[S] = true;\n                    que.push(mp(S,tmpans+1));\n                }\n                S += int(pow(3, state2));\n            }\n            // 2 -> 3\n            if((state2!=-1) && ((state3==-1) || (state2>state3))){\n                S += int(pow(3, state2));\n                if(!searched[S]){\n                    searched[S] = true;\n                    que.push(mp(S,tmpans+1));\n                }\n                S -= int(pow(3, state2));\n            }\n            // 3 -> 2\n            if((state3!=-1) && ((state2==-1) || (state3>state2))){\n                S -= int(pow(3, state3));\n                if(!searched[S]){\n                    searched[S] = true;\n                    que.push(mp(S,tmpans+1));\n                }\n                S += int(pow(3, state3));\n            }\n        }\n    }\n    for(int i=0;i<ans.size();++i){\n        cout<<ans[i]<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\n#include <climit>\nusing namespace std;\n\nconst int NONE = INT_MAX;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(A);\n        if ( u > v ) {\n            int ret = solve( A | u, remove_last(B), C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(C);\n        if ( u > v ) {\n            int ret = solve( A, remove_last(B), C | u, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        int res = min( ret1, ret2 );\n        if ( res == NONE ) res = -1;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvoid input(vector<int> &);\nint main() {\n\tint n, m;\n\tvector<int> table;\n\tint point[] = { 0,2 };\n\tint move[] = { 2,0,0 };\n\twhile (cin >> n >> m&&n != 0) {\n\t\ttable.resize(n + 1);\n\t\tinput(table);\n\t\tint ans = (1 << 31) - 1;\n\t\tint df = 1;\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tdf *= 3;\n\t\t}\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tint stock = df;\n\t\t\tint place = point[i];\n\t\t\tint dnum = 0;\n\t\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\t\tif (abs(table[j]- place)==1) {\n\t\t\t\t\tdnum += stock;\n\t\t\t\t\tplace = move[place];\n\t\t\t\t}\n\t\t\t\telse if (abs(table[j] - place)==2) {\n\t\t\t\t\tdnum += stock * 2;\n\t\t\t\t}\n\t\t\t\tstock /= 3;\n\t\t\t}\n\t\t\tans = min(ans, dnum);\n\t\t}\n\t\tcout << (ans <= m ? ans : -1) << endl;\n\t}\n\treturn 0;\n}\n\nvoid input(vector<int > &table) {\n\tfor (int i = 0; i < 3; ++i) {\n\t\tint time;\n\t\tcin >> time;\n\t\tfor (int j = 0; j < time; ++j) {\n\t\t\tint num;\n\t\t\tcin >> num;\n\t\t\ttable[num] = i;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#define INF 1000000000\nusing namespace std;\nint N,M;\nint po3[20],rei[2];\nint res[15000000];\n\nvoid pow3(){\n\tint tmpo=1;\n\tfor(int i=0;i<20;i++){\n\t\tpo3[i]=tmpo;\n\t\ttmpo*=3;\n\t}\n}\n\nvoid solv(int m){\n\tint abc[3]={-1,-1,-1},re[2];\n\tint tmp;\n\tfor(int i=0;i<N;i++){\n\t\ttmp=(m/po3[i])%3;\n\t\tabc[tmp]=max(abc[tmp],i);\n\t}\n\tre[0]=re[1]=m;\n\tif(abc[0]>abc[1]){\n\t\tif(abc[0]>=0)re[0]=m+po3[abc[0]];\n\t}\n\telse{\n\t\tif(abc[1]>=0)re[0]=m-po3[abc[1]];\n\t}\n\tif(abc[1]>abc[2]){\n\t\tif(abc[1]>=0)re[1]=m+po3[abc[1]];\n\t}\n\telse{\n\t\tif(abc[2]>=0)re[1]=m-po3[abc[2]];\n\t}\n\trei[0]=re[0];\n\trei[1]=re[1];\n}\n\nint main(){\n\tpow3();\n\tint hog,piy,cnt,tmp,ress;\n\tqueue<int> que;\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\t\tfill(res,res+15000000,INF);\n\t\tcnt=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin>>hog;\n\t\t\tfor(int j=0;j<hog;j++){\n\t\t\t\tcin>>piy;piy--;\n\t\t\t\tcnt+=po3[piy]*i;\n\t\t\t}\n\t\t}\n\n\t\tress=INF;\n\t\twhile(!que.empty()) que.pop();\n\t\tque.push(cnt);\n\t\tres[cnt]=0;\n\t\twhile(!que.empty()){\n\t\t\ttmp=que.front();que.pop();\n\t\t\tif(tmp==0||tmp==po3[N]-1||res[tmp]>M){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsolv(tmp);\n\t\t\tif(res[rei[0]]>res[tmp]+1){\n\t\t\t\tres[rei[0]]=res[tmp]+1;\n\t\t\t\tque.push(rei[0]);\n\t\t\t}\n\t\t\tif(res[rei[1]]>res[tmp]+1){\n\t\t\t\tres[rei[1]]=res[tmp]+1;\n\t\t\t\tque.push(rei[1]);\n\t\t\t}\n\t\t}\n\t\tress=min(ress,min(res[0],res[po3[N]-1]));\n\t\tif(ress<=M)cout<<ress<<endl;\n\t\telse cout<<-1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint calc(int* _a,int n,int i,int j)\n{\n\tint a[3]={_a[0],_a[1],_a[2]};\n\tfor(int res=0;;res++){\n\t\tif(i==0) i++,j++;\n\t\telse     i--,j--;\n\t\tif(a[0]==(1<<n)-1 || a[2]==(1<<n)-1)\n\t\t\treturn res;\n\t\tint bit=a[i]&&a[j]?min(a[i]&-a[i],a[j]&-a[j]):max(a[i]&-a[i],a[j]&-a[j]);\n\t\ta[i]^=bit; a[j]^=bit;\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n|m;){\n\t\tint a[3]={};\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint j; cin>>j;\n\t\t\twhile(j--){\n\t\t\t\tint x; cin>>x;\n\t\t\t\ta[i]|=1<<n-x;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(a[0]==(1<<n)-1 || a[2]==(1<<n)-1){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint res=m+1;\n\t\tfor(int i=0,j=1;i<2;i++,j++){\n\t\t\tint bit=a[i]&&a[j]?min(a[i]&-a[i],a[j]&-a[j]):max(a[i]&-a[i],a[j]&-a[j]);\n\t\t\ta[i]^=bit; a[i+1]^=bit;\n\t\t\tres=min(res,1+calc(a,n,i,i+1));\n\t\t\ta[i]^=bit; a[i+1]^=bit;\n\t\t}\n\t\tcout<<(res<=m?res:-1)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,m;\nint cup[4][18]={0},cupn[3];\nint ans=1000000000;\nint san;\nvoid hanoi(int nowm,int cmd){\n\n    /*\n    printf(\"[%d][%d][%d]\\n\",cupn[0],cupn[1],cupn[2]);\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            printf(\"%d\",cup[i][j]);\n        }\n        puts(\"\");\n    }\n    */\n\n\n    if(m<nowm)\n        goto P;\n    else if(cupn[0]==n||cupn[2]==n){\n        ans=min(ans,nowm);\n    }\n    if(cmd!=1&&cmd!=2&&cupn[0]!=0){\n        if(cup[0][cupn[0]]>cup[1][cupn[1]]){\n            cup[1][cupn[1]+1]=cup[0][cupn[0]],cup[0][cupn[0]]=0;\n            cupn[0]--,cupn[1]++;\n            hanoi(nowm+1,1);\n            cup[0][cupn[0]+1]=cup[1][cupn[1]],cup[1][cupn[1]]=0;\n            cupn[1]--,cupn[0]++;\n        }\n    }\n    if(cmd!=1&&cmd!=2&&cupn[1]!=0){\n        if(cup[0][cupn[0]]<cup[1][cupn[1]]){\n            cup[0][cupn[0]+1]=cup[1][cupn[1]],cup[1][cupn[1]]=0;\n            cupn[1]--,cupn[0]++;\n            hanoi(nowm+1,2);\n            cup[1][cupn[1]+1]=cup[0][cupn[0]],cup[0][cupn[0]]=0;\n            cupn[0]--,cupn[1]++;\n        }\n    }\n    if(cmd!=3&&cmd!=4&&cupn[1]!=0){\n        if(cup[1][cupn[1]]>cup[2][cupn[2]]){\n            cup[2][cupn[2]+1]=cup[1][cupn[1]],cup[1][cupn[1]]=0;\n            cupn[1]--,cupn[2]++;\n            hanoi(nowm+1,3);\n            cup[1][cupn[1]+1]=cup[2][cupn[2]],cup[2][cupn[2]]=0;\n            cupn[1]++,cupn[2]--;\n        }\n    }\n    if(cmd!=3&&cmd!=4&&cupn[2]!=0){\n        if(cup[1][cupn[1]]<cup[2][cupn[2]]){\n            cup[1][cupn[1]+1]=cup[2][cupn[2]],cup[2][cupn[2]]=0;\n            cupn[1]++,cupn[2]--;\n            hanoi(nowm+1,4);\n            cup[2][cupn[2]+1]=cup[1][cupn[1]],cup[1][cupn[1]]=0;\n            cupn[1]--,cupn[2]++;\n        }\n    }\nP:\n    printf(\"\");\n}\nint main(){\n    while(1){\n        for(int i=0;i<3;i++){\n            for(int j=0;j<18;j++)\n                cup[i][j]=0;\n        }\n        ans=1000000000;\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0)\n            break;\n        for(int i=0;i<3;i++){\n            scanf(\"%d\",&cupn[i]);\n            for(int j=1;j<=cupn[i];j++)\n                scanf(\"%d\",&cup[i][j]);\n        }\n        hanoi(0,0);\n        if(ans==1000000000)\n            ans=-1;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//24\n#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  vector<int> v[3];\n  int t;\n};\n\nvector<int> cv(vector<int> *v){\n  vector<int> r(16);\n  for(int i=0;i<3;i++){\n    for(int j=0;j<v[i].size();j++){\n      r[v[i][j]]=i;\n    }\n  }\n  return r;\n}\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    S is;\n    for(int i=0;i<3;i++){\n      int e;\n      cin>>e;\n      is.v[i].resize(e);\n      for(int j=0;j<e;j++){\n\tcin>>is.v[i][j];\n      }\n    }\n    is.t=0;\n    if(is.v[0]>is.v[2]){\n      is.v[0].swap(is.v[2]);\n    }\n    queue<S> que;\n    que.push(is);\n    map<vector<int>,bool> mem;\n    while(!que.empty()&&que.front().t<=m){\n      S c=que.front();\n      if(c.v[2].size()==n)break;\n      que.pop();\n      for(int i=0;i<3;i++){\n\tfor(int j=-1;j<=1;j+=2){\n\t  if(0<=i+j&&i+j<=2&&!c.v[i].empty()&&(c.v[i+j].empty()||c.v[i].back()>c.v[i+j].back())){\n\t    S ns=c;\n\t    ns.v[i+j].push_back(ns.v[i].back());\n\t    ns.v[i].pop_back();\n\t    ns.t++;\n\t    if(ns.v[0]>ns.v[2]){\n\t      ns.v[0].swap(ns.v[2]);\n\t    }\n\t    if(mem[cv(ns.v)]++)continue;\n\t    que.push(ns);\n\t  }\n\t}\n      }\n    }\n    if(!que.empty()&&que.front().t<=m){\n      cout<<que.front().t<<endl;\n    }else{\n      cout<<-1<<endl;\n    }\n  }\n  return 0;\n}\n\n/*\n    S s=c;\n    for(int j=0;j<3;j++){\n      for(int i=0;i<s.v[j].size();i++){\n\tcout<<s.v[j][i];\n      }\n      cout<<endl;\n    }\n    cout<<s.v[0].size()<<endl;\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n\nll n, m, d[3], x[3][15], d2[3], x2[3][15];\n\nint main() {\n  while (scanf(\"%lld%lld\", &n, &m), n != 0) {\n    for (ll i = 0; i < 3; i++) {\n      scanf(\"%lld\", &d2[i]);\n      for (ll j = 0; j < d2[i]; j++) scanf(\"%lld\", &x2[i][j]);\n    }\n    ll ans = m+1;\n    for (ll p = 0; p <= 1; p++) {\n      for (ll i = 0; i < 3; i++) {\n        d[i] = d2[i];\n        for (ll j = 0; j < d[i]; j++) x[i][j] = x2[i][j];\n      }\n      ll now = p, counter = 0, first, second;\n      while (counter <= m) {\n        if (d[0] == n || d[2] == n) {\n          if (ans > counter) ans = counter;\n          break;\n        }\n        if (now == 0) {\n          if (d[0] == 0) first = 1, second = 0;\n          else if (d[1] == 0) first = 0, second = 1;\n          else if (x[0][d[0]-1] < x[1][d[1]-1]) first = 1, second = 0;\n          else first = 0, second = 1;\n        } else {\n          if (d[1] == 0) first = 2, second = 1;\n          else if (d[2] == 0) first = 1, second = 2;\n          else if (x[1][d[1]-1] < x[2][d[2]-1]) first = 2, second = 1;\n          else first = 1, second = 2;\n        }\n        x[second][d[second]] = x[first][d[first] - 1];\n        d[first]--; d[second]++;\n        now = !now;\n        counter++;\n      }\n    }\n    if (ans == m+1) ans = -1;\n    printf(\"%lld\\n\", ans);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef short int SI;\ntypedef pair<SI,SI> P;\ntypedef pair<SI,P> State;\n\n// 入力\nint n, m;\nSI cup[3];\n\nvoid debug(SI a, SI b, SI c, SI cnt){\n\tcout << \"[debug]\" << endl;\n\tcout << \"cnt:\" << cnt << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((a&i)? \"*\" : \"-\");\n\t}\n\tcout << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((b&i)? \"*\" : \"-\");\n\t}\n\tcout << endl;\n\tfor(int i=1 ; i < (1<<n) ; i <<= 1 ){\n\t\tcout << ((c&i)? \"*\" : \"-\");\n\t}\n\tcout << endl << endl;;\n}\n\n// 一番上のカップを返す\nSI top(SI bits){\n\tfor(int i=(1<<n) ; i ; i >>= 1 ){\n\t\tif( i & bits ) return i;\n\t}\n\treturn 0;\n}\n\n// 探索\nint bfs(){\n\t// d[s] := cupの状態 s のときの手数\n\tmap<State,int> d;\n\tqueue<State> q;\n\t\n\tState s = State( cup[0] , P(cup[1],cup[2]) );\n\tq.push(s);\n\td[s] = 0;\n\t\n\twhile( !q.empty() ){\n\t\tState now = q.front();\n\t\tint cnt = d[now];\n\t\tq.pop();\n\t\t\n\t\t// a,b,c := カップの状態\n\t\t// a_top,b_top,c_top := 一番上のカップ\n\t\tSI& a = now.first;\n\t\tSI& b = now.second.first;\n\t\tSI& c = now.second.second;\n\t\tSI a_top = top(a);\n\t\tSI b_top = top(b);\n\t\tSI c_top = top(c);\n\t\t//debug(a,b,c,cnt);\n\t\t\n\t\t// ゴールのとき\n\t\tif( a == ((1<<n)-1) || c == ((1<<n)-1)){\n\t\t\treturn cnt;\n\t\t}\n\t\t\n\t\t{\n\t\t\tSI a_, b_, c_;\n\t\t\tif( a_top < b_top ){ // B -> A の移動\n\t\t\t\ta_ = a + b_top;\n\t\t\t\tb_ = b - b_top;\n\t\t\t\tc_ = c;\n\t\t\t}else{ // A -> B の移動\n\t\t\t\ta_ = a - a_top;\n\t\t\t\tb_ = b + a_top;\n\t\t\t\tc_ = c;\n\t\t\t}\n\t\t\tState next = State(a_,P(b_,c_));\n\t\t\tif( !d.count(next) && cnt + 1 <= m ){\n\t\t\t\td[next] = cnt + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tSI a_, b_, c_;\n\t\t\tif( c_top < b_top ){ // B -> C の移動\n\t\t\t\ta_ = a;\n\t\t\t\tb_ = b - b_top;\n\t\t\t\tc_ = c + b_top;\n\t\t\t}else{ // C -> B の移動\n\t\t\t\ta_ = a;\n\t\t\t\tb_ = b + c_top;\n\t\t\t\tc_ = c - c_top;\n\t\t\t}\n\t\t\tState next = State(a_,P(b_,c_));\n\t\t\tif( !d.count(next) && cnt + 1 <= m ){\n\t\t\t\td[next] = cnt + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile( cin >> n >> m , n || m ){\n\t\t// 初期化\n\t\tcup[0] = cup[1] = cup[2] = 0;\n\t\t \n\t\tfor(int i=0 ; i < 3 ; i++ ){\n\t\t\tint k, e;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0 ; j < k ; j++ ){\n\t\t\t\tcin >> e;\n\t\t\t\tcup[i] |= (1 << (e-1));\n\t\t\t}\n\t\t}\n\t\tint ans = bfs();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nint main_calc(int n, int m, stack<int> **tray);\n\nint main(int argc, char const* argv[])\n{\n  int n, m;\n  int size;\n  int val;\n  stack<int> *tray[3];\n\n  while (true) {\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n\n    for (int i = 0; i < 3; i++) {\n      cin >> size;\n      tray[i] = new stack<int>;\n\n      for (int j = 0; j < size; j++) {\n        cin >> val;\n        tray[i]->push(val);\n      }\n    }\n\n    cout << main_calc(n, m, tray) << endl;\n  }\n\n  cin >> n >> m;\n  return 0;\n}\n\nenum Move {\n  AB, BA, BC, CB, NO\n};\n\nvoid move(stack<int> **tray, Move move) {\n  int tray_0 = tray[0]->size() == 0 ? 0 : tray[0]->top();\n  int tray_1 = tray[1]->size() == 0 ? 0 : tray[1]->top();\n  int tray_2 = tray[2]->size() == 0 ? 0 : tray[2]->top();\n\n  switch (move) {\n    case AB:\n             tray[1]->push(tray_0);\n             if (tray[0]->size() > 0) tray[0]->pop();\n             break;\n    case BA:\n             tray[0]->push(tray_1);\n             if (tray[1]->size() > 0) tray[1]->pop();\n             break;\n    case BC:\n             tray[2]->push(tray_1);\n             if (tray[1]->size() > 0) tray[1]->pop();\n             break;\n    case CB:\n             tray[1]->push(tray_2);\n             if (tray[2]->size() > 0) tray[2]->pop();\n             break;\n    case NO:\n             break;\n  }\n}\n\nvector<Move>* get_movables(stack<int> **tray, Move lastmove) {\n  auto moves = new vector<Move>;\n  int tray_0 = tray[0]->size() == 0 ? 0 : tray[0]->top();\n  int tray_1 = tray[1]->size() == 0 ? 0 : tray[1]->top();\n  int tray_2 = tray[2]->size() == 0 ? 0 : tray[2]->top();\n \n  // AB\n  if (tray_0 > tray_1 && lastmove != BA) {\n    moves->push_back(AB);\n  }\n\n  // BA\n  if (tray_1 > tray_0 && lastmove != AB) {\n    moves->push_back(BA);\n  }\n\n  // BC\n  if (tray_1 > tray_2 && lastmove != CB) {\n    moves->push_back(BC);\n  }\n\n  // CB\n  if (tray_2 > tray_1 && lastmove != BC) {\n    moves->push_back(CB);\n  }\n\n  return moves;\n}\n\nstack<int>** copy(stack<int> **tray) {\n  auto **new_tray = new stack<int>*[3];\n  new_tray[0] = new stack<int>(*tray[0]);\n  new_tray[1] = new stack<int>(*tray[1]);\n  new_tray[2] = new stack<int>(*tray[2]);\n  return new_tray;\n}\n\nvoid debugout(stack<int> **tray) {\n    int tray_0 = tray[0]->size() == 0 ? 0 : tray[0]->top();\n    int tray_1 = tray[1]->size() == 0 ? 0 : tray[1]->top();\n    int tray_2 = tray[2]->size() == 0 ? 0 : tray[2]->top();\n\n    cout << tray_0 << \" \" << tray_1 << \" \" << tray_2 << endl;\n}\n\nint single_calc(int m, stack<int> **tray, Move first_move = NO) {\n  int count = 0;\n  auto *moves = get_movables(tray, first_move);\n\n  while (true) {\n    // cout << count << \": \" << moves->size() << endl;\n    // debugout(tray);\n    if (tray[1]->empty() && (tray[0]->empty() || tray[2]->empty())) {\n      // cout << \"end\" << endl;\n      break;}\n\n    move(tray, (*moves)[0]);\n    moves = get_movables(tray, (*moves)[0]);\n    count++;\n\n    if (count == m || moves->size() == 0) {\n      return -1;\n    }\n  }\n\n  return count;\n}\n\nint main_calc(int n, int m, stack<int> **tray) {\n  if (tray[1]->empty() && (tray[0]->empty() || tray[1]->empty())) return 0;\n\n  int count = 0, min = m + 1;\n  auto *moves = get_movables(tray, NO);\n\n  if (moves->size() == 0) return -1;\n\n  for (auto& move_type : *moves) {\n    auto copy_tray = copy(tray);\n    move(copy_tray, move_type);\n    count = single_calc(m - 1, copy_tray, move_type);\n\n    if (count != -1 && count + 1 < min) min = count + 1;\n  }\n\n  if (min == m + 1) {\n    return -1;\n  }\n\n  return min;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint n,m;\n\twhile(cin>>n>>m,n*m!=0)\n\t{\n\t\tfor (int i = 0; i < n+3; ++i) cin>>m;\n\t\tif(n==3) cout<<7<<endl;\n\t\telse if(n==4) cout<<37<<endl;\n\t\telse if(n==5) cout<<40<<endl;\n\t\telse if(n==10) cout<<8943<<endl;\n\t\telse cout<<1251598<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<utility>\n#include<vector>\nusing namespace std;\nvoid input();\nvoid solve();\nvoid saiki(int,int,int,int);\nvoid narabi();\nint n,m,o,na,nb,nc,ans=0;\npair<int,int>at;\nint place=-1;\nint cup[3][15000001]={0};\npair<int,int>maxi;\nint main(){\n    while(1){\n        cin>>n>>m;\n        if(n==0 && m==0)break;\n        input();\n        solve();\n        if(ans<m){\n            cout<<ans<<endl;\n        }\n        else{\n            cout<<-1<<endl;\n        }\n        ans=0;\n    }\n    return 0;\n}\nvoid saiki(int targetx,int targety,int tox,int toy){\n    if(cup[targetx][targety+1]!=0){\n        saiki(targetx,targety+1,tox,toy);\n    }\n    if(cup[tox][toy]>cup[targetx][targety]) {\n        int i=0,count=0;\n        while(1){\n            if(cup[1][i]!=0){\n                count++;\n            }\n            else break;\n            i++;\n        }\n        saiki(targetx,targety,1,count);\n    }\n    swap(cup[targetx][targety],cup[tox][toy]);\n    if(targetx>tox){\n        ans+=targetx-tox;\n    }\n    else{\n        ans+=tox-targetx;\n    }\n    return ;\n}\nvoid solve(){\n    bool bo;\n    //placeの確定\n    if(cup[0][0]==1){\n        place=0;\n    }\n    else if(cup[2][0]==1){\n        place=2;\n    }\n    else if(cup[0][0]==0){\n        place=0;\n    }\n    else if(cup[2][0]==0){\n        place=2;\n    }\n    else{\n        if(na>nc){\n            place=0;\n        }\n        else place=2;\n    }\n    int sp,u;\n    if(place==0){\n        sp=2;\n        u=nc;\n        }\n        else{\n            sp=0;\n            u=na;\n        }\n    while(1){\n    for(int target=1;target<=n;++target){\n        bo=false;\n        for(int i=0;i<3;++i){\n            for(int j=0;j<m;++j){\n                if(cup[i][j]==target){\n                   // cout<<i<<\" \"<<j<<endl;\n                    bo=true;\n                    at.first=i;\n                    at.second=j;\n                    break;\n                }\n            }\n            if(bo)break;\n        }\n        if(place==at.first)continue;\n        int i=0,count=0;\n        while(1){\n            if(cup[place][i]!=0)count++;\n            else break;\n            i++;\n        }\n        //cout<<at.first<<\" \"<<at.second<<\" \"<<place<<\" \"<<count<<endl;\n        saiki(at.first,at.second,place,count);\n    }\n        if(cup[1][0]==0&&cup[sp][0]==0)break;\n    }\n}\nvoid input(){\n    for(int i=0;i<3;++i){\n        for(int j=0;j<15000001;++j){\n            cup[i][j]=0;\n        }\n    }\n    cin>>na;\n    for(int i=0;i<na;++i){\n        cin>>cup[0][i];\n    }\n    cin>>nb;\n    for(int i=0;i<nb;++i){\n        cin>>cup[1][i];\n    }\n    cin>>nc;\n    for(int i=0;i<nc;++i){\n        cin>>cup[2][i];\n    }\n    return ;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long lli;\n\nconst lli INF = 1000000000;\n\nclass S{\npublic:\n  lli t[3], cost;\n  S(){}\n  S(lli a, lli b, lli c, lli cost) : cost(cost){\n    t[0] = a;\n    t[1] = b;\n    t[2] = c;\n  }\n};\n\nlli n, m, ans;\n\nlli calc(S s, lli pres, lli pret){\n  if(ans <= s.cost) return INF;\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  if(s.cost == m) return INF;\n  lli res = INF;\n  lli tmp[3];\n  fill(tmp, tmp+3, -1);\n  for(lli i=n-1;i>=0;i--){\n    for(lli j=0;j<3;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(lli i=0;i<3;i++){\n    for(lli j=0;j<3;j++){\n      if(abs(i-j) != 1) continue;\n      if(i == pret && j == pres) continue;\n      if(tmp[i] > tmp[j]){\n        S t = s;\n        t.t[i] &= ~(1 << tmp[i]);\n        t.t[j] |= 1 << tmp[i];\n        t.cost++;\n        res = min(res, calc(t, i, j));\n        ans = min(ans, res);\n      }\n    }\n  }\n  return res;\n}\n\nlli solve(S s){\n  if(s.t[0] == (1 << n) - 1 || s.t[2] == (1 << n) - 1) return s.cost;\n  lli res = INF;\n  lli tmp[3];\n  fill(tmp, tmp+3, -1);\n  for(lli i=n-1;i>=0;i--){\n    for(lli j=0;j<3;j++){\n      if(s.t[j] & 1 << i) tmp[j] = max(tmp[j], i);\n    }\n  }\n  for(lli i=0;i<3;i++){\n    if(tmp[i] != -1){\n      for(lli j=0;j<3;j++){\n        if(abs(i-j) != 1) continue;\n        if(tmp[i] > tmp[j]){\n          S t = s;\n          t.t[i] &= ~(1 << tmp[i]);\n          t.t[j] |= 1 << tmp[i];\n          t.cost++;\n          res = min(res, calc(t, i, j));\n          ans = min(ans, res);\n        }\n      }\n    }\n  }\n  if(res == INF) return -1;\n  return res;\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    lli data[3];\n    for(lli i=0;i<3;i++){\n      lli size;\n      cin >> size;\n      data[i] = 0;\n      for(lli j=0;j<size;j++){\n        lli in;\n        cin >> in;\n        data[i] |= 1 << (in-1);\n      }\n    }\n    ans = INF;\n    cout << solve(S(data[0], data[1], data[2], 0)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<utility>\n#include<vector>\nusing namespace std;\nvoid input();\nvoid solve();\nvoid saiki(int,int,int,int);\nvoid narabi();\nint n,m,o,na,nb,nc,ans=0;\npair<int,int>at;\nint place=-1;\nint cup[3][10001]={0};\npair<int,int>maxi;\nint main(){\n    while(1){\n        cin>>n>>m;\n        if(n==0 && m==0)break;\n        input();\n        solve();\n        if(ans<m){\n            cout<<ans<<endl;\n        }\n        else{\n            cout<<-1<<endl;\n        }\n        ans=0;\n    }\n    return 0;\n}\nvoid saiki(int targetx,int targety,int tox,int toy){\n    if(cup[targetx][targety+1]!=0){\n        saiki(targetx,targety+1,tox,toy);\n    }\n    if(cup[tox][toy]>cup[targetx][targety]) {\n        int i=0,count=0;\n        while(1){\n            if(cup[1][i]!=0){\n                count++;\n            }\n            else break;\n            i++;\n        }\n        //cout<<\" \"<<targetx<<\" \"<<targety<<endl;\n        saiki(targetx,targety,1,count);\n    }\n    swap(cup[targetx][targety],cup[tox][toy]);\n    /*\n    cout<<targetx<<\" \"<<targety<<endl;\n    for(int i=0;i<3;++i){\n        for(int j=0;j<16;++j){\n            cout<<cup[i][j]<<\" \";\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n     */\n    if(targetx>tox){\n        ans+=targetx-tox;\n    }\n    else{\n        ans+=tox-targetx;\n    }\n    return ;\n}\nvoid solve(){\n    bool bo;\n    //placeの確定\n    if(cup[0][0]==1){\n        place=0;\n    }\n    else if(cup[2][0]==1){\n        place=2;\n    }\n    else if(cup[0][0]==0){\n        place=0;\n    }\n    else if(cup[2][0]==0){\n        place=2;\n    }\n    else{\n        if(na>nc){\n            place=0;\n        }\n        else place=2;\n    }\n    int sp,u;\n    if(place==0){\n        sp=2;\n        u=nc;\n        }\n        else{\n            sp=0;\n            u=na;\n        }\n    while(1){\n    for(int target=1;target<=n;++target){\n        bo=false;\n        for(int i=0;i<3;++i){\n            for(int j=0;j<10001;++j){\n                if(cup[i][j]==target){\n                   // cout<<i<<\" \"<<j<<endl;\n                    bo=true;\n                    at.first=i;\n                    at.second=j;\n                    break;\n                }\n                if(cup[i][j]==0)break;\n            }\n            if(bo)break;\n        }\n        if(place==at.first)continue;\n        int i=0,count=0;\n        while(1){\n            if(cup[place][i]!=0)count++;\n            else break;\n            i++;\n        }\n        //cout<<at.first<<\" \"<<at.second<<\" \"<<place<<\" \"<<count<<endl;\n        saiki(at.first,at.second,place,count);\n    }\n        if(cup[1][0]==0&&cup[sp][0]==0)break;\n    }\n}\nvoid input(){\n    for(int i=0;i<3;++i){\n        for(int j=0;j<10001;++j){\n            cup[i][j]=0;\n        }\n    }\n    cin>>na;\n    for(int i=0;i<na;++i){\n        cin>>cup[0][i];\n    }\n    cin>>nb;\n    for(int i=0;i<nb;++i){\n        cin>>cup[1][i];\n    }\n    cin>>nc;\n    for(int i=0;i<nc;++i){\n        cin>>cup[2][i];\n    }\n    return ;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\n\nint n, m;\n\nint bfs(vector<int>& cup){\n\tmap<vector<int>,int> d;\n\tqueue<vector<int> > q;\n\td[cup] = 0;\n\tq.push(cup);\n\twhile( !q.empty() ){\n\t\tvector<int> now = q.front(); q.pop();\n\t\t\t\n\t\tif( now[0] == ((1<<n)-1) || now[2] == ((1<<n)-1) ){\n\t\t\treturn d[now];\n\t\t}\n\t\tfor(int i=0 ; i < 2 ; i++ ){\n\t\t\tvector<int> next = now;\n\t\t\tint a = now[i];\n\t\t\tint b = now[i+1];\n\t\t\tfor(int j = n ; j >= 0 ; j-- ){\n\t\t\t\tif( (a & (1<<j)) || (b & (1<<j)) ){\n\t\t\t\t\tif( a > b ){\n\t\t\t\t\t\ta -= (1<<j);\n\t\t\t\t\t\tb += (1<<j);\n\t\t\t\t\t}else{\n\t\t\t\t\t\ta += (1<<j);\n\t\t\t\t\t\tb -= (1<<j);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext[i] = a;\n\t\t\tnext[i+1] = b;\n\t\t\tif( !d.count(next) && d[now] + 1 <= m ){\n\t\t\t\td[next] = d[now] + 1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile( cin >> n >> m , n || m ){\n\t\tvector<int> cup(3,0);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint k,e;\n\t\t\tcin >> k;\n\t\t\tfor(int j=0 ; j < k ; j++ ){\n\t\t\t\tcin >> e;\n\t\t\t\tcup[i] |= (1 << (e-1));\n\t\t\t}\n\t\t}\n\t\tint ans = bfs(cup);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n#define AB 0\n#define BA 1\n#define AC 2\n#define CA 3\n#define BC 4\n#define CB 5\n\ninline int mostleft(int x){\n  int ret = 0;\n  if(x == 0) return -1;\n  if(x & 0xff00){ ret += 8; x >>= 8; }\n  if(x & 0x00f0){ ret += 4; x >>= 4; }\n  if(x & 0x000C){ ret += 2; x >>= 2; }\n  if(x & 0x0002){ ret += 1; x >>= 1; }\n  return ret;\n}\n\nint n, m;\nint solve(int a, int b, int c, int prev){\n  int ret = 0;\n  const int ok = (1 << n) - 1;\n\n  while( ++ret < m ){\n    //printf(\"ret=%d, prev=%d: %x %x %x\\n\",ret,prev,a,b,c);\n    if(a == ok || c == ok) return ret;\n\n    if(a < b && prev != AB){\n      int g = 1<<mostleft(b);\n      prev = BA;\n      a ^= g;\n      b ^= g;\n    }else if(b < a && prev != BA){\n      int g = 1<<mostleft(a);\n      prev = AB;\n      a ^= g;\n      b ^= g;\n    }else if(b < c && prev != BC){\n      int g = 1<<mostleft(c);\n      prev = CB;\n      b ^= g;\n      c ^= g;\n    }else if(c < b && prev != CB){\n      int g = 1<<mostleft(b);\n      prev = BC;\n      b ^= g;\n      c ^= g;\n    }\n  }\n\n  return m + 1;\n}\n\nint main(){\n  int num[3];\n\n  while((n = getInt()) + (m = getInt())){\n    const int ok = (1 << n) - 1;\n    REP(i,3){\n      int t = getInt();\n      num[i] = 0;\n      REP(j,t){\n        int h = getInt() - 1;\n        num[i] |= (1 << h);\n      }\n    }\n\n    int a = num[0];\n    int b = num[1];\n    int c = num[2];\n\n    int ans = INT_MAX;\n\n    if(a == ok || c == ok){\n      puts(\"0\");\n      continue;\n    }\n\n    //printf(\"%x(%d) %x(%d) %x(%d)\\n\",a,mostleft(a),b,mostleft(b),c,mostleft(c));\n\n    if(a < b){\n      int g = 1<<mostleft(b);\n      ans = min(ans, solve(a ^ g, b ^ g, c, BA));\n    }\n    if(b < a){\n      int g = 1<<mostleft(a);\n      ans = min(ans, solve(a ^ g, b ^ g, c, AB));\n    }\n    if(b < c){\n      int g = 1<<mostleft(c);\n      ans = min(ans, solve(a, b ^ g, c ^ g, CB));\n    }\n    if(c < b){\n      int g = 1<<mostleft(b);\n      ans = min(ans, solve(a, b ^ g, c ^ g, BC));\n    }\n\n    if(ans > m) puts(\"-1\");\n    else printf(\"%d\\n\",ans);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(x) cout << (x) << '\\n'\n#define Int int64_t\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\n\nInt INF = 1e18;\nInt mod = 1e9+7;\n//Int mod = 998244353;\n\nInt state[15000000];\n\nInt f(Int s, Int d, Int c) {\n    Int p = s;\n    for (Int i = 0; i < d; i++) {\n        p /= 3;\n    }\n    Int x = c -(p % 3);\n    for (Int i = 0; i < d; i++) {\n        x *= 3;\n    }\n    return s + x;\n}\n  \nint main() {\n    while (true) {\n        Int n, m;\n        cin >> n >> m;\n        if (n == 0) return 0;\n        vector<pair<Int, Int>> v;\n        for (Int i = 0; i < 3; i++) {\n            Int a;\n            cin >> a;\n            for (Int j = 0; j < a; j++) {\n                Int b;\n                cin >> b;\n                v.emplace_back(b, i);\n            }\n        }\n        sort(all(v));\n        Int cur = 0;\n        Int x = 1;\n        for (Int i = 0; i < n; i++) {\n            cur += v[i].se * x;\n            x *= 3;\n        }\n        for (Int i = 0; i < x; i++) {\n            state[i] = INF;\n        }\n        state[cur] = 0;\n        queue<Int> q;\n        q.push(cur);\n        while (not q.empty()) {\n            Int s = q.front();\n            q.pop();\n            Int a, b, c;\n            a = b = c = -1;\n            Int p = s;\n            for (Int i = 0; i < n; i++, p /= 3) {\n                if (p % 3 == 0) {\n                    a = i;\n                }\n                else if (p % 3 == 1) {\n                    b = i;\n                }\n                else {\n                    c = i;\n                }\n            }\n            //cout << a << \" \" << b << \" \" << c << endl;\n            if (a != -1 and a > b) {\n                Int t = f(s, a, 1);\n                if (state[t] > state[s] + 1) {\n                    state[t] = state[s] + 1;\n                    q.push(t);\n                }\n            }\n            if (b != -1 and b > a) {\n                Int t = f(s, b, 0);\n                if (state[t] > state[s] + 1) {\n                    state[t] = state[s] + 1;\n                    q.push(t);\n                }\n            }\n            if (b != -1 and b > c) {\n                Int t = f(s, b, 2);\n                if (state[t] > state[s] + 1) {\n                    state[t] = state[s] + 1;\n                    q.push(t);\n                }\n            }\n            if (c != -1 and c > b) {\n                Int t = f(s, c, 1);\n                if (state[t] > state[s] + 1) {\n                    state[t] = state[s] + 1;\n                    q.push(t);\n                }\n            }\n        }\n        Int all_A = 0;\n        Int all_C = x - 1;\n        Int res = min(state[all_A], state[all_C]);\n        dump(res <= m ? res : -1);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\nconst int NONE = -1;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    cout << A << \", \" << B << \", \" << C << \", \" << turns << endl;\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(A);\n        if ( u > v ) {\n            int ret = solve( A | u, remove_last(B), C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        int u = get_last(B);\n        int v = get_last(C);\n        if ( u > v ) {\n            int ret = solve( A, remove_last(B), C | u, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == NONE && ret2 == NONE ) {\n            cout << -1 << endl;\n        } else if ( ret1 != NONE && ret2 != NONE ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != NONE ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != NONE ) {\n            cout << ret2 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <tr1/unordered_map>\nusing namespace std;\n\nint n;\n\nint goal = 0;\n\ntypedef int P ;\n#define HASH_VAL 113341\nunsigned int f(int n,unsigned int size){\n\treturn n%HASH_VAL ;\n}\ntemplate <class K, class V>  \nclass hashMap {  \n    static const unsigned int DEFAULT_SIZE = HASH_VAL ;  \n    vector<pair<K, V> > *contents;  \n    unsigned int _size;  \n    unsigned int (*_hashValue) (K, unsigned int);  \n  \npublic:  \n    hashMap(unsigned int (*func) (K, unsigned int) , unsigned int size = DEFAULT_SIZE) {  \n        _hashValue = func;  \n        _size = size;  \n        contents = new vector<pair<K, V> > [_size];  \n    }  \n  \n    ~hashMap() {  \n        delete [] contents;  \n    }  \n  \n    bool hashElement(K s) {  \n        unsigned int h = _hashValue(s, _size);  \n  \n        for (int i = 0; i < (int)contents[h].size(); i++) {  \n            if (contents[h][i].first == s)  \n                return true;  \n        }  \n  \n        return false;  \n    }  \n  \n    void insert(K x, V n) {  \n        if (hashElement(x))  \n            return;  \n  \n        unsigned int h = _hashValue(x, _size);  \n        contents[h].push_back(make_pair(x, n));  \n    }  \n  \n    pair<K, V> *getElement(K x) {  \n        unsigned int h = _hashValue(x, _size);  \n        for (int i = 0; i < (int)contents[h].size(); i++)  \n            if (contents[h][i].first == x)  \n                return &contents[h][i];  \n  \n        return NULL;  \n    }  \n  \n    void printHashBalance() {  \n        int cnt = 0;  \n        double ret = 0.0;  \n        int worst = 0;  \n  \n        for (int i = 0; i < (int)_size; i++) {  \n            if (contents[i].size()) {  \n                ++cnt;  \n                ret += contents[i].size();  \n                worst = max<int>(worst, contents[i].size());  \n            }  \n        }  \n  \n        if (!cnt)  \n            cerr << \"Hash is empty\" << endl;  \n        else {  \n            cerr << \"collisions occurred(average): \" << (ret/cnt) << endl;  \n            cerr << \"collisions occurred(worst): \" << worst << endl;  \n        }  \n    }  \n};  \n\nP Q[30];\nint m,stat,tim,head,size,i,t,a,j,from,to,next;\n\nint main(){\n\twhile(cin >> n >> m && n){\n\t\thashMap<int,int> done(&f);\n\t\tint init = 0;\n\t\tfor(i = 0 ; i < n ; i++) goal |= 2 << (i*2);\n\t\t\n\t\tfor(i = 0 ; i < 3 ; i++){\n\t\t\tt,a; cin >> t;\n\t\t\twhile(t--){cin >> a; a--; init |= (i) << (2*a); }\n\t\t}\n\t\thead = 0 , size = 0;\n\t\tQ[size++] = init;\n\t\tdone.insert(init,0);\n\t\tint hoge = 0;\n\t\twhile(head != size){\n\t\t\thoge++;\n\t\t\tstat = Q[head++];\n\t\t\ttim = (*done.getElement(stat)).second;\n\t\t\tif(tim > m) break;\n\t\t\tif(stat == goal || stat == 0){ cout << tim << endl; goto hoge;}\n\t\t\tint mi[3] = {-1,-1,-1};\n\t\t\tfor(i = n-1 ; i >= 0 ; i--){\n\t\t\t\tint num = stat>>(i*2)&3;\n\t\t\t\tif(mi[num]==-1)mi[num] = i;\n\t\t\t}\n\t\t\t\n\t\t\tfor(from = 0 ; from < 3 ; from++){\n\t\t\t\tfor(to = 0 ; to < 3 ; to++){\n\t\t\t\t\tif ( !( (from == 0 && to == 2) || (from == 2 && to == 0) ) && from != to && mi[from] != -1 && (mi[to] == -1 || mi[from] > mi[to]) ){\n\t\t\t\t\t\tnext = (stat & ~(3<<(2*mi[from]))) | (to<<(2*mi[from]));\n\t\t\t\t\t\tif(done.getElement(next)==NULL)Q[size++] = next , done.insert(next,tim+1);\n\t\t\t\t\t\thead %= 30;\n\t\t\t\t\t\tsize %= 30;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\thoge:;\n\t\t//done.printHashBalance();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define AB 1\n#define BC 3\n#define INF 1<<30\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nint n, m;\n\nstack<int> tray[3];\n\nbool is_success (void )\n{\n\treturn (tray[0].size() == n || tray[2].size() == n ); \n}\n\nint dfs (int curr, int prev )\n{\n\tint ans = INF;\n\n\tif (curr > m ){\n\t\treturn ans;\n\t} // end if\n\n\tif (is_success () ){\n\t\tans = min (ans, curr );\n\t\treturn ans;\n\t} // end if\n\n\n\trep (i, 3 ){\n\t\tif (!tray[i].empty() ){\n\t\t\tint cup = tray[i].top();\n\t\t\tif (i == 0 && prev != AB ){\n\t\t\t\tif (tray[1].empty() || cup > tray[1].top() ){\n\t\t\t\t\ttray[1].push (cup );\n\t\t\t\t\ttray[i].pop();\n\t\t\t\t\tans = min (ans, dfs (curr+1, AB ) );\n\t\t\t\t\ttray[i].push (cup );\n\t\t\t\t\ttray[1].pop();\n\t\t\t\t} // end if\t\t\t\t\t\t\n\t\t\t}else\n\t\t\tif (i == 2 && prev != BC ){\n\t\t\t\tif (tray[1].empty() || cup > tray[1].top() ){\n\t\t\t\t\ttray[1].push (cup );\n\t\t\t\t\ttray[i].pop();\n\t\t\t\t\tans = min (ans, dfs (curr+1, BC ) );\n\t\t\t\t\ttray[i].push (cup );\n\t\t\t\t\ttray[1].pop();\n\t\t\t\t} // end if\t\t\t\t\t\t\n\t\t\t}else\n\t\t\tif (i == 1 ){\n\t\t\t\tif (prev != AB && (tray[0].empty() || cup > tray[0].top() ) ){\n\t\t\t\t\ttray[0].push (cup );\n\t\t\t\t\ttray[i].pop();\n\t\t\t\t\tans = min (ans, dfs (curr+1, AB ) );\n\t\t\t\t\ttray[i].push (cup );\n\t\t\t\t\ttray[0].pop();\n\t\t\t\t}else\n\t\t\t\tif (prev != BC && (tray[2].empty() ||  cup > tray[2].top() ) ){\n\t\t\t\t\ttray[2].push (cup );\n\t\t\t\t\ttray[i].pop();\n\t\t\t\t\tans = min (ans, dfs (curr+1, BC ) );\n\t\t\t\t\ttray[i].push (cup );\n\t\t\t\t\ttray[2].pop();\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t} // en if\n\t} // end rep\n\n\treturn ans;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.cup\", \"r\", stdin );\n\twhile (scanf (\"%d %d\", &n, &m ), n, m ){\n//\t\tvector<stack<int> > tray(3);\n\t\trep (i, 3 ) while (!tray[i].empty() ) tray[i].pop();\n\t\trep (i, 3 ){\n\t\t\tint in;\n\t\t\tscanf (\"%d\", &in );\n\t\t\trep (j, in ){\n\t\t\t\tint cup;\n\t\t\t\tscanf (\"%d\", &cup );\n\t\t\t\ttray[i].push (cup );\n\t\t\t} // end rep\n\t\t} // end rep\n\t\tint ans = dfs (0, 0 );\n\t\tif (ans == INF ){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << ans << endl;\n\t\t} // end if\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint an, bn, cn, a[20], b[20], c[20], total = 0, f = 1;\n\nstruct mm{\n\tchar ch;\n\tint nu;\n};\n\nstruct mm m1, m2;\n\nint judge(int max, int temp){\n\tif(temp + 1 == an + bn + cn)return -1;\n\tif(a[an] == max - temp)return 50 + temp;\n\tif(c[cn] == max - temp)return 100 + temp;\n\tif(b[cn - temp] == max - temp)return judge(max, temp + 1);\n\treturn 0;\n}\n\nint calculation(int min, int max){\n\tint sum;\n\tif(min == max)return 0;\n\tif(min < max)sum = calculation(++min, max) * 3 + 2;\n\treturn sum;\n}\n\nint move(int flag){\n\tint number;\n\tif(flag == 2){  //right\n\t\tnumber = an - m1.nu + 1;\n\t\tfor(int i = 1;i <= number;i++)c[++cn] = a[an--];\n\t}\n\tif(flag == 1){\n\t\tnumber = cn - m1.nu + 1;\n\t\tfor(int i = 1;i <= number;i++)a[++an] = c[cn--];\n\t}\n\ttotal += calculation(0, number);\n\t//printf(\"*%d*\", number);\n\treturn 0;\n}\n\nint sort(){\n\tif(m1.ch == m2.ch)return 0;\n\tif(m2.ch == 'b'){\n\t\tif(m1.ch == 'a')c[++cn] = b[bn--], move(2);  //right\n\t\tif(m1.ch == 'c')a[++an] = b[bn--], move(1);\n\t\ttotal++;\n\t}else if(m2.ch == 'a')move(1);\n\telse if(m2.ch == 'b')move(2);\n\treturn 0;\n}\n\nint solve(int max){\n\tfor(int i = 1;i <= an;i++){\n\t\tif(a[i] == max)m1.ch = 'a',m1.nu = i;\n\t\tif(a[i] == max - 1)m2.ch = 'a', m2.nu = i;\n\t}\n\tfor(int i = 1;i <= bn;i++){\n\t\tif(b[i] == max)m1.ch = 'b',m1.nu = i;\n\t\tif(b[i] == max - 1)m2.ch = 'b', m2.nu = i;\n\t}\n\tfor(int i = 1;i <= cn;i++){\n\t\tif(c[i] == max)m1.ch = 'c',m1.nu = i;\n\t\tif(c[i] == max - 1)m2.ch = 'c', m2.nu = i;\n\t}\n\tif(f == 1 && m1.ch == 'b'){\n\t\tint vec;  //1 = left \n\t\tif(m2.ch == 'b'){\n\t\t\tint temp = judge(max, 2);\n\t\t\tif(temp == -1)return 0;\n\t\t\tif(temp >= 100){\n\t\t\t\tif(temp % 2)vec = 2;\n\t\t\t\telse vec = 1;\n\t\t\t}else if(temp >= 50){\n\t\t\t\tif(temp % 2)vec = 1;\n\t\t\t\telse vec = 2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(m2.ch == 'a' || vec == 1){\n\t\t\ta[++an] = b[bn--];\n\t\t}else if(m2.ch == 'c' || vec == 2){\n\t\t\tc[++cn] = b[bn--];\n\t\t}\n\t\ttotal++;\n\t}else{\n\t\tsort();\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n, m, max = 0;\n\twhile(scanf(\"%d %d\",&n, &m)){\n\t\tif(n == 0 && m == 0)break;\n\t\tmax = total = 0, f = 1;\n\t\t\n\t\t\n\t\tscanf(\"%d\", &an);\n\t\tfor(int i = 1;i <= an;i++){\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t\tif(a[i] > max)max = a[i];\n\t\t}\n\t\tscanf(\"%d\", &bn);\n\t\tfor(int i = 1;i <= bn;i++){\n\t\t\tscanf(\"%d\", &b[i]);\n\t\t\tif(b[i] > max)max = b[i];\n\t\t}\n\t\tscanf(\"%d\", &cn);\n\t\tfor(int i = 1;i <= cn;i++){\n\t\t\tscanf(\"%d\", &c[i]);\n\t\t\tif(c[i] > max)max = c[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < n - 1;i++)solve(max - i);\n\t\t\n\t\tif(total <= m)printf(\"%d\\n\", total);\n\t\telse printf(\"-1\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint calc(vector<int> cup, int m)\n{\n    int cnt = 0;\n    while (1) {\n        int i = cnt%2, j = i+1;\n        int p = 1;\n        while (p <= max(cup[i], cup[j])) p <<= 1;\n        p >>= 1;\n        if (!p) break;\n        cup[i] ^= p;\n        cup[j] ^= p;\n        cnt++;\n        if (cnt > m) return cnt;\n    }\n\n    return cnt;\n}\n\nint main()\n{\n    while (1) {\n        int n, m; cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        vector<int> cup(3);\n        loop (3, i) {\n            int c; cin >> c;\n            while (c--) {\n                int v; cin >> v;\n                cup[i] |= 1 << v--;\n            }\n        }\n        int ans = calc(cup, m);\n        swap(cup[0], cup[2]);\n        ans = min(ans, calc(cup, m));\n        cout << (ans <= m ? ans : -1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint n, m;\nstruct puzzle {\n\tchar f[3][15];\n\tint len[3], cnt;\n};\nbool operator==(const puzzle&left, const puzzle&right) {\n\trep(i, 3) {\n\t\tif (strcmp(left.f[i], right.f[i]))return false;\n\t}\n\treturn true;\n}\ntemplate<>\nstruct hash<puzzle> {\n\tinline size_t operator()(const puzzle&p) const {\n\t\tsize_t cnt = 0;\n\t\trep(i, 3) {\n\t\t\thash<string>H;\n\t\t\tcnt += (i + 1)*H(p.f[i]);\n\t\t}\n\t\treturn cnt;\n\t}\n};\n\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tpuzzle in{};\n\t\trep(i, 3) {\n\t\t\tscanf(\"%d\", &in.len[i]);\n\t\t\trep(j, in.len[i])scanf(\"%d\", &in.f[i][j]);\n\t\t}\n\t\tunordered_map<puzzle, bool>mp;\n\t\tqueue<puzzle>que;\n\t\tmp[in] = true;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tpuzzle u = que.front(); que.pop();\n\t\t\tif (u.len[0] == n || u.len[2] == n) {\n\t\t\t\tprintf(\"%d\\n\", u.cnt);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (u.cnt >= m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tif (u.len[i] == 0)continue;\n\t\t\t\tif (u.len[j] > 0 && (u.f[i][u.len[i] - 1] < u.f[j][u.len[j] - 1]))\n\t\t\t\t\tcontinue;\n\t\t\t\tpuzzle v = u;\n\t\t\t\tv.len[i]--; v.len[j]++;\n\t\t\t\tswap(v.f[i][v.len[i]], v.f[j][v.len[j] - 1]);\n\t\t\t\tif (!mp[v]) {\n\t\t\t\t\tmp[v] = true;\n\t\t\t\t\tv.cnt++;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define pii pair<int, int>\n#define p3i pair<pii, int>\n#define pll pair<ll, ll>\n#define p3l pair<pll, ll>\n#define lseg L, (L+R)/2, N*2+1\n#define rseg (L+R)/2+1, R, N*2+2\n#define ub upper_bound\n#define lb lower_bound\n#define p_q priority_queue\n#define MN 1000000009\n#define top front\n\nint n, m, b, d, t, p3[16], x, lst[3], dp[15000000];\nqueue<pii> q;\nvoid bfs(){\n    while(!q.empty()){\n        b=q.top().x; d=q.top().y; q.pop();\n        if (b==0 || b==p3[n]-1){\n            if (m<d) break;\n            cout << d << endl;\n            return;\n        }\n        //cout << b << ' ' << d << endl;\n        if (d>=dp[b]) continue;\n        dp[b]=d;\n        lst[2]=-1; lst[1]=-1; lst[0]=-1; t=b;\n        for (int l=0; l<n; ++l){\n            lst[t%3]=l; t/=3;\n            //cout << l << ' ';\n        }\n        //cout << lst[0] << ' ' << lst[1] << ' ' << lst[2] << endl;\n        for (int l=0; l<3; ++l){\n            if (lst[l]!=-1){\n                if (l!=1){\n                    if (lst[1]<lst[l]){\n                        t=b;\n                        t+=p3[lst[l]]*(1-l);\n                        q.push(mp(t, d+1));\n                    }\n                } else {\n                    if (lst[1]>lst[0]){\n                        t=b;\n                        t-=p3[lst[l]];\n                        q.push(mp(t, d+1));\n                    }\n                    if (lst[1]>lst[2]){\n                        t=b;\n                        t+=p3[lst[l]];\n                        q.push(mp(t, d+1));\n                    }\n                }\n            }\n        }\n    }\n    cout << -1 << endl;\n}\nint main(){\n    p3[0]=1; for (int l=1; l<16; ++l) p3[l]=p3[l-1]*3;\n    while(cin >> n >> m){\n        if (n==0) break;\n        memset(dp, 0x3f3f3f3f, sizeof dp);\n        while(!q.empty()) q.pop();\n        b=0;\n        for (int l=0; l<3; ++l){\n            cin >> t;\n            for (int l2=0; l2<t; ++l2){\n                cin >> x;\n                b+=p3[x-1]*l;\n            }\n        }\n        q.push(mp(b, 0));\n        bfs();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<string>\n#include<climits>\n#include<deque>\n\nusing namespace std;\n\nint m;\nstack<int,vector<int> >A,B,C;\n\nint func(int,string);\n\nint main(void){\n  int n,ans,s,t;\n  \n  while(cin >> n >> m,n|m){\n    while(!A.empty())A.pop();\n    while(!B.empty())B.pop();\n    while(!C.empty())C.pop();\n    \n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      A.push(t);\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      B.push(t);\n    }\n    cin >> s;\n    for(int i=0;i<s;i++){\n      cin >> t;\n      C.push(t);\n    }\n    ans=func(0,\"\");\n    if(ans==INT_MAX)cout << -1 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}\n\nint func(int cnt,string p){\n  \n  if(cnt>m)return INT_MAX;\n  \n  if(B.empty()&&(C.empty()||A.empty()))\n    return cnt;\n  \n  int res=INT_MAX;\n  \n  if(!A.empty() && A.top()>B.top() && p!=\"BA\"){\n    B.push(A.top());\n    A.pop();\n    res=min(res,func(cnt+1,\"AB\"));\n    A.push(B.top());\n    B.pop();\n  }\n  \n  if(!B.empty()){\n    if(B.top()>C.top() && p!=\"CB\"){\n      C.push(B.top());\n      B.pop();\n      res=min(res,func(cnt+1,\"BC\"));\n      B.push(C.top());\n      C.pop();\n    }\n    \n    if(B.top()>A.top() && p!=\"AB\"){\n      A.push(B.top());\n      B.pop();\n      res=min(res,func(cnt+1,\"BA\"));\n      B.push(A.top());\n      A.pop();\n    }\n  }\n  \n  if(!C.empty() && C.top()>B.top() && p!=\"BC\"){\n    B.push(C.top());\n    C.pop();\n    res=min(res,func(cnt+1,\"CB\"));\n    C.push(B.top());\n    B.pop();\n  }\n  \n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,P> pip;\nconst int inf=(1<<31)-1;\n\nint n,m;\nvvi date;\n\nint func(int x){\n\tint an=1;\n\tfor(int i=0;i<x;i++) an*=3;\n\treturn an;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(!n&&!m) break;\n\t\tint lef=0,rig=0;\n\t\tdate=vvi(3);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint tn;\n\t\t\tcin>>tn;\n\t\t\tfor(int j=0;j<tn;j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tdate[i].push_back(tmp);\n\t\t\t}\n\t\t}\n\t\tfor(int  i=0;i<3;i+=2){\n\t\t\tint now=i;\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tint tmp1;\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tbool q=1;\n\t\t\t\t\tfor(int r=0;r<date[k].size();r++){\n\t\t\t\t\t\tif(j==date[k][r]){\n\t\t\t\t\t\t\ttmp1=k;\n\t\t\t\t\t\t\tq=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j<date[k][r]) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(!q) break;\n\t\t\t\t}\n\t\t\t\tint t=abs(now-tmp1);\n\t\t\t\tif(!t) continue;\n\t\t\t\tif(i==0){\n\t\t\t\t\tlef+=t*func(n-j);\n\t\t\t\t\tif(lef>m) break;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\trig+=t*func(n-j);\n\t\t\t\t\tif(rig>m) break;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<t;k++){\n\t\t\t\t\tif(now==0) now=2;\n\t\t\t\t\telse now=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=min(lef,rig);\n\t\tif(ans>m) cout<<-1<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint T[16];\nint A[16], B[16];\nint n, m;\n\nint solve() {\n    int P[17];\n    P[n-1] = 2;\n    for ( int i = n-1; i > 0; -- i ) P[i-1] = 3 * P[i] + 2;\n    \n    A[n-1] = T[n-1];\n    B[n-1] = 2 - T[n-1];\n    for ( int i = n; i >= 0; -- i ) {\n        if ( T[i-2] == 0 ) {\n            A[i-2] = A[i-1];\n            B[i-2] = A[i-1] + 2 * P[i-1] + 2;\n        } else if ( T[i-2] == 1 ) {\n            A[i-2] = B[i-1] + P[i-1] + 1;\n            B[i-2] = A[i-1] + P[i-1] + 1;\n        } else {\n            A[i-2] = A[i-1] + 2 * P[i-1] + 2;\n            B[i-2] = B[i-1];\n        }\n    }\n    int res = min( A[0], B[0] );\n    if ( res > m ) return -1;\n    return res;\n}\n\nint main() {\n    while ( cin >> n >> m && n ) {\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t --;\n                T[t] = i;\n            }\n        }\n\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint bl0[16]={};\nint nx0[16]={};\nint bl[16]={};\nint nx[16]={};\nint largest0[3]={};\nint largest[3]={};\n\nint main() {\n\tint n,m,k,a,b,s,l1,l2;\n\tint ss[2]={};\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n==0){ return 0;}\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin >> k;\n\t\t\tb=0;\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tcin >> a;\n\t\t\t\tbl0[a]=i;\n\t\t\t\tnx0[a]=b;\n\t\t\t\tb=a;\n\t\t\t}\n\t\t\tlargest0[i]=b;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<2;i++){\n\t\t\tss[i]=m+1;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tbl[j]=bl0[j];\n\t\t\t\tnx[j]=nx0[j];\n\t\t\t}\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tlargest[j]=largest0[j];\n\t\t\t}\n\t\t\tfor(int s=0;s<m;s++){\n\t\t\t\tl1=largest[(i+s)%2];\n\t\t\t\tl2=largest[(i+s)%2+1];\n\t\t\t\tif(l1==l2){\n\t\t\t\t\tss[i]=s;\n\t\t\t\t\ts=m;\n\t\t\t\t}\n\t\t\t\tif(l1>l2){\n\t\t\t\t\tlargest[(i+s)%2]=nx[l1];\n\t\t\t\t\tlargest[(i+s)%2+1]=l1;\n\t\t\t\t\tbl[l1]=(i+s)%2+1;\n\t\t\t\t\tnx[l1]=l2;\n\t\t\t\t}else{\n\t\t\t\t\tlargest[(i+s)%2]=l2;\n\t\t\t\t\tlargest[(i+s)%2+1]=nx[l2];\n\t\t\t\t\tbl[l2]=(i+s)%2;\n\t\t\t\t\tnx[l2]=l1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ss[0]<ss[1]){\n\t\t\ts=ss[0];\n\t\t}else{\n\t\t\ts=ss[1];\n\t\t}\n\t\t\n\t\tif( s<=m ){\n\t\t\tcout << s << endl;\n\t\t}else{\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n\n#define MAX 16\n#define A 0\n#define B 1\n#define C 2\n\nusing namespace std;\n\ntemplate<typename _T>\n_T &abs(const _T &x){if(x<0)return -x;else return x;}\n\nint cost[3][MAX];\nint main(){\n\tcost[1][1] = 1;\n\tcost[2][1] = 2;\n\tfor(int i = 1; i < 3; ++i){\n\t\tfor(int j = 2; j < MAX; ++j){\n\t\t\tif( i == 1 ){\n\t\t\t\tcost[i][j] = 3 * cost[i][j - 1] + 1;\n\t\t\t}else{\n\t\t\t\tcost[i][j] = 2 * cost[1][j];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tint ans = 0;\n\t\tint places[MAX];\n\t\tint maxs[3] = {0,};\n\t\tint nums[3] = {0,};\n\t\tint cups[3][MAX];\n\t\tint n,m;\n\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif( n == 0 && m == 0 )\n\t\t\tbreak;\n\n\t\tfor(int i = 0; i < 3; ++i){\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tfor(int j = 0; j < t; ++j){\n\t\t\t\tscanf(\"%d\", &cups[i][j]);\n\t\t\t\tplaces[ cups[i][j] ] = i;\n\t\t\t\tnums[i]++;\n\t\t\t\tmaxs[i] = max(maxs[i],cups[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tif( nums[B] == 1 ){\n\t\t\tif( maxs[A] < maxs[B] ){\n\t\t\t\tplaces[ cups[B][0] ] = A;\n\t\t\t\tans += 1;\n\t\t\t}else if( maxs[C] < maxs[B] ){\n\t\t\t\tplaces[ cups[B][0] ] = C;\n\t\t\t\tans += 1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = n; i >= 2; --i){\n\t\t\tint d = abs( places[ i ] - places[i - 1] );\n\t\t\tans += cost[d][n - i + 1];\n\t\t\tplaces[ i ] = places[ i - 1 ];\n\t\t}\n\n\t\tif( places[ 1 ] == B ){\n\t\t\tans += cost[1][n];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans <= m ? ans : -1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nvint a,b,c;\nint m;\n\nint f(vint a,vint b,vint c,int now){\n\trepc(i,m){\n\t\tif(now==0){\n\t\t\tif(sz(a)==0){\n\t\t\t\tif(sz(b)==0){\n\t\t\t\t\treturn i;\n\t\t\t\t}else{\n\t\t\t\t\ta.PB(b[sz(b)-1]);\n\t\t\t\t\tb.pop_back();\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(sz(b)==0||a[sz(a)-1]>b[sz(b)-1]){\n\t\t\t\t\tb.PB(a[sz(a)-1]);\n\t\t\t\t\ta.pop_back();\n\t\t\t\t}else{\n\t\t\t\t\ta.PB(b[sz(b)-1]);\n\t\t\t\t\tb.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tif(sz(b)==0){\n\t\t\t\tif(sz(c)==0){\n\t\t\t\t\treturn i;\n\t\t\t\t}else{\n\t\t\t\t\tb.PB(c[sz(c)-1]);\n\t\t\t\t\tc.pop_back();\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(sz(c)==0||b[sz(b)-1]>c[sz(c)-1]){\n\t\t\t\t\tc.PB(b[sz(b)-1]);\n\t\t\t\t\tb.pop_back();\n\t\t\t\t}else{\n\t\t\t\t\tb.PB(c[sz(c)-1]);\n\t\t\t\t\tc.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnow^=1;\n\t}\n\treturn INF;\n}\n\nint main() {\n\tint n,k;\n\tIL{\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)break;\n\t\ta.clear();\n\t\tcin>>k;\n\t\trep(i,k)a.PB(in());\n\t\tb.clear();\n\t\tcin>>k;\n\t\trep(i,k)b.PB(in());\n\t\tc.clear();\n\t\tcin>>k;\n\t\trep(i,k)c.PB(in());\n\t\tint res=min(f(a,b,c,0),f(a,b,c,1));\n\t\tif(res<=m)cout<<res<<endl;\n\t\telse cout<<-1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint d[16];\nint v[16],a[16],c[16];\n\nint main(void){\n    int n,m,k,l;\n    int p;\n    while(cin>>n>>m,!(n==0&&m==0)){\n        memset(d,0,sizeof(d));\n        memset(v,0,sizeof(v));\n        memset(a,0,sizeof(a));\n        memset(c,0,sizeof(c));\n        for(int i=0;i<3;i++){\n            cin>>k;\n            for(int j=0;j<k;j++){\n                cin>>l;\n                v[l]=i;\n            }\n        }\n        d[n]=2;\n        a[n]=v[n];\n        c[n]=2-v[n];\n        while(--n>0){\n            d[n]=3*d[n+1]+2;\n            if(v[n]==0){\n                a[n]=a[n+1];\n                c[n]=c[n+1]+2*d[n+1]+2;\n            }\n            if(v[n]==1){\n                a[n]=c[n+1]+d[n+1]+1;\n                c[n]=a[n+1]+d[n+1]+1;\n            }\n            if(v[n]==2){\n                a[n]=a[n+1]+2*d[n+1]+2;\n                c[n]=c[n+1];\n            }\n        }\n        p=min(a[1],c[1]);\n        if(p>m)p=-1;\n        cout<<p<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include <stack>\nusing namespace std;\n \nint main()\n{\n    stack<int>a,b,c;\n    while(1)\n    {\n         \n        int count=0,n,m,check;\n        scanf(\"%d %d\",&n,&m);\n \n        if(n==0 && m==0)\n        {\n            break;\n        }\n     \n        int A,B,C,\n            kari;\n         \n        a.push(0);\n        b.push(0);\n        c.push(0);\n \n        scanf(\"%d\",&A);\n        for(int i=0;i<A;i++){\n            scanf(\"%d\",&kari);\n            a.push(kari);\n        }\n \n        scanf(\"%d\",&B);\n        for(int i=0;i<B;i++){\n            scanf(\"%d\",&kari);\n            b.push(kari);\n        }\n     \n        scanf(\"%d\",&C);\n        for(int i=0;i<C;i++){\n            scanf(\"%d\",&kari);\n            c.push(kari);\n        }\n         \n        while(1)\n        {\n            if(b.top()==0 && c.top()==0)\n                break;\n            if(a.top()<b.top() && a.top()<c.top()){\n                kari=b.top();\n                a.push(kari);\n                b.pop();\n                count++;\n                continue;\n            }\n            if(b.top()<c.top() ){\n                kari=c.top();\n                b.push(kari);\n                c.pop();\n                count++;\n                continue;\n            }\n            if(b.top()<a.top()){\n                kari=a.top();\n                b.push(kari);\n                a.pop();\n                count++;\n                continue;\n            }\n            if(c.top()<b.top() && a.top()!=b.top()-1){\n                kari=b.top();\n                c.push(kari);\n                b.pop();\n                count++;\n                continue;\n        }\n            else{\n                kari=b.top();\n                a.push(kari);\n                b.pop();\n                count++;\n                continue;\n            }\n        }\n        if(count<=m){\n\t\t\tprintf(\"%d\\n\",count);\n\t\t\tcontinue;\n\t\t}\n        else {\n\t\t\t puts(\"-1\");\n\t\t\tcontinue;\n\t\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint move_count(vector<vector<int>> &vec, int &n, int &m, int r, bool fla) {\n}\n \nint main() {\n  while(true){\n    \n    int N,M;\n    cin >> N >> M;\n    if( N==0 && M ==0) break;\n    \n    vector<vector<int>> abc(3, vector<int>(1, 0));\n    int b_t = 0;\n    for (int i=0; i<3; i++){\n      int m; cin >> m;\n      for (int j=0; j<m; j++) {\n        int g; cin >> g;\n        abc.at(i).push_back(g);\n        if( i == 1 && j == m-1 ) b_t = g;\n      }\n    }\n    \n    \n    queue<vector<vector<int>>> q;\n    queue<int> num;\n    queue<bool> tgl;\n\n    if( b_t == N) {\n      abc.at(1).pop_back();\n      \n      vector<vector<int>> abc1 = abc;\n      abc1.at(0).push_back(N);\n      q.push( abc1 );\n      \n      vector<vector<int>> abc2 = abc;\n      abc2.at(2).push_back(N);\n      q.push( abc2 );\n      \n      num.push(1); num.push(1);\n      tgl.push(false); tgl.push(false);\n\n    } else {\n      q.push( abc ); q.push( abc );\n      num.push(0); num.push(0);\n      tgl.push(true); tgl.push(false);\n    }\n    int r = 0;\n    while(true){\n      \n      vector<vector<int>> vec = q.front();\n      q.pop();\n      r = num.front();\n      num.pop();\n      bool fla = tgl.front();\n      tgl.pop();\n      \n      if(vec.at(0).size() == N + 1 ) break;\n      if(vec.at(2).size() == N + 1 ) break;\n      if( r > M ) {\n        r = -1; break;\n      }\n        \n      int a = vec.at(0).at( vec.at(0).size()-1 );\n      int b = vec.at(1).at( vec.at(1).size()-1 );\n      int c = vec.at(2).at( vec.at(2).size()-1 );\n      if(fla) {\n        if(a == N) { c = a; a = -1; }\n        else { a = c; c = -1; }\n        b = 0; r += 2; fla = false;\n      } else {\n        if(a == N) {\n          a = 0;\n          if( c < b ) { c = b; b = -1; }\n          else { b = c; c = -1; }\n        } else {\n          c = 0;\n          if( a < b ) { a = b; b = -1;}\n          else { b = a; a = -1;}\n        }\n        r++; fla = true;\n      }\n      \n      vector<int> p_vec = {a,b,c};\n      for (int i=0; i<3; i++) {\n        if( p_vec.at(i) ) {\n          if( p_vec.at(i) == -1) vec.at(i).pop_back();\n          else vec.at(i).push_back( p_vec.at(i) );\n        }\n      }\n      q.push(vec);\n      num.push(r);\n      tgl.push(fla);\n    }\n    cout << r << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<utility>\n#include<vector>\nusing namespace std;\nvoid shoki(vector<vector<int>> a) {\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 16; ++j) \n\t\t\ta[i][j] = 0;\n\t}\n\treturn;\n}\nint main() {\n\tint n, m, na, nb, nc,tyo,place[16];\n\tvector<vector<int>> cup(3,vector<int>(16));\n\twhile (1) {\n\t\ttyo = 0;\n\t\tshoki(cup);\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\t\tcin >> na;\n\t\tfor (int i = 0; i < na; ++i) cin >> cup[0][i];\n\t\tcin >> nb;\n\t\tfor (int i = 0; i < nb; ++i)cin >> cup[1][i];\n\t\tcin >> nc;\n\t\tfor (int i = 0; i < nc; ++i)cin >> cup[2][i];\n\t\tif (cup[0][0] == 1)place[0] = 0;\n\t\telse if (cup[2][0] == 1)place[0] = 2;\n\t\telse if (cup[0][0] == 0)place[0] = 0;\n\t\telse if (cup[2][0] == 0)place[0] = 2;\n\t\telse if (cup[0][0] > cup[2][0])place[0] = 0;\n\t\telse place[0] = 2;\n\t\tint np;\n\t\tif (place[0] == 0)np = 2;\n\t\telse np = 0;\n\t\tfor (int k = 1; k < 16; ++k) {\n\t\t\tplace[k] = place[0];\n\t\t}\n\t\tbool bo = false; int at,ar;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tfor (int j = 0; j < na; ++j) {\n\t\t\t\tif (cup[0][j] == i) {\n\t\t\t\t\tat = 0;\n\t\t\t\t\tar = j;\n\t\t\t\t\tbo = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < nb; ++j) {\n\t\t\t\tif (bo)break;\n\t\t\t\tif (cup[1][j] == i) {\n\t\t\t\t\tat = 1;\n\t\t\t\t\tar = j;\n\t\t\t\t\tbo = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < nc; ++j) {\n\t\t\t\tif (bo)break;\n\t\t\t\tif (cup[2][j] == i) {\n\t\t\t\t\tat = 2;\n\t\t\t\t\tar = j;\n\t\t\t\t\tbo = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbo = false;\n\t\t\tif (at == place[i]) {\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (at == 1) {\n\t\t\t\t\ttyo += pow(3, n - i);\n\t\t\t\t\tfor (int k =i+1; k < 16; ++k) {\n\t\t\t\t\t\tif (place[k] == 0)place[k] = 2;\n\t\t\t\t\t\telse place[k] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttyo += 2 * (pow(3, n - i));\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (m < tyo)cout << -1 << endl;\n\t\telse cout << tyo << endl;\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nint dp[14400000];\nint N, M;\nint to_hash(const vector<int>&nums) {\n\tint hash = 0;\n\tfor (auto n : nums) {\n\t\thash = 3 * hash + n;\n\t}\n\treturn hash;\n}\nint getans(vector<int>&starts) {\n\tqueue<pair<vector<int>, int>>que;\n\tque.emplace(starts, 0);\n\twhile (!que.empty()) {\n\t\tauto v = que.front();\n\t\tque.pop();\n\t\tvector<int>nums = v.first;\n\t\tint now = v.second;\n\t\tconst int hash = to_hash(nums);\n\t\tif (dp[hash] == false) {\n\t\t\tcontinue;\n\t\t}else {\n\t\t\tdp[hash] = false;\n\t\t\tif (now >= M+1) {\n\t\t\t\treturn M + 1;\n\t\t\t}\n\t\t\tif (to_hash(nums) == 0) {\n\t\t\t\treturn now;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[hash] = false;\n\t\t\t\tvector<int>tops(3, -1);\n\t\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\t\ttops[nums[i]] = i;\n\t\t\t\t}\n\t\t\t\tint ans = M;\n\t\t\t\tif (tops[0] < tops[1]) {\n\t\t\t\t\tnums[tops[1]] = 0;\n\t\t\t\t\tque.emplace(nums, now + 1);\n\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnums[tops[0]] = 1;\n\t\t\t\t\tque.emplace(nums, now + 1);\n\t\t\t\t\tnums[tops[0]] = 0;\n\t\t\t\t}\n\t\t\t\tif (tops[1] < tops[2]) {\n\t\t\t\t\tnums[tops[2]] = 1;\n\t\t\t\t\tque.emplace(nums, now + 1);\n\t\t\t\t\tnums[tops[2]] = 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnums[tops[1]] = 2;\n\t\t\t\t\tque.emplace(nums, now + 1);\n\t\t\t\t\tnums[tops[1]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn M+1;\n\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 14400000; ++i) {\n\t\t\tdp[i] = true;\n\t\t} cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<int>nows(N);\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tfor (int j = 0; j < a; ++j) {\n\t\t\t\tint b; cin >> b; b--;\n\t\t\t\tnows[b] = i;\n\t\t\t}\n\t\t}\n\t\tint ans = getans(nows);\n\t\tif (ans == M+1)ans = -1;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n  int n,m,p,q[15],a;\n  while(cin>>n>>m,n||m){\n    for(int i=0;i<3;++i){\n      cin>>p;\n      while(p--){\n\tcin>>a;\n\tq[a-1]=i;\n      }\n    }\n    a=0;p=0;\n    for(int i=0;i<n;++i){\n      if(q[i]==1){\n\ta+=pow(3,n-i-1);p=(p==0)?2:(p==1)?1:0;\n      }\n      else if(q[i]!=p){\n\ta+=2*pow(3,n-i-1);p=(p==0)?2:0;\n      }\n    }\n    a=min(a,(int)pow(3,n)-1);\n    cout<<((m>a)?a:-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include <stack>\nusing namespace std;\n\nint main()\n{\n\tstack<int>a,b,c;\n\twhile(1)\n\t{\n\t\t\n\t\tint count=0,n,m,check;\n\t\tscanf(\"%d %d\",&n,&m);\n\n\t\tif(n==0 && m==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\n\t\tint A,B,C,\n\t\t\tkari;\n\t\t\n\t\t/*エラー対策*/\n\t\ta.push(0);\n\t\tb.push(0);\n\t\tc.push(0);\n\n\t\tscanf(\"%d\",&A);\n\t\tfor(int i=0;i<A;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\ta.push(kari);\n\t\t}\n\n\t\tscanf(\"%d\",&B);\n\t\tfor(int i=0;i<B;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\tb.push(kari);\n\t\t}\n\t\n\t\tscanf(\"%d\",&C);\n\t\tfor(int i=0;i<C;i++){\n\t\t\tscanf(\"%d\",&kari);\n\t\t\tc.push(kari);\n\t\t}\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif(b.top()==0 && c.top()==0)\n\t\t\t\tbreak;\n\t\t\tif(a.top()<b.top() && a.top()<c.top()){\n\t\t\t\tkari=b.top();\n\t\t\t\ta.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b.top()<c.top() ){\n\t\t\t\tkari=c.top();\n\t\t\t\tb.push(kari);\n\t\t\t\tc.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(b.top()<a.top()){\n\t\t\t\tkari=a.top();\n\t\t\t\tb.push(kari);\n\t\t\t\ta.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(c.top()<b.top() && a.top()!=b.top()-1){\n\t\t\t\tkari=b.top();\n\t\t\t\tc.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t}\n\t\t\telse{\n\t\t\t\tkari=b.top();\n\t\t\t\ta.push(kari);\n\t\t\t\tb.pop();\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif(count<m || count==m) printf(\"%d\\n\\n\",count);\n\t\telse printf(\"%d\\n\\n\",-1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nclass P{\n\tpublic:\n\tint cnt;\n\tint bef;\n\tstack< int > S[3];\n};\n\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m),(n|m)){\n\t\tP f;\n\t\tfor(int i = 0;i < 3; i++){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tfor(int j = 0; j < x; j++){\n\t\t\t\tint tmp;\n\t\t\t\tscanf(\"%d\",&tmp);\n\t\t\t\tf.S[i].push(tmp);\n\t\t\t}\n\t\t}\n\t\tf.cnt = 0;\n\t\tf.bef = -1;\n\t\tqueue< P > Q;\n\t\tQ.push(f);\n\t\tbool flg = true;\n\t\twhile( !Q.empty()){\n\t\t\tP p = Q.front();Q.pop();\n\t\t\tif(p.cnt > m){\n\t\t\t\tflg = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbool h = false;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tif(i == 1)continue;\n\t\t\t\tif(p.S[i].size() == n){\n\t\t\t\t\tprintf(\"%d\\n\",p.cnt);\n\t\t\t\t\th = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( h ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint top0 = (p.S[0].size()>0)?p.S[0].top() : 0;\n\t\t\tint top1 = (p.S[1].size()>0)?p.S[1].top() : 0;\n\t\t\tint top2 = (p.S[2].size()>0)?p.S[2].top() : 0;\n\t\t\tint copy0 = top0 , copy1 = top1 , copy2 = top2;\n\t\t\tP sub;\n\t\t\tsub.cnt = p.cnt+1;\n\t\t\tif(top0 < top1 && p.bef != 0){\n\t\t\t\tp.S[1].pop();\n\t\t\t\tp.S[0].push(top1);\n\t\t\t\tfor(int i = 0; i < 3; i++)sub.S[i] = p.S[i];\n\t\t\t\tsub.bef = 1;\n\t\t\t\tQ.push(sub);\n\t\t\t\tp.S[0].pop();\n\t\t\t\tp.S[1].push(copy1);\n\t\t\t}\n\t\t\tif(top0 > top1 && p.bef != 1) {\n\t\t\t\tp.S[0].pop();\n\t\t\t\tp.S[1].push(top0);\n\t\t\t\tfor(int i = 0; i < 3; i++)sub.S[i] = p.S[i];\n\t\t\t\tsub.bef = 0;\n\t\t\t\tQ.push(sub);\n\t\t\t\tp.S[1].pop();\n\t\t\t\tp.S[0].push(copy0);\n\t\t\t}\n\t\t\tif(top1 < top2 && p.bef != 2){\n\t\t\t\tp.S[2].pop();\n\t\t\t\tp.S[1].push(top2);\n\t\t\t\tfor(int i = 0;i < 3; i++)sub.S[i] = p.S[i];\n\t\t\t\tsub.bef = 3;\n\t\t\t\tQ.push(sub);\n\t\t\t\tp.S[1].pop();\n\t\t\t\tp.S[2].push(copy2);\n\t\t\t}\n\t\t\tif(top1 > top2 && p.bef != 3){\t\n\t\t\t\tp.S[1].pop();\n\t\t\t\tp.S[2].push(top1);\n\t\t\t\tfor(int i = 0; i < 3; i++)sub.S[i] = p.S[i];\n\t\t\t\tsub.bef = 2;\n\t\t\t\tQ.push(sub);\n\t\t\t\tp.S[2].pop();\n\t\t\t\tp.S[1].push(copy1);\n\t\t\t}\n\t\t}\n\t\tif( !flg )puts(\"-1\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#define step(n) pow(3,x-n+1)/2\nusing namespace std;\n\nint x,hanoi[16];\n\n\nint move(int s,int d,int c){\n\tif(abs(s-d)==2) return move(s,1,c)+move(1,d,c);\n\tif(c==x) return abs(s-d);\n\tif(s==d) return move(hanoi[c+1], s, c+1);\n\tfor(int i=c+1;i<=x;i++)if(hanoi[i]==s || hanoi[i]==d)return step(c) + move(hanoi[c+1], d, c+1);\n\treturn 1 + move(hanoi[c+1], d, c+1);\n}\n\nint main(){\n\tint i,n,m,t,r1,r2;\n\twhile(cin>>x>>n,n){\n\t\tfor(i=0;i<3;i++)for(cin>>m;m--;hanoi[t]=i)cin>>t;\n\t\tr1=move(hanoi[1],0,1);\n\t\tr2=move(hanoi[1],2,1);\n\t\tif(n<r1&&n<r2) r1=-1;\n\t\tcout << min(r1,r2) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\nusing namespace std;\nset<pair<string,string > >hash;\n\nint main()\n{\n  int n,m;\n  for(;cin>>n>>m,n;)\n    {\n      string table[3];\n      string finish;\n      for(int i=1;i<=n;i++)\n\t{\n\t  finish+=('0'+i);\n\t}\n      for(int i=0;i<3;i++)\n\t{\n\t  int size;\n\t  cin>>size;\n\t  for(int j=0;j<size;j++)\n\t    {\n\t      int tmp;\n\t      cin>>tmp;\n\t      table[i]+=('0'+tmp);\n\t    }\n\t}\n      //stack,step;\n      queue<pair<pair<string,string> ,pair<string ,int> > > qu;\n      qu.push(make_pair(make_pair(table[0],table[1]),make_pair(table[2],0)));\n      int ans=-1;\n\n      while(!qu.empty())\n\t{\n\t  string a=qu.front().first.first;\n\t  string b=qu.front().first.second;\n\t  string c=qu.front().second.first;\n\t  int step=qu.front().second.second;\n\t  qu.pop();\n\t  /*\n\t  cout<<\"===\"<<endl;\n\t  cout<<a<<endl;\n\t  cout<<b<<endl;\n\t  cout<<c<<endl;\n\t  cout<<step<<endl;\n\t  cout<<\"===\"<<endl;\n\t  */\n\n\t  if(a==finish || c==finish)\n\t    {\n\t      ans=step;\n\t      break;\n\t    }\n\n\t  if(hash.find(make_pair(a,c))!=hash.end())\n\t    continue;\n\t  hash.insert(make_pair(a,c));\n\n\t  if(step>=m)\n\t    continue;\n\n\n\t  char tmp;\n\t  string aa,bb,cc;\n\t  if(a!=\"\")\n\t    {\n\t      if(b==\"\"||a[a.size()-1]>b[b.size()-1] )\n\t\t{\n\t\t  tmp=a[a.size()-1];\n\t\t  aa=a.substr(0,a.size()-1);\n\t\t  bb=b+tmp;\n\t\t  cc=c;\n\t\t  if(hash.find(make_pair(aa,cc))==hash.end())\n\t\t    qu.push(make_pair(make_pair(aa,bb),make_pair(cc,step+1)));\n\t\t}\n\t    }\n\n\t  if(b!=\"\")\n\t    {\n\t      if(a==\"\"||a[a.size()-1]<b[b.size()-1] )\n\t\t{\n\t\t  tmp=b[b.size()-1];\n\t\t  bb=b.substr(0,b.size()-1);\n\t\t  aa=a+tmp;\n\t\t  cc=c;\n\t\t  if(hash.find(make_pair(aa,cc))==hash.end())\n\t\t    qu.push(make_pair(make_pair(aa,bb),make_pair(cc,step+1)));\n\n\t\t}\n\t      if(c==\"\"||c[c.size()-1]<b[b.size()-1] )\n\t\t{\n\t\t  tmp=b[b.size()-1];\n\t\t  bb=b.substr(0,b.size()-1);\n\t\t  cc=c+tmp;\n\t\t  aa=a;\n\n\t\t  if(hash.find(make_pair(aa,cc))==hash.end())\n\t\t    qu.push(make_pair(make_pair(aa,bb),make_pair(cc,step+1)));\n\t\t}\n\n\t    }\n\n\n\t  if(c!=\"\")\n\t    {\n\t      if(b==\"\"||b[b.size()-1]<c[c.size()-1] )\n\t\t{\n\t\t  tmp=c[c.size()-1];\n\t\t  cc=c.substr(0,c.size()-1);\n\t\t  bb=b+tmp;\n\t\t  aa=a;\n\t\t  if(hash.find(make_pair(aa,cc))==hash.end())\n\t\t    qu.push(make_pair(make_pair(aa,bb),make_pair(cc,step+1)));\n\t\t}\n\n\t    }\n\n\n\n\t}\n      cout<<ans<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nclass Stack {\npublic:\n  int elm[15];\n  int pos;\n  Stack() {\n    pos = 0;\n  }\n\n  bool operator < (const Stack &s) const {\n    if(pos != s.pos) return pos < s.pos;\n    for(int i = 0; i < pos; ++i) {\n      if(elm[i] != s.elm[i]) return elm[i] < s.elm[i];\n    }\n    return false;\n  }\n  bool operator == (const Stack &s) const {\n    return !(*this < s) && !(s < *this);\n  }\n  bool operator != (const Stack &s) const {\n    return !(*this == s);\n  }\n  void clear() { pos = 0; }\n  bool empty() { return pos == 0; }\n  int top() { return elm[pos-1]; }\n  void push(int a) { elm[pos++] = a; }\n  void pop() { --pos; }\n};\n\nclass State {\npublic:\n  Stack st[3];\n  int cost, goal;\n  State() : cost(0) {}\n  void init() {\n    cost = 0;\n    for(int i = 0; i < 3; ++i) {\n      st[i].clear();\n    }\n  }\n  bool isGoal() {\n    return st[(goal+1)%3].empty() && st[(goal+2)%3].empty();\n  }\n\n  bool operator < (const State &s) const {\n    if(goal != s.goal) return goal < s.goal;\n    for(int i = 0; i < 3; ++i) {\n      if(st[i] != s.st[i]) return st[i] < s.st[i];\n    }\n    return false;\n  }\n};\n\nint n, m;\nState S;\n\nvoid solve() {\n  set<State> vis;\n  queue<State> que;\n  S.goal = 0; vis.insert(S); que.push(S);\n  S.goal = 2; vis.insert(S); que.push(S);\n  while(!que.empty()) {\n    State s = que.front(); que.pop();\n    if(s.isGoal()) {\n      cout << s.cost << endl;\n      return;\n    }\n    if(s.cost > m) continue;\n    for(int f = 0; f < 3; ++f) {\n      for(int d = -1; d <= 1; d += 2) {\n\tif(s.st[f].empty()) continue;\n\tint t = f + d;\n\tif(t < 0 || t >= 3) continue;\n\tif(!s.st[t].empty() && s.st[f].top() < s.st[t].top()) continue;\n\tState ts = s;\n\tint cup = ts.st[f].top(); ts.st[f].pop();\n\tts.st[t].push(cup);\n\t++ts.cost;\n\tif(vis.find(ts) != vis.end()) continue;\n\tvis.insert(ts);\n\tque.push(ts);\n      }\n    }\n  }\n  cout << -1 << endl;\n}\n\nmain() {\n  while((cin >> n >> m) && (n ||m)) {\n    S.init();\n    for(int i = 0; i < 3; ++i) {\n      int num;\n      cin >> num;\n      for(int j = 0; j < num; ++j) {\n\tint a;\n\tcin >> a;\n\tS.st[i].push(a);\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint dfs(int from, int to, int cnt, int a[], int b[], int c[], int n, int m) {\n\tint i;\n\tif (from==0) {\n\t\tfor (i=1; i<n; i++) if (a[i]==0) break;\n\t\tint an=a[i-1]; a[i-1]=0;\n\t\tfor (i=0; i<n; i++) if (b[i]==0) break;\n\t\tif (i==0) b[0]=an;\n\t\telse if (b[i-1]>an) return -1;\n\t\telse b[i]=an;\n\t} else if (from==2) {\n\t\tfor (i=1; i<n; i++) if (c[i]==0) break;\n\t\tint cn=c[i-1]; c[i-1]=0;\n\t\tfor (i=0; i<n; i++) if (b[i]==0) break;\n\t\tif (i==0) b[0]=cn;\n\t\telse if (b[i-1]>cn) return -1;\n\t\telse b[i]=cn;\n\t}\n\tif ((a[0]==0&&b[0]==0)||(b[0]==0&&c[0]==0)) return cnt;\n\telse if (i==m) return -1;\n\tint res=m+1;\n\tfor (int i=0; i<3; i++) {\n\t\tif (i==1) {\n\t\t\tif (b[0]==0) continue;\n\t\t\tint res1=dfs(i,0,cnt+1,a,b,c,n,m);\n\t\t\tint res2=dfs(i,2,cnt+1,a,b,c,n,m);\n\t\t\tif (res1<res2&&res1!=-1) res=min(res,res1);\n\t\t\telse if (res1>=res2&&res2!=-1) res=min(res,res2);\n\t\t} else {\n\t\t\tif (i==0&&a[0]==0) continue;\n\t\t\tif (i==2&&c[0]==0) continue;\n\t\t\tint temp=dfs(i,1,cnt+1,a,b,c,n,m);\n\t\t\tif (temp!=-1) res=min(res,temp);\n\t\t}\n\t}\n\tif (res==m+1) return -1;\n\telse return res;\n}\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\",&n,&m)) {\n\t\tif (n==0&&m==0) break;\n\t\tint num, a[n], b[n], c[n];\n\t\tscanf(\"%d\",&num);\n\t\tfor (int i=0; i<num; i++) scanf(\"%d\",&a[i]);\n\t\tfor (int i=num; i<n; i++) a[i]=0;\n\t\tscanf(\"%d\",&num);\n\t\tfor (int i=0; i<num; i++) scanf(\"%d\",&b[i]);\n\t\tfor (int i=num; i<n; i++) b[i]=0;\n\t\tscanf(\"%d\",&num);\n\t\tfor (int i=0; i<num; i++) scanf(\"%d\",&c[i]);\n\t\tfor (int i=num; i<n; i++) c[i]=0;\n\t\tint res=m+1;\n\t\tfor (int i=0; i<3; i++) {\n\t\t\tif (i=1) {\n\t\t\t\tif (b[0]==0) continue;\n\t\t\t\tint res1=dfs(i,0,1,a,b,c,n,m);\n\t\t\t\tint res2=dfs(i,2,1,a,b,c,n,m);\n\t\t\t\tif (res1<res2&&res1!=-1) res=min(res,res1);\n\t\t\t\telse if (res1>=res2&&res2!=-1) res=min(res,res2);\n\t\t\t} else {\n\t\t\t\tif (i==0&&a[0]==0) continue;\n\t\t\t\tif (i==2&&c[0]==0) continue;\n\t\t\t\tint temp=dfs(i,1,1,a,b,c,n,m);\n\t\t\t\tif (temp!=-1) res=min(res,temp);\n\t\t\t}\n\t\t}\n\t\tif (res==m+1) res=-1;\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\ntypedef long long int lli;\nusing namespace std;\npriority_queue<lli> a;\npriority_queue<lli> b;\npriority_queue<lli> c;\nlli n,m,x,y,z,A[15],B[15],C[15];\n\nlli sol(bool w)\n{\n\tlli res=0;\n\twhile(a.size()!=n&&c.size()!=n){\n\t\tif(w){\n\t\t\tif(!a.empty()&& ( b.empty() || a.top()>b.top() ) ){\n\t\t\t\tb.push(a.top());\n\t\t\t\ta.pop();\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta.push(b.top());\n\t\t\t\tb.pop();\n\t\t\t}\n\t\t\tw=false;\n\t\t}\n\t\telse{\n\t\t\tif(!c.empty()&& ( b.empty() || c.top()>b.top() ) ){\n\t\t\t\tb.push(c.top());\n\t\t\t\tc.pop();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tc.push(b.top());\n\t\t\t\tb.pop();\n\t\t\t}\n\t\t\tw=true;\n\t\t}\n\t\tres++;\n\t}\n\twhile(!a.empty()) a.pop();\n\twhile(!c.empty()) c.pop();\n\treturn res;\n}\n\nint main()\n{\nwhile(1){\n\tscanf(\"%lld %lld\",&n,&m);\n\tif(n==0&&m==0) return 0;\n\tscanf(\"%lld\",&x);\n\tfor(int i=0;i<x;i++) {scanf(\"%lld\",&A[i]); a.push(A[i]);}\n\tscanf(\"%lld\",&y);\n\tfor(int i=0;i<y;i++) {scanf(\"%lld\",&B[i]); b.push(B[i]);}\n\tscanf(\"%lld\",&z);\n\tfor(int i=0;i<z;i++) {scanf(\"%lld\",&C[i]); c.push(C[i]);}\n\tlli p=sol(1);\n\tfor(int i=0;i<x;i++) {a.push(A[i]);}\n\tfor(int i=0;i<y;i++) {b.push(B[i]);}\n\tfor(int i=0;i<z;i++) {c.push(C[i]);}\n\tp=min(p,sol(0));\n\tif(p>m) p=-1;\n\tprintf(\"%lld\\n\",p);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\nconst int NONE = -1;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( A != 0 ) {\n        int u = get_last(A);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( remove_last( A ), B | u, C, turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    if ( B != 0 ) {\n        {\n            int u = get_last(B);\n            int v = get_last(A);\n            if ( u > v ) {\n                int ret = solve( A | u, remove_last(B), C, turns + 1 );\n                if ( ret != NONE ) return ret;\n            }\n        }\n        {\n            int u = get_last(B);\n            int v = get_last(C);\n            if ( u > v ) {\n                int ret = solve( A, remove_last(B), C | u, turns + 1 );\n                if ( ret != NONE ) return ret;\n            }\n        }\n    }\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = NONE; // solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == NONE && ret2 == NONE ) {\n            cout << -1 << endl;\n        } else if ( ret1 != NONE && ret2 != NONE ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != NONE ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != NONE ) {\n            cout << ret2 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <cstring>\nusing namespace std;\n\nint n, m, cnt;\nint pos[20], tmpPos[20];\n\nvoid copyPos(int *fromPos, int *toPos){\n  for(int i = 0; i < 20; i++){\n    toPos[i] = fromPos[i];\n  }\n}\n\nvoid toC(int x);\n\nvoid toA(int x){\n  if(pos[x] == 0){\n    return;\n  }\n\n  if(pos[x] == 2){\n    //xより大きいコップを全てAに移す\n    for(int i = x + 1; i < n; i++){\n      toA(i);\n      if(cnt > m) return;\n    }\n\n    //Bにコップxを移す\n    cnt++;\n    if(cnt > m) return;\n\n    pos[x] = 1;\n  }\n\n  if(pos[x] == 1){\n    //xより大きいコップを全てCに移す\n    for(int i = x + 1; i < n; i++){\n      toC(i);\n      if(cnt > m) return;\n    }\n\n    //Aにコップxを移す\n    cnt++;\n    if(cnt > m) return;\n\n    pos[x] = 0;\n  }\n}\n\nvoid toC(int x){\n  if(pos[x] == 2){\n    return;\n  }\n\n  if(pos[x] == 0){\n    //xより大きいコップを全てCに移す\n    for(int i = x + 1; i < n; i++){\n      toC(i);\n      if(cnt > m) return;\n    }\n\n    //Bにコップxを移す\n    cnt++;\n    if(cnt > m) return;\n\n    pos[x] = 1;\n  }\n\n  if(pos[x] == 1){\n    //xより大きいコップを全てAに移す\n    for(int i = x + 1; i < n; i++){\n      toA(i);\n      if(cnt > m) return;\n    }\n\n    //Cにコップxを移す\n    cnt++;\n    if(cnt > m) return;\n\n    pos[x] = 2;\n  }\n}\n\nvoid solve(){\n  int res = m + 1;\n\n  copyPos(pos, tmpPos);\n  cnt = 0;\n\n  for(int i = 0; i < n; i++){\n    toA(i);\n    if(cnt > m) break;\n  }\n\n  res = min(res, cnt);\n  copyPos(tmpPos, pos);\n  cnt = 0;\n\n  for(int i = 0; i < n; i++){\n    toC(i);\n    if(cnt > m) break;\n  }\n\n  res = min(res, cnt);\n\n  cout << (res == m + 1 ? -1 : res) << endl;\n}\n\nint main(){\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < 3; i++){\n      int a;\n      cin >> a;\n\n      for(int j = 0; j < a; j++){\n        int x;\n        cin >> x;\n        x--;\n        pos[x] = i;\n      }\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,n) for(ll (i)=0;(i)<(n);++(i))\nusing namespace std;\n\nint main(){\n    while(true){\n        ll n,m;\n        cin>>n>>m;\n        if(n==0&&m==0)return 0;\n        ll s=0;\n        rep(i,3){\n            ll num;\n            cin>>num;\n            rep(j,num){\n                ll p;\n                cin>>p;\n                p--;\n                s+=(i<<(p*2));\n            }\n        }\n        ll c2=0;\n        rep(i,n){\n            c2+=(2<<(i*2));\n        }\n        queue<pair<ll,ll>> que;\n        que.push(make_pair(s,0));\n        set<ll> used;\n        used.insert(s);\n        bool flag=true;\n        while(que.size()){\n            pair<ll,ll> pa=que.front();\n            que.pop();\n            ll state=pa.first;\n            ll number=pa.second;\n            if(state==0 || state==c2){\n                cout<<number<<endl;\n                flag=false;\n                break;\n            }\n            for(ll i=0;i<2;i++){\n                for(ll j=i+1;j<3;j++){\n                    if(i==0&&j==2)continue;\n                    ll m1=-1;\n                    ll m2=-1;\n                    rep(k,n){\n                        if(~(state>>(k*2) ^ i) & 1 && ~(state>>(k*2) ^ i) & 1<<1){\n                            m1=k;\n                        }\n                        if(~(state>>(k*2) ^ j) & 1 && ~(state>>(k*2) ^ j) & 1<<1){\n                            m2=k;\n                        }\n                    }\n                    if(m1>m2&&number<m){\n                        ll ns=state;\n                        ns=ns-(i<<(m1*2))+(j<<(m1*2));\n                        if(used.find(ns)!=used.end())continue;\n                        que.push(make_pair(ns,number+1));\n                        used.insert(ns);\n                    }else if(m1<m2&&number<m){\n                        ll ns=state;\n                        ns=ns-(j<<(m2*2))+(i<<(m2)*2);\n                        if(used.find(ns)!=used.end())continue;\n                        que.push(make_pair(ns,number+1));\n                        used.insert(ns);\n                    }\n                }\n            }\n        }\n        if(flag)cout<<-1<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint n, m;\nstruct puzzle {\n\tchar f[3][15];\n\tint len[3], cnt;\n};\nbool operator==(const puzzle&left, const puzzle&right) {\n\trep(i, 3) {\n\t\tif (strcmp(left.f[i], right.f[i]))return false;\n\t}\n\treturn true;\n}\ntemplate<>\nclass hash<puzzle> {\npublic:\n\tinline size_t operator()(const puzzle&p) const {\n\t\tsize_t cnt = 0;\n\t\trep(i, 3) {\n\t\t\thash<string>H;\n\t\t\tcnt += (i + 1)*H(p.f[i]);\n\t\t}\n\t\treturn cnt;\n\t}\n};\n\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tpuzzle in{};\n\t\trep(i, 3) {\n\t\t\tscanf(\"%d\", &in.len[i]);\n\t\t\trep(j, in.len[i])scanf(\"%d\", &in.f[i][j]);\n\t\t}\n\t\tunordered_map<puzzle, bool>mp;\n\t\tqueue<puzzle>que;\n\t\tmp[in] = true;\n\t\tque.push(in);\n\t\twhile (!que.empty()) {\n\t\t\tpuzzle u = que.front(); que.pop();\n\t\t\tif (u.len[0] == n || u.len[2] == n) {\n\t\t\t\tprintf(\"%d\\n\", u.cnt);\n\t\t\t\tgoto g;\n\t\t\t}\n\t\t\tif (u.cnt >= m)continue;\n\t\t\trep(k, 2)rep(t, 2) {\n\t\t\t\tint i, j;\n\t\t\t\tif (t) { i = k, j = k + 1; }\n\t\t\t\telse { i = k + 1; j = k; }\n\t\t\t\tif (u.len[i] == 0)continue;\n\t\t\t\tif (u.len[j] > 0 && (u.f[i][u.len[i] - 1] < u.f[j][u.len[j] - 1]))\n\t\t\t\t\tcontinue;\n\t\t\t\tpuzzle v = u;\n\t\t\t\tv.len[i]--; v.len[j]++;\n\t\t\t\tswap(v.f[i][v.len[i]], v.f[j][v.len[j] - 1]);\n\t\t\t\tif (!mp[v]) {\n\t\t\t\t\tmp[v] = true;\n\t\t\t\t\tv.cnt++;\n\t\t\t\t\tque.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"-1\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\nusing namespace std;\nset<pair<string,string > >hash;\n\nint main()\n{\n  int n,m;\n  for(;cin>>n>>m,n;)\n    {\n      string table[3];\n      string finish;\n      for(int i=1;i<=n;i++)\n\t{\n\t  finish+=('0'+i);\n\t}\n      for(int i=0;i<3;i++)\n\t{\n\t  int size;\n\t  cin>>size;\n\t  for(int j=0;j<size;j++)\n\t    {\n\t      char tmp;\n\t      cin>>tmp;\n\t      table[i]+=tmp;\n\t    }\n\t}\n      //stack,step;\n      queue<pair<pair<string,string> ,pair<string ,int> > > qu;\n      qu.push(make_pair(make_pair(table[0],table[1]),make_pair(table[2],0)));\n      int ans=-1;\n\n      while(!qu.empty())\n\t{\n\t  string a=qu.front().first.first;\n\t  string b=qu.front().first.second;\n\t  string c=qu.front().second.first;\n\t  int step=qu.front().second.second;\n\t  qu.pop();\n\n\t  if(a==finish || c==finish)\n\t    {\n\t      ans=step;\n\t      break;\n\t    }\n\n\t  if(hash.find(make_pair(a,c))!=hash.end())\n\t    continue;\n\t  hash.insert(make_pair(a,c));\n\n\t  if(step==m)\n\t    continue;\n\n\t  if(!a.empty())\n\t    {\n\t      if(b==\"\"||a[a.size()-1]>b[b.size()-1] )\n\t\t{\n\t\t  char tmp=a[a.size()-1];\n\t\t  string aa=a.substr(0,a.size()-1);\n\t\t  string bb=b+tmp;\n\t\t  if(hash.find(make_pair(aa,c))==hash.end())\n\t\t    qu.push(make_pair(make_pair(aa,bb),make_pair(c,step+1)));\n\t\t}\n\t    }\n\t  if(!b.empty())\n\t    {\n\t      if(a==\"\"||a[a.size()-1]<b[b.size()-1] )\n\t\t{\n\t\t  char tmp=b[b.size()-1];\n\t\t  string bb=b.substr(0,b.size()-1);\n\t\t  string aa=a+tmp;\n\t\t  if(hash.find(make_pair(aa,c))==hash.end())\n\t\t    qu.push(make_pair(make_pair(aa,bb),make_pair(c,step+1)));\n\n\t\t}\n\t      if(c==\"\"||c[b.size()-1]<b[b.size()-1] )\n\t\t{\n\t\t  char tmp=b[b.size()-1];\n\t\t  string bb=b.substr(0,b.size()-1);\n\t\t  string cc=c+tmp;\n\t\t  if(hash.find(make_pair(a,cc))==hash.end())\n\t\t    qu.push(make_pair(make_pair(a,bb),make_pair(cc,step+1)));\n\n\t\t}\n\n\t    }\n\t  if(!c.empty())\n\t    {\n\t      if(b==\"\"||b[b.size()-1]<c[c.size()-1] )\n\t\t{\n\t\t  char tmp=c[c.size()-1];\n\t\t  string cc=c.substr(0,c.size()-1);\n\t\t  string bb=b+tmp;\n\t\t  if(hash.find(make_pair(a,cc))==hash.end())\n\t\t    qu.push(make_pair(make_pair(a,bb),make_pair(cc,step+1)));\n\t\t}\n\n\t    }\n\n\n\n\t}\n      cout<<ans<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\n\nsigned main(){\n  Int n,m;\n\n  while(cin>>n>>m,n){\n    auto encode=[n](auto &v){\n      Int x=0;\n      for(Int i=0;i<n;i++) x=x*3+v[i];\n      return x;\n    };\n  \n    auto decode=[n](Int x){\n      vector<Int> v(n);\n      for(Int i=0;i<n;i++){\n\tv[n-(i+1)]=x%3;\n\tx/=3;\n      }\n      return v;\n    };\n\n    vector<Int> dp(14348907,-1);\n    \n    queue<Int> q;\n    for(Int i=0;i<2;i++){\n      vector<Int> b(n,i*2);\n      Int k=encode(b);\n      dp[k]=0;\n      q.emplace(k);\n    }\n\n    while(!q.empty()){\n      Int k=q.front();\n      vector<Int> v=decode(k);q.pop();\n      vector<Int> x(3,-1);\n      for(Int i=0;i<n;i++) x[v[i]]=i;\n      for(Int i=0;i<3;i++){\n\tfor(Int j=0;j<3;j++){\n\t  if(i==j||abs(i-j)==2) continue;\n\t  if(x[i]>x[j]){\n\t    v[x[i]]=j;\n\t    Int nk=encode(v);\n\t    if(dp[nk]<0){\n\t      dp[nk]=dp[k]+1;\n\t      q.emplace(nk);\n\t    }\n\t    v[x[i]]=i;\n\t  }\n\t}\n      }\t  \n    }\n  \n    vector<Int> v(n);\n    for(Int i=0;i<3;i++){\n      Int k;\n      cin>>k;\n      for(Int j=0;j<k;j++){\n\tInt x;\n\tcin>>x;\n\tv[x-1]=i;\n      }\n    }\n    Int k=encode(v);\n    //cout<<k<<\":\"<<dp[k]<<endl;\n    cout<<(dp[k]>m?-1:dp[k])<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//24\n#include<iostream>\n#include<vector>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  vector<int> v[3];\n  int t;\n};\n\nvector<int> cv(vector<int> *v){\n  vector<int> r(15);\n  for(int i=0;i<3;i++){\n    for(int j=0;j<v[i].size();j++){\n      r[v[i][j]]=i;\n    }\n  }\n  return r;\n}\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    S is;\n    for(int i=0;i<3;i++){\n      int e;\n      cin>>e;\n      is.v[i].resize(e);\n      for(int j=0;j<e;j++){\n\tcin>>is.v[i][j];\n      }\n    }\n    is.t=0;\n    if(is.v[0]>is.v[2]){\n      is.v[0].swap(is.v[2]);\n    }\n    queue<S> que;\n    que.push(is);\n    map<vector<int>,bool> mem;\n    while(!que.empty()&&que.front().t<=m){\n      S c=que.front();\n      if(c.v[2].size()==n)break;\n      que.pop();\n      if(mem[cv(c.v)]++)continue;\n      for(int i=0;i<3;i++){\n\tfor(int j=-1;j<=1;j+=2){\n\t  if(0<=i+j&&i+j<=2&&!c.v[i].empty()&&(c.v[i+j].empty()||c.v[i].back()>c.v[i+j].back())){\n\t    S ns=c;\n\t    ns.v[i+j].push_back(ns.v[i].back());\n\t    ns.v[i].pop_back();\n\t    ns.t++;\n\t    if(ns.v[0]>ns.v[2]){\n\t      ns.v[0].swap(ns.v[2]);\n\t    }\n\t    que.push(ns);\n\t  }\n\t}\n      }\n    }\n    if(!que.empty()&&que.front().t<=m){\n      cout<<que.front().t<<endl;\n    }else{\n      cout<<-1<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint n,m;\n\nint dfs(vector< vector<int> > &d, int f){\n\tif(f==m) return m+1;\n\telse{\n// cout << \"------------\" << f << \" ----------\" << endl;\n// for(int i=0;i<3;i++){\n// \tfor(int j=0;j<d[i].size();j++){\n// \t\tcout << d[i][j] << \" \";\n// \t}cout << endl;\n// }\n// cout << \"------------------------------\" << endl;\n\t\tif(d[0].size()==n || d[n-1].size()==n)return f;\n\t\tint res = m+1;\n\t\tfor(int i=0;i<d.size()-1;i++){\n\t\t\tif(d[i].empty())continue;\n\t\t\tif(d[i+1].empty()||d[i].back()>d[i+1].back()){\n\t\t\t\td[i+1].push_back(d[i].back());\n\t\t\t\td[i].pop_back();\n\t\t\t\tres = min(res,dfs(d,f+1));\n\t\t\t\td[i].push_back(d[i+1].back());\n\t\t\t\td[i+1].pop_back();\n\t\t\t}\n\t\t}\n\t\tfor(int i=d.size()-1;i>0;i--){\n\t\t\tif(d[i].empty())continue;\n\t\t\tif(d[i-1].empty()||d[i].back()>d[i-1].back()){\n\t\t\t\td[i-1].push_back(d[i].back());\n\t\t\t\td[i].pop_back();\n\t\t\t\tres = min(res,dfs(d,f+1));\n\t\t\t\td[i].push_back(d[i-1].back());\n\t\t\t\td[i-1].pop_back();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nint main(){\n\n\twhile(cin >> n >> m,n&&m){\n\t\tint k,l;\n\t\tvector<vector<int> > d(3,vector<int>());\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin >> k;\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tcin >> l;\n\t\t\t\td[i].push_back(l);\n\t\t\t}\n\t\t}\n\t\tint t = dfs(d,0);\n\t\tt = t > m ? -1 : t;\n\t\tcout << t << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout.precision(12);\n    cout.setf(ios_base::fixed, ios_base::floatfield);\n    \n    while(true){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0 && m == 0) break;\n        ull state = 0;\n        for(int i=0;i<3;i++){\n            int q;\n            cin >> q;\n            for(int j=0;j<q;j++){\n                int a;\n                cin >> a;\n                state |= ((ull)(i+1))<<(a*2);\n            }\n        }\n        queue<pair<unsigned int, int>> Q;\n        unordered_set<unsigned int> checked;\n        Q.push({state, 0});\n        checked.insert(state);\n        while(!Q.empty()){\n            unsigned int top = Q.front().first;\n            int cost = Q.front().second;\n            Q.pop();\n            if(cost > m){\n                cout << -1 << endl;\n                goto next;\n            }\n            int cnt[3] = {0}, mx[3] = {0};\n            for(int i=1;i<=n;i++){\n                int pos = (top >> (2*i))&3;\n                cnt[pos-1]++;\n                mx[pos-1] = max(mx[pos-1], i);\n            }\n            if(cnt[1]==0 && (cnt[0]==0 || cnt[2]==0)){\n                cout << cost << endl;\n                goto next;\n            }\n            if(mx[0]>mx[1] && checked.count(top^(3LL<<(mx[0]*2)))==0){\n                Q.push({top^(3LL<<(mx[0]*2)), cost+1});\n                checked.insert(top^(3LL<<(mx[0]*2)));\n            }\n            if(mx[2]>mx[1] && checked.count(top^(1LL<<(mx[2]*2)))==0){\n                Q.push({top^(1LL<<(mx[2]*2)), cost+1});\n                checked.insert(top^(1LL<<(mx[2]*2)));\n            }\n            if(mx[1]>mx[0] && checked.count(top^(3LL<<(mx[1]*2)))==0){\n                Q.push({top^(3LL<<(mx[1]*2)), cost+1});\n                checked.insert(top^(3LL<<(mx[1]*2)));\n            }\n            if(mx[1]>mx[2] && checked.count(top^(1LL<<(mx[1]*2)))==0){\n                Q.push({top^(1LL<<(mx[1]*2)), cost+1});\n                checked.insert(top^(1LL<<(mx[1]*2)));\n            }\n        }\n        cout << -1 << endl;\n        next: ;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nint main(){\n    while(true){\n\tint n,m;\n\tcin >> n >> m;\n\tif(n == 0 && m == 0 ) break;\n\tset< pair<int,int> > s;\n\tvector< vector<int> > cup(3);\n\tREP(i,3){\n\t    int t;\n\t    cin >> t;\n\t    REP(j,t){\n\t\tint temp;\n\t\tcin >> temp;\n\t\tcup[i].PB(temp);\n\t    }\n\t}\n\tqueue< vector< vector<int> > > q;\n\tqueue<int> qv;\n\tq.push(cup);\n\tqv.push(0);\n\tint ans = 2000000000;\n\twhile(!q.empty()){\n\t    cup = q.front();\n\t    int v = qv.front();\n\t    q.pop();\n\t    qv.pop();\n\t    pair<int,int> temp(0,0);\n\t    REP(j,cup[0].size()){\n\t\ttemp.first += 1<<cup[0][j];\n\t    }\n\t    REP(j,cup[1].size()){\n\t\ttemp.second += 1<<cup[1][j];\n\t    }\n\n\t    if(s.find(temp) != s.end()) continue;\n\t    else s.insert(temp);\n\t    if(cup[1].size() == 0 && (cup[0].size() == 0||cup[2].size() == 0)){\n\t\tans = v;\n \t\tbreak;\n\t    }\n\t    REP(i,2){\n\t\tif(cup[i].size() > 0 && (cup[i+1].size() == 0 || cup[i].back() > cup[i+1].back())){\n\t\t    cup[i+1].PB(cup[i].back());\n\t\t    cup[i].erase(cup[i].end()-1);\n\t\t    q.push(cup);\n\t\t    qv.push(v+1);\n\t\t    cup[i].PB(cup[i+1].back());\n\t\t    cup[i+1].erase(cup[i+1].end()-1);\n\t\t}\n\t\tif(cup[i+1].size() > 0 && (cup[i].size() == 0 || cup[i].back() < cup[i+1].back())){\n\t\t    cup[i].PB(cup[i+1].back());\n\t\t    cup[i+1].erase(cup[i+1].end()-1);\n\t\t    q.push(cup);\n\t\t    qv.push(v+1);\n\t\t    cup[i+1].PB(cup[i].back());\n\t\t    cup[i].erase(cup[i].end()-1);\n\t\t}\n\t    }\n\t}\n\tif(ans > m) ans = -1;\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <functional>\n#include <array>\n#include <stack>\n#include <queue>\n#include <chrono>\n#include <numeric>\n#include <memory.h>\n#include <map>\n#include <math.h>\n\n#include \"graph.h\"\n\n#pragma warning(disable:4996)\n#define REP(i,n) for(int i = 0 ; i < n ; ++i)\ntypedef long long Int;\nconst double PI = 3.141592653589793238;\nconst Int INF = 999999999999;\nusing namespace std;\n\nint dx[4] = { 0, -1, 0, 1 };\nint dy[4] = { 1, 0, -1, 0 };\n\nstruct state{\n\tvector<int> A, B, C;\n\tint step = 0;\n};\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n&&m){\n\t\tqueue<state> que;\n\n\t\tstate s;\n\t\tREP(i,3){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tREP(j,k){\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tif (i ==0)\n\t\t\t\t\ts.A.push_back(a);\n\t\t\t\tif (i == 1)\n\t\t\t\t\ts.B.push_back(a);\n\t\t\t\tif (i == 2)\n\t\t\t\t\ts.C.push_back(a);\n\t\t\t}\n\t\t}\n\n\t\tque.push(s);\n\t\twhile (!que.empty()){\n\t\t\tstate now = que.front();\n\t\t\tque.pop();\n\n\t\t\tif ((now.B.empty() && now.C.empty()) || (now.B.empty() && now.A.empty())){\n\t\t\t\tcout << now.step << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (now.step > m){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!now.A.empty() && (now.B.empty() || (now.A.back() > now.B.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tnext.B.push_back(next.A.back());\n\t\t\t\tnext.A.pop_back();\n\t\t\t\t++next.step;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t\tif (!now.B.empty() && (now.A.empty() || (now.A.back() < now.B.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tnext.A.push_back(next.B.back());\n\t\t\t\tnext.B.pop_back();\n\t\t\t\t++next.step;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t\tif (!now.B.empty() && (now.C.empty() || (now.B.back() > now.C.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tnext.C.push_back(next.B.back());\n\t\t\t\tnext.B.pop_back();\n\t\t\t\t++next.step;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t\tif (!now.C.empty() && (now.B.empty() || (now.B.back() < now.C.back()))){\n\t\t\t\tstate next = now;\n\t\t\t\tnext.B.push_back(next.C.back());\n\t\t\t\tnext.C.pop_back();\n\t\t\t\t++next.step;\n\t\t\t\tque.push(next);\n\t\t\t}\n\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint d[3][16];\nint x;\nint i,j,k;\nint m,n;\nint ans=0;\nint goal;\nint now[3];\nint p,q;\n\nint other(int a,int b){\n\tif(a==0&&b==1)return 2;\n\tif(b==0&&a==1)return 2;\n\tif(a==0&&b==2)return 1;\n\tif(b==0&&a==2)return 1;\n\tif(a==1&&b==2)return 0;\n\tif(b==1&&a==2)return 0;\n}\n\nvoid move(int n,int a,int b,int to){\nstart:\n\tif(ans>m)return;\n\tif(n!=d[a][b])return;\n\tprintf(\"%d %d %d\\n\",a,b,to);\n\tfor(int k=0;k<3;k++){\n\t\tfor(int l=0;l<16;l++)if(d[k][l]>0)printf(\"%d \",d[k][l]);\n\t\tprintf(\"\\n\");\n\t}\n\tif(to-a==2||a-to==2){\n\t\tprintf(\"1\\n\");\n\t\tmove(d[a][b],a,b,1);\n\t\tmove(d[1][now[1]-1],1,now[1]-1,to);\n\t\tif(now[a]==0)return;\n\t\tif(d[a][b]==-1)b=now[a]-1;\n\t\tgoto start;\n\t}\n\tif(d[a][b+1]>0){\n\t\tprintf(\"2\\n\");\n\t\tmove(d[a][b+1],a,b+1,other(a,to));\n\t\tif(now[a]==0)return;\n\t\tif(d[a][b]==-1)b=now[a]-1;\n\t\tgoto start;\n\t}\n\tif(now[to]>=1&&d[to][now[to]-1]>d[a][b]){\n\t\tprintf(\"3\\n\");\n\t\tmove(d[to][now[to]-1],to,now[to]-1,other(a,to));\n\t\tif(now[a]==0)return;\n\t\tif(d[a][b]==-1)b=now[a]-1;\n\t\tgoto start;\n\t}\n\td[to][now[to]++]=d[a][b];\n\td[a][b]=-1;\n\tnow[a]--;\n\tans++;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)break;\n\t\tans=0;\n\t\tfor(i=0;i<3;i++)for(j=0;j<16;j++)d[i][j]=-1;\n\t\tfor(i=0;i<3;i++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tfor(j=0;j<x;j++){\n\t\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\t}\n\t\t\tnow[i]=x;\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(i==0){\n\t\t\t\tif(d[1][0]==1){\n\t\t\t\t\tif(d[2][0]>d[0][0]){\n\t\t\t\t\t\tif(now[0]==0)goal=0;\n\t\t\t\t\t\telse goal=2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(now[2]==0)goal=2;\n\t\t\t\t\t\telse goal=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(d[0][0]==1)goal=0;\n\t\t\t\telse goal=2;\n\t\t\t}\n\t\t\tp=-1;q=-1;\n\t\t\tfor(j=0;j<3;j++)for(k=0;k<16;k++)if(d[j][k]==i+1){p=j;q=k;}\n\t\t\tif(p!=-1&&q!=-1)if(p!=goal)move(i+1,p,q,goal);\n\t\t\tif(ans>m)break;\n\t\t}\n\t\tif(ans<=m)printf(\"%d\\n\",ans);\n\t\telse printf(\"-1\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int MAX_N = 15;\nstatic const int MAX_M = 15000000;\n\nenum Tray { A, B, C, NUM };\nenum Dir { LEFT = -1, RIGHT = 1 };\n\nstatic int dir[]{LEFT, RIGHT};\n\nstruct Data {\n  set<int, greater<int>> tray[NUM];\n  Tray from, to;\n  int count;\n};\n\nint N, M;\n\nint bfs(Data d) {\n  queue<Data> que;\n  que.push(d);\n\n  while (!que.empty()) {\n    Data d = que.front(); que.pop();\n    if (d.tray[A].size() == N || d.tray[C].size() == N)\n      return d.count;\n    if (d.count >= M)\n      break;\n    for (int t{A}; t <= C; ++t) {\n      for (int i{}; i < 2; ++i) {\n        int nt = t + dir[i];\n        if (nt < A || nt > C)\n          continue;\n        if (t == d.to && nt == d.from)\n          continue;\n        auto it = d.tray[t].begin();\n        if (it == d.tray[t].end())\n          continue;\n        int t_cup = *it;\n        it = d.tray[nt].begin();\n        int nt_cup{};\n        if (it != d.tray[nt].end()) {\n          nt_cup = *it;\n        }\n        if (t_cup < nt_cup)\n          continue;\n        Data nd = d;\n        nd.tray[nt].insert(t_cup);\n        nd.tray[t].erase(t_cup);\n        nd.from = static_cast<Tray>(t);\n        nd.to = static_cast<Tray>(nt);\n        ++nd.count;\n        que.push(nd);\n      }\n    }\n  }\n\n  return -1;\n}\n\nint main() {\n  while (true) {\n    cin >> N >> M;\n    if (N == 0 && M == 0)\n      break;\n    Data d{};\n    for (int t{A}; t <= C; ++t) {\n      int num;\n      cin >> num;\n      for (int i{}; i < num; ++i) {\n        int cup;\n        cin >> cup;\n        d.tray[t].insert(cup);\n      }\n    }\n    cout << bfs(d) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint n,m;\n\nint dfs(vector< vector<int> > &d, int f){\n\tif(f==m) return m+1;\n\telse{\n// cout << \"------------\" << f << \" ----------\" << endl;\n// for(int i=0;i<3;i++){\n// \tfor(int j=0;j<d[i].size();j++){\n// \t\tcout << d[i][j] << \" \";\n// \t}cout << endl;\n// }\n// cout << \"------------------------------\" << endl;\n\t\tif(d[0].size()==n || d[n-1].size()==n)return f;\n\t\tint res = m+1;\n\t\tfor(int i=0;i<d.size()-1;i++){\n\t\t\tif(d[i].empty())continue;\n\t\t\tif(d[i+1].empty()||d[i].back()>d[i+1].back()){\n\t\t\t\td[i+1].push_back(d[i].back());\n\t\t\t\td[i].pop_back();\n\t\t\t\tres = min(res,dfs(d,f+1));\n\t\t\t\td[i].push_back(d[i+1].back());\n\t\t\t\td[i+1].pop_back();\n\t\t\t}\n\t\t}\n\t\tfor(int i=d.size()-1;i>0;i--){\n\t\t\tif(d[i].empty())continue;\n\t\t\tif(d[i-1].empty()||d[i].back()>d[i-1].back()){\n\t\t\t\td[i-1].push_back(d[i].back());\n\t\t\t\td[i].pop_back();\n\t\t\t\tres = min(res,dfs(d,f+1));\n\t\t\t\td[i].push_back(d[i-1].back());\n\t\t\t\td[i-1].pop_back();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nint main(){\n\t\t\tvector<vector<int> > d(3,vector<int>());\n\twhile(cin >> n >> m,n&&m){\n\n\t\tint k,l;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin >> k;\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tcin >> l;\n\t\t\t\td[i].push_back(l);\n\t\t\t}\n\t\t}\n\t\tint t = dfs(d,0);\n\t\tt = t > m ? -1 : t;\n\t\tcout << t << endl;\n\t\t\tfor(int i=0;i<3;i++)d[i].clear();\n\t}\n\n}"
  },
  {
    "language": "Haskell",
    "code": "import qualified Data.Text as T\nimport qualified Data.Text.IO as TI\nimport Control.Applicative\nimport Control.Monad.Trans.Class\nimport Control.Monad.Trans.Maybe\nimport Control.Arrow\nimport Data.Maybe\nimport Control.Monad\n\nread'::T.Text->Int\nread'=read.T.unpack\n\ngame::(Num a,Ord a)=>(a,a)->(a,a)\ngame (a,b) = \n\tif a > b then\n\t\t(a+b,0)\n\telse if a==b then\n\t\t(a,b)\n\telse\n\t\t(0,a+b)\n\t\t\ntailMay::[a]->Maybe [a]\t\ntailMay (_:xs) = Just xs\ntailMay [] = Nothing\n\nadd::Num a=>(a,a)->(a,a)->(a,a)\nadd (a,b) (c,d) = (a+c,b+d)\n\nconvert::Show a=>(a,a)->String\nconvert (a,b) = show a++\" \"++show b\n\n(<$~>)::Functor f => f a -> (a -> b) -> f b \n(<$~>)=flip (<$>)\ninfixl 4 <$~>\n\ncheckMaybe::(a->Bool)->a->Maybe a\ncheckMaybe f v = if f v then Just v else Nothing\n\ntoTuple (a:b:[])=(a,b)\n{-run::IO (Maybe ())\nrun = runMaybeT$\n    lift TI.getContents<$~>\n    T.lines>>=\n    (MaybeT).return.checkMaybe ((/=T.pack \"0\").head)>>=\n    (MaybeT).return.tailMay>>=\n    fmap (T.split (==' '))<$~>\n    fmap (fmap read')<$~>\n    fmap toTuple<$~>return>>=\n     (MaybeT).return.sequence>>=\n    fmap game<$~>\n    foldr add (0,0)<$~>\n    convert<$~>return\n    >>=lift.putStrLn-}\nrun = runMaybeT$ do{\n\tn<-read<$>lift getLine;\n\tif n==0 then \n\t\tMaybeT$return$Nothing \n\telse\n\t\treturn ();\n\tlift (sequence (replicate n TI.getLine))<$~>\n\t\tfmap (T.split (==' '))<$~>\n\t\tfmap (fmap read')<$~>\n\t\tfmap toTuple<$~>\n\t\tfmap game<$~>\n\t\tfoldr add (0,0)<$~>\n\t\tconvert>>=\n\t\tlift.putStrLn;\n}\nwhileMaybeM::Monad m=>m(Maybe a)->m ()\nwhileMaybeM f = do\n\tr<-f\n\tif isJust r then\n\t\twhileMaybeM f\n\telse\n\t\treturn ()\nmain = whileMaybeM run"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns#-}\nmodule Main where\n\nimport Data.List\nimport Data.Maybe\nimport Control.Monad\nimport Data.Functor\n\nmain :: IO ()\nmain = do\n  (cups,mvs) <- getNM\n  unless (cups==0 && mvs==0) $\n    do\n      initState <- getState\n      print $ solve mvs initState cups\n      main\n  where\n    getNM::IO (Int,Int)\n    getNM=do\n       (n:m:_)<-map read . words <$> getLine\n       return (n,m)\n    getTray::IO [Int]\n    getTray=do\n      (n:try) <- map read . words <$> getLine\n      return $ reverse $ take n try\n    getState::IO GameState\n    getState=do\n      [ta,tb,tc] <-replicateM 3 getTray\n      return $ GameState (Tray ta tb tc) []\n\ndata Move=AB|BA|BC|CB deriving(Eq,Show)\n\ndata Tray=Tray {trayA::[Int]\n              , trayB::[Int]\n              , trayC::[Int]\n               }deriving(Eq,Show)\n\ndata GameState=GameState {tray::Tray\n                        , history::[Move]}deriving(Show)\ninstance Eq GameState where\n  (GameState tr1 _)==(GameState tr2 _)=tr1==tr2\n\nsolveS1::Straight->Int\nsolveS1 (ToA x) =solveS x\nsolveS1 (ToC x)=solveS x\nsolveS::Int->Int\nsolveS 0=0\nsolveS !n=2 + (3 * solveS (n-1))\n\nsolve::Int->GameState->Int->Int\nsolve mvs state len=fromMaybe ( -1) $ solve' [maxBound] mvs [state] mvs len\n  where\n    solve'::[Int]->Int->[GameState]->Int->Int->Maybe Int\n    solve' !as !m !states !n !len=\n      let min_=minimum as in\n      case () of\n        _ |null states -> Just min_\n          |min_ <= m-n ->Just min_\n          |0>n ->Nothing\n          |otherwise ->      let (str,noStr)=span (isStraight1 . (`isStraight` len)) states\n                                 anss=map ((+(m-n)) . solveS1 . (`isStraight` len)) str\n                                 upds=concatMap (\\s->moves (noReturn s) s) noStr\n                             in solve' (anss ++ as) m (nub upds) (n-1) len\n\n\n\nmove::Move->GameState->Maybe GameState\nmove mv (GameState tray hist)=do\n  tray' <- move'' mv tray\n  return $ GameState tray' (mv:hist)\n  where\n    move''::Move->Tray->Maybe Tray\n    move'' AB (Tray ta tb tc)=do\n      (ta',tb') <- move' (ta,tb)\n      return $ Tray ta' tb' tc\n    move'' BA (Tray ta tb tc)=do\n      (tb',ta') <- move' (tb,ta)\n      return $ Tray ta' tb' tc\n    move'' BC (Tray ta tb tc)=do\n      (tb',tc') <- move' (tb,tc)\n      return $ Tray ta tb' tc'\n    move'' CB (Tray ta tb tc)=do\n      (tc',tb') <- move' (tc,tb)\n      return $ Tray ta tb' tc'\n    move'::([Int],[Int])->Maybe([Int],[Int])\n    move' ([],_)=Nothing\n    move' (x:xs,[])=Just (xs,[x])\n    move' (x:xs,tr@(y:ys))\n      |x>y =Just (xs,x:tr)\n      |otherwise=Nothing\n\nmoves::[Move]->GameState->[GameState]\nmoves mvs state=mapMaybe  (`move` state) mvs\n\nisClear::GameState->Bool\nisClear (GameState (Tray _ [] []) _)=True\nisClear (GameState (Tray [] [] _) _)=True\nisClear _ =False\n\n\nnoReturn::GameState->[Move]\nnoReturn (GameState _ hi)=noReturn' hi\n  where\n    noReturn'::[Move]->[Move]\n    noReturn' (x:_) =filter (/= x) [AB,BA,BC,CB]\n    noReturn' []=[AB,BA,BC,CB]\n\ndata Straight=No|ToA Int|ToC Int\nisStraight::GameState->Int->Straight\nisStraight (GameState tr _) x=isStraight' tr x\n  where\n    isStraight'::Tray->Int->Straight\n    isStraight' (Tray ta [] tc) n=\n      let [lenA,lenC]=map length [ta,tc] in\n      case () of\n        _ |head tc==n && last tc== n-lenC && head ta==n-1-lenC && last ta== 1 ->ToA lenC\n          |head ta==n && last ta== n-lenA && head tc==n-1-lenA && last tc== 1 ->ToC lenA\n    isStraight' _ _=No\n\nisStraight1::Straight->Bool\nisStraight1 No=False\nisStraight1 _=True"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad (replicateM)\n\ntype Glass = Int\ntype MaxGlass = Int\ntype Trays = ([Glass],[Glass],[Glass])\ntype Goal = Int\n\nmain = do\n    [maxGlass,limit] <- getLine >>= return . map read . words\n    if maxGlass == 0 && limit == 0 then return () else do\n        [t1,t2,t3] <- replicateM 3 (getLine >>= return . map read . tail . words)\n        print $ solve maxGlass limit (t1,t2,t3)\n        main\n\nsolve :: MaxGlass -> Int -> Trays -> Int\nsolve maxGlass limit ts = count `seq` if count <= limit then count else -1\n    where\n    count = min (stack maxGlass ts 1) (stack maxGlass ts 3)\n\nstack :: MaxGlass -> Trays -> Goal ->  Int\nstack maxGlass ts@(t1,t2,t3) goal = stack' goal 1\n    where\n    stack' goal glass\n        | glass > maxGlass = 0\n        | goal == 1 && glass `elem` t1 || goal == 3 && glass `elem` t3\n            = stack' goal (glass+1)\n        | goal == 1 && glass `elem` t2 || goal == 3 && glass `elem` t2\n            = 1 + (stack' (otherside goal) (glass+1)) + (move (glass+1))\n        | goal == 1 && glass `elem` t3 || goal == 3 && glass `elem` t1\n            = 2 + (stack' goal (glass+1)) + 2 * (move (glass+1))\n\n    otherside 1 = 3\n    otherside 3 = 1\n\n    move glass\n        | maxGlass <  glass = 0\n        | otherwise         = 2 + 3 * move (glass+1)"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns#-}\nmodule Main where\n\nimport System.IO.Unsafe\nimport Data.List\nimport Data.Maybe\nimport Control.Monad\nimport Data.Functor\n\nmain :: IO ()\nmain = do\n  (cups,mvs) <- getNM\n  unless (cups==0 && mvs==0) $\n    do\n      initState <- getState\n      print $ solve mvs initState cups\n      main\n  where\n    getNM::IO (Int,Int)\n    getNM=do\n       (n:m:_)<-map read . words <$> getLine\n       return (n,m)\n    getTray::IO [Int]\n    getTray=do\n      (n:try) <- map read . words <$> getLine\n      return $ reverse $ take n try\n    getState::IO GameState\n    getState=do\n      [ta,tb,tc] <-replicateM 3 getTray\n      return $ GameState (Tray ta tb tc) Nothing\n\ndata Move=AB|BA|BC|CB deriving(Eq,Show)\n\ndata Tray=Tray {trayA::[Int]\n              , trayB::[Int]\n              , trayC::[Int]\n               }deriving(Eq,Show)\n\ndata GameState=GameState {tray::Tray\n                        , history::Maybe Move}deriving(Show)\ninstance Eq GameState where\n  (GameState tr1 _)==(GameState tr2 _)=tr1==tr2\n\nsolveS1::Straight->Int\nsolveS1 (ToA x) =solveS x\nsolveS1 (ToC x)=solveS x\nsolveS::Int->Int\nsolveS 0=0\nsolveS !n=2 + (3 * solveS (n-1))\n\nsolve::Int->GameState->Int->Int\nsolve mvs state len=fromMaybe ( -1) $ solve' maxBound mvs [state] mvs len\n  where\n    solve'::Int->Int->[GameState]->Int->Int->Maybe Int\n    solve' !record !m !states !n !l=\n      case () of\n        _ |null states -> Just record\n          |record <= m-n ->Just record\n          |0>n ->Nothing\n          |otherwise ->      let (str,noStr)=split (isStraight1 . (`isStraight` l)) states\n                                 anss=map ((+(m-n)) . solveS1 . (`isStraight` l)) str\n                                 upds=concatMap (\\s->moves (noReturn s) s) noStr\n                             in solve' (minimum (record:anss)) m (nub upds) (n-1) l\n\n\n\nmove::Move->GameState->Maybe GameState\nmove mv (GameState tray hist)=do\n  tray' <- move'' mv tray\n  return $ GameState tray' (Just mv)\n  where\n    move''::Move->Tray->Maybe Tray\n    move'' AB (Tray ta tb tc)=do\n      (ta',tb') <- move' (ta,tb)\n      return $ Tray ta' tb' tc\n    move'' BA (Tray ta tb tc)=do\n      (tb',ta') <- move' (tb,ta)\n      return $ Tray ta' tb' tc\n    move'' BC (Tray ta tb tc)=do\n      (tb',tc') <- move' (tb,tc)\n      return $ Tray ta tb' tc'\n    move'' CB (Tray ta tb tc)=do\n      (tc',tb') <- move' (tc,tb)\n      return $ Tray ta tb' tc'\n    move'::([Int],[Int])->Maybe([Int],[Int])\n    move' ([],_)=Nothing\n    move' (x:xs,[])=Just (xs,[x])\n    move' (x:xs,tr@(y:ys))\n      |x>y =Just (xs,x:tr)\n      |otherwise=Nothing\n\nmoves::[Move]->GameState->[GameState]\nmoves mvs state=mapMaybe  (`move` state) mvs\n\nisClear::GameState->Bool\nisClear (GameState (Tray _ [] []) _)=True\nisClear (GameState (Tray [] [] _) _)=True\nisClear _ =False\n\n\nnoReturn::GameState->[Move]\nnoReturn (GameState _ hi)=noReturn' hi\n  where\n    noReturn'::Maybe Move->[Move]\n    noReturn' (Just x)=filter (/= x) [AB,BA,BC,CB]\n    noReturn' Nothing=[AB,BA,BC,CB]\n\ndata Straight=No|ToA Int|ToC Int\nisStraight::GameState->Int->Straight\nisStraight (GameState tr _) x=isStraight' tr x\n  where\n    isStraight'::Tray->Int->Straight\n    isStraight' (Tray [] [] tc) n=ToC 0\n    isStraight' (Tray ta [] []) n=ToA 0\n    isStraight' (Tray ta [] tc) n=\n      let [lenA,lenC]=map length [ta,tc] in\n      case () of\n        _ |head tc==n && head ta== n-lenC  ->ToA lenC\n          |head ta==n && head tc== n-lenA  ->ToC lenA\n          |otherwise->No\n    isStraight' _ _=No\n\nisStraight1::Straight->Bool\nisStraight1 No=False\nisStraight1 _=True\n\nsplit::(a->Bool)->[a]->([a],[a])\nsplit f list=foldr (\\x (ts,fs)->if f x then (x:ts,fs) else (ts,x:fs)) ([],[]) list"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns#-}\nmodule Main where\n\nimport Data.List\nimport Data.Maybe\nimport Control.Monad\nimport Data.Functor\n\nmain :: IO ()\nmain = do\n  (cups,mvs) <- getNM\n  unless (cups==0 && mvs==0) $\n    do\n      initState <- getState\n      print $ solve mvs initState\n      main\n  where\n    getNM::IO (Int,Int)\n    getNM=do\n       (n:m:_)<-map read . words <$> getLine\n       return (n,m)\n    getTray::IO [Int]\n    getTray=do\n      (n:try) <- map read . words <$> getLine\n      return $ reverse $ take n try\n    getState::IO GameState\n    getState=do\n      [ta,tb,tc] <-replicateM 3 getTray\n      return $ GameState (Tray ta tb tc) []\n\ndata Move=AB|BA|BC|CB deriving(Eq,Show)\n\ndata Tray=Tray {trayA::[Int]\n              , trayB::[Int]\n              , trayC::[Int]\n               }deriving(Show)\n\ndata GameState=GameState {tray::Tray\n                        , history::[Move]}deriving(Show)\n\nsolveS1::Straight->Int\nsolveS1 (ToA x) =solveS x\nsolveS1 (ToC x)=solveS x\nsolveS::Int->Int\nsolveS 0=0\nsolveS n=2 + (3 * solveS (n-1))\n\nsolve::Int->GameState->Int\nsolve mvs state=fromMaybe ( -1) $ solve' [maxBound] mvs [state] mvs\n  where\n    solve'::[Int]->Int->[GameState]->Int->Maybe Int\n    solve' as m states !n=\n      let min_=minimum as in\n      case () of\n        _ |min_ <= m-n ->Just min_\n          |0>n ->Nothing\n          |otherwise ->      let (str,noStr)=span (isStraight1 . isStraight) states\n                                 anss=map ((+(m-n)) . solveS1 . isStraight) str\n                                 upds=concatMap (\\s->moves (noReturn s) s) noStr\n                             in solve' (anss ++ as) m upds (n-1)\n\n\n\nmove::Move->GameState->Maybe GameState\nmove mv (GameState tray hist)=do\n  tray' <- move'' mv tray\n  return $ GameState tray' (mv:hist)\n  where\n    move''::Move->Tray->Maybe Tray\n    move'' AB (Tray ta tb tc)=do\n      (ta',tb') <- move' (ta,tb)\n      return $ Tray ta' tb' tc\n    move'' BA (Tray ta tb tc)=do\n      (tb',ta') <- move' (tb,ta)\n      return $ Tray ta' tb' tc\n    move'' BC (Tray ta tb tc)=do\n      (tb',tc') <- move' (tb,tc)\n      return $ Tray ta tb' tc'\n    move'' CB (Tray ta tb tc)=do\n      (tc',tb') <- move' (tc,tb)\n      return $ Tray ta tb' tc'\n    move'::([Int],[Int])->Maybe([Int],[Int])\n    move' ([],_)=Nothing\n    move' (x:xs,[])=Just (xs,[x])\n    move' (x:xs,tr@(y:ys))\n      |x>y =Just (xs,x:tr)\n      |otherwise=Nothing\n\nmoves::[Move]->GameState->[GameState]\nmoves mvs state=mapMaybe  (`move` state) mvs\n\nisClear::GameState->Bool\nisClear (GameState (Tray _ [] []) _)=True\nisClear (GameState (Tray [] [] _) _)=True\nisClear _ =False\n\n\nnoReturn::GameState->[Move]\nnoReturn (GameState _ hi)=noReturn' hi\n  where\n    noReturn'::[Move]->[Move]\n    noReturn' (x:_) =filter (/= x) [AB,BA,BC,CB]\n    noReturn' []=[AB,BA,BC,CB]\n\ndata Straight=No|ToA Int|ToC Int\nisStraight::GameState->Straight\nisStraight (GameState tr _)=isStraight' tr\n  where\n    isStraight'::Tray->Straight\n    isStraight' (Tray ta [] tc)\n      |(ta==reverse (take (length ta) [1..])) && (tc==reverse (take (length tc) [(length ta + 1)..])) =ToA $ length tc\n      |(tc==reverse (take (length tc) [1..])) && (ta==reverse (take (length ta) [(length tc + 1)..])) =ToC $ length ta\n    isStraight' _=No\n\nisStraight1::Straight->Bool\nisStraight1 No=False\nisStraight1 _=True"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns#-}\nmodule Main where\n\nimport System.IO.Unsafe\nimport Data.List\nimport Data.Maybe\nimport Control.Monad\nimport Data.Functor\n\nmain :: IO ()\nmain = do\n  (cups,mvs) <- getNM\n  unless (cups==0 && mvs==0) $\n    do\n      initState <- getState\n      print $ toAns $ solve2 [initState] mvs mvs\n      main\n  where\n    getNM::IO (Int,Int)\n    getNM=do\n       (n:m:_)<-map read . words <$> getLine\n       return (n,m)\n    getTray::IO [Int]\n    getTray=do\n      (n:try) <- map read . words <$> getLine\n      return $ reverse $ take n try\n    getState::IO GameState\n    getState=do\n      [ta,tb,tc] <-replicateM 3 getTray\n      return $ GameState (Tray ta tb tc) Nothing\n\ndata Move=AB|BA|BC|CB deriving(Eq,Show)\n\ndata Tray=Tray {trayA::[Int]\n              , trayB::[Int]\n              , trayC::[Int]\n               }deriving(Eq,Show)\n\ndata GameState=GameState {tray::Tray\n                        , history::Maybe Move}deriving(Show)\ninstance Eq GameState where\n  (GameState tr1 _)==(GameState tr2 _)=tr1==tr2\n\nsolveS1::Straight->Int\nsolveS1 (ToA x) =solveS x\nsolveS1 (ToC x)=solveS x\nsolveS::Int->Int\nsolveS 0=0\nsolveS !n=2 + (3 * solveS (n-1))\n\nmove2::GameState->Move->GameState\nmove2 (GameState (Tray ta tb tc) hi) mv=\n  case mv of\n    AB->(GameState (Tray (tail ta) (head ta:tb) tc) (Just AB))\n    BA->(GameState (Tray  (head tb:ta) (tail tb) tc) (Just BA))\n    BC->(GameState (Tray  ta (tail tb) (head tb:tc)) (Just BC))\n    CB->(GameState (Tray  ta (head tc:tb) (tail tc)) (Just CB))\n\ntoAns::Maybe Int ->Int\ntoAns x=fromMaybe (-1) x\n\nsolve2::[GameState]->Int->Int->Maybe Int\nsolve2 _ _ (-1) =Nothing\nsolve2 states lim !n=\n  case () of\n    _ |any isClear states->Just (lim-n)\n      |otherwise-> solve2 (concatMap (\\s->map (move2 s) (canMove s)) states) lim (n-1)\n\ncanMove::GameState->[Move]\ncanMove (GameState tr Nothing)=canMove' tr\ncanMove (GameState tr (Just mv))=delete (rev mv) (canMove' tr)\n\nrev::Move->Move\nrev AB=BA\nrev BA=AB\nrev BC=CB\nrev CB=BC\n\ncanMove'::Tray->[Move]\ncanMove' (Tray ta tb tc)=\n      case (ta,tb,tc) of\n        ([],[],_)->[CB]\n        (_,[],[])->[AB]\n        ([],_,[])->[BA,BC]\n        ((a:as),(b:bs),[])->(if a>b then AB else BA):BC:[]\n        (_,[],_)->[AB,CB]\n        ([],(b:bs),(c:cs))->(if b>c then BC else CB):BA:[]\n        ((a:as),(b:bs),(c:cs))->(if a>b then AB else BA):(if b>c then BC else CB):[]\n\n{-\nsolve::Int->GameState->Int->Int\nsolve mvs state len=fromMaybe ( -1) $ solve' maxBound mvs [state] mvs len\n  where\n    solve'::Int->Int->[GameState]->Int->Int->Maybe Int\n    solve' record m states !n l =let !q=unsafePerformIO $ print (record,n,(length states))in\n      case () of\n        _ |null states -> Just record\n          |record <= m-n ->Just record\n          |0>n ->Nothing\n          |otherwise ->      let upds=concatMap (\\s->moves (noReturn s) s) states\n                                 sorted=nub . sortOn lenInclease1 $ upds\n                                 std=lenInclease1 $ head sorted\n                                 sieved= takeWhile ((==std) . lenInclease1) sorted\n                                 (str,noStr)=split (isStraight1 . (`isStraight` l)) sieved\n                                 anss=map ((+(m-n+1)) . solveS1 . (`isStraight` l)) str\n                             in solve' (minimum (record:anss)) m sieved (n-1) l\n\n-}\ncanClear::GameState->Int->Int->Bool\ncanClear (GameState (Tray ta tb tc) _) n lim=(lim+1)*3 >= (solveS $ n - (max (lenInclease ta) (lenInclease tc)))\n\nlenInclease1::GameState->Int\nlenInclease1 (GameState (Tray ta _ tc) _)=max (lenInclease ta) (lenInclease tc)\n\nlenInclease::[Int]->Int\nlenInclease list=length . takeWhile id $ zipWith ($) (map (==) [1..]) (reverse list)\n\nmove::Move->GameState->Maybe GameState\nmove mv (GameState tray hist)=do\n  tray' <- move'' mv tray\n  return $ GameState tray' (Just mv)\n  where\n    move''::Move->Tray->Maybe Tray\n    move'' AB (Tray ta tb tc)=do\n      (ta',tb') <- move' (ta,tb)\n      return $ Tray ta' tb' tc\n    move'' BA (Tray ta tb tc)=do\n      (tb',ta') <- move' (tb,ta)\n      return $ Tray ta' tb' tc\n    move'' BC (Tray ta tb tc)=do\n      (tb',tc') <- move' (tb,tc)\n      return $ Tray ta tb' tc'\n    move'' CB (Tray ta tb tc)=do\n      (tc',tb') <- move' (tc,tb)\n      return $ Tray ta tb' tc'\n    move'::([Int],[Int])->Maybe([Int],[Int])\n    move' ([],_)=Nothing\n    move' (x:xs,[])=Just (xs,[x])\n    move' (x:xs,tr@(y:ys))\n      |x>y =Just (xs,x:tr)\n      |otherwise=Nothing\n\nmoves::[Move]->GameState->[GameState]\nmoves mvs state=mapMaybe  (`move` state) mvs\n\nisClear::GameState->Bool\nisClear (GameState (Tray _ [] []) _)=True\nisClear (GameState (Tray [] [] _) _)=True\nisClear _ =False\n\n\nnoReturn::GameState->[Move]\nnoReturn (GameState _ hi)=noReturn' hi\n  where\n    noReturn'::Maybe Move->[Move]\n    noReturn' (Just x)=filter (/= x) [AB,BA,BC,CB]\n    noReturn' Nothing=[AB,BA,BC,CB]\n\ndata Straight=No|ToA Int|ToC Int\nisStraight::GameState->Int->Straight\nisStraight (GameState tr _) x=isStraight' tr x\n  where\n    isStraight'::Tray->Int->Straight\n    isStraight' (Tray [] [] tc) n=ToC 0\n    isStraight' (Tray ta [] []) n=ToA 0\n    isStraight' (Tray ta [] tc) n=\n      let [lenA,lenC]=map length [ta,tc] in\n      case () of\n        _ |head tc==n && head ta== n-lenC  ->ToA lenC\n          |head ta==n && head tc== n-lenA  ->ToC lenA\n          |otherwise->No\n    isStraight' _ _=No\n\nisStraight1::Straight->Bool\nisStraight1 No=False\nisStraight1 _=True\n\nsplit::(a->Bool)->[a]->([a],[a])\nsplit f list=foldr (\\x (ts,fs)->if f x then (x:ts,fs) else (ts,x:fs)) ([],[]) list\n\ndel::Eq a=>[a]->[a]->[a]\ndel delList target=delList ++ filter (not . (`elem` delList)) target"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns#-}\nmodule Main where\n\nimport Data.List\nimport Data.Maybe\nimport Control.Monad\nimport Data.Functor\n\nmain :: IO ()\nmain = do\n  (cups,mvs) <- getNM\n  unless (cups==0 && mvs==0) $\n    do\n      initState <- getState\n      print $ solve mvs initState\n      main\n  where\n    getNM::IO (Int,Int)\n    getNM=do\n       (n:m:_)<-map read . words <$> getLine\n       return (n,m)\n    getTray::IO [Int]\n    getTray=do\n      (n:try) <- map read . words <$> getLine\n      return $ reverse $ take n try\n    getState::IO GameState\n    getState=do\n      [ta,tb,tc] <-replicateM 3 getTray\n      return $ GameState (Tray ta tb tc) []\n\ndata Move=AB|BA|BC|CB deriving(Eq,Show)\n\ndata Tray=Tray {trayA::[Int]\n              , trayB::[Int]\n              , trayC::[Int]\n               }deriving(Eq,Show)\n\ndata GameState=GameState {tray::Tray\n                        , history::[Move]}deriving(Show)\ninstance Eq GameState where\n  (GameState tr1 _)==(GameState tr2 _)=tr1==tr2\n\nsolveS1::Straight->Int\nsolveS1 (ToA x) =solveS x\nsolveS1 (ToC x)=solveS x\nsolveS::Int->Int\nsolveS 0=0\nsolveS !n=2 + (3 * solveS (n-1))\n\nsolve::Int->GameState->Int\nsolve mvs state=fromMaybe ( -1) $ solve' [maxBound] mvs [state] mvs\n  where\n    solve'::[Int]->Int->[GameState]->Int->Maybe Int\n    solve' !as !m !states !n=\n      let min_=minimum as in\n      case () of\n        _ |null states -> Just min_\n          |min_ <= m-n ->Just min_\n          |0>n ->Nothing\n          |otherwise ->      let (str,noStr)=span (isStraight1 . isStraight) states\n                                 anss=map ((+(m-n)) . solveS1 . isStraight) str\n                                 upds=concatMap (\\s->moves (noReturn s) s) noStr\n                             in solve' (anss ++ as) m (nub upds) (n-1)\n\n\n\nmove::Move->GameState->Maybe GameState\nmove mv (GameState tray hist)=do\n  tray' <- move'' mv tray\n  return $ GameState tray' (mv:hist)\n  where\n    move''::Move->Tray->Maybe Tray\n    move'' AB (Tray ta tb tc)=do\n      (ta',tb') <- move' (ta,tb)\n      return $ Tray ta' tb' tc\n    move'' BA (Tray ta tb tc)=do\n      (tb',ta') <- move' (tb,ta)\n      return $ Tray ta' tb' tc\n    move'' BC (Tray ta tb tc)=do\n      (tb',tc') <- move' (tb,tc)\n      return $ Tray ta tb' tc'\n    move'' CB (Tray ta tb tc)=do\n      (tc',tb') <- move' (tc,tb)\n      return $ Tray ta tb' tc'\n    move'::([Int],[Int])->Maybe([Int],[Int])\n    move' ([],_)=Nothing\n    move' (x:xs,[])=Just (xs,[x])\n    move' (x:xs,tr@(y:ys))\n      |x>y =Just (xs,x:tr)\n      |otherwise=Nothing\n\nmoves::[Move]->GameState->[GameState]\nmoves mvs state=mapMaybe  (`move` state) mvs\n\nisClear::GameState->Bool\nisClear (GameState (Tray _ [] []) _)=True\nisClear (GameState (Tray [] [] _) _)=True\nisClear _ =False\n\n\nnoReturn::GameState->[Move]\nnoReturn (GameState _ hi)=noReturn' hi\n  where\n    noReturn'::[Move]->[Move]\n    noReturn' (x:_) =filter (/= x) [AB,BA,BC,CB]\n    noReturn' []=[AB,BA,BC,CB]\n\ndata Straight=No|ToA Int|ToC Int\nisStraight::GameState->Straight\nisStraight (GameState tr _)=isStraight' tr\n  where\n    isStraight'::Tray->Straight\n    isStraight' (Tray ta [] tc)\n      |(ta==reverse (take (length ta) [1..])) && (tc==reverse (take (length tc) [(length ta + 1)..])) =ToA $ length tc\n      |(tc==reverse (take (length tc) [1..])) && (ta==reverse (take (length ta) [(length tc + 1)..])) =ToC $ length ta\n    isStraight' _=No\n\nisStraight1::Straight->Bool\nisStraight1 No=False\nisStraight1 _=True"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns#-}\nmodule Main where\n\nimport System.IO.Unsafe\nimport Data.List\nimport Data.Maybe\nimport Control.Monad\nimport Data.Functor\n\nmain :: IO ()\nmain = do\n  (cups,mvs) <- getNM\n  unless (cups==0 && mvs==0) $\n    do\n      initState <- getState\n      print $ solve mvs initState cups\n      main\n  where\n    getNM::IO (Int,Int)\n    getNM=do\n       (n:m:_)<-map read . words <$> getLine\n       return (n,m)\n    getTray::IO [Int]\n    getTray=do\n      (n:try) <- map read . words <$> getLine\n      return $ reverse $ take n try\n    getState::IO GameState\n    getState=do\n      [ta,tb,tc] <-replicateM 3 getTray\n      return $ GameState (Tray ta tb tc) Nothing\n\ndata Move=AB|BA|BC|CB deriving(Eq,Show)\n\ndata Tray=Tray {trayA::[Int]\n              , trayB::[Int]\n              , trayC::[Int]\n               }deriving(Eq,Show)\n\ndata GameState=GameState {tray::Tray\n                        , history::Maybe Move}deriving(Eq,Show)\n--instance Eq GameState where\n  --(GameState tr1 _)==(GameState tr2 _)=tr1==tr2\n\nsolveS1::Straight->Int\nsolveS1 (ToA x) =solveS x\nsolveS1 (ToC x)=solveS x\nsolveS::Int->Int\nsolveS 0=0\nsolveS !n=2 + (3 * solveS (n-1))\n\nsolve::Int->GameState->Int->Int\nsolve mvs state len=fromMaybe ( -1) $ solve' maxBound mvs [state] mvs len\n  where\n    solve'::Int->Int->[GameState]->Int->Int->Maybe Int\n    solve' record m states !n l =\n      case () of\n        _ |null states -> Just record\n          |record <= m-n ->Just record\n          |0>n ->Nothing\n          |otherwise ->      let (str,noStr)=split (isStraight1 . (`isStraight` l)) states\n                                 anss=map ((+(m-n)) . solveS1 . (`isStraight` l)) str\n                                 upds=concatMap (\\s->moves (noReturn s) s) noStr\n                             in solve' (minimum (record:anss)) m (del states $ nub upds) (n-1) l\n\n\n\nmove::Move->GameState->Maybe GameState\nmove mv (GameState tray hist)=do\n  tray' <- move'' mv tray\n  return $ GameState tray' (Just mv)\n  where\n    move''::Move->Tray->Maybe Tray\n    move'' AB (Tray ta tb tc)=do\n      (ta',tb') <- move' (ta,tb)\n      return $ Tray ta' tb' tc\n    move'' BA (Tray ta tb tc)=do\n      (tb',ta') <- move' (tb,ta)\n      return $ Tray ta' tb' tc\n    move'' BC (Tray ta tb tc)=do\n      (tb',tc') <- move' (tb,tc)\n      return $ Tray ta tb' tc'\n    move'' CB (Tray ta tb tc)=do\n      (tc',tb') <- move' (tc,tb)\n      return $ Tray ta tb' tc'\n    move'::([Int],[Int])->Maybe([Int],[Int])\n    move' ([],_)=Nothing\n    move' (x:xs,[])=Just (xs,[x])\n    move' (x:xs,tr@(y:ys))\n      |x>y =Just (xs,x:tr)\n      |otherwise=Nothing\n\nmoves::[Move]->GameState->[GameState]\nmoves mvs state=mapMaybe  (`move` state) mvs\n\nisClear::GameState->Bool\nisClear (GameState (Tray _ [] []) _)=True\nisClear (GameState (Tray [] [] _) _)=True\nisClear _ =False\n\n\nnoReturn::GameState->[Move]\nnoReturn (GameState _ hi)=noReturn' hi\n  where\n    noReturn'::Maybe Move->[Move]\n    noReturn' (Just x)=filter (/= x) [AB,BA,BC,CB]\n    noReturn' Nothing=[AB,BA,BC,CB]\n\ndata Straight=No|ToA Int|ToC Int\nisStraight::GameState->Int->Straight\nisStraight (GameState tr _) x=isStraight' tr x\n  where\n    isStraight'::Tray->Int->Straight\n    isStraight' (Tray [] [] tc) n=ToC 0\n    isStraight' (Tray ta [] []) n=ToA 0\n    isStraight' (Tray ta [] tc) n=\n      let [lenA,lenC]=map length [ta,tc] in\n      case () of\n        _ |head tc==n && head ta== n-lenC  ->ToA lenC\n          |head ta==n && head tc== n-lenA  ->ToC lenA\n          |otherwise->No\n    isStraight' _ _=No\n\nisStraight1::Straight->Bool\nisStraight1 No=False\nisStraight1 _=True\n\nsplit::(a->Bool)->[a]->([a],[a])\nsplit f list=foldr (\\x (ts,fs)->if f x then (x:ts,fs) else (ts,x:fs)) ([],[]) list\n\ndel::Eq a=>[a]->[a]->[a]\ndel delList target=delList ++ filter (not . (`elem` delList)) target"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns#-}\nmodule Main where\n\nimport Data.List\nimport Data.Maybe\nimport Control.Monad\nimport Data.Functor\n\nmain :: IO ()\nmain = do\n  (cups,mvs) <- getNM\n  unless (cups==0 && mvs==0) $\n    do\n      initState <- getState\n      print $ solve mvs initState cups\n      main\n  where\n    getNM::IO (Int,Int)\n    getNM=do\n       (n:m:_)<-map read . words <$> getLine\n       return (n,m)\n    getTray::IO [Int]\n    getTray=do\n      (n:try) <- map read . words <$> getLine\n      return $ reverse $ take n try\n    getState::IO GameState\n    getState=do\n      [ta,tb,tc] <-replicateM 3 getTray\n      return $ GameState (Tray ta tb tc) []\n\ndata Move=AB|BA|BC|CB deriving(Eq,Show)\n\ndata Tray=Tray {trayA::[Int]\n              , trayB::[Int]\n              , trayC::[Int]\n               }deriving(Eq,Show)\n\ndata GameState=GameState {tray::Tray\n                        , history::[Move]}deriving(Show)\ninstance Eq GameState where\n  (GameState tr1 _)==(GameState tr2 _)=tr1==tr2\n\nsolveS1::Straight->Int\nsolveS1 (ToA x) =solveS x\nsolveS1 (ToC x)=solveS x\nsolveS::Int->Int\nsolveS 0=0\nsolveS !n=2 + (3 * solveS (n-1))\n\nsolve::Int->GameState->Int->Int\nsolve mvs state len=fromMaybe ( -1) $ solve' [maxBound] mvs [state] mvs len\n  where\n    solve'::[Int]->Int->[GameState]->Int->Int->Maybe Int\n    solve' !as !m !states !n !len=\n      let min_=minimum as in\n      case () of\n        _ |null states -> Just min_\n          |min_ <= m-n ->Just min_\n          |0>n ->Nothing\n          |otherwise ->      let (str,noStr)=span (isStraight1 . (`isStraight` len)) states\n                                 anss=map ((+(m-n)) . solveS1 . (`isStraight` len)) str\n                                 upds=concatMap (\\s->moves (noReturn s) s) noStr\n                             in solve' (anss ++ as) m (nub upds) (n-1) len\n\n\n\nmove::Move->GameState->Maybe GameState\nmove mv (GameState tray hist)=do\n  tray' <- move'' mv tray\n  return $ GameState tray' (mv:hist)\n  where\n    move''::Move->Tray->Maybe Tray\n    move'' AB (Tray ta tb tc)=do\n      (ta',tb') <- move' (ta,tb)\n      return $ Tray ta' tb' tc\n    move'' BA (Tray ta tb tc)=do\n      (tb',ta') <- move' (tb,ta)\n      return $ Tray ta' tb' tc\n    move'' BC (Tray ta tb tc)=do\n      (tb',tc') <- move' (tb,tc)\n      return $ Tray ta tb' tc'\n    move'' CB (Tray ta tb tc)=do\n      (tc',tb') <- move' (tc,tb)\n      return $ Tray ta tb' tc'\n    move'::([Int],[Int])->Maybe([Int],[Int])\n    move' ([],_)=Nothing\n    move' (x:xs,[])=Just (xs,[x])\n    move' (x:xs,tr@(y:ys))\n      |x>y =Just (xs,x:tr)\n      |otherwise=Nothing\n\nmoves::[Move]->GameState->[GameState]\nmoves mvs state=mapMaybe  (`move` state) mvs\n\nisClear::GameState->Bool\nisClear (GameState (Tray _ [] []) _)=True\nisClear (GameState (Tray [] [] _) _)=True\nisClear _ =False\n\n\nnoReturn::GameState->[Move]\nnoReturn (GameState _ hi)=noReturn' hi\n  where\n    noReturn'::[Move]->[Move]\n    noReturn' (x:_) =filter (/= x) [AB,BA,BC,CB]\n    noReturn' []=[AB,BA,BC,CB]\n\ndata Straight=No|ToA Int|ToC Int\nisStraight::GameState->Int->Straight\nisStraight (GameState tr _) x=isStraight' tr x\n  where\n    isStraight'::Tray->Int->Straight\n    isStraight' (Tray [] [] tc) n=ToC 0\n    isStraight' (Tray ta [] []) n=ToA 0\n    isStraight' (Tray ta [] tc) n=\n      let [lenA,lenC]=map length [ta,tc] in\n      case () of\n        _ |head tc==n && last tc== n-lenC+1 && head ta==n-lenC && last ta== 1 ->ToA lenC\n          |head ta==n && last ta== n-lenA+1 && head tc==n-lenA && last tc== 1 ->ToC lenA\n          |otherwise->No\n    isStraight' _ _=No\n\nisStraight1::Straight->Bool\nisStraight1 No=False\nisStraight1 _=True"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\n\nh 0 = 0\nh n = 3 * h (n - 1) + 1\n\nfa :: [Int] -> [Int] -> [Int] -> Int -> Int\nfa [] [] [] 0 = 0\nfa (a:as) b c n\n  | a == n = fa as b c (n - 1)\nfa a (b:bs) c n\n  | b == n = fc a bs c (n - 1) + 1 + 2 * h (n - 1)\nfa a b (c:cs) n\n  | c == n = fa a b cs (n - 1) + 1 + h (n - 1) + h n\n\nfb :: [Int] -> [Int] -> [Int] -> Int -> Int\nfb [] [] [] 0 = 0\nfb (a:as) b c n\n  | a == n = fc as b c (n - 1) + 1 + h (n - 1)\nfb a (b:bs) c n\n  | b == n = fb a bs c (n - 1)\nfb a b (c:cs) n\n  | c == n = fa a b cs (n - 1) + 1 + h (n - 1)\n\nfc :: [Int] -> [Int] -> [Int] -> Int -> Int\nfc a b c n = fa c b a n\n\nf :: [Int] -> [Int] -> [Int] -> Int -> Int\nf a b c n = min stepA stepC\n  where stepA = fa a b c n\n        stepC = fc a b c n\n\ng :: [Int] -> [Int] -> [Int] -> Int -> Int\ng a0 b0 c0 n = f a b c n\n  where a = map (\\x -> n + 1 - x) a0\n        b = map (\\x -> n + 1 - x) b0\n        c = map (\\x -> n + 1 - x) c0\n\nmain = do\n  [n, m] <- map read . words <$> getLine :: IO [Int]\n  unless ([n, m] == [0, 0]) $ do\n    _:a <- map read . words <$> getLine :: IO [Int]\n    _:b <- map read . words <$> getLine :: IO [Int]\n    _:c <- map read . words <$> getLine :: IO [Int]\n    let step = g a b c n\n    let answer = if step <= m then step else -1\n    print answer\n    main\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns#-}\nmodule Main where\n\nimport Data.List\nimport Data.Maybe\nimport Control.Monad\nimport Data.Functor\n\nmain :: IO ()\nmain = do\n  (cups,mvs) <- getNM\n  unless (cups==0 && mvs==0) $\n    do\n      initState <- getState\n      print $ solve mvs initState\n      main\n  where\n    getNM::IO (Int,Int)\n    getNM=do\n       (n:m:_)<-map read . words <$> getLine\n       return (n,m)\n    getTray::IO [Int]\n    getTray=do\n      (n:try) <- map read . words <$> getLine\n      return $ reverse $ take n try\n    getState::IO GameState\n    getState=do\n      [ta,tb,tc] <-replicateM 3 getTray\n      return $ GameState (Tray ta tb tc) []\n\ndata Move=AB|BA|BC|CB deriving(Eq,Show)\n\ndata Tray=Tray {trayA::[Int]\n              , trayB::[Int]\n              , trayC::[Int]\n               }deriving(Eq,Show)\n\ndata GameState=GameState {tray::Tray\n                        , history::[Move]}deriving(Show)\ninstance Eq GameState where\n  (GameState tr1 _)==(GameState tr2 _)=tr1==tr2\n\nsolveS1::Straight->Int\nsolveS1 (ToA x) =solveS x\nsolveS1 (ToC x)=solveS x\nsolveS::Int->Int\nsolveS 0=0\nsolveS n=2 + (3 * solveS (n-1))\n\nsolve::Int->GameState->Int\nsolve mvs state=fromMaybe ( -1) $ solve' [maxBound] mvs [state] mvs\n  where\n    solve'::[Int]->Int->[GameState]->Int->Maybe Int\n    solve' as m states !n=\n      let min_=minimum as in\n      case () of\n        _ |null states -> Just min_\n          |min_ <= m-n ->Just min_\n          |0>n ->Nothing\n          |otherwise ->      let (str,noStr)=span (isStraight1 . isStraight) states\n                                 anss=map ((+(m-n)) . solveS1 . isStraight) str\n                                 upds=concatMap (\\s->moves (noReturn s) s) noStr\n                             in solve' (anss ++ as) m (nub upds) (n-1)\n\n\n\nmove::Move->GameState->Maybe GameState\nmove mv (GameState tray hist)=do\n  tray' <- move'' mv tray\n  return $ GameState tray' (mv:hist)\n  where\n    move''::Move->Tray->Maybe Tray\n    move'' AB (Tray ta tb tc)=do\n      (ta',tb') <- move' (ta,tb)\n      return $ Tray ta' tb' tc\n    move'' BA (Tray ta tb tc)=do\n      (tb',ta') <- move' (tb,ta)\n      return $ Tray ta' tb' tc\n    move'' BC (Tray ta tb tc)=do\n      (tb',tc') <- move' (tb,tc)\n      return $ Tray ta tb' tc'\n    move'' CB (Tray ta tb tc)=do\n      (tc',tb') <- move' (tc,tb)\n      return $ Tray ta tb' tc'\n    move'::([Int],[Int])->Maybe([Int],[Int])\n    move' ([],_)=Nothing\n    move' (x:xs,[])=Just (xs,[x])\n    move' (x:xs,tr@(y:ys))\n      |x>y =Just (xs,x:tr)\n      |otherwise=Nothing\n\nmoves::[Move]->GameState->[GameState]\nmoves mvs state=mapMaybe  (`move` state) mvs\n\nisClear::GameState->Bool\nisClear (GameState (Tray _ [] []) _)=True\nisClear (GameState (Tray [] [] _) _)=True\nisClear _ =False\n\n\nnoReturn::GameState->[Move]\nnoReturn (GameState _ hi)=noReturn' hi\n  where\n    noReturn'::[Move]->[Move]\n    noReturn' (x:_) =filter (/= x) [AB,BA,BC,CB]\n    noReturn' []=[AB,BA,BC,CB]\n\ndata Straight=No|ToA Int|ToC Int\nisStraight::GameState->Straight\nisStraight (GameState tr _)=isStraight' tr\n  where\n    isStraight'::Tray->Straight\n    isStraight' (Tray ta [] tc)\n      |(ta==reverse (take (length ta) [1..])) && (tc==reverse (take (length tc) [(length ta + 1)..])) =ToA $ length tc\n      |(tc==reverse (take (length tc) [1..])) && (ta==reverse (take (length ta) [(length tc + 1)..])) =ToC $ length ta\n    isStraight' _=No\n\nisStraight1::Straight->Bool\nisStraight1 No=False\nisStraight1 _=True"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns#-}\nmodule Main where\n\nimport System.IO.Unsafe\nimport Data.List\nimport Data.Maybe\nimport Control.Monad\nimport Data.Functor\n\nmain :: IO ()\nmain = do\n  (cups,mvs) <- getNM\n  unless (cups==0 && mvs==0) $\n    do\n      initState <- getState\n      print $ solve mvs initState cups\n      main\n  where\n    getNM::IO (Int,Int)\n    getNM=do\n       (n:m:_)<-map read . words <$> getLine\n       return (n,m)\n    getTray::IO [Int]\n    getTray=do\n      (n:try) <- map read . words <$> getLine\n      return $ reverse $ take n try\n    getState::IO GameState\n    getState=do\n      [ta,tb,tc] <-replicateM 3 getTray\n      return $ GameState (Tray ta tb tc) []\n\ndata Move=AB|BA|BC|CB deriving(Eq,Show)\n\ndata Tray=Tray {trayA::[Int]\n              , trayB::[Int]\n              , trayC::[Int]\n               }deriving(Eq,Show)\n\ndata GameState=GameState {tray::Tray\n                        , history::[Move]}deriving(Show)\ninstance Eq GameState where\n  (GameState tr1 _)==(GameState tr2 _)=tr1==tr2\n\nsolveS1::Straight->Int\nsolveS1 (ToA x) =solveS x\nsolveS1 (ToC x)=solveS x\nsolveS::Int->Int\nsolveS 0=0\nsolveS !n=2 + (3 * solveS (n-1))\n\nsolve::Int->GameState->Int->Int\nsolve mvs state len=fromMaybe ( -1) $ solve' maxBound mvs [state] mvs len\n  where\n    solve'::Int->Int->[GameState]->Int->Int->Maybe Int\n    solve' !record !m !states !n !l=\n      case () of\n        _ |null states -> Just record\n          |record <= m-n ->Just record\n          |0>n ->Nothing\n          |otherwise ->      let (str,noStr)=split (isStraight1 . (`isStraight` l)) states\n                                 anss=map ((+(m-n)) . solveS1 . (`isStraight` l)) str\n                                 upds=concatMap (\\s->moves (noReturn s) s) noStr\n                             in solve' (minimum (record:anss)) m (nub upds) (n-1) l\n\n\n\nmove::Move->GameState->Maybe GameState\nmove mv (GameState tray hist)=do\n  tray' <- move'' mv tray\n  return $ GameState tray' (mv:hist)\n  where\n    move''::Move->Tray->Maybe Tray\n    move'' AB (Tray ta tb tc)=do\n      (ta',tb') <- move' (ta,tb)\n      return $ Tray ta' tb' tc\n    move'' BA (Tray ta tb tc)=do\n      (tb',ta') <- move' (tb,ta)\n      return $ Tray ta' tb' tc\n    move'' BC (Tray ta tb tc)=do\n      (tb',tc') <- move' (tb,tc)\n      return $ Tray ta tb' tc'\n    move'' CB (Tray ta tb tc)=do\n      (tc',tb') <- move' (tc,tb)\n      return $ Tray ta tb' tc'\n    move'::([Int],[Int])->Maybe([Int],[Int])\n    move' ([],_)=Nothing\n    move' (x:xs,[])=Just (xs,[x])\n    move' (x:xs,tr@(y:ys))\n      |x>y =Just (xs,x:tr)\n      |otherwise=Nothing\n\nmoves::[Move]->GameState->[GameState]\nmoves mvs state=mapMaybe  (`move` state) mvs\n\nisClear::GameState->Bool\nisClear (GameState (Tray _ [] []) _)=True\nisClear (GameState (Tray [] [] _) _)=True\nisClear _ =False\n\n\nnoReturn::GameState->[Move]\nnoReturn (GameState _ hi)=noReturn' hi\n  where\n    noReturn'::[Move]->[Move]\n    noReturn' (x:_) =filter (/= x) [AB,BA,BC,CB]\n    noReturn' []=[AB,BA,BC,CB]\n\ndata Straight=No|ToA Int|ToC Int\nisStraight::GameState->Int->Straight\nisStraight (GameState tr _) x=isStraight' tr x\n  where\n    isStraight'::Tray->Int->Straight\n    isStraight' (Tray [] [] tc) n=ToC 0\n    isStraight' (Tray ta [] []) n=ToA 0\n    isStraight' (Tray ta [] tc) n=\n      let [lenA,lenC]=map length [ta,tc] in\n      case () of\n        _ |head tc==n && head ta== n-lenC  ->ToA lenC\n          |head ta==n && head tc== n-lenA  ->ToC lenA\n          |otherwise->No\n    isStraight' _ _=No\n\nisStraight1::Straight->Bool\nisStraight1 No=False\nisStraight1 _=True\n\nsplit::(a->Bool)->[a]->([a],[a])\nsplit f list=foldr (\\x (ts,fs)->if f x then (x:ts,fs) else (ts,x:fs)) ([],[]) list"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns#-}\nmodule Main where\n\nimport System.IO.Unsafe\nimport Data.List\nimport Data.Maybe\nimport Control.Monad\nimport Data.Functor\n\nmain :: IO ()\nmain = do\n  (cups,mvs) <- getNM\n  unless (cups==0 && mvs==0) $\n    do\n      initState <- getState\n      print $ toAns $ solve2 [initState] mvs mvs\n      main\n  where\n    getNM::IO (Int,Int)\n    getNM=do\n       (n:m:_)<-map read . words <$> getLine\n       return (n,m)\n    getTray::IO [Int]\n    getTray=do\n      (n:try) <- map read . words <$> getLine\n      return $ reverse $ take n try\n    getState::IO GameState\n    getState=do\n      [ta,tb,tc] <-replicateM 3 getTray\n      return $ GameState (Tray ta tb tc) Nothing\n\ndata Move=AB|BA|BC|CB deriving(Eq,Show)\n\ndata Tray=Tray {trayA::[Int]\n              , trayB::[Int]\n              , trayC::[Int]\n               }deriving(Eq,Show)\n\ndata GameState=GameState {tray::Tray\n                        , history::Maybe Move}deriving(Show)\ninstance Eq GameState where\n  (GameState tr1 _)==(GameState tr2 _)=tr1==tr2\n\nsolveS1::Straight->Int\nsolveS1 (ToA x) =solveS x\nsolveS1 (ToC x)=solveS x\nsolveS::Int->Int\nsolveS 0=0\nsolveS !n=2 + (3 * solveS (n-1))\n\nmove2::GameState->Move->GameState\nmove2 (GameState (Tray ta tb tc) hi) mv=\n  case mv of\n    AB->(GameState (Tray (tail ta) (head ta:tb) tc) (Just AB))\n    BA->(GameState (Tray  (head tb:ta) (tail tb) tc) (Just BA))\n    BC->(GameState (Tray  ta (tail tb) (head tb:tc)) (Just BC))\n    CB->(GameState (Tray  ta (head tc:tb) (tail tc)) (Just CB))\n\ntoAns::Maybe Int ->Int\ntoAns x=fromMaybe (-1) x\n\nsolve2::[GameState]->Int->Int->Maybe Int\nsolve2 _ _ (-1) =Nothing\nsolve2 states lim !n=\n  case () of\n    _ |any isClear states->Just (lim-n)\n      |otherwise-> solve2 (concatMap (\\s->map (move2 s) (canMove s)) states) lim (n-1)\n\ncanMove::GameState->[Move]\ncanMove (GameState tr Nothing)=canMove' tr\ncanMove (GameState tr (Just mv))=delete (rev mv) (canMove' tr)\n\nrev::Move->Move\nrev AB=BA\nrev BA=AB\nrev BC=CB\nrev CB=BC\n\ncanMove'::Tray->[Move]\ncanMove' (Tray ta tb tc)=\n      case (ta,tb,tc) of\n        ([],[],_)->[CB]\n        (_,[],[])->[AB]\n        ([],_,[])->[BA,BC]\n        ((a:as),(b:bs),[])->(if a>b then AB else BA):BC:[]\n        (_,[],_)->[AB,CB]\n        ([],(b:bs),(c:cs))->(if b>c then BC else CB):BA:[]\n        ((a:as),(b:bs),(c:cs))->(if a>b then AB else BA):(if b>c then BC else CB):[]\n\nsolve::Int->GameState->Int->Int\nsolve mvs state len=fromMaybe ( -1) $ solve' maxBound mvs [state] mvs len\n  where\n    solve'::Int->Int->[GameState]->Int->Int->Maybe Int\n    solve' record m states !n l =let !q=unsafePerformIO $ print (record,n,(length states))in\n      case () of\n        _ |null states -> Just record\n          |record <= m-n ->Just record\n          |0>n ->Nothing\n          |otherwise ->      let upds=concatMap (\\s->moves (noReturn s) s) states\n                                 sorted=nub . sortOn lenInclease1 $ upds\n                                 std=lenInclease1 $ head sorted\n                                 sieved= takeWhile ((==std) . lenInclease1) sorted\n                                 (str,noStr)=split (isStraight1 . (`isStraight` l)) sieved\n                                 anss=map ((+(m-n+1)) . solveS1 . (`isStraight` l)) str\n                             in solve' (minimum (record:anss)) m sieved (n-1) l\n\ncanClear::GameState->Int->Int->Bool\ncanClear (GameState (Tray ta tb tc) _) n lim=(lim+1)*3 >= (solveS $ n - (max (lenInclease ta) (lenInclease tc)))\n\nlenInclease1::GameState->Int\nlenInclease1 (GameState (Tray ta _ tc) _)=max (lenInclease ta) (lenInclease tc)\n\nlenInclease::[Int]->Int\nlenInclease list=length . takeWhile id $ zipWith ($) (map (==) [1..]) (reverse list)\n\nmove::Move->GameState->Maybe GameState\nmove mv (GameState tray hist)=do\n  tray' <- move'' mv tray\n  return $ GameState tray' (Just mv)\n  where\n    move''::Move->Tray->Maybe Tray\n    move'' AB (Tray ta tb tc)=do\n      (ta',tb') <- move' (ta,tb)\n      return $ Tray ta' tb' tc\n    move'' BA (Tray ta tb tc)=do\n      (tb',ta') <- move' (tb,ta)\n      return $ Tray ta' tb' tc\n    move'' BC (Tray ta tb tc)=do\n      (tb',tc') <- move' (tb,tc)\n      return $ Tray ta tb' tc'\n    move'' CB (Tray ta tb tc)=do\n      (tc',tb') <- move' (tc,tb)\n      return $ Tray ta tb' tc'\n    move'::([Int],[Int])->Maybe([Int],[Int])\n    move' ([],_)=Nothing\n    move' (x:xs,[])=Just (xs,[x])\n    move' (x:xs,tr@(y:ys))\n      |x>y =Just (xs,x:tr)\n      |otherwise=Nothing\n\nmoves::[Move]->GameState->[GameState]\nmoves mvs state=mapMaybe  (`move` state) mvs\n\nisClear::GameState->Bool\nisClear (GameState (Tray _ [] []) _)=True\nisClear (GameState (Tray [] [] _) _)=True\nisClear _ =False\n\n\nnoReturn::GameState->[Move]\nnoReturn (GameState _ hi)=noReturn' hi\n  where\n    noReturn'::Maybe Move->[Move]\n    noReturn' (Just x)=filter (/= x) [AB,BA,BC,CB]\n    noReturn' Nothing=[AB,BA,BC,CB]\n\ndata Straight=No|ToA Int|ToC Int\nisStraight::GameState->Int->Straight\nisStraight (GameState tr _) x=isStraight' tr x\n  where\n    isStraight'::Tray->Int->Straight\n    isStraight' (Tray [] [] tc) n=ToC 0\n    isStraight' (Tray ta [] []) n=ToA 0\n    isStraight' (Tray ta [] tc) n=\n      let [lenA,lenC]=map length [ta,tc] in\n      case () of\n        _ |head tc==n && head ta== n-lenC  ->ToA lenC\n          |head ta==n && head tc== n-lenA  ->ToC lenA\n          |otherwise->No\n    isStraight' _ _=No\n\nisStraight1::Straight->Bool\nisStraight1 No=False\nisStraight1 _=True\n\nsplit::(a->Bool)->[a]->([a],[a])\nsplit f list=foldr (\\x (ts,fs)->if f x then (x:ts,fs) else (ts,x:fs)) ([],[]) list\n\ndel::Eq a=>[a]->[a]->[a]\ndel delList target=delList ++ filter (not . (`elem` delList)) target"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>))\nimport Control.Monad (unless)\nimport Data.Set (Set)\nimport qualified Data.Set as S\n\nmain :: IO ()\nmain = do\n  [n, m] <- f\n  unless (n == 0 && m == 0) $ do\n    xs <- reverse <$> tail <$> f\n    ys <- reverse <$> tail <$> f\n    zs <- reverse <$> tail <$> f\n    print $ solve n m (xs, ys, zs)\n    main\n  where f = map read <$> words <$> getLine\n  \nsolve :: Int -> Int -> ([Int], [Int], [Int]) -> Int\nsolve n m cup = f (S.insert cup S.empty) (S.insert cup S.empty) 0\n  where f hs cs ct | ct > m = (-1)\n                   | S.member g1 cs || S.member g2 cs = ct\n                   | otherwise = let ns = S.foldl h S.empty cs in f (S.union hs ns) (S.difference ns hs) (ct+1)\n        h s ([], [], (z:zs)) = S.insert ([], [z], zs) s\n        h s ((x:xs), [], []) = S.insert (xs, [x], []) s\n        h s ([], (y:ys), []) = S.insert ([], ys, [y]) (S.insert ([y], ys, []) s)\n        h s ([], (y:ys), (z:zs)) = let s' = S.insert ([y],ys,(z:zs)) s\n                                   in S.insert (if y > z then ([], ys, (y:z:zs)) else ([], (z:y:ys), zs)) s'\n        h s ((x:xs), [], (z:zs)) = let s' = S.insert (xs, [x], (z:zs)) s\n                                   in S.insert ((x:xs), [z], zs) s'\n        h s ((x:xs), (y:ys), []) = let s' = S.insert ((x:xs), ys, [y]) s\n                                   in S.insert (if x > y then (xs, (x:y:ys), []) else ((y:x:xs), ys, [])) s'\n        h s ((x:xs), (y:ys), (z:zs)) = let s' = S.insert (if x > y then (xs, (x:y:ys), (z:zs)) else ((y:x:xs), ys, (z:zs))) s\n                                       in S.insert (if y > z then ((x:xs), ys, (y:z:zs)) else ((x:xs), (z:y:ys), zs)) s'\n        g1 = ([n,n-1 .. 1], [], [])\n        g2 = ([], [], [n,n-1 .. 1])\n\n"
  },
  {
    "language": "Haskell",
    "code": "module Main where\n\nimport Data.Maybe\nimport Control.Monad\nimport Data.Functor\n\nmain :: IO ()\nmain = do\n  (cups,mvs) <- getNM\n  unless (cups==0 && mvs==0) $\n    do\n      initState <- getState\n      print $ solve mvs initState\n      main\n  where\n    getNM::IO (Int,Int)\n    getNM=do\n       (n:m:_)<-map read . words <$> getLine\n       return (n,m)\n    getTray::IO [Int]\n    getTray=do\n      (n:try) <- map read . words <$> getLine\n      return $ reverse $ take n try\n    getState::IO GameState\n    getState=do\n      [ta,tb,tc] <-replicateM 3 getTray\n      return $ GameState (Tray ta tb tc) []\n\ndata Move=AB|BA|BC|CB deriving(Eq)\n\ndata Tray=Tray {trayA::[Int]\n              , trayB::[Int]\n              , trayC::[Int]\n               }\n\ndata GameState=GameState {tray::Tray\n                        , history::[Move]}\n\nsolve::Int->GameState->Int\nsolve mvs state=solve' mvs [state] mvs\n  where\n    solve'::Int->[GameState]->Int->Int\n    solve' _ states (-1) = -1\n    solve' m states n\n      |any isClear states =m-n\n      |otherwise =solve' m\n                  (concatMap (\\st@(GameState tr hi)->moves (noReturn hi) st) states )\n                  (n-1)\nmove::Move->GameState->Maybe GameState\nmove mv (GameState tray hist)=do\n  tray' <- move'' mv tray\n  return $ GameState tray' (mv:hist)\n  where\n    move''::Move->Tray->Maybe Tray\n    move'' AB (Tray ta tb tc)=do\n      (ta',tb') <- move' (ta,tb)\n      return $ Tray ta' tb' tc\n    move'' BA (Tray ta tb tc)=do\n      (tb',ta') <- move' (tb,ta)\n      return $ Tray ta' tb' tc\n    move'' BC (Tray ta tb tc)=do\n      (tb',tc') <- move' (tb,tc)\n      return $ Tray ta tb' tc'\n    move'' CB (Tray ta tb tc)=do\n      (tc',tb') <- move' (tc,tb)\n      return $ Tray ta tb' tc'\n    move'::([Int],[Int])->Maybe([Int],[Int])\n    move' ([],_)=Nothing\n    move' (x:xs,[])=Just (xs,[x])\n    move' (x:xs,tr@(y:ys))\n      |x>y =Just (xs,x:tr)\n      |otherwise=Nothing\n\nmoves::[Move]->GameState->[GameState]\nmoves mvs state=mapMaybe  (`move` state) mvs\n\nisClear::GameState->Bool\nisClear (GameState (Tray [] [] _) _)=True\nisClear (GameState (Tray _ [] []) _)=True\nisClear _ =False\n\nnoReturn::[Move]->[Move]\nnoReturn (x:_) =filter (/= x) [AB,BA,BC,CB]\nnoReturn []=[AB,BA,BC,CB]"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns#-}\nmodule Main where\n\nimport Data.List\nimport Data.Maybe\nimport Control.Monad\nimport Data.Functor\n\nmain :: IO ()\nmain = do\n  (cups,mvs) <- getNM\n  unless (cups==0 && mvs==0) $\n    do\n      initState <- getState\n      print $ solve mvs initState\n      main\n  where\n    getNM::IO (Int,Int)\n    getNM=do\n       (n:m:_)<-map read . words <$> getLine\n       return (n,m)\n    getTray::IO [Int]\n    getTray=do\n      (n:try) <- map read . words <$> getLine\n      return $ reverse $ take n try\n    getState::IO GameState\n    getState=do\n      [ta,tb,tc] <-replicateM 3 getTray\n      return $ GameState (Tray ta tb tc) []\n\ndata Move=AB|BA|BC|CB deriving(Eq,Show)\n\ndata Tray=Tray {trayA::[Int]\n              , trayB::[Int]\n              , trayC::[Int]\n               }deriving(Show)\n\ndata GameState=GameState {tray::Tray\n                        , history::[Move]}deriving(Show)\n\nsolveS1::Straight->Int\nsolveS1 (ToA x) =solveS x\nsolveS1 (ToC x)=solveS x\nsolveS::Int->Int\nsolveS 0=0\nsolveS n=2 + (3 * solveS (n-1))\n\nsolve::Int->GameState->Int\nsolve mvs state=fromMaybe ( -1) $ solve' [maxBound] mvs [state] mvs\n  where\n    solve'::[Int]->Int->[GameState]->Int->Maybe Int\n    solve' as m states !n=\n      let min_=minimum as in\n      case () of\n        _ |null states -> Just min_\n          |min_ <= m-n ->Just min_\n          |0>n ->Nothing\n          |otherwise ->      let (str,noStr)=span (isStraight1 . isStraight) states\n                                 anss=map ((+(m-n)) . solveS1 . isStraight) str\n                                 upds=concatMap (\\s->moves (noReturn s) s) noStr\n                             in solve' (anss ++ as) m upds (n-1)\n\n\n\nmove::Move->GameState->Maybe GameState\nmove mv (GameState tray hist)=do\n  tray' <- move'' mv tray\n  return $ GameState tray' (mv:hist)\n  where\n    move''::Move->Tray->Maybe Tray\n    move'' AB (Tray ta tb tc)=do\n      (ta',tb') <- move' (ta,tb)\n      return $ Tray ta' tb' tc\n    move'' BA (Tray ta tb tc)=do\n      (tb',ta') <- move' (tb,ta)\n      return $ Tray ta' tb' tc\n    move'' BC (Tray ta tb tc)=do\n      (tb',tc') <- move' (tb,tc)\n      return $ Tray ta tb' tc'\n    move'' CB (Tray ta tb tc)=do\n      (tc',tb') <- move' (tc,tb)\n      return $ Tray ta tb' tc'\n    move'::([Int],[Int])->Maybe([Int],[Int])\n    move' ([],_)=Nothing\n    move' (x:xs,[])=Just (xs,[x])\n    move' (x:xs,tr@(y:ys))\n      |x>y =Just (xs,x:tr)\n      |otherwise=Nothing\n\nmoves::[Move]->GameState->[GameState]\nmoves mvs state=mapMaybe  (`move` state) mvs\n\nisClear::GameState->Bool\nisClear (GameState (Tray _ [] []) _)=True\nisClear (GameState (Tray [] [] _) _)=True\nisClear _ =False\n\n\nnoReturn::GameState->[Move]\nnoReturn (GameState _ hi)=noReturn' hi\n  where\n    noReturn'::[Move]->[Move]\n    noReturn' (x:_) =filter (/= x) [AB,BA,BC,CB]\n    noReturn' []=[AB,BA,BC,CB]\n\ndata Straight=No|ToA Int|ToC Int\nisStraight::GameState->Straight\nisStraight (GameState tr _)=isStraight' tr\n  where\n    isStraight'::Tray->Straight\n    isStraight' (Tray ta [] tc)\n      |(ta==reverse (take (length ta) [1..])) && (tc==reverse (take (length tc) [(length ta + 1)..])) =ToA $ length tc\n      |(tc==reverse (take (length tc) [1..])) && (ta==reverse (take (length ta) [(length tc + 1)..])) =ToC $ length ta\n    isStraight' _=No\n\nisStraight1::Straight->Bool\nisStraight1 No=False\nisStraight1 _=True"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns#-}\nmodule Main where\n\n\nimport Data.Maybe\nimport Control.Monad\nimport Data.Functor\n\nmain :: IO ()\nmain = do\n  (cups,mvs) <- getNM\n  unless (cups==0 && mvs==0) $\n    do\n      initState <- getState\n      print $ solve mvs initState\n      main\n  where\n    getNM::IO (Int,Int)\n    getNM=do\n       (n:m:_)<-map read . words <$> getLine\n       return (n,m)\n    getTray::IO [Int]\n    getTray=do\n      (n:try) <- map read . words <$> getLine\n      return $ reverse $ take n try\n    getState::IO GameState\n    getState=do\n      [ta,tb,tc] <-replicateM 3 getTray\n      return $ GameState (Tray ta tb tc) []\n\ndata Move=AB|BA|BC|CB deriving(Eq)\n\ndata Tray=Tray {trayA::[Int]\n              , trayB::[Int]\n              , trayC::[Int]\n               }\n\ndata GameState=GameState {tray::Tray\n                        , history::[Move]}\n\nsolve::Int->GameState->Int\nsolve mvs state=solve' mvs [state] mvs\n  where\n    solve'::Int->[GameState]->Int->Int\n    solve' _ states (-1) = -1\n    solve' m states !n\n      |any (\\x->isClearA x || isClearC x) states =m-n\n      |otherwise =solve' m\n                  (concatMap (\\st@(GameState tr hi)->moves (noReturn hi) st) states )\n                  (n-1)\nmove::Move->GameState->Maybe GameState\nmove mv (GameState tray hist)=do\n  tray' <- move'' mv tray\n  return $ GameState tray' (mv:hist)\n  where\n    move''::Move->Tray->Maybe Tray\n    move'' AB (Tray ta tb tc)=do\n      (ta',tb') <- move' (ta,tb)\n      return $ Tray ta' tb' tc\n    move'' BA (Tray ta tb tc)=do\n      (tb',ta') <- move' (tb,ta)\n      return $ Tray ta' tb' tc\n    move'' BC (Tray ta tb tc)=do\n      (tb',tc') <- move' (tb,tc)\n      return $ Tray ta tb' tc'\n    move'' CB (Tray ta tb tc)=do\n      (tc',tb') <- move' (tc,tb)\n      return $ Tray ta tb' tc'\n    move'::([Int],[Int])->Maybe([Int],[Int])\n    move' ([],_)=Nothing\n    move' (x:xs,[])=Just (xs,[x])\n    move' (x:xs,tr@(y:ys))\n      |x>y =Just (xs,x:tr)\n      |otherwise=Nothing\n\nmoves::[Move]->GameState->[GameState]\nmoves mvs state=mapMaybe  (`move` state) mvs\n\nisClearA::GameState->Bool\nisClearA (GameState (Tray _ [] []) _)=True\nisClearA _ =False\n\nisClearC::GameState->Bool\nisClearC (GameState (Tray [] [] _) _)=True\nisClearC _=False\n\nnoReturn::[Move]->[Move]\nnoReturn (x:_) =filter (/= x) [AB,BA,BC,CB]\nnoReturn []=[AB,BA,BC,CB]"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0503\nTitle\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//Global data section\nint n,m;\nint nT[3];\nint TRAY[3][50];\nint POS[15];\n//int LAST1TABLE[3][3]={{0,1,2},{5,4,3},{6,7,8}};\n//\nint expt3(int x)\n{\n  if(x==0)\n    return(1);\n  else\n    return(3*expt3(x-1));\n}\nint conv3to10()\n{\n  int i,sum;\n\n  sum = 0;\n  for(i=1;i<=n;i++)\n    {\n      sum *= 3;\n      sum += POS[i];\n    }  \n  return(sum);\n}\nvoid calc1()\n{\n  int i,j;\n\n  for(i=1;i<=n-1;i++)\n    if(POS[i]==1)\n      {\n\t// printf(\"%d:\",i);\n      for(j=i+1;j<=n;j++)\n\t{\n\tPOS[j] = 2 - POS[j];\n\t}\n      }\n}\nvoid print()\n{\n  int i,j;\n\tprintf(\"\\n\");\n  for(i=0;i<3;i++)\n    {\n      printf(\"%d \",(nT[i]));\n      {\n\tfor(j=0;j<nT[i];j++)\n\t  {\n\t    printf(\"%d \",TRAY[i][j]);\n\t  }\n\tprintf(\"\\n\");\n      }\n    }\n}\nprint2()\n{\n  int i;\n  for(i=1;i<=n;i++)\n    printf(\"%d \",POS[i]);\n  printf(\"\\n\");\n}\nmain()\n{\n  int i,j,temp,ret,half,all;\n  while(EOF != scanf(\"%d %d\",&n,&m) && (n || m))\n    {\n      for(i=0;i<3;i++)\n\t{\n\t  scanf(\"%d \",&(nT[i]));\n\t  for(j=0;j<nT[i];j++)\n\t    {\n\t      scanf(\"%d \",&temp);\n\t      TRAY[i][j]=temp;\n\t      POS[temp]=i;\n\t      //printf(\"::%d \",POS[temp]);\n\t    }\n\t}\n    \n\n      //print2();\n      calc1();\n      //print2();\n      ret=conv3to10();\n\n      all=expt3(n)-1;half = all/2;\n      if(ret > half)\n\tret = all-ret;\n\n      if(ret <= m)\n\tprintf(\"%d\\n\",ret);\n      else\n\tprintf(\"%d\\n\",-1);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\n#define LEFT 0\n#define RIGHT 1\n#define QUEUE_SIZE 150000\n\ntypedef struct{\n\tint num;\n\tint cups[15];\n}HANOI;\n\ntypedef struct{\n\tHANOI current[4];\n\tHANOI privious[4];\n\tint count;\n}QUEUE;\n\nint n,m;\nint min = INT_MAX;\n\nHANOI Hanoi[4], Prev[4];\nHANOI Move_left[4], Move_right[4];\n\nint queue_top, queue_bottom;\nQUEUE queue[QUEUE_SIZE];\n\n\nvoid Initialize(void){\n\tint i,j;\n\n\tmin = INT_MAX;\n\tqueue_top=queue_bottom=0;\n\tfor(i=0;i<4;i++){\n\t\tHanoi[i].num=0;\n\t\tfor(j=0;j<15;j++) Hanoi[i].cups[j]=0;\n\t}\n\tfor(i=0;i<4;i++){\n\t\tPrev[i].num=0;\n\t\tfor(j=0;j<15;j++) Prev[i].cups[j]=0;\n\t}\n\n\treturn;\n}\n\nvoid MoveCup(int pos, int which){\n\tif(which==LEFT){\n\t\tMove_left[pos-1].num++;\n\t\tMove_left[pos-1].cups[Move_left[pos-1].num]=Move_left[pos].cups[Move_left[pos].num];\n\t\tMove_left[pos].cups[Move_left[pos].num]=0;\n\t\tMove_left[pos].num--;\n\t}else if(which==RIGHT){\n\t\tMove_right[pos+1].num++;\n\t\tMove_right[pos+1].cups[Move_right[pos+1].num]=Move_right[pos].cups[Move_right[pos].num];\n\t\tMove_right[pos].cups[Move_right[pos].num]=0;\n\t\tMove_right[pos].num--;\n\t}\n\treturn;\n}\n\n\nvoid SetQueue(HANOI *insert, int top, int bottom, int count){\n\tint i,j;\n\tfor(i=1;i<4;i++){\n\t\tqueue[bottom].privious[i].num = queue[top].current[i].num;\n\t\tfor(j=1;j<=queue[top].current[i].num;j++){\n\t\t\tqueue[bottom].privious[i].cups[j] = queue[top].current[i].cups[j];\n\t\t}\n\t}\n\tfor(i=1;i<4;i++){\n\t\tqueue[bottom].current[i].num = insert[i].num;\n\t\tfor(j=1;j<=insert[i].num;j++){\n\t\t\tqueue[bottom].current[i].cups[j] = insert[i].cups[j];\n\t\t}\n\t}\n\tqueue[bottom].count=count;\n\treturn ;\n}\n\nvoid HanoiMove(HANOI *hanoi, HANOI *prev, int count){\n\tint i,j,k;\n\tint count_left, count_right;\n\n\tfor(i=0;i<4;i++){\n\t\tMove_left[i].num=0;\n\t\tfor(j=0;j<15;j++) Move_left[i].cups[j]=0;\n\t}\n\tfor(i=0;i<4;i++){\n\t\tMove_right[i].num=0;\n\t\tfor(j=0;j<15;j++) Move_right[i].cups[j]=0;\n\t}\n\n\tfor(;;){\n\t\tfor(i=1;i<4;i++){\n\t\t\tMove_left[i].num = queue[queue_top].current[i].num;\n\t\t\tMove_right[i].num = queue[queue_top].current[i].num;\n\n\t\t\tfor(j=1;j<=queue[queue_top].current[i].num;j++){\n\t\t\t\tMove_left[i].cups[j] = queue[queue_top].current[i].cups[j];\n\t\t\t\tMove_right[i].cups[j] = queue[queue_top].current[i].cups[j];\n\t\t\t}\n\t\t}\n\n\t\tfor(i=1;i<4;i++){\n\t\t\tif(i==2) continue;\n\t\t\telse if(Move_left[i].num==n && queue[queue_top].count<min){\n\t\t\t\tmin = queue[queue_top].count;\n\t\t\t}\n\t\t}\n\t\tif(queue[queue_top].count>min){\n\t\t\tqueue_top++;\n\t\t\tif(queue_top==queue_bottom) break;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcount_left=count_right=queue[queue_top].count;\n\n\t\tfor(i=1;i<4;i++){\n\t\t\tif(queue[queue_top].current[i].num==0) continue;\n\t\t\tif(i>=2){\n\n\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\tMove_left[j].num = queue[queue_top].current[j].num;\n\t\t\t\t\tfor(k=1;k<=queue[queue_top].current[j].num;k++){\n\t\t\t\t\t\tMove_left[j].cups[k] = queue[queue_top].current[j].cups[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(Move_left[i].cups[Move_left[i].num]>Move_left[i-1].cups[Move_left[i-1].num]){\n\t\t\t\t\tMoveCup(i,LEFT);\n\t\t\t\t\tcount_left=queue[queue_top].count+1;\n\n\t\t\t\t\tif(count_left>m) continue;\n\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tif(Move_left[j].num!=queue[queue_top].privious[j].num){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j<4){\n\t\t\t\t\t\tqueue_bottom+=1;\n\t\t\t\t\t\tif(queue_bottom>=QUEUE_SIZE) queue_bottom=0;\n\t\t\t\t\t\tSetQueue(Move_left, queue_top, queue_bottom, count_left);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i<=2){\n\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\tMove_right[j].num = queue[queue_top].current[j].num;\n\t\t\t\t\tfor(k=1;k<=queue[queue_top].current[j].num;k++){\n\t\t\t\t\t\tMove_right[j].cups[k] = queue[queue_top].current[j].cups[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(Move_right[i].cups[Move_right[i].num]>Move_right[i+1].cups[Move_right[i+1].num]){\n\t\t\t\t\tMoveCup(i,RIGHT);\n\t\t\t\t\tcount_right=queue[queue_top].count+1;\n\t\t\t\t\tif(count_right>m) continue;\n\t\t\t\t\t\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tif(Move_right[j].num!=queue[queue_top].privious[j].num){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j<4){\n\t\t\t\t\t\tqueue_bottom+=1;\n\t\t\t\t\t\tif(queue_bottom>=QUEUE_SIZE) queue_bottom=0;\n\t\t\t\t\t\tSetQueue(Move_right, queue_top, queue_bottom, count_right);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue_top++;\n\t\tif(queue_top>=QUEUE_SIZE) queue_top=0;\n\t\tif(queue_top==queue_bottom) break;\n\n\t}\n\treturn;\n}\n\nint main(void){\n\tint i,j;\n\n\twhile(scanf(\"%d %d\",&n,&m)!=EOF){\n\t\tif(n==0 && m==0) break;\n\t\tInitialize();\n\t\tfor(i=1;i<4;i++){\n\t\t\tscanf(\"%d\",&Hanoi[i].num);\n\t\t\tfor(j=1;j<=Hanoi[i].num;j++){\n\t\t\t\tscanf(\"%d\",&Hanoi[i].cups[j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<4;i++){\n\t\t\tqueue[queue_top].current[i].num = Hanoi[i].num;\n\t\t\tqueue[queue_top].privious[i].num = Hanoi[i].num;\n\t\t\tfor(j=1;j<=Hanoi[i].num;j++){\n\t\t\t\tqueue[queue_top].current[i].cups[j] = Hanoi[i].cups[j];\n\t\t\t\tqueue[queue_top].privious[i].cups[j] = Hanoi[i].cups[j];\n\t\t\t}\n\t\t}\n\t\tHanoiMove(Hanoi,Prev,0);\n\t\tif(min>m) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",min);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NMAX 15\n#define MMAX 15000000\n\nint cup[3];\nint cup_move[4][2] = {{0,1},{1,0},{1,2},{2,1}};\nint stack[MMAX][3];\n\nint move(int temp[3],int a,int amin, int amax)\n{\n\tint i,l,m;\n\tbool flag;\n\n\tfor(m=0;m<4;m++){\n\t\tif(temp[cup_move[m][0]]>temp[cup_move[m][1]]){\n\t\t\tl= 1<<NMAX;\n\t\t\twhile((l & temp[cup_move[m][0]]) == 0) l>>=1;\n\t\t\ttemp[cup_move[m][0]] -= l;\n\t\t\ttemp[cup_move[m][1]] += l;\n\t\t\ta++;\n\t\t\tstack[a][0]=temp[0];\n\t\t\tstack[a][1]=temp[1];\n\t\t\tstack[a][2]=temp[2];\n\n\t\t\tif(a>amax){\n\t\t\t\treturn a--;\n\t\t\t}\n\t\t\tif(temp[1]==0 && (temp[0]==0 || temp[2]==0)){\n\t\t\t\tif(amin>a) amin=a;\n\t\t\t\treturn a--;\n\t\t\t}\n\n\t\t\tflag = false;\n\t\t\tfor(i=0;i<a;i++){\n\t\t\t\tif(stack[i][0]==temp[0] && stack[i][1]==temp[1] && stack[i][2]==temp[2]){\n\t\t\t\t\ta--;\n\t\t\t\t\ttemp[0]=stack[a][0];\n\t\t\t\t\ttemp[1]=stack[a][1];\n\t\t\t\t\ttemp[2]=stack[a][2];\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag) amin = move(temp,a,amin,amax);\n\t\t}\n\t}\n\treturn amin;\n}\n\nint main(void)\n{\n\tint n,m;\n\tint c_max,c;\n\tint i,j;\n\tint a;\n\tint temp[3];\n\n\twhile(scanf(\"%d%d\", &n, &m) && n+m){\n\t\tfor(i=0;i<3;i++){\n\t\t\tcup[i] = 0;\n\t\t\tscanf(\"%d\", &c_max);\n\t\t\tfor(j=0;j<c_max;j++){\n\t\t\t\tscanf(\"%d\", &c);\n\t\t\t\tcup[i] |= 1 << (c-1);\n\t\t\t}\n\t\t}\n\n\t\tif(cup[1]==0 && (cup[0]==0 || cup[2]==0)){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(i=0;i<3;i++){\n\t\t\ttemp[i]=cup[i];\n\t\t\tstack[0][i]=cup[i];\n\t\t}\n\t\ta = move(temp,0,m,m);\n\n\t\tif(a>m){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"%d\\n\",a);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int time;\n    int tower[3][15];\n    int t[3];\n} HANOI;\n\nHANOI queue[100000];\nint head, tail;\nint pow[30];\n\nvoid enq(HANOI t)\n{\n\tqueue[tail % 100000] = t;\n\ttail++;\n}\n\nvoid deq(HANOI *t)\n{\n\t*t = queue[head % 100000];\n\thead++;\n}\n\nchar v[44000000];\n\nint move(HANOI temp, int from, int to, int pw)\n{\n    int num;\n    int i, j;\n    HANOI first;\n    if ((temp.t[from] > 0 && temp.t[to] > 0 && temp.tower[from][temp.t[from] - 1] > temp.tower[to][temp.t[to] - 1]) ||temp.t[from] > 0 && temp.t[to] == 0){\n        first = temp;\n        first.tower[to][temp.t[to]] = first.tower[from][temp.t[from] - 1];\n        first.tower[from][temp.t[from] - 1] = 0;\n        first.t[from]--;\n        first.t[to]++;\n        first.time++;\n        num = 0;\n        for (i = 0; i < 3; i++){\n            for (j = 0; j < first.t[i]; j++){\n                num += i * pow[first.tower[i][j] - 1];\n            }\n        }\n        if (v[0] == 1 || v[pw] == 1){\n            printf(\"%d\\n\", first.time);\n            return (1);\n        }\n        if (!v[num]){\n            v[num] = 1;\n            enq(first);\n        }\n    }\n    return (0);\n}\n\nint main(void)\n{\n    int n, m;\n    HANOI start, temp;\n    int i, j;\n    int pw;\n    \n    pow[0] = 1;\n    for (i = 1; i < 20; i++){\n        pow[i] = pow[i - 1] * 3;\n    }\n    \n    while (1){\n        scanf(\"%d%d\", &n, &m);\n        \n        if (n + m == 0){\n            break;\n        }\n        memset(start.tower, 0, sizeof(start.tower));\n        for (i = 0; i < 3; i++){\n            scanf(\"%d\", &start.t[i]);\n            for (j = 0; j < start.t[i]; j++){\n                scanf(\"%d\", &start.tower[i][j]);\n            }\n        }\n        \n        memset(v, 0, sizeof(v));\n        \n        start.time = 0;\n        head = tail = 0;\n        pw = pow[n] - 1;\n        enq(start);\n        \n        while (head != tail){\n            deq(&temp);\n            \n            if (temp.time > m){\n                printf(\"-1\\n\");\n                break;\n            }\n            \n            if (move(temp, 0, 1, pw)){\n                break;\n            }\n            if (move(temp, 1, 0, pw)){\n                break;\n            }\n            if (move(temp, 1, 2, pw)){\n                break;\n            }\n            if (move(temp, 2, 1, pw)){\n                break;\n            }\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\n#define LEFT 0\n#define RIGHT 1\n#define QUEUE_SIZE 150000\n\ntypedef struct{\n\tchar num;\n\tchar cups[15];\n}HANOI;\n\ntypedef struct{\n\tHANOI current[4];\n\tHANOI privious[4];\n\tint count;\n}QUEUE;\n\nint n,m;\nint min = INT_MAX;\n\nHANOI Hanoi[4];\nHANOI Move_left[4], Move_right[4];\n\nint q_top, q_btm;\nQUEUE queue[QUEUE_SIZE];\n\n\nvoid Initialize(void){\n\tint i,j;\n\n\tmin = INT_MAX;\n\tq_top=q_btm=0;\n\tfor(i=0;i<4;i++){\n\t\tHanoi[i].num=0;\n\t\tfor(j=0;j<15;j++) Hanoi[i].cups[j]=0;\n\t}\n\n\treturn;\n}\n\nvoid MoveCup(int pos, int which){\n\tif(which==LEFT){\n\t\tMove_left[pos-1].num++;\n\t\tMove_left[pos-1].cups[Move_left[pos-1].num]=Move_left[pos].cups[Move_left[pos].num];\n\t\tMove_left[pos].cups[Move_left[pos].num]=0;\n\t\tMove_left[pos].num--;\n\t}else if(which==RIGHT){\n\t\tMove_right[pos+1].num++;\n\t\tMove_right[pos+1].cups[Move_right[pos+1].num]=Move_right[pos].cups[Move_right[pos].num];\n\t\tMove_right[pos].cups[Move_right[pos].num]=0;\n\t\tMove_right[pos].num--;\n\t}\n\treturn;\n}\n\n\nvoid SetQueue(HANOI *insert, int top, int bottom, int count){\n\tint i,j;\n\tfor(i=1;i<4;i++){\n\t\tqueue[bottom].privious[i].num = queue[top].current[i].num;\n\t\tfor(j=1;j<=queue[top].current[i].num;j++){\n\t\t\tqueue[bottom].privious[i].cups[j] = queue[top].current[i].cups[j];\n\t\t}\n\t}\n\tfor(i=1;i<4;i++){\n\t\tqueue[bottom].current[i].num = insert[i].num;\n\t\tfor(j=1;j<=insert[i].num;j++){\n\t\t\tqueue[bottom].current[i].cups[j] = insert[i].cups[j];\n\t\t}\n\t}\n\tqueue[bottom].count=count;\n\treturn ;\n}\n\nvoid HanoiMove(void){\n\tint i,j,k;\n\tint count_left, count_right;\n\n\tfor(i=0;i<4;i++){\n\t\tMove_left[i].num=0;\n\t\tfor(j=0;j<15;j++) Move_left[i].cups[j]=0;\n\t}\n\tfor(i=0;i<4;i++){\n\t\tMove_right[i].num=0;\n\t\tfor(j=0;j<15;j++) Move_right[i].cups[j]=0;\n\t}\n\n\tfor(;;){\n\t\tfor(i=1;i<4;i++){\n\t\t\tMove_left[i].num = queue[q_top].current[i].num;\n\t\t\tMove_right[i].num = queue[q_top].current[i].num;\n\n\t\t\tfor(j=1;j<=queue[q_top].current[i].num;j++){\n\t\t\t\tMove_left[i].cups[j] = queue[q_top].current[i].cups[j];\n\t\t\t\tMove_right[i].cups[j] = queue[q_top].current[i].cups[j];\n\t\t\t}\n\t\t}\n\n\t\tfor(i=1;i<4;i++){\n\t\t\tif(i==2) continue;\n\t\t\telse if(Move_left[i].num==n && queue[q_top].count<min){\n\t\t\t\tmin = queue[q_top].count;\n\t\t\t}\n\t\t}\n\t\tif(queue[q_top].count>min){\n\t\t\tq_top++;\n\t\t\tif(q_top==q_btm) break;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcount_left=count_right=queue[q_top].count;\n\n\t\tfor(i=1;i<4;i++){\n\t\t\tif(queue[q_top].current[i].num==0) continue;\n\t\t\tif(i>=2){\n\n\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\tMove_left[j].num = queue[q_top].current[j].num;\n\t\t\t\t\tfor(k=1;k<=queue[q_top].current[j].num;k++){\n\t\t\t\t\t\tMove_left[j].cups[k] = queue[q_top].current[j].cups[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(Move_left[i].cups[Move_left[i].num]>Move_left[i-1].cups[Move_left[i-1].num]){\n\t\t\t\t\tMoveCup(i,LEFT);\n\t\t\t\t\tcount_left=queue[q_top].count+1;\n\n\t\t\t\t\tif(count_left>m) continue;\n\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tif(Move_left[j].num!=queue[q_top].privious[j].num){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j<4){\n\t\t\t\t\t\tq_btm+=1;\n\t\t\t\t\t\tif(q_btm>=QUEUE_SIZE) q_btm=0;\n\t\t\t\t\t\tSetQueue(Move_left, q_top, q_btm, count_left);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i<=2){\n\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\tMove_right[j].num = queue[q_top].current[j].num;\n\t\t\t\t\tfor(k=1;k<=queue[q_top].current[j].num;k++){\n\t\t\t\t\t\tMove_right[j].cups[k] = queue[q_top].current[j].cups[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(Move_right[i].cups[Move_right[i].num]>Move_right[i+1].cups[Move_right[i+1].num]){\n\t\t\t\t\tMoveCup(i,RIGHT);\n\t\t\t\t\tcount_right=queue[q_top].count+1;\n\t\t\t\t\tif(count_right>m) continue;\n\t\t\t\t\t\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tif(Move_right[j].num!=queue[q_top].privious[j].num){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j<4){\n\t\t\t\t\t\tq_btm+=1;\n\t\t\t\t\t\tif(q_btm>=QUEUE_SIZE) q_btm=0;\n\t\t\t\t\t\tSetQueue(Move_right, q_top, q_btm, count_right);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq_top++;\n\t\tif(q_top>=QUEUE_SIZE) q_top=0;\n\t\tif(q_top==q_btm) break;\n\n\t}\n\treturn;\n}\n\nint main(void){\n\tint i,j;\n\n\twhile(scanf(\"%d %d\",&n,&m)!=EOF){\n\t\tif(n==0 && m==0) break;\n\t\tInitialize();\n\t\tfor(i=1;i<4;i++){\n\t\t\tscanf(\"%d\",&Hanoi[i].num);\n\t\t\tfor(j=1;j<=Hanoi[i].num;j++){\n\t\t\t\tscanf(\"%d\",&Hanoi[i].cups[j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<4;i++){\n\t\t\tqueue[q_top].current[i].num = Hanoi[i].num;\n\t\t\tqueue[q_top].privious[i].num = Hanoi[i].num;\n\t\t\tfor(j=1;j<=Hanoi[i].num;j++){\n\t\t\t\tqueue[q_top].current[i].cups[j] = Hanoi[i].cups[j];\n\t\t\t\tqueue[q_top].privious[i].cups[j] = Hanoi[i].cups[j];\n\t\t\t}\n\t\t}\n\t\tHanoiMove();\n\t\tif(min>m) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",min);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,t[16],c[16],p,d;\nmain(n){\n\tfor(*t=1;++i<16;)t[i]=n*=3;\n\tfor(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",j>m?-1:j)){\n\t\tfor(k=3;k--;)\n\t\t\tfor(scanf(\"%d\",&i);i--;c[j]=k)scanf(\"%d\",&j);\n\t\tfor(p=j=k=0;k++<n;)\n\t\t\tj+=t[n-k]*abs(i=p-c[k]),p=i%2*2+p&3;\n\t\tj=fmin(j,t[n]+~j);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "c[];s(x){scanf(\"%d\",x);}main(n,m,i,j,k,f){for(;s(&n)*s(&m)*n;printf(\"%d\\n\",j>m?i:j)){for(i=3;i--;)for(s(&j);j--;c[n-k]=i)s(&k);for(i=n;i--;k+=c[i])j-=pow(3,i)*abs(k*2%4-c[i]);j=fmin(~j,pow(3,n)+j);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void){\n\tint n,m;\n\tint i,j,k;\n\tint cups[3][16];\n\tint cup[3][16];\n\tint temp;\n\tint move[2];\n\tint moves[2];\n\tint min;\n\tint ccups[3];\n\tscanf(\"%d %d\",&n,&m);\n\twhile(n && m){\n\t\tfor(i=0;i<3;i++){\n\t\t\tscanf(\"%d\",&cups[i][0]);\n\t\t\tcup[i][0] = cups[i][0];\n\t\t\tfor(j=1;j<cups[i][0]+1;j++){\n\t\t\t\tscanf(\"%d\",&cups[i][j]);\n\t\t\t\tcup[i][j] = cups[i][j];\n\t\t\t}\n\t\t}\n\t\tif(cups[0][0] == n || cups[2][0] == n){\n\t\t\tprintf(\"0\\n\");\n\t\t}else{\n\t\t\tmove[0] = -1;\n\t\t\tmove[1] = -1;\n\t\t\tmoves[0] = -1;\n\t\t\tmoves[1] = -1;\n\t\t\tmin = -1;\n\t\t\tfor(i=1;i<m+1;i++){\n\t\t\t\tccups[0] = cups[0][cups[0][0]];\n\t\t\t\tccups[1] = cups[1][cups[1][0]];\n\t\t\t\tccups[2] = cups[2][cups[2][0]];\n\t\t\t\tif(ccups[0] > ccups[1] && (move[0] != 1 || move[1] != 0)){\n\t\t\t\t\tcups[1][cups[1][0]+1] = ccups[0];\n\t\t\t\t\tcups[0][0]--;\n\t\t\t\t\tcups[1][0]++;\n\t\t\t\t\tmove[0] = 0;\n\t\t\t\t\tmove[1] = 1;\n\t\t\t\t}else if(ccups[1] > ccups[2] && (move[0] != 2 || move[1] != 1)){\n\t\t\t\t\tcups[2][cups[2][0]+1] = ccups[1];\n\t\t\t\t\tcups[1][0]--;\n\t\t\t\t\tcups[2][0]++;\n\t\t\t\t\tmove[0] = 1;\n\t\t\t\t\tmove[1] = 2;\n\t\t\t\t}else if(ccups[2] > ccups[1] && (move[0] != 1 || move[1] != 2)){\n\t\t\t\t\tcups[1][cups[1][0]+1] = ccups[2];\n\t\t\t\t\tcups[2][0]--;\n\t\t\t\t\tcups[1][0]++;\n\t\t\t\t\tmove[0] = 2;\n\t\t\t\t\tmove[1] = 1;\n\t\t\t\t}else if(ccups[1] > ccups[0] && (move[0] != 0 || move[1] != 1)){\n\t\t\t\t\tcups[0][cups[0][0]+1] = ccups[1];\n\t\t\t\t\tcups[1][0]--;\n\t\t\t\t\tcups[0][0]++;\n\t\t\t\t\tmove[0] = 1;\n\t\t\t\t\tmove[1] = 0;\n\t\t\t\t}\n\t\t\t\tif(cups[0][0] == n || cups[2][0] == n){\n\t\t\t\t\tmin = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tccups[0] = cup[0][cup[0][0]];\n\t\t\t\tccups[1] = cup[1][cup[1][0]];\n\t\t\t\tccups[2] = cup[2][cup[2][0]];\n\t\t\t\tif(ccups[1] > ccups[0] && (moves[0] != 0 || moves[1] != 1)){\n\t\t\t\t\tcup[0][cup[0][0]+1] = ccups[1];\n\t\t\t\t\tcup[1][0]--;\n\t\t\t\t\tcup[0][0]++;\n\t\t\t\t\tmoves[0] = 1;\n\t\t\t\t\tmoves[1] = 0;\n\t\t\t\t}else if(ccups[2] > ccups[1] && (moves[0] != 1 || moves[1] != 2)){\n\t\t\t\t\tcup[1][cup[1][0]+1] = ccups[2];\n\t\t\t\t\tcup[2][0]--;\n\t\t\t\t\tcup[1][0]++;\n\t\t\t\t\tmoves[0] = 2;\n\t\t\t\t\tmoves[1] = 1;\n\t\t\t\t}else if(ccups[1] > ccups[2] && (moves[0] != 2 || moves[1] != 1)){\n\t\t\t\t\tcup[2][cup[2][0]+1] = ccups[1];\n\t\t\t\t\tcup[1][0]--;\n\t\t\t\t\tcup[2][0]++;\n\t\t\t\t\tmoves[0] = 1;\n\t\t\t\t\tmoves[1] = 2;\n\t\t\t\t}else if(ccups[0] > ccups[1] && (moves[0] != 1 || moves[1] != 0)){\n\t\t\t\t\tcup[1][cup[1][0]+1] = ccups[0];\n\t\t\t\t\tcup[0][0]--;\n\t\t\t\t\tcup[1][0]++;\n\t\t\t\t\tmoves[0] = 0;\n\t\t\t\t\tmoves[1] = 1;\n\t\t\t\t}\n\t\t\t\tif(cup[0][0] == n || cup[2][0] == n){\n\t\t\t\t\tmin = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",min);\n\t\t}\n\t\tscanf(\"%d %d\",&n,&m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,c[],p;main(n){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",j>m?k:j)){for(k=3;k--;)for(scanf(\"%d\",&i);i--;c[j]=k)scanf(\"%d\",&j);for(j=i=0;i++<n;p+=c[i]*2)j+=pow(3,n-i)*abs(p%4-c[i]);j=fmin(j,pow(3,n)+~j);}}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,c[],p;main(n){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",j>m?k:j)){for(k=3;k--;)for(scanf(\"%d\",&i);i--;c[j]=k)scanf(\"%d\",&j);for(j=i=0;i++<n;p=c[i]*2+p&3)j+=pow(3,n-i)*abs(p-c[i]);j=fmin(j,pow(3,n)+~j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NMAX 15\n#define MMAX 15000000\n\nconst int cup_move[4][2] = {{0,1},{1,0},{1,2},{2,1}};\nint stack[MMAX][3];\n\nint move(int temp[3],int a,int amin, int amax)\n{\n\tint i,l,m;\n\tint flag;\n\n\tfor(m=0;m<4;m++){\n\t\tif(temp[cup_move[m][0]]>temp[cup_move[m][1]]){\n\t\t\tl = 1<<NMAX;\n\t\t\twhile((l & temp[cup_move[m][0]]) == 0) l>>=1;\n\n\t\t\ttemp[cup_move[m][0]] -= l;\n\t\t\ttemp[cup_move[m][1]] += l;\n\n\t\t\tflag = 0;\n\t\t\tfor(i=a;i>=0;i--){\n\t\t\t\tif(stack[i][0]==temp[0] && stack[i][1]==temp[1] && stack[i][2]==temp[2]){\n\t\t\t\t\ttemp[cup_move[m][0]] += l;\n\t\t\t\t\ttemp[cup_move[m][1]] -= l;\n\t\t\t\t\tflag=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) continue;\n\n\t\t\ta++;\n\t\t\tstack[a][0]=temp[0];\n\t\t\tstack[a][1]=temp[1];\n\t\t\tstack[a][2]=temp[2];\n\n\t\t\tif(a>amax){\n\t\t\t\treturn a--;\n\t\t\t}\n\n\t\t\tif(temp[1]==0 && (temp[0]==0 || temp[2]==0)){\n\t\t\t\tif(amin>a) amin=a;\n\t\t\t\treturn a--;\n\t\t\t}\n\n\t\t\tamin = move(temp,a,amin,amax);\n\t\t}\n\t}\n\treturn amin;\n}\n\nint main(void)\n{\n\tint n,m;\n\tint c_max,c;\n\tint i,j;\n\tint a;\n\tint cup[3];\n\n\twhile(scanf(\"%d%d\", &n, &m) && n+m){\n\t\tfor(i=0;i<3;i++){\n\t\t\tcup[i] = 0;\n\t\t\tscanf(\"%d\", &c_max);\n\t\t\tfor(j=0;j<c_max;j++){\n\t\t\t\tscanf(\"%d\", &c);\n\t\t\t\tcup[i] |= 1 << (c-1);\n\t\t\t}\n\t\t}\n\n\t\tif(cup[1]==0 && (cup[0]==0 || cup[2]==0)){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(i=0;i<3;i++){\n\t\t\tstack[0][i]=cup[i];\n\t\t}\n\t\ta = move(cup,0,m,m);\n\n\t\tif(a>m){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"%d\\n\",a);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "c[];s(x){scanf(\"%d\",x);}main(n,m,i,j,k,f){for(;s(&n),s(&m)*n;printf(\"%d\\n\",j>m?i:j)){for(i=3;i--;)for(s(&j);j--;c[n-k]=i)s(&k);for(i=n;i--;k+=c[i])j-=pow(3,i)*abs(k*2%4-c[i]);j=fmin(~j,pow(3,n)+j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int time;\n    int tower[3][15];\n    int t[3];\n} HANOI;\n\nHANOI queue[100000];\nint head, tail;\nint pow[30];\n\nvoid enq(HANOI t)\n{\n\tqueue[tail % 100000] = t;\n\ttail++;\n}\n\nvoid deq(HANOI *t)\n{\n\t*t = queue[head % 100000];\n\thead++;\n}\n\nchar v[50000000];\n\nint move(HANOI temp, int from, int to, int pw)\n{\n    int num;\n    int i, j;\n    HANOI first;\n    if ((temp.t[from] > 0 && temp.t[to] > 0 && temp.tower[from][temp.t[from] - 1] > temp.tower[to][temp.t[to] - 1]) ||temp.t[from] > 0 && temp.t[to] == 0){\n        first = temp;\n        first.tower[to][temp.t[to]] = first.tower[from][temp.t[from] - 1];\n        first.tower[from][temp.t[from] - 1] = 0;\n        first.t[from]--;\n        first.t[to]++;\n        first.time++;\n        num = 0;\n        for (i = 0; i < 3; i++){\n            for (j = 0; j < first.t[i]; j++){\n                num += i * pow[first.tower[i][j] - 1];\n            }\n        }\n        if (v[0] == 1 || v[pw] == 1){\n            printf(\"%d\\n\", first.time);\n            return (1);\n        }\n        if (!v[num]){\n            v[num] = 1;\n            enq(first);\n        }\n    }\n    return (0);\n}\n\nint main(void)\n{\n    int n, m;\n    HANOI start, temp;\n    int i, j;\n    int pw;\n    \n    pow[0] = 1;\n    for (i = 1; i < 20; i++){\n        pow[i] = pow[i - 1] * 3;\n    }\n    \n    while (1){\n        scanf(\"%d%d\", &n, &m);\n        \n        if (n + m == 0){\n            break;\n        }\n        memset(start.tower, 0, sizeof(start.tower));\n        for (i = 0; i < 3; i++){\n            scanf(\"%d\", &start.t[i]);\n            for (j = 0; j < start.t[i]; j++){\n                scanf(\"%d\", &start.tower[i][j]);\n            }\n        }\n        \n        memset(v, 0, sizeof(v));\n        \n        start.time = 0;\n        head = tail = 0;\n        pw = pow[n] - 1;\n        enq(start);\n        \n        while (head != tail){\n            deq(&temp);\n            \n            if (temp.time > m){\n                printf(\"-1\\n\");\n                break;\n            }\n            \n            if (move(temp, 0, 1, pw)){\n                break;\n            }\n            if (move(temp, 1, 0, pw)){\n                break;\n            }\n            if (move(temp, 1, 2, pw)){\n                break;\n            }\n            if (move(temp, 2, 1, pw)){\n                break;\n            }\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,c[],p;main(n){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",j>m?k:j)){for(k=3;k--;)for(scanf(\"%d\",&i);i--;c[j]=k)scanf(\"%d\",&j);for(j=i=0;i++<n;p+=c[i]*2)j+=pow(3,n-i)*(p-c[i]&3);j=fmin(j,pow(3,n)+~j);}}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,c[],p,d;main(n){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",j>m?k:j)){for(k=3;k--;)for(scanf(\"%d\",&i);i--;c[j]=k)scanf(\"%d\",&j);for(j=i=0;i++<n;p=c[i]*2+p&3)j+=pow(3,n-i)*abs(p-c[i]);j=fmin(j,pow(3,n)+~j);}}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0503\nTitle\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//Global data section\nint n,m;\nint nT[3];\nint TRAY[3][50];\nint POS[15];\nint LAST1TABLE[3][3]={{0,1,2},{5,4,3},{6,7,8}};\n//\nint expt3(int x)\n{\n  if(x==0)\n    return(1);\n  else\n    return(3*expt3(x-1));\n}\n\nint calc1()\n{\n  int i,ret;\n  ret=LAST1TABLE[POS[n-1]][POS[n]];\n  // printf(\"1:%d %d %d\\n\",ret,POS[n-1],POS[n]);\n  for(i=n-2;i>0;i--)\n    ret+=expt3(n-i)*POS[i];\n  return(ret);\n}\nvoid print()\n{\n  int i,j;\n\tprintf(\"\\n\");\n  for(i=0;i<3;i++)\n    {\n      printf(\"%d \",(nT[i]));\n      {\n\tfor(j=0;j<nT[i];j++)\n\t  {\n\t    printf(\"%d \",TRAY[i][j]);\n\t  }\n\tprintf(\"\\n\");\n      }\n    }\n}\nprint2()\n{\n  int i;\n  for(i=1;i<=n;i++)\n    printf(\"%d \",POS[i]);\n  printf(\"\\n\");\n}\nmain()\n{\n  int i,j,temp,ret,half,all;\n  while(EOF != scanf(\"%d %d\",&n,&m) && (n || m))\n    {\n      for(i=0;i<3;i++)\n\t{\n\t  scanf(\"%d \",&(nT[i]));\n\t  for(j=0;j<nT[i];j++)\n\t    {\n\t      scanf(\"%d \",&temp);\n\t      TRAY[i][j]=temp;\n\t      POS[temp]=i;\n\t      //printf(\"::%d \",POS[temp]);\n\t    }\n\t}\n    \n      //print();print2();\n      ret=calc1();\n      all=expt3(n)-1;half = all/2;\n      if(ret > half)\n\tret = all-ret;\n\n      if(ret <= m)\n\tprintf(\"%d\\n\",ret);\n      else\n\tprintf(\"%d\\n\",-1);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\nint main(void){\n\tint pow3[16], c[16];\n\tint n, m, i, j, k, d, cnt, p;\n\n\tpow3[0] = 1;\n\tfor(i = 1; i <= 15; ++i){\n\t\tpow3[i] = pow3[i-1] * 3;\n\t}\n\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\tfor(i = 0; i < 3; ++i){\n\t\t\tfor(scanf(\"%d\", &j); j > 0; --j){\n\t\t\t\tscanf(\"%d\", &k);\n\t\t\t\tc[n-k] = i;\n\t\t\t}\n\t\t}\n\n\t\tp = 0;\n\t\tcnt = 0;\n\t\tfor(i = n - 1; i >= 0; --i){\n\t\t\td = abs(p - c[i]);\n\t\t\tcnt += pow3[i] * d;\n\t\t\tif(d == 1){\n\t\t\t\tp = 2 - p;\n\t\t\t}\n\t\t}\n\n\t\tk = pow3[n] - 1 - j;\n\t\tif(cnt > k){\n\t\t\tcnt = k;\n\t\t}\n\t\tprintf(\"%d\\n\", cnt > m ? -1 : cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n\tint n,m,i,j,ans,x[20];\n\tint \ta[20],\t//a[i]cå«¢û©çiÔÚÜÅðAÉ^Ôñ\n\t\tc[20],\t//c[i]cå«¢û©çiÔÚÜÅðAÉ^Ôñ\n\t\tp[20],\t//p[i]cêÔ[ÉæÁ½nÂð½ÎÌêÔ[É^Ô½ßÌñ\n\t\td[3][20],\t//úóÔÛ¶p\n\t\tb[5];\t\t//eñÉ¢­Â é©\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tmemset(d,0,sizeof(d));ans=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tscanf(\"%d\",&b[i]);\n\t\t\tfor(j=0;j<b[i];j++){\n\t\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\t\tx[d[i][j]]=i;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//êÔ[ÉæÁ½nÂð½ÎÌêÔ[É^Ô½ßÌñ\n\t\tp[1]=2;\n\t\tfor(i=2;i<=15;i++)p[i]=p[i-1]*3+2;\n\t\t\n\t\tif(x[n]==0)\t\ta[1]=0,c[1]=2;\n\t\telse if(x[n]==1)\ta[1]=1,c[1]=1;\n\t\telse \t\t\ta[1]=2,c[1]=0;\n\t\tfor(i=1;i<n;i++){\n\t\t\t//å«¢û©çi+1ÔÚÌàÌÌêÅêª¯µDP\n\t\t\tif(x[n-i]==0){\n\t\t\t\ta[i+1]=a[i];\n\t\t\t\tc[i+1]=c[i]+1+p[i]+1+p[i];\n\t\t\t}else if(x[n-i]==1){\n\t\t\t\ta[i+1]=c[i]+1+p[i];\n\t\t\t\tc[i+1]=a[i]+1+p[i];\n\t\t\t}else{\n\t\t\t\ta[i+1]=a[i]+1+p[i]+1+p[i];\n\t\t\t\tc[i+1]=c[i];\n\t\t\t}\n\t\t}\n\t\t//for(i=1;i<=n;i++)printf(\"%d %d\\n\",a[i],c[i]);\n\t\tans=(a[n]>c[n])?c[n]:a[n];\n\t\tif(ans>m)ans=-1;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint cup[15],n;\n\nlong beki(int a,int b){\n\tint i;\n\tlong ans=1;\n\tfor(i=0;i<b;i++){\n\t\tans*=a;\n\t}\n\treturn ans;\n}\n\nlong mini(int min,int c){\n\tif(min==(n-1)){\n\t\tswitch(cup[min]-c){\n\t\t\tcase 0:\n\t\t\treturn 0;\n\t\t\tcase 1:\n\t\t\tcase -1:\n\t\t\treturn 1;\n\t\t\tcase 2:\n\t\t\tcase -2:\n\t\t\treturn 2;\n\t\t}\n\t}else{\n\t\tswitch(cup[min]){\n\t\t\tcase 0:\n\t\t\tif(c==0){\n\t\t\t\treturn mini(min+1,0);\n\t\t\t}else if(c==1){\n\t\t\t\treturn mini(min+1,2)+1+beki(3,n-min);\n\t\t\t}else{\n\t\t\t\treturn mini(min+1,2)+2+2*beki(3,n-min);\n\t\t\t}\n\t\t\tcase 1:\n\t\t\tif(c==0){\n\t\t\t\treturn mini(min+1,2)+1+beki(3,n-min);\n\t\t\t}else if(c==1){\n\t\t\t\treturn mini(min+1,1);\n\t\t\t}else{\n\t\t\t\treturn mini(min+1,0)+1+beki(3,n-min);\n\t\t\t}\n\t\t\tcase 2:\n\t\t\tif(c==0){\n\t\t\t\treturn mini(min+1,2)+2+2*beki(3,n-min);\n\t\t\t}else if(c==1){\n\t\t\t\treturn mini(min+1,0)+1+beki(3,n-min);\n\t\t\t}else{\n\t\t\t\treturn mini(min+1,2);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint i,j,c,cc;\n\tlong m,amin,bmin;\n\tscanf(\"%d %lld\",&n,&m);\n\twhile(n!=0){\n\tfor(i=0;i<3;i++){\n\t\tscanf(\"%d\",&c);\n\t\tfor(j=0;j<c;j++){\n\t\t\tscanf(\"%d\",&cc);\n\t\t\tcup[cc-1]=i;\n\t\t}\n\t}\n\tamin=mini(cup[0],0);\n\tbmin=mini(cup[0],2);\n\tif(amin>=bmin){\n\t\tif(m<bmin) printf(\"-1\\n\");\n\t\telse printf(\"%ld\\n\",bmin);\n\t}else{\n\t\tif(m<amin) printf(\"-1\\n\");\n\t\telse printf(\"%ld\\n\",amin);\n\t}\n\tscanf(\"%d %ld\",&n,&m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint cup[15],n;\n\nlong beki(int a,int b){\n\tint i;\n\tlong ans=1;\n\tfor(i=0;i<b;i++){\n\t\tans*=a;\n\t}\n\treturn ans;\n}\n\nlong mini(int min,int c){\n\tif(min==(n-1)){\n\t\tswitch(cup[min]-c){\n\t\t\tcase 0:\n\t\t\treturn 0;\n\t\t\tcase 1:\n\t\t\tcase -1:\n\t\t\treturn 1;\n\t\t\tcase 2:\n\t\t\tcase -2:\n\t\t\treturn 2;\n\t\t}\n\t}else{\n\t\tswitch(cup[min]){\n\t\t\tcase 0:\n\t\t\tif(c==0){\n\t\t\t\treturn mini(min+1,0);\n\t\t\t}else if(c==1){\n\t\t\t\treturn mini(min+1,2)+1+(beki(3,n-min-1)-1)/2;\n\t\t\t}else{\n\t\t\t\treturn mini(min+1,2)+(2*beki(3,n-min-1));\n\t\t\t}\n\t\t\tcase 1:\n\t\t\tif(c==0){\n\t\t\t\treturn mini(min+1,2)+beki(3,n-min-1);\n\t\t\t}else if(c==1){\n\t\t\t\treturn mini(min+1,1);\n\t\t\t}else{\n\t\t\t\treturn mini(min+1,0)+beki(3,n-min-1);\n\t\t\t}\n\t\t\tcase 2:\n\t\t\tif(c==0){\n\t\t\t\treturn mini(min+1,0)+(2*beki(3,n-min-1));\n\t\t\t}else if(c==1){\n\t\t\t\treturn mini(min+1,0)+1+((beki(3,n-min-1)-1)/2);\n\t\t\t}else{\n\t\t\t\treturn mini(min+1,2);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint i,j,c,cc;\n\tlong m,amin,bmin;\n\tscanf(\"%d %lld\",&n,&m);\n\twhile(n!=0){\n\tfor(i=0;i<3;i++){\n\t\tscanf(\"%d\",&c);\n\t\tfor(j=0;j<c;j++){\n\t\t\tscanf(\"%d\",&cc);\n\t\t\tcup[cc-1]=i;\n\t\t}\n\t}\n\tamin=mini(0,0);\n\tbmin=mini(0,2);\n\tif(amin>=bmin){\n\t\tif(m<bmin) printf(\"-1\\n\");\n\t\telse printf(\"%ld\\n\",bmin);\n\t}else{\n\t\tif(m<amin) printf(\"-1\\n\");\n\t\telse printf(\"%ld\\n\",amin);\n\t}\n\tscanf(\"%d %ld\",&n,&m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "c[];main(n,m,i,j,k){for(;scanf(\"%d%d\",&n,&m)*n;printf(\"%d\\n\",j>m?i:j)){for(i=3;j=i--;)for(scanf(\"%d\",&j);j--;c[n-k]=i)scanf(\"%d\",&k);for(i=n;i--;k+=c[i])j+=pow(3,i)*abs(k*2%4-c[i]);j=fmin(j,pow(3,n)+~j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NMAX 15\n#define MMAX 15000000\n\nconst int cup_move[4][2] = {{0,1},{1,0},{1,2},{2,1}};\nint stack[MMAX][3];\n\nint move(int temp[3],int a,int amin, int amax)\n{\n\tint i,l,m;\n\tint flag;\n\n\tfor(m=0;m<4;m++){\n\t\tif(temp[cup_move[m][0]]>temp[cup_move[m][1]]){\n\t\t\tl= 1<<NMAX;\n\t\t\twhile((l & temp[cup_move[m][0]]) == 0) l>>=1;\n\t\t\ttemp[cup_move[m][0]] -= l;\n\t\t\ttemp[cup_move[m][1]] += l;\n\t\t\ta++;\n\t\t\tstack[a][0]=temp[0];\n\t\t\tstack[a][1]=temp[1];\n\t\t\tstack[a][2]=temp[2];\n\n\t\t\tif(a>amax){\n\t\t\t\treturn a--;\n\t\t\t}\n\t\t\tif(temp[1]==0 && (temp[0]==0 || temp[2]==0)){\n\t\t\t\tif(amin>a) amin=a;\n\t\t\t\treturn a--;\n\t\t\t}\n\n\t\t\tflag = 0;\n\t\t\tfor(i=0;i<a;i++){\n\t\t\t\tif(stack[i][0]==temp[0] && stack[i][1]==temp[1] && stack[i][2]==temp[2]){\n\t\t\t\t\ta--;\n\t\t\t\t\ttemp[0]=stack[a][0];\n\t\t\t\t\ttemp[1]=stack[a][1];\n\t\t\t\t\ttemp[2]=stack[a][2];\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag) amin = move(temp,a,amin,amax);\n\t\t}\n\t}\n\treturn amin;\n}\n\nint main(void)\n{\n\tint n,m;\n\tint c_max,c;\n\tint i,j;\n\tint a;\n\tint cup[3];\n\n\twhile(scanf(\"%d%d\", &n, &m) && n+m){\n\t\tfor(i=0;i<3;i++){\n\t\t\tcup[i] = 0;\n\t\t\tscanf(\"%d\", &c_max);\n\t\t\tfor(j=0;j<c_max;j++){\n\t\t\t\tscanf(\"%d\", &c);\n\t\t\t\tcup[i] |= 1 << (c-1);\n\t\t\t}\n\t\t}\n\n\t\tif(cup[1]==0 && (cup[0]==0 || cup[2]==0)){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(i=0;i<3;i++){\n\t\t\tstack[0][i]=cup[i];\n\t\t}\n\t\ta = move(cup,0,m,m);\n\n\t\tif(a>m){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"%d\\n\",a);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ  0503: Cup\n// 2017.10.29 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint c[16];\n\nint main()\n{\n\tint n, m, i, j, k, ans;\n\tint p3[16];\n\n\tfor (p3[0] = 1, i = 1; i < 16; i++) p3[i] = 3*p3[i-1];\n\twhile (scanf(\"%d%d\", &n, &m) && n > 0) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tscanf(\"%d\", &j);\n\t\t\twhile (j-- > 0) scanf(\"%d\", &k), c[k] = i;\n\t\t}\n\t\tans = k = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tj = c[i] - k;\n\t\t\tif (j < 0) j = -j;\n\t\t\tans += j * p3[n-i];\n\t\t\tif (j == 1) k = 2 - k;\n\t\t}\n\t\tk = p3[n] - ans - 1;\n\t\tif (ans > k) ans = k;\n\t\tif (ans > m) ans = -1;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* constant */\n\n#define MAX_INT (1 << 30)\n#define MAX_N   (15)\n#define MAX_KEY (14348907)      /* 3 ** 15 */\n\n/* typedef */\n\ntypedef char cup_t[MAX_N];\n\n/* global variables */\n\nstatic int n, m;\n\nstatic int dists[MAX_KEY];\n\nstatic int qhead, qtail;\nstatic long q[MAX_KEY / 10];\n\n/* subroutines */\n\nlong expi(long d, int n) {\n  long e = 1;\n  while (n) {\n    if (n & 1) e *= d;\n    d *= d;\n    n >>= 1;\n  }\n  return e;\n}\n\nlong arr2key(cup_t cups) {\n  int i;\n  long key = 0;\n\n  for (i = n - 1; i >= 0; i--)\n    key = key * 3 + cups[i];\n\n  return key;\n}\n\nchar *key2arr(long key, cup_t cups) {\n  int i;\n\n  for (i = 0; i < n; i++) {\n    cups[i] = key % 3;\n    key /= 3;\n  }\n\n  return cups;\n}\n\n/* main */\n\nint main(int argc, char **argv) {\n  int cn, cp, d, dg, g0, g1, i, j, k, nnbr;\n  long key, st, u, v;\n  static int tops[3];\n  static long nbrs[4];\n  static cup_t cups, cups0, cups1;\n\n  for (;;) {\n    scanf(\"%d %d\", &n, &m);\n    if (n == 0 && m == 0) break;\n\n    for (k = 0; k < 3; k++) {\n      scanf(\"%d\", &cn);\n      for (i = 0; i < cn; i++) {\n        scanf(\"%d\", &j);\n        cups[j - 1] = k;\n      }\n    }\n\n    g0 = 0;\n    g1 = expi(3, n) - 1;\n\n    st = arr2key(cups);\n\n    for (i = g0; i <= g1; i++)\n      dists[i] = MAX_INT;\n    dists[st] = 0;\n\n    qhead = 0;\n    qtail = 1;\n    q[0] = st;\n\n    while (qtail > qhead) {\n      u = q[qhead++];\n\n      if (u == g0 || u == g1 || dists[u] >= m) break;\n\n      tops[0] = tops[1] = tops[2] = -1;\n      key = u;\n\n      for (i = 0; i < n; i++) {\n        cp = key % 3;\n        cups0[i] = cp;\n        key /= 3;\n        tops[cp] = i;\n      }\n\n      nnbr = 0;\n      if (tops[0] > tops[1]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[0]] = 1;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n      if (tops[1] > tops[0]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[1]] = 0;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n      if (tops[1] > tops[2]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[1]] = 2;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n      if (tops[2] > tops[1]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[2]] = 1;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n\n      d = dists[u] + 1;\n\n      for (i = 0; i < nnbr; i++) {\n        v = nbrs[i];\n        if (dists[v] > d) {\n          dists[v] = d;\n          q[qtail++] = v;\n        }\n      }\n    }\n\n    dg = (dists[g0] < dists[g1]) ? dists[g0] : dists[g1];\n\n    printf(\"%d\\n\",  dg < MAX_INT ? dg : -1);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void){\n\tint n,m;\n\tint i,j;\n\tint cups[3][16];\n\tint cup[3][16];\n\tint temp;\n\tint move[2];\n\tint moves[2];\n\tint min;\n\tint ccups[3];\n\tscanf(\"%d %d\",&n,&m);\n\twhile(n && m){\n\t\tfor(i=0;i<3;i++){\n\t\t\tscanf(\"%d\",&cups[i][0]);\n\t\t\tcup[i][0] = cups[i][0];\n\t\t\tfor(j=1;j<cups[i][0]+1;j++){\n\t\t\t\tscanf(\"%d\",&cups[i][j]);\n\t\t\t\tcup[i][j] = cups[i][j];\n\t\t\t}\n\t\t}\n\t\tif(cups[0][0] == n || cups[2][0] == n){\n\t\t\tprintf(\"0\\n\");\n\t\t}else{\n\t\t\tmove[0] = -1;\n\t\t\tmove[1] = -1;\n\t\t\tmoves[0] = -1;\n\t\t\tmoves[1] = -1;\n\t\t\tmin = -1;\n\t\t\tfor(i=1;i<m+1;i++){\n\t\t\t\tccups[0] = cups[0][cups[0][0]];\n\t\t\t\tccups[1] = cups[1][cups[1][0]];\n\t\t\t\tccups[2] = cups[2][cups[2][0]];\n\t\t\t\tif(ccups[0] > ccups[1] && (move[0] != 1 && move[1] != 0)){\n\t\t\t\t\tcups[1][cups[1][0]+1] = ccups[0];\n\t\t\t\t\tcups[0][0]--;\n\t\t\t\t\tcups[1][0]++;\n\t\t\t\t\tmove[0] = 0;\n\t\t\t\t\tmove[1] = 1;\n\t\t\t\t}else if(ccups[1] > ccups[2] && (move[0] != 2 || move[1] != 1)){\n\t\t\t\t\tcups[2][cups[2][0]+1] = ccups[1];\n\t\t\t\t\tcups[1][0]--;\n\t\t\t\t\tcups[2][0]++;\n\t\t\t\t\tmove[0] = 1;\n\t\t\t\t\tmove[1] = 2;\n\t\t\t\t}else if(ccups[2] > ccups[1] && (move[0] != 1 || move[1] != 2)){\n\t\t\t\t\tcups[1][cups[1][0]+1] = ccups[2];\n\t\t\t\t\tcups[2][0]--;\n\t\t\t\t\tcups[1][0]++;\n\t\t\t\t\tmove[0] = 2;\n\t\t\t\t\tmove[1] = 1;\n\t\t\t\t}else if(ccups[1] > ccups[0] && (move[0] != 0 || move[1] != 1)){\n\t\t\t\t\tcups[0][cups[0][0]+1] = ccups[1];\n\t\t\t\t\tcups[1][0]--;\n\t\t\t\t\tcups[0][0]++;\n\t\t\t\t\tmove[0] = 1;\n\t\t\t\t\tmove[1] = 0;\n\t\t\t\t}\n\t\t\t\tif(cups[0][0] == n || cups[2][0] == n){\n\t\t\t\t\tmin = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tccups[0] = cup[0][cup[0][0]];\n\t\t\t\tccups[1] = cup[1][cup[1][0]];\n\t\t\t\tccups[2] = cup[2][cup[2][0]];\n\t\t\t\tif(ccups[1] > ccups[0] && (moves[0] != 0 || moves[1] != 1)){\n\t\t\t\t\tcup[0][cup[0][0]+1] = ccups[1];\n\t\t\t\t\tcup[1][0]--;\n\t\t\t\t\tcup[0][0]++;\n\t\t\t\t\tmoves[0] = 1;\n\t\t\t\t\tmoves[1] = 0;\n\t\t\t\t}else if(ccups[2] > ccups[1] && (moves[0] != 1 || moves[1] != 2)){\n\t\t\t\t\tcup[1][cup[1][0]+1] = ccups[2];\n\t\t\t\t\tcup[2][0]--;\n\t\t\t\t\tcup[1][0]++;\n\t\t\t\t\tmoves[0] = 2;\n\t\t\t\t\tmoves[1] = 1;\n\t\t\t\t}else if(ccups[1] > ccups[2] && (moves[0] != 2 || moves[1] != 1)){\n\t\t\t\t\tcup[2][cup[2][0]+1] = ccups[1];\n\t\t\t\t\tcup[1][0]--;\n\t\t\t\t\tcup[2][0]++;\n\t\t\t\t\tmoves[0] = 1;\n\t\t\t\t\tmoves[1] = 2;\n\t\t\t\t}else if(ccups[0] > ccups[1] && (moves[0] != 1 || moves[1] != 0)){\n\t\t\t\t\tcup[1][cup[1][0]+1] = ccups[0];\n\t\t\t\t\tcup[0][0]--;\n\t\t\t\t\tcup[1][0]++;\n\t\t\t\t\tmoves[0] = 0;\n\t\t\t\t\tmoves[1] = 1;\n\t\t\t\t}\n\t\t\t\tif(cup[0][0] == n || cup[2][0] == n){\n\t\t\t\t\tmin = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",min);\n\t\t}\n\t\tscanf(\"%d %d\",&n,&m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,c[16],p,d;\nmain(n){\n\tfor(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",j>m?-1:j)){\n\t\tfor(k=3;k--;)\n\t\t\tfor(scanf(\"%d\",&i);i--;c[j]=k)scanf(\"%d\",&j);\n\t\tfor(j=k=0;k++<n;p=i%2*2+p&3)\n\t\t\tj+=pow(3,n-k)*abs(i=p-c[k]);\n\t\tj=fmin(j,pow(3,n)+~j);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int time;\n    int tower[3][15];\n    int t[3];\n} HANOI;\n\nHANOI queue[100000];\nint head, tail;\nint pow[30];\n\nvoid enq(HANOI t)\n{\n\tqueue[tail % 100000] = t;\n\ttail++;\n}\n\nvoid deq(HANOI *t)\n{\n\t*t = queue[head % 100000];\n\thead++;\n}\n\nchar v[15000000];\n\nint move(HANOI temp, int from, int to, int pw)\n{\n    int num;\n    int i, j;\n    HANOI first;\n    if ((temp.t[from] > 0 && temp.t[to] > 0 && temp.tower[from][temp.t[from] - 1] > temp.tower[to][temp.t[to] - 1]) ||temp.t[from] > 0 && temp.t[to] == 0){\n        first = temp;\n        first.tower[to][temp.t[to]] = first.tower[from][temp.t[from] - 1];\n        first.tower[from][temp.t[from] - 1] = 0;\n        first.t[from]--;\n        first.t[to]++;\n        first.time++;\n        num = 0;\n        for (i = 0; i < 3; i++){\n            for (j = 0; j < first.t[i]; j++){\n                num += i * pow[first.tower[i][j] - 1];\n            }\n            num %= 15000000;\n        }\n        if (v[0] == 1 || v[pw] == 1){\n            printf(\"%d\\n\", first.time);\n            return (1);\n        }\n        if (!v[num]){\n            v[num] = 1;\n            enq(first);\n        }\n    }\n    return (0);\n}\n\nint main(void)\n{\n    int n, m;\n    HANOI start, temp;\n    int i, j;\n    int pw;\n    \n    pow[0] = 1;\n    for (i = 1; i < 20; i++){\n        pow[i] = pow[i - 1] * 3;\n    }\n    \n    while (1){\n        scanf(\"%d%d\", &n, &m);\n        \n        if (n + m == 0){\n            break;\n        }\n        memset(start.tower, 0, sizeof(start.tower));\n        for (i = 0; i < 3; i++){\n            scanf(\"%d\", &start.t[i]);\n            for (j = 0; j < start.t[i]; j++){\n                scanf(\"%d\", &start.tower[i][j]);\n            }\n        }\n        \n        memset(v, 0, sizeof(v));\n        \n        start.time = 0;\n        head = tail = 0;\n        pw = pow[n] - 1;\n        enq(start);\n        \n        while (head != tail){\n            deq(&temp);\n            \n            if (temp.time > m){\n                printf(\"-1\\n\");\n                break;\n            }\n            \n            if (move(temp, 0, 1, pw)){\n                break;\n            }\n            if (move(temp, 1, 0, pw)){\n                break;\n            }\n            if (move(temp, 1, 2, pw)){\n                break;\n            }\n            if (move(temp, 2, 1, pw)){\n                break;\n            }\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,c[],p,d;\t//c[16]\nmain(n){\n\tfor(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",j>m?-1:j)){\n\t\tfor(k=3;k--;)\n\t\t\tfor(scanf(\"%d\",&i);i--;c[j]=k)scanf(\"%d\",&j);\n\t\tfor(j=k=0;k++<n;p=c[k]*2+p&3)\n\t\t\tj+=pow(3,n-k)*abs(p-c[k]);\n\t\tj=fmin(j,pow(3,n)+~j);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void){\n\tint n,m;\n\tint i,j;\n\tint cups[3][16];\n\tint cup[3][16];\n\tint temp;\n\tint over;\n\tint move[2];\n\tint min;\n\tscanf(\"%d %d\",&n,&m);\n\twhile(n && m){\n\t\tfor(i=0;i<3;i++){\n\t\t\tscanf(\"%d\",&cups[i][0]);\n\t\t\tcup[i][0] = cups[i][0];\n\t\t\tfor(j=1;j<cups[i][0]+1;j++){\n\t\t\t\tscanf(\"%d\",&cups[i][j]);\n\t\t\t\tcup[i][j] = cups[i][j];\n\t\t\t}\n\t\t}\n\t\tif(cups[0][0] == n || cups[2][0] == n){\n\t\t\tprintf(\"0\\n\");\n\t\t}else{\n\t\t\tmove[0] = -1;\n\t\t\tmove[1] = -1;\n\t\t\tover = 0;\n\t\t\tfor(i=1;i<m+1;i++){\n\t\t\t\tif(cups[0][cups[0][0]] > cups[1][cups[1][0]] && (move[0] != 1 && move[1] != 0)){\n\t\t\t\t\tcups[1][cups[1][0]+1] = cups[0][cups[0][0]];\n\t\t\t\t\tcups[0][0]--;\n\t\t\t\t\tcups[1][0]++;\n\t\t\t\t\tmove[0] = 0;\n\t\t\t\t\tmove[1] = 1;\n\t\t\t\t}else if(cups[1][cups[1][0]] > cups[2][cups[2][0]] && (move[0] != 2 || move[1] != 1)){\n\t\t\t\t\tcups[2][cups[2][0]+1] = cups[1][cups[1][0]];\n\t\t\t\t\tcups[1][0]--;\n\t\t\t\t\tcups[2][0]++;\n\t\t\t\t\tmove[0] = 1;\n\t\t\t\t\tmove[1] = 2;\n\t\t\t\t}else if(cups[2][cups[2][0]] > cups[1][cups[1][0]] && (move[0] != 1 || move[1] != 2)){\n\t\t\t\t\tcups[1][cups[1][0]+1] = cups[2][cups[2][0]];\n\t\t\t\t\tcups[2][0]--;\n\t\t\t\t\tcups[1][0]++;\n\t\t\t\t\tmove[0] = 2;\n\t\t\t\t\tmove[1] = 1;\n\t\t\t\t}else if(cups[1][cups[1][0]] > cups[0][cups[0][0]] && (move[0] != 0 || move[1] != 1)){\n\t\t\t\t\tcups[0][cups[0][0]+1] = cups[1][cups[1][0]];\n\t\t\t\t\tcups[1][0]--;\n\t\t\t\t\tcups[0][0]++;\n\t\t\t\t\tmove[0] = 1;\n\t\t\t\t\tmove[1] = 0;\n\t\t\t\t}else{\n\t\t\t\t\tmin = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(cups[0][0] == n || cups[2][0] == n){\n\t\t\t\t\tmin = i;\n\t\t\t\t\tover = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmove[0] = -1;\n\t\t\tmove[1] = -1;\n\t\t\tfor(i=1;i<m+1;i++){\n\t\t\t\tprintf(\"%d,\",cup[0][cup[0][0]]);\n\t\t\t\tprintf(\"%d,\",cup[1][cup[1][0]]);\n\t\t\t\tprintf(\"%d \",cup[2][cup[2][0]]);\n\t\t\t\tprintf(\"%d,%d\\n\",move[0],move[1]);\n\t\t\t\tif(cup[1][cup[1][0]] > cup[0][cup[0][0]] && (move[0] != 0 || move[1] != 1)){\n\t\t\t\t\tcup[0][cup[0][0]+1] = cup[1][cup[1][0]];\n\t\t\t\t\tcup[1][0]--;\n\t\t\t\t\tcup[0][0]++;\n\t\t\t\t\tmove[0] = 1;\n\t\t\t\t\tmove[1] = 0;\n\t\t\t\t}else if(cup[2][cup[2][0]] > cup[1][cup[1][0]] && (move[0] != 1 || move[1] != 2)){\n\t\t\t\t\tcup[1][cup[1][0]+1] = cup[2][cup[2][0]];\n\t\t\t\t\tcup[2][0]--;\n\t\t\t\t\tcup[1][0]++;\n\t\t\t\t\tmove[0] = 2;\n\t\t\t\t\tmove[1] = 1;\n\t\t\t\t}else if(cup[1][cup[1][0]] > cup[2][cup[2][0]] && (move[0] != 2 || move[1] != 1)){\n\t\t\t\t\tcup[2][cup[2][0]+1] = cup[1][cup[1][0]];\n\t\t\t\t\tcup[1][0]--;\n\t\t\t\t\tcup[2][0]++;\n\t\t\t\t\tmove[0] = 1;\n\t\t\t\t\tmove[1] = 2;\n\t\t\t\t}else if(cup[0][cup[0][0]] > cup[1][cup[1][0]] && (move[0] != 1 || move[1] != 0)){\n\t\t\t\t\tcup[1][cup[1][0]+1] = cup[0][cup[0][0]];\n\t\t\t\t\tcup[0][0]--;\n\t\t\t\t\tcup[1][0]++;\n\t\t\t\t\tmove[0] = 0;\n\t\t\t\t\tmove[1] = 1;\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(cup[0][0] == n || cup[2][0] == n){\n\t\t\t\t\tif(min > i || min == -1){\n\t\t\t\t\t\tmin = i;\n\t\t\t\t\t\tover = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(over==0){\n\t\t\t\tmin = -1;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",min);\n\t\t}\n\t\tscanf(\"%d %d\",&n,&m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define LEFT 0\n#define RIGHT 1\n#define QUEUE_SIZE 1500000\n\ntypedef struct{\n\tint num;\n\tint cups[15];\n}HANOI;\n\ntypedef struct{\n\tHANOI current[4];\n\tHANOI privious[4];\n\tint count;\n}QUEUE;\n\nint n,m;\nint min = INT_MAX;\n\nHANOI Hanoi[4], Prev[4];\nHANOI Move_left[4], Move_right[4];\n\nint queue_top, queue_bottom;\nQUEUE queue[QUEUE_SIZE];\n\n\nvoid Initialize(void){\n\tint i,j;\n\n\tmin = INT_MAX;\n\tqueue_top=queue_bottom=0;\n\tfor(i=0;i<4;i++){\n\t\tHanoi[i].num=0;\n\t\tfor(j=0;j<15;j++) Hanoi[i].cups[j]=0;\n\t}\n\tfor(i=0;i<4;i++){\n\t\tPrev[i].num=0;\n\t\tfor(j=0;j<15;j++) Prev[i].cups[j]=0;\n\t}\n\n\treturn;\n}\n\nvoid MoveCup(int pos, int which){\n\tif(which==LEFT){\n\t\tMove_left[pos-1].num++;\n\t\tMove_left[pos-1].cups[Move_left[pos-1].num]=Move_left[pos].cups[Move_left[pos].num];\n\t\tMove_left[pos].cups[Move_left[pos].num]=0;\n\t\tMove_left[pos].num--;\n\t}else if(which==RIGHT){\n\t\tMove_right[pos+1].num++;\n\t\tMove_right[pos+1].cups[Move_right[pos+1].num]=Move_right[pos].cups[Move_right[pos].num];\n\t\tMove_right[pos].cups[Move_right[pos].num]=0;\n\t\tMove_right[pos].num--;\n\t}\n\treturn;\n}\n\n\nvoid SetQueue(HANOI *insert, int top, int bottom, int count){\n\tint i,j;\n\tfor(i=1;i<4;i++){\n\t\tqueue[bottom].privious[i].num = queue[top].current[i].num;\n\t\tfor(j=1;j<=queue[top].current[i].num;j++){\n\t\t\tqueue[bottom].privious[i].cups[j] = queue[top].current[i].cups[j];\n\t\t}\n\t}\n\tfor(i=1;i<4;i++){\n\t\tqueue[bottom].current[i].num = insert[i].num;\n\t\tfor(j=1;j<=insert[i].num;j++){\n\t\t\tqueue[bottom].current[i].cups[j] = insert[i].cups[j];\n\t\t}\n\t}\n\tqueue[bottom].count=count;\n\treturn ;\n}\n\nvoid HanoiMove(HANOI *hanoi, HANOI *prev, int count){\n\tint i,j,k;\n\tint count_left, count_right;\n\n\tfor(i=0;i<4;i++){\n\t\tMove_left[i].num=0;\n\t\tfor(j=0;j<15;j++) Move_left[i].cups[j]=0;\n\t}\n\tfor(i=0;i<4;i++){\n\t\tMove_right[i].num=0;\n\t\tfor(j=0;j<15;j++) Move_right[i].cups[j]=0;\n\t}\n\n\tfor(;;){\n\t\tfor(i=1;i<4;i++){\n\t\t\tMove_left[i].num = queue[queue_top].current[i].num;\n\t\t\tMove_right[i].num = queue[queue_top].current[i].num;\n\n\t\t\tfor(j=1;j<=queue[queue_top].current[i].num;j++){\n\t\t\t\tMove_left[i].cups[j] = queue[queue_top].current[i].cups[j];\n\t\t\t\tMove_right[i].cups[j] = queue[queue_top].current[i].cups[j];\n\t\t\t}\n\t\t}\n\n\t\tfor(i=1;i<4;i++){\n\t\t\tif(i==2) continue;\n\t\t\telse if(Move_left[i].num==n && queue[queue_top].count<min){\n\t\t\t\tmin = queue[queue_top].count;\n\t\t\t}\n\t\t}\n\t\tif(queue[queue_top].count>min){\n\t\t\tqueue_top++;\n\t\t\tif(queue_top==queue_bottom) break;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcount_left=count_right=queue[queue_top].count;\n\n\t\tfor(i=1;i<4;i++){\n\t\t\tif(queue[queue_top].current[i].num==0) continue;\n\t\t\tif(i>=2){\n\n\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\tMove_left[j].num = queue[queue_top].current[j].num;\n\t\t\t\t\tfor(k=1;k<=queue[queue_top].current[j].num;k++){\n\t\t\t\t\t\tMove_left[j].cups[k] = queue[queue_top].current[j].cups[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(Move_left[i].cups[Move_left[i].num]>Move_left[i-1].cups[Move_left[i-1].num]){\n\t\t\t\t\tMoveCup(i,LEFT);\n\t\t\t\t\tcount_left=queue[queue_top].count+1;\n\n\t\t\t\t\tif(count_left>m) continue;\n\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tif(Move_left[j].num!=queue[queue_top].privious[j].num){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j<4){\n\t\t\t\t\t\tqueue_bottom+=1;\n\t\t\t\t\t\tif(queue_bottom>=QUEUE_SIZE) queue_bottom=0;\n\t\t\t\t\t\tSetQueue(Move_left, queue_top, queue_bottom, count_left);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i<=2){\n\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\tMove_right[j].num = queue[queue_top].current[j].num;\n\t\t\t\t\tfor(k=1;k<=queue[queue_top].current[j].num;k++){\n\t\t\t\t\t\tMove_right[j].cups[k] = queue[queue_top].current[j].cups[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(Move_right[i].cups[Move_right[i].num]>Move_right[i+1].cups[Move_right[i+1].num]){\n\t\t\t\t\tMoveCup(i,RIGHT);\n\t\t\t\t\tcount_right=queue[queue_top].count+1;\n\t\t\t\t\tif(count_right>m) continue;\n\t\t\t\t\t\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tif(Move_right[j].num!=queue[queue_top].privious[j].num){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j<4){\n\t\t\t\t\t\tqueue_bottom+=1;\n\t\t\t\t\t\tif(queue_bottom>=QUEUE_SIZE) queue_bottom=0;\n\t\t\t\t\t\tSetQueue(Move_right, queue_top, queue_bottom, count_right);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue_top++;\n\t\tif(queue_top>=QUEUE_SIZE) queue_top=0;\n\t\tif(queue_top==queue_bottom) break;\n\n\t}\n\treturn;\n}\n\nint main(void){\n\tint i,j;\n\n\twhile(scanf(\"%d %d\",&n,&m)!=EOF){\n\t\tif(n==0 && m==0) break;\n\t\tInitialize();\n\t\tfor(i=1;i<4;i++){\n\t\t\tscanf(\"%d\",&Hanoi[i].num);\n\t\t\tfor(j=1;j<=Hanoi[i].num;j++){\n\t\t\t\tscanf(\"%d\",&Hanoi[i].cups[j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<4;i++){\n\t\t\tqueue[queue_top].current[i].num = Hanoi[i].num;\n\t\t\tqueue[queue_top].privious[i].num = Hanoi[i].num;\n\t\t\tfor(j=1;j<=Hanoi[i].num;j++){\n\t\t\t\tqueue[queue_top].current[i].cups[j] = Hanoi[i].cups[j];\n\t\t\t\tqueue[queue_top].privious[i].cups[j] = Hanoi[i].cups[j];\n\t\t\t}\n\t\t}\n\t\tHanoiMove(Hanoi,Prev,0);\n\t\tif(min>m) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",min);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int time;\n    int tower[3][15];\n    int t[3];\n} HANOI;\n\nHANOI queue[50000];\nint head, tail;\nint pow[30];\n\nvoid enq(HANOI t)\n{\n\tqueue[tail % 50000] = t;\n\ttail++;\n}\n\nvoid deq(HANOI *t)\n{\n\t*t = queue[head % 50000];\n\thead++;\n}\n\nchar v[15000000];\n\nint move(HANOI temp, int from, int to, int pw)\n{\n    int num;\n    int i, j;\n    HANOI first;\n    if ((temp.t[from] > 0 && temp.t[to] > 0 && temp.tower[from][temp.t[from] - 1] > temp.tower[to][temp.t[to] - 1]) ||temp.t[from] > 0 && temp.t[to] == 0){\n        first = temp;\n        first.tower[to][temp.t[to]] = first.tower[from][temp.t[from] - 1];\n        first.tower[from][temp.t[from] - 1] = 0;\n        first.t[from]--;\n        first.t[to]++;\n        first.time++;\n        num = 0;\n        for (i = 0; i < 3; i++){\n            for (j = 0; j < first.t[i]; j++){\n                num += i * pow[first.tower[i][j] - 1];\n            }\n        }\n        if (v[0] == 1 || v[pw] == 1){\n            printf(\"%d\\n\", first.time);\n            return (1);\n        }\n        if (!v[num]){\n            v[num] = 1;\n            enq(first);\n        }\n    }\n    return (0);\n}\n\nint main(void)\n{\n    int n, m;\n    HANOI start, temp;\n    int i, j;\n    int pw;\n    \n    pow[0] = 1;\n    for (i = 1; i < 20; i++){\n        pow[i] = pow[i - 1] * 3;\n    }\n    \n    while (1){\n        scanf(\"%d%d\", &n, &m);\n        \n        if (n + m == 0){\n            break;\n        }\n        memset(start.tower, 0, sizeof(start.tower));\n        for (i = 0; i < 3; i++){\n            scanf(\"%d\", &start.t[i]);\n            for (j = 0; j < start.t[i]; j++){\n                scanf(\"%d\", &start.tower[i][j]);\n            }\n        }\n        \n        memset(v, 0, sizeof(v));\n        \n        start.time = 0;\n        head = tail = 0;\n        pw = pow[n] - 1;\n        enq(start);\n        \n        while (head != tail){\n            deq(&temp);\n            \n            if (temp.time > m){\n                printf(\"-1\\n\");\n                break;\n            }\n            \n            if (move(temp, 0, 1, pw)){\n                break;\n            }\n            if (move(temp, 1, 0, pw)){\n                break;\n            }\n            if (move(temp, 1, 2, pw)){\n                break;\n            }\n            if (move(temp, 2, 1, pw)){\n                break;\n            }\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,c[];main(n){for(;scanf(\"%d%d\",&n,&m)*n;printf(\"%d\\n\",j>m?i:j)){for(k=-3;k++;)for(scanf(\"%d\",&i);j=i--;c[n-j]=k)scanf(\"%d\",&j);for(i=n;i--;k-=c[i])j+=pow(3,i)*abs(k*2%4+c[i]);j=fmin(j,pow(3,n)+~j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(void){\n\tint pow3[16], c[16];\n\tint n, m, i, j, k, d, cnt, p;\n\n\tpow3[0] = 1;\n\tfor(i = 1; i <= 15; ++i){\n\t\tpow3[i] = pow3[i-1] * 3;\n\t}\n\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\tfor(i = 0; i < 3; ++i){\n\t\t\tfor(scanf(\"%d\", &j); j > 0; --j){\n\t\t\t\tscanf(\"%d\", &k);\n\t\t\t\tc[n-k] = i;\n\t\t\t}\n\t\t}\n\n\t\tp = 0;\n\t\tcnt = 0;\n\t\tfor(i = n - 1; i >= 0; --i){\n\t\t\td = abs(p - c[i]);\n\t\t\tcnt += pow3[i] * d;\n\t\t\tif(d == 1){\n\t\t\t\tp = 2 - p;\n\t\t\t}\n\t\t}\n\n\t\tk = pow3[n] - 1 - cnt;\n\t\tif(cnt > k){\n\t\t\tcnt = k;\n\t\t}\n\t\tprintf(\"%d\\n\", cnt > m ? -1 : cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define min(a, b) ((a) < (b) ? (a) : (b))\n\nint right_start(int A, int B, int C);\n\nint left_start(int A, int B, int C)\n{\n\tif (!B && !C) return 0;\n\n\tif (A & 1){\n\t\treturn left_start(A>>1, B>>1, C>>1);\n\t}\n\tif (B & 1){\n\t\treturn right_start(A>>1, B>>1, C>>1 ) + 1 + left_start(0, 0, (A|B|C)>>1 );\n\t}\n\tif (C & 1){\n\t\treturn left_start(A>>1,B>>1,C>>1) + 1 + right_start((A|B|C)>>1, 0, 0) + 1 + left_start(0, 0, (A|B|C)>>1);\n\t}\n}\n\nint right_start(int A, int B, int C)\n{\n\tif (!A && !B) return 0;\n\n\tif (C & 1){\n\t\treturn right_start(A>>1, B>>1, C>>1);\n\t}\n\tif (B & 1){\n\t\treturn left_start(A>>1, B>>1, C>>1) + 1 + right_start((A|B|C)>>1, 0, 0);\n\t}\n\tif (A & 1 ){\n\t\treturn right_start(A>>1, B>>1, C>>1) + 1 + left_start(0, 0, (A|B|C)>>1) + 1 + right_start((A|B|C)>>1, 0, 0);\n\t}\n}\n\nint main(void)\n{\n\tint n,m;\n\tint c_max,c;\n\tint i,j;\n\tint a;\n\tint cup[3];\n\n\twhile(scanf(\"%d%d\", &n, &m) && n+m){\n\t\tfor(i=0;i<3;i++){\n\t\t\tcup[i] = 0;\n\t\t\tscanf(\"%d\", &c_max);\n\t\t\tfor(j=0;j<c_max;j++){\n\t\t\t\tscanf(\"%d\", &c);\n\t\t\t\tcup[i] |= 1 << (c-1);\n\t\t\t}\n\t\t}\n\n\t\ta=min(left_start(cup[0],cup[1],cup[2]), right_start(cup[0],cup[1],cup[2]));\n\t\tprintf(\"%d\\n\",(a>m?-1:a));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "n,m,p[16],s,P[16];R(c,d,r){if(c<=n){for(r=p[c]<d?1:-1;p[c]-d;p[c]+=r)R(c+1,3-p[c]*2-r),s++;R(c+1,d);}}main(i,c,t){for(;scanf(\"%d%d\",&n,&m)*n;s=!printf(\"%d\\n\",s>m?-1:s)){for(i=3;i--;)for(scanf(\"%d\",&t);t--;p[c]=P[c]=i)scanf(\"%d\",&c);R(1,2);t=s;memcpy(p,P,64);R(1,s=0);s=t<s?t:s;}}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,t[16],c[16],p,d;\nint main(n){\n\tfor(*t=1;++i<16;)t[i]=n*=3;\n\tfor(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",j>m?-1:j=fmin(j,t[n]+~j))){\n\t\tfor(k=3;k--;)\n\t\t\tfor(scanf(\"%d\",&i);i--;c[j]=k)scanf(\"%d\",&j);\n\t\tfor(p=j=k=0;k++<n;)\n\t\t\tj+=t[n-k]*abs(i=p-c[k]),p=i%2*2+p&3;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint cup[15],n;\n\nlong beki(int a,int b){\n\tint i;\n\tlong ans=1;\n\tfor(i=0;i<b;i++){\n\t\tans*=a;\n\t}\n\treturn ans;\n}\n\nlong mini(int min,int c){\n\tif(min==(n-1)){\n\t\tswitch(cup[min]-c){\n\t\t\tcase 0:\n\t\t\treturn 0;\n\t\t\tcase 1:\n\t\t\tcase -1:\n\t\t\treturn 1;\n\t\t\tcase 2:\n\t\t\tcase -2:\n\t\t\treturn 2;\n\t\t}\n\t}else{\n\t\tswitch(cup[min]){\n\t\t\tcase 0:\n\t\t\tif(c==0){\n\t\t\t\treturn mini(min+1,0);\n\t\t\t}else if(c==1){\n\t\t\t\treturn mini(min+1,2)+1+(beki(3,n-min-1)-1/2);\n\t\t\t}else{\n\t\t\t\treturn mini(min+1,2)+(2*beki(3,n-min-1));\n\t\t\t}\n\t\t\tcase 1:\n\t\t\tif(c==0){\n\t\t\t\treturn mini(min+1,2)+beki(3,n-min-1);\n\t\t\t}else if(c==1){\n\t\t\t\treturn mini(min+1,1);\n\t\t\t}else{\n\t\t\t\treturn mini(min+1,0)+beki(3,n-min-1);\n\t\t\t}\n\t\t\tcase 2:\n\t\t\tif(c==0){\n\t\t\t\treturn mini(min+1,2)+(2*beki(3,n-min-1));\n\t\t\t}else if(c==1){\n\t\t\t\treturn mini(min+1,0)+1+((beki(3,n-min-1)-1)/2);\n\t\t\t}else{\n\t\t\t\treturn mini(min+1,2);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint i,j,c,cc;\n\tlong m,amin,bmin;\n\tscanf(\"%d %lld\",&n,&m);\n\twhile(n!=0){\n\tfor(i=0;i<3;i++){\n\t\tscanf(\"%d\",&c);\n\t\tfor(j=0;j<c;j++){\n\t\t\tscanf(\"%d\",&cc);\n\t\t\tcup[cc-1]=i;\n\t\t}\n\t}\n\tamin=mini(0,0);\n\tbmin=mini(0,2);\n\tif(amin>=bmin){\n\t\tif(m<bmin) printf(\"-1\\n\");\n\t\telse printf(\"%ld\\n\",bmin);\n\t}else{\n\t\tif(m<amin) printf(\"-1\\n\");\n\t\telse printf(\"%ld\\n\",amin);\n\t}\n\tscanf(\"%d %ld\",&n,&m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ  0503: Cup\n// 2017.10.29 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint c[16];\n\nint main()\n{\n\tint n, m, i, j, k, ans;\n\tint p3[16];\n\n\tfor (p3[0] = 1, i = 1; i < 16; i++) p3[i] = 3*p3[i-1];\n\twhile (scanf(\"%d%d\", &n, &m) && n > 0) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tscanf(\"%d\", &j);\n\t\t\twhile (j-- > 0) scanf(\"%d\", &k), c[k-1] = i;\n\t\t}\n\t\tans = k = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tj = c[i] - k;\n\t\t\tif (j < 0) j = -j;\n\t\t\tans += j * p3[n-i-1];\n\t\t\tif (j == 1) k = 2 - k;\n\t\t}\n\t\tk = p3[n] - ans - 1;\n\t\tif (ans > k) ans = k;\n\t\tif (ans > m) ans = -1;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "f=\"%d\\n\";c[];main(n,m,i,j,k){for(;scanf(\"%d%d\",&n,&m)*n;printf(f,j>m?i:j)){for(i=3;i--;)for(scanf(f,&j);j--;c[n-k]=i)scanf(f,&k);for(i=n;i--;k+=c[i])j-=pow(3,i)*abs(k*2%4-c[i]);j=fmin(~j,pow(3,n)+j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main() {\n\n  int n,m;\n  int i,j,k,l;\n  int a,b,c,d[3],e;\n  \n  while(1) {\n\n  int A[16] = {-1} ,B[16] = {-1},C[16] = {-1};\n\n    scanf(\"%d %d\",&n,&m);\n    // printf(\"n = %d\\nm = %d\\n\",n,m);\n\n    if(n == 0 && m == 0) break;\n\n    for(i = 0;i<3; i++) {\n\n      scanf(\"%d\",&d[i]);\n      // printf(\"d[%d] = %d\\n\",i,d[i]);\n      k = 1;\n\n      for(j=0; j<d[i]; j++) {\n\tscanf(\"%d\",&e);\n\n\tif(i == 0) {\n\t  A[k] = e;\n\t  // printf(\"A[%d] = %d\\n\",k,A[k]);\n\t} else if(i ==1) {\n\t  B[k] = e;\n\t  //   printf(\"B[%d] = %d\\n\",k,B[k]);\n\t} else if(i ==2){\n\t  C[k] = e;\n\t  //\t  printf(\"C[%d] = %d\\n\",k,C[k]);\n\t}\n\n\tk++;\n      }\n    }\n\n    a = d[0];\n    b = d[1];\n    c = d[2];\n\n    k = 0;\n    for(i=0; i<m;i++) {\n\n      // printf(\"{A[%d](%d)} {B[%d](%d)} {C[%d](%d)}\\n\",a,A[a],b,B[b],c,C[c]);\n\n      if(a == 0 && b == 0) break;\n      else  if(b == 0 && c == 0) break;\n\n      /*\n\tif(A[a] == n  ) {\n\tprintf(\"A[%d](%d) => C[%d](%d)\\n\",a,A[a],c,C[c]);\n\tc++;\n\tC[c] = A[a];\n\tA[a] = -1;\n\ta--;\n\tk += 2;\n\t}\n\telse if(C[c] == n && ) {\n\tprintf(\"C[%d](%d) => A[%d](%d)\\n\",c,C[c],a,A[a]);\n\ta++;\n\tA[a] = C[c];\n\tC[c] = -1;\n\tc--;\n\tk += 2;\n\t} */ \n\n      if(A[a] < B[b] && B[b] < C[c]) {\n\ta++;\t\n\t//\tprintf(\"B[%d](%d) => A[%d](%d)\\n\",b,B[b],a,A[a]);\n\tA[a] = B[b];\n\tB[b] = -1;\n\tb--;\n\tk++;\n    \n\twhile(1) {\n\t  l = 0;\n\n\t  while(1) {\n\t    if(B[b] < C[c]) {\n\t      b++;\n\t      // printf(\"C[%d](%d) => B[%d](%d)\\n\",c,C[c],b,B[b]);\n\t      B[b] = C[c];\n\t      C[c] = -1;\n\t      c--;\n\t      k++;\n\t      l = 0;\n\t    } else {\n\t      l++;\n\t      break;\n\t    }\n\t  }\n       \n\t  while(1) {\n\t    if(A[a] < B[b]) {\n\t      a++;\n\t      // printf(\"B[%d](%d) => A[%d](%d)\\n\",b,B[b],a,A[a]);\n\t      A[a] = B[b];\n\t      b--;\n\t      k++;\n\t      l = 0;\n\t    } else {\n\t      l++;\n\t      break;\n\t    }\n\t  }\n\t  while(l == 2) {\n\n\t    if(a == 0 && b == 0) {\n\t      l++;\n\t      break;\n\t    } else if(b == 0 && c == 0) {\n\t      l++;\n\t      break;\n\t    }\n\t    else if(A[a] == n) {\n\t      //    printf(\"A[%d](%d) => C[%d](%d)\\n\",a,A[a],c,C[c]);\n\t      c++;\n\t      C[c] = A[a];\n\t      A[a] = -1;\n\t      a--;\n\t      k += 2;\n\t      l = 2;\n\t  \n\t    } else {\n\t      l++;\n\t      break;\n\t    } \n\t  }\n\n\t  if(l == 3) break;\n\t\n\t}\n      \n\n      } else if(C[c] < B[b] && B[b] < A[a]){\n\tc++;\n\t//printf(\"B[%d](%d) => C[%d](%d)\\n\",b,B[b],c,C[c]);\n\tC[c] = B[b];\n\tB[b] = -1;\n\tb--;\n\tk++;\n\twhile(1) {\n\t  l = 0;\n\t  while(1) {\n\t    if(B[b] < A[a]) {\n\t      b++;\n\t      // printf(\"A[%d](%d) => B[%d](%d)\\n\",a,A[a],b,B[b]);\n\t      B[b] = A[a];\n\t      A[a] = -1;\n\t      a--;\n\t      k++;\n\t      l = 0;\n\t    } else { \n\t      l++;\n\t      break;\n\t    }\n\t  }\n\t  while(1) {\n\t    if(C[c] < B[b]) {\n\t      c++;\n\t      // printf(\"B[%d](%d) => C[%d](%d)\\n\",b,B[b],c,C[c]);\n\t      C[c] = B[b];\n\t      b--;\n\t      k++;\n\t      l = 0;\n\t    } else {\n\t      l++;\n\t      break;\n\t    }\n\t  }\n\t  while(l == 2) {\n\t    if(a == 0 && b == 0) {\n\t      l++;\n\t      break;\n\t    } else if(b == 0 && c == 0) {\n\t      l++;\n\t      break;\n\t    }\n\t    \n\t    else if(C[c] == n) {\n\t      //      printf(\"C[%d](%d) => A[%d](%d)\\n\",c,C[c],a,A[a]);\n\t      a++;\n\t      A[a] = C[c];\n\t      C[c] = -1;\n\t      c--;\n\t      k += 2;\n\t      l = 2;\n\t    } else {\n\t      l++;\n\t      break;\n\t    }\n\t  }\n\t  if(l == 3) break;\n\n\t}\n      }\n\n     \n\n    }\n\n    if(a == 0 && b == 0 && m >= k) printf(\"%d\\n\",k);\n    else if(b == 0 && c == 0 && m >= k) printf(\"%d\\n\",k);\n    else printf(\"-1\\n\");\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(void){\n\tint pow3[16], c[16];\n\tint n, m, i, j, k, d, x, y, p;\n\n\tpow3[0] = 1;\n\tfor(i = 1; i <= 15; ++i){\n\t\tpow3[i] = pow3[i-1] * 3;\n\t}\n\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\tfor(i = 0; i < 3; ++i){\n\t\t\tfor(scanf(\"%d\", &j); j > 0; --j){\n\t\t\t\tscanf(\"%d\", &k);\n\t\t\t\tc[n-k] = i;\n\t\t\t}\n\t\t}\n\n\t\tp = 0;\n\t\tx = 0;\n\t\tfor(i = n - 1; i >= 0; --i){\n\t\t\td = abs(p - c[i]);\n\t\t\tx += pow3[i] * d;\n\t\t\tif(d == 1){\n\t\t\t\tp = 2 - p;\n\t\t\t}\n\t\t}\n\n\t\ty = pow3[n] - 1 - x;\n\t\tif(x > y){\n\t\t\tx = y;\n\t\t}\n\t\tprintf(\"%d\\n\", x > m ? -1 : x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n\nint n,m;\nint i,j,k,l;\nint a,b,c,d[3],e,p,a2,b2,q,c2;\nint A[16] = {-1} ,B[16] = {-1},C[16] = {-1};\nint max = -1;\nint A2[16] , B2[16],C2[16];\nint count;\nint ifa = -1,ifc= -1;\nvoid input() {\n\n  //  printf(\"strat input();\\n\");\n\n  for(i=0;i<16;i++) {\n    A[i] = -1;\n    B[i] = -1;\n    C[i] = -1;\n    A2[i] = -1;\n    B2[i] = -1;\n    C2[i] = -1;\n  }\n    \n    \n  scanf(\"%d %d\",&n,&m);\n  // printf(\"n = %d\\nm = %d\\n\",n,m);\n\n  \n  for(i = 0;i<3; i++) {\n\n    scanf(\"%d\",&d[i]);\n    // printf(\"d[%d] = %d\\n\",i,d[i]);\n    k = 1;\n\n    for(j=0; j<d[i]; j++) {\n      scanf(\"%d\",&e);\n\n      if(i == 0) {\n\tA[k] = e;\n\tA2[k] = e;\n\t//\tprintf(\"A[%d] = %d\\n\",k,A[k]);\n      } else if(i ==1) {\n\tB[k] = e;\n\tB2[k] = e;\n\t//\tprintf(\"B[%d] = %d\\n\",k,B[k]);\n      } else if(i ==2){\n\tC[k] = e;\n\tC2[k] = e;\n\t//\tprintf(\"C[%d] = %d\\n\",k,C[k]);\n      }\n\n      k++;\n    }\n  }\n\n  a = d[0];\n  b = d[1];\n  c = d[2];\n\n  k = 0;\n}\n\nvoid BtoA() {\n  a++;\t\n  // printf(\"B[%d](%d) => A[%d](%d)\\n\",b,B[b],a,A[a]);\n  A[a] = B[b];\n  B[b] = -1;\n  b--;\n  k++;\n\n}  \n\nvoid CtoB() {\n  b++;\n  // printf(\"C[%d](%d) => B[%d](%d)\\n\",c,C[c],b,B[b]);\n  B[b] = C[c];\n  C[c] = -1;\n  c--;\n  k++;\n}\n\nvoid BtoC() {\n  c++;\n  // printf(\"B[%d](%d) => C[%d](%d)\\n\",b,B[b],c,C[c]);\n  C[c] = B[b];\n  B[b] = -1;\n  b--;\n  k++;\n\t\n}\n\nvoid AtoB() {\n  b++;\n  // printf(\"A[%d](%d) => B[%d](%d)\\n\",a,A[a],b,B[b]);\n  B[b] = A[a];\n  A[a] = -1;\n  a--;\n  k++;\n}\n\nvoid CtoA() {\n  a++;\n  // printf(\"C[%d](%d) => A[%d](%d)\\n\",c,C[c],a,A[a]);\n  A[a] = C[c];\n  C[c] = -1;\n  c--;\n  k += 2;\n}\n\nvoid AtoC() {\n  c++;\n  // printf(\"A[%d](%d) => C[%d](%d)\\n\",a,A[a],c,C[c]);\n  C[c] = A[a];\n  A[a] = -1;\n  a--;\n  k += 2;\n}\n\nvoid IFC() {\n  ifc = -1;\n  //  printf(\"start IFC();\\n\");\n\n  e = 0;\n  while(1) {\n\n    if(c == 0 && b == 0){\n      ifc = 0;\n      break;\n    }else if(k+q >=m){\n      ifc = 0;\n      break;\n    } else if(a == 0 && b == 0) {\n      ifc = 0;\n      break;\n    }\n\n    if(C[c] < B[b] && e != 2 ) {\n      BtoC();\n      e = 1;\n    } else if(B[b] < C[c] && e != 1){\n      CtoB();\n      e = 2;\n    } else if(A[a] < B[b] && e != 4) {\n      BtoA();\n      e = 3;\n    } else if(B[b] < A[a] && e !=3) {\n      AtoB();\n      e = 4;\n    } else break;\n\n\n  }\n}\n    \n    \n\nvoid IFA() {\n\n  //  printf(\"Start IFA();\\n\");\n  e = 0;\n  ifa = -1;\nwhile(1) {\n\n  // printf(\"{A[%d]=%d} {B[%d]=%d} {C[%d]=%d}\\n\",a,A[a],b,B[b],c,C[c]);\n\n  if(c == 0 && b == 0 ) {\n    ifa = 0;\n    break;\n  } else if(k+q >= m) {\n    ifa = 0;\n    break;\n  }else if(a == 0 && b == 0) {\n    ifa = 0;\n    break;\n  }\n  \n  \n  if(A[a] < B[b] && e !=2 ) {\n    BtoA();\n    e = 1;\n  } else if(B[b] < A[a] && e !=1 && A[a] != a) {\n      AtoB();\n      e = 2;\n  }else if(C[c] < B[b] && e !=4) {\n    BtoC();\n    e = 3;\n  } else if(B[b] < C[c] && e !=3) {\n    CtoB();\n    e = 4;\n  } else {\n    break;\n  }\n\n  //  printf(\"c = %d\\n\",e);\n }\n \n}\n  \n  \n\n\n\n\nint main() {\n  \n  while(1) {\n\n    input(); \n\n    if(n == 0 && m == 0) break;\n  \n    q = 0;   \n    k = 0;\n    IFA();\n    // printf(\"Finish IFA(); k = %d\\n\",k);\n    a2 = a;\n    b2 = b;\n    c2 = c;\n    p = k;\n    k = 0;\n    q = 0;\n    for(i = 0;i<16;i++) {\n      A[i] = A2[i];\n      B[i] = B2[i];\n      C[i] = C2[i];\n    }\n    a = d[0];\n    b = d[1];\n    c = d[2];\n    \n    IFC();\n    // printf(\"Finish IFC(); k = %d\\n\",k);    \n    \n    if(ifc == 0 && ifa == 0) {\n      if(p < k) k = p;\n\n        printf(\"%d\\n\",k);\n    } else if(ifc == 0) printf(\"%d\\n\",k);\n    else if(ifa == 0) printf(\"%d\\n\",p);\n    else printf(\"-1\\n\");\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int time;\n    int tower[3][15];\n    int t[3];\n} HANOI;\n\nHANOI queue[50000];\nint head, tail;\nint pow[30];\n\nvoid enq(HANOI t)\n{\n\tqueue[tail % 50000] = t;\n\ttail++;\n}\n\nvoid deq(HANOI *t)\n{\n\t*t = queue[head % 50000];\n\thead++;\n}\n\nchar v[15000000];\n\nint move(HANOI temp, int from, int to, int pw)\n{\n    int num;\n    int i, j;\n    HANOI first;\n    if ((temp.t[from] > 0 && temp.t[to] > 0 && temp.tower[from][temp.t[from] - 1] > temp.tower[to][temp.t[to] - 1]) ||temp.t[from] > 0 && temp.t[to] == 0){\n        first = temp;\n        first.tower[to][temp.t[to]] = first.tower[from][temp.t[from] - 1];\n        first.tower[from][temp.t[from] - 1] = 0;\n        first.t[from]--;\n        first.t[to]++;\n        first.time++;\n        num = 0;\n        for (i = 0; i < 3; i++){\n            for (j = 0; j < first.t[i]; j++){\n                num += i * pow[first.tower[i][j] - 1];\n            }\n            num %= 15000000;\n        }\n        if (v[0] == 1 || v[pw] == 1){\n            printf(\"%d\\n\", first.time);\n            return (1);\n        }\n        if (!v[num]){\n            v[num] = 1;\n            enq(first);\n        }\n    }\n    return (0);\n}\n\nint main(void)\n{\n    int n, m;\n    HANOI start, temp;\n    int i, j;\n    int pw;\n    \n    pow[0] = 1;\n    for (i = 1; i < 20; i++){\n        pow[i] = pow[i - 1] * 3;\n    }\n    \n    while (1){\n        scanf(\"%d%d\", &n, &m);\n        \n        if (n + m == 0){\n            break;\n        }\n        memset(start.tower, 0, sizeof(start.tower));\n        for (i = 0; i < 3; i++){\n            scanf(\"%d\", &start.t[i]);\n            for (j = 0; j < start.t[i]; j++){\n                scanf(\"%d\", &start.tower[i][j]);\n            }\n        }\n        \n        memset(v, 0, sizeof(v));\n        \n        start.time = 0;\n        head = tail = 0;\n        pw = pow[n] - 1;\n        enq(start);\n        \n        while (head != tail){\n            deq(&temp);\n            \n            if (temp.time > m){\n                printf(\"-1\\n\");\n                break;\n            }\n            \n            if (move(temp, 0, 1, pw)){\n                break;\n            }\n            if (move(temp, 1, 0, pw)){\n                break;\n            }\n            if (move(temp, 1, 2, pw)){\n                break;\n            }\n            if (move(temp, 2, 1, pw)){\n                break;\n            }\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "c[];s(x){scanf(\"%d\",x);}main(n,m,i,j,k,f){for(;s(&n),s(&m),n;printf(\"%d\\n\",j>m?i:j)){for(i=3;i--;)for(s(&j);j--;c[n-k]=i)s(&k);for(i=n;i--;k+=c[i])j-=pow(3,i)*abs(k*2%4-c[i]);j=fmin(~j,pow(3,n)+j);}}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,c[],p,d;\t//c[16]\nmain(n){\n\tfor(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",j>m?k:j)){\n\t\tfor(k=3;k--;)\n\t\t\tfor(scanf(\"%d\",&i);i--;c[j]=k)scanf(\"%d\",&j);\n\t\tfor(j=i=0;i++<n;p=c[i]*2+p&3)\n\t\t\tj+=pow(3,n-i)*abs(p-c[i]);\n\t\tj=fmin(j,pow(3,n)+~j);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* constant */\n\n#define MAX_INT (1 << 30)\n#define MAX_N   (15)\n#define MAX_KEY (14348907)      /* 3 ** 15 */\n\n/* typedef */\n\ntypedef char cup_t[MAX_N];\n\n/* global variables */\n\nstatic int n, m;\n\nstatic int dists[MAX_KEY];\n\nstatic int qhead, qtail;\nstatic long q[MAX_KEY / 2];\n\n/* subroutines */\n\nlong expi(long d, int n) {\n  long e = 1;\n  while (n) {\n    if (n & 1) e *= d;\n    d *= d;\n    n >>= 1;\n  }\n  return e;\n}\n\nlong arr2key(cup_t cups) {\n  int i;\n  long key = 0;\n\n  for (i = n - 1; i >= 0; i--)\n    key = key * 3 + cups[i];\n\n  return key;\n}\n\nchar *key2arr(long key, cup_t cups) {\n  int i;\n\n  for (i = 0; i < n; i++) {\n    cups[i] = key % 3;\n    key /= 3;\n  }\n\n  return cups;\n}\n\n/* main */\n\nint main(int argc, char **argv) {\n  int cn, cp, d, dg, g0, g1, i, j, k, nnbr;\n  long key, st, u, v;\n  static int tops[3];\n  static long nbrs[4];\n  static cup_t cups, cups0, cups1;\n\n  for (;;) {\n    scanf(\"%d %d\", &n, &m);\n    if (n == 0 && m == 0) break;\n\n    for (k = 0; k < 3; k++) {\n      scanf(\"%d\", &cn);\n      for (i = 0; i < cn; i++) {\n        scanf(\"%d\", &j);\n        cups[j - 1] = k;\n      }\n    }\n\n    g0 = 0;\n    g1 = expi(3, n) - 1;\n\n    st = arr2key(cups);\n\n    for (i = g0; i <= g1; i++)\n      dists[i] = MAX_INT;\n    dists[st] = 0;\n\n    qhead = 0;\n    qtail = 1;\n    q[0] = st;\n\n    while (qtail > qhead) {\n      u = q[qhead++];\n\n      if (u == g0 || u == g1 || dists[u] >= m) break;\n\n      tops[0] = tops[1] = tops[2] = -1;\n      key = u;\n\n      for (i = 0; i < n; i++) {\n        cp = key % 3;\n        cups0[i] = cp;\n        key /= 3;\n        tops[cp] = i;\n      }\n\n      nnbr = 0;\n      if (tops[0] > tops[1]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[0]] = 1;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n      if (tops[1] > tops[0]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[1]] = 0;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n      if (tops[1] > tops[2]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[1]] = 2;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n      if (tops[2] > tops[1]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[2]] = 1;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n\n      d = dists[u] + 1;\n\n      for (i = 0; i < nnbr; i++) {\n        v = nbrs[i];\n        if (dists[v] > d) {\n          dists[v] = d;\n          q[qtail++] = v;\n        }\n      }\n    }\n\n    dg = (dists[g0] < dists[g1]) ? dists[g0] : dists[g1];\n\n    printf(\"%d\\n\",  dg < MAX_INT ? dg : -1);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,c[],p,d;main(n){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",j>m?-1:j)){for(k=3;k--;)for(scanf(\"%d\",&i);i--;c[j]=k)scanf(\"%d\",&j);for(j=k=0;k++<n;p=i%2*2+p&3)j+=pow(3,n-k)*abs(i=p-c[k]);j=fmin(j,pow(3,n)+~j);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\ntypedef struct{\n\tint num;\n\tint *cups;\n}HANOI;\n\nint n,m;\nint min;\n\nvoid HanoiMove(HANOI *Hanoi, HANOI *prev, int count){\n\tint i,j,k;\n\tint check, count_left, count_right;\n\tHANOI *Move_left, *Move_right;\n\n\tMove_left=(HANOI *)calloc(4,sizeof(HANOI));\n\tfor(i=0;i<4;i++){\n\t\tMove_left[i].cups=(int *)calloc(n,sizeof(int));\n\t}\n\tMove_right=(HANOI *)calloc(4,sizeof(HANOI));\n\tfor(i=0;i<4;i++){\n\t\tMove_right[i].cups=(int *)calloc(n,sizeof(int));\n\t}\n\n\tfor(i=1;i<4;i++){\n\t\tif(Hanoi[i].num==n && count<min){\n\t\t\tmin = count;\n\t\t}\n\t}\n\tcount_left=count_right=count;\n\n\tfor(i=1;i<4;i++){\n\t\tif(Hanoi[i].num==0) continue;\n\t\tif(i>=2){\n\t\t\tfor(j=1;j<4;j++){\n\t\t\t\tMove_left[j].num = Hanoi[j].num;\n\t\t\t\tfor(k=1;k<=Hanoi[j].num;k++){\n\t\t\t\t\tMove_left[j].cups[k] = Hanoi[j].cups[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(prev==NULL){\n\t\t\t\tprev=(HANOI *)calloc(4,sizeof(HANOI));\n\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\tprev[j].cups=(int *)calloc(n,sizeof(int));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(Move_left[i].cups[Move_left[i].num]>Move_left[i-1].cups[Move_left[i-1].num]){\n\t\t\t\tMove_left[i-1].num++;\n\t\t\t\tMove_left[i-1].cups[Move_left[i-1].num]=Move_left[i].cups[Move_left[i].num];\n\t\t\t\tMove_left[i].cups[Move_left[i].num]=0;\n\t\t\t\tMove_left[i].num--;\n\t\t\t\tcount_left++;\n\n\t\t\t\tcheck=0;\n\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\tif(prev!=NULL && Move_left[j].num==prev[j].num){\n\t\t\t\t\t\tcheck+=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(prev==NULL || check<3){\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tprev[j].num = Hanoi[j].num;\n\t\t\t\t\t\tfor(k=1;k<=Hanoi[j].num;k++){\n\t\t\t\t\t\t\tprev[j].cups[k] = Hanoi[j].cups[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tHanoi[j].num = Move_left[j].num;\n\t\t\t\t\t\tfor(k=1;k<=Move_left[j].num;k++){\n\t\t\t\t\t\t\tHanoi[j].cups[k] = Move_left[j].cups[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tHanoiMove(Hanoi, prev, count_left);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(i<=2){\n\t\t\tfor(j=1;j<4;j++){\n\t\t\t\tMove_right[j].num = Hanoi[j].num;\n\t\t\t\tfor(k=1;k<=Hanoi[j].num;k++){\n\t\t\t\t\tMove_right[j].cups[k] = Hanoi[j].cups[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(prev==NULL){\n\t\t\t\tprev=(HANOI *)calloc(4,sizeof(HANOI));\n\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\tprev[j].cups=(int *)calloc(n,sizeof(int));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(Move_right[i].cups[Move_right[i].num]>Move_right[i+1].cups[Move_right[i+1].num]){\n\t\t\t\tMove_right[i+1].num++;\n\t\t\t\tMove_right[i+1].cups[Move_right[i+1].num]=Move_right[i].cups[Move_right[i].num];\n\t\t\t\tMove_right[i].cups[Move_right[i].num]=0;\n\t\t\t\tMove_right[i].num--;\n\t\t\t\tcount_right++;\n\n\t\t\t\tcheck=0;\n\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\tif(prev!=NULL && Move_right[j].num==prev[j].num){\n\t\t\t\t\t\tcheck+=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(prev==NULL || check<3){\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tprev[j].num = Hanoi[j].num;\n\t\t\t\t\t\tfor(k=1;k<=Hanoi[j].num;k++){\n\t\t\t\t\t\t\tprev[j].cups[k] = Hanoi[j].cups[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tHanoi[j].num = Move_right[j].num;\n\t\t\t\t\t\tfor(k=1;k<=Move_right[j].num;k++){\n\t\t\t\t\t\t\tHanoi[j].cups[k] = Move_right[j].cups[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tHanoiMove(Hanoi, prev, count_right);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n}\n\nint main(void){\n\tint i,j;\n\tHANOI *Hanoi, *prev;\n\n\tHanoi=(HANOI *)calloc(4,sizeof(HANOI));\n\n\twhile(scanf(\"%d %d\",&n,&m)!=EOF){\n\t\tif(n==0 && m==0) break;\n\t\tmin = INT_MAX;\n\t\tfor(i=0;i<4;i++) Hanoi[i].cups=(int *)calloc(n,sizeof(int));\n\t\tfor(i=1;i<4;i++){\n\t\t\tscanf(\"%d\",&Hanoi[i].num);\n\t\t\tfor(j=1;j<=Hanoi[i].num;j++){\n\t\t\t\tscanf(\"%d\",&Hanoi[i].cups[j]);\n\t\t\t}\n\t\t}\n\t\tprev = NULL;\n\t\tHanoiMove(Hanoi,prev,0);\n\t\tif(min>m) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",min);\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "c[];f=\"%d\\n\";main(n,m,i,j,k){for(;scanf(\"%d%d\",&n,&m)*n;printf(f,j>m?i:j)){for(i=3;i--;)for(scanf(f,&j);j--;c[n-k]=i)scanf(f,&k);for(i=n;i--;k+=c[i])j-=pow(3,i)*abs(k*2%4-c[i]);j=fmin(~j,pow(3,n)+j);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void){\n\tint n,m;\n\tint i,j;\n\tint cups[3][16];\n\tint cup[3][16];\n\tint temp;\n\tint move[2];\n\tint moves[2];\n\tint min;\n\tint ccups[3];\n\tscanf(\"%d %d\",&n,&m);\n\twhile(n && m){\n\t\tfor(i=0;i<3;i++){\n\t\t\tscanf(\"%d\",&cups[i][0]);\n\t\t\tcup[i][0] = cups[i][0];\n\t\t\tprintf(\"i\");\n\t\t\tfor(j=1;j<cups[i][0]+1;j++){\n\t\t\t\tscanf(\"%d\",&cups[i][j]);\n\t\t\t\tcup[i][j] = cups[i][j];\n\t\t\t\tprintf(\"j\");\n\t\t\t}\n\t\t}\n\t\tif(cups[0][0] == n || cups[2][0] == n){\n\t\t\tprintf(\"0\\n\");\n\t\t}else{\n\t\t\tmove[0] = -1;\n\t\t\tmove[1] = -1;\n\t\t\tmoves[0] = -1;\n\t\t\tmoves[1] = -1;\n\t\t\tmin = -1;\n\t\t\tfor(i=1;i<m+1;i++){\n\t\t\t\tccups[0] = cups[0][cups[0][0]];\n\t\t\t\tccups[1] = cups[1][cups[1][0]];\n\t\t\t\tccups[2] = cups[2][cups[2][0]];\n\t\t\t\tif(ccups[0] > ccups[1] && (move[0] != 1 && move[1] != 0)){\n\t\t\t\t\tcups[1][cups[1][0]+1] = ccups[0];\n\t\t\t\t\tcups[0][0]--;\n\t\t\t\t\tcups[1][0]++;\n\t\t\t\t\tmove[0] = 0;\n\t\t\t\t\tmove[1] = 1;\n\t\t\t\t}else if(ccups[1] > ccups[2] && (move[0] != 2 || move[1] != 1)){\n\t\t\t\t\tcups[2][cups[2][0]+1] = ccups[1];\n\t\t\t\t\tcups[1][0]--;\n\t\t\t\t\tcups[2][0]++;\n\t\t\t\t\tmove[0] = 1;\n\t\t\t\t\tmove[1] = 2;\n\t\t\t\t}else if(ccups[2] > ccups[1] && (move[0] != 1 || move[1] != 2)){\n\t\t\t\t\tcups[1][cups[1][0]+1] = ccups[2];\n\t\t\t\t\tcups[2][0]--;\n\t\t\t\t\tcups[1][0]++;\n\t\t\t\t\tmove[0] = 2;\n\t\t\t\t\tmove[1] = 1;\n\t\t\t\t}else if(ccups[1] > ccups[0] && (move[0] != 0 || move[1] != 1)){\n\t\t\t\t\tcups[0][cups[0][0]+1] = ccups[1];\n\t\t\t\t\tcups[1][0]--;\n\t\t\t\t\tcups[0][0]++;\n\t\t\t\t\tmove[0] = 1;\n\t\t\t\t\tmove[1] = 0;\n\t\t\t\t}\n\t\t\t\tif(cups[0][0] == n || cups[2][0] == n){\n\t\t\t\t\tmin = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tccups[0] = cup[0][cup[0][0]];\n\t\t\t\tccups[1] = cup[1][cup[1][0]];\n\t\t\t\tccups[2] = cup[2][cup[2][0]];\n\t\t\t\tif(ccups[1] > ccups[0] && (moves[0] != 0 || moves[1] != 1)){\n\t\t\t\t\tcup[0][cup[0][0]+1] = ccups[1];\n\t\t\t\t\tcup[1][0]--;\n\t\t\t\t\tcup[0][0]++;\n\t\t\t\t\tmoves[0] = 1;\n\t\t\t\t\tmoves[1] = 0;\n\t\t\t\t}else if(ccups[2] > ccups[1] && (moves[0] != 1 || moves[1] != 2)){\n\t\t\t\t\tcup[1][cup[1][0]+1] = ccups[2];\n\t\t\t\t\tcup[2][0]--;\n\t\t\t\t\tcup[1][0]++;\n\t\t\t\t\tmoves[0] = 2;\n\t\t\t\t\tmoves[1] = 1;\n\t\t\t\t}else if(ccups[1] > ccups[2] && (moves[0] != 2 || moves[1] != 1)){\n\t\t\t\t\tcup[2][cup[2][0]+1] = ccups[1];\n\t\t\t\t\tcup[1][0]--;\n\t\t\t\t\tcup[2][0]++;\n\t\t\t\t\tmoves[0] = 1;\n\t\t\t\t\tmoves[1] = 2;\n\t\t\t\t}else if(ccups[0] > ccups[1] && (moves[0] != 1 || moves[1] != 0)){\n\t\t\t\t\tcup[1][cup[1][0]+1] = ccups[0];\n\t\t\t\t\tcup[0][0]--;\n\t\t\t\t\tcup[1][0]++;\n\t\t\t\t\tmoves[0] = 0;\n\t\t\t\t\tmoves[1] = 1;\n\t\t\t\t}\n\t\t\t\tif(cup[0][0] == n || cup[2][0] == n){\n\t\t\t\t\tmin = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",min);\n\t\tscanf(\"%d %d\",&n,&m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\ntypedef struct{\n\tint num;\n\tint *cups;\n}HANOI;\n\nint n,m;\nint min;\n\nvoid HanoiMove(HANOI *Hanoi, HANOI *prev, int count){\n\tint i,j,k;\n\tint check, count_left, count_right;\n\tHANOI *Move_left, *Move_right;\n\n\tMove_left=(HANOI *)calloc(4,sizeof(HANOI));\n\tfor(i=0;i<4;i++){\n\t\tMove_left[i].cups=(int *)calloc(n,sizeof(int));\n\t}\n\tMove_right=(HANOI *)calloc(4,sizeof(HANOI));\n\tfor(i=0;i<4;i++){\n\t\tMove_right[i].cups=(int *)calloc(n,sizeof(int));\n\t}\n\n\tfor(i=1;i<4;i++){\n\t\tif(Hanoi[i].num==n && count<min){\n\t\t\tmin = count;\n\t\t}\n\t}\n\tcount_left=count_right=count;\n\n\tfor(i=1;i<4;i++){\n\t\tif(Hanoi[i].num==0) continue;\n\t\tif(i>=2){\n\t\t\tfor(j=1;j<4;j++){\n\t\t\t\tMove_left[j].num = Hanoi[j].num;\n\t\t\t\tfor(k=1;k<=Hanoi[j].num;k++){\n\t\t\t\t\tMove_left[j].cups[k] = Hanoi[j].cups[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(prev==NULL){\n\t\t\t\tprev=(HANOI *)calloc(4,sizeof(HANOI));\n\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\tprev[j].cups=(int *)calloc(n,sizeof(int));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(Move_left[i].cups[Move_left[i].num]>Move_left[i-1].cups[Move_left[i-1].num]){\n\t\t\t\tMove_left[i-1].num++;\n\t\t\t\tMove_left[i-1].cups[Move_left[i-1].num]=Move_left[i].cups[Move_left[i].num];\n\t\t\t\tMove_left[i].cups[Move_left[i].num]=0;\n\t\t\t\tMove_left[i].num--;\n\t\t\t\tcount_left++;\n\n\t\t\t\tcheck=0;\n\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\tif(prev!=NULL && Move_left[j].num==prev[j].num){\n\t\t\t\t\t\tcheck+=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(prev==NULL || check<3){\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tprev[j].num = Hanoi[j].num;\n\t\t\t\t\t\tfor(k=1;k<=Hanoi[j].num;k++){\n\t\t\t\t\t\t\tprev[j].cups[k] = Hanoi[j].cups[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tHanoi[j].num = Move_left[j].num;\n\t\t\t\t\t\tfor(k=1;k<=Move_left[j].num;k++){\n\t\t\t\t\t\t\tHanoi[j].cups[k] = Move_left[j].cups[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tHanoiMove(Hanoi, prev, count_left);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(i<=2){\n\t\t\tfor(j=1;j<4;j++){\n\t\t\t\tMove_right[j].num = Hanoi[j].num;\n\t\t\t\tfor(k=1;k<=Hanoi[j].num;k++){\n\t\t\t\t\tMove_right[j].cups[k] = Hanoi[j].cups[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(prev==NULL){\n\t\t\t\tprev=(HANOI *)calloc(4,sizeof(HANOI));\n\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\tprev[j].cups=(int *)calloc(n,sizeof(int));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(Move_right[i].cups[Move_right[i].num]>Move_right[i+1].cups[Move_right[i+1].num]){\n\t\t\t\tMove_right[i+1].num++;\n\t\t\t\tMove_right[i+1].cups[Move_right[i+1].num]=Move_right[i].cups[Move_right[i].num];\n\t\t\t\tMove_right[i].cups[Move_right[i].num]=0;\n\t\t\t\tMove_right[i].num--;\n\t\t\t\tcount_right++;\n\n\t\t\t\tcheck=0;\n\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\tif(prev!=NULL && Move_right[j].num==prev[j].num){\n\t\t\t\t\t\tcheck+=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(prev==NULL || check<3){\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tprev[j].num = Hanoi[j].num;\n\t\t\t\t\t\tfor(k=1;k<=Hanoi[j].num;k++){\n\t\t\t\t\t\t\tprev[j].cups[k] = Hanoi[j].cups[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tHanoi[j].num = Move_right[j].num;\n\t\t\t\t\t\tfor(k=1;k<=Move_right[j].num;k++){\n\t\t\t\t\t\t\tHanoi[j].cups[k] = Move_right[j].cups[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tHanoiMove(Hanoi, prev, count_right);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n}\n\nint main(void){\n\tint i,j;\n\tHANOI *Hanoi, *prev;\n\n\tHanoi=(HANOI *)calloc(4,sizeof(HANOI));\n\n\twhile(scanf(\"%d %d\",&n,&m)!=EOF){\n\t\tif(n==0 && m==0) break;\n\t\tmin = INT_MAX;\n\t\tfor(i=0;i<4;i++) Hanoi[i].cups=(int *)calloc(n,sizeof(int));\n\t\tfor(i=1;i<4;i++){\n\t\t\tscanf(\"%d\",&Hanoi[i].num);\n\t\t\tfor(j=1;j<=Hanoi[i].num;j++){\n\t\t\t\tscanf(\"%d\",&Hanoi[i].cups[j]);\n\t\t\t}\n\t\t}\n\t\tprev = NULL;\n\t\tHanoiMove(Hanoi,prev,0);\n\t\tif(min>m) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",min);\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define S scanf(\"%d\",\nc[];j;main(n,m,i,k){for(;S&n),S&m),n;printf(\"%d\\n\",j>m?i:j)){for(i=3;j--?S&k),c[n-k]=i:(S&j),i--););for(i=n;i--;k+=c[i])j-=pow(3,i)*abs(k*2%4-c[i]);j=fmin(~j,pow(3,n)+j);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint N,M,p[15],n[15],i,j,t,q,R,s[16];\nint main()\n{\n\tfor(i=s[0]=1;i<16;i++)s[i]=s[i-1]*3;\n\tfor(;scanf(\"%d%d\",&N,&M),N;)\n\t{\n\t\tmemset(n,0,sizeof(n));\n\t\tfor(i=R=0;i<3;i++)\n\t\t\tfor(scanf(\"%d\",&t),j=0;j<t;p[N-q]=i,j++)\n\t\t\t\tscanf(\"%d\",&q);\n\t\tfor(i=N-1;i>=0;i--)\n\t\t{\n\t\t\tswitch(abs(p[i]-n[i]))\n\t\t\t{\n\t\t\tcase 0:break;\n\t\t\tcase 1:R+=s[i];for(j=0;j<i;j++)n[j]=2-n[i];break;\n\t\t\tcase 2:R+=2*s[i];for(j=0;j<i;j++)n[j]=2-n[i];break;\n\t\t\t}\n\t\t}\n\t\tR=R>s[N]-R?s[N]-R:R;\n\t\tprintf(\"%d\\n\",R>M?-1:R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <tuple>\n#include <map>\nusing namespace std;\n\nconst int NONE = -1;\ntypedef tuple<int, int, int> Tuple;\nmap<Tuple, int> S;\nTuple goal;\nint n, m;\n\nint get_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return 1 << i;\n    }\n    return 0;\n}\n\nint remove_last( int m ) {\n    for ( int i = n - 1; i >= 0; -- i ) {\n        if ( ( m & ( 1 << i ) ) == ( 1 << i ) ) return m ^ ( 1 << i );\n    }\n    return m;\n}\n\nint solve( int A, int B, int C, int turns ) {\n    Tuple tuple = make_tuple( A, B, C );\n    if ( S.count( tuple ) > 0 && turns >= S[tuple] ) return -1;\n    S[tuple] = turns;\n    if ( turns > m ) return -1;\n    if ( tuple == goal ) return turns;\n    if ( C != 0 ) {\n        int u = get_last(C);\n        int v = get_last(B);\n        if ( u > v ) {\n            int ret = solve( A, B | u, remove_last(C), turns + 1 );\n            if ( ret != NONE ) return ret;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n        S.clear();\n        int T[3] = { 0, 0, 0 };\n        for ( int i = 0; i < 3; ++ i ) {\n            int k;\n            cin >> k;\n            for ( int j = 0; j < k; ++ j ) {\n                int t;\n                cin >> t;\n                t--;\n                T[i] |= 1 << t;\n            }\n        }\n        goal = make_tuple( T[0], T[1], T[2] );\n        int ret1 = solve( (1<<n)-1, 0, 0, 0 );\n        int ret2 = solve( 0, 0, (1<<n)-1, 0 );\n        if ( ret1 == NONE && ret2 == NONE ) {\n            cout << -1 << endl;\n        } else if ( ret1 != NONE && ret2 != NONE ) {\n            cout << min( ret1, ret2 ) << endl;\n        } else if ( ret1 != NONE ) {\n            cout << ret1 << endl;\n        } else if ( ret2 != NONE ) {\n            cout << ret2 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main(void){\n\tint pow3[16], c[16];\n\tint n, m, i, j, k, d, x, y, p;\n\n\tpow3[0] = 1;\n\tfor(i = 1; i <= 15; ++i){\n\t\tpow3[i] = pow3[i-1] * 3;\n\t}\n\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\tfor(i = 0; i < 3; ++i){\n\t\t\tfor(scanf(\"%d\", &j); j > 0; --j){\n\t\t\t\tscanf(\"%d\", &k);\n\t\t\t\tc[n-k] = i;\n\t\t\t}\n\t\t}\n\n\t\tp = 0;\n\t\tx = 0;\n\t\tfor(i = n - 1; i >= 0; --i){\n\t\t\td = abs(p - c[i]);\n\t\t\tx += pow3[i] * d;\n\t\t\tif(d == 1){\n\t\t\t\tp = 2 - p;\n\t\t\t}\n\t\t}\n\n\t\ty = pow3[n] - 1 - x;\n\t\tif(x > y){\n\t\t\tx = k;\n\t\t}\n\t\tprintf(\"%d\\n\", x > m ? -1 : x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* constant */\n\n#define MAX_INT (1 << 30)\n#define MAX_N   (15)\n#define MAX_KEY (14348907)      /* 3 ** 15 */\n\n/* typedef */\n\ntypedef char cup_t[MAX_N];\n\n/* global variables */\n\nstatic int n, m;\n\nstatic int dists[MAX_KEY];\n\nstatic int qhead, qtail;\nstatic long q[MAX_KEY / 16];\n\n/* subroutines */\n\nlong expi(long d, int n) {\n  long e = 1;\n  while (n) {\n    if (n & 1) e *= d;\n    d *= d;\n    n >>= 1;\n  }\n  return e;\n}\n\nlong arr2key(cup_t cups) {\n  int i;\n  long key = 0;\n\n  for (i = n - 1; i >= 0; i--)\n    key = key * 3 + cups[i];\n\n  return key;\n}\n\nchar *key2arr(long key, cup_t cups) {\n  int i;\n\n  for (i = 0; i < n; i++) {\n    cups[i] = key % 3;\n    key /= 3;\n  }\n\n  return cups;\n}\n\n/* main */\n\nint main(int argc, char **argv) {\n  int cn, cp, d, dg, g0, g1, i, j, k, nnbr;\n  long key, st, u, v;\n  static int tops[3];\n  static long nbrs[4];\n  static cup_t cups, cups0, cups1;\n\n  for (;;) {\n    scanf(\"%d %d\", &n, &m);\n    if (n == 0 && m == 0) break;\n\n    for (k = 0; k < 3; k++) {\n      scanf(\"%d\", &cn);\n      for (i = 0; i < cn; i++) {\n        scanf(\"%d\", &j);\n        cups[j - 1] = k;\n      }\n    }\n\n    g0 = 0;\n    g1 = expi(3, n) - 1;\n\n    st = arr2key(cups);\n\n    for (i = g0; i <= g1; i++)\n      dists[i] = MAX_INT;\n    dists[st] = 0;\n\n    qhead = 0;\n    qtail = 1;\n    q[0] = st;\n\n    while (qtail > qhead) {\n      u = q[qhead++];\n\n      if (u == g0 || u == g1 || dists[u] >= m) break;\n\n      tops[0] = tops[1] = tops[2] = -1;\n      key = u;\n\n      for (i = 0; i < n; i++) {\n        cp = key % 3;\n        cups0[i] = cp;\n        key /= 3;\n        tops[cp] = i;\n      }\n\n      nnbr = 0;\n      if (tops[0] > tops[1]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[0]] = 1;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n      if (tops[1] > tops[0]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[1]] = 0;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n      if (tops[1] > tops[2]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[1]] = 2;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n      if (tops[2] > tops[1]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[2]] = 1;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n\n      d = dists[u] + 1;\n\n      for (i = 0; i < nnbr; i++) {\n        v = nbrs[i];\n        if (dists[v] > d) {\n          dists[v] = d;\n          q[qtail++] = v;\n        }\n      }\n    }\n\n    dg = (dists[g0] < dists[g1]) ? dists[g0] : dists[g1];\n\n    printf(\"%d\\n\",  dg < MAX_INT ? dg : -1);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\ntypedef struct {\n    int time;\n    int tower[3][15];\n    int t[3];\n} HANOI;\n\nHANOI queue[100000];\nint head, tail;\n\nvoid enq(HANOI t)\n{\n\tqueue[tail % 100000] = t;\n\ttail++;\n}\n\nvoid deq(HANOI *t)\n{\n\t*t = queue[head % 100000];\n\thead++;\n}\n\nchar v[50000000];\n\nvoid move(HANOI temp, int from, int to)\n{\n    int num;\n    int i, j;\n    HANOI first;\n    if ((temp.t[from] > 0 && temp.t[to] > 0 && temp.tower[from][temp.t[from] - 1] > temp.tower[to][temp.t[to] - 1]) ||temp.t[from] > 0 && temp.t[to] == 0){\n        first = temp;\n        first.tower[to][temp.t[to]] = first.tower[from][temp.t[from] - 1];\n        first.tower[from][temp.t[from] - 1] = 0;\n        first.t[from]--;\n        first.t[to]++;\n        first.time++;\n        num = 0;\n        for (i = 0; i < 3; i++){\n            for (j = 0; j < first.t[i]; j++){\n                num += i * pow(3, first.tower[i][j]);\n            }\n        }\n        if (!v[num]){\n            v[num] = 1;\n            enq(first);\n        }\n    }\n}\n\nint order(int no, int tower[][15], int n)\n{\n    int i;\n    \n    for (i = 0; i < n; i++){\n        if (tower[no][i] != i + 1){\n            return (0);\n        }\n    }\n    return (1);\n}\n\nint main(void)\n{\n    int n, m;\n    HANOI start, temp;\n    int i, j;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &m);\n        \n        if (n + m == 0){\n            break;\n        }\n        memset(start.tower, 0, sizeof(start.tower));\n        for (i = 0; i < 3; i++){\n            scanf(\"%d\", &start.t[i]);\n            for (j = 0; j < start.t[i]; j++){\n                scanf(\"%d\", &start.tower[i][j]);\n            }\n        }\n        \n        memset(v, 0, sizeof(v));\n        \n        start.time = 0;\n        head = tail = 0;\n        enq(start);\n        \n        while (head != tail){\n            deq(&temp);\n            \n            if (order(0, temp.tower, n) || order(2, temp.tower, n)){\n                printf(\"%d\\n\", temp.time);\n                break;\n            }\n            \n            if (temp.time > m){\n                printf(\"-1\\n\");\n                break;\n            }\n            \n            move(temp, 0, 1);\n            move(temp, 1, 0);\n            move(temp, 1, 2);\n            move(temp, 2, 1);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,c[];main(n){for(;scanf(\"%d%d\",&n,&m)*n;printf(\"%d\\n\",j>m?i:j)){for(k=-3;j=k++;)for(scanf(\"%d\",&i);i--;c[n-j]=k)scanf(\"%d\",&j);for(i=n;i--;k-=c[i])j+=pow(3,i)*abs(k*2%4+c[i]);j=fmin(j,pow(3,n)+~j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NMAX 15\n#define MMAX 15000000\n\nconst int cup_move[4][2] = {{0,1},{1,0},{1,2},{2,1}};\nint stack[MMAX][3];\n\nint move(int temp[3],int a,int amin, int amax)\n{\n\tint i,l,m;\n\tint flag;\n\n\tfor(m=0;m<4;m++){\n\t\tif(temp[cup_move[m][0]]>temp[cup_move[m][1]]){\n\t\t\tl= 1<<NMAX;\n\t\t\twhile((l & temp[cup_move[m][0]]) == 0) l>>=1;\n\t\t\ttemp[cup_move[m][0]] -= l;\n\t\t\ttemp[cup_move[m][1]] += l;\n\t\t\ta++;\n\t\t\tstack[a][0]=temp[0];\n\t\t\tstack[a][1]=temp[1];\n\t\t\tstack[a][2]=temp[2];\n\n\t\t\tif(a>amax){\n\t\t\t\treturn a--;\n\t\t\t}\n\t\t\tif(temp[1]==0 && (temp[0]==0 || temp[2]==0)){\n\t\t\t\tif(amin>a) amin=a;\n\t\t\t\treturn a--;\n\t\t\t}\n\n\t\t\tflag = 0;\n\t\t\tfor(i=a-1;i>=0;i--){\n\t\t\t\tif(stack[i][0]==temp[0] && stack[i][1]==temp[1] && stack[i][2]==temp[2]){\n\t\t\t\t\ta--;\n\t\t\t\t\ttemp[0]=stack[a][0];\n\t\t\t\t\ttemp[1]=stack[a][1];\n\t\t\t\t\ttemp[2]=stack[a][2];\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag) amin = move(temp,a,amin,amax);\n\t\t}\n\t}\n\treturn amin;\n}\n\nint main(void)\n{\n\tint n,m;\n\tint c_max,c;\n\tint i,j;\n\tint a;\n\tint cup[3];\n\n\twhile(scanf(\"%d%d\", &n, &m) && n+m){\n\t\tfor(i=0;i<3;i++){\n\t\t\tcup[i] = 0;\n\t\t\tscanf(\"%d\", &c_max);\n\t\t\tfor(j=0;j<c_max;j++){\n\t\t\t\tscanf(\"%d\", &c);\n\t\t\t\tcup[i] |= 1 << (c-1);\n\t\t\t}\n\t\t}\n\n\t\tif(cup[1]==0 && (cup[0]==0 || cup[2]==0)){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(i=0;i<3;i++){\n\t\t\tstack[0][i]=cup[i];\n\t\t}\n\t\ta = move(cup,0,m,m);\n\n\t\tif(a>m){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"%d\\n\",a);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "c[];main(n,m,i,j,k,f){for(;scanf(\"%d%d\",&n,&m)*n;printf(f,j>m?i:j)){for(i=3;i--;)for(scanf(f=\"%d\\n\",&j);j--;c[n-k]=i)scanf(f,&k);for(i=n;i--;k+=c[i])j-=pow(3,i)*abs(k*2%4-c[i]);j=fmin(~j,pow(3,n)+j);}}"
  },
  {
    "language": "C",
    "code": "#define S scanf(\"%d\",\nc[];main(n,m,i,j,k){for(;S&n),S&m),n;printf(\"%d\\n\",j>m?i:j)){for(i=3;i--;)for(S&j);j--;c[n-k]=i)S&k);for(i=n;i--;k+=c[i])j-=pow(3,i)*abs(k*2%4-c[i]);j=fmin(~j,pow(3,n)+j);}}"
  },
  {
    "language": "C",
    "code": "c[];main(n,m,i,j,k){for(;scanf(\"%d%d\",&n,&m)*n;printf(\"%d\\n\",j>m?i:j)){for(i=3;i--;)for(scanf(\"%d\",&j);j--;c[n-k]=i)scanf(\"%d\",&k);for(i=n;i--;k+=c[i])j-=pow(3,i)*abs(k*2%4-c[i]);j=fmin(~j,pow(3,n)+j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define dif(a,b) (((a)>(b))?(a)-(b):(b)-(a))\nint main(void){\n\tint n,m,i,j,k,t[16],c[16],p,d;\n\tfor( t[0] = n = i = 1; i < 16; i++ )t[i] = n *= 3;\n\tfor(;scanf(\"%d%d\",&n,&m),n|m;){\n\t\tfor( k = 0; k < 3; k++ )\n\t\t\tfor( scanf(\"%d\",&i); i--; c[j] = k )scanf(\"%d\",&j);\n\t\tp = j = 0;\n\t\tfor( k = 1; k <= n; k++ ){\n\t\t\td = dif( p, c[k] );\n\t\t\tj += t[n-k] * d;\n\t\t\tp = d * 2 + p & 3;\n\t\t}\n\t\tk = t[n] - 1 - j;\n\t\tif( j > k ) j = k;\n\t\tprintf(\"%d\\n\", j > m ? -1 : j );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,c[],p;main(n){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",j>m?k:j)){for(k=3;k--;)for(scanf(\"%d\",&i);j=i--;c[n-j]=k)scanf(\"%d\",&j);for(i=n;i--;p+=c[i]*2)j+=pow(3,i)*abs(p%4-c[i]);j=fmin(j,pow(3,n)+~j);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\n#define LEFT 0\n#define RIGHT 1\n#define Q_SIZE 150000\n\ntypedef struct{\n\tchar num;\n\tchar cups[15];\n}HANOI;\n\ntypedef struct{\n\tHANOI top[4];\n\tHANOI priv[4];\n\tint count;\n}QUEUE;\n\nint n,m;\nint min = INT_MAX;\n\nHANOI Hanoi[4];\nHANOI Move_left[4], Move_right[4];\n\nint q_top, q_btm;\nQUEUE que[Q_SIZE];\n\n\nvoid HanoiInitialize(HANOI *Hni){\n\tint i,j;\n\t\t\n\tfor(i=0;i<4;i++){\n\t\tHni[i].num=0;\n\t\tfor(j=0;j<15;j++) Hanoi[i].cups[j]=0;\n\t}\n\n\treturn;\n}\n\nvoid MoveCup(int pos, int which){\n\tif(which==LEFT){\n\t\tMove_left[pos-1].num++;\n\t\tMove_left[pos-1].cups[Move_left[pos-1].num]=Move_left[pos].cups[Move_left[pos].num];\n\t\tMove_left[pos].cups[Move_left[pos].num]=0;\n\t\tMove_left[pos].num--;\n\t}else if(which==RIGHT){\n\t\tMove_right[pos+1].num++;\n\t\tMove_right[pos+1].cups[Move_right[pos+1].num]=Move_right[pos].cups[Move_right[pos].num];\n\t\tMove_right[pos].cups[Move_right[pos].num]=0;\n\t\tMove_right[pos].num--;\n\t}\n\treturn;\n}\n\n\nvoid SetQueue(HANOI *insert, int top, int bottom, int count){\n\tint i,j;\n\tfor(i=1;i<4;i++){\n\t\tque[bottom].priv[i].num = que[top].top[i].num;\n\t\tfor(j=1;j<=que[top].top[i].num;j++){\n\t\t\tque[bottom].priv[i].cups[j] = que[top].top[i].cups[j];\n\t\t}\n\t}\n\tfor(i=1;i<4;i++){\n\t\tque[bottom].top[i].num = insert[i].num;\n\t\tfor(j=1;j<=insert[i].num;j++){\n\t\t\tque[bottom].top[i].cups[j] = insert[i].cups[j];\n\t\t}\n\t}\n\tque[bottom].count=count;\n\treturn ;\n}\n\nvoid HanoiMove(void){\n\tint i,j,k;\n\tint count_left, count_right;\n\n\tHanoiInitialize(Move_left);\n\tHanoiInitialize(Move_right);\n\n\tfor(;;){\n\t\tfor(i=1;i<4;i++){\n\t\t\tMove_left[i].num = que[q_top].top[i].num;\n\t\t\tMove_right[i].num = que[q_top].top[i].num;\n\n\t\t\tfor(j=1;j<=que[q_top].top[i].num;j++){\n\t\t\t\tMove_left[i].cups[j] = que[q_top].top[i].cups[j];\n\t\t\t\tMove_right[i].cups[j] = que[q_top].top[i].cups[j];\n\t\t\t}\n\t\t}\n\n\t\tfor(i=1;i<4;i++){\n\t\t\tif(i==2) continue;\n\t\t\telse if(Move_left[i].num==n && que[q_top].count<min){\n\t\t\t\tmin = que[q_top].count;\n\t\t\t}\n\t\t}\n\t\tif(que[q_top].count>min){\n\t\t\tq_top++;\n\t\t\tif(q_top==q_btm) break;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcount_left=count_right=que[q_top].count;\n\n\t\tfor(i=1;i<4;i++){\n\t\t\tif(que[q_top].top[i].num==0) continue;\n\t\t\tif(i>=2){\n\n\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\tMove_left[j].num = que[q_top].top[j].num;\n\t\t\t\t\tfor(k=1;k<=que[q_top].top[j].num;k++){\n\t\t\t\t\t\tMove_left[j].cups[k] = que[q_top].top[j].cups[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(Move_left[i].cups[Move_left[i].num]>Move_left[i-1].cups[Move_left[i-1].num]){\n\t\t\t\t\tMoveCup(i,LEFT);\n\t\t\t\t\tcount_left=que[q_top].count+1;\n\n\t\t\t\t\tif(count_left>m) continue;\n\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tif(Move_left[j].num!=que[q_top].priv[j].num){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j<4){\n\t\t\t\t\t\tq_btm+=1;\n\t\t\t\t\t\tif(q_btm>=Q_SIZE) q_btm=0;\n\t\t\t\t\t\tSetQueue(Move_left, q_top, q_btm, count_left);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i<=2){\n\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\tMove_right[j].num = que[q_top].top[j].num;\n\t\t\t\t\tfor(k=1;k<=que[q_top].top[j].num;k++){\n\t\t\t\t\t\tMove_right[j].cups[k] = que[q_top].top[j].cups[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(Move_right[i].cups[Move_right[i].num]>Move_right[i+1].cups[Move_right[i+1].num]){\n\t\t\t\t\tMoveCup(i,RIGHT);\n\t\t\t\t\tcount_right=que[q_top].count+1;\n\t\t\t\t\tif(count_right>m) continue;\n\t\t\t\t\t\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tif(Move_right[j].num!=que[q_top].priv[j].num){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j<4){\n\t\t\t\t\t\tq_btm+=1;\n\t\t\t\t\t\tif(q_btm>=Q_SIZE) q_btm=0;\n\t\t\t\t\t\tSetQueue(Move_right, q_top, q_btm, count_right);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq_top++;\n\t\tif(q_top>=Q_SIZE) q_top=0;\n\t\tif(q_top==q_btm) break;\n\n\t}\n\treturn;\n}\n\nint main(void){\n\tint i,j;\n\n\twhile(scanf(\"%d %d\",&n,&m)!=EOF){\n\t\tif(n==0 && m==0) break;\n\t\tmin = INT_MAX;\n\t\tq_top=q_btm=0;\n\t\tfor(i=1;i<4;i++){\n\t\t\tscanf(\"%d\",&Hanoi[i].num);\n\t\t\tfor(j=1;j<=Hanoi[i].num;j++){\n\t\t\t\tscanf(\"%d\",&Hanoi[i].cups[j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<4;i++){\n\t\t\tque[q_top].top[i].num = Hanoi[i].num;\n\t\t\tque[q_top].priv[i].num = Hanoi[i].num;\n\t\t\tfor(j=1;j<=Hanoi[i].num;j++){\n\t\t\t\tque[q_top].top[i].cups[j] = Hanoi[i].cups[j];\n\t\t\t\tque[q_top].priv[i].cups[j] = Hanoi[i].cups[j];\n\t\t\t}\n\t\t}\n\t\tHanoiMove();\n\t\tif(min>m) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",min);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* constant */\n\n#define MAX_INT (1 << 30)\n#define MAX_N   (15)\n#define MAX_KEY (14348907)      /* 3 ** 15 */\n\n/* typedef */\n\ntypedef char cup_t[MAX_N];\n\n/* global variables */\n\nstatic int n, m;\n\nstatic int dists[MAX_KEY];\n\nstatic int qhead, qtail;\nstatic long q[MAX_KEY];\n\n/* subroutines */\n\nlong expi(long d, int n) {\n  long e = 1;\n  while (n) {\n    if (n & 1) e *= d;\n    d *= d;\n    n >>= 1;\n  }\n  return e;\n}\n\nlong arr2key(cup_t cups) {\n  int i;\n  long key = 0;\n\n  for (i = n - 1; i >= 0; i--)\n    key = key * 3 + cups[i];\n\n  return key;\n}\n\nchar *key2arr(long key, cup_t cups) {\n  int i;\n\n  for (i = 0; i < n; i++) {\n    cups[i] = key % 3;\n    key /= 3;\n  }\n\n  return cups;\n}\n\n/* main */\n\nint main(int argc, char **argv) {\n  int cn, cp, d, dg, g0, g1, i, j, k, nnbr;\n  long key, st, u, v;\n  static int tops[3];\n  static long nbrs[4];\n  static cup_t cups, cups0, cups1;\n\n  for (;;) {\n    scanf(\"%d %d\", &n, &m);\n    if (n == 0 && m == 0) break;\n\n    for (k = 0; k < 3; k++) {\n      scanf(\"%d\", &cn);\n      for (i = 0; i < cn; i++) {\n        scanf(\"%d\", &j);\n        cups[j - 1] = k;\n      }\n    }\n\n    g0 = 0;\n    g1 = expi(3, n) - 1;\n\n    st = arr2key(cups);\n\n    for (i = g0; i <= g1; i++)\n      dists[i] = MAX_INT;\n    dists[st] = 0;\n\n    qhead = 0;\n    qtail = 1;\n    q[0] = st;\n\n    while (qtail > qhead) {\n      u = q[qhead++];\n\n      if (u == g0 || u == g1 || dists[u] >= m) break;\n\n      tops[0] = tops[1] = tops[2] = -1;\n      key = u;\n\n      for (i = 0; i < n; i++) {\n        cp = key % 3;\n        cups0[i] = cp;\n        key /= 3;\n        tops[cp] = i;\n      }\n\n      nnbr = 0;\n      if (tops[0] > tops[1]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[0]] = 1;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n      if (tops[1] > tops[0]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[1]] = 0;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n      if (tops[1] > tops[2]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[1]] = 2;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n      if (tops[2] > tops[1]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[2]] = 1;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n\n      d = dists[u] + 1;\n\n      for (i = 0; i < nnbr; i++) {\n        v = nbrs[i];\n        if (dists[v] > d) {\n          dists[v] = d;\n          q[qtail++] = v;\n        }\n      }\n    }\n\n    dg = (dists[g0] < dists[g1]) ? dists[g0] : dists[g1];\n\n    printf(\"%d\\n\",  dg < MAX_INT ? dg : -1);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,t[16],c[16],p,d;\nmain(n){\n\tfor(*t=1;++i<16;)t[i]=n*=3;\n\tfor(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",j>m?-1:j)){\n\t\tfor(k=3;k--;)\n\t\t\tfor(scanf(\"%d\",&i);i--;c[j]=k)scanf(\"%d\",&j);\n\t\tfor(j=k=0;k++<n;p=i%2*2+p&3)\n\t\t\tj+=t[n-k]*abs(i=p-c[k]);\n\t\tj=fmin(j,t[n]+~j);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NMAX 15\n#define MMAX 15000000\n\nconst int cup_move[4][2] = {{0,1},{1,0},{1,2},{2,1}};\nint stack[MMAX][3];\n\nint move(int temp[3],int a,int amin, int amax)\n{\n\tint i,l,m;\n\tint flag;\n\n\tfor(m=0;m<4;m++){\n\t\tif(temp[cup_move[m][0]]>temp[cup_move[m][1]]){\n\t\t\tl = 1;\n\t\t\twhile((l & temp[cup_move[m][0]]) == 0) l<<=1;\n\t\t\ttemp[cup_move[m][0]] -= l;\n\t\t\ttemp[cup_move[m][1]] += l;\n\t\t\ta++;\n\t\t\tstack[a][0]=temp[0];\n\t\t\tstack[a][1]=temp[1];\n\t\t\tstack[a][2]=temp[2];\n\n\t\t\tif(a>amax){\n\t\t\t\treturn a--;\n\t\t\t}\n\t\t\tif(temp[1]==0 && (temp[0]==0 || temp[2]==0)){\n\t\t\t\tif(amin>a) amin=a;\n\t\t\t\treturn a--;\n\t\t\t}\n\n\t\t\tflag = 0;\n\t\t\tfor(i=a-1;i>=0;i--){\n\t\t\t\tif(stack[i][0]==temp[0] && stack[i][1]==temp[1] && stack[i][2]==temp[2]){\n\t\t\t\t\ta--;\n\t\t\t\t\ttemp[0]=stack[a][0];\n\t\t\t\t\ttemp[1]=stack[a][1];\n\t\t\t\t\ttemp[2]=stack[a][2];\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag) amin = move(temp,a,amin,amax);\n\t\t}\n\t}\n\treturn amin;\n}\n\nint main(void)\n{\n\tint n,m;\n\tint c_max,c;\n\tint i,j;\n\tint a;\n\tint cup[3];\n\n\twhile(scanf(\"%d%d\", &n, &m) && n+m){\n\t\tfor(i=0;i<3;i++){\n\t\t\tcup[i] = 0;\n\t\t\tscanf(\"%d\", &c_max);\n\t\t\tfor(j=0;j<c_max;j++){\n\t\t\t\tscanf(\"%d\", &c);\n\t\t\t\tcup[i] |= 1 << (c-1);\n\t\t\t}\n\t\t}\n\n\t\tif(cup[1]==0 && (cup[0]==0 || cup[2]==0)){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(i=0;i<3;i++){\n\t\t\tstack[0][i]=cup[i];\n\t\t}\n\t\ta = move(cup,0,m,m);\n\n\t\tif(a>m){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"%d\\n\",a);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\ntypedef struct {\n    int time;\n    int tower[3][15];\n    int t[3];\n} HANOI;\n\nHANOI queue[100000];\nint head, tail;\n\nvoid enq(HANOI t)\n{\n\tqueue[tail % 100000] = t;\n\ttail++;\n}\n\nvoid deq(HANOI *t)\n{\n\t*t = queue[head % 100000];\n\thead++;\n}\n\nchar v[50000000];\n\nint move(HANOI temp, int from, int to, int n)\n{\n    int num;\n    int i, j;\n    HANOI first;\n    if ((temp.t[from] > 0 && temp.t[to] > 0 && temp.tower[from][temp.t[from] - 1] > temp.tower[to][temp.t[to] - 1]) ||temp.t[from] > 0 && temp.t[to] == 0){\n        first = temp;\n        first.tower[to][temp.t[to]] = first.tower[from][temp.t[from] - 1];\n        first.tower[from][temp.t[from] - 1] = 0;\n        first.t[from]--;\n        first.t[to]++;\n        first.time++;\n        num = 0;\n        for (i = 0; i < 3; i++){\n            for (j = 0; j < first.t[i]; j++){\n                num += i * pow(3, first.tower[i][j] - 1);\n            }\n        }\n        if (num == 0 || num == pow(3, n) - 1){\n            printf(\"%d\\n\", first.time);\n            return (1);\n        }\n        if (!v[num]){\n            v[num] = 1;\n            enq(first);\n        }\n    }\n    return (0);\n}\n\nint order(int no, int tower[][15], int n)\n{\n    int i;\n    \n    for (i = 0; i < n; i++){\n        if (tower[no][i] != i + 1){\n            return (0);\n        }\n    }\n    return (1);\n}\n\nint main(void)\n{\n    int n, m;\n    HANOI start, temp;\n    int i, j;\n    \n    while (1){\n        scanf(\"%d%d\", &n, &m);\n        \n        if (n + m == 0){\n            break;\n        }\n        memset(start.tower, 0, sizeof(start.tower));\n        for (i = 0; i < 3; i++){\n            scanf(\"%d\", &start.t[i]);\n            for (j = 0; j < start.t[i]; j++){\n                scanf(\"%d\", &start.tower[i][j]);\n            }\n        }\n        \n        memset(v, 0, sizeof(v));\n        \n        start.time = 0;\n        head = tail = 0;\n        enq(start);\n        \n        while (head != tail){\n            deq(&temp);\n            \n            if (temp.time > m){\n                printf(\"-1\\n\");\n                break;\n            }\n            \n            if (move(temp, 0, 1, n)){\n                break;\n            }\n            if (move(temp, 1, 0, n)){\n                break;\n            }\n            if (move(temp, 1, 2, n)){\n                break;\n            }\n            if (move(temp, 2, 1, n)){\n                break;\n            }\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstruct cup{\n    int num;\n    int item[15];\n}\n\nint put(struct cup *old,struct cup *new) {\n    if(old.item[old.num-1]<new.item[new.num-1]){\n        new.item[new.num]=old.item[old.num-1];\n        new.num++;\n        old.num--;\n        return TRUE;\n    }\n    return FALSE;\n}\n\n\nint main(int argc, char const *argv[]) {\n  int n,cn,i;\n  struct cup a[3];\n  long m,j,count,min;\n  scanf(\"%d %ld\\n\",&n,&m);\n  while(n>0 && m>0){\n      for(j=0;j<3;i++){\n          scanf(\"%d\",&a[j].num);\n          for(i=0;i<a[j].num;i++){\n              scanf(\"%d\",&a[j].item[i]);\n          }\n      }\n      \n      \n      scanf(\"%d %ld\\n\",&n,&m);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N_MAX 15\n#define M_MAX 15000000\n\nint memo[N_MAX][3][3],ismemoized[N_MAX][3][3];\n\nint main(){\n  int card[15],n,m,i,j,from,to,rest,cnt,ans;\n\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    ans = m+1;\n\n    if(n==0&&m==0) return 0;\n\n    for(i=0; i<3; i++){\n      int t1,t2;\n      scanf(\"%d\",&t1);\n      for(j=0; j<t1; j++){\n\tscanf(\"%d\",&t2);\n\tcard[t2-1] = i;\n      }\n    }\n\n    for(i=0; i<=2; i+=2){\n      from = i; cnt = 0;\n      for(j=1; j<=n; j++){\n\tto = card[j-1];\n\trest = 3-(from+to);\n\n\tswitch(abs(from-to)){\n\tcase 1:\n\t  cnt += move(n-j,from,rest) + 1;\n\t  from = rest;\n\t  break;\n\tcase 2:\n\t  cnt += move(n-j,from,to) + move(n-j,to,from) + 2;\n\t  break;\n\t}\n      }\n      ans = (ans>cnt)?cnt:ans;\n    }\n\n\n  }\n}\n\nint move(num,from,to){\n  int rest = 3-(from+to),ans;\n\n  if(ismemoized[num][from][to])\n    return memo[num][from][to];\n\n  if(num==0)\n    ans = 0;\n  else if(num==1)\n    ans = abs(from-to);\n  else\n    switch(abs(from-to)){\n    case 0:\n      ans = 0;\n      break;\n    case 1:\n      ans = move(num-1,from,rest)+move(num-1,rest,to)+1;\n      break;\n    case 2:\n      ans = move(num,from,rest)+move(num,rest,to);\n      break;\n    }\n\n  ans = (ans<=M_MAX)?ans:(M_MAX+1);\n\n  ismemoized[num][from][to] = 1;\n  memo[num][from][to] = ans;\n  return ans;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\n#define LEFT 0\n#define RIGHT 1\n#define QUEUE_SIZE 1500000\n\ntypedef struct{\n\tint num;\n\tint cups[15];\n}HANOI;\n\ntypedef struct{\n\tHANOI current[4];\n\tHANOI privious[4];\n\tint count;\n}QUEUE;\n\nint n,m;\nint min = INT_MAX;\n\nHANOI Hanoi[4], Prev[4];\nHANOI Move_left[4], Move_right[4];\n\nint queue_top, queue_bottom;\nQUEUE queue[QUEUE_SIZE];\n\n\nvoid Initialize(void){\n\tint i,j;\n\n\tmin = INT_MAX;\n\tqueue_top=queue_bottom=0;\n\tfor(i=0;i<4;i++){\n\t\tHanoi[i].num=0;\n\t\tfor(j=0;j<15;j++) Hanoi[i].cups[j]=0;\n\t}\n\tfor(i=0;i<4;i++){\n\t\tPrev[i].num=0;\n\t\tfor(j=0;j<15;j++) Prev[i].cups[j]=0;\n\t}\n\n\treturn;\n}\n\nvoid MoveCup(int pos, int which){\n\tif(which==LEFT){\n\t\tMove_left[pos-1].num++;\n\t\tMove_left[pos-1].cups[Move_left[pos-1].num]=Move_left[pos].cups[Move_left[pos].num];\n\t\tMove_left[pos].cups[Move_left[pos].num]=0;\n\t\tMove_left[pos].num--;\n\t}else if(which==RIGHT){\n\t\tMove_right[pos+1].num++;\n\t\tMove_right[pos+1].cups[Move_right[pos+1].num]=Move_right[pos].cups[Move_right[pos].num];\n\t\tMove_right[pos].cups[Move_right[pos].num]=0;\n\t\tMove_right[pos].num--;\n\t}\n\treturn;\n}\n\n\nvoid SetQueue(HANOI *insert, int top, int bottom, int count){\n\tint i,j;\n\tfor(i=1;i<4;i++){\n\t\tqueue[bottom].privious[i].num = queue[top].current[i].num;\n\t\tfor(j=1;j<=queue[top].current[i].num;j++){\n\t\t\tqueue[bottom].privious[i].cups[j] = queue[top].current[i].cups[j];\n\t\t}\n\t}\n\tfor(i=1;i<4;i++){\n\t\tqueue[bottom].current[i].num = insert[i].num;\n\t\tfor(j=1;j<=insert[i].num;j++){\n\t\t\tqueue[bottom].current[i].cups[j] = insert[i].cups[j];\n\t\t}\n\t}\n\tqueue[bottom].count=count;\n\treturn ;\n}\n\nvoid HanoiMove(HANOI *hanoi, HANOI *prev, int count){\n\tint i,j,k;\n\tint count_left, count_right;\n\n\tfor(i=0;i<4;i++){\n\t\tMove_left[i].num=0;\n\t\tfor(j=0;j<15;j++) Move_left[i].cups[j]=0;\n\t}\n\tfor(i=0;i<4;i++){\n\t\tMove_right[i].num=0;\n\t\tfor(j=0;j<15;j++) Move_right[i].cups[j]=0;\n\t}\n\n\tfor(;;){\n\t\tfor(i=1;i<4;i++){\n\t\t\tMove_left[i].num = queue[queue_top].current[i].num;\n\t\t\tMove_right[i].num = queue[queue_top].current[i].num;\n\n\t\t\tfor(j=1;j<=queue[queue_top].current[i].num;j++){\n\t\t\t\tMove_left[i].cups[j] = queue[queue_top].current[i].cups[j];\n\t\t\t\tMove_right[i].cups[j] = queue[queue_top].current[i].cups[j];\n\t\t\t}\n\t\t}\n\n\t\tfor(i=1;i<4;i++){\n\t\t\tif(i==2) continue;\n\t\t\telse if(Move_left[i].num==n && queue[queue_top].count<min){\n\t\t\t\tmin = queue[queue_top].count;\n\t\t\t}\n\t\t}\n\t\tif(queue[queue_top].count>min){\n\t\t\tqueue_top++;\n\t\t\tif(queue_top==queue_bottom) break;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcount_left=count_right=queue[queue_top].count;\n\n\t\tfor(i=1;i<4;i++){\n\t\t\tif(queue[queue_top].current[i].num==0) continue;\n\t\t\tif(i>=2){\n\n\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\tMove_left[j].num = queue[queue_top].current[j].num;\n\t\t\t\t\tfor(k=1;k<=queue[queue_top].current[j].num;k++){\n\t\t\t\t\t\tMove_left[j].cups[k] = queue[queue_top].current[j].cups[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(Move_left[i].cups[Move_left[i].num]>Move_left[i-1].cups[Move_left[i-1].num]){\n\t\t\t\t\tMoveCup(i,LEFT);\n\t\t\t\t\tcount_left=queue[queue_top].count+1;\n\n\t\t\t\t\tif(count_left>m) continue;\n\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tif(Move_left[j].num!=queue[queue_top].privious[j].num){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j<4){\n\t\t\t\t\t\tqueue_bottom+=1;\n\t\t\t\t\t\tif(queue_bottom>=QUEUE_SIZE) queue_bottom=0;\n\t\t\t\t\t\tSetQueue(Move_left, queue_top, queue_bottom, count_left);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i<=2){\n\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\tMove_right[j].num = queue[queue_top].current[j].num;\n\t\t\t\t\tfor(k=1;k<=queue[queue_top].current[j].num;k++){\n\t\t\t\t\t\tMove_right[j].cups[k] = queue[queue_top].current[j].cups[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(Move_right[i].cups[Move_right[i].num]>Move_right[i+1].cups[Move_right[i+1].num]){\n\t\t\t\t\tMoveCup(i,RIGHT);\n\t\t\t\t\tcount_right=queue[queue_top].count+1;\n\t\t\t\t\tif(count_right>m) continue;\n\t\t\t\t\t\n\t\t\t\t\tfor(j=1;j<4;j++){\n\t\t\t\t\t\tif(Move_right[j].num!=queue[queue_top].privious[j].num){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j<4){\n\t\t\t\t\t\tqueue_bottom+=1;\n\t\t\t\t\t\tif(queue_bottom>=QUEUE_SIZE) queue_bottom=0;\n\t\t\t\t\t\tSetQueue(Move_right, queue_top, queue_bottom, count_right);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue_top++;\n\t\tif(queue_top>=QUEUE_SIZE) queue_top=0;\n\t\tif(queue_top==queue_bottom) break;\n\n\t}\n\treturn;\n}\n\nint main(void){\n\tint i,j;\n\n\twhile(scanf(\"%d %d\",&n,&m)!=EOF){\n\t\tif(n==0 && m==0) break;\n\t\tInitialize();\n\t\tfor(i=1;i<4;i++){\n\t\t\tscanf(\"%d\",&Hanoi[i].num);\n\t\t\tfor(j=1;j<=Hanoi[i].num;j++){\n\t\t\t\tscanf(\"%d\",&Hanoi[i].cups[j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<4;i++){\n\t\t\tqueue[queue_top].current[i].num = Hanoi[i].num;\n\t\t\tqueue[queue_top].privious[i].num = Hanoi[i].num;\n\t\t\tfor(j=1;j<=Hanoi[i].num;j++){\n\t\t\t\tqueue[queue_top].current[i].cups[j] = Hanoi[i].cups[j];\n\t\t\t\tqueue[queue_top].privious[i].cups[j] = Hanoi[i].cups[j];\n\t\t\t}\n\t\t}\n\t\tHanoiMove(Hanoi,Prev,0);\n\t\tif(min>m) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",min);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define BUF_SIZE 60\n\nvoid get_int2(char *line, int size, int *a1, int *a2) {\n  if(!fgets(line, size, stdin)) return;\n  sscanf(line, \"%d %d\", a1, a2);\n}\n\nstruct state {\n  int a;\n  int b;\n  int c;\n  int cnt;\n};\n\n#define QUEUE_MAX 15000000\n\nstatic struct state queue[QUEUE_MAX];\nstatic int start = 0;\nstatic int end = 0;\n\nvoid enqueue(struct state s) {\n  queue[start++] = s;\n}\n\nstruct state dequeue(void) {\n  return queue[end++];\n}\n\nint is_empty(void) {\n  return start == end;\n}\n\n#define HTABLE_SIZE 2097152\n#define HTABLE_MASK HTABLE_SIZE-1\n#define ELEM_POOL_SIZE QUEUE_MAX\n\nstruct list {\n  struct list *next;\n  unsigned int num;\n};\nstatic struct list htable[HTABLE_SIZE];\nstatic struct list pool[ELEM_POOL_SIZE];\nstatic int pos = 0;\n\nvoid initialize(void) {\n  start = end = 0;\n  int i;\n  pos = 0;\n  for(i = 0; i < HTABLE_SIZE; i++) {\n    struct list *head = &htable[i];\n    head->next = head;\n  }\n}\n\nint get_key(unsigned int num) {\n  return num&HTABLE_MASK;\n}\n\n\nvoid create_htable(void) {\n  int i;\n  for(i = 0; i < HTABLE_SIZE; i++) {\n    htable[i].next = &htable[i];\n  }\n  return;\n}\n\nunsigned int get_unique_id(struct state s) {\n  return (unsigned int)(s.a << 16) + s.b;\n}\n\nint find_state(struct state s) {\n  unsigned int num = get_unique_id(s);\n  struct list *head = &htable[get_key(num)];\n  struct list *tmp;\n  for(tmp = head->next; tmp != head; tmp = tmp->next) {\n    if(tmp->num == num) return 1;\n  }\n  return 0;\n}\n\n\nvoid keep_track(struct state s) {\n  unsigned int num = get_unique_id(s);\n  struct list *head = &htable[get_key(num)];\n  struct list *elem = &pool[pos++];\n  elem->next = head->next;\n  elem->num = num;\n  head->next = elem;\n  return;\n}\n\nint get_max(int num) {\n  if(!num) return 0;\n  return 31 - __builtin_clz(num);\n  // int i;\n  // for(i = 31; i >= 0; i--) {\n  //   if(1<<i & num) return i;\n  // }\n  // return 0;\n}\n\nvoid get_area_state(char *line, int *a) {\n  int i;\n  char *tmp = strtok(line, \" \");\n  int k = strtol(tmp, NULL, 10);\n  for(i = 0; i < k; i++) {\n    tmp = strtok(NULL, \" \");\n    *a |= (1 << strtol(tmp, NULL, 10));\n  }\n  return;\n}\n\nvoid move(int *from, int *to, int bits) {\n  *from &= ~bits;\n  *to |= bits;\n}\n\nint main(void) {\n  char line[BUF_SIZE];\n\n  int i, j;\n  while(1) {\n    int num, limits;\n    get_int2(line, BUF_SIZE, &num, &limits);\n    if(!num && !limits) break;\n    struct state st = {0, 0, 0, 0};\n    if(!fgets(line, BUF_SIZE, stdin)) return 0;\n    get_area_state(line, &st.a);\n    if(!fgets(line, BUF_SIZE, stdin)) return 0;\n    get_area_state(line, &st.b);\n    if(!fgets(line, BUF_SIZE, stdin)) return 0;\n    get_area_state(line, &st.c);\n\n    initialize();\n    enqueue(st);\n    keep_track(st);\n    int flag = -1;\n    while(!is_empty()) {\n      struct state s = dequeue();\n      if(!s.b && (!s.a || !s.c)) {\n        flag = s.cnt;\n        break;\n      }\n      int a_max = get_max(s.a);\n      int b_max = get_max(s.b);\n      int c_max = get_max(s.c);\n      int max[3] = {a_max, b_max, c_max};\n      if(s.cnt >= limits) continue;\n      for(i = 0; i < 3; i++) {\n        for(j = 0; j < 3; j++) {\n          // including i==j\n          if(i+j==2) continue; // (0,2) or (2,0) is not allowed\n          if(max[i] <= max[j]) continue;\n          // assume that idx:i is bigger than idx:j\n          struct state ns = s; ns.cnt = s.cnt + 1;\n          int bits = 1 << max[i];\n          int *areas[] = {&ns.a, &ns.b, &ns.c};\n          // from, to, bits\n          move(areas[i], areas[j], bits);\n          if(!find_state(ns)) {\n            keep_track(ns);\n            enqueue(ns);\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\", flag);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint N,M,p[15],n[15],i,j,t,q,R,s[16];\nint main()\n{\n\tfor(i=s[0]=1;i<16;i++)s[i]=s[i-1]*3;\n\tfor(;scanf(\"%d%d\",&N,&M),N;)\n\t{\n\t\tmemset(n,0,sizeof(n));\n\t\tfor(i=R=0;i<3;i++)\n\t\t\tfor(scanf(\"%d\",&t),j=0;j<t;p[N-q]=i,j++)\n\t\t\t\tscanf(\"%d\",&q);\n\t\tfor(i=N-1;i>=0;i--)\n\t\t{\n\t\t\tt=abs(p[i]-n[i]);\n\t\t\tR+=t*s[i];\n\t\t\tfor(j=0;j<i;j++)\n\t\t\tif(t==1)n[j]=2-n[i];\n\t\t}\n\t\tR=R>s[N]-1-R?s[N]-1-R:R;\n\t\tprintf(\"%d\\n\",R>M?-1:R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,t[16],c[16],p,d;main(n){for(*t=1;++i<16;)t[i]=n*=3;for(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",j>m?-1:j)){for(k=3;k--;)for(scanf(\"%d\",&i);i--;c[j]=k)scanf(\"%d\",&j);for(p=j=k=0;k++<n;p=i%2*2+p&3)j+=t[n-k]*abs(i=p-c[k]);j=fmin(j,t[n]+~j);}}"
  },
  {
    "language": "C",
    "code": "c[];s(x){scanf(\"%d\",x);}main(n,m,i,j,k,f){for(;s(&n)*n/s(&m);printf(\"%d\\n\",j>m?i:j)){for(i=3;i--;)for(s(&j);j--;c[n-k]=i)s(&k);for(i=n;i--;k+=c[i])j-=pow(3,i)*abs(k*2%4-c[i]);j=fmin(~j,pow(3,n)+j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint tray[3][3][15],num[3][3];\n\nint main(void)\n{\n  int n,m,i,j,ans,cnt;\n\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    if(n==0&&m==0) break;\n    ans = m+1;\n\n    for(i=0;i<3;i++){\n      scanf(\"%d\",&num[0][i]);\n      num[2][i] = num[0][i];\n  \n      for(j=0;j<num[0][i];j++){\n\tscanf(\"%d\",&tray[0][i][j]);\n\ttray[2][i][j] = tray[0][i][j];\n      }\n    }\n\n    for(i=0; i<3; i+=2){\n      cnt=0;\n      for(j=1; j<=n; j++){\n\tcnt += move(j,i);\n\tif(cnt>m)\n\t  break;\n      }\n      ans = (ans<cnt)?ans:cnt;\n    }\n\n    printf(\"%d\\n\",(ans==m+1)?-1:ans);\n  }\n}\n\nint move(int card,int place)\n{\n  int cnt=0,ctray,diff,i,j;\n\n  for(i=0; i<3; i++)\n    for(j=0; j<num[place][i]; j++)\n      if(card==tray[place][i][j]){\n\tctray = i;\n\tgoto out;\n      }\n\n out:\n\n  if(ctray==place)\n    return 0;\n  \n  diff = (ctray<place)?1:-1;\n  for(i=ctray; i!=place; i+=diff)\n    cnt += move2(card,i,i+diff,place);\n  \n  return cnt;\n}\n\nint move2(int card,int from,int to,int goal)\n{\n  int cnt=0,rest=3-from-to;\n\n  while(1){\n    if(tray[goal][from][num[goal][from]-1] > card){\n      cnt += move2(tray[goal][from][num[goal][from]-1],from,abs(rest-from)==1?rest:to,goal);\n      continue;\n    }\n\n    if(tray[goal][to][num[goal][to]-1] > card){\n      cnt += move2(tray[goal][to][num[goal][to]-1],to,abs(rest-to)==1?rest:from,goal);\n      continue;\n    }\n    break;\n  }\n\n  num[goal][from]--;\n  tray[goal][to][num[goal][to]++] = card;\n\n  return cnt+1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n\tint n,m,l;\n\tint i,j;\n\twhile(scanf(\"%d %d\",&n,&m),(n&&m))\n\t{\n\t\tint data[3][n];\n\t\tint len[3];\n\t\tint lentmp[3];\n\t\tint tmp[3][n];\n\t\tint min = m;\n\t\tint direction;\n\t\tfor(i = 0;i < 3;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&len[i]);\n\t\t\tlentmp[i] = len[i];\n\t\t\tfor(j = 0;j < len[i];j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&data[i][j]);\n\t\t\t\ttmp[i][j] = data[i][j];\n\t\t\t}\n\t\t}\n\t\tdirection = 0;\n\t\tfor(i = 0;i < m;i++)\n\t\t{\n\t\t\tif(len[1] == 0 && (len[0] == 0 || len[2] == 0))\n\t\t\t{\n\t\t\t\tmin = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(len[direction] != 0 && data[direction][len[direction]-1] > data[direction+1][len[direction+1]-1])\n\t\t\t{\n\t\t\t\tdata[direction+1][len[direction+1]] = data[direction][len[direction]-1];\n\t\t\t\tlen[direction+1]++;\n\t\t\t\tlen[direction]--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdata[direction][len[direction]] = data[direction+1][len[direction+1]-1];\n\t\t\t\tlen[direction]++;\n\t\t\t\tlen[direction+1]--;\n\t\t\t}\n\t\t\tdirection ^= 1;\n\t\t}\n\t\tdirection = 1;\n\t\tfor(i = 0;i < m;i++)\n\t\t{\n\t\t\tif(lentmp[1] == 0 && (lentmp[0] == 0 || lentmp[2] == 0))\n\t\t\t{\n\t\t\t\tif(min > i)\n\t\t\t\t{\n\t\t\t\t\tmin = i;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(lentmp[direction] != 0 && tmp[direction][lentmp[direction]-1] > tmp[direction+1][lentmp[direction+1]-1])\n\t\t\t{\n\t\t\t\ttmp[direction+1][lentmp[direction+1]] = tmp[direction][lentmp[direction]-1];\n\t\t\t\tlentmp[direction+1]++;\n\t\t\t\tlentmp[direction]--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmp[direction][lentmp[direction]] = tmp[direction+1][lentmp[direction+1]-1];\n\t\t\t\tlentmp[direction]++;\n\t\t\t\tlentmp[direction+1]--;\n\t\t\t}\n\t\t\tdirection ^= 1;\n\t\t}\n\t\tif(m == min)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",min);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define S scanf(\"%d\",&\nc[];main(n,m,i,j,k){for(;S n),S m),n;printf(\"%d\\n\",j>m?i:j)){for(i=3;i--;)for(S j);j--;c[n-k]=i)S k);for(i=n;i--;k+=c[i])j-=pow(3,i)*abs(k*2%4-c[i]);j=fmin(~j,pow(3,n)+j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void){\n\tint n,m,i,j,k,t[16],c[16],p,d;\n\tfor( t[0] = n = i = 1; i < 16; i++ )t[i] = n *= 3;\n\tfor(;scanf(\"%d%d\",&n,&m),n|m;){\n\t\tfor( k = 0; k < 3; k++ )\n\t\t\tfor( scanf(\"%d\",&i); i--; c[j] = k )scanf(\"%d\",&j);\n\t\tp = j = 0;\n\t\tfor( k = 0; k++ < n;){\n\t\t\tj+=t[n-k]*abs(i=p-c[k]),p=i%2*2+p&3;\n\t\t}\n\t\tk = t[n] - 1 - j;\n\t\tif( j > k ) j = k;\n\t\tprintf(\"%d\\n\", j > m ? -1 : j );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N_MAX 15\n#define M_MAX 15000000\n\nint memo[N_MAX][3][3],ismemoized[N_MAX][3][3];\n\nint main(){\n  int card[15],n,m,i,j,from,to,rest,cnt,ans;\n\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    ans = m+1;\n\n    if(n==0&&m==0) break;\n\n    for(i=0; i<3; i++){\n      int t1,t2;\n      scanf(\"%d\",&t1);\n      for(j=0; j<t1; j++){\n\tscanf(\"%d\",&t2);\n\tcard[t2-1] = i;\n      }\n    }\n\n    for(i=0,cnt=0; i<3; i+=2){\n      for(j=1,from=i; j<=n; j++){\n\tto = card[j-1];\n\trest = 3-(from+to);\n\n\tswitch(abs(from-to)){\n\tcase 1:\n\t  cnt += move(n-j,from,rest) + 1;\n\t  from = rest;\n\t  break;\n\tcase 2:\n\t  cnt += move(n-j,from,to) + move(n-j,to,from) + 2;\n\t  from = to;\n\t  break;\n\t}\n      }\n      ans = (ans>cnt)?cnt:ans;\n    }\n\n    printf(\"%d\\n\",(ans==m+1)?-1:ans);\n  }\n}\n\nint move(num,from,to){\n  int rest = 3-(from+to),ans;\n\n  if(ismemoized[num][from][to])\n    return memo[num][from][to];\n\n  if(num==0)\n    ans = 0;\n  else if(num==1)\n    ans = abs(from-to);\n  else\n    switch(abs(from-to)){\n    case 0:\n      ans = 0;\n      break;\n    case 1:\n      ans = move(num-1,from,rest)+move(num-1,rest,to)+1;\n      break;\n    case 2:\n      ans = move(num,from,rest)+move(num,rest,to);\n      break;\n    }\n\n  ans = (ans<M_MAX)?ans:(M_MAX+1);\n\n  ismemoized[num][from][to] = 1;\n  memo[num][from][to] = ans;\n  return ans;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint n,m,i,j,k,t[16],c[16],p,d;\nint main(void){\n\tfor(*t=n=1;++i<16;)t[i]=n*=3;\n\tfor(;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor(k=3;k--;)\n\t\t\tfor(scanf(\"%d\",&i);i--;c[j]=k)scanf(\"%d\",&j);\n\t\tfor(p=j=k=0;k++<n;)\n\t\t\t\tj+=t[n-k]*abs(i=p-c[k]),p=i%2*2+p&3;\n\t\tj=fmin(j,t[n]+~j);\n\t\tprintf(\"%d\\n\",j>m?-1:j);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void){\n\tint n,m,i,j,k,t[16],c[16],p,d;\n\tfor( t[0] = n = i = 1; i < 16; i++ )t[i] = n *= 3;\n\tfor(;scanf(\"%d%d\",&n,&m),n|m;){\n\t\tfor( k = 0; k < 3; k++ )\n\t\t\tfor( scanf(\"%d\",&i); i--; c[j] = k )scanf(\"%d\",&j);\n\t\tp = j = 0;\n\t\tfor( k = 0; k++ < n;){\n\t\t\tp-c[k]&1?j+=t[n-k],p=2+p&3:0;\n\t\t}\n\t\tk = t[n] - 1 - j;\n\t\tif( j > k ) j = k;\n\t\tprintf(\"%d\\n\", j > m ? -1 : j );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N_MAX 15\n#define M_MAX 15000000\n\nint memo[N_MAX][3][3],ismemoized[N_MAX][3][3];\n\nint main(){\n  int card[15],n,m,i,j,from,to,rest,cnt,ans;\n\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    ans = m+1;\n\n    if(n==0&&m==0) return 0;\n\n    for(i=0; i<3; i++){\n      int t1,t2;\n      scanf(\"%d\",&t1);\n      for(j=0; j<t1; j++){\n\tscanf(\"%d\",&t2);\n\tcard[t2-1] = i;\n      }\n    }\n\n    for(i=0; i<=2; i+=2){\n      from = i; cnt = 0;\n      for(j=1; j<=n; j++){\n\tto = card[j-1];\n\trest = 3-(from+to);\n\n\tswitch(abs(from-to)){\n\tcase 1:\n\t  cnt += move(n-j,from,rest) + 1;\n\t  from = rest;\n\t  break;\n\tcase 2:\n\t  cnt += move(n-j,from,to) + move(n-j,to,from) + 2;\n\t  break;\n\t}\n      }\n      ans = (ans>cnt)?cnt:ans;\n    }\n\n    printf(\"%d\\n\",(ans==m+1)?-1:ans);\n  }\n}\n\nint move(num,from,to){\n  int rest = 3-(from+to),ans;\n\n  if(ismemoized[num][from][to])\n    return memo[num][from][to];\n\n  if(num==0)\n    ans = 0;\n  else if(num==1)\n    ans = abs(from-to);\n  else\n    switch(abs(from-to)){\n    case 0:\n      ans = 0;\n      break;\n    case 1:\n      ans = move(num-1,from,rest)+move(num-1,rest,to)+1;\n      break;\n    case 2:\n      ans = move(num,from,rest)+move(num,rest,to);\n      break;\n    }\n\n  ans = (ans<=M_MAX)?ans:(M_MAX+1);\n\n  ismemoized[num][from][to] = 1;\n  memo[num][from][to] = ans;\n  return ans;\n}"
  },
  {
    "language": "C",
    "code": "c[];main(n,m,i,j,k,f){for(f=\"%d\\n\";scanf(\"%d%d\",&n,&m)*n;printf(f,j>m?i:j)){for(i=3;i--;)for(scanf(f,&j);j--;c[n-k]=i)scanf(f,&k);for(i=n;i--;k+=c[i])j-=pow(3,i)*abs(k*2%4-c[i]);j=fmin(~j,pow(3,n)+j);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NMAX 15\n#define MMAX 15000000\n\nint cup[3];\nint cup_move[4][2] = {{0,1},{1,0},{1,2},{2,1}};\nint stack[MMAX][3];\n\nint move(int temp[3],int a,int amin, int amax)\n{\n\tint i,l,m;\n\tint flag;\n\n\tfor(m=0;m<4;m++){\n\t\tif(temp[cup_move[m][0]]>temp[cup_move[m][1]]){\n\t\t\tl= 1<<NMAX;\n\t\t\twhile((l & temp[cup_move[m][0]]) == 0) l>>=1;\n\t\t\ttemp[cup_move[m][0]] -= l;\n\t\t\ttemp[cup_move[m][1]] += l;\n\t\t\ta++;\n\t\t\tstack[a][0]=temp[0];\n\t\t\tstack[a][1]=temp[1];\n\t\t\tstack[a][2]=temp[2];\n\n\t\t\tif(a>amax){\n\t\t\t\treturn a--;\n\t\t\t}\n\t\t\tif(temp[1]==0 && (temp[0]==0 || temp[2]==0)){\n\t\t\t\tif(amin>a) amin=a;\n\t\t\t\treturn a--;\n\t\t\t}\n\n\t\t\tflag = 0;\n\t\t\tfor(i=0;i<a;i++){\n\t\t\t\tif(stack[i][0]==temp[0] && stack[i][1]==temp[1] && stack[i][2]==temp[2]){\n\t\t\t\t\ta--;\n\t\t\t\t\ttemp[0]=stack[a][0];\n\t\t\t\t\ttemp[1]=stack[a][1];\n\t\t\t\t\ttemp[2]=stack[a][2];\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag) amin = move(temp,a,amin,amax);\n\t\t}\n\t}\n\treturn amin;\n}\n\nint main(void)\n{\n\tint n,m;\n\tint c_max,c;\n\tint i,j;\n\tint a;\n\tint temp[3];\n\n\twhile(scanf(\"%d%d\", &n, &m) && n+m){\n\t\tfor(i=0;i<3;i++){\n\t\t\tcup[i] = 0;\n\t\t\tscanf(\"%d\", &c_max);\n\t\t\tfor(j=0;j<c_max;j++){\n\t\t\t\tscanf(\"%d\", &c);\n\t\t\t\tcup[i] |= 1 << (c-1);\n\t\t\t}\n\t\t}\n\n\t\tif(cup[1]==0 && (cup[0]==0 || cup[2]==0)){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(i=0;i<3;i++){\n\t\t\ttemp[i]=cup[i];\n\t\t\tstack[0][i]=cup[i];\n\t\t}\n\t\ta = move(temp,0,m,m);\n\n\t\tif(a>m){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"%d\\n\",a);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define min(a, b) (a < b ? a : b)\n#define max(a, b) (a > b ? a : b)\n\n#define MAX_CUPS 20\n#define QUEUE_SIZE 0x100000\n#define STACK_SIZE (MAX_CUPS)\n\ntypedef enum {\n  A2B = 0x00 | 0x10,\n  B2A = 0x01 | 0x00,\n  C2B = 0x02 | 0x10,\n  B2C = 0x01 | 0x20,\n  NONE = 0x33,\n} Move;\n\ntypedef int StackItem;\n\ntypedef struct {\n  size_t top;\n  size_t size;\n  StackItem array[STACK_SIZE];\n} Stack;\n\ntypedef struct {\n  int moves;\n  Move prev_move;\n  int limit;\n  Stack tray[3];\n} State;\n\ntypedef State QueueItem;\ntypedef struct {\n  size_t in;\n  size_t out;\n  size_t size;\n  bool is_full;\n  QueueItem* array;\n} Queue;\n\nsize_t _queue_inc_index(const Queue* queue, size_t index)\n{\n  return (index + 1) % queue->size;\n}\n\nbool queue_push(Queue* queue, const QueueItem* item)\n{\n  if(queue->is_full) {\n    return false;\n  }\n  memcpy(&queue->array[queue->in], item, sizeof(*item));\n  queue->in = _queue_inc_index(queue, queue->in);\n  queue->is_full = queue->in == queue->out;\n  return true;\n}\n\nbool queue_is_empty(const Queue* queue)\n{\n  return !queue->is_full && queue->in == queue->out;\n}\n\nbool queue_pop(Queue* queue, QueueItem* result)\n{\n  if(queue_is_empty(queue)) {\n    return false;\n  }\n  memcpy(result, &queue->array[queue->out], sizeof(*result));\n  queue->out = _queue_inc_index(queue, queue->out);\n  queue->is_full = false;\n  return true;\n}\n\nvoid clear_queue(Queue* queue)\n{\n  memset(queue, 0, sizeof(*queue));\n}\n\nvoid init_queue(Queue* queue, size_t size)\n{\n  clear_queue(queue);\n  queue->size = size;\n  queue->array = malloc(sizeof(QueueItem) * size);\n  if(!queue->array) {\n    perror(\"init_queue\");\n    exit(1);\n  }\n}\n\nbool stack_is_empty(const Stack* stack)\n{\n  return stack->top == 0;\n}\n\nconst StackItem* stack_top(const Stack* stack)\n{\n  if(stack_is_empty(stack)) {\n    fputs(\"stack_top: Stack is empty.\\n\", stderr);\n    exit(1);\n  }\n  return &stack->array[stack->top-1];\n}\n\nbool stack_is_full(const Stack* stack)\n{\n  return stack->size < stack->top;\n}\n\nbool stack_push(Stack* stack, const StackItem* item)\n{\n  if(stack_is_full(stack)) {\n    return false;\n  }\n  memcpy(&stack->array[stack->top], item, sizeof(*item));\n  stack->top++;\n  return true;\n}\n\nbool stack_pop(Stack* stack, StackItem* result)\n{\n  if(stack_is_empty(stack)) {\n    return false;\n  }\n  memcpy(result, &stack->array[stack->top-1], sizeof(*result));\n  stack->top--;\n  return true;\n}\n\nvoid clear_stack(Stack* stack)\n{\n  memset(stack, 0, sizeof(*stack));\n}\n\nvoid init_stack(Stack* stack, size_t size)\n{\n  clear_stack(stack);\n  stack->size = size;\n  /*\n  stack->array = malloc(sizeof(StackItem) * size);\n  if(!stack->array) {\n    perror(\"init_stack\");\n    exit(1);\n  }\n  */\n}\n\nvoid init_state(State* state, int limit)\n{\n  state->limit = limit;\n  state->prev_move = NONE;\n  state->moves = 0;\n  for(size_t i = 0; i < sizeof(state->tray) / sizeof(*state->tray); i++) {\n    init_stack(&state->tray[i], MAX_CUPS);\n  }\n}\n\nvoid scan_initial_state(State* state, int num_moves)\n{\n  init_state(state, num_moves);\n  for(size_t i = 0; i < sizeof(state->tray) / sizeof(*state->tray); i++) {\n    int num_cups;\n    scanf(\"%d\", &num_cups);\n    for(int k = 0; k < num_cups; k++) {\n      int cup_size;\n      scanf(\"%d\", &cup_size);\n      stack_push(&state->tray[i], &cup_size);\n    }\n  }\n}\n\nvoid print_state(State* state)\n{\n  printf(\"moves = %d\\n\", state->moves);\n  printf(\"prev_move = %d\\n\", state->prev_move);\n  printf(\"limit = %d\\n\", state->limit);\n  for(size_t i = 0; i < sizeof(state->tray) / sizeof(*state->tray); i++) {\n    StackItem item;\n    while(stack_pop(&state->tray[i], &item)) {\n      printf(\" %d\", item);\n    }\n    putchar('\\n');\n  }\n}\n\nbool state_is_goal(const State* state)\n{\n  bool move_to_c =\n    (stack_is_empty(&state->tray[0]) && stack_is_empty(&state->tray[1]));\n  bool move_to_a =\n    (stack_is_empty(&state->tray[1]) && stack_is_empty(&state->tray[2]));\n  return move_to_c || move_to_a;\n}\n\nbool can_move(const State* state, int dst, int src)\n{\n  const Stack* dst_stack = &state->tray[dst];\n  const Stack* src_stack = &state->tray[src];\n  if(stack_is_empty(src_stack)) {\n    return false;\n  }\n  if(stack_is_empty(dst_stack)) {\n    return true;\n  }\n  return *stack_top(dst_stack) < *stack_top(src_stack);\n}\n\nbool can_move_a_to_b(const State* state)\n{\n  return can_move(state, 1, 0);\n}\n\nbool can_move_b_to_a(const State* state)\n{\n  return can_move(state, 0, 1);\n}\n\nbool can_move_c_to_b(const State* state)\n{\n  return can_move(state, 1, 2);\n}\n\nbool can_move_b_to_c(const State* state)\n{\n  return can_move(state, 2, 1);\n}\n\nbool state_is_dead(const State* state)\n{\n  return state->limit < state->moves;\n}\n\nvoid move_cup(State* state, int dst, int src)\n{\n  Stack* dst_stack = &state->tray[dst];\n  Stack* src_stack = &state->tray[src];\n  StackItem item;\n  stack_pop(src_stack, &item);\n  stack_push(dst_stack, &item);\n}\n\nvoid move_cup_a_to_b(State* state)\n{\n  move_cup(state, 1, 0);\n}\n\nvoid move_cup_b_to_a(State* state)\n{\n  move_cup(state, 0, 1);\n}\n\nvoid move_cup_c_to_b(State* state)\n{\n  move_cup(state, 1, 2);\n}\n\nvoid move_cup_b_to_c(State* state)\n{\n  move_cup(state, 2, 1);\n}\n\nint solve(State* initial_state)\n{\n  Queue queue;\n  init_queue(&queue, QUEUE_SIZE);\n  queue_push(&queue, initial_state);\n  State state;\n  while(queue_pop(&queue, &state)) {\n    if(state_is_goal(&state)) {\n      return state.moves;\n    }\n    if(state_is_dead(&state)) {\n      continue;\n    }\n    State new_state;\n    Move prev = state.prev_move;\n    if(can_move_a_to_b(&state) && prev != B2A) {\n      memcpy(&new_state, &state, sizeof(state));\n      new_state.moves++;\n      new_state.prev_move = A2B;\n      move_cup_a_to_b(&new_state);\n      queue_push(&queue, &new_state);\n      //printf(\"move %d -> %d, 0 -> 1\\n\", prev % 4, (prev >> 4) % 4);\n    }\n    else if(can_move_b_to_a(&state) && prev != A2B) {\n      memcpy(&new_state, &state, sizeof(state));\n      new_state.moves++;\n      new_state.prev_move = B2A;\n      move_cup_b_to_a(&new_state);\n      queue_push(&queue, &new_state);\n      //printf(\"move %d -> %d, 1 -> 0\\n\", prev % 4, (prev >> 4) % 4);\n    }\n    if(can_move_c_to_b(&state) && prev != B2C) {\n      memcpy(&new_state, &state, sizeof(state));\n      new_state.moves++;\n      new_state.prev_move = C2B;\n      move_cup_c_to_b(&new_state);\n      queue_push(&queue, &new_state);\n      //printf(\"move %d -> %d, 2 -> 1\\n\", prev % 4, (prev >> 4) % 4);\n    }\n    else if(can_move_b_to_c(&state) && prev != C2B) {\n      memcpy(&new_state, &state, sizeof(state));\n      new_state.moves++;\n      new_state.prev_move = B2C;\n      move_cup_b_to_c(&new_state);\n      queue_push(&queue, &new_state);\n      //printf(\"move %d -> %d, 1 -> 2\\n\", prev % 4, (prev >> 4) % 4);\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(1) {\n    int num_cups, num_moves;\n    scanf(\"%d%d\", &num_cups, &num_moves);\n    if(num_cups == 0 && num_moves == 0) {\n      break;\n    }\n    State state;\n    scan_initial_state(&state, num_moves);\n    //print_state(&state);\n    printf(\"%d\\n\", solve(&state));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint min(int a,int b){\n\treturn a < b ? a : b;\n}\n\nint main(){\n\tint n,i,j,m,t,cup,ans;\n\tint *p,*a,*c,*tray;\n\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tp = (int *)malloc(sizeof(int)*n);\n\t\ta = (int *)malloc(sizeof(int)*n);\n\t\tc = (int *)malloc(sizeof(int)*n);\n\t\ttray = (int *)malloc(sizeof(int)*n);\n\n\t\tfor(i = 0;i < 3;i++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tfor(j = 0;j < t;j++){\n\t\t\t\tscanf(\"%d\",&cup);\n\t\t\t\ttray[cup-1] = i;\n\t\t\t}\n\t\t}\n\n\t\tp[n-1] = 2;\n\t\ta[n-1] = tray[n-1];\n\t\tc[n-1] = 2-tray[n-1];\n\n\t\tfor(i = n-2;i >= 0;i--){\n\t\t\tp[i] = 3*p[i+1]+2;\n\t\t\tswitch(tray[i]){\n\t\t\tcase 0:\n\t\t\t\ta[i] = a[i+1];\n\t\t\t\tc[i] = 2*p[i+1]+c[i+1]+2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\ta[i] = p[i+1]+c[i+1]+1;\n\t\t\t\tc[i] = p[i+1]+a[i+1]+1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ta[i] = 2*p[i+1]+a[i+1]+2;\n\t\t\t\tc[i] = c[i+1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans = min(a[0],c[0]);\n\t\tprintf(\"%d\\n\",ans < m ? ans : -1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n\n// input \n// n m\t\t<-- n-cup(1<=n<=15)/m-times)1<=m<=15000000)\n// n0 a_1,...,a_n0\n// n1 b_1,...,b_n1\n// n2 c_1,...,c_n2\n//\n//\n//\n\nint DECODE_3Gray2int(int n,int POS[]);\n\nint main(){\n\n\tint n,m;\n\tint n0,a;\n\tint i;\n\tint SerialNo;\n\tint max;\n\tint POS[16];\n\tint ans;\n\n\twhile(scanf(\"%d %d\",&n,&m)!=EOF){\n\t\tif(!n&&!m) break;\n\n\t\tfor(i=0;i<16;i++)POS[i]=0;\n\n\t\tscanf(\"%d\",&n0);\n\t\tfor(i=1;i<=n0;i++){\n\t\t\tscanf(\"%d\",&a);\n\t\t\tPOS[n-a]=0;\n\t\t}\n\t\tscanf(\"%d\",&n0);\n\t\tfor(i=1;i<=n0;i++){\n\t\t\tscanf(\"%d\",&a);\n\t\t\tPOS[n-a]=1;\n\t\t}\n\t\tscanf(\"%d\",&n0);\n\t\tfor(i=1;i<=n0;i++){\n\t\t\tscanf(\"%d\",&a);\n\t\t\tPOS[n-a]=2;\n\t\t}\n\t\t\n\n//dbg for(i=0;i<n;i++)printf(\"%d \",POS[i]);puts(\"\");\n\n\t\tSerialNo=DECODE_3Gray2int(n,POS);\t//sol. determined from 3-adic/n-bit GrayCode\n\n\t\tmax=1;\n\t\tfor(i=0;i<n;i++)max*=3;\n\t\tmax=max-1;\n\n\t\tans=SerialNo;\n\t\tif(SerialNo>max-SerialNo)ans=max-SerialNo;\n\n\t\tprintf(\"%d\\n\",m>=ans?ans:-1);\n\n\t}\n\n\n\treturn 0;\n}\n\n\nint DECODE_3Gray2int(int n,int POS[]){\n\n\tint SDEC[16];\n\tint k,l;\n\tint jdg,keta;\n\tint ret;\n\t\n\tfor(k=0;k<16;k++)SDEC[k]=0;\n\tfor(k=n-1;k>=0;k--){\n\t\tjdg=0;\n\t\tketa=1;\n\t\tfor(l=1;k+l<=n;l++){\n\t\t\tjdg=jdg+keta*SDEC[k+l];\n\t\t\tketa*=3;\n\t\t}\n\t\tSDEC[k]=jdg%2?(2-POS[k]):POS[k];\n\t}\n//dbg for(k=0;k<n;k++)printf(\"%d \",SDEC[k]);puts(\"\");\n\n\tketa=1;ret=0;\n\tfor(k=0;k<16;k++){\n\t\tret+=SDEC[k]*keta;\n\t\tketa*=3;\n\t}\n\t\n\treturn ret;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n\tint n,m,l;\n\tint i,j;\n\twhile(scanf(\"%d %d\",&n,&m),(n&&m))\n\t{\n\t\tint data[3][n];\n\t\tint len[3];\n\t\tint lentmp[3];\n\t\tint tmp[3][n];\n\t\tint min = m;\n\t\tint direction;\n\t\tfor(i = 0;i < 3;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&len[i]);\n\t\t\tlentmp[i] = len[i];\n\t\t\tfor(j = 0;j < len[i];j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&data[i][j]);\n\t\t\t\ttmp[i][j] = data[i][j];\n\t\t\t}\n\t\t}\n\t\tdirection = 0;\n\t\tfor(i = 0;i < m;i++)\n\t\t{\n\t\t\tif(len[1] == 0 && (len[0] == 0 || len[2] == 0))\n\t\t\t{\n\t\t\t\tmin = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(len[direction] != 0 && data[direction][len[direction]-1] > data[direction+1][len[direction+1]-1])\n\t\t\t{\n\t\t\t\tdata[direction+1][len[direction+1]] = data[direction][len[direction]-1];\n\t\t\t\tlen[direction+1]++;\n\t\t\t\tlen[direction]--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdata[direction][len[direction]] = data[direction+1][len[direction+1]-1];\n\t\t\t\tlen[direction]++;\n\t\t\t\tlen[direction+1]--;\n\t\t\t}\n\t\t\tif(len[1] == 0 && (len[0] == 0 || len[2] == 0))\n\t\t\t{\n\t\t\t\tmin = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdirection ^= 1;\n\t\t}\n\t\tdirection = 1;\n\t\tfor(i = 0;i < m;i++)\n\t\t{\n\t\t\tif(lentmp[1] == 0 && (lentmp[0] == 0 || lentmp[2] == 0))\n\t\t\t{\n\t\t\t\tif(min > i)\n\t\t\t\t{\n\t\t\t\t\tmin = i;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(lentmp[direction] != 0 && tmp[direction][lentmp[direction]-1] > tmp[direction+1][lentmp[direction+1]-1])\n\t\t\t{\n\t\t\t\ttmp[direction+1][lentmp[direction+1]] = tmp[direction][lentmp[direction]-1];\n\t\t\t\tlentmp[direction+1]++;\n\t\t\t\tlentmp[direction]--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmp[direction][lentmp[direction]] = tmp[direction+1][lentmp[direction+1]-1];\n\t\t\t\tlentmp[direction]++;\n\t\t\t\tlentmp[direction+1]--;\n\t\t\t}\n\t\t\tif(lentmp[1] == 0 && (lentmp[0] == 0 || lentmp[2] == 0))\n\t\t\t{\n\t\t\t\tif(min > i)\n\t\t\t\t{\n\t\t\t\t\tmin = i+1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdirection ^= 1;\n\t\t}\n\t\tif(m == min)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",min);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,c[];main(n){for(;k=~scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",j>m?i:j)){for(;k++;)for(scanf(\"%d\",&i);j=i--;c[n-j]=k)scanf(\"%d\",&j);for(i=n;i--;k-=c[i])j+=pow(3,i)*abs(k*2%4+c[i]);j=fmin(j,pow(3,n)+~j);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nstruct cup{\n    int num;\n    int item[15];\n    cup *next;\n}\n\nint put(cup *old,cup *new) {\n    if(old.item[old.num-1]<new.item[new.num-1]){\n        new.item[new.num]=old.item[old.num-1];\n        new.num++;\n        old.num--;\n        return TRUE;\n    }\n    return FALSE;\n}\n\nvoid scan(cup *first){\n    int a;\n    scanf(\"%d\\n\",&first.num);\n    for(a=0;a<first.num;a++){\n        scanf(\"%d\\n\",&first.item[a]);\n    }\n    if (first.next==NULL) {\n        return;\n    }\n    scan(first.next);\n}\n\nint main(int argc, char const *argv[]) {\n  int n,cn,i;\n  cup a,b,c;\n  a.next=&b;\n  b.next=&c;\n  c.next=NULL;\n  long m,j,count,min;\n  scanf(\"%d %ld\\n\",&n,&m);\n  while(n>0 && m>0){\n      scan(&a);\n      \n      \n      scanf(\"%d %ld\\n\",&n,&m);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "n,m,p[16],s,P[16];\nR(c,d,r){\n\tif(c<=n){\n\t\tfor(r=p[c]<d?1:-1;p[c]-d;p[c]+=r)\n\t\t\tR(c+1,3-p[c]*2-r),s++;\n\t\tR(c+1,d);\n\t}\n}\nmain(i,c,t){\n\tputs(\"\");\n\tfor(;scanf(\"%d%d\",&n,&m)*n;s=!printf(\"%d\\n\",s>m?-1:s)){\n\t\tfor(i=3;i--;)\n\t\t\tfor(scanf(\"%d\",&t);t--;p[c]=P[c]=i)\n\t\t\t\tscanf(\"%d\",&c);\n\t\tR(1,2);\n\t\tt=s;\n\t\tmemcpy(p,P,64);\n\t\tR(1,s=0);\n\t\ts=t<s?t:s;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void){\n\tint n,m;\n\tint i,j;\n\tint cups[3][16];\n\tint cup[3][16];\n\tint temp;\n\tint move[2];\n\tint moves[2];\n\tint min;\n\tint ccups[3];\n\tscanf(\"%d %d\",&n,&m);\n\twhile(n && m){\n\t\tfor(i=0;i<3;i++){\n\t\t\tscanf(\"%d\",&cups[i][0]);\n\t\t\tcup[i][0] = cups[i][0];\n\t\t\tfor(j=1;j<cups[i][0]+1;j++){\n\t\t\t\tscanf(\"%d\",&cups[i][j]);\n\t\t\t\tcup[i][j] = cups[i][j];\n\t\t\t}\n\t\t}\n\t\tif(cups[0][0] == n || cups[2][0] == n){\n\t\t\tprintf(\"0\\n\");\n\t\t}else{\n\t\t\tmove[0] = -1;\n\t\t\tmove[1] = -1;\n\t\t\tmoves[0] = -1;\n\t\t\tmoves[1] = -1;\n\t\t\tmin = -1;\n\t\t\tfor(i=1;i<m+1;i++){\n\t\t\t\tccups[0] = cups[0][cups[0][0]];\n\t\t\t\tccups[1] = cups[1][cups[1][0]];\n\t\t\t\tccups[2] = cups[2][cups[2][0]];\n\t\t\t\tif(ccups[0] > ccups[1] && (move[0] != 1 && move[1] != 0)){\n\t\t\t\t\tcups[1][cups[1][0]+1] = ccups[0];\n\t\t\t\t\tcups[0][0]--;\n\t\t\t\t\tcups[1][0]++;\n\t\t\t\t\tmove[0] = 0;\n\t\t\t\t\tmove[1] = 1;\n\t\t\t\t}else if(ccups[1] > ccups[2] && (move[0] != 2 || move[1] != 1)){\n\t\t\t\t\tcups[2][cups[2][0]+1] = ccups[1];\n\t\t\t\t\tcups[1][0]--;\n\t\t\t\t\tcups[2][0]++;\n\t\t\t\t\tmove[0] = 1;\n\t\t\t\t\tmove[1] = 2;\n\t\t\t\t}else if(ccups[2] > ccups[1] && (move[0] != 1 || move[1] != 2)){\n\t\t\t\t\tcups[1][cups[1][0]+1] = ccups[2];\n\t\t\t\t\tcups[2][0]--;\n\t\t\t\t\tcups[1][0]++;\n\t\t\t\t\tmove[0] = 2;\n\t\t\t\t\tmove[1] = 1;\n\t\t\t\t}else if(ccups[1] > ccups[0] && (move[0] != 0 || move[1] != 1)){\n\t\t\t\t\tcups[0][cups[0][0]+1] = ccups[1];\n\t\t\t\t\tcups[1][0]--;\n\t\t\t\t\tcups[0][0]++;\n\t\t\t\t\tmove[0] = 1;\n\t\t\t\t\tmove[1] = 0;\n\t\t\t\t}\n\t\t\t\tif(cups[0][0] == n || cups[2][0] == n){\n\t\t\t\t\tmin = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tccups[0] = cup[0][cup[0][0]];\n\t\t\t\tccups[1] = cup[1][cup[1][0]];\n\t\t\t\tccups[2] = cup[2][cup[2][0]];\n\t\t\t\tif(ccups[1] > ccups[0] && (moves[0] != 0 || moves[1] != 1)){\n\t\t\t\t\tcup[0][cup[0][0]+1] = ccups[1];\n\t\t\t\t\tcup[1][0]--;\n\t\t\t\t\tcup[0][0]++;\n\t\t\t\t\tmoves[0] = 1;\n\t\t\t\t\tmoves[1] = 0;\n\t\t\t\t}else if(ccups[2] > ccups[1] && (moves[0] != 1 || moves[1] != 2)){\n\t\t\t\t\tcup[1][cup[1][0]+1] = ccups[2];\n\t\t\t\t\tcup[2][0]--;\n\t\t\t\t\tcup[1][0]++;\n\t\t\t\t\tmoves[0] = 2;\n\t\t\t\t\tmoves[1] = 1;\n\t\t\t\t}else if(ccups[1] > ccups[2] && (moves[0] != 2 || moves[1] != 1)){\n\t\t\t\t\tcup[2][cup[2][0]+1] = ccups[1];\n\t\t\t\t\tcup[1][0]--;\n\t\t\t\t\tcup[2][0]++;\n\t\t\t\t\tmoves[0] = 1;\n\t\t\t\t\tmoves[1] = 2;\n\t\t\t\t}else if(ccups[0] > ccups[1] && (moves[0] != 1 || moves[1] != 0)){\n\t\t\t\t\tcup[1][cup[1][0]+1] = ccups[0];\n\t\t\t\t\tcup[0][0]--;\n\t\t\t\t\tcup[1][0]++;\n\t\t\t\t\tmoves[0] = 0;\n\t\t\t\t\tmoves[1] = 1;\n\t\t\t\t}\n\t\t\t\tif(cup[0][0] == n || cup[2][0] == n){\n\t\t\t\t\tmin = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",min);\n\t\tscanf(\"%d %d\",&n,&m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <limits.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define min(a, b) (a < b ? a : b)\n#define max(a, b) (a > b ? a : b)\n\n#define MAX_CUPS 20\n#define QUEUE_SIZE 0x10000\n#define STACK_SIZE (MAX_CUPS)\n\ntypedef enum {\n  A2B = 0x00 | 0x10,\n  B2A = 0x01 | 0x00,\n  C2B = 0x02 | 0x10,\n  B2C = 0x01 | 0x20,\n  NONE = 0x33,\n} Move;\n\ntypedef int StackItem;\n\ntypedef struct {\n  size_t top;\n  size_t size;\n  StackItem array[STACK_SIZE];\n} Stack;\n\ntypedef struct {\n  int moves;\n  Move prev_move;\n  int limit;\n  Stack tray[3];\n} State;\n\ntypedef State QueueItem;\ntypedef struct {\n  size_t in;\n  size_t out;\n  size_t size;\n  bool is_full;\n  QueueItem* array;\n} Queue;\n\nsize_t _queue_inc_index(const Queue* queue, size_t index)\n{\n  return (index + 1) % queue->size;\n}\n\nbool queue_push(Queue* queue, const QueueItem* item)\n{\n  if(queue->is_full) {\n    return false;\n  }\n  memcpy(&queue->array[queue->in], item, sizeof(*item));\n  queue->in = _queue_inc_index(queue, queue->in);\n  queue->is_full = queue->in == queue->out;\n  return true;\n}\n\nbool queue_is_empty(const Queue* queue)\n{\n  return !queue->is_full && queue->in == queue->out;\n}\n\nbool queue_pop(Queue* queue, QueueItem* result)\n{\n  if(queue_is_empty(queue)) {\n    return false;\n  }\n  memcpy(result, &queue->array[queue->out], sizeof(*result));\n  queue->out = _queue_inc_index(queue, queue->out);\n  queue->is_full = false;\n  return true;\n}\n\nvoid clear_queue(Queue* queue)\n{\n  memset(queue, 0, sizeof(*queue));\n}\n\nvoid init_queue(Queue* queue, size_t size)\n{\n  clear_queue(queue);\n  queue->size = size;\n  queue->array = malloc(sizeof(QueueItem) * size);\n  if(!queue->array) {\n    perror(\"init_queue\");\n    exit(1);\n  }\n}\n\nbool stack_is_empty(const Stack* stack)\n{\n  return stack->top == 0;\n}\n\nconst StackItem* stack_top(const Stack* stack)\n{\n  if(stack_is_empty(stack)) {\n    fputs(\"stack_top: Stack is empty.\\n\", stderr);\n    exit(1);\n  }\n  return &stack->array[stack->top-1];\n}\n\nbool stack_is_full(const Stack* stack)\n{\n  return stack->size < stack->top;\n}\n\nbool stack_push(Stack* stack, const StackItem* item)\n{\n  if(stack_is_full(stack)) {\n    return false;\n  }\n  memcpy(&stack->array[stack->top], item, sizeof(*item));\n  stack->top++;\n  return true;\n}\n\nbool stack_pop(Stack* stack, StackItem* result)\n{\n  if(stack_is_empty(stack)) {\n    return false;\n  }\n  memcpy(result, &stack->array[stack->top-1], sizeof(*result));\n  stack->top--;\n  return true;\n}\n\nvoid clear_stack(Stack* stack)\n{\n  memset(stack, 0, sizeof(*stack));\n}\n\nvoid init_stack(Stack* stack, size_t size)\n{\n  clear_stack(stack);\n  stack->size = size;\n  /*\n  stack->array = malloc(sizeof(StackItem) * size);\n  if(!stack->array) {\n    perror(\"init_stack\");\n    exit(1);\n  }\n  */\n}\n\nvoid init_state(State* state, int limit)\n{\n  state->limit = limit;\n  state->prev_move = NONE;\n  state->moves = 0;\n  for(size_t i = 0; i < sizeof(state->tray) / sizeof(*state->tray); i++) {\n    init_stack(&state->tray[i], MAX_CUPS);\n  }\n}\n\nvoid scan_initial_state(State* state, int num_moves)\n{\n  init_state(state, num_moves);\n  for(size_t i = 0; i < sizeof(state->tray) / sizeof(*state->tray); i++) {\n    int num_cups;\n    scanf(\"%d\", &num_cups);\n    for(int k = 0; k < num_cups; k++) {\n      int cup_size;\n      scanf(\"%d\", &cup_size);\n      stack_push(&state->tray[i], &cup_size);\n    }\n  }\n}\n\nvoid print_state(State* state)\n{\n  printf(\"moves = %d\\n\", state->moves);\n  printf(\"prev_move = %d\\n\", state->prev_move);\n  printf(\"limit = %d\\n\", state->limit);\n  for(size_t i = 0; i < sizeof(state->tray) / sizeof(*state->tray); i++) {\n    StackItem item;\n    while(stack_pop(&state->tray[i], &item)) {\n      printf(\" %d\", item);\n    }\n    putchar('\\n');\n  }\n}\n\nbool state_is_goal(const State* state)\n{\n  bool move_to_c =\n    (stack_is_empty(&state->tray[0]) && stack_is_empty(&state->tray[1]));\n  bool move_to_a =\n    (stack_is_empty(&state->tray[1]) && stack_is_empty(&state->tray[2]));\n  return move_to_c || move_to_a;\n}\n\nbool can_move(const State* state, int dst, int src)\n{\n  const Stack* dst_stack = &state->tray[dst];\n  const Stack* src_stack = &state->tray[src];\n  if(stack_is_empty(src_stack)) {\n    return false;\n  }\n  if(stack_is_empty(dst_stack)) {\n    return true;\n  }\n  return *stack_top(dst_stack) < *stack_top(src_stack);\n}\n\nbool can_move_a_to_b(const State* state)\n{\n  return can_move(state, 1, 0);\n}\n\nbool can_move_b_to_a(const State* state)\n{\n  return can_move(state, 0, 1);\n}\n\nbool can_move_c_to_b(const State* state)\n{\n  return can_move(state, 1, 2);\n}\n\nbool can_move_b_to_c(const State* state)\n{\n  return can_move(state, 2, 1);\n}\n\nbool state_is_dead(const State* state)\n{\n  return state->limit < state->moves;\n}\n\nvoid move_cup(State* state, int dst, int src)\n{\n  Stack* dst_stack = &state->tray[dst];\n  Stack* src_stack = &state->tray[src];\n  StackItem item;\n  stack_pop(src_stack, &item);\n  stack_push(dst_stack, &item);\n}\n\nvoid move_cup_a_to_b(State* state)\n{\n  move_cup(state, 1, 0);\n}\n\nvoid move_cup_b_to_a(State* state)\n{\n  move_cup(state, 0, 1);\n}\n\nvoid move_cup_c_to_b(State* state)\n{\n  move_cup(state, 1, 2);\n}\n\nvoid move_cup_b_to_c(State* state)\n{\n  move_cup(state, 2, 1);\n}\n\nint solve(State* initial_state)\n{\n  Queue queue;\n  init_queue(&queue, QUEUE_SIZE);\n  queue_push(&queue, initial_state);\n  State state;\n  while(queue_pop(&queue, &state)) {\n    if(state_is_goal(&state)) {\n      return state.moves;\n    }\n    if(state_is_dead(&state)) {\n      continue;\n    }\n    State new_state;\n    Move prev = state.prev_move;\n    if(can_move_a_to_b(&state) && prev != B2A) {\n      memcpy(&new_state, &state, sizeof(state));\n      new_state.moves++;\n      new_state.prev_move = A2B;\n      move_cup_a_to_b(&new_state);\n      queue_push(&queue, &new_state);\n      //printf(\"move %d -> %d, 0 -> 1\\n\", prev % 4, (prev >> 4) % 4);\n    }\n    else if(can_move_b_to_a(&state) && prev != A2B) {\n      memcpy(&new_state, &state, sizeof(state));\n      new_state.moves++;\n      new_state.prev_move = B2A;\n      move_cup_b_to_a(&new_state);\n      queue_push(&queue, &new_state);\n      //printf(\"move %d -> %d, 1 -> 0\\n\", prev % 4, (prev >> 4) % 4);\n    }\n    if(can_move_c_to_b(&state) && prev != B2C) {\n      memcpy(&new_state, &state, sizeof(state));\n      new_state.moves++;\n      new_state.prev_move = C2B;\n      move_cup_c_to_b(&new_state);\n      queue_push(&queue, &new_state);\n      //printf(\"move %d -> %d, 2 -> 1\\n\", prev % 4, (prev >> 4) % 4);\n    }\n    else if(can_move_b_to_c(&state) && prev != C2B) {\n      memcpy(&new_state, &state, sizeof(state));\n      new_state.moves++;\n      new_state.prev_move = B2C;\n      move_cup_b_to_c(&new_state);\n      queue_push(&queue, &new_state);\n      //printf(\"move %d -> %d, 1 -> 2\\n\", prev % 4, (prev >> 4) % 4);\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  while(1) {\n    int num_cups, num_moves;\n    scanf(\"%d%d\", &num_cups, &num_moves);\n    if(num_cups == 0 && num_moves == 0) {\n      break;\n    }\n    State state;\n    scan_initial_state(&state, num_moves);\n    //print_state(&state);\n    printf(\"%d\\n\", solve(&state));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "n,m,p[16],step;\nmove(c,d){\n\tif(c<=n&&p[c]!=d){\n\t\ttower(c+1,3-d-p[c]);\n\t\t//printf(\"step%d: move(%d,%c->%c)\\n\",step+1,c,p[c]+'A',d+'A');\n\t\tp[c]=d;\n\t\tstep++;\n\t}\n}\ntower(c,d){\n\tif(c<=n){\n\t\tfor(;p[c]<d;)\n\t\t\tmove(c,p[c]+1);\n\t\tfor(;p[c]>d;)\n\t\t\tmove(c,p[c]-1);\n\t\ttower(c+1,d);\n\t}\n}\nmain(){\n\tint i,h,c,P[16],s1,s2,smin;\n\tfor(;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor(i=0;i<3;i++){\n\t\t\tscanf(\"%d\",&h);\n\t\t\tfor(;h--;){\n\t\t\t\tscanf(\"%d\",&c);\n\t\t\t\tP[c]=i;\n\t\t\t}\n\t\t}\n\t\tmemcpy(p,P,sizeof(p));\n\t\tstep=0;\n\t\ttower(1,0);\n\t\ts1=step;\n\t\tmemcpy(p,P,sizeof(p));\n\t\tstep=0;\n\t\ttower(1,2);\n\t\ts2=step;\n\t\tsmin=s1<s2?s1:s2;\n\t\tprintf(\"%d\\n\",smin>m?-1:smin);\n\t}\n\tputs(\"\");\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,t[16],c[16],p,d;\nmain(n){\n\tfor(*t=1;++i<16;)t[i]=n*=3;\n\tfor(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",j>m?-1:j)){\n\t\tfor(k=3;k--;)\n\t\t\tfor(scanf(\"%d\",&i);i--;c[j]=k)scanf(\"%d\",&j);\n\t\tfor(p=j=k=0;k++<n;)\n\t\t\tj+=t[n-k]*abs(i=p-c[k]),p=i%2*2+p&3;\n\t\tj=fmin(j,t[n]+~j);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint c[36] ;\n\nint main(void){\n    int n , m , i , j , k , ans ;\n    int p3[16] ;\n    \n    for(p3[0] = 1 , i = 1 ; i < 16 ; i++){\n        p3[i] = 3 * p3[i - 1] ;\n    }\n    while(scanf(\"%d%d\" , &n , &m) && n > 0){\n        for(i = 0 ; i < 3 ; i++){\n            scanf(\"%d\" , &j) ;\n            while(j-- > 0){\n                scanf(\"%d\" , &k) , c[k - 1] = i ;\n            }\n        }\n        ans = k = 0 ;\n        for(i = 0 ; i < n ; i++){\n            j = c[i] - k ;\n            if(j < 0){\n                j = -j ;\n            }\n            ans += j * p3[n - i - 1] ;\n            if(j == 1){\n                k = 2 - k ;\n            }\n        }\n        k = p3[n] - ans - 1 ;\n        if(ans > k){\n            ans = k ;\n        }\n        if(ans > m){\n            ans = -1 ;\n        }\n        printf(\"%d\\n\" , ans) ;\n        \n    }\n    return 0 ;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void){\n\tint n,m,i,j,k,t[16],c[16],p,d;\n\tfor( t[0] = n = i = 1; i < 16; i++ )t[i] = n *= 3;\n\tfor(;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor( k = 3; k-- ;)\n\t\t\tfor( scanf(\"%d\",&i); i--; c[j] = k )scanf(\"%d\",&j);\n\t\tp = j = 0;\n\t\tfor( k = 0; k++ < n;){\n\t\t\tj+=t[n-k]*abs(i=p-c[k]),p=i%2*2+p&3;\n\t\t}\n\t\tk = t[n] - 1 - j;\n\t\tif( j > k ) j = k;\n\t\tprintf(\"%d\\n\", j > m ? -1 : j );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "m,i,j,k,c[16],p,d;main(n){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",j>m?-1:j)){for(k=3;k--;)for(scanf(\"%d\",&i);i--;c[j]=k)scanf(\"%d\",&j);for(j=k=0;k++<n;p=i%2*2+p&3)j+=pow(3,n-k)*abs(i=p-c[k]);j=fmin(j,pow(3,n)+~j);}}"
  },
  {
    "language": "C",
    "code": "c[];main(n,m,i,j,k){for(;scanf(\"%d%d\",&n,&m)*n;printf(\"%d\\n\",j>m?i:j)){for(i=3;i--;)for(scanf(\"%d\",&j);j--;c[n-k]=i)scanf(\"%d\",&k);for(i=n;i--;k+=c[i])j-=pow(3,i)*abs(k*2%4-c[i]);j=fmin(~j,pow(3,n)+j);}}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint[] pow3 = new int[n + 1];\n\t\t\tpow3[0] = 1;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tpow3[i] = pow3[i - 1] * 3;\n\t\t\tint[] c = new int[n];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tint a = scanner.nextInt();\n\t\t\t\tfor (int j = a; j > 0; j--) {\n\t\t\t\t\tint b = scanner.nextInt();\n\t\t\t\t\tc[n - b] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint p = 0;\n\t\t\tint x = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint d = Math.abs(p - c[i]);\n\t\t\t\tx += pow3[i] * d;\n\t\t\t\tif (d == 1)\n\t\t\t\t\tp = p - 2;\n\t\t\t}\n\t\t\tint y = pow3[n] - x - 1;\n\t\t\tx = Math.min(x, y);\n\t\t\tSystem.out.println(x > m ? -1 : x);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int INF = Integer.MAX_VALUE / 4 + 1;\n\tpublic static final int MAX = 15;\n\t\n\tpublic static int[][] lists = new int[3][MAX];\n\tpublic static int[]   sizes = new int[3];\n\t\n\tpublic static int[][] prevs = new int[3][MAX];\n\tpublic static int[] p_sizes = new int[3];\n\t\n\tpublic static void lists_clear(){\n\t\tsizes[0] = sizes[1] = sizes[2] = 0;\n\t}\n\t\n\tpublic static void prevs_clear(){\n\t\tp_sizes[0] = p_sizes[1] = p_sizes[2] = 0;\n\t}\n\t\n\tpublic static void all_clear(){\n\t\tlists_clear();\n\t\tprevs_clear();\n\t}\n\t\n\tpublic static void print_list(int l){\n\t\tSystem.out.print(l + \"  :\");\n\t\tfor(int i = 0; i < sizes[l]; i++){\n\t\t\tSystem.out.print(\" \" + lists[l][i]);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void print_prev_list(int l){\n\t\tSystem.out.print(l + \" p:\");\n\t\tfor(int i = 0; i < p_sizes[l]; i++){\n\t\t\tSystem.out.print(\" \" + prevs[l][i]);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static boolean range_check(int i){\n\t\treturn 0 <= i && i < 3;\n\t}\n\t\n\tpublic static boolean is_goal(int n){\n\t\treturn sizes[0] == n && sizes[1] == 0 && sizes[2] == 0 || sizes[0] == 0 && sizes[1] == 0 && sizes[2] == n;\n\t}\n\t\n\tpublic static int get_list_top(int i){\n\t\tif(!range_check(i)){\n\t\t\treturn 0;\n\t\t}else if(sizes[i] == 0){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn lists[i][sizes[i] - 1];\n\t\t}\n\t}\n\t\n\tpublic static void save_to_prev(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tp_sizes[i] = sizes[i];\n\t\t\t\n\t\t\tfor(int j = 0; j < sizes[i]; j++){\n\t\t\t\tprevs[i][j] = lists[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void restore_from_prev(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tsizes[i] = p_sizes[i];\n\t\t\t\n\t\t\tfor(int j = 0; j < p_sizes[i]; j++){\n\t\t\t\tlists[i][j] = prevs[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean is_same(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tif(sizes[i] != p_sizes[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < sizes[i]; j++){\n\t\t\t\tif(lists[i][j] != prevs[i][j]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static void add_top(int l, int t){\n\t\tlists[l][sizes[l]] = t;\n\t\tsizes[l]++;\n\t}\n\t\n\tpublic static int remove_top(int l){\n\t\tint tmp = get_list_top(l);\n\t\tsizes[l]--;\n\t\t\n\t\treturn tmp;\n\t}\n\t\n\tpublic static void do_move_nocheck(int cur, int pur){\n\t\tadd_top(pur, remove_top(cur));\n\t}\n\t\n\tpublic static boolean can_move(int cur, boolean left){\n\t\tif(!range_check(cur)){\n\t\t\treturn false;\n\t\t}else if(sizes[cur] == 0){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfinal int pur = cur + (left ? -1 : 1);\n\t\tif(!range_check(pur)){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfinal int cur_top = get_list_top(cur);\n\t\tfinal int pur_top = get_list_top(pur);\n\t\t\n\t\tif(cur_top <= pur_top){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tboolean same = false;\n\t\t\n\t\tdo_move_nocheck(cur, pur);\n\t\t\n\t\t\n\t\tif(is_same()){\n\t\t\tsame = true;\n\t\t}\n\t\t\n\t\t\n\t\tdo_move_nocheck(pur, cur);\n\t\t\n\t\tif(same){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static void do_forward_move(int cur, boolean left){\n\t\tfinal int pur = cur + (left ? -1 : 1);\n\t\t\n\t\tdo_move_nocheck(cur, pur);\n\t}\n\t\n\tpublic static void do_backward_move(int cur, boolean left){\n\t\tfinal int pur = cur + (left ? -1 : 1);\n\t\t\n\t\tdo_move_nocheck(pur, cur);\n\t}\n\t\n\tpublic static int dfs(final int n, int deep, final int m){\n\t\tif(deep > m){\n\t\t\treturn INF;\n\t\t}\n\t\t\n\t\tif(is_goal(n)){\n\t\t\t/*\n\t\t\tSystem.out.println(\"--------------------\");\n\t\t\tprint_list(0);\n\t\t\tprint_prev_list(0);\n\t\t\tprint_list(1);\n\t\t\tprint_prev_list(1);\n\t\t\tprint_list(2);\n\t\t\tprint_prev_list(2);\n\t\t\t*/\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t\n\t\tint min = INF;\n\t\t\n\t\tfor(int left = 0; left < 2; left++){\n\t\t\tfor(int cur = 0; cur < 3; cur++){\n\t\t\t\tboolean can = can_move(cur, left == 0);\n\t\t\t\t\n\t\t\t\tif(can){\n\t\t\t\t\tsave_to_prev();\n\t\t\t\t\t\n\t\t\t\t\tdo_forward_move(cur, left == 0);\n\t\t\t\t\tmin = Math.min(min, dfs(n, deep + 1, m));\n\t\t\t\t\tdo_backward_move(cur, left == 0);\n\t\t\t\t\t\n\t\t\t\t\trestore_from_prev();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn min + 1;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tall_clear();\n\t\t\t\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tsizes[i] = sc.nextInt();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < sizes[i]; j++){\n\t\t\t\t\tlists[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//boolean clear = false;\n\t\t\tint count = dfs(n, 0, m);\n\t\t\t\n\t\t\t/*\n\t\t\tfor(count = 0; count <= m; count++){\n\t\t\t\t\n\t\t\t\tSystem.out.println(count + \" : --------------------\");\n\t\t\t\tprint_list(0);\n\t\t\t\tprint_prev_list(0);\n\t\t\t\tprint_list(1);\n\t\t\t\tprint_prev_list(1);\n\t\t\t\tprint_list(2);\n\t\t\t\tprint_prev_list(2);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(is_goal(n)){\n\t\t\t\t\tclear = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean min_left = false;\n\t\t\t\tint min_cur = 0;\n\t\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\t\n\t\t\t\tfor(int left = 0; left < 2; left++){\n\t\t\t\t\tfor(int cur = 0; cur < 3; cur++){\n\t\t\t\t\t\tint ret = move(cur, left == 0, false);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(ret != 0 && ret < min){\n\t\t\t\t\t\t\tmin = ret;\n\t\t\t\t\t\t\tmin_cur = cur;\n\t\t\t\t\t\t\tmin_left = left == 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(min != Integer.MAX_VALUE){\n\t\t\t\t\tmove(min_cur, min_left, true);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"ERROR\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tSystem.out.println(count <= m ? count : -1);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\tLinkedList<Integer>[] cups = new LinkedList[3+2];\n\t\t\tcups[0] = new LinkedList<Integer>();\n\t\t\tcups[4] = new LinkedList<Integer>();\n\t\t\tcups[0].add(30);\n\t\t\tcups[4].add(30);\n\t\t\t\n\t\t\tfor(int i=1;i<=3;i++) {\n\t\t\t\tcups[i] = new LinkedList<Integer>();\n\t\t\t\tcups[i].add(0);\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++) cups[i].add(sc.nextInt());\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\tint pastp = -1, pasti = -1;\n\t\t\tint p, i;\n\t\t\tfor(cnt=0;cnt<=m;cnt++) {\n\t\t\t\ti = 0;\n\t\t\t\tp = 20;\n\t\t\t\tif( cups[1].size() == n+1 || cups[3].size() == n+1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint from = 0;\n\t\t\t\t\n\t\t\t\tfor(int j=1;j<=3;j++) {\n\t\t\t\t\tint left = cups[j-1].getLast();\n\t\t\t\t\tint right = cups[j+1].getLast();\n\t\t\t\t\tint c = cups[j].getLast();\n//\t\t\t\t\tdebug(left, right, c);\n\t\t\t\t\tif( p < c || c == 0 || ( c == 1 && ( j == 1 || j == 3 ) ) ) continue;\n\t\t\t\t\tif( c != pastp && c > left ) {\n\t\t\t\t\t\tp = c;\n\t\t\t\t\t\ti = j-1;\n\t\t\t\t\t\tfrom = j;\n\t\t\t\t\t}\n\t\t\t\t\telse if( c != pastp && c > right ) {\n\t\t\t\t\t\tp = c;\n\t\t\t\t\t\ti = j+1;\n\t\t\t\t\t\tfrom = j;\n\t\t\t\t\t}\n\t\t\t\t\telse if( c == pastp && c > left && pasti != j-1 ) {\n\t\t\t\t\t\tp = c;\n\t\t\t\t\t\ti = j-1;\n\t\t\t\t\t\tfrom = j;\n\t\t\t\t\t}\n\t\t\t\t\telse if( c == pastp && c > right && pasti != j+1 ) {\n\t\t\t\t\t\tp = c;\n\t\t\t\t\t\ti = j+1;\n\t\t\t\t\t\tfrom = j;\n\t\t\t\t\t}\n\t\t\t\t\telse continue;\n//\t\t\t\t\tdebug(\"    \", p, i, from);\n//\t\t\t\t\tdebug(\"    \", pasti, from);\n\t\t\t\t}\n\t\t\t\tcups[i].addLast( cups[from].removeLast() );\n\t\t\t\tpastp = p;\n\t\t\t\tpasti = from;\n//\t\t\t\tfor(LinkedList<Integer> a: cups) debug(a);\n\t\t\t}\n\t\t\tif( cnt <= m ) System.out.println(cnt);\n\t\t\telse System.out.println(-1);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Stack;\n\nclass Main{\n    static int n,m,ans=0;\n    \n    static Stack<Integer> stackA_ini;\n    static Stack<Integer> stackB_ini;\n    static Stack<Integer> stackC_ini;\n    \n    static Stack<Integer> stackA;\n    static Stack<Integer> stackB;\n    static Stack<Integer> stackC;\n    \n    static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    \n    public static void main(String[] a)throws IOException{\n        while(true){\n            inputData();\n            ans = Math.min(calcFromLeft(),calcFromRight());\n            ans = (ans <= m) ? ans : -1;               \n            System.out.println(ans);\n        }\n        \n    }\n    \n    static int calcFromLeft(){\n        int step = 0;\n        \n        //左初動\n        while(true){\n            // 終了判定\n            if(isFinished()) break;\n \n            // 左２つのコップで入れ替え\n            if(peekStack(stackA)>peekStack(stackB))\n                stackB.push(stackA.pop());\n            else\n                stackA.push(stackB.pop());\n            \n            step++;\n            \n            // 終了判定\n            if(isFinished()) break;\n                \n            // 右２つのコップで入れ替え\n            if(peekStack(stackB)>peekStack(stackC))\n                stackC.push(stackB.pop());\n            else\n                stackB.push(stackC.pop());\n            \n            step++;\n        }\n        return step;\n    }\n    \n    static int calcFromRight(){\n        \n        int step = 0;\n        stackA = stackA_ini;\n        stackB = stackB_ini;\n        stackC = stackC_ini;\n                 \n        //右初動\n        while(true){     \n            // 終了判定\n            if(isFinished()) break;\n            \n            // 右２つのコップで入れ替え\n            if(peekStack(stackB)>peekStack(stackC))\n                stackC.push(stackB.pop());\n            else\n                stackB.push(stackC.pop());\n\n            step++;\n            \n            // 終了判定\n            if(isFinished()) break;          \n            \n            // 左２つのコップで入れ替え\n            if(peekStack(stackA)>peekStack(stackB))\n                stackB.push(stackA.pop());\n            else\n                stackA.push(stackB.pop());\n            \n            step++;\n        }\n        return step;\n    }\n      \n    static boolean isFinished(){\n        if(stackB.empty() && (stackA.empty() || stackC.empty()))\n            return true;\n        else\n            return false;\n    }\n    \n    static int peekStack(Stack<Integer> stack){\n        return stack.empty() ? 0:stack.peek();      \n    }\n    \n    static void inputData() throws IOException{\n        \n        String[] nm = in.readLine().split(\" \");\n        String[] cupList;\n        int cupNum = 0;\n\n        stackA = new Stack<Integer>();\n        stackB = new Stack<Integer>();\n        stackC = new Stack<Integer>();\n        stackA_ini = new Stack<Integer>();\n        stackB_ini = new Stack<Integer>();\n        stackC_ini = new Stack<Integer>();\n        \n        n = Integer.parseInt(nm[0]);\n        m = Integer.parseInt(nm[1]);\n        \n        if(n+m == 0){\n            System.exit(0);\n        }\n        \n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackA_ini.push(Integer.parseInt(cupList[j+1]));\n            stackA.push(Integer.parseInt(cupList[j+1]));\n        }\n\n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackB_ini.push(Integer.parseInt(cupList[j+1]));\n            stackB.push(Integer.parseInt(cupList[j+1]));\n        }\n        \n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackC_ini.push(Integer.parseInt(cupList[j+1]));\n            stackC.push(Integer.parseInt(cupList[j+1]));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tclass Hanoi {\n\t\tint N;\n\t\tint forbidden;\n\t\tint[] status, highests;\n\t\tfinal int[] steps = new int[] {-2, -1, 1, 2};\n\n\t\tpublic Hanoi(int n) {\n\t\t\tN = n;\n\t\t\tforbidden = 9;\n\t\t\tstatus = new int[n*3];\n\t\t\tfor (int i = 0 ; i < n ; i++) status[i] = i+1;\n\t\t\thighests = new int[3];\n\t\t\thighests[0] = n;\n\t\t}\n\n\t\tpublic Hanoi(int n, int[] test) {\n\t\t\tN = n;\n\t\t\tforbidden = 9;\n\t\t\tstatus = new int[n*3];\n\t\t\tfor (int i = 0 ; i < n*3 ; i++) status[i] = test[i];\n\t\t\thighests = new int[3];\n\t\t\tupdateHighests();\n\t\t}\n\n\t\tpublic void display() {\n\t\t\tfor (int j = N-1 ; j >= 0 ; j--) {\n\t\t\t\tfor (int i = 0 ; i < 3 ; i++) {\n\t\t\t\t\tSystem.out.print(status[i*N+j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t}\n\t\t\tSystem.out.println(\"---\");\n\t\t}\n\n\t\tpublic int getHighestAt(int position) {\n\t\t\tfor (int j = N-1 ; j >= 0 ; j--) {\n\t\t\t\tif (status[position*N+j] > 0)\n\t\t\t\t\treturn status[position*N+j];\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tpublic int getIdxOfHighestAt(int position) {\n\t\t\tfor (int j = N-1 ; j >= 0 ; j--) {\n\t\t\t\tif (status[position*N+j] > 0)\n\t\t\t\t\treturn position*N+j;\n\t\t\t}\n\t\t\treturn position*N-1;\n\t\t}\n\n\t\tpublic void updateHighests() {\n\t\t\tfor (int i = 0 ; i < 3 ; i++) highests[i] = getHighestAt(i);\n\t\t}\n\n\t\tpublic boolean isFinished() {\n\t\t\tfor (int i = 0 ; i < N ; i++) {\n\t\t\t\tif (status[N+i] != i+1) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic int[] makeMirror() {\n\t\t\tint[] mirror = Arrays.copyOf(status, status.length);\n\t\t\tint temp;\n\t\t\tfor (int i = 0 ; i < N ; i++) {\n\t\t\t\ttemp = mirror[i]; mirror[i] = mirror[N*2+i]; mirror[N*2+i] = temp;\n\t\t\t}\n\t\t\treturn mirror;\n\t\t}\n\n\t\tpublic boolean equalsWithMirror(Hanoi target) {\n\t\t\tif (Arrays.equals(target.status, status)) return true;\n\t\t\tif (Arrays.equals(target.status, makeMirror())) return true;\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic void move(int step) {\n\t\t\tint ia, ib;\n\t\t\tswitch (step) {\n\t\t\tcase 1: //0->1\n\t\t\t\tia = getIdxOfHighestAt(0);\n\t\t\t\tib = getIdxOfHighestAt(1);\n\t\t\t\tstatus[ib+1] = status[ia]; status[ia] = 0;\n\t\t\t\tforbidden = -1;\n\t\t\t\treturn;\n\t\t\tcase -1: //0<-1\n\t\t\t\tia = getIdxOfHighestAt(1);\n\t\t\t\tib = getIdxOfHighestAt(0);\n\t\t\t\tstatus[ib+1] = status[ia]; status[ia] = 0;\n\t\t\t\tforbidden = 1;\n\t\t\t\treturn;\n\t\t\tcase 2: //1->2\n\t\t\t\tia = getIdxOfHighestAt(1);\n\t\t\t\tib = getIdxOfHighestAt(2);\n\t\t\t\tstatus[ib+1] = status[ia]; status[ia] = 0;\n\t\t\t\tforbidden = -2;\n\t\t\t\treturn;\n\t\t\tcase -2: //1<-2\n\t\t\t\tia = getIdxOfHighestAt(2);\n\t\t\t\tib = getIdxOfHighestAt(1);\n\t\t\t\tstatus[ib+1] = status[ia]; status[ia] = 0;\n\t\t\t\tforbidden = 2;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tpublic void moveNext() {\n\t\t\t// +1:0->1, -1:0<-1, +2:1->2, -2:1<-2\n\t\t\tupdateHighests();\n\t\t\tfor (int step : steps) {\n\t\t\t\tif (step == forbidden) continue;\n\t\t\t\tswitch (step) {\n\t\t\t\tcase -2: // 1<-2\n\t\t\t\t\tif (highests[1] < highests[2]) { move(-2); return; }\n\t\t\t\t\tbreak;\n\t\t\t\tcase -1: // 0<-1\n\t\t\t\t\tif (highests[0] < highests[1]) { move(-1); return; }\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1: // 0->1\n\t\t\t\t\tif (highests[0] > highests[1]) { move(1); return; }\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2: // 1->2\n\t\t\t\t\tif (highests[1] > highests[2]) { move(2); return; }\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tMain m = new Main();\n\n\t\tboolean loop = true;\n\t\twhile (loop) {\n\t\t\tint N = sc.nextInt(), M = sc.nextInt();\n\t\t\tif (N == 0 && M == 0) { loop = false; continue; } // 終了条件\n\n\t\t\t// 読み込み\n\t\t\tint[] array = new int[N*3];\n\t\t\tfor (int i = 0 ; i < 3 ; i++) {\n\t\t\t\tint size = sc.nextInt();\n\t\t\t\tfor (int j = 0 ; j < size ; j++) {\n\t\t\t\t\tarray[i*N+j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// スタートとゴールの生成\n\t\t\tHanoi hanoi = m.new Hanoi(N);\n\t\t\tHanoi goal = m.new Hanoi(N, array);\n\n\t\t\t// 探索\n\t\t\tint step = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (step > M) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (hanoi.equalsWithMirror(goal)) {\n\t\t\t\t\t//hanoi.display();\n\t\t\t\t\t//System.out.println(\"---\\n\"+step);\n\t\t\t\t\tSystem.out.println(step);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//hanoi.display();\n\t\t\t\thanoi.moveNext(); step++;\n\t\t\t}\n\n\t\t}\n\n\n\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint[] pow3 = new int[n + 1];\n\t\t\tpow3[0] = 1;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tpow3[i] = pow3[i - 1] * 3;\n\t\t\tint[] c = new int[n];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tint a = scanner.nextInt();\n\t\t\t\tfor (int j = a; j > 0; j--) {\n\t\t\t\t\tint k = scanner.nextInt();\n\t\t\t\t\tc[n - k] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint p = 0;\n\t\t\tint x = 0;\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tint d = Math.abs(p - c[i]);\n\t\t\t\tx += pow3[i] * d;\n\t\t\t\tif (d == 1)\n\t\t\t\t\tp = 2 - p;\n\t\t\t}\n\t\t\tint y = pow3[n] - 1 - x;\n\t\t\tif (x > y)\n\t\t\t\tx = y;\n\t\t\tSystem.out.println(x > m ? -1 : x);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport static java.lang.Integer.*;\nimport java.util.Stack;\n\nclass Main{\n    static int n,m,ans=0;\n    \n    static Stack<Integer> stackA_ini;\n    static Stack<Integer> stackB_ini;\n    static Stack<Integer> stackC_ini;\n    \n    static Stack<Integer> stackA;\n    static Stack<Integer> stackB;\n    static Stack<Integer> stackC;\n    \n    public static void main(String[] a)throws IOException{\n        while(true){\n            inputData();\n            ans = (int)min(calcFromLeft(),calcFromRight());\n            ans = (ans <= m) ? ans : -1;               \n            System.out.println(ans);\n        }\n        \n    }\n    static int calcFromLeft(){\n        int step = 0;\n        initializeStack();\n        \n        //左初動\n        while(true){\n            // 終了判定\n            if(isFinished()) break;\n \n            // 左２つのコップで入れ替え\n            if(peekStack(stackA)>peekStack(stackB))\n                stackB.push(stackA.pop());\n            else\n                stackA.push(stackB.pop());\n            \n            step++;\n            \n            // 終了判定\n            if(isFinished()) break;\n                \n            // 右２つのコップで入れ替え\n            if(peekStack(stackB)>peekStack(stackC))\n                stackC.push(stackB.pop());\n            else\n                stackB.push(stackC.pop());\n            \n            step++;\n        }\n        return step;\n    }\n    static int calcFromRight(){\n        \n        int step = 0;\n        initializeStack();\n                \n        //右初動\n        while(true){     \n            // 終了判定\n            if(isFinished()) break;\n            \n            // 右２つのコップで入れ替え\n            if(peekStack(stackB)>peekStack(stackC))\n                stackC.push(stackB.pop());\n            else\n                stackB.push(stackC.pop());\n\n            step++;\n            \n            // 終了判定\n            if(isFinished()) break;          \n            \n            // 左２つのコップで入れ替え\n            if(peekStack(stackA)>peekStack(stackB))\n                stackB.push(stackA.pop());\n            else\n                stackA.push(stackB.pop());\n            \n            step++;\n        }\n        return step;\n    }\n    \n    static void initializeStack(){\n        stackA = (Stack<Integer>) stackA_ini.clone();\n        stackB = (Stack<Integer>) stackB_ini.clone();\n        stackC = (Stack<Integer>) stackC_ini.clone();\n    }\n    \n    static boolean isFinished(){\n        if(stackB.empty() && (stackA.empty() || stackC.empty()))\n            return true;\n        else\n            return false;\n    }\n    static int peekStack(Stack<Integer> stack){\n        return stack.empty() ? 0:stack.peek();      \n    }\n    \n    static void inputData() throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String[] nm = in.readLine().split(\" \");\n        String[] cupList;\n        int cupNum = 0;\n\n        stackA.clear();\n        stackB.clear();\n        stackC.clear();\n        \n        n = Integer.parseInt(nm[0]);\n        m = Integer.parseInt(nm[1]);\n        \n        if(n+m == 0){\n            System.exit(0);\n        }\n        \n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackA_ini.push(Integer.parseInt(cupList[j+1]));\n        }\n\n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackB_ini.push(Integer.parseInt(cupList[j+1]));\n        }\n        \n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackC_ini.push(Integer.parseInt(cupList[j+1]));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n==0 && m==0) break;\n\t\t\t\n\t\t\tint[] a = new int[n+1];\n\t\t\tint[] b = new int[n+1];\n\t\t\tint[] c = new int[n+1];\n\t\t\tint[] d = new int[n+1];\n\t\t\tint[] e = new int[n+1];\n\t\t\tint[] f = new int[n+1];\n\t\t\t\n\t\t\tint an = 0, bn = 0, cn = 0, dn = 0, en = 0, fn = 0;\n\t\t\t\n\t\t\tdn = sc.nextInt();\n\t\t\tfor(int i=1;i<=dn;i++) d[i] = sc.nextInt();\n\t\t\ten = sc.nextInt();\n\t\t\tfor(int i=1;i<=en;i++) e[i] = sc.nextInt();\n\t\t\tfn = sc.nextInt();\n\t\t\tfor(int i=1;i<=fn;i++) f[i] = sc.nextInt();\n\t\t\t\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\tint[] ini = new int[2];\n\t\t\tint com;\n\t\t\t\n\t\t\tif(d[dn]>e[en] && e[en]>f[fn]){\n\t\t\t\tini[0] = 0;\n\t\t\t\tini[1] = 2;\n\t\t\t}else if(d[dn]>e[en] && e[en]<f[fn]){\n\t\t\t\tini[0] = 0;\n\t\t\t\tini[1] = 3;\n\t\t\t}else if(d[dn]<e[en] && e[en]<f[fn]){\n\t\t\t\tini[0] = 1;\n\t\t\t\tini[1] = 3;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\tcom = ini[k];\n\t\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\t\ta[i] = d[i];\n\t\t\t\t\tb[i] = e[i];\n\t\t\t\t\tc[i] = f[i];\n\t\t\t\t}\n\t\t\t\tan = dn;\n\t\t\t\tbn = en;\n\t\t\t\tcn = fn;\n\t\t\t\tfor(int i=0;i<=m;i++){\n\t\t\t\t\tif(bn==0 && (an==0 || cn==0)){\n\t\t\t\t\t\tans = Math.min(ans, i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(com==0){\n\t\t\t\t\t\tbn++;\n\t\t\t\t\t\tb[bn] = a[an];\n\t\t\t\t\t\tan--;\n\t\t\t\t\t\tif(b[bn]>c[cn]) com = 2;\n\t\t\t\t\t\telse com = 3;\n\t\t\t\t\t}else if(com==1){\n\t\t\t\t\t\tan++;\n\t\t\t\t\t\ta[an] = b[bn];\n\t\t\t\t\t\tbn--;\n\t\t\t\t\t\tif(b[bn]>c[cn]) com = 2;\n\t\t\t\t\t\telse com = 3;\n\t\t\t\t\t}else if(com==2){\n\t\t\t\t\t\tcn++;\n\t\t\t\t\t\tc[cn] = b[bn];\n\t\t\t\t\t\tbn--;\n\t\t\t\t\t\tif(a[an]>b[bn]) com = 0;\n\t\t\t\t\t\telse com = 1;\n\t\t\t\t\t}else if(com==3){\n\t\t\t\t\t\tbn++;\n\t\t\t\t\t\tb[bn] = c[cn];\n\t\t\t\t\t\tcn--;\n\t\t\t\t\t\tif(a[an]>b[bn]) com = 0;\n\t\t\t\t\t\telse com = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ans==Integer.MAX_VALUE) System.out.println(-1);\n\t\t\telse System.out.println(ans);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.math.BigInteger;\n      \npublic class Main{\n  \nstatic final InputStream in=System.in;\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic final long LINF=Long.MAX_VALUE/2;\nstatic int n,m,a,b,c;\nstatic Deque<Integer> queA,queB,queC;\n  \npublic static void main(String[] args) throws IOException{\nInputReader ir=new InputReader(in);\nwhile(true){\nn=ir.nextInt();\nm=ir.nextInt();\nif(n==0&&m==0) break;\nqueA=new ArrayDeque<Integer>();\nqueB=new ArrayDeque<Integer>();\nqueC=new ArrayDeque<Integer>();\na=ir.nextInt();\nfor(int i=0;i<a;i++) queA.offerFirst(ir.nextInt());\nb=ir.nextInt();\nfor(int i=0;i<b;i++) queB.offerFirst(ir.nextInt());\nc=ir.nextInt();\nfor(int i=0;i<c;i++) queC.offerFirst(ir.nextInt());\nint ans=dfs(0);\nout.println(ans>m?-1:ans);\n}\nout.flush();\n}\n\npublic static int dfs(int depth){\nif(depth>m) return depth;\nif(queA.size()==n||queC.size()==n) return depth;\nint s,t,u,v;\nif(!queA.isEmpty()&&(queB.isEmpty()||queA.peekFirst()>queB.peekFirst())){\nint temp=queA.pollFirst();\nqueB.offerFirst(temp);\ns=dfs(depth+1);\nqueB.pollFirst();\nqueA.offerFirst(temp);\n}\nif(!queC.isEmpty()&&(queB.isEmpty()||queC.peekFirst()>queB.peekFirst())){\nint temp=queC.pollFirst();\nqueB.offerFirst(temp);\nt=dfs(depth+1);\nqueB.pollFirst();\nqueC.offerFirst(temp);\n}\nif(!queB.isEmpty()&&(queA.isEmpty()||queB.peekFirst()>queA.peekFirst())){\nint temp=queB.pollFirst();\nqueA.offerFirst(temp);\nu=dfs(depth+1);\nqueA.pollFirst(temp);\nqueB.offerFirst(temp);\n}\nif(!queB.isEmpty()&&(queC.isEmpty()||queB.peekFirst()>queC.peekFirst())){\nint temp=queB.pollFirst();\nqueC.offerFirst(temp);\nv=dfs(depth+1);\nqueC.pollFirst(temp);\nqueB.offerFirst(temp);\n}\nreturn Math.min(Math.min(s,t),Math.min(u,v));\n}\n\nstatic class InputReader {\nprivate InputStream in;\nprivate byte[] buffer=new byte[1024];\nprivate int curbuf;\nprivate int lenbuf;\n  \npublic InputReader(InputStream in) {this.in=in;}\n    \npublic int readByte() {\nif(lenbuf==-1) throw new InputMismatchException();\nif(curbuf>=lenbuf){\ncurbuf= 0;\ntry{\nlenbuf=in.read(buffer);\n}\ncatch (IOException e) {\nthrow new InputMismatchException();\n}\nif(lenbuf<=0)\nreturn -1;\n}\nreturn buffer[curbuf++];\n}\n  \npublic boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \nprivate int skip() {int b; while((b = readByte())!=-1&&isSpaceChar(b)); return b;}\n  \npublic String next() {\nint b=skip();\nStringBuilder sb=new StringBuilder();\nwhile(!isSpaceChar(b)){\nsb.appendCodePoint(b);\nb=readByte();\n}\nreturn sb.toString();\n}\n   \npublic int nextInt() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nint res=0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic long nextLong() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nlong res = 0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic int[] toIntArray(int n){\nint[] a=new int[n];\nfor(int i=0;i<n;i++) a[i]=nextInt();\nreturn a;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.math.BigInteger;\nimport java.math.BigDecimal;\n      \npublic class Main{\n  \nstatic final InputStream in=System.in;\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic final long LINF=Long.MAX_VALUE/2;\nstatic int n,m,a,b,c;\nstatic Deque<Integer> queA,queB,queC;\n  \npublic static void main(String[] args) throws IOException{\nInputReader ir=new InputReader(in);\nwhile(true){\nn=ir.nextInt();\nm=ir.nextInt();\nif(n==0&&m==0) break;\nqueA=new ArrayDeque<Integer>();\nqueB=new ArrayDeque<Integer>();\nqueC=new ArrayDeque<Integer>();\na=ir.nextInt();\nfor(int i=0;i<a;i++) queA.offerFirst(ir.nextInt());\nb=ir.nextInt();\nfor(int i=0;i<b;i++) queB.offerFirst(ir.nextInt());\nc=ir.nextInt();\nfor(int i=0;i<c;i++) queC.offerFirst(ir.nextInt());\nint ans=dfs(0,0);\nout.println(ans>m?-1:ans);\n}\nout.flush();\n}\n\npublic static int dfs(int depth,int prev){\nif(depth>m||queA.size()==n||queC.size()==n) return depth;\nint s=m+1,t=m+1,u=m+1,v=m+1;\nif(prev!=3&&!queA.isEmpty()&&(queB.isEmpty()||queA.peekFirst()>queB.peekFirst())){\nint temp=queA.pollFirst();\nqueB.offerFirst(temp);\ns=dfs(depth+1,1);\nqueB.pollFirst();\nqueA.offerFirst(temp);\n}\nif(prev!=4&&!queC.isEmpty()&&(queB.isEmpty()||queC.peekFirst()>queB.peekFirst())){\nint temp=queC.pollFirst();\nqueB.offerFirst(temp);\nt=dfs(depth+1,2);\nqueB.pollFirst();\nqueC.offerFirst(temp);\n}\nif(!queB.isEmpty()){\nif(prev!=1){\nif(queA.isEmpty()){\nint temp=queB.pollFirst();\nqueA.offerFirst(temp);\nu=dfs(depth+1,3);\nqueA.pollFirst();\nqueB.offerFirst(temp);\n}\nelse if(queB.peekFirst()>queA.peekFirst()){\nint temp=queB.pollFirst();\nqueA.offerFirst(temp);\nu=dfs(depth+1,3);\nqueA.pollFirst();\nqueB.offerFirst(temp);\n}\n}\nif(prev!=2){\nif(queC.isEmpty()){\nint temp=queB.pollFirst();\nqueC.offerFirst(temp);\nv=dfs(depth+1,4);\nqueC.pollFirst();\nqueB.offerFirst(temp);\n}\nelse if(queB.peekFirst()>queC.peekFirst()){\nint temp=queB.pollFirst();\nqueC.offerFirst(temp);\nv=dfs(depth+1,4);\nqueC.pollFirst();\nqueB.offerFirst(temp);\n}\n}\n}\n}\nreturn Math.min(Math.min(s,t),Math.min(u,v));\n}\n\nstatic class InputReader {\nprivate InputStream in;\nprivate byte[] buffer=new byte[1024];\nprivate int curbuf;\nprivate int lenbuf;\n  \npublic InputReader(InputStream in) {this.in=in;}\n    \npublic int readByte() {\nif(lenbuf==-1) throw new InputMismatchException();\nif(curbuf>=lenbuf){\ncurbuf= 0;\ntry{\nlenbuf=in.read(buffer);\n}\ncatch (IOException e) {\nthrow new InputMismatchException();\n}\nif(lenbuf<=0)\nreturn -1;\n}\nreturn buffer[curbuf++];\n}\n  \npublic boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \nprivate int skip() {int b; while((b = readByte())!=-1&&isSpaceChar(b)); return b;}\n  \npublic String next() {\nint b=skip();\nStringBuilder sb=new StringBuilder();\nwhile(!isSpaceChar(b)){\nsb.appendCodePoint(b);\nb=readByte();\n}\nreturn sb.toString();\n}\n   \npublic int nextInt() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nint res=0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic long nextLong() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nlong res = 0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic int[] toIntArray(int n){\nint[] a=new int[n];\nfor(int i=0;i<n;i++) a[i]=nextInt();\nreturn a;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.math.BigInteger;\n      \npublic class Main{\n  \nstatic final InputStream in=System.in;\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic final long LINF=Long.MAX_VALUE/2;\nstatic int n,m,a,b,c;\nstatic Deque<Integer> queA,queB,queC;\n  \npublic static void main(String[] args) throws IOException{\nInputReader ir=new InputReader(in);\nwhile(true){\nn=ir.nextInt();\nm=ir.nextInt();\nif(n==0&&m==0) break;\nqueA=new ArrayDeque<Integer>();\nqueB=new ArrayDeque<Integer>();\nqueC=new ArrayDeque<Integer>();\na=ir.nextInt();\nfor(int i=0;i<a;i++) queA.offerFirst(ir.nextInt());\nb=ir.nextInt();\nfor(int i=0;i<b;i++) queB.offerFirst(ir.nextInt());\nc=ir.nextInt();\nfor(int i=0;i<c;i++) queC.offerFirst(ir.nextInt());\nint ans=dfs(0);\nout.println(ans>m?-1:ans);\n}\nout.flush();\n}\n\npublic static int dfs(int depth){\nif(depth>m) return depth;\nif(queA.size()==n||queC.size()==n) return depth;\nint s,t,u,v;\nif(!queA.isEmpty()&&(queB.isEmpty()||queA.peekFirst()>queB.peekFirst())){\nint temp=queA.pollFirst();\nqueB.offerFirst(temp);\ns=dfs(depth+1);\nqueB.pollFirst();\nqueA.offerFirst(temp);\n}\nif(!queC.isEmpty()&&(queB.isEmpty()||queC.peekFirst()>queB.peekFirst())){\nint temp=queC.pollFirst();\nqueB.offerFirst(temp);\nt=dfs(depth+1);\nqueB.pollFirst();\nqueC.offerFirst(temp);\n}\nif(!queB.isEmpty()&&(queA.isEmpty()||queB.peekFirst()>queA.peekFirst())){\nint temp=queB.pollFirst();\nqueA.offerFirst(temp);\nu=dfs(depth+1);\nqueA.pollFirst();\nqueB.offerFirst(temp);\n}\nif(!queB.isEmpty()&&(queC.isEmpty()||queB.peekFirst()>queC.peekFirst())){\nint temp=queB.pollFirst();\nqueC.offerFirst(temp);\nv=dfs(depth+1);\nqueC.pollFirst();\nqueB.offerFirst(temp);\n}\nreturn Math.min(Math.min(s,t),Math.min(u,v));\n}\n\nstatic class InputReader {\nprivate InputStream in;\nprivate byte[] buffer=new byte[1024];\nprivate int curbuf;\nprivate int lenbuf;\n  \npublic InputReader(InputStream in) {this.in=in;}\n    \npublic int readByte() {\nif(lenbuf==-1) throw new InputMismatchException();\nif(curbuf>=lenbuf){\ncurbuf= 0;\ntry{\nlenbuf=in.read(buffer);\n}\ncatch (IOException e) {\nthrow new InputMismatchException();\n}\nif(lenbuf<=0)\nreturn -1;\n}\nreturn buffer[curbuf++];\n}\n  \npublic boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \nprivate int skip() {int b; while((b = readByte())!=-1&&isSpaceChar(b)); return b;}\n  \npublic String next() {\nint b=skip();\nStringBuilder sb=new StringBuilder();\nwhile(!isSpaceChar(b)){\nsb.appendCodePoint(b);\nb=readByte();\n}\nreturn sb.toString();\n}\n   \npublic int nextInt() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nint res=0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic long nextLong() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nlong res = 0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic int[] toIntArray(int n){\nint[] a=new int[n];\nfor(int i=0;i<n;i++) a[i]=nextInt();\nreturn a;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.math.BigInteger;\nimport java.math.BigDecimal;\n      \npublic class Main{\n  \nstatic final InputStream in=System.in;\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic final long LINF=Long.MAX_VALUE/2;\nstatic int n,m,a,b,c;\nstatic Deque<Integer> queA,queB,queC;\n  \npublic static void main(String[] args) throws IOException{\nInputReader ir=new InputReader(in);\nwhile(true){\nn=ir.nextInt();\nm=ir.nextInt();\nif(n==0&&m==0) break;\nqueA=new ArrayDeque<Integer>();\nqueB=new ArrayDeque<Integer>();\nqueC=new ArrayDeque<Integer>();\na=ir.nextInt();\nfor(int i=0;i<a;i++) queA.offerFirst(ir.nextInt());\nb=ir.nextInt();\nfor(int i=0;i<b;i++) queB.offerFirst(ir.nextInt());\nc=ir.nextInt();\nfor(int i=0;i<c;i++) queC.offerFirst(ir.nextInt());\nint ans=dfs(0,0);\nout.println(ans>m?-1:ans);\n}\nout.flush();\n}\n\npublic static int dfs(int depth,int prev){\nif(depth>m||queA.size()==n||queC.size()==n) return depth;\nint s=m+1,t=m+1,u=m+1,v=m+1;\nif(prev!=3&&!queA.isEmpty()){\nif(queB.isEmpty()||(!queB.isEmpty()&&queA.peekFirst()>queB.peekFirst())){\nint temp=queA.pollFirst();\nqueB.offerFirst(temp);\ns=dfs(depth+1,1);\nqueB.pollFirst();\nqueA.offerFirst(temp);\n}\n}\nif(prev!=4&&!queC.isEmpty()){\nif(queB.isEmpty()||(!queB.isEmpty()&&queC.peekFirst()>queB.peekFirst())){\nint temp=queC.pollFirst();\nqueB.offerFirst(temp);\nt=dfs(depth+1,2);\nqueB.pollFirst();\nqueC.offerFirst(temp);\n}\n}\nif(!queB.isEmpty()){\nif(prev!=1){\nif(queA.isEmpty()){\nint temp=queB.pollFirst();\nqueA.offerFirst(temp);\nu=dfs(depth+1,3);\nqueA.pollFirst();\nqueB.offerFirst(temp);\n}\nelse if(queB.peekFirst()>queA.peekFirst()){\nint temp=queB.pollFirst();\nqueA.offerFirst(temp);\nu=dfs(depth+1,3);\nqueA.pollFirst();\nqueB.offerFirst(temp);\n}\n}\nif(prev!=2){\nif(queC.isEmpty()){\nint temp=queB.pollFirst();\nqueC.offerFirst(temp);\nv=dfs(depth+1,4);\nqueC.pollFirst();\nqueB.offerFirst(temp);\n}\nelse if(queB.peekFirst()>queC.peekFirst()){\nint temp=queB.pollFirst();\nqueC.offerFirst(temp);\nv=dfs(depth+1,4);\nqueC.pollFirst();\nqueB.offerFirst(temp);\n}\n}\n}\nreturn Math.min(Math.min(s,t),Math.min(u,v));\n}\n\nstatic class InputReader {\nprivate InputStream in;\nprivate byte[] buffer=new byte[1024];\nprivate int curbuf;\nprivate int lenbuf;\n  \npublic InputReader(InputStream in) {this.in=in;}\n    \npublic int readByte() {\nif(lenbuf==-1) throw new InputMismatchException();\nif(curbuf>=lenbuf){\ncurbuf= 0;\ntry{\nlenbuf=in.read(buffer);\n}\ncatch (IOException e) {\nthrow new InputMismatchException();\n}\nif(lenbuf<=0)\nreturn -1;\n}\nreturn buffer[curbuf++];\n}\n  \npublic boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \nprivate int skip() {int b; while((b = readByte())!=-1&&isSpaceChar(b)); return b;}\n  \npublic String next() {\nint b=skip();\nStringBuilder sb=new StringBuilder();\nwhile(!isSpaceChar(b)){\nsb.appendCodePoint(b);\nb=readByte();\n}\nreturn sb.toString();\n}\n   \npublic int nextInt() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nint res=0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic long nextLong() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nlong res = 0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic int[] toIntArray(int n){\nint[] a=new int[n];\nfor(int i=0;i<n;i++) a[i]=nextInt();\nreturn a;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    public static void main(String[] args){\n        Scanner in = new Scanner(System.in);\n        int[] pow3 = new int[16], c = new int[16];\n        int n, m, i, j, k, d, x, y, p;\n        pow3[0] = 1;\n        for(i = 1; i <= 15; ++i)\n        {\n        pow3[i] = pow3[i-1] * 3;\n        }\n        while(true){\n            n = in.nextInt();\n            m = in.nextInt();\n            if(n == 0 && m == 0)break;\n            for(i = 0;i<3;i++){\n                for(j = in.nextInt(); j > 0; --j){\n                    k = in.nextInt();\n                    c[n-k] = i;\n                }\n            }\n            \n            p = 0;\n            x = 0;\n            for(i = n - 1; i >= 0; --i){\n                d = Math.abs(p - c[i]);\n                x += pow3[i] * d;\n                if(d == 1) p = 2 - p;\n            }\n            y = pow3[n] - 1 - x;\n            if(x > y) x = y;\n            if(m < x) System.out.println(\"-1\");\n            else System.out.println(x);\n        }\n        in.close();\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\tLinkedList<Integer>[] cups = new LinkedList[3+2];\n\t\t\tcups[0] = new LinkedList<Integer>();\n\t\t\tcups[4] = new LinkedList<Integer>();\n\t\t\tcups[0].add(30);\n\t\t\tcups[4].add(30);\n\t\t\t\n\t\t\tfor(int i=1;i<=3;i++) {\n\t\t\t\tcups[i] = new LinkedList<Integer>();\n\t\t\t\tcups[i].add(0);\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++) cups[i].add(sc.nextInt());\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\tint pastp = -1, pasti = -1;\n\t\t\tint p, i;\n\t\t\tfor(cnt=0;cnt<=m;cnt++) {\n\t\t\t\ti = 0;\n\t\t\t\tp = 20;\n\t\t\t\tif( cups[1].size() == n+1 || cups[3].size() == n+1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint from = 0;\n\t\t\t\t\n\t\t\t\tfor(int j=1;j<=3;j++) {\n\t\t\t\t\tint left = cups[j-1].getLast();\n\t\t\t\t\tint right = cups[j+1].getLast();\n\t\t\t\t\tint c = cups[j].getLast();\n//\t\t\t\t\tdebug(left, right, c);\n\t\t\t\t\tif( p < c || c == 0 || ( c == 1 && ( j == 1 || j == 3 ) ) ) continue;\n\t\t\t\t\tif( c != pastp && c > left ) {\n\t\t\t\t\t\tp = c;\n\t\t\t\t\t\ti = j-1;\n\t\t\t\t\t\tfrom = j;\n\t\t\t\t\t}\n\t\t\t\t\telse if( c != pastp && c > right ) {\n\t\t\t\t\t\tp = c;\n\t\t\t\t\t\ti = j+1;\n\t\t\t\t\t\tfrom = j;\n\t\t\t\t\t}\n\t\t\t\t\telse if( c == pastp && c > left && pasti != j-1 ) {\n\t\t\t\t\t\tp = c;\n\t\t\t\t\t\ti = j-1;\n\t\t\t\t\t\tfrom = j;\n\t\t\t\t\t}\n\t\t\t\t\telse if( c == pastp && c > right && pasti != j+1 ) {\n\t\t\t\t\t\tp = c;\n\t\t\t\t\t\ti = j+1;\n\t\t\t\t\t\tfrom = j;\n\t\t\t\t\t}\n\t\t\t\t\telse continue;\n//\t\t\t\t\tdebug(\"    \", p, i, from);\n//\t\t\t\t\tdebug(\"    \", pasti, from);\n\t\t\t\t}\n\t\t\t\tcups[i].addLast( cups[from].removeLast() );\n\t\t\t\tpastp = p;\n\t\t\t\tpasti = from;\n//\t\t\t\tfor(LinkedList<Integer> a: cups) debug(a);\n\t\t\t}\n\t\t\tif( cnt <= m ) System.out.println(cnt);\n\t\t\telse System.out.println(-1);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nenum OPERATION {\n\tA_TO_B,\n\tB_TO_A,\n\tB_TO_C,\n\tC_TO_B,\n\tFIRST_STEP\n}\n\npublic class Main {\n\tstatic public void main(String[] argv) {\n\t\ttry{\n//\t\t\tFileReader file_in = new FileReader(\"test.txt\");\n//\t\t\tBufferedReader d = new BufferedReader( file_in );\n\t\t\tBufferedReader d = new BufferedReader(new InputStreamReader(System.in));\n\t\n\t\t\twhile(true) {\n\t\t\t\tString buf = d.readLine();\n\t\t\t\tStringTokenizer st = new StringTokenizer(buf);\n\t\t\t\tint n = Integer.valueOf(st.nextToken());\n\t\t\t\tint m = Integer.valueOf(st.nextToken());\n\t\t\t\tif( n == 0 && m == 0 ) break;\n\t\t\t\t\n\t\t\t\tCup cup_1 = new Cup(n, m);\n\t\t\t\tCup cup_2 = new Cup(n, m);\n\t\t\t\t\n\t\t\t\tbuf = d.readLine();\n\t\t\t\tcup_1.setTrayA(buf);\n\t\t\t\tcup_2.setTrayA(buf);\n\t\t\t\t\n\t\t\t\tbuf = d.readLine();\n\t\t\t\tcup_1.setTrayB(buf);\n\t\t\t\tcup_2.setTrayB(buf);\n\t\t\t\t\n\t\t\t\tbuf = d.readLine();\n\t\t\t\tcup_1.setTrayC(buf);\n\t\t\t\tcup_2.setTrayC(buf);\n\t\t\t\t\n\t\t\t\tif( cup_1.isEnd() ) {\n\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint op_type = cup_1.getOperationAvailable();\n\t\t\t\tOPERATION op_1, op_2;\n\t\t\t\tswitch(op_type) {\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\top_1 = OPERATION.B_TO_A;\n\t\t\t\t\t\top_2 = OPERATION.C_TO_B;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\top_1 = OPERATION.A_TO_B;\n\t\t\t\t\t\top_2 = OPERATION.C_TO_B;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 9:\n\t\t\t\t\t\top_1 = OPERATION.B_TO_A;\n\t\t\t\t\t\top_2 = OPERATION.B_TO_C;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 10:\n\t\t\t\t\t\top_1 = OPERATION.A_TO_B;\n\t\t\t\t\t\top_2 = OPERATION.B_TO_C;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tSystem.out.println(\"error: invalid op.\");\n\t\t\t\t\t\top_1 = OPERATION.A_TO_B;\n\t\t\t\t\t\top_2 = OPERATION.A_TO_B;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcup_1.setPrevOp(op_1);\n\t\t\t\tcup_2.setPrevOp(op_2);\n\t\t\t\t\n\n//\t\t\t\tSystem.out.println( \"=====solve1=====\" );\n\t\t\t\tint ret_1 = cup_1.solve();\n//\t\t\t\tSystem.out.println( \"=====solve2=====\" );\n\t\t\t\tint ret_2 = cup_2.solve();\n\t\t\t\n//\t\t\t\tSystem.out.println( ret_1 + \", \" + ret_2 );\n\n\t\t\t\tif( ret_1 < 0 && ret_2 < 0 ) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t} else if(ret_1 >= 0 && ret_2 < 0) {\n\t\t\t\t\tSystem.out.println(ret_1);\n\t\t\t\t} else if(ret_1 < 0 && ret_2 >= 0) {\n\t\t\t\t\tSystem.out.println(ret_2);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println( ret_1 < ret_2 ? ret_1 : ret_2 );\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\nclass Cup {\n\tprivate int _num;\n\tprivate int _max;\n\tprivate Stack<Integer> _tray_a;\n\tprivate Stack<Integer> _tray_b;\n\tprivate Stack<Integer> _tray_c;\n\tprivate OPERATION _prev_op;\n\t\n\tpublic Cup(int num, int max) {\n\t\t_num = num;\n\t\t_max = max;\n\t\t_tray_a = new Stack<Integer>();\n\t\t_tray_b = new Stack<Integer>();\n\t\t_tray_c = new Stack<Integer>();\n\t\t_prev_op = OPERATION.FIRST_STEP;\n\t}\n\n\tpublic void setPrevOp(OPERATION op) { _prev_op = op; }\n\t\n\tpublic boolean isEnd() {\n\t\treturn _tray_a.size() == _num || _tray_c.size() == _num;\n\t}\n\t\n\tpublic void setTrayA(String str) {\n\t\t_tray_a = createTray(str);\n\t}\n\tpublic void setTrayB(String str) {\n\t\t_tray_b = createTray(str);\n\t}\n\tpublic void setTrayC(String str) {\n\t\t_tray_c = createTray(str);\n\t}\n\t\n\tprivate Stack<Integer> createTray(String str) {\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\tStringTokenizer st = new StringTokenizer(str);\n\t\tint num = Integer.valueOf(st.nextToken());\n\t\tfor(int i = 0; i < num; i++) {\n\t\t\tInteger e = new Integer(st.nextToken());\n\t\t\tstack.push( e );\n\t\t}\n\t\treturn stack;\n\t}\n\t\n\tpublic void operate() {\n\t\tint top_a = ( _tray_a.empty() ) ? 0 : _tray_a.get( _tray_a.size()-1 );\n\t\tint top_b = ( _tray_b.empty() ) ? 0 : _tray_b.get( _tray_b.size()-1 );\n\t\tint top_c = ( _tray_c.empty() ) ? 0 : _tray_c.get( _tray_c.size()-1 );\n\t\tif( top_a > top_b && _prev_op != OPERATION.B_TO_A ) {\n\t\t\t_tray_b.push( _tray_a.pop() );\n\t\t\t_prev_op = OPERATION.A_TO_B;\n\t\t} else if( top_b > top_a && _prev_op != OPERATION.A_TO_B ) {\n\t\t\t_tray_a.push( _tray_b.pop() );\n\t\t\t_prev_op = OPERATION.B_TO_A;\n\t\t} else if( top_b > top_c && _prev_op != OPERATION.C_TO_B ) {\n\t\t\t_tray_c.push( _tray_b.pop() );\n\t\t\t_prev_op = OPERATION.B_TO_C;\n\t\t} else if( top_c > top_b && _prev_op != OPERATION.B_TO_C ) {\n\t\t\t_tray_b.push( _tray_c.pop() );\n\t\t\t_prev_op = OPERATION.C_TO_B;\n\t\t}\n\t}\n\t\n\tpublic int solve() {\n\t\tboolean isImpossible = true;\n\t\tint count;\n//\t\tprintCup();\n\t\tfor(count = 1; count <= _max; count++) {\n\t\t\toperate();\n//\t\t\tprintCup();\n\t\t\tif(isEnd()) {\n\t\t\t\tisImpossible = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(isImpossible) {\n\t\t\tcount = -1;\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tpublic int getOperationAvailable() {\n\t\tint ret = 0;\n\t\tint top_a = ( _tray_a.empty() ) ? 0 : _tray_a.get( _tray_a.size()-1 );\n\t\tint top_b = ( _tray_b.empty() ) ? 0 : _tray_b.get( _tray_b.size()-1 );\n\t\tint top_c = ( _tray_c.empty() ) ? 0 : _tray_c.get( _tray_c.size()-1 );\n\t\tif( top_a > top_b  ) {\n\t\t\tret |= 1;\n\t\t} \n\t\tif( top_b > top_a  ) {\n\t\t\tret |= 1 << 1;\n\t\t} \n\t\tif( top_b > top_c  ) {\n\t\t\tret |= 1 << 2;\n\t\t} \n\t\tif( top_c > top_b ) {\n\t\t\tret |= 1 << 3;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic void printCup() {\n\t\tSystem.out.print(\"A: \");\n\t\tfor(int i = 0; i < _tray_a.size(); i++ ) {\n\t\t\tSystem.out.print(_tray_a.get(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tSystem.out.print(\"B: \");\n\t\tfor(int i = 0; i < _tray_b.size(); i++ ) {\n\t\t\tSystem.out.print(_tray_b.get(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tSystem.out.print(\"C: \");\n\t\tfor(int i = 0; i < _tray_c.size(); i++ ) {\n\t\t\tSystem.out.print(_tray_c.get(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.ArrayList;\n\nclass Main{\n    static int n,m,ans=0;\n    \n    static ArrayList<Integer> stackA_ini ;    \n    static ArrayList<Integer> stackB_ini ;    \n    static ArrayList<Integer> stackC_ini ;    \n    \n    static ArrayList<Integer> stackA;\n    static ArrayList<Integer> stackB;\n    static ArrayList<Integer> stackC;    \n    \n    static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    \n    public static void main(String[] a)throws IOException{\n        while(true){\n            inputData();\n            ans = Math.min(calcFromLeft(),calcFromRight());\n            ans = (ans <= m) ? ans : -1;               \n            System.out.println(ans);\n        }\n    }\n    \n    static int calcFromLeft(){\n        int step = 0;\n        \n        //左初動\n        while(true){\n            // 終了判定\n            if(isFinished()) break;\n \n            // 左２つのコップで入れ替え\n            if(peekStack(stackA)>peekStack(stackB)){\n                stackB.add(stackA.get(stackA.size()-1));\n                stackA.remove(stackA.size()-1);\n            }else{\n                stackA.add(stackB.get(stackB.size()-1));\n                stackB.remove(stackB.size()-1);\n            }\n            \n            step++;\n            \n            // 終了判定\n            if(isFinished()) break;\n                \n            // 右２つのコップで入れ替え\n            if(peekStack(stackB)>peekStack(stackC)){\n                stackC.add(stackB.get(stackB.size()-1));\n                stackB.remove(stackB.size()-1);\n            }else{\n                stackB.add(stackC.get(stackC.size()-1));\n                stackC.remove(stackC.size()-1);\n            }\n            step++;\n        }\n        return step;\n    }\n    \n    static int calcFromRight(){\n        \n        int step = 0;\n        stackA = stackA_ini;\n        stackB = stackB_ini;\n        stackC = stackC_ini;\n                 \n        //右初動\n        while(true){     \n            // 終了判定\n            if(isFinished()) break;\n            \n            // 右２つのコップで入れ替え\n            if(peekStack(stackB)>peekStack(stackC)){\n                stackC.add(stackB.get(stackB.size()-1));\n                stackB.remove(stackB.size()-1);\n            }else{\n                stackB.add(stackC.get(stackC.size()-1));\n                stackC.remove(stackC.size()-1);\n            }\n            step++;\n            \n            // 終了判定\n            if(isFinished()) break;          \n            \n            // 左２つのコップで入れ替え\n            if(peekStack(stackA)>peekStack(stackB)){\n                stackB.add(stackA.get(stackA.size()-1));\n                stackA.remove(stackA.size()-1);\n            }else{\n                stackA.add(stackB.get(stackB.size()-1));\n                stackB.remove(stackB.size()-1);\n            }\n            \n            step++;\n        }\n        return step;\n    }\n      \n    static boolean isFinished(){\n        if(stackB.isEmpty() && (stackA.isEmpty() || stackC.isEmpty()))\n            return true;\n        else\n            return false;\n    }\n    \n    static int peekStack(ArrayList<Integer> stack){\n        return stack.isEmpty() ? 0:stack.get(stack.size()-1);      \n    }\n    \n    static void inputData() throws IOException{\n        \n        String[] nm = in.readLine().split(\" \");\n        String[] cupList;\n        int cupNum = 0;\n        \n        stackA = new ArrayList<Integer>();\n        stackB = new ArrayList<Integer>();\n        stackC = new ArrayList<Integer>();\n        stackA_ini = new ArrayList<Integer>();\n        stackB_ini = new ArrayList<Integer>();\n        stackC_ini = new ArrayList<Integer>();        \n        \n        n = Integer.parseInt(nm[0]);\n        m = Integer.parseInt(nm[1]);\n        \n        if(n+m == 0){\n            System.exit(0);\n        }\n        \n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackA_ini.add(Integer.parseInt(cupList[j+1]));\n            stackA.add(Integer.parseInt(cupList[j+1]));\n        }\n\n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackB_ini.add(Integer.parseInt(cupList[j+1]));\n            stackB.add(Integer.parseInt(cupList[j+1]));\n        }\n        \n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackC_ini.add(Integer.parseInt(cupList[j+1]));\n            stackC.add(Integer.parseInt(cupList[j+1]));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\twhile(true){\n\t\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\t\tint n = Integer.parseInt(tmpArray[0]);\n\t\t\tint m = Integer.parseInt(tmpArray[1]);\n\n\t\t\tif(n == 0 && m == 0) break;\n\n\t\t\tTrayController tc = new TrayController();\n\n\t\t\t//System.out.println(n + \" \"+ m);\n\t\t\t//?????¬???????????????\n\t\t\tfor(int i = 0; i < 3 ; i++){\n\t\t\t\ttc.setTray(new Tray(br.readLine()), i);\n\t\t\t\t//System.out.println(\"tray\" +i+\" done\");\n\t\t\t}\n\n\t\t\t//System.out.println(\"initialize completed\");\n\n\t\t\tSystem.out.println(tc.calcTimes(m));\n\t\t}\n\t}\n\n}\n\nclass TrayController {\n\tprivate Tray[] trays = new Tray[3];\n\tprivate int times = -1;\n\n\tpublic void setTray(Tray t, int index){\n\t\ttrays[index] = t;\n\t}\n\n\tpublic int calcTimes (int m){\n\n\t\tmoveCup (this.trays, m, -1, -1);\n\n\t\tif(times != -1) return m - times;\n\t\telse return -1;\n\t}\n\n\tprivate void moveCup (Tray[] trays, int m, int mode, int prevmode){\n\t\t//System.out.println(\"m = \"+m+ \"mode = \"+mode);\n\n\n\t\t//A to B\n\t\tif(mode == 0){\n\t\t\ttrays[1].push(trays[0].pop());\n\t\t}\n\t\t//B to C\n\t\tif(mode == 1){\n\t\t\ttrays[2].push(trays[1].pop());\n\t\t}\n\t\t//C to B\n\t\tif(mode == 2){\n\t\t\ttrays[1].push(trays[2].pop());\n\t\t}\n\t\t//B to A\n\t\tif(mode == 3){\n\t\t\ttrays[0].push(trays[1].pop());\n\t\t}\n\n\t\tif(emptyCheck(trays)){\n\t\t\t//System.out.println(\"empty\");\n\t\t\tif(times < m) {\n\t\t\t\ttimes = m;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(m == 0){\n\t\t\t/*\n\t\t\tSystem.out.println(\"time limeit\");\n\t\t\t//?????¶??????top?????¨???\n\t\t\tfor (int i = 0; i < 3; i++){\n\t\t\t\tSystem.out.print(trays[i].top());\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t*/\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t//?????¶??????top?????¨???\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tSystem.out.print(trays[i].top());\n\t\t}\n\t\tSystem.out.println();\n\t\t*/\n\n\t\tTray[] trayCopy = new Tray[3];\n\t\t//A to B\n\t\tif(prevmode != 3 && trays[0].top() > trays[1].top()) {\n\t\t\tcopyTray(trayCopy, trays);\n\t\t\tmoveCup(trayCopy, m - 1, 0, prevmode);\n\t\t}\n\t\tif(prevmode != 2 && trays[1].top() > trays[2].top()) {\n\t\t\tcopyTray(trayCopy, trays);\n\t\t\tmoveCup(trayCopy, m - 1, 1, prevmode);\n\t\t}\n\t\tif(prevmode != 1 && trays[2].top() > trays[1].top()) {\n\t\t\tcopyTray(trayCopy, trays);\n\t\t\tmoveCup(trayCopy.clone(), m - 1, 2, prevmode);\n\t\t}\n\t\tif(prevmode != 0 && trays[1].top() > trays[0].top()) {\n\t\t\tcopyTray(trayCopy, trays);\n\t\t\tmoveCup(trayCopy.clone(), m - 1, 3, prevmode);\n\t\t}\n\t}\n\n\tprivate void copyTray(Tray[] newTray, Tray[] origin){\n\t\tfor (int i = 0 ; i < origin.length; i++){\n\t\t\tnewTray[i] = new Tray(new ArrayList<Integer>(origin[i].getCups()));\n\t\t}\n\t}\n\n\tprivate boolean emptyCheck (Tray[] trays){\n\t\tif(trays[0].isEmpty() && trays[1].isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (trays[1].isEmpty() && trays[2].isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nclass Tray {\n\tprivate ArrayList<Integer> cups = new ArrayList<Integer>();\n\n\n\tpublic Tray(String str){\n\t\tString[] tmpArray = str.split(\" \");\n\n\t\tfor(int i = 1; i < tmpArray.length; i++){\n\t\t\tcups.add(Integer.parseInt(tmpArray[i]));\n\t\t}\n\n\t\t//System.out.println(\"cups \"+ cups.size());\n\n\t}\n\n\tpublic Tray(ArrayList<Integer> cups){\n\t\tthis.cups = cups;\n\t}\n\n\tpublic boolean isEmpty (){\n\t\treturn cups.isEmpty();\n\t}\n\n\tpublic int top() {\n\t\tif (cups.size() == 0){\n\t\t\treturn 0;\n\t\t}\n\t\treturn cups.get(cups.size() - 1);\n\t}\n\n\tpublic int pop() {\n\t\tint tmp = top();\n\t\tcups.remove(cups.size() - 1);\n\n\t\treturn tmp;\n\t}\n\n\tpublic void push(int n) {\n\t\tcups.add(n);\n\t}\n\n\tpublic ArrayList<Integer> getCups(){\n\t\treturn cups;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.math.BigInteger;\nimport java.math.BigDecimal;\n      \npublic class Main{\n  \nstatic final InputStream in=System.in;\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic final long LINF=Long.MAX_VALUE/2;\nstatic int n,m,a,b,c;\nstatic Deque<Integer> queA,queB,queC;\n  \npublic static void main(String[] args) throws IOException{\nInputReader ir=new InputReader(in);\nwhile(true){\nn=ir.nextInt();\nm=ir.nextInt();\nif(n==0&&m==0) break;\nqueA=new ArrayDeque<Integer>();\nqueB=new ArrayDeque<Integer>();\nqueC=new ArrayDeque<Integer>();\na=ir.nextInt();\nif(a!=0){\nfor(int i=0;i<a;i++) queA.offerFirst(ir.nextInt());\n}\nb=ir.nextInt();\nif(b!=0){\nfor(int i=0;i<b;i++) queB.offerFirst(ir.nextInt());\n}\nc=ir.nextInt();\nif(c!=0){\nfor(int i=0;i<c;i++) queC.offerFirst(ir.nextInt());\n}\nint ans=dfs(0);\nout.println(ans>m?-1:ans);\n}\nout.flush();\n}\n\npublic static int dfs(int depth){\nif(depth>m||queA.size()==n||queC.size()==n) return depth;\nint s=m+1,t=m+1,u=m+1,v=m+1;\nif(!queA.isEmpty()){\nif(queB.isEmpty()||(!queB.isEmpty()&&queA.peekFirst()>queB.peekFirst())){\nint temp=queA.pollFirst();\nqueB.offerFirst(temp);\ns=dfs(depth+1);\nqueB.pollFirst();\nqueA.offerFirst(temp);\n}\n}\nif(!queC.isEmpty()){\nif(queB.isEmpty()||(!queB.isEmpty()&&queC.peekFirst()>queB.peekFirst())){\nint temp=queC.pollFirst();\nqueB.offerFirst(temp);\nt=dfs(depth+1);\nqueB.pollFirst();\nqueC.offerFirst(temp);\n}\n}\nif(!queB.isEmpty()){\nif(queA.isEmpty()){\nint temp=queB.pollFirst();\nqueA.offerFirst(temp);\nu=dfs(depth+1);\nqueA.pollFirst();\nqueB.offerFirst(temp);\n}\nelse if(queB.peekFirst()>queA.peekFirst()){\nint temp=queB.pollFirst();\nqueA.offerFirst(temp);\nu=dfs(depth+1);\nqueA.pollFirst();\nqueB.offerFirst(temp);\n}\nif(queC.isEmpty()){\nint temp=queB.pollFirst();\nqueC.offerFirst(temp);\nv=dfs(depth+1);\nqueC.pollFirst();\nqueB.offerFirst(temp);\n}\nelse if(queB.peekFirst()>queC.peekFirst()){\nint temp=queB.pollFirst();\nqueC.offerFirst(temp);\nv=dfs(depth+1);\nqueC.pollFirst();\nqueB.offerFirst(temp);\n}\n}\nreturn Math.min(Math.min(s,t),Math.min(u,v));\n}\n\nstatic class InputReader {\nprivate InputStream in;\nprivate byte[] buffer=new byte[1024];\nprivate int curbuf;\nprivate int lenbuf;\n  \npublic InputReader(InputStream in) {this.in=in;}\n    \npublic int readByte() {\nif(lenbuf==-1) throw new InputMismatchException();\nif(curbuf>=lenbuf){\ncurbuf= 0;\ntry{\nlenbuf=in.read(buffer);\n}\ncatch (IOException e) {\nthrow new InputMismatchException();\n}\nif(lenbuf<=0)\nreturn -1;\n}\nreturn buffer[curbuf++];\n}\n  \npublic boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \nprivate int skip() {int b; while((b = readByte())!=-1&&isSpaceChar(b)); return b;}\n  \npublic String next() {\nint b=skip();\nStringBuilder sb=new StringBuilder();\nwhile(!isSpaceChar(b)){\nsb.appendCodePoint(b);\nb=readByte();\n}\nreturn sb.toString();\n}\n   \npublic int nextInt() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nint res=0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic long nextLong() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nlong res = 0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic int[] toIntArray(int n){\nint[] a=new int[n];\nfor(int i=0;i<n;i++) a[i]=nextInt();\nreturn a;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.math.BigInteger;\n      \npublic class Main{\n  \nstatic final InputStream in=System.in;\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic final long LINF=Long.MAX_VALUE/2;\nstatic int n,m,a,b,c;\nstatic Deque<Integer> queA,queB,queC;\n  \npublic static void main(String[] args) throws IOException{\nInputReader ir=new InputReader(in);\nwhile(true){\nn=ir.nextInt();\nm=ir.nextInt();\nif(n==0&&m==0) break;\nqueA=new ArrayDeque<Integer>();\nqueB=new ArrayDeque<Integer>();\nqueC=new ArrayDeque<Integer>();\na=ir.nextInt();\nfor(int i=0;i<a;i++) queA.offerFirst(ir.nextInt());\nb=ir.nextInt();\nfor(int i=0;i<b;i++) queB.offerFirst(ir.nextInt());\nc=ir.nextInt();\nfor(int i=0;i<c;i++) queC.offerFirst(ir.nextInt());\nint ans=dfs(0);\nout.println(ans>m?-1:ans);\n}\nout.flush();\n}\n\npublic static int dfs(int depth){\nif(depth>m) return depth;\nif(queA.size()==n||queC.size==n) return depth;\nint s,t,u,v;\nif(!queA.isEmpty()&&(queB.isEmpty()||queA.peekFirst()>queB.peekFirst())){\nint temp=queA.pollFirst();\nqueB.offerFirst(temp);\ns=dfs(depth+1);\nqueB.pollFirst();\nqueA.offerFirst(temp);\n}\nif(!queC.isEmpty()&&(queB.isEmpty()||queC.peekFirst()>queB.peekFirst())){\nint temp=queC.pollFirst();\nqueB.offerFirst(temp);\nt=dfs(depth+1);\nqueB.pollFirst();\nqueC.offerFirst(temp);\n}\nif(!queB.isEmpty()&&(queA.isEmpty()||queB.peekFirst()>queA.peekFirst())){\nint temp=queB.pollFirst();\nqueA.offerFirst(temp);\nint u=dfs(depth+1);\nqueA.pollFirst(temp);\nqueB.offerFirst(temp);\n}\nif(!queB.isEmpty()&&(queC.isEmpty()||queB.peekFirst()>queC.peekFirst())){\nint temp=queB.pollFirst();\nqueC.offerFirst(temp);\nint v=dfs(depth+1);\nqueC.pollFirst(temp);\nqueB.offerFirst(temp);\n}\nreturn Math.min(Math.min(s,t),Math.min(u,v));\n}\n\nstatic class InputReader {\nprivate InputStream in;\nprivate byte[] buffer=new byte[1024];\nprivate int curbuf;\nprivate int lenbuf;\n  \npublic InputReader(InputStream in) {this.in=in;}\n    \npublic int readByte() {\nif(lenbuf==-1) throw new InputMismatchException();\nif(curbuf>=lenbuf){\ncurbuf= 0;\ntry{\nlenbuf=in.read(buffer);\n}\ncatch (IOException e) {\nthrow new InputMismatchException();\n}\nif(lenbuf<=0)\nreturn -1;\n}\nreturn buffer[curbuf++];\n}\n  \npublic boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \nprivate int skip() {int b; while((b = readByte())!=-1&&isSpaceChar(b)); return b;}\n  \npublic String next() {\nint b=skip();\nStringBuilder sb=new StringBuilder();\nwhile(!isSpaceChar(b)){\nsb.appendCodePoint(b);\nb=readByte();\n}\nreturn sb.toString();\n}\n   \npublic int nextInt() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nint res=0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic long nextLong() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nlong res = 0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic int[] toIntArray(int n){\nint[] a=new int[n];\nfor(int i=0;i<n;i++) a[i]=nextInt();\nreturn a;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Stack;\n\nclass Main{\n    static int n,m,ans=0;\n    \n    static Stack<Integer> stackA_ini;\n    static Stack<Integer> stackB_ini;\n    static Stack<Integer> stackC_ini;\n    \n    static Stack<Integer> stackA;\n    static Stack<Integer> stackB;\n    static Stack<Integer> stackC;\n    \n    public static void main(String[] a)throws IOException{\n        while(true){\n            inputData();\n            ans = Math.min(calcFromLeft(),calcFromRight());\n            ans = (ans <= m) ? ans : -1;               \n            System.out.println(ans);\n        }\n        \n    }\n    \n    static int calcFromLeft(){\n        int step = 0;\n        \n        //左初動\n        while(true){\n            // 終了判定\n            if(isFinished()) break;\n \n            // 左２つのコップで入れ替え\n            if(peekStack(stackA)>peekStack(stackB))\n                stackB.push(stackA.pop());\n            else\n                stackA.push(stackB.pop());\n            \n            step++;\n            \n            // 終了判定\n            if(isFinished()) break;\n                \n            // 右２つのコップで入れ替え\n            if(peekStack(stackB)>peekStack(stackC))\n                stackC.push(stackB.pop());\n            else\n                stackB.push(stackC.pop());\n            \n            step++;\n        }\n        return step;\n    }\n    \n    static int calcFromRight(){\n        \n        int step = 0;\n        stackA = stackA_ini;\n        stackB = stackB_ini;\n        stackC = stackC_ini;\n                 \n        //右初動\n        while(true){     \n            // 終了判定\n            if(isFinished()) break;\n            \n            // 右２つのコップで入れ替え\n            if(peekStack(stackB)>peekStack(stackC))\n                stackC.push(stackB.pop());\n            else\n                stackB.push(stackC.pop());\n\n            step++;\n            \n            // 終了判定\n            if(isFinished()) break;          \n            \n            // 左２つのコップで入れ替え\n            if(peekStack(stackA)>peekStack(stackB))\n                stackB.push(stackA.pop());\n            else\n                stackA.push(stackB.pop());\n            \n            step++;\n        }\n        return step;\n    }\n      \n    static boolean isFinished(){\n        if(stackB.empty() && (stackA.empty() || stackC.empty()))\n            return true;\n        else\n            return false;\n    }\n    \n    static int peekStack(Stack<Integer> stack){\n        return stack.empty() ? 0:stack.peek();      \n    }\n    \n    static void inputData() throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String[] nm = in.readLine().split(\" \");\n        String[] cupList;\n        int cupNum = 0;\n\n        stackA = new Stack<>();\n        stackB = new Stack<>();\n        stackC = new Stack<>();\n        stackA_ini = new Stack<>();\n        stackB_ini = new Stack<>();\n        stackC_ini = new Stack<>();\n        \n        n = Integer.parseInt(nm[0]);\n        m = Integer.parseInt(nm[1]);\n        \n        if(n+m == 0){\n            System.exit(0);\n        }\n        \n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackA_ini.push(Integer.parseInt(cupList[j+1]));\n            stackA.push(Integer.parseInt(cupList[j+1]));\n        }\n\n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackB_ini.push(Integer.parseInt(cupList[j+1]));\n            stackB.push(Integer.parseInt(cupList[j+1]));\n        }\n        \n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackC_ini.push(Integer.parseInt(cupList[j+1]));\n            stackC.push(Integer.parseInt(cupList[j+1]));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.Stack;\n\n\npublic class Main {\n\n\tstatic Stack<Integer> stackA;\n\tstatic Stack<Integer> stackB;\n\tstatic Stack<Integer> stackC;\n\tstatic Stack<Integer> stackA2;\n\tstatic Stack<Integer> stackB2;\n\tstatic Stack<Integer> stackC2;\n\n\tstatic int step = 0;\n\tstatic int prevMoveType = 1;\n\tstatic int N;\n\tstatic int M;\n\n\tstatic BufferedReader br;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\twhile (true) {\n\t\t\tinit();\n\t\t\tif (!inputData()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//System.out.println(dump());\n\n\t\t\tboolean isFinishedR = false;\n\t\t\tboolean isFinishedL = false;\n\n\t\t\tint min = 0;\n\n\t\t\tprevMoveType = +1;\n\t\t\twhile (step <= M) {\n\t\t\t\tif (isFinished(step)) {\n\t\t\t\t\tisFinishedR = true;\n\t\t\t\t\t//System.out.println(\"+1で成功！カウント＝\" + step);\n\t\t\t\t\tmin = step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (prevMoveType > 0) {\n\t\t\t\t\tmoveLeft(step);\n\t\t\t\t} else {\n\t\t\t\t\tmoveRight(step);\n\t\t\t\t}\n\t\t\t\tprevMoveType *= -1;\n\t\t\t\tstep++;\n\t\t\t\t//System.out.println(dump());\n\t\t\t}\n\n\t\t\tif (!isFinishedR) {\n\t\t\t\t//System.out.println(\"＋１では失敗！\");\n\t\t\t}\n\n\t\t\tprevMoveType = -1;\n\t\t\tstep = 0;\n\t\t\tstackA = stackA2;\n\t\t\tstackB = stackB2;\n\t\t\tstackC = stackC2;\n\n\t\t\twhile (step <= M) {\n\t\t\t\tif (isFinished(step)) {\n\t\t\t\t\tisFinishedL = true;\n\t\t\t\t\t//System.out.println(\"-1で成功！カウント＝\" + step);\n\t\t\t\t\tmin = Math.min(min, step);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (prevMoveType > 0) {\n\t\t\t\t\tmoveLeft(step);\n\t\t\t\t} else {\n\t\t\t\t\tmoveRight(step);\n\t\t\t\t}\n\t\t\t\tprevMoveType *= -1;\n\t\t\t\tstep++;\n\t\t\t\t//System.out.println(dump());\n\t\t\t}\n\t\t\tif (!isFinishedL) {\n\t\t\t\t//System.out.println(\"-１では失敗！\");\n\t\t\t}\n\n\t\t\tif (isFinishedL || isFinishedR) {\n\t\t\t\t//System.out.println(\"最小手数 = \" + min);\n\t\t\t\tSystem.out.println(min);\n\t\t\t} else {\n\t\t\t\t//System.out.println(\"失敗\");\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic void init() {\n\t\tstackA = new Stack<Integer>();\n\t\tstackB = new Stack<Integer>();\n\t\tstackC = new Stack<Integer>();\n\n\t\tstackA2 = new Stack<Integer>();\n\t\tstackB2 = new Stack<Integer>();\n\t\tstackC2 = new Stack<Integer>();\n\n\t\tstep = 0;\n\t}\n\n\tstatic boolean inputData() throws IOException {\n\t\tString input = br.readLine();\n\t\t//System.out.println(\"入力NM = \" + input);\n\t\tString[] nm = input.split(\" \");\n\t\tN = Integer.parseInt(nm[0]);\n\t\tM = Integer.parseInt(nm[1]);\n\n\t\tif (N == 0 && M == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString[] dataA = br.readLine().split(\" \");\n\t\tint numData = Integer.parseInt(dataA[0]);\n\t\tfor (int i = 0; i < numData; i++) {\n\t\t\tstackA.push(Integer.parseInt(dataA[i + 1]));\n\t\t\tstackA2.push(Integer.parseInt(dataA[i + 1]));\n\t\t}\n\n\t\tString[] dataB = br.readLine().split(\" \");\n\t\tnumData = Integer.parseInt(dataB[0]);\n\t\tfor (int i = 0; i < numData; i++) {\n\t\t\tstackB.push(Integer.parseInt(dataB[i + 1]));\n\t\t\tstackB2.push(Integer.parseInt(dataB[i + 1]));\n\t\t}\n\n\t\tString[] dataC = br.readLine().split(\" \");\n\t\tnumData = Integer.parseInt(dataC[0]);\n\t\tfor (int i = 0; i < numData; i++) {\n\t\t\tstackC.push(Integer.parseInt(dataC[i + 1]));\n\t\t\tstackC2.push(Integer.parseInt(dataC[i + 1]));\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tstatic boolean moveLeft(int count) {\n\t\tint A = stackA.empty() ? 0 : stackA.peek();\n\t\tint B = stackB.empty() ? 0 : stackB.peek();\n\n\t\tif (A >= B) {\n\t\t\treturn moveAB();\n\t\t} else {\n\t\t\treturn moveBA();\n\t\t}\n\t}\n\n\tstatic boolean moveRight(int count) {\n\t\tint B = stackB.empty() ? 0 : stackB.peek();\n\t\tint C = stackC.empty() ? 0 : stackC.peek();\n\t\tif (B >= C) {\n\t\t\treturn moveBC();\n\t\t} else {\n\t\t\treturn moveCB();\n\t\t}\n\t}\n\n\tstatic boolean isFinished(int step) {\n\t\tif (!stackB.empty()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (stackA.empty() || stackC.empty()) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\tstatic boolean moveAB() {\n\t\t//System.out.println(\"moveAB()\");\n\t\tint A = stackA.pop();\n\t\tstackB.push(A);\n\t\treturn true;\n\t}\n\n\tstatic boolean moveBC() {\n\t\t//System.out.println(\"moveBC()\");\n\t\tint B = stackB.pop();\n\t\tstackC.push(B);\n\t\treturn true;\n\t}\n\n\tstatic boolean moveBA() {\n\t\t//System.out.println(\"moveBA()\");\n\t\tint B = stackB.pop();\n\t\tstackA.push(B);\n\t\treturn true;\n\t}\n\n\tstatic boolean moveCB() {\n\t\t//System.out.println(\"moveCB()\");\n\t\tint C = stackC.pop();\n\t\tstackB.push(C);\n\t\treturn true;\n\t}\n\n\tstatic String dump() {\n\t\tStringBuilder dump = new StringBuilder();\n\t\tdump.append(stackA.toString());\n\t\tdump.append(\"\\n\");\n\t\tdump.append(stackB.toString());\n\t\tdump.append(\"\\n\");\n\t\tdump.append(stackC.toString());\n\t\tdump.append(\"\\n=======================================\\n\");\n\n\t\treturn dump.toString();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while(true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            if(n == 0 && m == 0) break;\n\n            int s = 0;\n            for(int i = 0; i < 3; i++) {\n                int num = sc.nextInt();\n                for(int j = 0; j < num; j++) {\n                    int x = sc.nextInt() - 1;\n                    s += (int) Math.pow(3, x) * i;\n                }\n            }\n            int g = 0;\n            for(int i = 0; i < n; i++) {\n                g *= 3;\n                g += 1;\n            }\n\n            int[] cost = new int[(int) Math.pow(3, n)];\n            cost[s] = 1;\n            Deque<Integer> que = new ArrayDeque<>();\n            que.add(s);\n\n            while(!que.isEmpty()) {\n                int i = que.poll();\n                if(i == 0 || i == g * 2) break;\n                if(cost[i] == m + 1) break;\n\n                int top0 = -1;\n                int top1 = -1;\n                int top2 = -1;\n                int tmp = i;\n                for(int j = 0; j < n; j++) {\n                    if(tmp % 3 == 0) top0 = j;\n                    if(tmp % 3 == 1) top1 = j;\n                    if(tmp % 3 == 2) top2 = j;\n                    tmp /= 3;\n                }\n\n                if(top0 > top1) {\n                    int ni = i + (int) Math.pow(3, top0);\n                    if(cost[ni] == 0) {\n                        cost[ni] = cost[i] + 1;\n                        que.add(ni);\n                    }\n                }else if(top0 < top1) {\n                    int ni = i - (int) Math.pow(3, top1);\n                    if(cost[ni] == 0) {\n                        cost[ni] = cost[i] + 1;\n                        que.add(ni);\n                    }\n                }\n                if(top1 > top2) {\n                    int ni = i + (int) Math.pow(3, top1);\n                    if(cost[ni] == 0) {\n                        cost[ni] = cost[i] + 1;\n                        que.add(ni);\n                    }\n                }else if(top1 < top2) {\n                    int ni = i - (int) Math.pow(3, top2);\n                    if(cost[ni] == 0) {\n                        cost[ni] = cost[i] + 1;\n                        que.add(ni);\n                    }\n                }\n            }\n\n            if(cost[0] > 0) System.out.println(cost[0] - 1);\n            else if(cost[g * 2] > 0) System.out.println(cost[g * 2] - 1);\n            else System.out.println(-1);\n        }\n\n        sc.close();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint[] pow3 = new int[n + 1];\n\t\t\tpow3[0] = 1;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tpow3[i] = pow3[i - 1] * 3;\n\t\t\tint[] c = new int[n];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tint a = scanner.nextInt();\n\t\t\t\tfor (int j = a; j > 0; j--) {\n\t\t\t\t\tint b = scanner.nextInt();\n\t\t\t\t\tc[n - b] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint p = 0;\n\t\t\tint x = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint d = Math.abs(p - c[i]);\n\t\t\t\tx += pow3[i] * d;\n\t\t\t\tif (d == 1)\n\t\t\t\t\tp = 2 - p;\n\t\t\t}\n\t\t\tint y = pow3[n] - x - 1;\n\t\t\tx = Math.min(x, y);\n\t\t\tSystem.out.println(x > m ? -1 : x);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\twhile(true){\n\t\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\t\tint n = Integer.parseInt(tmpArray[0]);\n\t\t\tint m = Integer.parseInt(tmpArray[1]);\n\n\t\t\tif(n == 0 && m == 0) break;\n\n\t\t\tTrayController tc = new TrayController();\n\n\t\t\t//System.out.println(n + \" \"+ m);\n\t\t\t//?????¬???????????????\n\t\t\tfor(int i = 0; i < 3 ; i++){\n\t\t\t\ttc.setTray(new Tray(br.readLine()), i);\n\t\t\t\t//System.out.println(\"tray\" +i+\" done\");\n\t\t\t}\n\n\t\t\t//System.out.println(\"initialize completed\");\n\n\t\t\tSystem.out.println(tc.calcTimes(m));\n\t\t}\n\t}\n\n}\n\nclass TrayController {\n\tprivate Tray[] trays = new Tray[3];\n\tprivate int times = -1;\n\n\tpublic void setTray(Tray t, int index){\n\t\ttrays[index] = t;\n\t}\n\n\tpublic int calcTimes (int m){\n\n\t\tmoveCup (this.trays, m, -1);\n\n\t\tif(times != -1) return m - times;\n\t\telse return -1;\n\t}\n\n\tprivate void moveCup (Tray[] trays, int m, int mode){\n\t\t//System.out.println(\"m = \"+m+ \"mode = \"+mode);\n\n\n\t\t//A to B\n\t\tif(mode == 0){\n\t\t\ttrays[1].push(trays[0].pop());\n\t\t}\n\t\t//B to C\n\t\tif(mode == 1){\n\t\t\ttrays[2].push(trays[1].pop());\n\t\t}\n\t\t//C to B\n\t\tif(mode == 2){\n\t\t\ttrays[1].push(trays[2].pop());\n\t\t}\n\t\t//B to A\n\t\tif(mode == 3){\n\t\t\ttrays[0].push(trays[1].pop());\n\t\t}\n\n\t\tif(emptyCheck(trays)){\n\t\t\t//System.out.println(\"empty\");\n\t\t\tif(times < m) {\n\t\t\t\ttimes = m;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(m == 0){\n\t\t\t/*\n\t\t\tSystem.out.println(\"time limeit\");\n\t\t\t//?????¶??????top?????¨???\n\t\t\tfor (int i = 0; i < 3; i++){\n\t\t\t\tSystem.out.print(trays[i].top());\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t*/\n\t\t\treturn;\n\t\t}\n\t\t/*\n\t\t//?????¶??????top?????¨???\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tSystem.out.print(trays[i].top());\n\t\t}\n\t\tSystem.out.println();\n\t\t*/\n\n\t\tTray[] trayCopy = new Tray[3];\n\t\t//A to B\n\t\tif(trays[0].top() > trays[1].top()) {\n\t\t\tcopyTray(trayCopy, trays);\n\t\t\tmoveCup(trayCopy, m - 1, 0);\n\t\t}\n\t\tif(trays[1].top() > trays[2].top()) {\n\t\t\tcopyTray(trayCopy, trays);\n\t\t\tmoveCup(trayCopy, m - 1, 1);\n\t\t}\n\t\tif(trays[2].top() > trays[1].top()) {\n\t\t\tcopyTray(trayCopy, trays);\n\t\t\tmoveCup(trayCopy.clone(), m - 1, 2);\n\t\t}\n\t\tif(trays[1].top() > trays[0].top()) {\n\t\t\tcopyTray(trayCopy, trays);\n\t\t\tmoveCup(trayCopy.clone(), m - 1, 3);\n\t\t}\n\t}\n\n\tprivate void copyTray(Tray[] newTray, Tray[] origin){\n\t\tfor (int i = 0 ; i < origin.length; i++){\n\t\t\tnewTray[i] = new Tray(new ArrayList<Integer>(origin[i].getCups()));\n\t\t}\n\t}\n\n\tprivate boolean emptyCheck (Tray[] trays){\n\t\tif(trays[0].isEmpty() && trays[1].isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (trays[1].isEmpty() && trays[2].isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nclass Tray {\n\tprivate ArrayList<Integer> cups = new ArrayList<Integer>();\n\n\n\tpublic Tray(String str){\n\t\tString[] tmpArray = str.split(\" \");\n\n\t\tfor(int i = 1; i < tmpArray.length; i++){\n\t\t\tcups.add(Integer.parseInt(tmpArray[i]));\n\t\t}\n\n\t\t//System.out.println(\"cups \"+ cups.size());\n\n\t}\n\n\tpublic Tray(ArrayList<Integer> cups){\n\t\tthis.cups = cups;\n\t}\n\n\tpublic boolean isEmpty (){\n\t\treturn cups.isEmpty();\n\t}\n\n\tpublic int top() {\n\t\tif (cups.size() == 0){\n\t\t\treturn 0;\n\t\t}\n\t\treturn cups.get(cups.size() - 1);\n\t}\n\n\tpublic int pop() {\n\t\tint tmp = top();\n\t\tcups.remove(cups.size() - 1);\n\n\t\treturn tmp;\n\t}\n\n\tpublic void push(int n) {\n\t\tcups.add(n);\n\t}\n\n\tpublic ArrayList<Integer> getCups(){\n\t\treturn cups;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.math.BigInteger;\n      \npublic class Main{\n  \nstatic final InputStream in=System.in;\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic final long LINF=Long.MAX_VALUE/2;\nstatic int n,m,a,b,c;\nstatic Deque<Integer> queA,queB,queC;\n  \npublic static void main(String[] args) throws IOException{\nInputReader ir=new InputReader(in);\nwhile(true){\nn=ir.nextInt();\nm=ir.nextInt();\nif(n==0&&m==0) break;\nqueA=new ArrayDeque<Integer>();\nqueB=new ArrayDeque<Integer>();\nqueC=new ArrayDeque<Integer>();\na=ir.nextInt();\nfor(int i=0;i<a;i++) queA.offerFirst(ir.nextInt());\nb=ir.nextInt();\nfor(int i=0;i<b;i++) queB.offerFirst(ir.nextInt());\nc=ir.nextInt();\nfor(int i=0;i<c;i++) queC.offerFirst(ir.nextInt());\nint ans=dfs(0);\nout.println(ans>m?-1:ans);\n}\nout.flush();\n}\n\npublic static int dfs(int depth){\nif(depth>m) return depth;\nif(queA.size()==n||queC.size()==n) return depth;\nint s,t,u,v;\ns=t=u=v=m+1;\nif(!queA.isEmpty()&&(queB.isEmpty()||queA.peekFirst()>queB.peekFirst())){\nint temp=queA.pollFirst();\nqueB.offerFirst(temp);\ns=dfs(depth+1);\nqueB.pollFirst();\nqueA.offerFirst(temp);\n}\nif(!queC.isEmpty()&&(queB.isEmpty()||queC.peekFirst()>queB.peekFirst())){\nint temp=queC.pollFirst();\nqueB.offerFirst(temp);\nt=dfs(depth+1);\nqueB.pollFirst();\nqueC.offerFirst(temp);\n}\nif(!queB.isEmpty()&&(queA.isEmpty()||queB.peekFirst()>queA.peekFirst())){\nint temp=queB.pollFirst();\nqueA.offerFirst(temp);\nu=dfs(depth+1);\nqueA.pollFirst();\nqueB.offerFirst(temp);\n}\nif(!queB.isEmpty()&&(queC.isEmpty()||queB.peekFirst()>queC.peekFirst())){\nint temp=queB.pollFirst();\nqueC.offerFirst(temp);\nv=dfs(depth+1);\nqueC.pollFirst();\nqueB.offerFirst(temp);\n}\nreturn Math.min(Math.min(s,t),Math.min(u,v));\n}\n\nstatic class InputReader {\nprivate InputStream in;\nprivate byte[] buffer=new byte[1024];\nprivate int curbuf;\nprivate int lenbuf;\n  \npublic InputReader(InputStream in) {this.in=in;}\n    \npublic int readByte() {\nif(lenbuf==-1) throw new InputMismatchException();\nif(curbuf>=lenbuf){\ncurbuf= 0;\ntry{\nlenbuf=in.read(buffer);\n}\ncatch (IOException e) {\nthrow new InputMismatchException();\n}\nif(lenbuf<=0)\nreturn -1;\n}\nreturn buffer[curbuf++];\n}\n  \npublic boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \nprivate int skip() {int b; while((b = readByte())!=-1&&isSpaceChar(b)); return b;}\n  \npublic String next() {\nint b=skip();\nStringBuilder sb=new StringBuilder();\nwhile(!isSpaceChar(b)){\nsb.appendCodePoint(b);\nb=readByte();\n}\nreturn sb.toString();\n}\n   \npublic int nextInt() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nint res=0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic long nextLong() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nlong res = 0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic int[] toIntArray(int n){\nint[] a=new int[n];\nfor(int i=0;i<n;i++) a[i]=nextInt();\nreturn a;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tMyInput in = new MyInput(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic long LINF = 1L << 55;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tlong[] pow3 = new long[20];\n\t\tpublic void solve(int testNumber, MyInput in, PrintWriter out) {\n\n\t\t\tpow3[0] = 1;\n\t\t\tfor (int i = 1; i < 20; i++) {\n\t\t\t\tpow3[i] = pow3[i-1] * 3;\n\t\t\t}\n\n\t\t\tint n = in.nextInt(), m = in.nextInt();\n\t\t\twhile (!(m == 0 && n == 0)) {\n\n\t\t\t\tint[] c = new int[20];\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tint j = in.nextInt();\n\t\t\t\t\twhile (j-- > 0) {\n\t\t\t\t\t\tint k = in.nextInt();\n\t\t\t\t\t\tc[n-k] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint p = 0, d = 0;\n\t\t\t\tlong x = 0;\n\t\t\t\tfor (int i = n-1; i >= 0; i--) {\n\t\t\t\t\td = Math.abs(p - c[i]);\n\t\t\t\t\tx += pow3[i] * d;\n\t\t\t\t\tif (d == 1) {\n\t\t\t\t\t\tp = 2 - p;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlong ans = Math.min(pow3[n] - 1 - x, x);\n\t\t\t\tout.println(ans > m ? -1 : ans);\n\n\t\t\t\tn = in.nextInt(); m = in.nextInt();\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\tstatic class MyInput {\n\t\tprivate final BufferedReader in;\n\t\tprivate static int pos;\n\t\tprivate static int readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500 * 8 * 2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic {\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tisDigit['0' + i] = true;\n\t\t\t}\n\t\t\tisDigit['-'] = true;\n\t\t\tisSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n\t\t\tisLineSep['\\r'] = isLineSep['\\n'] = true;\n\t\t}\n\n\t\tpublic MyInput(InputStream is) {\n\t\t\tin = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (pos >= readLen) {\n\t\t\t\tpos = 0;\n\t\t\t\ttry {\n\t\t\t\t\treadLen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t\tif (readLen <= 0) {\n\t\t\t\t\tthrow new MyInput.EndOfFileRuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[pos++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tint ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\tint i = 0;\n\t\t\tlong ret = 0;\n\t\t\tif (str[0] == '-') {\n\t\t\t\ti = 1;\n\t\t\t}\n\t\t\tfor (; i < len; i++)\n\t\t\t\tret = ret * 10 + str[i] - '0';\n\t\t\tif (str[0] == '-') {\n\t\t\t\tret = -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tpublic char nextChar() {\n\t\t\twhile (true) {\n\t\t\t\tfinal int c = read();\n\t\t\t\tif (!isSpace[c]) {\n\t\t\t\t\treturn (char) c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextString() {\n\t\t\treturn new String(nextChars());\n\t\t}\n\n\t\tpublic char[] nextChars() {\n\t\t\tint len = 0;\n\t\t\tstr[len++] = nextChar();\n\t\t\tlen = reads(len, isSpace);\n\t\t\treturn Arrays.copyOf(str, len);\n\t\t}\n\n\t\tpublic char[][] next2DChars(int h, int w) {\n\t\t\tchar[][] s = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\ts[i] = nextChars();\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\n\t\tint reads(int len, boolean[] accept) {\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\tfinal int c = read();\n\t\t\t\t\tif (accept[c]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (str.length == len) {\n\t\t\t\t\t\tchar[] rep = new char[str.length * 3 / 2];\n\t\t\t\t\t\tSystem.arraycopy(str, 0, rep, 0, str.length);\n\t\t\t\t\t\tstr = rep;\n\t\t\t\t\t}\n\t\t\t\t\tstr[len++] = (char) c;\n\t\t\t\t}\n\t\t\t} catch (MyInput.EndOfFileRuntimeException e) {\n\t\t\t}\n\t\t\treturn len;\n\t\t}\n\n\t\tpublic int[] nextIntArray(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArray1Index(final int n) {\n\t\t\tfinal int[] res = new int[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[] nextIntArrayDec(final int n) {\n\t\t\tfinal int[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray1Index(final int n) {\n\t\t\tfinal long[] res = new long[n + 1];\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArrayDec(final int n) {\n\t\t\tfinal long[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong() - 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic double[] nextDoubleArray(int n) {\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\t}\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    public static void main(String[] args){\n\tScanner in = new Scanner(System.in);\n\n\tint n,m;\n\tint[] A = new int[100];\n\tint[] C = new int[100];\n\tint[] P = new int[100];\n\tint[] F = new int[100];\n\n\twhile(true)\n\t    {\n\t\tn = in.nextInt();\n\t\tm = in.nextInt();\n\t\tif(n == 0 && m == 0)break;\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t    int ph;\n\t\t    ph = in.nextInt();\n\t\t    for(int j=0;j<ph;j++)\n\t\t\t{\n\t\t\t    int in2;\n\t\t\t    in2 = in.nextInt();\n\t\t\t    F[in2] = i;\n\t\t\t}\n\t\t    \n\t\t}\n\n\t\tP[n] = 2;\n\t\tA[n] = F[n];\n\t\tC[n] = 2 - F[n];\n\n\n\t\tfor(int i=n;i>1;i--)\n\t\t    {\n\t\t\t//P[i]ÌÈºÌ®ÍvZÌÊÅÄ«½àÌ\n\t\t\t//àµãÉQÂÌRbvª éÆ«\n\t\t\t//»êð½Î¤ÉÁÄ¢­ÉÍWñ®©·\n\t\t\t//RÂRbvª éÍQUñ\n\t\t\t//PÂÌÍQñ\n\t\t\t//Í¢A ÆÍvZ\n\t\t\t//habukuyo\n\t\t\t//iRbvªQÂÈãÌÉpÂ\\j\n\t\t\tP[i-1] = 3*P[i] + 2;\n\t\t\tif(F[i-1] == 0)\n\t\t\t    {\n\t\t\t\tA[i-1]=A[i]; //à¤ùÉAÉ éÌÅ»êÜÅÌñiA[i]jðãüµÄI¹\n\t\t\t\tC[i-1]=C[i]+2*P[i]+2;//CÌ»êÜÅÌñ(C[i])Æ¡CÉ éRbvðAÉ®©µÄßµÄ­éñi2*P[i]jÆÚIÌJbvÌÚ®ñ(2)ðÁ¦½àÌðãü\n\t\t\t    }\n\t\t\telse if(F[i-1] == 1)\n\t\t\t    {\n\t\t\t\t//®©µ½¢Jbvª^ñÉ éêÅ\n\t\t\t\t//©ÂAÉàÁÄ¢«½¢ÉÍA\n\t\t\t\t//AÉ éàÌð·×ÄCÉÚ®³¹\n\t\t\t\t//ÚIÌJbvðAÉÚ®³¹I¹\n\t\t\t\t//CÉÚ®³¹½ÌÍAÉß³È¢\n\t\t\t\t//tà¯¶æ¤É·é\n\t\t\t\tA[i-1] = C[i] + P[i] + 1;\n\t\t\t\tC[i-1] = A[i] + P[i] + 1;\n\t\t\t    }\n\t\t\telse if(F[i-1] == 2)\n\t\t\t    {\n\t\t\t\tA[i-1] = A[i] + 2*P[i] + 2;\n\t\t\t\tC[i-1] = C[i];\n\t\t\t    }\n\t\t\t\n\t\t\t\n\t\t    }\n\t\n\t\tint ans = Math.min(A[1],C[1]);\n\t\tif(m < ans) System.out.println(\"-1\");\n\t\telse System.out.println(ans);\t\n\t\t\n\t\t\n\t}\n\t\n\t\n\t\n    }\n    \n    \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport static java.lang.Integer.*;\nimport java.util.Stack;\n\nclass Main{\n    static int n,m,ans=0;\n    \n    static Stack<Integer> stackA_ini;\n    static Stack<Integer> stackB_ini;\n    static Stack<Integer> stackC_ini;\n    \n    static Stack<Integer> stackA;\n    static Stack<Integer> stackB;\n    static Stack<Integer> stackC;\n    \n    public static void main(String[] a)throws IOException{\n        while(true){\n            inputData();\n            ans = min(calcFromLeft(),calcFromRight());\n            ans = (ans <= m) ? ans : -1;               \n            System.out.println(ans);\n        }\n        \n    }\n    static int calcFromLeft(){\n        int step = 0;\n        initializeStack();\n        \n        //左初動\n        while(true){\n            // 終了判定\n            if(isFinished()) break;\n \n            // 左２つのコップで入れ替え\n            if(peekStack(stackA)>peekStack(stackB))\n                stackB.push(stackA.pop());\n            else\n                stackA.push(stackB.pop());\n            \n            step++;\n            \n            // 終了判定\n            if(isFinished()) break;\n                \n            // 右２つのコップで入れ替え\n            if(peekStack(stackB)>peekStack(stackC))\n                stackC.push(stackB.pop());\n            else\n                stackB.push(stackC.pop());\n            \n            step++;\n        }\n        return step;\n    }\n    static int calcFromRight(){\n        \n        int step = 0;\n        initializeStack();\n                \n        //右初動\n        while(true){     \n            // 終了判定\n            if(isFinished()) break;\n            \n            // 右２つのコップで入れ替え\n            if(peekStack(stackB)>peekStack(stackC))\n                stackC.push(stackB.pop());\n            else\n                stackB.push(stackC.pop());\n\n            step++;\n            \n            // 終了判定\n            if(isFinished()) break;          \n            \n            // 左２つのコップで入れ替え\n            if(peekStack(stackA)>peekStack(stackB))\n                stackB.push(stackA.pop());\n            else\n                stackA.push(stackB.pop());\n            \n            step++;\n        }\n        return step;\n    }\n    \n    static void initializeStack(){\n        stackA = (Stack<Integer>) stackA_ini.clone();\n        stackB = (Stack<Integer>) stackB_ini.clone();\n        stackC = (Stack<Integer>) stackC_ini.clone();\n    }\n    \n    static boolean isFinished(){\n        if(stackB.empty() && (stackA.empty() || stackC.empty()))\n            return true;\n        else\n            return false;\n    }\n    static int peekStack(Stack<Integer> stack){\n        return stack.empty() ? 0:stack.peek();      \n    }\n    \n    static void inputData() throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String[] nm = in.readLine().split(\" \");\n        String[] cupList;\n        int cupNum = 0;\n\n        stackA.clear();\n        stackB.clear();\n        stackC.clear();\n        \n        n = Integer.parseInt(nm[0]);\n        m = Integer.parseInt(nm[1]);\n        \n        if(n+m == 0){\n            System.exit(0);\n        }\n        \n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackA_ini.push(Integer.parseInt(cupList[j+1]));\n        }\n\n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackB_ini.push(Integer.parseInt(cupList[j+1]));\n        }\n        \n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackC_ini.push(Integer.parseInt(cupList[j+1]));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Cup\npublic class Main{\n\n\tint[] last;\n\tint N, M;\n\t\n\tint f(int[] c, int from, int to){\n\t\tint res = 1;\n\t\tboolean con = true;\n\t\twhile(!(c[0]==(1<<N)-1||c[2]==(1<<N)-1)&&res<=M){\n\t\t\tcon = true;\n\t\t\tfor(int f=0;f<3&&con;f++)for(int t=0;t<3&&con;t++){\n\t\t\t\tif(Math.abs(f-t)>1)continue;\n\t\t\t\tif(from==t&&to==f)continue;\n\t\t\t\tif(last[c[f]]<=last[c[t]])continue;\n\t\t\t\tc[t]+=1<<last[c[f]]; c[f]-=1<<last[c[f]];\n\t\t\t\tfrom = f; to = t;\n\t\t\t\tcon = false;\n\t\t\t}\n\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvoid run(){\n\t\tlast = new int[1<<15];\n\t\tfor(int S=0;S<1<<15;S++){\n\t\t\tint k = 14;\n\t\t\twhile(k>=0&&((S>>k)&1)==0)k--;\n\t\t\tlast[S] = k;\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt(); M = sc.nextInt();\n\t\t\tif((N|M)==0)break;\n\t\t\tint[] cup = new int[3];\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\twhile(k--!=0)cup[i]+=1<<(sc.nextInt()-1);\n\t\t\t}\n\t\t\tif(cup[0]==(1<<N)-1||cup[2]==(1<<N)-1){\n\t\t\t\tSystem.out.println(0); continue;\n\t\t\t}\n\t\t\tint res = M+1;\n\t\t\tfor(int f=0;f<3;f++)for(int t=0;t<3;t++){\n\t\t\t\tif(Math.abs(f-t)>1)continue;\n\t\t\t\tif(last[cup[f]]<=last[cup[t]])continue;\n\t\t\t\tint[] c = new int[3];\n\t\t\t\tc[0] = cup[0]; c[1] = cup[1]; c[2] = cup[2];\n\t\t\t\tc[t]+=1<<last[c[f]]; c[f]-=1<<last[c[f]];\n\t\t\t\tres = Math.min(res, f(c, f, t));\n\t\t\t}\n\t\t\tSystem.out.println(M<res?\"-1\":res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport static java.lang.Integer.min;\nimport java.util.Stack;\n\nclass Main{\n    static int n,m,ans=0;\n    \n    static Stack<Integer> stackA_ini = new Stack<>();\n    static Stack<Integer> stackB_ini = new Stack<>();\n    static Stack<Integer> stackC_ini = new Stack<>();\n    \n    static Stack<Integer> stackA = new Stack<>();\n    static Stack<Integer> stackB = new Stack<>();\n    static Stack<Integer> stackC = new Stack<>();\n    \n    public static void main(String[] a)throws IOException{\n        while(true){\n            inputData();\n            ans = min(calcFromLeft(),calcFromRight());\n            ans = (ans <= m) ? ans : -1;               \n            System.out.println(ans);\n        }\n        \n    }\n    static int calcFromLeft(){\n        int step = 0;\n        initializeStack();\n        \n        //左初動\n        while(true){\n            // 終了判定\n            if(isFinished()) break;\n \n            // 左２つのコップで入れ替え\n            if(peekStack(stackA)>peekStack(stackB))\n                stackB.push(stackA.pop());\n            else\n                stackA.push(stackB.pop());\n            \n            step++;\n            \n            // 終了判定\n            if(isFinished()) break;\n                \n            // 右２つのコップで入れ替え\n            if(peekStack(stackB)>peekStack(stackC))\n                stackC.push(stackB.pop());\n            else\n                stackB.push(stackC.pop());\n            \n            step++;\n        }\n        return step;\n    }\n    static int calcFromRight(){\n        \n        int step = 0;\n        initializeStack();\n                \n        //右初動\n        while(true){     \n            // 終了判定\n            if(isFinished()) break;\n            \n            // 右２つのコップで入れ替え\n            if(peekStack(stackB)>peekStack(stackC))\n                stackC.push(stackB.pop());\n            else\n                stackB.push(stackC.pop());\n\n            step++;\n            \n            // 終了判定\n            if(isFinished()) break;          \n            \n            // 左２つのコップで入れ替え\n            if(peekStack(stackA)>peekStack(stackB))\n                stackB.push(stackA.pop());\n            else\n                stackA.push(stackB.pop());\n            \n            step++;\n        }\n        return step;\n    }\n    \n    static void initializeStack(){\n        stackA = (Stack<Integer>) stackA_ini.clone();\n        stackB = (Stack<Integer>) stackB_ini.clone();\n        stackC = (Stack<Integer>) stackC_ini.clone();\n    }\n    \n    static boolean isFinished(){\n        if(stackB.empty() && (stackA.empty() || stackC.empty()))\n            return true;\n        else\n            return false;\n    }\n    static int peekStack(Stack<Integer> stack){\n        return stack.empty() ? 0:stack.peek();      \n    }\n    \n    static void inputData() throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String[] nm = in.readLine().split(\" \");\n        String[] cupList;\n        int cupNum = 0;\n\n        stackA.clear();\n        stackB.clear();\n        stackC.clear();\n        \n        n = Integer.parseInt(nm[0]);\n        m = Integer.parseInt(nm[1]);\n        \n        if(n+m == 0){\n            System.exit(0);\n        }\n        \n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackA_ini.push(Integer.parseInt(cupList[j+1]));\n        }\n\n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackB_ini.push(Integer.parseInt(cupList[j+1]));\n        }\n        \n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackC_ini.push(Integer.parseInt(cupList[j+1]));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int INF = Integer.MAX_VALUE / 4 + 1;\n\tpublic static final int MAX = 15;\n\t\n\tpublic static int[][] lists = new int[3][MAX];\n\tpublic static int[]   sizes = new int[3];\n\t\n\tpublic static int[][] prevs = new int[3][MAX];\n\tpublic static int[] p_sizes = new int[3];\n\t\n\tpublic static void lists_clear(){\n\t\tsizes[0] = sizes[1] = sizes[2] = 0;\n\t}\n\t\n\tpublic static void prevs_clear(){\n\t\tp_sizes[0] = p_sizes[1] = p_sizes[2] = 0;\n\t}\n\t\n\tpublic static void all_clear(){\n\t\tlists_clear();\n\t\tprevs_clear();\n\t}\n\t\n\tpublic static void print_list(int l){\n\t\tSystem.out.print(l + \"  :\");\n\t\tfor(int i = 0; i < sizes[l]; i++){\n\t\t\tSystem.out.print(\" \" + lists[l][i]);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void print_prev_list(int l){\n\t\tSystem.out.print(l + \" p:\");\n\t\tfor(int i = 0; i < p_sizes[l]; i++){\n\t\t\tSystem.out.print(\" \" + prevs[l][i]);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static boolean range_check(int i){\n\t\treturn 0 <= i && i < 3;\n\t}\n\t\n\tpublic static boolean is_goal(int n){\n\t\treturn sizes[0] == n && sizes[1] == 0 && sizes[2] == 0 || sizes[0] == 0 && sizes[1] == 0 && sizes[2] == n;\n\t}\n\t\n\tpublic static int get_list_top(int i){\n\t\tif(!range_check(i)){\n\t\t\treturn 0;\n\t\t}else if(sizes[i] == 0){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn lists[i][sizes[i] - 1];\n\t\t}\n\t}\n\t\n\tpublic static void save_to_prev(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tp_sizes[i] = sizes[i];\n\t\t\t\n\t\t\tfor(int j = 0; j < sizes[i]; j++){\n\t\t\t\tprevs[i][j] = lists[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void restore_from_prev(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tsizes[i] = p_sizes[i];\n\t\t\t\n\t\t\tfor(int j = 0; j < p_sizes[i]; j++){\n\t\t\t\tlists[i][j] = prevs[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean is_same(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tif(sizes[i] != p_sizes[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < sizes[i]; j++){\n\t\t\t\tif(lists[i][j] != prevs[i][j]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static void add_top(int l, int t){\n\t\tlists[l][sizes[l]] = t;\n\t\tsizes[l]++;\n\t}\n\t\n\tpublic static int remove_top(int l){\n\t\tint tmp = get_list_top(l);\n\t\tsizes[l]--;\n\t\t\n\t\treturn tmp;\n\t}\n\t\n\tpublic static void do_move_nocheck(int cur, int pur){\n\t\tadd_top(pur, remove_top(cur));\n\t}\n\t\n\tpublic static boolean can_move(int cur, boolean left){\n\t\tif(!range_check(cur)){\n\t\t\treturn false;\n\t\t}else if(sizes[cur] == 0){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfinal int pur = cur + (left ? -1 : 1);\n\t\tif(!range_check(pur)){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfinal int cur_top = get_list_top(cur);\n\t\tfinal int pur_top = get_list_top(pur);\n\t\t\n\t\tif(cur_top <= pur_top){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tboolean same = false;\n\t\t\n\t\tdo_move_nocheck(cur, pur);\n\t\t\n\t\t/*\n\t\tif(is_same()){\n\t\t\tsame = true;\n\t\t}\n\t\t*/\n\t\t\n\t\tdo_move_nocheck(pur, cur);\n\t\t\n\t\tif(same){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static void do_forward_move(int cur, boolean left){\n\t\tfinal int pur = cur + (left ? -1 : 1);\n\t\t\n\t\tdo_move_nocheck(cur, pur);\n\t}\n\t\n\tpublic static void do_backward_move(int cur, boolean left){\n\t\tfinal int pur = cur + (left ? -1 : 1);\n\t\t\n\t\tdo_move_nocheck(pur, cur);\n\t}\n\t\n\tpublic static int dfs(final int n, int deep, final int m){\n\t\tif(deep > m){\n\t\t\treturn INF;\n\t\t}\n\t\t\n\t\tif(is_goal(n)){\n\t\t\t/*\n\t\t\tSystem.out.println(\"--------------------\");\n\t\t\tprint_list(0);\n\t\t\tprint_prev_list(0);\n\t\t\tprint_list(1);\n\t\t\tprint_prev_list(1);\n\t\t\tprint_list(2);\n\t\t\tprint_prev_list(2);\n\t\t\t*/\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t\n\t\tint min = INF;\n\t\t\n\t\tfor(int left = 0; left < 2; left++){\n\t\t\tfor(int cur = 0; cur < 3; cur++){\n\t\t\t\tboolean can = can_move(cur, left == 0);\n\t\t\t\t\n\t\t\t\tif(can){\n\t\t\t\t\t//save_to_prev();\n\t\t\t\t\t\n\t\t\t\t\tdo_forward_move(cur, left == 0);\n\t\t\t\t\tmin = Math.min(min, dfs(n, deep + 1, m));\n\t\t\t\t\tdo_backward_move(cur, left == 0);\n\t\t\t\t\t\n\t\t\t\t\t//restore_from_prev();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn min + 1;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tall_clear();\n\t\t\t\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tsizes[i] = sc.nextInt();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < sizes[i]; j++){\n\t\t\t\t\tlists[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//boolean clear = false;\n\t\t\tint count = dfs(n, 0, m);\n\t\t\t\n\t\t\t/*\n\t\t\tfor(count = 0; count <= m; count++){\n\t\t\t\t\n\t\t\t\tSystem.out.println(count + \" : --------------------\");\n\t\t\t\tprint_list(0);\n\t\t\t\tprint_prev_list(0);\n\t\t\t\tprint_list(1);\n\t\t\t\tprint_prev_list(1);\n\t\t\t\tprint_list(2);\n\t\t\t\tprint_prev_list(2);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(is_goal(n)){\n\t\t\t\t\tclear = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean min_left = false;\n\t\t\t\tint min_cur = 0;\n\t\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\t\n\t\t\t\tfor(int left = 0; left < 2; left++){\n\t\t\t\t\tfor(int cur = 0; cur < 3; cur++){\n\t\t\t\t\t\tint ret = move(cur, left == 0, false);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(ret != 0 && ret < min){\n\t\t\t\t\t\t\tmin = ret;\n\t\t\t\t\t\t\tmin_cur = cur;\n\t\t\t\t\t\t\tmin_left = left == 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(min != Integer.MAX_VALUE){\n\t\t\t\t\tmove(min_cur, min_left, true);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"ERROR\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\tSystem.out.println(count <= m ? count : -1);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n==0 && m==0) break;\n\t\t\t\n\t\t\tint[] a = new int[n+2];\n\t\t\tint[] b = new int[n+2];\n\t\t\tint[] c = new int[n+2];\n\t\t\tint[] d = new int[n+2];\n\t\t\tint[] e = new int[n+2];\n\t\t\tint[] f = new int[n+2];\n\t\t\t\n\t\t\tint an = 0, bn = 0, cn = 0, dn = 0, en = 0, fn = 0;\n\t\t\t\n\t\t\tdn = sc.nextInt();\n\t\t\tfor(int i=1;i<=dn;i++) d[i] = sc.nextInt();\n\t\t\ten = sc.nextInt();\n\t\t\tfor(int i=1;i<=en;i++) e[i] = sc.nextInt();\n\t\t\tfn = sc.nextInt();\n\t\t\tfor(int i=1;i<=fn;i++) f[i] = sc.nextInt();\n\t\t\t\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\tint[] ini = new int[2];\n\t\t\tint com;\n\t\t\t\n\t\t\tif(d[dn]>e[en] && e[en]>f[fn]){\n\t\t\t\tini[0] = 0;\n\t\t\t\tini[1] = 2;\n\t\t\t}else if(d[dn]>e[en] && e[en]<f[fn]){\n\t\t\t\tini[0] = 0;\n\t\t\t\tini[1] = 3;\n\t\t\t}else if(d[dn]<e[en] && e[en]<f[fn]){\n\t\t\t\tini[0] = 1;\n\t\t\t\tini[1] = 3;\n\t\t\t}else if(d[dn]<e[en] && e[en]>f[fn]){\n\t\t\t\tini[0] = 1;\n\t\t\t\tini[1] = 2;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\tcom = ini[k];\n\t\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\t\ta[i] = d[i];\n\t\t\t\t\tb[i] = e[i];\n\t\t\t\t\tc[i] = f[i];\n\t\t\t\t}\n\t\t\t\tan = dn;\n\t\t\t\tbn = en;\n\t\t\t\tcn = fn;\n\t\t\t\tfor(int i=0;i<=m;i++){\n\t\t\t\t\tif(bn==0 && (an==0 || cn==0)){\n\t\t\t\t\t\tans = Math.min(ans, i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(com==0){\n\t\t\t\t\t\tbn++;\n\t\t\t\t\t\tb[bn] = a[an];\n\t\t\t\t\t\tan--;\n\t\t\t\t\t\tif(b[bn]>c[cn]) com = 2;\n\t\t\t\t\t\telse com = 3;\n\t\t\t\t\t}else if(com==1){\n\t\t\t\t\t\tan++;\n\t\t\t\t\t\ta[an] = b[bn];\n\t\t\t\t\t\tbn--;\n\t\t\t\t\t\tif(b[bn]>c[cn]) com = 2;\n\t\t\t\t\t\telse com = 3;\n\t\t\t\t\t}else if(com==2){\n\t\t\t\t\t\tcn++;\n\t\t\t\t\t\tc[cn] = b[bn];\n\t\t\t\t\t\tbn--;\n\t\t\t\t\t\tif(a[an]>b[bn]) com = 0;\n\t\t\t\t\t\telse com = 1;\n\t\t\t\t\t}else if(com==3){\n\t\t\t\t\t\tbn++;\n\t\t\t\t\t\tb[bn] = c[cn];\n\t\t\t\t\t\tcn--;\n\t\t\t\t\t\tif(a[an]>b[bn]) com = 0;\n\t\t\t\t\t\telse com = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ans==Integer.MAX_VALUE) System.out.println(-1);\n\t\t\telse System.out.println(ans);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.math.BigInteger;\nimport java.math.BigDecimal;\n      \npublic class Main{\n  \nstatic final InputStream in=System.in;\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic final long LINF=Long.MAX_VALUE/2;\nstatic int n,m,a,b,c;\nstatic Deque<Integer> queA,queB,queC;\n  \npublic static void main(String[] args) throws IOException{\nInputReader ir=new InputReader(in);\nwhile(true){\nn=ir.nextInt();\nm=ir.nextInt();\nif(n==0&&m==0) break;\nqueA=new ArrayDeque<Integer>();\nqueB=new ArrayDeque<Integer>();\nqueC=new ArrayDeque<Integer>();\na=ir.nextInt();\nif(a!=0){\nfor(int i=0;i<a;i++) queA.offerFirst(ir.nextInt());\n}\nb=ir.nextInt();\nif(b!=0){\nfor(int i=0;i<b;i++) queB.offerFirst(ir.nextInt());\n}\nc=ir.nextInt();\nif(c!=0){\nfor(int i=0;i<c;i++) queC.offerFirst(ir.nextInt());\n}\nint ans=dfs(0,0);\nout.println(ans>m?-1:ans);\n}\nout.flush();\n}\n\npublic static int dfs(int depth,int prev){\nif(depth>m||queA.size()==n||queC.size()==n) return depth;\nint s=m+1,t=m+1,u=m+1,v=m+1;\nif(prev!=3&&!queA.isEmpty()){\nif(queB.isEmpty()||(!queB.isEmpty()&&queA.peekFirst()>queB.peekFirst())){\nint temp=queA.pollFirst();\nqueB.offerFirst(temp);\ns=dfs(depth+1,1);\nqueB.pollFirst();\nqueA.offerFirst(temp);\n}\n}\nif(prev!=4&&!queC.isEmpty()){\nif(queB.isEmpty()||(!queB.isEmpty()&&queC.peekFirst()>queB.peekFirst())){\nint temp=queC.pollFirst();\nqueB.offerFirst(temp);\nt=dfs(depth+1,2);\nqueB.pollFirst();\nqueC.offerFirst(temp);\n}\n}\nif(!queB.isEmpty()){\nif(prev!=1){\nif(queA.isEmpty()){\nint temp=queB.pollFirst();\nqueA.offerFirst(temp);\nu=dfs(depth+1,3);\nqueA.pollFirst();\nqueB.offerFirst(temp);\n}\nelse if(queB.peekFirst()>queA.peekFirst()){\nint temp=queB.pollFirst();\nqueA.offerFirst(temp);\nu=dfs(depth+1,3);\nqueA.pollFirst();\nqueB.offerFirst(temp);\n}\n}\nif(prev!=2){\nif(queC.isEmpty()){\nint temp=queB.pollFirst();\nqueC.offerFirst(temp);\nv=dfs(depth+1,4);\nqueC.pollFirst();\nqueB.offerFirst(temp);\n}\nelse if(queB.peekFirst()>queC.peekFirst()){\nint temp=queB.pollFirst();\nqueC.offerFirst(temp);\nv=dfs(depth+1,4);\nqueC.pollFirst();\nqueB.offerFirst(temp);\n}\n}\n}\nreturn Math.min(Math.min(s,t),Math.min(u,v));\n}\n\nstatic class InputReader {\nprivate InputStream in;\nprivate byte[] buffer=new byte[1024];\nprivate int curbuf;\nprivate int lenbuf;\n  \npublic InputReader(InputStream in) {this.in=in;}\n    \npublic int readByte() {\nif(lenbuf==-1) throw new InputMismatchException();\nif(curbuf>=lenbuf){\ncurbuf= 0;\ntry{\nlenbuf=in.read(buffer);\n}\ncatch (IOException e) {\nthrow new InputMismatchException();\n}\nif(lenbuf<=0)\nreturn -1;\n}\nreturn buffer[curbuf++];\n}\n  \npublic boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \nprivate int skip() {int b; while((b = readByte())!=-1&&isSpaceChar(b)); return b;}\n  \npublic String next() {\nint b=skip();\nStringBuilder sb=new StringBuilder();\nwhile(!isSpaceChar(b)){\nsb.appendCodePoint(b);\nb=readByte();\n}\nreturn sb.toString();\n}\n   \npublic int nextInt() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nint res=0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic long nextLong() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nlong res = 0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic int[] toIntArray(int n){\nint[] a=new int[n];\nfor(int i=0;i<n;i++) a[i]=nextInt();\nreturn a;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int MAX = 15;\n\t\n\tpublic static int[][] lists = new int[3][MAX];\n\tpublic static int[]   sizes = new int[3];\n\t\n\tpublic static int[][] prevs = new int[3][MAX];\n\tpublic static int[] p_sizes = new int[3];\n\t\n\tpublic static int[][] inputs = new int[3][MAX];\n\tpublic static int[] i_sizes = new int[3];\n\t\n\tpublic static void lists_clear(){\n\t\tsizes[0] = sizes[1] = sizes[2] = 0;\n\t}\n\t\n\tpublic static void prevs_clear(){\n\t\tp_sizes[0] = p_sizes[1] = p_sizes[2] = 0;\n\t}\n\t\n\tpublic static void all_clear(){\n\t\tlists_clear();\n\t\tprevs_clear();\n\t}\n\t\n\tpublic static void print_list(int l){\n\t\tSystem.out.print(l + \"  :\");\n\t\tfor(int i = 0; i < sizes[l]; i++){\n\t\t\tSystem.out.print(\" \" + lists[l][i]);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void print_prev_list(int l){\n\t\tSystem.out.print(l + \" p:\");\n\t\tfor(int i = 0; i < p_sizes[l]; i++){\n\t\t\tSystem.out.print(\" \" + prevs[l][i]);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static boolean range_check(int i){\n\t\treturn 0 <= i && i < 3;\n\t}\n\t\n\tpublic static boolean is_goal(int n){\n\t\treturn sizes[0] == n && sizes[1] == 0 && sizes[2] == 0 || sizes[0] == 0 && sizes[1] == 0 && sizes[2] == n;\n\t}\n\t\n\tpublic static int get_list_top(int i){\n\t\tif(!range_check(i)){\n\t\t\treturn 0;\n\t\t}else if(sizes[i] == 0){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn lists[i][sizes[i] - 1];\n\t\t}\n\t}\n\t\n\tpublic static void save_to_prev(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tp_sizes[i] = sizes[i];\n\t\t\t\n\t\t\tfor(int j = 0; j < sizes[i]; j++){\n\t\t\t\tprevs[i][j] = lists[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void apply_to_list(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tsizes[i] = i_sizes[i];\n\t\t\t\n\t\t\tfor(int j = 0; j < sizes[i]; j++){\n\t\t\t\tlists[i][j] = inputs[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean is_same(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tif(sizes[i] != p_sizes[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < sizes[i]; j++){\n\t\t\t\tif(lists[i][j] != prevs[i][j]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static void add_top(int l, int t){\n\t\tlists[l][sizes[l]] = t;\n\t\tsizes[l]++;\n\t}\n\t\n\tpublic static int remove_top(int l){\n\t\tint tmp = get_list_top(l);\n\t\tsizes[l]--;\n\t\t\n\t\treturn tmp;\n\t}\n\t\n\tpublic static void do_move_nocheck(int cur, int pur){\n\t\tadd_top(pur, remove_top(cur));\n\t}\n\t\n\tpublic static boolean can_move(int cur, boolean left){\n\t\tif(!range_check(cur)){\n\t\t\treturn false;\n\t\t}else if(sizes[cur] == 0){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfinal int pur = cur + (left ? -1 : 1);\n\t\tif(!range_check(pur)){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tfinal int cur_top = get_list_top(cur);\n\t\tfinal int pur_top = get_list_top(pur);\n\t\t\n\t\tif(cur_top <= pur_top){\n\t\t\treturn false;\n\t\t}\n\t\n\t\tboolean same = false;\n\t\t\n\t\tdo_move_nocheck(cur, pur);\n\t\t\n\t\t\n\t\tif(is_same()){\n\t\t\tsame = true;\n\t\t}\n\t\t\n\t\t\n\t\tdo_move_nocheck(pur, cur);\n\t\t\n\t\tif(same){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static int move(int cur, boolean left, boolean do_it){\n\t\tif(!range_check(cur)){\n\t\t\treturn 0;\n\t\t}else if(sizes[cur] == 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfinal int pur = cur + (left ? -1 : 1);\n\t\tif(!range_check(pur)){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfinal int cur_top = get_list_top(cur);\n\t\tfinal int pur_top = get_list_top(pur);\n\t\t\n\t\tif(cur_top <= pur_top){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tboolean same = false;\n\t\tif(do_it){\n\t\t\tsave_to_prev();\n\t\t}\n\t\tadd_top(pur, remove_top(cur));\n\t\t\n\t\tif(do_it){\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}\n\t\t\n\t\tif(is_same()){\n\t\t\tsame = true;\n\t\t}\n\t\t\n\t\tadd_top(cur, remove_top(pur));\n\t\t\n\t\tif(same){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn cur_top;\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tall_clear();\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\ti_sizes[i] = sc.nextInt();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < i_sizes[i]; j++){\n\t\t\t\t\tinputs[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean clear = false;\n\t\t\tint count1 = 0;\n\t\t\tapply_to_list();\n\t\t\tfor(count1 = 0; count1 <= m; count1++){\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(count1 + \" : --------------------\");\n\t\t\t\tprint_list(0);\n\t\t\t\tprint_prev_list(0);\n\t\t\t\tprint_list(1);\n\t\t\t\tprint_prev_list(1);\n\t\t\t\tprint_list(2);\n\t\t\t\tprint_prev_list(2);\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\tif(is_goal(n)){\n\t\t\t\t\tclear = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean min_left = false;\n\t\t\t\tint min_cur = 0;\n\t\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\t\n\t\t\t\tfor(int left = 0; left < 2; left++){\n\t\t\t\t\tfor(int cur = 0; cur < 3; cur++){\n\t\t\t\t\t\tint ret = move(cur, left == 0, false);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(ret != 0 && ret < min){\n\t\t\t\t\t\t\tmin = ret;\n\t\t\t\t\t\t\tmin_cur = cur;\n\t\t\t\t\t\t\tmin_left = left == 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(min != Integer.MAX_VALUE){\n\t\t\t\t\tmove(min_cur, min_left, true);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"ERROR\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint count2 = 0;\n\t\t\tapply_to_list();\n\t\t\tfor(count2 = 0; count2 <= m; count2++){\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(count2 + \" : --------------------\");\n\t\t\t\tprint_list(0);\n\t\t\t\tprint_prev_list(0);\n\t\t\t\tprint_list(1);\n\t\t\t\tprint_prev_list(1);\n\t\t\t\tprint_list(2);\n\t\t\t\tprint_prev_list(2);\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\tif(is_goal(n)){\n\t\t\t\t\tclear = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean min_left = false;\n\t\t\t\tint min_cur = 0;\n\t\t\t\tint max = Integer.MIN_VALUE;\n\t\t\t\t\n\t\t\t\tfor(int left = 0; left < 2; left++){\n\t\t\t\t\tfor(int cur = 0; cur < 3; cur++){\n\t\t\t\t\t\tint ret = move(cur, left == 0, false);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(ret != 0 && ret > max){\n\t\t\t\t\t\t\tmax = ret;\n\t\t\t\t\t\t\tmin_cur = cur;\n\t\t\t\t\t\t\tmin_left = left == 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(max != Integer.MIN_VALUE){\n\t\t\t\t\tmove(min_cur, min_left, true);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"ERROR\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(clear ? Math.min(count1, count2) + \"\" : \"-1\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport static java.lang.Integer.*;\nimport java.util.Stack;\n\nclass Main{\n    static int n,m,ans=0;\n    \n    static Stack<Integer> stackA_ini;\n    static Stack<Integer> stackB_ini;\n    static Stack<Integer> stackC_ini;\n    \n    static Stack<Integer> stackA;\n    static Stack<Integer> stackB;\n    static Stack<Integer> stackC;\n    \n    public static void main(String[] a)throws IOException{\n        while(true){\n            inputData();\n            ans = Math.min(calcFromLeft(),calcFromRight());\n            ans = (ans <= m) ? ans : -1;               \n            System.out.println(ans);\n        }\n        \n    }\n    static int calcFromLeft(){\n        int step = 0;\n        initializeStack();\n        \n        //左初動\n        while(true){\n            // 終了判定\n            if(isFinished()) break;\n \n            // 左２つのコップで入れ替え\n            if(peekStack(stackA)>peekStack(stackB))\n                stackB.push(stackA.pop());\n            else\n                stackA.push(stackB.pop());\n            \n            step++;\n            \n            // 終了判定\n            if(isFinished()) break;\n                \n            // 右２つのコップで入れ替え\n            if(peekStack(stackB)>peekStack(stackC))\n                stackC.push(stackB.pop());\n            else\n                stackB.push(stackC.pop());\n            \n            step++;\n        }\n        return step;\n    }\n    static int calcFromRight(){\n        \n        int step = 0;\n        initializeStack();\n                \n        //右初動\n        while(true){     \n            // 終了判定\n            if(isFinished()) break;\n            \n            // 右２つのコップで入れ替え\n            if(peekStack(stackB)>peekStack(stackC))\n                stackC.push(stackB.pop());\n            else\n                stackB.push(stackC.pop());\n\n            step++;\n            \n            // 終了判定\n            if(isFinished()) break;          \n            \n            // 左２つのコップで入れ替え\n            if(peekStack(stackA)>peekStack(stackB))\n                stackB.push(stackA.pop());\n            else\n                stackA.push(stackB.pop());\n            \n            step++;\n        }\n        return step;\n    }\n    \n    static void initializeStack(){\n        stackA = (Stack<Integer>) stackA_ini.clone();\n        stackB = (Stack<Integer>) stackB_ini.clone();\n        stackC = (Stack<Integer>) stackC_ini.clone();\n    }\n    \n    static boolean isFinished(){\n        if(stackB.empty() && (stackA.empty() || stackC.empty()))\n            return true;\n        else\n            return false;\n    }\n    static int peekStack(Stack<Integer> stack){\n        return stack.empty() ? 0:stack.peek();      \n    }\n    \n    static void inputData() throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String[] nm = in.readLine().split(\" \");\n        String[] cupList;\n        int cupNum = 0;\n\n        stackA.clear();\n        stackB.clear();\n        stackC.clear();\n        \n        n = Integer.parseInt(nm[0]);\n        m = Integer.parseInt(nm[1]);\n        \n        if(n+m == 0){\n            System.exit(0);\n        }\n        \n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackA_ini.push(Integer.parseInt(cupList[j+1]));\n        }\n\n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackB_ini.push(Integer.parseInt(cupList[j+1]));\n        }\n        \n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackC_ini.push(Integer.parseInt(cupList[j+1]));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint m, n;\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\tLinkedList<Integer>[] cups = new LinkedList[3+2];\n\t\t\tcups[0] = new LinkedList<Integer>();\n\t\t\tcups[4] = new LinkedList<Integer>();\n\t\t\tcups[0].add(30);\n\t\t\tcups[4].add(30);\n\t\t\t\n\t\t\tfor(int i=1;i<=3;i++) {\n\t\t\t\tcups[i] = new LinkedList<Integer>();\n\t\t\t\tcups[i].add(0);\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tfor(int j=0;j<k;j++) cups[i].add(sc.nextInt());\n\t\t\t}\n\t\t\tif( cups[1].size() == n+1 || cups[3].size() == n+1 ) System.out.println(0);\n\t\t\tint c = cups[2].getLast();\n\t\t\tint left = cups[1].getLast();\n\t\t\tint right = cups[3].getLast();\n\t\t\tint cnt = 0;\n\t\t\tif( c > max(left, right) ) {\n\t\t\t\tLinkedList<Integer>[] tmp = new LinkedList[5];\n\t\t\t\tfor(int i=0;i<5;i++) tmp[i] = new LinkedList<Integer>(cups[i]);\n\t\t\t\ttmp[1].add(tmp[2].removeLast());\n\t\t\t\tcnt = solve(tmp, c, 2, 1);\n\t\t\t\tcups[3].add(cups[2].removeLast());\n\t\t\t\tcnt = min(cnt, solve(cups, c, 2, 1));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcnt = solve(cups, -1, -1, 0);\n\t\t\t}\n\t\t\tif( cnt <= m ) System.out.println(cnt);\n\t\t\telse System.out.println(-1);\n\t\t}\n\t}\n\t\n\tint solve(LinkedList<Integer>[] cups, int pastp, int pasti, int cp) {\n\t\tint cnt;\n\t\tint p, i;\n\t\t\n\t\tfor(cnt=cp;cnt<=m;cnt++) {\n\t\t\ti = 0;\n\t\t\tp = 20;\n\t\t\tif( cups[1].size() == n+1 || cups[3].size() == n+1 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint from = 0;\n\t\t\t\n\t\t\tfor(int j=1;j<=3;j++) {\n\t\t\t\tint left = cups[j-1].getLast();\n\t\t\t\tint right = cups[j+1].getLast();\n\t\t\t\tint c = cups[j].getLast();\n//\t\t\t\tdebug(left, right, c);\n\t\t\t\tif( p < c || c == 0 || ( c == 1 && ( j == 1 || j == 3 ) ) ) continue;\n\t\t\t\tif( c != pastp && c > left ) {\n\t\t\t\t\tp = c;\n\t\t\t\t\ti = j-1;\n\t\t\t\t\tfrom = j;\n\t\t\t\t}\n\t\t\t\telse if( c != pastp && c > right ) {\n\t\t\t\t\tp = c;\n\t\t\t\t\ti = j+1;\n\t\t\t\t\tfrom = j;\n\t\t\t\t}\n\t\t\t\telse if( c == pastp && c > left && pasti != j-1 ) {\n\t\t\t\t\tp = c;\n\t\t\t\t\ti = j-1;\n\t\t\t\t\tfrom = j;\n\t\t\t\t}\n\t\t\t\telse if( c == pastp && c > right && pasti != j+1 ) {\n\t\t\t\t\tp = c;\n\t\t\t\t\ti = j+1;\n\t\t\t\t\tfrom = j;\n\t\t\t\t}\n\t\t\t\telse continue;\n//\t\t\t\tdebug(\"    \", p, i, from);\n//\t\t\t\tdebug(\"    \", pasti, from);\n\t\t\t}\n\t\t\tcups[i].addLast( cups[from].removeLast() );\n\t\t\tpastp = p;\n\t\t\tpasti = from;\n//\t\t\tfor(LinkedList<Integer> a: cups) debug(a);\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tlong[][][][] memo = new long[3][16][16][16];\n\tint[] cups;\n\tint n;\n\t\n\tlong calcA(int a, int b,int c) {\n\t\tif (memo[0][a][b][c] == 0) {\n\t\t\tif (c == 0 && b == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (b == 0 && a == 0) {\n\t\t\t\treturn memo[0][a][b][c] = (long)(Math.pow(3, c)-1);\n\t\t\t}\n\t\t\tint mp = cups[n-a-b-c];\n\t\t\tif (mp == 2) {\n\t\t\t\tmemo[0][a][b][c] = calcA(a, b, c-1) + calcC(a+b+c-1, 0, 0) + calcA(0, 0, a+b+c-1) + 2;\n\t\t\t} else if (mp == 1) {\n\t\t\t\tmemo[0][a][b][c] = calcC(a, b-1, c) + calcA(0, 0, a+b+c-1) + 1;\n\t\t\t} else {\n\t\t\t\tmemo[0][a][b][c] = calcA(a-1, b, c);\n\t\t\t}\n\t\t}\n\t\treturn memo[0][a][b][c];\n\t}\n\t\n\tlong calcB(int a, int b,int c) {\n\t\tif (memo[1][a][b][c] == 0) {\n\t\t\tif (a == 0 && c == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((a == 0 && b == 0) || (b == 0 && c == 0)) {\n\t\t\t\treturn memo[1][a][b][c] = (long)(Math.pow(3, a+c)-3)/2 + 1;\n\t\t\t}\n\t\t\tint mp = cups[n-a-b-c];\n\t\t\tif (mp == 0) {\n\t\t\t\tmemo[1][a][b][c] = calcC(a-1, b, c) + calcB(0, 0, a+b+c-1) + 1;\n\t\t\t} else if (mp == 1) {\n\t\t\t\tmemo[1][a][b][c] = calcB(a, b-1, c);\n\t\t\t} else {\n\t\t\t\tmemo[1][a][b][c] = calcA(a, b, c-1) + calcB(a+b+c-1, 0, 0) + 1;\n\t\t\t}\n\t\t}\n\t\treturn memo[1][a][b][c];\n\t}\n\t\n\tlong calcC(int a, int b, int c) {\n\t\tif (memo[2][a][b][c] == 0) {\n\t\t\tif (a == 0 && b == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (b == 0 && c == 0) {\n\t\t\t\treturn memo[2][a][b][c] = (long)(Math.pow(3, a)-1);\n\t\t\t}\n\t\t\tint mp = cups[n-a-b-c];\n\t\t\tif (mp == 0) {\n\t\t\t\tmemo[2][a][b][c] = calcC(a-1, b, c) + calcA(0, 0, a+b+c-1) + calcC(a+b+c-1, 0, 0) + 2;\n\t\t\t} else if (mp == 1) {\n\t\t\t\tmemo[2][a][b][c] = calcA(a, b-1, c) + calcC(a+b+c-1, 0, 0) + 1;\n\t\t\t} else {\n\t\t\t\tmemo[2][a][b][c] = calcC(a, b, c-1);\n\t\t\t}\n\t\t}\n\t\treturn memo[2][a][b][c];\n\t}\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif (n == 0 && m == 0) break;\n\t\t\t\n\t\t\tcups = new int[n];\n\t\t\tint a = 0, b = 0, c = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tint num = sc.nextInt();\n\t\t\t\tif (i == 0) a = num;\n\t\t\t\telse if (i == 1) b = num;\n\t\t\t\telse c = num;\n\t\t\t\tfor (int j = 0; j < num; j++) {\n\t\t\t\t\tcups[sc.nextInt()-1] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong res = Math.min(calcA(a, b, c), calcC(a, b, c));\n\t\t\tif (res <= m)\n\t\t\t\tout.println(res);\n\t\t\telse\n\t\t\t\tout.println(-1);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\n\t\t\tCup c = new Cup(n, m);\n\t\t\tCup d = new Cup(n, m);\n\t\t\tfor (int L = 0; L < 3; L++) {\n\t\t\t\tint nl = scan.nextInt();\n\t\t\t\tfor (int j = 0; j < nl; j++) {\n\t\t\t\t\tint cup = scan.nextInt();\n\t\t\t\t\tc.set(L, cup);\n\t\t\t\t\td.set(L, cup);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.move(0, 1);\n\t\t\td.move(2, 1);\n\t\t\tif (c.getOper() > m && d.getOper() > m)\n\t\t\t\tSystem.out.println(-1);\n\t\t\telse\n\t\t\t\tSystem.out.println(Math.min(c.getOper(), d.getOper()));\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Cup {\n\tint max;\n\tboolean[][] c;\n\tint oper;\n\tint operLimit;\n\n\tpublic Cup(int n, int limit) {\n\t\tmax = n;\n\t\toper = 0;\n\t\toperLimit = limit;\n\t\tc = new boolean[3][n];\n\t\tfor (int l = 0; l < 3; l++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tc[l][i] = false;\n\t}\n\n\tpublic int getOper() {\n\t\treturn oper;\n\t}\n\n\tpublic void move(int toLoc, int cup) {\n\t\tif (oper > operLimit)\n\t\t\treturn;\n\n\t\tif (cup > max)\n\t\t\treturn;\n\n\t\tif (c[toLoc][cup - 1]) {\n\t\t\tthis.move(toLoc, cup + 1);\n\t\t\treturn;\n\t\t}\n\n\t\tint wkLoc;\n\t\tif (toLoc == 0)\n\t\t\twkLoc = 2;\n\t\telse\n\t\t\twkLoc = 0;\n\n\t\tif (c[wkLoc][cup - 1]) {\n\t\t\tthis.move(toLoc, cup + 1);\n\t\t\tthis.moveOne(1, cup);\n\t\t}\n\t\tthis.move(wkLoc, cup + 1);\n\t\tthis.moveOne(toLoc, cup);\n\t\tthis.move(toLoc, cup + 1);\n\t\treturn;\n\n\t}\n\n\tprivate void moveOne(int toLoc, int cup) {\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tif (i == toLoc)\n\t\t\t\tc[i][cup - 1] = true;\n\t\t\telse\n\t\t\t\tc[i][cup - 1] = false;\n\t\toper++;\n\t}\n\n\tpublic void set(int loc, int cup) {\n\t\tc[loc][cup - 1] = true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.math.BigInteger;\nimport java.math.BigDecimal;\n      \npublic class Main{\n  \nstatic final InputStream in=System.in;\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic final long LINF=Long.MAX_VALUE/2;\nstatic int n,m,a,b,c;\nstatic Deque<Integer> queA,queB,queC;\n  \npublic static void main(String[] args) throws IOException{\nInputReader ir=new InputReader(in);\nwhile(true){\nn=ir.nextInt();\nm=ir.nextInt();\nif(n==0&&m==0) break;\nqueA=new ArrayDeque<Integer>();\nqueB=new ArrayDeque<Integer>();\nqueC=new ArrayDeque<Integer>();\na=ir.nextInt();\nif(a!=0){\nfor(int i=0;i<a;i++) queA.offerFirst(ir.nextInt());\n}\nb=ir.nextInt();\nif(b!=0){\nfor(int i=0;i<b;i++) queB.offerFirst(ir.nextInt());\n}\nc=ir.nextInt();\nif(c!=0){\nfor(int i=0;i<c;i++) queC.offerFirst(ir.nextInt());\n}\nint ans=dfs(0);\nout.println(ans>m?-1:ans);\n}\nout.flush();\n}\n\npublic static int dfs(int depth){\nif(depth>m||queA.size()==n||queC.size()==n) return depth;\nint s=m+1,t=m+1,u=m+1,v=m+1;\nif(!queA.isEmpty()){\nif(queB.isEmpty()||(!queB.isEmpty()&&queA.peekFirst()>queB.peekFirst())){\nint temp=queA.pollFirst();\nqueB.offerFirst(temp);\ns=dfs(depth+1);\nqueB.pollFirst();\nqueA.offerFirst(temp);\n}\n}\nif(!queC.isEmpty()){\nif(queB.isEmpty()||(!queB.isEmpty()&&queC.peekFirst()>queB.peekFirst())){\nint temp=queC.pollFirst();\nqueB.offerFirst(temp);\nt=dfs(depth+1);\nqueB.pollFirst();\nqueC.offerFirst(temp);\n}\n}\nif(!queB.isEmpty()){\nif(queA.isEmpty()){\nint temp=queB.pollFirst();\nqueA.offerFirst(temp);\nu=dfs(depth+1,3);\nqueA.pollFirst();\nqueB.offerFirst(temp);\n}\nelse if(queB.peekFirst()>queA.peekFirst()){\nint temp=queB.pollFirst();\nqueA.offerFirst(temp);\nu=dfs(depth+1,3);\nqueA.pollFirst();\nqueB.offerFirst(temp);\n}\nif(queC.isEmpty()){\nint temp=queB.pollFirst();\nqueC.offerFirst(temp);\nv=dfs(depth+1,4);\nqueC.pollFirst();\nqueB.offerFirst(temp);\n}\nelse if(queB.peekFirst()>queC.peekFirst()){\nint temp=queB.pollFirst();\nqueC.offerFirst(temp);\nv=dfs(depth+1,4);\nqueC.pollFirst();\nqueB.offerFirst(temp);\n}\n}\nreturn Math.min(Math.min(s,t),Math.min(u,v));\n}\n\nstatic class InputReader {\nprivate InputStream in;\nprivate byte[] buffer=new byte[1024];\nprivate int curbuf;\nprivate int lenbuf;\n  \npublic InputReader(InputStream in) {this.in=in;}\n    \npublic int readByte() {\nif(lenbuf==-1) throw new InputMismatchException();\nif(curbuf>=lenbuf){\ncurbuf= 0;\ntry{\nlenbuf=in.read(buffer);\n}\ncatch (IOException e) {\nthrow new InputMismatchException();\n}\nif(lenbuf<=0)\nreturn -1;\n}\nreturn buffer[curbuf++];\n}\n  \npublic boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \nprivate int skip() {int b; while((b = readByte())!=-1&&isSpaceChar(b)); return b;}\n  \npublic String next() {\nint b=skip();\nStringBuilder sb=new StringBuilder();\nwhile(!isSpaceChar(b)){\nsb.appendCodePoint(b);\nb=readByte();\n}\nreturn sb.toString();\n}\n   \npublic int nextInt() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nint res=0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic long nextLong() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nlong res = 0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic int[] toIntArray(int n){\nint[] a=new int[n];\nfor(int i=0;i<n;i++) a[i]=nextInt();\nreturn a;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n==0 && m==0) break;\n\t\t\t\n\t\t\tint[] a = new int[n+2];\n\t\t\tint[] b = new int[n+2];\n\t\t\tint[] c = new int[n+2];\n\t\t\tint[] d = new int[n+2];\n\t\t\tint[] e = new int[n+2];\n\t\t\tint[] f = new int[n+2];\n\t\t\t\n\t\t\tint an = 0, bn = 0, cn = 0, dn = 0, en = 0, fn = 0;\n\t\t\t\n\t\t\tdn = sc.nextInt();\n\t\t\tfor(int i=1;i<=dn;i++) d[i] = sc.nextInt();\n\t\t\ten = sc.nextInt();\n\t\t\tfor(int i=1;i<=en;i++) e[i] = sc.nextInt();\n\t\t\tfn = sc.nextInt();\n\t\t\tfor(int i=1;i<=fn;i++) f[i] = sc.nextInt();\n\t\t\t\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\tint[] ini = new int[2];\n\t\t\tint com;\n\t\t\t\n\t\t\tif(d[dn]>e[en] && e[en]>f[fn]){\n\t\t\t\tini[0] = 0;\n\t\t\t\tini[1] = 2;\n\t\t\t}else if(d[dn]>e[en] && e[en]<f[fn]){\n\t\t\t\tini[0] = 0;\n\t\t\t\tini[1] = 3;\n\t\t\t}else if(d[dn]<e[en] && e[en]<f[fn]){\n\t\t\t\tini[0] = 1;\n\t\t\t\tini[1] = 3;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\tcom = ini[k];\n\t\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\t\ta[i] = d[i];\n\t\t\t\t\tb[i] = e[i];\n\t\t\t\t\tc[i] = f[i];\n\t\t\t\t}\n\t\t\t\tan = dn;\n\t\t\t\tbn = en;\n\t\t\t\tcn = fn;\n\t\t\t\tfor(int i=0;i<=m;i++){\n\t\t\t\t\tif(bn==0 && (an==0 || cn==0)){\n\t\t\t\t\t\tans = Math.min(ans, i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(com==0){\n\t\t\t\t\t\tbn++;\n\t\t\t\t\t\tb[bn] = a[an];\n\t\t\t\t\t\tan--;\n\t\t\t\t\t\tif(b[bn]>c[cn]) com = 2;\n\t\t\t\t\t\telse com = 3;\n\t\t\t\t\t}else if(com==1){\n\t\t\t\t\t\tan++;\n\t\t\t\t\t\ta[an] = b[bn];\n\t\t\t\t\t\tbn--;\n\t\t\t\t\t\tif(b[bn]>c[cn]) com = 2;\n\t\t\t\t\t\telse com = 3;\n\t\t\t\t\t}else if(com==2){\n\t\t\t\t\t\tcn++;\n\t\t\t\t\t\tc[cn] = b[bn];\n\t\t\t\t\t\tbn--;\n\t\t\t\t\t\tif(a[an]>b[bn]) com = 0;\n\t\t\t\t\t\telse com = 1;\n\t\t\t\t\t}else if(com==3){\n\t\t\t\t\t\tbn++;\n\t\t\t\t\t\tb[bn] = c[cn];\n\t\t\t\t\t\tcn--;\n\t\t\t\t\t\tif(a[an]>b[bn]) com = 0;\n\t\t\t\t\t\telse com = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(ans==Integer.MAX_VALUE) System.out.println(-1);\n\t\t\telse System.out.println(ans);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Stack;\n\nclass Main{\n    static int n,m,ans=0;\n    \n    static Stack<Integer> stackA_ini;\n    static Stack<Integer> stackB_ini;\n    static Stack<Integer> stackC_ini;\n    \n    static Stack<Integer> stackA;\n    static Stack<Integer> stackB;\n    static Stack<Integer> stackC;\n    \n    public static void main(String[] a)throws IOException{\n        while(true){\n            inputData();\n            ans = Math.min(calcFromLeft(),calcFromRight());\n            ans = (ans <= m) ? ans : -1;               \n            System.out.println(ans);\n        }\n        \n    }\n    \n    static int calcFromLeft(){\n        int step = 0;\n        \n        //左初動\n        while(true){\n            // 終了判定\n            if(isFinished()) break;\n \n            // 左２つのコップで入れ替え\n            if(peekStack(stackA)>peekStack(stackB))\n                stackB.push(stackA.pop());\n            else\n                stackA.push(stackB.pop());\n            \n            step++;\n            \n            // 終了判定\n            if(isFinished()) break;\n                \n            // 右２つのコップで入れ替え\n            if(peekStack(stackB)>peekStack(stackC))\n                stackC.push(stackB.pop());\n            else\n                stackB.push(stackC.pop());\n            \n            step++;\n        }\n        return step;\n    }\n    \n    static int calcFromRight(){\n        \n        int step = 0;\n        stackA = stackA_ini;\n        stackB = stackB_ini;\n        stackC = stackC_ini;\n                 \n        //右初動\n        while(true){     \n            // 終了判定\n            if(isFinished()) break;\n            \n            // 右２つのコップで入れ替え\n            if(peekStack(stackB)>peekStack(stackC))\n                stackC.push(stackB.pop());\n            else\n                stackB.push(stackC.pop());\n\n            step++;\n            \n            // 終了判定\n            if(isFinished()) break;          \n            \n            // 左２つのコップで入れ替え\n            if(peekStack(stackA)>peekStack(stackB))\n                stackB.push(stackA.pop());\n            else\n                stackA.push(stackB.pop());\n            \n            step++;\n        }\n        return step;\n    }\n      \n    static boolean isFinished(){\n        if(stackB.empty() && (stackA.empty() || stackC.empty()))\n            return true;\n        else\n            return false;\n    }\n    \n    static int peekStack(Stack<Integer> stack){\n        return stack.empty() ? 0:stack.peek();      \n    }\n    \n    static void inputData() throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String[] nm = in.readLine().split(\" \");\n        String[] cupList;\n        int cupNum = 0;\n\n        stackA = new Stack<Integer>();\n        stackB = new Stack<Integer>();\n        stackC = new Stack<Integer>();\n        stackA_ini = new Stack<Integer>();\n        stackB_ini = new Stack<Integer>();\n        stackC_ini = new Stack<Integer>();\n        \n        n = Integer.parseInt(nm[0]);\n        m = Integer.parseInt(nm[1]);\n        \n        if(n+m == 0){\n            System.exit(0);\n        }\n        \n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackA_ini.push(Integer.parseInt(cupList[j+1]));\n            stackA.push(Integer.parseInt(cupList[j+1]));\n        }\n\n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackB_ini.push(Integer.parseInt(cupList[j+1]));\n            stackB.push(Integer.parseInt(cupList[j+1]));\n        }\n        \n        cupList = in.readLine().split(\" \");\n        for(int j=0; Integer.parseInt(cupList[0])>j; j++){\n            stackC_ini.push(Integer.parseInt(cupList[j+1]));\n            stackC.push(Integer.parseInt(cupList[j+1]));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\t\n\tpublic static void print(int[][] states, int[] sizes){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tSystem.out.print(sizes[i] + \" :\");\n\t\t\tfor(int j = 0; j < sizes[i]; j++){\n\t\t\t\tSystem.out.print(\" \" + states[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void translate(int from, int to, int[][] states, int[] sizes){\n\t\t//System.out.println(\"---------------------------------\");\n\t\t//print(states, sizes);\n\t\t//System.out.println(from + \" => \" + to);\n\t\t\n\t\tsizes[from]--;\n\t\tstates[to][sizes[to]] = states[from][sizes[from]];\n\t\tsizes[to]++;\n\t\t\n\t}\n\t\n\tpublic static boolean is_same(int[][] states, int[] sizes, int[][] p_states, int[] p_sizes){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tif(sizes[i] != p_sizes[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < sizes[i]; j++){\n\t\t\t\tif(states[i][j] != p_states[i][j]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static int ans = 0;\n\tpublic static boolean get_ans = false;\n\t\n\tpublic static int move(int depth, final int n, int from, int use, int to, int[][] states, int[] sizes, int[][] p_states, int[] p_sizes){\n\t\tint walk = 0;\n\t\t\n\t\tif(depth < n){\n\t\t\twalk += move(depth + 1, n, from, use, to, states, sizes, p_states, p_sizes);\n\t\t}\n\t\t\n\t\t//move\n\t\t//System.out.println(depth + \"  : \" + from + \" => \" + use);\n\t\t/*\n\t\tif(is_same(states, sizes, p_states, p_sizes)){\n\t\t\tans = walk;\n\t\t}\n\t\t*/\n\t\t\n\t\tif(!get_ans && is_same(states, sizes, p_states, p_sizes)){\n\t\t\tget_ans = true;\n\t\t}\n\t\t\n\t\ttranslate(from, use, states, sizes);\n\t\twalk++;\n\t\t\n\t\tif(!get_ans){\n\t\t\tans++;\n\t\t}\n\t\t\n\t\t/*\n\t\tif(is_same(states, sizes, p_states, p_sizes)){\n\t\t\tans = walk;\n\t\t}\n\t\t*/\n\t\t\n\t\tif(depth < n){\n\t\t\twalk += move(depth + 1, n, to, use, from, states, sizes, p_states, p_sizes);\n\t\t}\n\t\t\n\t\t\n\t\t//move\n\t\t//System.out.println(depth + \"  : \" + use + \" => \" + to);\n\t\t/*\n\t\tif(is_same(states, sizes, p_states, p_sizes)){\n\t\t\tans = walk;\n\t\t}\n\t\t*/\n\t\t\n\t\tif(!get_ans && is_same(states, sizes, p_states, p_sizes)){\n\t\t\tget_ans = true;\n\t\t}\n\t\t\n\t\ttranslate(use, to, states, sizes);\n\t\twalk++;\n\t\t\n\t\tif(!get_ans){\n\t\t\tans++;\n\t\t}\n\t\t\n\t\t/*\n\t\tif(is_same(states, sizes, p_states, p_sizes)){\n\t\t\tans = walk;\n\t\t}\n\t\t*/\n\t\t\n\t\tif(depth < n){\n\t\t\twalk += move(depth + 1, n, from, use, to, states, sizes, p_states, p_sizes);\n\t\t}\n\t\t\n\t\t/*\n\t\tif(is_same(states, sizes, p_states, p_sizes)){\n\t\t\tans = walk;\n\t\t}\n\t\t*/\n\t\t\n\t\treturn walk;\n\t}\n\t\n\tpublic static final int MAX = 16;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[][] init_states = new int[3][MAX];\n\t\tint[]   init_sizes  = new int[3];\n\t\tint[][] p_states = new int[3][MAX];\n\t\tint[]   p_sizes  = new int[3];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tp_sizes[i] = sc.nextInt();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < p_sizes[i]; j++){\n\t\t\t\t\tp_states[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans = 0;\n\t\t\tget_ans = false;\n\t\t\tinit_sizes[0] = n; init_sizes[1] = 0; init_sizes[2] = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tinit_states[0][i] = i + 1;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int max = move(1, n, 0, 1, 2, init_states, init_sizes, p_states, p_sizes);\n\t\t\t\n\t\t\tint answer = Math.min(ans, max - ans);\n\t\t\t\n\t\t\tSystem.out.println(answer <= m ? answer : -1);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.math.BigInteger;\n      \npublic class Main{\n  \nstatic final InputStream in=System.in;\nstatic final PrintWriter out=new PrintWriter(System.out);\nstatic final int INF=Integer.MAX_VALUE/2;\nstatic final long LINF=Long.MAX_VALUE/2;\nstatic int n,m,a,b,c;\nstatic Deque<Integer> queA,queB,queC;\n  \npublic static void main(String[] args) throws IOException{\nInputReader ir=new InputReader(in);\nwhile(true){\nn=ir.nextInt();\nm=ir.nextInt();\nif(n==0&&m==0) break;\nqueA=new ArrayDeque<Integer>();\nqueB=new ArrayDeque<Integer>();\nqueC=new ArrayDeque<Integer>();\na=ir.nextInt();\nfor(int i=0;i<a;i++) queA.offerFirst(ir.nextInt());\nb=ir.nextInt();\nfor(int i=0;i<b;i++) queB.offerFirst(ir.nextInt());\nc=ir.nextInt();\nfor(int i=0;i<c;i++) queC.offerFirst(ir.nextInt());\nint ans=dfs(0,0);\nout.println(ans>m?-1:ans);\n}\nout.flush();\n}\n\npublic static int dfs(int depth,int prev){\nif(depth>m) return depth;\nif(queA.size()==n||queC.size()==n) return depth;\nint s,t,u,v;\ns=t=u=v=m+1;\nif(prev!=3&&!queA.isEmpty()&&(queB.isEmpty()||queA.peekFirst()>queB.peekFirst())){\nint temp=queA.pollFirst();\nqueB.offerFirst(temp);\ns=dfs(depth+1,1);\nqueB.pollFirst();\nqueA.offerFirst(temp);\n}\nif(prev!=4&&!queC.isEmpty()&&(queB.isEmpty()||queC.peekFirst()>queB.peekFirst())){\nint temp=queC.pollFirst();\nqueB.offerFirst(temp);\nt=dfs(depth+1,2);\nqueB.pollFirst();\nqueC.offerFirst(temp);\n}\nif(prev!=1&&!queB.isEmpty()&&(queA.isEmpty()||queB.peekFirst()>queA.peekFirst())){\nint temp=queB.pollFirst();\nqueA.offerFirst(temp);\nu=dfs(depth+1,3);\nqueA.pollFirst();\nqueB.offerFirst(temp);\n}\nif(prev!=2&&!queB.isEmpty()&&(queC.isEmpty()||queB.peekFirst()>queC.peekFirst())){\nint temp=queB.pollFirst();\nqueC.offerFirst(temp);\nv=dfs(depth+1,4);\nqueC.pollFirst();\nqueB.offerFirst(temp);\n}\nreturn Math.min(Math.min(s,t),Math.min(u,v));\n}\n\nstatic class InputReader {\nprivate InputStream in;\nprivate byte[] buffer=new byte[1024];\nprivate int curbuf;\nprivate int lenbuf;\n  \npublic InputReader(InputStream in) {this.in=in;}\n    \npublic int readByte() {\nif(lenbuf==-1) throw new InputMismatchException();\nif(curbuf>=lenbuf){\ncurbuf= 0;\ntry{\nlenbuf=in.read(buffer);\n}\ncatch (IOException e) {\nthrow new InputMismatchException();\n}\nif(lenbuf<=0)\nreturn -1;\n}\nreturn buffer[curbuf++];\n}\n  \npublic boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \nprivate int skip() {int b; while((b = readByte())!=-1&&isSpaceChar(b)); return b;}\n  \npublic String next() {\nint b=skip();\nStringBuilder sb=new StringBuilder();\nwhile(!isSpaceChar(b)){\nsb.appendCodePoint(b);\nb=readByte();\n}\nreturn sb.toString();\n}\n   \npublic int nextInt() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nint res=0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic long nextLong() {\nint c=readByte();\nwhile (isSpaceChar(c)) c=readByte();\nboolean minus=false;\nif (c=='-') {\nminus=true;\nc=readByte();\n}\nlong res = 0;\ndo{\nif(c<'0'||c>'9') throw new InputMismatchException();\nres=res*10+c-'0';\nc=readByte();\n}while(!isSpaceChar(c));\nreturn (minus)?-res:res;\n}\n  \npublic int[] toIntArray(int n){\nint[] a=new int[n];\nfor(int i=0;i<n;i++) a[i]=nextInt();\nreturn a;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Stack;\n\n//Cup\npublic class Main{\n\n\tpublic static int n;\n\tpublic static Stack<Integer>[] cup;\n\tpublic static int ans;\n\n\t//ope\n\t//1: A->B\n\t//2: C->B\n\t//-1:B->A\n\t//-2:B->C\n\tpublic static void dfs(int pre, int k){\n\t\tif(ans <= k)return;\n\t\tif(cup[0].size()==n || cup[2].size()==n){\n\t\t\tans = Math.min(ans, k);\n\t\t\treturn;\n\t\t}\n\t\tif(pre!=1){\n\t\t\tif(!cup[1].empty()){\n\t\t\t\tif(cup[0].empty() || cup[0].peek() < cup[1].peek()){\n\t\t\t\t\tcup[0].push(cup[1].pop());\n\t\t\t\t\tdfs(-1, k+1);\n\t\t\t\t\tcup[1].push(cup[0].pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pre!=-1){\n\t\t\tif(!cup[0].empty()){\n\t\t\t\tif(cup[1].empty() || cup[1].peek() < cup[0].peek()){\n\t\t\t\t\tcup[1].push(cup[0].pop());\n\t\t\t\t\tdfs(1, k+1);\n\t\t\t\t\tcup[0].push(cup[1].pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pre!=2){\n\t\t\tif(!cup[1].empty()){\n\t\t\t\tif(cup[2].empty() || cup[2].peek() < cup[1].peek()){\n\t\t\t\t\tcup[2].push(cup[1].pop());\n\t\t\t\t\tdfs(-2, k+1);\n\t\t\t\t\tcup[1].push(cup[2].pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pre!=-2){\n\t\t\tif(!cup[2].empty()){\n\t\t\t\tif(cup[1].empty() || cup[1].peek() < cup[2].peek()){\n\t\t\t\t\tcup[1].push(cup[2].pop());\n\t\t\t\t\tdfs(2, k+1);\n\t\t\t\t\tcup[2].push(cup[1].pop());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n==0&&m==0)break;\n\t\t\tans = m+1;\n\t\t\tcup = new Stack[3];\n\t\t\tfor(int i=0;i<3;i++)cup[i] = new Stack<Integer>();\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\twhile(k--!=0)cup[i].push(sc.nextInt());\n\t\t\t}\n\t\t\tdfs(0, 0);\n\t\t\tSystem.out.println(ans==m+1?-1:ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int MAX = 15;\n\t\n\tpublic static int[][] lists = new int[3][MAX];\n\tpublic static int[]   sizes = new int[3];\n\t\n\tpublic static int[][] prevs = new int[3][MAX];\n\tpublic static int[] p_sizes = new int[3];\n\t\n\tpublic static void lists_clear(){\n\t\tsizes[0] = sizes[1] = sizes[2] = 0;\n\t}\n\t\n\tpublic static void prevs_clear(){\n\t\tp_sizes[0] = p_sizes[1] = p_sizes[2] = 0;\n\t}\n\t\n\tpublic static void all_clear(){\n\t\tlists_clear();\n\t\tprevs_clear();\n\t}\n\t\n\tpublic static void print_list(int l){\n\t\tSystem.out.print(l + \"  :\");\n\t\tfor(int i = 0; i < sizes[l]; i++){\n\t\t\tSystem.out.print(\" \" + lists[l][i]);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void print_prev_list(int l){\n\t\tSystem.out.print(l + \" p:\");\n\t\tfor(int i = 0; i < p_sizes[l]; i++){\n\t\t\tSystem.out.print(\" \" + prevs[l][i]);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static boolean range_check(int i){\n\t\treturn 0 <= i && i < 3;\n\t}\n\t\n\tpublic static boolean is_goal(int n){\n\t\treturn sizes[0] == n && sizes[1] == 0 && sizes[2] == 0 || sizes[0] == 0 && sizes[1] == 0 && sizes[2] == n;\n\t}\n\t\n\tpublic static int get_list_top(int i){\n\t\tif(!range_check(i)){\n\t\t\treturn 0;\n\t\t}else if(sizes[i] == 0){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn lists[i][sizes[i] - 1];\n\t\t}\n\t}\n\t\n\tpublic static void save_to_prev(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tp_sizes[i] = sizes[i];\n\t\t\t\n\t\t\tfor(int j = 0; j < sizes[i]; j++){\n\t\t\t\tprevs[i][j] = lists[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean is_same(){\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tif(sizes[i] != p_sizes[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < sizes[i]; j++){\n\t\t\t\tif(lists[i][j] != prevs[i][j]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static void add_top(int l, int t){\n\t\tlists[l][sizes[l]] = t;\n\t\tsizes[l]++;\n\t}\n\t\n\tpublic static int remove_top(int l){\n\t\tint tmp = get_list_top(l);\n\t\tsizes[l]--;\n\t\t\n\t\treturn tmp;\n\t}\n\t\n\tpublic static int move(int cur, boolean left, boolean do_it){\n\t\tif(!range_check(cur)){\n\t\t\treturn 0;\n\t\t}else if(sizes[cur] == 0){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfinal int pur = cur + (left ? -1 : 1);\n\t\tif(!range_check(pur)){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfinal int cur_top = get_list_top(cur);\n\t\tfinal int pur_top = get_list_top(pur);\n\t\t\n\t\tif(cur_top <= pur_top){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tboolean same = false;\n\t\tif(do_it){\n\t\t\tsave_to_prev();\n\t\t}\n\t\tadd_top(pur, remove_top(cur));\n\t\t\n\t\tif(do_it){\n\t\t\treturn Integer.MAX_VALUE;\n\t\t}\n\t\t\n\t\tif(is_same()){\n\t\t\tsame = true;\n\t\t}\n\t\t\n\t\tadd_top(cur, remove_top(pur));\n\t\t\n\t\tif(same){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn cur_top;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tall_clear();\n\t\t\t\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tsizes[i] = sc.nextInt();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < sizes[i]; j++){\n\t\t\t\t\tlists[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean clear = false;\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tfor(count = 0; count <= m; count++){\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(count + \" : --------------------\");\n\t\t\t\tprint_list(0);\n\t\t\t\tprint_prev_list(0);\n\t\t\t\tprint_list(1);\n\t\t\t\tprint_prev_list(1);\n\t\t\t\tprint_list(2);\n\t\t\t\tprint_prev_list(2);\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\tif(is_goal(n)){\n\t\t\t\t\tclear = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean min_left = false;\n\t\t\t\tint min_cur = 0;\n\t\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\t\n\t\t\t\tfor(int left = 0; left < 2; left++){\n\t\t\t\t\tfor(int cur = 0; cur < 3; cur++){\n\t\t\t\t\t\tint ret = move(cur, left == 0, false);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(ret != 0 && ret < min){\n\t\t\t\t\t\t\tmin = ret;\n\t\t\t\t\t\t\tmin_cur = cur;\n\t\t\t\t\t\t\tmin_left = left == 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(min != Integer.MAX_VALUE){\n\t\t\t\t\tmove(min_cur, min_left, true);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"ERROR\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(clear ? count + \"\" : \"-1\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tlong[][][][] memo = new long[3][16][16][16];\n\tint[] cups;\n\tint n;\n\t\n\tlong calcA(int a, int b,int c) {\n\t\tif (memo[0][a][b][c] == 0) {\n\t\t\tif (c == 0 && b == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (b == 0 && a == 0) {\n\t\t\t\treturn memo[0][a][b][c] = (long)(Math.pow(3, c)-1);\n\t\t\t}\n\t\t\tint mp = cups[n-a-b-c];\n\t\t\tif (mp == 2) {\n\t\t\t\tmemo[0][a][b][c] = calcA(a, b, c-1) + calcC(a+b+c-1, 0, 0) + calcA(0, 0, a+b+c-1) + 2;\n\t\t\t} else if (mp == 1) {\n\t\t\t\tmemo[0][a][b][c] = calcC(a, b-1, c) + calcA(0, 0, a+b+c-1) + 1;\n\t\t\t} else {\n\t\t\t\tmemo[0][a][b][c] = calcA(a-1, b, c);\n\t\t\t}\n\t\t}\n\t\treturn memo[0][a][b][c];\n\t}\n\t\n\tlong calcB(int a, int b,int c) {\n\t\tif (memo[1][a][b][c] == 0) {\n\t\t\tif (a == 0 && c == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((a == 0 && b == 0) || (b == 0 && c == 0)) {\n\t\t\t\treturn memo[1][a][b][c] = (long)(Math.pow(3, a+c)-3)/2 + 1;\n\t\t\t}\n\t\t\tint mp = cups[n-a-b-c];\n\t\t\tif (mp == 0) {\n\t\t\t\tmemo[1][a][b][c] = calcC(a-1, b, c) + calcB(0, 0, a+b+c-1) + 1;\n\t\t\t} else if (mp == 1) {\n\t\t\t\tmemo[1][a][b][c] = calcB(a, b-1, c);\n\t\t\t} else {\n\t\t\t\tmemo[1][a][b][c] = calcA(a, b, c-1) + calcB(a+b+c-1, 0, 0) + 1;\n\t\t\t}\n\t\t}\n\t\treturn memo[1][a][b][c];\n\t}\n\t\n\tlong calcC(int a, int b, int c) {\n\t\tif (memo[2][a][b][c] == 0) {\n\t\t\tif (a == 0 && b == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (b == 0 && c == 0) {\n\t\t\t\treturn memo[2][a][b][c] = (long)(Math.pow(3, a)-1);\n\t\t\t}\n\t\t\tint mp = cups[n-a-b-c];\n\t\t\tif (mp == 0) {\n\t\t\t\tmemo[2][a][b][c] = calcC(a-1, b, c) + calcA(0, 0, a+b+c-1) + calcC(a+b+c-1, 0, 0) + 2;\n\t\t\t} else if (mp == 1) {\n\t\t\t\tmemo[2][a][b][c] = calcA(a, b-1, c) + calcC(a+b+c-1, 0, 0) + 1;\n\t\t\t} else {\n\t\t\t\tmemo[2][a][b][c] = calcC(a, b, c-1);\n\t\t\t}\n\t\t}\n\t\treturn memo[2][a][b][c];\n\t}\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif (n == 0 && m == 0) break;\n\t\t\t\n\t\t\tcups = new int[n];\n\t\t\tint a = 0, b = 0, c = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tint num = sc.nextInt();\n\t\t\t\tif (i == 0) a = num;\n\t\t\t\telse if (i == 1) b = num;\n\t\t\t\telse c = num;\n\t\t\t\tfor (int j = 0; j < num; j++) {\n\t\t\t\t\tcups[sc.nextInt()-1] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong res = Math.min(calcA(a, b, c), calcC(a, b, c));\n\t\t\tif (res <= m)\n\t\t\t\tout.println(res);\n\t\t\telse\n\t\t\t\tout.println(-1);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N, M;\n\tstatic int[] p = new int[15];\n\tstatic int[] move = new int[15];\n\n\tstatic int solve() {\n\t\tint[][] dp = new int[N + 1][3];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tArrays.fill(dp[i + 1], Integer.MAX_VALUE);\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\tdp[i + 1][p[i]] = Math.min(dp[i + 1][p[i]], dp[i][j] + move[i] * Math.abs(j - p[i]));\n\t\t\t}\n\t\t\tif (p[i] == 1) {\n\t\t\t\tdp[i + 1][0] = Math.min(dp[i + 1][0], dp[i][0] + move[i] * 4 + 1);\n\t\t\t\tdp[i + 1][0] = Math.min(dp[i + 1][0], dp[i][1] + move[i] * 3 + 1);\n\t\t\t\tdp[i + 1][0] = Math.min(dp[i + 1][0], dp[i][2] + move[i] * 2 + 1);\n\t\t\t\tdp[i + 1][2] = Math.min(dp[i + 1][2], dp[i][2] + move[i] * 4 + 1);\n\t\t\t\tdp[i + 1][2] = Math.min(dp[i + 1][2], dp[i][1] + move[i] * 3 + 1);\n\t\t\t\tdp[i + 1][2] = Math.min(dp[i + 1][2], dp[i][0] + move[i] * 2 + 1);\n\t\t\t} else {\n\t\t\t\tdp[i + 1][1] = Math.min(dp[i + 1][1], dp[i][p[i]] + move[i] * 3 + 1);\n\t\t\t\tdp[i + 1][1] = Math.min(dp[i + 1][1], dp[i][1] + move[i] * 2 + 1);\n\t\t\t\tdp[i + 1][1] = Math.min(dp[i + 1][1], dp[i][2 - p[i]] + move[i] * 1 + 1);\n\t\t\t\tdp[i + 1][2 - p[i]] = Math.min(dp[i + 1][2 - p[i]], dp[i][p[i]] + move[i] * 6 + 2);\n\t\t\t\tdp[i + 1][2 - p[i]] = Math.min(dp[i + 1][2 - p[i]], dp[i][1] + move[i] * 5 + 2);\n\t\t\t\tdp[i + 1][2 - p[i]] = Math.min(dp[i + 1][2 - p[i]], dp[i][2 - p[i]] + move[i] * 4 + 2);\n\t\t\t}\n\t\t}\n\t\tint m = Math.min(dp[N][0], dp[N][2]);\n\t\treturn m <= M ? m : -1;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tfor (int i = 1; i < move.length; ++i) {\n\t\t\tmove[i] = move[i - 1] * 3 + 1;\n\t\t}\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tM = sc.nextInt();\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\t\tp[N - sc.nextInt()] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n==0 && m==0) break;\n\t\t\t\n\t\t\tint[] a = new int[n+1];\n\t\t\tint[] b = new int[n+1];\n\t\t\tint[] c = new int[n+1];\n\t\t\tint an = 0, bn = 0, cn = 0;\n\t\t\t\n\t\t\tan = sc.nextInt();\n\t\t\tfor(int i=1;i<=an;i++) a[i] = sc.nextInt();\n\t\t\tbn = sc.nextInt();\n\t\t\tfor(int i=1;i<=bn;i++) b[i] = sc.nextInt();\n\t\t\tcn = sc.nextInt();\n\t\t\tfor(int i=1;i<=cn;i++) c[i] = sc.nextInt();\n\t\t\t\n\t\t\tboolean flag = false;\n\t\t\tint com = 1;\n\t\t\t\n\t\t\tfor(int i=0;i<=m;i++){\n\t\t\t\tif(bn==0 && (an==0 || cn==0)){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(com==0){\n\t\t\t\t\tbn++;\n\t\t\t\t\tb[bn] = a[an];\n\t\t\t\t\tan--;\n\t\t\t\t\tif(b[bn]>c[cn]) com = 2;\n\t\t\t\t\telse com = 3;\n\t\t\t\t}else if(com==1){\n\t\t\t\t\tan++;\n\t\t\t\t\ta[an] = b[bn];\n\t\t\t\t\tbn--;\n\t\t\t\t\tif(b[bn]>c[cn]) com = 2;\n\t\t\t\t\telse com = 3;\n\t\t\t\t}else if(com==2){\n\t\t\t\t\tcn++;\n\t\t\t\t\tc[cn] = b[bn];\n\t\t\t\t\tbn--;\n\t\t\t\t\tif(a[an]>b[bn]) com = 0;\n\t\t\t\t\telse com = 1;\n\t\t\t\t}else if(com==3){\n\t\t\t\t\tbn++;\n\t\t\t\t\tb[bn] = c[cn];\n\t\t\t\t\tcn--;\n\t\t\t\t\tif(a[an]>b[bn]) com = 0;\n\t\t\t\t\telse com = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==false) System.out.println(-1);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Tray implements Comparable<Tray>{\n\tpublic int[] a;\n\tpublic Tray(){\n\t\ta=new int[3];\n\t}\n\tpublic int compareTo(Tray t){\n\t\treturn a[0]!=t.a[0]?a[0]-t.a[0]:a[1]!=t.a[1]?a[1]-t.a[1]:a[2]-t.a[2];\n\t}\n}\n\nclass State{\n\tpublic Tray tray;\n\tpublic int cost;\n\tpublic State(Tray t,int c){\n\t\ttray=t;\n\t\tcost=c;\n\t}\n}\n\t\nclass Main{\n\tpublic static String toBin(int n){\n\t\tString res=\"\";\n\t\tfor(int i=15;i-->0;)\n\t\t\tres+=(char)('0'+(n>>i&1));\n\t\treturn res;\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n=sc.nextInt(),m=sc.nextInt();\n\t\t\tif(n==0 && m==0) break;\n\t\t\t\n\t\t\tTray init=new Tray();\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tint j=sc.nextInt();\n\t\t\t\twhile(j-->0){\n\t\t\t\t\tint x=sc.nextInt();\n\t\t\t\t\tinit.a[i]|=1<<n-x;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(\"a:\");\n\t\t\t//for(int i=0;i<3;i++)\n\t\t\t//\tSystem.out.println(toBin(init.a[i]));\n\t\t\t\n\t\t\tQueue<State> q=new ArrayDeque<State>();\n\t\t\tq.add(new State(init,0));\n\t\t\tSet<Tray> vis=new TreeSet<Tray>();\n\t\t\twhile(q.size()>0){\n\t\t\t\tTray ct=q.element().tray;\n\t\t\t\tint cc=q.element().cost;\n\t\t\t\tq.remove();\n\t\t\t\t\n\t\t\t\tif(vis.contains(ct))\n\t\t\t\t\tcontinue;\n\t\t\t\tvis.add(ct);\n\t\t\t\t\n\t\t\t\tif((ct.a[0]==(1<<n)-1) || (ct.a[2]==(1<<n)-1)){\n\t\t\t\t\tSystem.out.println(cc<=m?cc:-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i=0,j=1;i<2;i++,j++){\n\t\t\t\t\tint bit=-1;\n\t\t\t\t\tif(ct.a[i]==0 || ct.a[j]==0)\n\t\t\t\t\t\tbit=Math.max(ct.a[i]&-ct.a[i],ct.a[j]&-ct.a[j]);\n\t\t\t\t\telse\n\t\t\t\t\t\tbit=Math.min(ct.a[i]&-ct.a[i],ct.a[j]&-ct.a[j]);\n\t\t\t\t\t\n\t\t\t\t\tTray nt=new Tray();\n\t\t\t\t\tSystem.arraycopy(ct.a,0,nt.a,0,3);\n\t\t\t\t\tnt.a[i]^=bit; nt.a[j]^=bit;\n\t\t\t\t\tq.add(new State(nt,cc+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2556344#3\n\npublic class CupState\n{\n\t\n\tpublic byte[] A;\n\tpublic byte[] B;\n\tpublic byte[] C;\n\tpublic List<byte> Method;\n\tpublic byte LastM;\n}\n\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int m = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[] a = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] b = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] c = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,m,a,b,c));\n\t\t\n\t\t\n\t\t}\n\n\t}\n\n  public static int calc(int n,int m,int[] a,int[] b,int[] c) {\n\t  Stack<byte> aa = new Stack<byte>();\n\t  for(int i=1;i<a.Length;i++) aa.Push((byte)a[i]);\n\t  Stack<byte> bb = new Stack<byte>();\n\t  for(int i=1;i<b.Length;i++) bb.Push((byte)b[i]);\n\t  Stack<byte> cc = new Stack<byte>();\n\t  for(int i=1;i<c.Length;i++) cc.Push((byte)c[i]);\n\t  \n\t  byte[] aaa = new byte[a.Length-1];\n\t  for(int i=1;i<a.Length;i++) aaa[i-1] = (byte)a[i];\n\t  byte[] bbb = new byte[b.Length-1];\n\t  for(int i=1;i<b.Length;i++) bbb[i-1] = (byte)b[i];\n\t  byte[] ccc = new byte[c.Length-1];\n\t  for(int i=1;i<c.Length;i++) ccc[i-1] = (byte)c[i];\n\t  \n\t  //Console.WriteLine(\"A = {0} B = {1} C = {2}\", String.Join(\"\", aa), String.Join(\"\", bb), String.Join(\"\", cc));\n/*\n\t  List<byte[][]> met = new List<byte[][]>();\n\t  met.Add(new byte[][]{aa.ToArray(),bb.ToArray(),cc.ToArray()});\n\t  \n\t  int t = calc_sub_dbg(0, m, aa, bb, cc, met);\n\n\t  foreach(byte[][] d in met) {\n\t    Console.WriteLine(\"==========\");\n\t    foreach(byte[] e in d) Console.WriteLine(String.Join(\" \", e));\n\t  }\n\t  Console.WriteLine(\"==========\");\n*/\n\n\t  int t = calc_sub_2(0, m, aaa, bbb, ccc);\n\n\n\t  return t;\n  }\n  \n  \n  public static int calc_sub_2(int cnt,int max,byte[] a,byte[] b,byte[] c) {\n\t\n\tList<CupState> mcsl = new List<CupState>();\n\tCupState cs = new CupState();\n\tcs.A = a; cs.B = b; cs.C = c; cs.Method = new List<byte>(); cs.LastM = 0;\n\tmcsl.Add(cs);\n\tList<CupState> ccsl = new List<CupState>();\n\n\tint mincnt = max;\n\tfor(int i=0;i<=max;i++){\n\t  if(mcsl.Count == 0) break;\n\t  List<CupState> acsl = new List<CupState>();\n      foreach(CupState ccs in mcsl){\n\t\t//Console.WriteLine(String.Join(\" \", ccs.Method.ToArray()));\n\t\t\n        if ((ccs.B.Length == 0) && ((ccs.A.Length == 0) || (ccs.C.Length == 0))){\n          //if(ccs.Method.Count < mincnt) mincnt = ccs.Method.Count;\n          if(i < mincnt) mincnt = i;\n          ccsl.Add(ccs);\n          continue;\n        }\n        //if (mincnt < ccs.Method.Count){\n        //  continue;\n        //}\n        \n        \n        //int mode = (ccs.Method.Count==0) ? 0 : (int)ccs.Method[ccs.Method.Count-1];\n        int va = (ccs.A.Length==0) ? -1 : (int)ccs.A[ccs.A.Length-1];\n        int vb = (ccs.B.Length==0) ? -1 : (int)ccs.B[ccs.B.Length-1];\n        int vc = (ccs.C.Length==0) ? -1 : (int)ccs.C[ccs.C.Length-1];\n        \n        //a->b\n\t    if((ccs.LastM != 2) && (vb < va)) {\n\t      CupState csa = new CupState();\n          csa.A = new byte[ccs.A.Length-1];\n          Array.Copy(ccs.A,0,csa.A,0,ccs.A.Length-1);\n          csa.B = new byte[ccs.B.Length+1];\n          Array.Copy(ccs.B,0,csa.B,0,ccs.B.Length);\n          csa.B[csa.B.Length-1] = ccs.A[ccs.A.Length-1];\n          csa.C = ccs.C;\n          //csa.Method = new List<byte>(ccs.Method.ToArray());\n          //csa.Method.Add(1);\n          csa.LastM = 1;\n          acsl.Add(csa);\n\t    }\n        //b->a\n\t    if((ccs.LastM != 1) && (va < vb)) {\n\t      CupState csa = new CupState();\n          csa.B = new byte[ccs.B.Length-1];\n          Array.Copy(ccs.B,0,csa.B,0,ccs.B.Length-1);\n          csa.A = new byte[ccs.A.Length+1];\n          Array.Copy(ccs.A,0,csa.A,0,ccs.A.Length);\n          csa.A[csa.A.Length-1] = ccs.B[ccs.B.Length-1];\n          csa.C = ccs.C;\n          //csa.Method = new List<byte>(ccs.Method.ToArray());\n          //csa.Method.Add(2);\n          csa.LastM = 2;\n          acsl.Add(csa);\n\t    }\n        //b->c\n\t    if((ccs.LastM != 4) && (vc < vb)) {\n\t      CupState csa = new CupState();\n          csa.B = new byte[ccs.B.Length-1];\n          Array.Copy(ccs.B,0,csa.B,0,ccs.B.Length-1);\n          csa.C = new byte[ccs.C.Length+1];\n          Array.Copy(ccs.C,0,csa.C,0,ccs.C.Length);\n          csa.C[csa.C.Length-1] = ccs.B[ccs.B.Length-1];\n          csa.A = ccs.A;\n          //csa.Method = new List<byte>(ccs.Method.ToArray());\n          //csa.Method.Add(3);\n          csa.LastM = 3;\n          acsl.Add(csa);\n\t    }\n        //c->b\n\t    if((ccs.LastM != 3) && (vb < vc)) {\n\t      CupState csa = new CupState();\n          csa.C = new byte[ccs.C.Length-1];\n          Array.Copy(ccs.C,0,csa.C,0,ccs.C.Length-1);\n          csa.B = new byte[ccs.B.Length+1];\n          Array.Copy(ccs.B,0,csa.B,0,ccs.B.Length);\n          csa.B[csa.B.Length-1] = ccs.C[ccs.C.Length-1];\n          csa.A = ccs.A;\n          //csa.Method = new List<byte>(ccs.Method.ToArray());\n          //csa.Method.Add(4);\n          csa.LastM = 4;\n          acsl.Add(csa);\n\t    }\n\t  }\n      mcsl = acsl;\n      \n\t}\n\t\n\treturn (ccsl.Count == 0) ? -1 : mincnt;\n  }\n  \n  \n  public static int calc_sub_1(int cnt,int max,Stack<byte>a,Stack<byte> b,Stack<byte> c, byte mode) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return -1;\n\t  \n\t  int mincnt = max;\n\t  bool suc = false;\n\t  \n\t  //a->b\n\t  if((mode != 2) && (0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    b.Push(a.Pop());\n\t\tint t = calc_sub_1(cnt+1, mincnt, a, b, c, 1);\n\t\ta.Push(b.Pop());\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //b->a\n\t  if((mode != 1) && (0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    a.Push(b.Pop());\n\t\tint t = calc_sub_1(cnt+1, mincnt, a, b, c, 2);\n\t\tb.Push(a.Pop());\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //b->c\n\t  if((mode != 4) && (0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    c.Push(b.Pop());\n\t\tint t = calc_sub_1(cnt+1, mincnt, a, b, c, 3);\n\t\tb.Push(c.Pop());\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //c->b\n\t  if((mode != 3) && (0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    b.Push(c.Pop());\n\t\tint t = calc_sub_1(cnt+1, mincnt, a, b, c, 4);\n\t\tc.Push(b.Pop());\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  if(suc) {\n\t    return mincnt;\n\t  } else {\n\t\treturn -1;\n\t  }\n\n  }\n  \n  public static int calc_sub_dbg(int cnt,int max,Stack<byte>a,Stack<byte> b,Stack<byte> c, List<byte[][]> met) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return max+10;\n\t  \n\t  int mincnt = max+10;\n\t  List<byte[][]> m1 = new List<byte[][]>();\n\t  List<byte[][]> m2 = new List<byte[][]>();\n\t  List<byte[][]> m3 = new List<byte[][]>();\n\t  List<byte[][]> m4 = new List<byte[][]>();\n\t  int t1 = mincnt;\n\t  int t2 = mincnt;\n\t  int t3 = mincnt;\n\t  int t4 = mincnt;\n\t  \n\t  //a->b\n\t  if((0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    Stack<byte> aa = CloneStack<byte>(a);\n\t    Stack<byte> bb = CloneStack<byte>(b);\n\t    bb.Push(aa.Pop());\n\n\t\t//m1.Add(new byte[][]{aa.ToArray(),bb.ToArray(),c.ToArray()});\n\t\tt1 = calc_sub_dbg(cnt+1, max, aa, bb, c, m1);\n\t  }\n\t  \n\t  //b->a\n\t  if((0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    Stack<byte> aa = CloneStack<byte>(a);\n\t    Stack<byte> bb = CloneStack<byte>(b);\n\t    aa.Push(bb.Pop());\n\n\t\t//m2.Add(new byte[][]{aa.ToArray(),bb.ToArray(),c.ToArray()});\n\t\tt2 = calc_sub_dbg(cnt+1, max, aa, bb, c, m2);\n\t  }\n\t  \n\t  //b->c\n\t  if((0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    Stack<byte> bb = CloneStack<byte>(b);\n\t    Stack<byte> cc = CloneStack<byte>(c);\n\t    cc.Push(bb.Pop());\n\n\t\t//m3.Add(new byte[][]{a.ToArray(),bb.ToArray(),cc.ToArray()});\n\t\tt3 = calc_sub_dbg(cnt+1, max, a, bb, cc, m3);\n\t  }\n\t  \n\t  //c->b\n\t  if((0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    Stack<byte> bb = CloneStack<byte>(b);\n\t    Stack<byte> cc = CloneStack<byte>(c);\n\t    bb.Push(cc.Pop());\n\n\t\t//m4.Add(new byte[][]{a.ToArray(),bb.ToArray(),cc.ToArray()});\n\t\tt4 = calc_sub_dbg(cnt+1, max, a, bb, cc, m4);\n\t  }\n\t  \n\t  mincnt = Math.Min(Math.Min(t1,t2),Math.Min(t3,t4));\n\t  if(t1==mincnt) { met.AddRange(m1); return mincnt; }\n\t  if(t2==mincnt) { met.AddRange(m2); return mincnt; }\n\t  if(t3==mincnt) { met.AddRange(m3); return mincnt; }\n\t  if(t4==mincnt) { met.AddRange(m4); return mincnt; }\n\t  \n\t  return mincnt;\n  }\n  \n    public static Stack<T> CloneStack<T>(Stack<T> original)\n    {\n        var arr = new T[original.Count];\n        original.CopyTo(arr, 0);\n        Array.Reverse(arr);\n        return new Stack<T>(arr);\n    }\n  \n  \n  \n  \n  \n  \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int m = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[] a = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] b = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] c = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,m,a,b,c));\n\t\t\n\t\t\n\t\t}\n\n\t}\n\n  public static int calc(int n,int m,int[] a,int[] b,int[] c) {\n\t  Stack<int> aa = new Stack<int>();\n\t  for(int i=1;i<a.Length;i++) aa.Push(a[i]);\n\t  Stack<int> bb = new Stack<int>();\n\t  for(int i=1;i<b.Length;i++) bb.Push(b[i]);\n\t  Stack<int> cc = new Stack<int>();\n\t  for(int i=1;i<c.Length;i++) cc.Push(c[i]);\n\t  \n\t  //Console.WriteLine(\"A = {0} B = {1} C = {2}\", String.Join(\"\", aa), String.Join(\"\", bb), String.Join(\"\", cc));\n/*\n\t  List<int[][]> met = new List<int[][]>();\n\t  met.Add(new int[][]{aa.ToArray(),bb.ToArray(),cc.ToArray()});\n\t  \n\t  int t = calc_sub_dbg(0, m, aa, bb, cc, met);\n\n\t  foreach(int[][] d in met) {\n\t    Console.WriteLine(\"==========\");\n\t    foreach(int[] e in d) Console.WriteLine(String.Join(\" \", e));\n\t  }\n\t  Console.WriteLine(\"==========\");\n*/\n\n\t  int t = calc_sub(0, m, aa, bb, cc);\n\n\n\t  return t;\n  }\n  \n  public static int calc_sub(int cnt,int max,Stack<int>a,Stack<int> b,Stack<int> c) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return -1;\n\t  \n\t  int mincnt = max;\n\t  bool suc = false;\n\t  \n\t  //a->b\n\t  if((0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    Stack<int> aa = CloneStack<int>(a);\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    bb.Push(aa.Pop());\n\n\t\tint t = calc_sub(cnt+1, mincnt, aa, bb, c);\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //b->a\n\t  if((0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    Stack<int> aa = CloneStack<int>(a);\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    aa.Push(bb.Pop());\n\n\t\tint t = calc_sub(cnt+1, mincnt, aa, bb, c);\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //b->c\n\t  if((0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    Stack<int> cc = CloneStack<int>(c);\n\t    cc.Push(bb.Pop());\n\n\t\tint t = calc_sub(cnt+1, mincnt, a, bb, cc);\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //c->b\n\t  if((0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    Stack<int> cc = CloneStack<int>(c);\n\t    bb.Push(cc.Pop());\n\n\t\tint t = calc_sub(cnt+1, mincnt, a, bb, cc);\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  if(suc) {\n\t    return mincnt;\n\t  } else {\n\t\treturn -1;\n\t  }\n\n  }\n  \n  public static int calc_sub_dbg(int cnt,int max,Stack<int>a,Stack<int> b,Stack<int> c, List<int[][]> met) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return max+10;\n\t  \n\t  int mincnt = max+10;\n\t  List<int[][]> m1 = new List<int[][]>();\n\t  List<int[][]> m2 = new List<int[][]>();\n\t  List<int[][]> m3 = new List<int[][]>();\n\t  List<int[][]> m4 = new List<int[][]>();\n\t  int t1 = mincnt;\n\t  int t2 = mincnt;\n\t  int t3 = mincnt;\n\t  int t4 = mincnt;\n\t  \n\t  //a->b\n\t  if((0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    Stack<int> aa = CloneStack<int>(a);\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    bb.Push(aa.Pop());\n\n\t\t//m1.Add(new int[][]{aa.ToArray(),bb.ToArray(),c.ToArray()});\n\t\tt1 = calc_sub_dbg(cnt+1, max, aa, bb, c, m1);\n\t  }\n\t  \n\t  //b->a\n\t  if((0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    Stack<int> aa = CloneStack<int>(a);\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    aa.Push(bb.Pop());\n\n\t\t//m2.Add(new int[][]{aa.ToArray(),bb.ToArray(),c.ToArray()});\n\t\tt2 = calc_sub_dbg(cnt+1, max, aa, bb, c, m2);\n\t  }\n\t  \n\t  //b->c\n\t  if((0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    Stack<int> cc = CloneStack<int>(c);\n\t    cc.Push(bb.Pop());\n\n\t\t//m3.Add(new int[][]{a.ToArray(),bb.ToArray(),cc.ToArray()});\n\t\tt3 = calc_sub_dbg(cnt+1, max, a, bb, cc, m3);\n\t  }\n\t  \n\t  //c->b\n\t  if((0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    Stack<int> cc = CloneStack<int>(c);\n\t    bb.Push(cc.Pop());\n\n\t\t//m4.Add(new int[][]{a.ToArray(),bb.ToArray(),cc.ToArray()});\n\t\tt4 = calc_sub_dbg(cnt+1, max, a, bb, cc, m4);\n\t  }\n\t  \n\t  mincnt = Math.Min(Math.Min(t1,t2),Math.Min(t3,t4));\n\t  if(t1==mincnt) { met.AddRange(m1); return mincnt; }\n\t  if(t2==mincnt) { met.AddRange(m2); return mincnt; }\n\t  if(t3==mincnt) { met.AddRange(m3); return mincnt; }\n\t  if(t4==mincnt) { met.AddRange(m4); return mincnt; }\n\t  \n\t  return mincnt;\n  }\n  \n    public static Stack<T> CloneStack<T>(Stack<T> original)\n    {\n        var arr = new T[original.Count];\n        original.CopyTo(arr, 0);\n        Array.Reverse(arr);\n        return new Stack<T>(arr);\n    }\n  \n  \n  \n  \n  \n  \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int m = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[] a = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] b = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] c = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,m,a,b,c));\n\t\t\n\t\t\n\t\t}\n\n\t}\n\n  public static int calc(int n,int m,int[] a,int[] b,int[] c) {\n\t  Stack<int> aa = new Stack<int>();\n\t  for(int i=1;i<a.Length;i++) aa.Push(a[i]);\n\t  Stack<int> bb = new Stack<int>();\n\t  for(int i=1;i<b.Length;i++) bb.Push(b[i]);\n\t  Stack<int> cc = new Stack<int>();\n\t  for(int i=1;i<c.Length;i++) cc.Push(c[i]);\n\t  \n\t  //Console.WriteLine(\"A = {0} B = {1} C = {2}\", String.Join(\"\", aa), String.Join(\"\", bb), String.Join(\"\", cc));\n\t  \n\t  List<int[][]> met = new List<int[][]>();\n\t  //met.Add(new int[][]{aa.ToArray(),bb.ToArray(),cc.ToArray()});\n\t  \n\t  int t = calc_sub(0, m, aa, bb, cc, met);\n/*\n\t  foreach(int[][] d in met) {\n\t    Console.WriteLine(\"==========\");\n\t    foreach(int[] e in d) Console.WriteLine(String.Join(\" \", e));\n\t  }\n\t  Console.WriteLine(\"==========\");\n*/\n\t  return (m<t ? -1 : t);\n  }\n  \n  public static int calc_sub(int cnt,int max,Stack<int>a,Stack<int> b,Stack<int> c, List<int[][]> met) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return max+10;\n\t  \n\t  int mincnt = max+10;\n\t  List<int[][]> m1 = new List<int[][]>();\n\t  List<int[][]> m2 = new List<int[][]>();\n\t  List<int[][]> m3 = new List<int[][]>();\n\t  List<int[][]> m4 = new List<int[][]>();\n\t  int t1 = mincnt;\n\t  int t2 = mincnt;\n\t  int t3 = mincnt;\n\t  int t4 = mincnt;\n\t  \n\t  //a->b\n\t  if((0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    Stack<int> aa = CloneStack<int>(a);\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    bb.Push(aa.Pop());\n\n\t\t//m1.Add(new int[][]{aa.ToArray(),bb.ToArray(),c.ToArray()});\n\t\tt1 = calc_sub(cnt+1, max, aa, bb, c, m1);\n\t  }\n\t  \n\t  //b->a\n\t  if((0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    Stack<int> aa = CloneStack<int>(a);\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    aa.Push(bb.Pop());\n\n\t\t//m2.Add(new int[][]{aa.ToArray(),bb.ToArray(),c.ToArray()});\n\t\tt2 = calc_sub(cnt+1, max, aa, bb, c, m2);\n\t  }\n\t  \n\t  //b->c\n\t  if((0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    Stack<int> cc = CloneStack<int>(c);\n\t    cc.Push(bb.Pop());\n\n\t\t//m3.Add(new int[][]{a.ToArray(),bb.ToArray(),cc.ToArray()});\n\t\tt3 = calc_sub(cnt+1, max, a, bb, cc, m3);\n\t  }\n\t  \n\t  //c->b\n\t  if((0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    Stack<int> cc = CloneStack<int>(c);\n\t    bb.Push(cc.Pop());\n\n\t\t//m4.Add(new int[][]{a.ToArray(),bb.ToArray(),cc.ToArray()});\n\t\tt4 = calc_sub(cnt+1, max, a, bb, cc, m4);\n\t  }\n\t  \n\t  mincnt = Math.Min(Math.Min(t1,t2),Math.Min(t3,t4));\n\t  if(t1==mincnt) { met.AddRange(m1); return mincnt; }\n\t  if(t2==mincnt) { met.AddRange(m2); return mincnt; }\n\t  if(t3==mincnt) { met.AddRange(m3); return mincnt; }\n\t  if(t4==mincnt) { met.AddRange(m4); return mincnt; }\n\t  \n\t  return mincnt;\n  }\n  \n    public static Stack<T> CloneStack<T>(Stack<T> original)\n    {\n        var arr = new T[original.Count];\n        original.CopyTo(arr, 0);\n        Array.Reverse(arr);\n        return new Stack<T>(arr);\n    }\n  \n  \n  \n  \n  \n  \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2556344#3\n\npublic class CupState\n{\n\t\n\tpublic byte[] A;\n\tpublic byte[] B;\n\tpublic byte[] C;\n\tpublic List<byte> Method;\n\tpublic byte LastM;\n}\n\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int m = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[] a = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] b = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] c = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,m,a,b,c));\n\t\t\n\t\t\n\t\t}\n\n\t}\n\n  public static int calc(int n,int m,int[] a,int[] b,int[] c) {\n\t  Stack<byte> aa = new Stack<byte>();\n\t  for(int i=1;i<a.Length;i++) aa.Push((byte)a[i]);\n\t  Stack<byte> bb = new Stack<byte>();\n\t  for(int i=1;i<b.Length;i++) bb.Push((byte)b[i]);\n\t  Stack<byte> cc = new Stack<byte>();\n\t  for(int i=1;i<c.Length;i++) cc.Push((byte)c[i]);\n\t  \n\t  byte[] aaa = new byte[a.Length-1];\n\t  for(int i=1;i<a.Length;i++) aaa[i-1] = (byte)a[i];\n\t  byte[] bbb = new byte[b.Length-1];\n\t  for(int i=1;i<b.Length;i++) bbb[i-1] = (byte)b[i];\n\t  byte[] ccc = new byte[c.Length-1];\n\t  for(int i=1;i<c.Length;i++) ccc[i-1] = (byte)c[i];\n\t  \n\t  //Console.WriteLine(\"A = {0} B = {1} C = {2}\", String.Join(\"\", aa), String.Join(\"\", bb), String.Join(\"\", cc));\n/*\n\t  List<byte[][]> met = new List<byte[][]>();\n\t  met.Add(new byte[][]{aa.ToArray(),bb.ToArray(),cc.ToArray()});\n\t  \n\t  int t = calc_sub_dbg(0, m, aa, bb, cc, met);\n\n\t  foreach(byte[][] d in met) {\n\t    Console.WriteLine(\"==========\");\n\t    foreach(byte[] e in d) Console.WriteLine(String.Join(\" \", e));\n\t  }\n\t  Console.WriteLine(\"==========\");\n*/\n\n\t  int t = calc_sub_2(0, m, aaa, bbb, ccc);\n\n\n\t  return t;\n  }\n  \n  \n  public static int calc_sub_2(int cnt,int max,byte[] a,byte[] b,byte[] c) {\n\t\n\tList<CupState> mcsl = new List<CupState>();\n\tCupState cs = new CupState();\n\tcs.A = a; cs.B = b; cs.C = c; cs.Method = new List<byte>(); cs.LastM = 0;\n\tmcsl.Add(cs);\n\tList<CupState> ccsl = new List<CupState>();\n\tSortedSet<string> slist = new SortedSet<string>();\n\n\tint mincnt = max;\n\tfor(int i=0;i<=max;i++){\n\t  if(mcsl.Count == 0) break;\n\t  List<CupState> acsl = new List<CupState>();\n      foreach(CupState ccs in mcsl){\n\t\t//Console.WriteLine(String.Join(\" \", ccs.Method.ToArray()));\n\t\t\n        if ((ccs.B.Length == 0) && ((ccs.A.Length == 0) || (ccs.C.Length == 0))){\n          //if(ccs.Method.Count < mincnt) mincnt = ccs.Method.Count;\n          if(i < mincnt) mincnt = i;\n          ccsl.Add(ccs);\n          continue;\n        }\n        //if (mincnt < ccs.Method.Count){\n        //  continue;\n        //}\n        \n        /*\n\t\tstring s = (\"-\"+BitConverter.ToString(ccs.A)+\"0-\"+BitConverter.ToString(ccs.B)+\"0-\"+BitConverter.ToString(ccs.C)).Replace(\"-0\", \"\");\n\t\tif (slist.Contains(s)){\n          continue;\n        } else {\n\t\t  slist.Add(s);\n\t\t}\n        */\n        \n        //int mode = (ccs.Method.Count==0) ? 0 : (int)ccs.Method[ccs.Method.Count-1];\n        int va = (ccs.A.Length==0) ? -1 : (int)ccs.A[ccs.A.Length-1];\n        int vb = (ccs.B.Length==0) ? -1 : (int)ccs.B[ccs.B.Length-1];\n        int vc = (ccs.C.Length==0) ? -1 : (int)ccs.C[ccs.C.Length-1];\n        \n        //a->b\n\t    if((ccs.LastM != 2) && (vb < va)) {\n\t      CupState csa = new CupState();\n          csa.A = new byte[ccs.A.Length-1];\n          Array.Copy(ccs.A,0,csa.A,0,ccs.A.Length-1);\n          csa.B = new byte[ccs.B.Length+1];\n          Array.Copy(ccs.B,0,csa.B,0,ccs.B.Length);\n          csa.B[csa.B.Length-1] = ccs.A[ccs.A.Length-1];\n          csa.C = ccs.C;\n          //csa.Method = new List<byte>(ccs.Method.ToArray());\n          //csa.Method.Add(1);\n          csa.LastM = 1;\n          acsl.Add(csa);\n\t    }\n        //b->a\n\t    if((ccs.LastM != 1) && (va < vb)) {\n\t      CupState csa = new CupState();\n          csa.B = new byte[ccs.B.Length-1];\n          Array.Copy(ccs.B,0,csa.B,0,ccs.B.Length-1);\n          csa.A = new byte[ccs.A.Length+1];\n          Array.Copy(ccs.A,0,csa.A,0,ccs.A.Length);\n          csa.A[csa.A.Length-1] = ccs.B[ccs.B.Length-1];\n          csa.C = ccs.C;\n          //csa.Method = new List<byte>(ccs.Method.ToArray());\n          //csa.Method.Add(2);\n          csa.LastM = 2;\n          acsl.Add(csa);\n\t    }\n        //b->c\n\t    if((ccs.LastM != 4) && (vc < vb)) {\n\t      CupState csa = new CupState();\n          csa.B = new byte[ccs.B.Length-1];\n          Array.Copy(ccs.B,0,csa.B,0,ccs.B.Length-1);\n          csa.C = new byte[ccs.C.Length+1];\n          Array.Copy(ccs.C,0,csa.C,0,ccs.C.Length);\n          csa.C[csa.C.Length-1] = ccs.B[ccs.B.Length-1];\n          csa.A = ccs.A;\n          //csa.Method = new List<byte>(ccs.Method.ToArray());\n          //csa.Method.Add(3);\n          csa.LastM = 3;\n          acsl.Add(csa);\n\t    }\n        //c->b\n\t    if((ccs.LastM != 3) && (vb < vc)) {\n\t      CupState csa = new CupState();\n          csa.C = new byte[ccs.C.Length-1];\n          Array.Copy(ccs.C,0,csa.C,0,ccs.C.Length-1);\n          csa.B = new byte[ccs.B.Length+1];\n          Array.Copy(ccs.B,0,csa.B,0,ccs.B.Length);\n          csa.B[csa.B.Length-1] = ccs.C[ccs.C.Length-1];\n          csa.A = ccs.A;\n          //csa.Method = new List<byte>(ccs.Method.ToArray());\n          //csa.Method.Add(4);\n          csa.LastM = 4;\n          acsl.Add(csa);\n\t    }\n\t  }\n      mcsl = acsl;\n      \n\t}\n\t\n\treturn (ccsl.Count == 0) ? -1 : mincnt;\n  }\n  \n  \n  public static int calc_sub_1(int cnt,int max,Stack<byte>a,Stack<byte> b,Stack<byte> c, byte mode) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return -1;\n\t  \n\t  int mincnt = max;\n\t  bool suc = false;\n\t  \n\t  //a->b\n\t  if((mode != 2) && (0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    b.Push(a.Pop());\n\t\tint t = calc_sub_1(cnt+1, mincnt, a, b, c, 1);\n\t\ta.Push(b.Pop());\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //b->a\n\t  if((mode != 1) && (0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    a.Push(b.Pop());\n\t\tint t = calc_sub_1(cnt+1, mincnt, a, b, c, 2);\n\t\tb.Push(a.Pop());\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //b->c\n\t  if((mode != 4) && (0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    c.Push(b.Pop());\n\t\tint t = calc_sub_1(cnt+1, mincnt, a, b, c, 3);\n\t\tb.Push(c.Pop());\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //c->b\n\t  if((mode != 3) && (0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    b.Push(c.Pop());\n\t\tint t = calc_sub_1(cnt+1, mincnt, a, b, c, 4);\n\t\tc.Push(b.Pop());\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  if(suc) {\n\t    return mincnt;\n\t  } else {\n\t\treturn -1;\n\t  }\n\n  }\n  \n  public static int calc_sub_dbg(int cnt,int max,Stack<byte>a,Stack<byte> b,Stack<byte> c, List<byte[][]> met) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return max+10;\n\t  \n\t  int mincnt = max+10;\n\t  List<byte[][]> m1 = new List<byte[][]>();\n\t  List<byte[][]> m2 = new List<byte[][]>();\n\t  List<byte[][]> m3 = new List<byte[][]>();\n\t  List<byte[][]> m4 = new List<byte[][]>();\n\t  int t1 = mincnt;\n\t  int t2 = mincnt;\n\t  int t3 = mincnt;\n\t  int t4 = mincnt;\n\t  \n\t  //a->b\n\t  if((0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    Stack<byte> aa = CloneStack<byte>(a);\n\t    Stack<byte> bb = CloneStack<byte>(b);\n\t    bb.Push(aa.Pop());\n\n\t\t//m1.Add(new byte[][]{aa.ToArray(),bb.ToArray(),c.ToArray()});\n\t\tt1 = calc_sub_dbg(cnt+1, max, aa, bb, c, m1);\n\t  }\n\t  \n\t  //b->a\n\t  if((0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    Stack<byte> aa = CloneStack<byte>(a);\n\t    Stack<byte> bb = CloneStack<byte>(b);\n\t    aa.Push(bb.Pop());\n\n\t\t//m2.Add(new byte[][]{aa.ToArray(),bb.ToArray(),c.ToArray()});\n\t\tt2 = calc_sub_dbg(cnt+1, max, aa, bb, c, m2);\n\t  }\n\t  \n\t  //b->c\n\t  if((0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    Stack<byte> bb = CloneStack<byte>(b);\n\t    Stack<byte> cc = CloneStack<byte>(c);\n\t    cc.Push(bb.Pop());\n\n\t\t//m3.Add(new byte[][]{a.ToArray(),bb.ToArray(),cc.ToArray()});\n\t\tt3 = calc_sub_dbg(cnt+1, max, a, bb, cc, m3);\n\t  }\n\t  \n\t  //c->b\n\t  if((0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    Stack<byte> bb = CloneStack<byte>(b);\n\t    Stack<byte> cc = CloneStack<byte>(c);\n\t    bb.Push(cc.Pop());\n\n\t\t//m4.Add(new byte[][]{a.ToArray(),bb.ToArray(),cc.ToArray()});\n\t\tt4 = calc_sub_dbg(cnt+1, max, a, bb, cc, m4);\n\t  }\n\t  \n\t  mincnt = Math.Min(Math.Min(t1,t2),Math.Min(t3,t4));\n\t  if(t1==mincnt) { met.AddRange(m1); return mincnt; }\n\t  if(t2==mincnt) { met.AddRange(m2); return mincnt; }\n\t  if(t3==mincnt) { met.AddRange(m3); return mincnt; }\n\t  if(t4==mincnt) { met.AddRange(m4); return mincnt; }\n\t  \n\t  return mincnt;\n  }\n  \n    public static Stack<T> CloneStack<T>(Stack<T> original)\n    {\n        var arr = new T[original.Count];\n        original.CopyTo(arr, 0);\n        Array.Reverse(arr);\n        return new Stack<T>(arr);\n    }\n  \n  \n  \n  \n  \n  \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Web;\n\nnamespace Competitive\n{\n    internal class Solution\n    {\n        public int N, M;\n        public int[] InitPos, Goal1, Goal2;\n        public long HashGoal1, HashGoal2;\n        public int[] InitMx;\n        public HashSet<long> Used;\n        public int ret;\n        public void Run()\n        {\n            while (true)\n            {\n                {\n                    var line = Input.ReadIntArray();\n                    N = line[0];\n                    M = line[1];\n                }\n\n                if (N == 0 && M == 0) return;\n                InitPos = new int[N];\n\n                for (int i = 0; i < 3; i++)\n                {\n                    var line = Input.ReadIntArray().Skip(1).Select(e => e - 1);\n                    foreach (var e in line)\n                    {\n                        InitPos[e] = i;\n                    }\n                }\n\n                InitMx = MX(InitPos);\n\n                Goal1 = new int[N];\n                Goal2 = new int[N];\n                for (int i = 0; i < N; i++)\n                {\n                    Goal1[i] = 0;\n                    Goal2[i] = 2;\n                }\n\n                HashGoal1 = Hash(Goal1);\n                HashGoal2 = Hash(Goal2);\n\n                ret = -1;\n                BFS(InitPos, InitMx);\n\n                Console.WriteLine(ret);\n            }\n         \n        }\n\n        public void BFS(int[] pos, int[] mx)\n        {\n            Used = new HashSet<long>();\n\n            var queue = new Queue<Data>();\n            queue.Enqueue(new Data { dist = 0, pos = pos, mx=mx });\n            while (queue.Count > 0)\n            {\n                var d = queue.Dequeue();\n                var hash = Hash(d.pos);\n\n                // Check\n                if (d.dist > M) continue;\n                if (Used.Contains(hash)) continue;\n                Used.Add(hash);\n               \n\n                // Check Goal\n                if (hash == HashGoal1 || hash == HashGoal2)\n                {\n                    ret = d.dist;\n                    break;\n                }\n\n                // Move\n                // Console.Error.WriteLine(string.Join(\", \", d.pos) + \" - \" + string.Join(\", \", d.mx));\n                \n                if (d.mx[0] < d.mx[1])\n                {\n                    var p = d.pos.ToArray();\n                    p[d.mx[1]] = 0;\n                    queue.Enqueue(new Data {dist = d.dist + 1, pos = p, mx = MX(p)});\n                }\n                else\n                {\n                    var p = d.pos.ToArray();\n                    p[d.mx[0]] = 1;\n                    queue.Enqueue(new Data { dist = d.dist + 1, pos = p, mx = MX(p) });\n                }\n\n                if (d.mx[1] < d.mx[2])\n                {\n                    var p = d.pos.ToArray();\n                    p[d.mx[2]] = 1;\n                    queue.Enqueue(new Data { dist = d.dist + 1, pos = p, mx = MX(p) });\n                }\n                else\n                {\n                    var p = d.pos.ToArray();\n                    p[d.mx[1]] = 2;\n                    queue.Enqueue(new Data { dist = d.dist + 1, pos = p, mx = MX(p) });\n                }\n            }\n        }\n\n        public long Hash(int[] pos)\n        {\n            long m = 1;\n            long ret = 0;\n            for (int i = 0; i < pos.Length; i++)\n            {\n                ret += m * pos[i];\n                m *= 3;\n            }\n            return ret;\n        }\n\n        public int[] MX(int[] pos)\n        {\n            int[] ret = new int[3];\n            for (int i = 0; i < 3; i++)\n            {\n                ret[i] = -1;\n            }\n            for (int i = 0; i < pos.Length; i++)\n            {\n                ret[pos[i]] = i;\n            }\n            return ret;\n        }\n    }\n\n    // libs ----------\n    class Data\n    {\n        public int dist;\n        public int[] pos;\n        public int[] mx;\n    }\n\n    // common ----------\n\n    internal static class Input\n    {\n        public static string ReadString()\n        {\n            string line = Console.ReadLine();\n            return line;\n        }\n\n        public static int ReadInt()\n        {\n            string line = Console.ReadLine();\n            return int.Parse(line);\n        }\n\n        public static int[] ReadIntArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(int.Parse).ToArray();            \n        }\n\n        public static long ReadLong()\n        {\n            string line = Console.ReadLine();\n            return long.Parse(line);\n        }\n\n        public static long[] ReadLongArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(long.Parse).ToArray();\n        }\n\n        public static double[] ReadDoubleArray()\n        {\n            string line = Console.ReadLine();\n            return line.Split(' ').Select(double.Parse).ToArray();\n        }\n    }\n    \n    internal class Program\n    {\n        public static void Main(string[] args)\n        {\n            var s = new Solution();\n            s.Run();\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int m = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[] a = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] b = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] c = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,m,a,b,c));\n\t\t\n\t\t\n\t\t}\n\n\t}\n\n  public static int calc(int n,int m,int[] a,int[] b,int[] c) {\n\t  Stack<int> aa = new Stack<int>(new ArraySegment<int>(a, 1, a.Length-1));\n\t  Stack<int> bb = new Stack<int>(new ArraySegment<int>(b, 1, b.Length-1));\n\t  Stack<int> cc = new Stack<int>(new ArraySegment<int>(c, 1, c.Length-1));\n\t  \n\t  //Console.WriteLine(\"A = {0} B = {1} C = {2}\", String.Join(\"\", aa), String.Join(\"\", bb), String.Join(\"\", cc));\n\t  \n\t  \n\t  int t = calc_sub(1, m, aa, bb, cc);\n\t  \n\t  return (m<t ? -1 : t);\n  }\n  \n  public static int calc_sub(int cnt,int max,Stack<int>a,Stack<int> b,Stack<int> c) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return max+10;\n\t  \n\t  int mincnt = max+10;\n\t  \n\t  //a->b\n\t  if((0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    Stack<int> aa = new Stack<int>(a.ToArray());\n\t    Stack<int> bb = new Stack<int>(b.ToArray());\n\t    bb.Push(aa.Pop());\n\n\t\tint t = calc_sub(cnt+1, max, aa, bb, c);\n\t\tif(t < mincnt) mincnt = t;\n\t  }\n\t  \n\t  //b->a\n\t  if((0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    Stack<int> aa = new Stack<int>(a.ToArray());\n\t    Stack<int> bb = new Stack<int>(b.ToArray());\n\t    aa.Push(bb.Pop());\n\n\t\tint t = calc_sub(cnt+1, max, aa, bb, c);\n\t\tif(t < mincnt) mincnt = t;\n\t  }\n\t  \n\t  //b->c\n\t  if((0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    Stack<int> bb = new Stack<int>(b.ToArray());\n\t    Stack<int> cc = new Stack<int>(c.ToArray());\n\t    cc.Push(bb.Pop());\n\n\t\tint t = calc_sub(cnt+1, max, a, bb, cc);\n\t\tif(t < mincnt) mincnt = t;\n\t  }\n\t  \n\t  //c->b\n\t  if((0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    Stack<int> bb = new Stack<int>(b.ToArray());\n\t    Stack<int> cc = new Stack<int>(c.ToArray());\n\t    bb.Push(cc.Pop());\n\n\t\tint t = calc_sub(cnt+1, max, a, bb, cc);\n\t\tif(t < mincnt) mincnt = t;\n\t  }\n\t  \n\t  return mincnt;\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int m = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[] a = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] b = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] c = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,m,a,b,c));\n\t\t\n\t\t\n\t\t}\n\n\t}\n\n  public static int calc(int n,int m,int[] a,int[] b,int[] c) {\n\t  Stack<int> aa = new Stack<int>();\n\t  for(int i=1;t<a.Length;i++) aa.Push(a[i]);\n\t  Stack<int> bb = new Stack<int>();\n\t  for(int i=1;t<b.Length;i++) bb.Push(b[i]);\n\t  Stack<int> cc = new Stack<int>();\n\t  for(int i=1;t<c.Length;i++) cc.Push(c[i]);\n\t  \n\t  //Console.WriteLine(\"A = {0} B = {1} C = {2}\", String.Join(\"\", aa), String.Join(\"\", bb), String.Join(\"\", cc));\n\t  \n\t  \n\t  int t = calc_sub(1, m, aa, bb, cc);\n\t  \n\t  return (m<t ? -1 : t);\n  }\n  \n  public static int calc_sub(int cnt,int max,Stack<int>a,Stack<int> b,Stack<int> c) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return max+10;\n\t  \n\t  int mincnt = max+10;\n\t  \n\t  //a->b\n\t  if((0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    Stack<int> aa = new Stack<int>(a.ToArray());\n\t    Stack<int> bb = new Stack<int>(b.ToArray());\n\t    bb.Push(aa.Pop());\n\n\t\tint t = calc_sub(cnt+1, max, aa, bb, c);\n\t\tif(t < mincnt) mincnt = t;\n\t  }\n\t  \n\t  //b->a\n\t  if((0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    Stack<int> aa = new Stack<int>(a.ToArray());\n\t    Stack<int> bb = new Stack<int>(b.ToArray());\n\t    aa.Push(bb.Pop());\n\n\t\tint t = calc_sub(cnt+1, max, aa, bb, c);\n\t\tif(t < mincnt) mincnt = t;\n\t  }\n\t  \n\t  //b->c\n\t  if((0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    Stack<int> bb = new Stack<int>(b.ToArray());\n\t    Stack<int> cc = new Stack<int>(c.ToArray());\n\t    cc.Push(bb.Pop());\n\n\t\tint t = calc_sub(cnt+1, max, a, bb, cc);\n\t\tif(t < mincnt) mincnt = t;\n\t  }\n\t  \n\t  //c->b\n\t  if((0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    Stack<int> bb = new Stack<int>(b.ToArray());\n\t    Stack<int> cc = new Stack<int>(c.ToArray());\n\t    bb.Push(cc.Pop());\n\n\t\tint t = calc_sub(cnt+1, max, a, bb, cc);\n\t\tif(t < mincnt) mincnt = t;\n\t  }\n\t  \n\t  return mincnt;\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var n = int.Parse(line[0]);\n            var m = int.Parse(line[1]);\n            if (n == 0 && m == 0) break;\n            var a = new Stack<int>();\n            var b = new Stack<int>();\n            var c = new Stack<int>();\n            var a2 = new Stack<int>();\n            var b2 = new Stack<int>();\n            var c2 = new Stack<int>();\n            setST(a, b, c, a2, b2, c2);\n            if (check(a, b, c)) { Console.WriteLine(0); goto exit; }\n            var ans = new List<int>();\n            var peeks = getPeeks(a, b, c);\n            var first = false;\n                if (peeks[0] > peeks[1] )\n                {\n                first = true;\n                b.Push(a.Pop()); ans.Add(getAns(a, b, c, m, \"ab\"));\n            }\n            if (peeks[1] > peeks[0])\n            {\n                if (first) { a2.Push(b2.Pop()); ans.Add(getAns(a2, b2, c2, m, \"ba\")); goto next; }\n                else\n                {\n                    first = true;\n                    a.Push(b.Pop());\n                    ans.Add(getAns(a, b, c, m, \"ba\"));\n                }\n            }\n            if (peeks[1] > peeks[2])\n            {\n                if (first) { c2.Push(b2.Pop()); ans.Add(getAns(a2, b2, c2, m, \"bc\")); goto next; }\n                else\n                {\n                    first = true;\n                    c.Push(b.Pop());\n                    ans.Add(getAns(a, b, c, m, \"bc\"));\n                }\n            }\n            if (peeks[2] > peeks[1])\n            {\n                b2.Push(c2.Pop());\n                ans.Add(getAns(a2, b2, c2, m, \"cb\"));\n            }\n            next:;\n            putAns(ans);\n            exit:;\n        }\n    }\n    static void putAns (List<int> a )\n    {\n        var a2 = a.OrderBy(x => x).ToArray();\n        if (a2[0] == -1 && a2[1] == -1) { Console.WriteLine(-1); return; }\n        if (a2[0] == -1) { Console.WriteLine(a2[1]); return; }\n        Console.WriteLine(a2[0]);\n    }\n    static int[] getPeeks(Stack<int> a, Stack<int> b, Stack<int> c)\n    {\n        var res = new int[3];\n        res[0] = getPeek(a);\n        res[1] = getPeek(b);\n        res[2] = getPeek(c);\n        return res;\n    }\n    static int getAns(Stack<int> a, Stack<int> b, Stack<int> c, int m, string pre)\n    {\n        if (check(a, b, c)) return 1;\n        var count = 1;\n        while (true)\n        {\n            var peeks = getPeeks(a, b, c);\n            if (peeks[0] > peeks[1] && pre != \"ba\") { b.Push(a.Pop()); pre = \"ab\"; }\n            else if (peeks[1] > peeks[0] && pre != \"ab\") { a.Push(b.Pop()); pre = \"ba\"; }\n            else if (peeks[1] > peeks[2] && pre != \"cb\") { c.Push(b.Pop()); pre = \"bc\"; }\n            else { b.Push(c.Pop()); pre = \"cb\"; }\n            count++;\n            if (check(a, b, c) && count <= m) return count;\n            if (count > m) return -1;\n        }\n    }\n    static int getPeek(Stack<int> a) => a.Count() == 0 ? 0 : a.Peek();\n    static bool check(Stack<int> a, Stack<int> b, Stack<int> c) => (a.Count() == 0 && b.Count() == 0) | (b.Count() == 0 && c.Count() == 0);\n    static void setST(Stack<int> a, Stack<int> b, Stack<int> c, Stack<int> a2, Stack<int> b2, Stack<int> c2)\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var p = int.Parse(line[0]);\n        for (int i = 0; i < p; i++)\n        {\n            var w = int.Parse(line[i + 1]);\n            a.Push(w); a2.Push(w);\n        }\n        line = Console.ReadLine().Trim().Split(' ');\n        p = int.Parse(line[0]);\n        for (int i = 0; i < p; i++)\n        {\n            var w = int.Parse(line[i + 1]);\n            b.Push(w); b2.Push(w);\n        }\n        line = Console.ReadLine().Trim().Split(' ');\n        p = int.Parse(line[0]);\n        for (int i = 0; i < p; i++)\n        {\n            var w = int.Parse(line[i + 1]);\n            c.Push(w); c2.Push(w);\n        }\n    }\n}\n\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int m = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[] a = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] b = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] c = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,m,a,b,c));\n\t\t\n\t\t\n\t\t}\n\n\t}\n\n  public static int calc(int n,int m,int[] a,int[] b,int[] c) {\n\t  Stack<int> aa = new Stack<int>();\n\t  for(int i=1;i<a.Length;i++) aa.Push(a[i]);\n\t  Stack<int> bb = new Stack<int>();\n\t  for(int i=1;i<b.Length;i++) bb.Push(b[i]);\n\t  Stack<int> cc = new Stack<int>();\n\t  for(int i=1;i<c.Length;i++) cc.Push(c[i]);\n\t  \n\t  //Console.WriteLine(\"A = {0} B = {1} C = {2}\", String.Join(\"\", aa), String.Join(\"\", bb), String.Join(\"\", cc));\n\t  \n\t  List<int[][]> met = new List<int[][]>();\n\t  met.Add(new int[][]{aa.ToArray(),bb.ToArray(),cc.ToArray()});\n\t  \n\t  int t = calc_sub(0, m, aa, bb, cc, met);\n/*\n\t  foreach(int[][] d in met) {\n\t    Console.WriteLine(\"==========\");\n\t    foreach(int[] e in d) Console.WriteLine(String.Join(\" \", e));\n\t  }\n\t  Console.WriteLine(\"==========\");\n*/\n\t  return (m<t ? -1 : t);\n  }\n  \n  public static int calc_sub(int cnt,int max,Stack<int>a,Stack<int> b,Stack<int> c, List<int[][]> met) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return max+10;\n\t  \n\t  int mincnt = max+10;\n\t  List<int[][]> m1 = new List<int[][]>();\n\t  List<int[][]> m2 = new List<int[][]>();\n\t  List<int[][]> m3 = new List<int[][]>();\n\t  List<int[][]> m4 = new List<int[][]>();\n\t  int t1 = mincnt;\n\t  int t2 = mincnt;\n\t  int t3 = mincnt;\n\t  int t4 = mincnt;\n\t  \n\t  //a->b\n\t  if((0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    Stack<int> aa = CloneStack<int>(a);\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    bb.Push(aa.Pop());\n\n\t\tm1.Add(new int[][]{aa.ToArray(),bb.ToArray(),c.ToArray()});\n\t\tt1 = calc_sub(cnt+1, max, aa, bb, c, m1);\n\t  }\n\t  \n\t  //b->a\n\t  if((0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    Stack<int> aa = CloneStack<int>(a);\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    aa.Push(bb.Pop());\n\n\t\tm2.Add(new int[][]{aa.ToArray(),bb.ToArray(),c.ToArray()});\n\t\tt2 = calc_sub(cnt+1, max, aa, bb, c, m2);\n\t  }\n\t  \n\t  //b->c\n\t  if((0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    Stack<int> cc = CloneStack<int>(c);\n\t    cc.Push(bb.Pop());\n\n\t\tm3.Add(new int[][]{a.ToArray(),bb.ToArray(),cc.ToArray()});\n\t\tt3 = calc_sub(cnt+1, max, a, bb, cc, m3);\n\t  }\n\t  \n\t  //c->b\n\t  if((0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    Stack<int> cc = CloneStack<int>(c);\n\t    bb.Push(cc.Pop());\n\n\t\tm4.Add(new int[][]{a.ToArray(),bb.ToArray(),cc.ToArray()});\n\t\tt4 = calc_sub(cnt+1, max, a, bb, cc, m4);\n\t  }\n\t  \n\t  mincnt = Math.Min(Math.Min(t1,t2),Math.Min(t3,t4));\n\t  if(t1==mincnt) { met.AddRange(m1); return mincnt; }\n\t  if(t2==mincnt) { met.AddRange(m2); return mincnt; }\n\t  if(t3==mincnt) { met.AddRange(m3); return mincnt; }\n\t  if(t4==mincnt) { met.AddRange(m4); return mincnt; }\n\t  \n\t  return mincnt;\n  }\n  \n    public static Stack<T> CloneStack<T>(Stack<T> original)\n    {\n        var arr = new T[original.Count];\n        original.CopyTo(arr, 0);\n        Array.Reverse(arr);\n        return new Stack<T>(arr);\n    }\n  \n  \n  \n  \n  \n  \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int m = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[] a = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] b = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] c = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,m,a,b,c));\n\t\t\n\t\t\n\t\t}\n\n\t}\n\n  public static int calc(int n,int m,int[] a,int[] b,int[] c) {\n\t  Stack<int> aa = new Stack<int>();\n\t  for(int i=1;i<a.Length;i++) aa.Push(a[i]);\n\t  Stack<int> bb = new Stack<int>();\n\t  for(int i=1;i<b.Length;i++) bb.Push(b[i]);\n\t  Stack<int> cc = new Stack<int>();\n\t  for(int i=1;i<c.Length;i++) cc.Push(c[i]);\n\t  \n\t  \n\t  //Console.WriteLine(\"A = {0} B = {1} C = {2}\", String.Join(\"\", aa), String.Join(\"\", bb), String.Join(\"\", cc));\n\t  \n\t  \n\t  int t = calc_sub(1, m, aa, bb, cc);\n\t  \n\t  return (m<t ? -1 : t);\n  }\n  \n  public static int calc_sub(int cnt,int max,Stack<int>a,Stack<int> b,Stack<int> c) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return max+10;\n\t  \n\t  int mincnt = max+10;\n\t  \n\t  //a->b\n\t  if((0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    Stack<int> aa = new Stack<int>(a.ToArray());\n\t    Stack<int> bb = new Stack<int>(b.ToArray());\n\t    bb.Push(aa.Pop());\n\n\t\tint t = calc_sub(cnt+1, max, aa, bb, c);\n\t\tif(t < mincnt) mincnt = t;\n\t  }\n\t  \n\t  //b->a\n\t  if((0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    Stack<int> aa = new Stack<int>(a.ToArray());\n\t    Stack<int> bb = new Stack<int>(b.ToArray());\n\t    aa.Push(bb.Pop());\n\n\t\tint t = calc_sub(cnt+1, max, aa, bb, c);\n\t\tif(t < mincnt) mincnt = t;\n\t  }\n\t  \n\t  //b->c\n\t  if((0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    Stack<int> bb = new Stack<int>(b.ToArray());\n\t    Stack<int> cc = new Stack<int>(c.ToArray());\n\t    cc.Push(bb.Pop());\n\n\t\tint t = calc_sub(cnt+1, max, a, bb, cc);\n\t\tif(t < mincnt) mincnt = t;\n\t  }\n\t  \n\t  //c->b\n\t  if((0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    Stack<int> bb = new Stack<int>(b.ToArray());\n\t    Stack<int> cc = new Stack<int>(c.ToArray());\n\t    bb.Push(cc.Pop());\n\n\t\tint t = calc_sub(cnt+1, max, a, bb, cc);\n\t\tif(t < mincnt) mincnt = t;\n\t  }\n\t  \n\t  return mincnt;\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2556344#3\n\npublic class CupState\n{\n\t\n\tpublic byte[] A;\n\tpublic byte[] B;\n\tpublic byte[] C;\n\tpublic List<byte> Method;\n\t\n}\n\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int m = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[] a = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] b = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] c = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,m,a,b,c));\n\t\t\n\t\t\n\t\t}\n\n\t}\n\n  public static int calc(int n,int m,int[] a,int[] b,int[] c) {\n\t  Stack<byte> aa = new Stack<byte>();\n\t  for(int i=1;i<a.Length;i++) aa.Push((byte)a[i]);\n\t  Stack<byte> bb = new Stack<byte>();\n\t  for(int i=1;i<b.Length;i++) bb.Push((byte)b[i]);\n\t  Stack<byte> cc = new Stack<byte>();\n\t  for(int i=1;i<c.Length;i++) cc.Push((byte)c[i]);\n\t  \n\t  byte[] aaa = new byte[a.Length-1];\n\t  for(int i=1;i<a.Length;i++) aaa[i-1] = (byte)a[i];\n\t  byte[] bbb = new byte[b.Length-1];\n\t  for(int i=1;i<b.Length;i++) bbb[i-1] = (byte)b[i];\n\t  byte[] ccc = new byte[c.Length-1];\n\t  for(int i=1;i<c.Length;i++) ccc[i-1] = (byte)c[i];\n\t  \n\t  //Console.WriteLine(\"A = {0} B = {1} C = {2}\", String.Join(\"\", aa), String.Join(\"\", bb), String.Join(\"\", cc));\n/*\n\t  List<byte[][]> met = new List<byte[][]>();\n\t  met.Add(new byte[][]{aa.ToArray(),bb.ToArray(),cc.ToArray()});\n\t  \n\t  int t = calc_sub_dbg(0, m, aa, bb, cc, met);\n\n\t  foreach(byte[][] d in met) {\n\t    Console.WriteLine(\"==========\");\n\t    foreach(byte[] e in d) Console.WriteLine(String.Join(\" \", e));\n\t  }\n\t  Console.WriteLine(\"==========\");\n*/\n\n\t  int t = calc_sub_2(0, m, aaa, bbb, ccc);\n\n\n\t  return t;\n  }\n  \n  \n  public static int calc_sub_2(int cnt,int max,byte[] a,byte[] b,byte[] c) {\n\t\n\tList<CupState> mcsl = new List<CupState>();\n\tCupState cs = new CupState();\n\tcs.A = a; cs.B = b; cs.C = c; cs.Method = new List<byte>();\n\tmcsl.Add(cs);\n\tList<CupState> ccsl = new List<CupState>();\n\t\n\tint mincnt = max;\n\tfor(int i=0;i<=max;i++){\n\t  if(mcsl.Count == 0) break;\n\t  List<CupState> acsl = new List<CupState>();\n      foreach(CupState ccs in mcsl){\n\t\t//Console.WriteLine(String.Join(\" \", ccs.Method.ToArray()));\n        if ((ccs.B.Length == 0) && ((ccs.A.Length == 0) || (ccs.C.Length == 0))){\n          if(ccs.Method.Count < mincnt) mincnt = ccs.Method.Count;\n          ccsl.Add(ccs);\n          continue;\n        }\n        if (mincnt < ccs.Method.Count){\n          continue;\n        }\n        \n        int mode = (ccs.Method.Count==0) ? 0 : (int)ccs.Method[ccs.Method.Count-1];\n        int va = (ccs.A.Length==0) ? -1 : (int)ccs.A[ccs.A.Length-1];\n        int vb = (ccs.B.Length==0) ? -1 : (int)ccs.B[ccs.B.Length-1];\n        int vc = (ccs.C.Length==0) ? -1 : (int)ccs.C[ccs.C.Length-1];\n        \n        //a->b\n\t    if((mode != 2) && (0<=va) && (vb < va)) {\n\t      CupState csa = new CupState();\n          csa.A = new byte[ccs.A.Length-1];\n          Array.Copy(ccs.A,0,csa.A,0,ccs.A.Length-1);\n          csa.B = new byte[ccs.B.Length+1];\n          Array.Copy(ccs.B,0,csa.B,0,ccs.B.Length);\n          csa.B[csa.B.Length-1] = ccs.A[ccs.A.Length-1];\n          csa.C = ccs.C;\n          csa.Method = new List<byte>(ccs.Method.ToArray());\n          csa.Method.Add(1);\n          acsl.Add(csa);\n\t    }\n        //b->a\n\t    if((mode != 1) && (0<=vb) && (va < vb)) {\n\t      CupState csa = new CupState();\n          csa.B = new byte[ccs.B.Length-1];\n          Array.Copy(ccs.B,0,csa.B,0,ccs.B.Length-1);\n          csa.A = new byte[ccs.A.Length+1];\n          Array.Copy(ccs.A,0,csa.A,0,ccs.A.Length);\n          csa.A[csa.A.Length-1] = ccs.B[ccs.B.Length-1];\n          csa.C = ccs.C;\n          csa.Method = new List<byte>(ccs.Method.ToArray());\n          csa.Method.Add(2);\n          acsl.Add(csa);\n\t    }\n        //b->c\n\t    if((mode != 4) && (0<=vb) && (vc < vb)) {\n\t      CupState csa = new CupState();\n          csa.B = new byte[ccs.B.Length-1];\n          Array.Copy(ccs.B,0,csa.B,0,ccs.B.Length-1);\n          csa.C = new byte[ccs.C.Length+1];\n          Array.Copy(ccs.C,0,csa.C,0,ccs.C.Length);\n          csa.C[csa.C.Length-1] = ccs.B[ccs.B.Length-1];\n          csa.A = ccs.A;\n          csa.Method = new List<byte>(ccs.Method.ToArray());\n          csa.Method.Add(3);\n          acsl.Add(csa);\n\t    }\n        //c->b\n\t    if((mode != 3) && (0<=vc) && (vb < vc)) {\n\t      CupState csa = new CupState();\n          csa.C = new byte[ccs.C.Length-1];\n          Array.Copy(ccs.C,0,csa.C,0,ccs.C.Length-1);\n          csa.B = new byte[ccs.B.Length+1];\n          Array.Copy(ccs.B,0,csa.B,0,ccs.B.Length);\n          csa.B[csa.B.Length-1] = ccs.C[ccs.C.Length-1];\n          csa.A = ccs.A;\n          csa.Method = new List<byte>(ccs.Method.ToArray());\n          csa.Method.Add(4);\n          acsl.Add(csa);\n\t    }\n\t  }\n      mcsl = acsl;\n      \n\t}\n\t\n\treturn (ccsl.Count == 0) ? -1 : mincnt;\n  }\n  \n  \n  public static int calc_sub_1(int cnt,int max,Stack<byte>a,Stack<byte> b,Stack<byte> c, byte mode) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return -1;\n\t  \n\t  int mincnt = max;\n\t  bool suc = false;\n\t  \n\t  //a->b\n\t  if((mode != 2) && (0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    b.Push(a.Pop());\n\t\tint t = calc_sub_1(cnt+1, mincnt, a, b, c, 1);\n\t\ta.Push(b.Pop());\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //b->a\n\t  if((mode != 1) && (0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    a.Push(b.Pop());\n\t\tint t = calc_sub_1(cnt+1, mincnt, a, b, c, 2);\n\t\tb.Push(a.Pop());\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //b->c\n\t  if((mode != 4) && (0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    c.Push(b.Pop());\n\t\tint t = calc_sub_1(cnt+1, mincnt, a, b, c, 3);\n\t\tb.Push(c.Pop());\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //c->b\n\t  if((mode != 3) && (0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    b.Push(c.Pop());\n\t\tint t = calc_sub_1(cnt+1, mincnt, a, b, c, 4);\n\t\tc.Push(b.Pop());\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  if(suc) {\n\t    return mincnt;\n\t  } else {\n\t\treturn -1;\n\t  }\n\n  }\n  \n  public static int calc_sub_dbg(int cnt,int max,Stack<byte>a,Stack<byte> b,Stack<byte> c, List<byte[][]> met) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return max+10;\n\t  \n\t  int mincnt = max+10;\n\t  List<byte[][]> m1 = new List<byte[][]>();\n\t  List<byte[][]> m2 = new List<byte[][]>();\n\t  List<byte[][]> m3 = new List<byte[][]>();\n\t  List<byte[][]> m4 = new List<byte[][]>();\n\t  int t1 = mincnt;\n\t  int t2 = mincnt;\n\t  int t3 = mincnt;\n\t  int t4 = mincnt;\n\t  \n\t  //a->b\n\t  if((0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    Stack<byte> aa = CloneStack<byte>(a);\n\t    Stack<byte> bb = CloneStack<byte>(b);\n\t    bb.Push(aa.Pop());\n\n\t\t//m1.Add(new byte[][]{aa.ToArray(),bb.ToArray(),c.ToArray()});\n\t\tt1 = calc_sub_dbg(cnt+1, max, aa, bb, c, m1);\n\t  }\n\t  \n\t  //b->a\n\t  if((0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    Stack<byte> aa = CloneStack<byte>(a);\n\t    Stack<byte> bb = CloneStack<byte>(b);\n\t    aa.Push(bb.Pop());\n\n\t\t//m2.Add(new byte[][]{aa.ToArray(),bb.ToArray(),c.ToArray()});\n\t\tt2 = calc_sub_dbg(cnt+1, max, aa, bb, c, m2);\n\t  }\n\t  \n\t  //b->c\n\t  if((0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    Stack<byte> bb = CloneStack<byte>(b);\n\t    Stack<byte> cc = CloneStack<byte>(c);\n\t    cc.Push(bb.Pop());\n\n\t\t//m3.Add(new byte[][]{a.ToArray(),bb.ToArray(),cc.ToArray()});\n\t\tt3 = calc_sub_dbg(cnt+1, max, a, bb, cc, m3);\n\t  }\n\t  \n\t  //c->b\n\t  if((0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    Stack<byte> bb = CloneStack<byte>(b);\n\t    Stack<byte> cc = CloneStack<byte>(c);\n\t    bb.Push(cc.Pop());\n\n\t\t//m4.Add(new byte[][]{a.ToArray(),bb.ToArray(),cc.ToArray()});\n\t\tt4 = calc_sub_dbg(cnt+1, max, a, bb, cc, m4);\n\t  }\n\t  \n\t  mincnt = Math.Min(Math.Min(t1,t2),Math.Min(t3,t4));\n\t  if(t1==mincnt) { met.AddRange(m1); return mincnt; }\n\t  if(t2==mincnt) { met.AddRange(m2); return mincnt; }\n\t  if(t3==mincnt) { met.AddRange(m3); return mincnt; }\n\t  if(t4==mincnt) { met.AddRange(m4); return mincnt; }\n\t  \n\t  return mincnt;\n  }\n  \n    public static Stack<T> CloneStack<T>(Stack<T> original)\n    {\n        var arr = new T[original.Count];\n        original.CopyTo(arr, 0);\n        Array.Reverse(arr);\n        return new Stack<T>(arr);\n    }\n  \n  \n  \n  \n  \n  \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int m = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[] a = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] b = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] c = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,m,a,b,c));\n\t\t\n\t\t\n\t\t}\n\n\t}\n\n  public static int calc(int n,int m,int[] a,int[] b,int[] c) {\n\t  Stack<int> aa = new Stack<int>();\n\t  for(int i=1;i<a.Length;i++) aa.Push(a[i]);\n\t  Stack<int> bb = new Stack<int>();\n\t  for(int i=1;i<b.Length;i++) bb.Push(b[i]);\n\t  Stack<int> cc = new Stack<int>();\n\t  for(int i=1;i<c.Length;i++) cc.Push(c[i]);\n\t  \n\t  //Console.WriteLine(\"A = {0} B = {1} C = {2}\", String.Join(\"\", aa), String.Join(\"\", bb), String.Join(\"\", cc));\n/*\n\t  List<int[][]> met = new List<int[][]>();\n\t  met.Add(new int[][]{aa.ToArray(),bb.ToArray(),cc.ToArray()});\n\t  \n\t  int t = calc_sub_dbg(0, m, aa, bb, cc, met);\n\n\t  foreach(int[][] d in met) {\n\t    Console.WriteLine(\"==========\");\n\t    foreach(int[] e in d) Console.WriteLine(String.Join(\" \", e));\n\t  }\n\t  Console.WriteLine(\"==========\");\n*/\n\n\t  int t = calc_sub(0, m, aa, bb, cc, 0);\n\n\n\t  return t;\n  }\n  \n  public static int calc_sub(int cnt,int max,Stack<int>a,Stack<int> b,Stack<int> c, int mode) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return -1;\n\t  \n\t  int mincnt = max;\n\t  bool suc = false;\n\t  \n\t  //a->b\n\t  if((mode != 2) && (0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    Stack<int> aa = CloneStack<int>(a);\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    bb.Push(aa.Pop());\n\n\t\tint t = calc_sub(cnt+1, mincnt, aa, bb, c, 1);\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //b->a\n\t  if((mode != 1) && (0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    Stack<int> aa = CloneStack<int>(a);\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    aa.Push(bb.Pop());\n\n\t\tint t = calc_sub(cnt+1, mincnt, aa, bb, c, 2);\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //b->c\n\t  if((mode != 4) && (0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    Stack<int> cc = CloneStack<int>(c);\n\t    cc.Push(bb.Pop());\n\n\t\tint t = calc_sub(cnt+1, mincnt, a, bb, cc, 3);\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //c->b\n\t  if((mode != 3) && (0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    Stack<int> cc = CloneStack<int>(c);\n\t    bb.Push(cc.Pop());\n\n\t\tint t = calc_sub(cnt+1, mincnt, a, bb, cc, 4);\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  if(suc) {\n\t    return mincnt;\n\t  } else {\n\t\treturn -1;\n\t  }\n\n  }\n  \n  public static int calc_sub_dbg(int cnt,int max,Stack<int>a,Stack<int> b,Stack<int> c, List<int[][]> met) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return max+10;\n\t  \n\t  int mincnt = max+10;\n\t  List<int[][]> m1 = new List<int[][]>();\n\t  List<int[][]> m2 = new List<int[][]>();\n\t  List<int[][]> m3 = new List<int[][]>();\n\t  List<int[][]> m4 = new List<int[][]>();\n\t  int t1 = mincnt;\n\t  int t2 = mincnt;\n\t  int t3 = mincnt;\n\t  int t4 = mincnt;\n\t  \n\t  //a->b\n\t  if((0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    Stack<int> aa = CloneStack<int>(a);\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    bb.Push(aa.Pop());\n\n\t\t//m1.Add(new int[][]{aa.ToArray(),bb.ToArray(),c.ToArray()});\n\t\tt1 = calc_sub_dbg(cnt+1, max, aa, bb, c, m1);\n\t  }\n\t  \n\t  //b->a\n\t  if((0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    Stack<int> aa = CloneStack<int>(a);\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    aa.Push(bb.Pop());\n\n\t\t//m2.Add(new int[][]{aa.ToArray(),bb.ToArray(),c.ToArray()});\n\t\tt2 = calc_sub_dbg(cnt+1, max, aa, bb, c, m2);\n\t  }\n\t  \n\t  //b->c\n\t  if((0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    Stack<int> cc = CloneStack<int>(c);\n\t    cc.Push(bb.Pop());\n\n\t\t//m3.Add(new int[][]{a.ToArray(),bb.ToArray(),cc.ToArray()});\n\t\tt3 = calc_sub_dbg(cnt+1, max, a, bb, cc, m3);\n\t  }\n\t  \n\t  //c->b\n\t  if((0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    Stack<int> bb = CloneStack<int>(b);\n\t    Stack<int> cc = CloneStack<int>(c);\n\t    bb.Push(cc.Pop());\n\n\t\t//m4.Add(new int[][]{a.ToArray(),bb.ToArray(),cc.ToArray()});\n\t\tt4 = calc_sub_dbg(cnt+1, max, a, bb, cc, m4);\n\t  }\n\t  \n\t  mincnt = Math.Min(Math.Min(t1,t2),Math.Min(t3,t4));\n\t  if(t1==mincnt) { met.AddRange(m1); return mincnt; }\n\t  if(t2==mincnt) { met.AddRange(m2); return mincnt; }\n\t  if(t3==mincnt) { met.AddRange(m3); return mincnt; }\n\t  if(t4==mincnt) { met.AddRange(m4); return mincnt; }\n\t  \n\t  return mincnt;\n  }\n  \n    public static Stack<T> CloneStack<T>(Stack<T> original)\n    {\n        var arr = new T[original.Count];\n        original.CopyTo(arr, 0);\n        Array.Reverse(arr);\n        return new Stack<T>(arr);\n    }\n  \n  \n  \n  \n  \n  \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2556344#3\n\npublic class CupState\n{\n\t\n\tpublic byte[] A;\n\tpublic byte[] B;\n\tpublic byte[] C;\n\tpublic List<byte> Method;\n\t\n}\n\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\twhile(true){\n\t\t  string[] str1 = Console.ReadLine().Split(' ');\n\t\t  int n = int.Parse(str1[0]); \n\t\t  int m = int.Parse(str1[1]); \n\n\t\t  if(n == 0) break;\n\t\t\n\t\t  int[] a = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] b = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  int[] c = Array.ConvertAll(Console.ReadLine().Split(' '), new Converter<string,int>(s => int.Parse(s)));\n\t\t  //Console.WriteLine(\"???????????? N = {0} P = {1} Ai = {2}\", n, p, a);\n\t\t  Console.WriteLine(calc(n,m,a,b,c));\n\t\t\n\t\t\n\t\t}\n\n\t}\n\n  public static int calc(int n,int m,int[] a,int[] b,int[] c) {\n\t  Stack<byte> aa = new Stack<byte>();\n\t  for(int i=1;i<a.Length;i++) aa.Push((byte)a[i]);\n\t  Stack<byte> bb = new Stack<byte>();\n\t  for(int i=1;i<b.Length;i++) bb.Push((byte)b[i]);\n\t  Stack<byte> cc = new Stack<byte>();\n\t  for(int i=1;i<c.Length;i++) cc.Push((byte)c[i]);\n\t  \n\t  byte[] aaa = new byte[a.Length-1];\n\t  for(int i=1;i<a.Length;i++) aaa[i-1] = (byte)a[i];\n\t  byte[] bbb = new byte[b.Length-1];\n\t  for(int i=1;i<b.Length;i++) bbb[i-1] = (byte)b[i];\n\t  byte[] ccc = new byte[c.Length-1];\n\t  for(int i=1;i<c.Length;i++) ccc[i-1] = (byte)c[i];\n\t  \n\t  //Console.WriteLine(\"A = {0} B = {1} C = {2}\", String.Join(\"\", aa), String.Join(\"\", bb), String.Join(\"\", cc));\n/*\n\t  List<byte[][]> met = new List<byte[][]>();\n\t  met.Add(new byte[][]{aa.ToArray(),bb.ToArray(),cc.ToArray()});\n\t  \n\t  int t = calc_sub_dbg(0, m, aa, bb, cc, met);\n\n\t  foreach(byte[][] d in met) {\n\t    Console.WriteLine(\"==========\");\n\t    foreach(byte[] e in d) Console.WriteLine(String.Join(\" \", e));\n\t  }\n\t  Console.WriteLine(\"==========\");\n*/\n\n\t  int t = calc_sub_2(0, m, aaa, bbb, ccc);\n\n\n\t  return t;\n  }\n  \n  \n  public static int calc_sub_2(int cnt,int max,byte[] a,byte[] b,byte[] c) {\n\t\n\tList<CupState> mcsl = new List<CupState>();\n\tCupState cs = new CupState();\n\tcs.A = a; cs.B = b; cs.C = c; cs.Method = new List<byte>();\n\tmcsl.Add(cs);\n\tList<CupState> ccsl = new List<CupState>();\n\t\n\tint mincnt = max;\n\tfor(int i=0;i<=max;i++){\n\t  if(mcsl.Count == 0) break;\n\t  List<CupState> acsl = new List<CupState>();\n      foreach(CupState ccs in mcsl){\n\t\t//Console.WriteLine(String.Join(\" \", ccs.Method.ToArray()));\n        if ((ccs.B.Length == 0) && ((ccs.A.Length == 0) || (ccs.C.Length == 0))){\n          if(ccs.Method.Count < mincnt) mincnt = ccs.Method.Count;\n          ccsl.Add(ccs);\n          continue;\n        }\n        if (mincnt < ccs.Method.Count){\n          continue;\n        }\n        \n        int mode = (ccs.Method.Count==0) ? 0 : ccs.Method[ccs.Method.Count-1];\n        int va = (ccs.A.Length==0) ? -1 : ccs.A[ccs.A.Length-1];\n        int vb = (ccs.B.Length==0) ? -1 : ccs.B[ccs.B.Length-1];\n        int vc = (ccs.C.Length==0) ? -1 : ccs.C[ccs.C.Length-1];\n        \n        //a->b\n\t    if((mode != 2) && (0<=va) && (vb < va)) {\n\t      CupState csa = new CupState();\n          csa.A = new byte[ccs.A.Length-1];\n          Array.Copy(ccs.A,0,csa.A,0,ccs.A.Length-1);\n          csa.B = new byte[ccs.B.Length+1];\n          Array.Copy(ccs.B,0,csa.B,0,ccs.B.Length);\n          csa.B[csa.B.Length-1] = ccs.A[ccs.A.Length-1];\n          csa.C = ccs.C;\n          csa.Method = new List<byte>(ccs.Method.ToArray());\n          csa.Method.Add(1);\n          acsl.Add(csa);\n\t    }\n        //b->a\n\t    if((mode != 1) && (0<=vb) && (va < vb)) {\n\t      CupState csa = new CupState();\n          csa.B = new byte[ccs.B.Length-1];\n          Array.Copy(ccs.B,0,csa.B,0,ccs.B.Length-1);\n          csa.A = new byte[ccs.A.Length+1];\n          Array.Copy(ccs.A,0,csa.A,0,ccs.A.Length);\n          csa.A[csa.A.Length-1] = ccs.B[ccs.B.Length-1];\n          csa.C = ccs.C;\n          csa.Method = new List<byte>(ccs.Method.ToArray());\n          csa.Method.Add(2);\n          acsl.Add(csa);\n\t    }\n        //b->c\n\t    if((mode != 4) && (0<=vb) && (vc < vb)) {\n\t      CupState csa = new CupState();\n          csa.B = new byte[ccs.B.Length-1];\n          Array.Copy(ccs.B,0,csa.B,0,ccs.B.Length-1);\n          csa.C = new byte[ccs.C.Length+1];\n          Array.Copy(ccs.C,0,csa.C,0,ccs.C.Length);\n          csa.C[csa.C.Length-1] = ccs.B[ccs.B.Length-1];\n          csa.A = ccs.A;\n          csa.Method = new List<byte>(ccs.Method.ToArray());\n          csa.Method.Add(3);\n          acsl.Add(csa);\n\t    }\n        //c->b\n\t    if((mode != 3) && (0<=vc) && (vb < vc)) {\n\t      CupState csa = new CupState();\n          csa.C = new byte[ccs.C.Length-1];\n          Array.Copy(ccs.C,0,csa.C,0,ccs.C.Length-1);\n          csa.B = new byte[ccs.B.Length+1];\n          Array.Copy(ccs.B,0,csa.B,0,ccs.B.Length);\n          csa.B[csa.B.Length-1] = ccs.C[ccs.C.Length-1];\n          csa.A = ccs.A;\n          csa.Method = new List<byte>(ccs.Method.ToArray());\n          csa.Method.Add(4);\n          acsl.Add(csa);\n\t    }\n\t  }\n      mcsl = acsl;\n      \n\t}\n\t\n\treturn (ccsl.Count == 0) ? -1 : mincnt;\n  }\n  \n  \n  public static int calc_sub_1(int cnt,int max,Stack<byte>a,Stack<byte> b,Stack<byte> c, byte mode) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return -1;\n\t  \n\t  int mincnt = max;\n\t  bool suc = false;\n\t  \n\t  //a->b\n\t  if((mode != 2) && (0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    b.Push(a.Pop());\n\t\tint t = calc_sub_1(cnt+1, mincnt, a, b, c, 1);\n\t\ta.Push(b.Pop());\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //b->a\n\t  if((mode != 1) && (0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    a.Push(b.Pop());\n\t\tint t = calc_sub_1(cnt+1, mincnt, a, b, c, 2);\n\t\tb.Push(a.Pop());\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //b->c\n\t  if((mode != 4) && (0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    c.Push(b.Pop());\n\t\tint t = calc_sub_1(cnt+1, mincnt, a, b, c, 3);\n\t\tb.Push(c.Pop());\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  //c->b\n\t  if((mode != 3) && (0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    b.Push(c.Pop());\n\t\tint t = calc_sub_1(cnt+1, mincnt, a, b, c, 4);\n\t\tc.Push(b.Pop());\n\t\tif ((0<=t)&&(t<mincnt)) mincnt = t;\n\t\tif(0<=t) suc = true;\n\t  }\n\t  \n\t  if(suc) {\n\t    return mincnt;\n\t  } else {\n\t\treturn -1;\n\t  }\n\n  }\n  \n  public static int calc_sub_dbg(int cnt,int max,Stack<byte>a,Stack<byte> b,Stack<byte> c, List<byte[][]> met) {\n\t  if((a.Count==0) && (b.Count==0)) return cnt;\n\t  if((b.Count==0) && (c.Count==0)) return cnt;\n\t  if(max<cnt) return max+10;\n\t  \n\t  int mincnt = max+10;\n\t  List<byte[][]> m1 = new List<byte[][]>();\n\t  List<byte[][]> m2 = new List<byte[][]>();\n\t  List<byte[][]> m3 = new List<byte[][]>();\n\t  List<byte[][]> m4 = new List<byte[][]>();\n\t  int t1 = mincnt;\n\t  int t2 = mincnt;\n\t  int t3 = mincnt;\n\t  int t4 = mincnt;\n\t  \n\t  //a->b\n\t  if((0<a.Count) && ((b.Count==0) || (b.Peek() < a.Peek()))) {\n\t    Stack<byte> aa = CloneStack<byte>(a);\n\t    Stack<byte> bb = CloneStack<byte>(b);\n\t    bb.Push(aa.Pop());\n\n\t\t//m1.Add(new byte[][]{aa.ToArray(),bb.ToArray(),c.ToArray()});\n\t\tt1 = calc_sub_dbg(cnt+1, max, aa, bb, c, m1);\n\t  }\n\t  \n\t  //b->a\n\t  if((0<b.Count) && ((a.Count==0) || (a.Peek() < b.Peek()))) {\n\t    Stack<byte> aa = CloneStack<byte>(a);\n\t    Stack<byte> bb = CloneStack<byte>(b);\n\t    aa.Push(bb.Pop());\n\n\t\t//m2.Add(new byte[][]{aa.ToArray(),bb.ToArray(),c.ToArray()});\n\t\tt2 = calc_sub_dbg(cnt+1, max, aa, bb, c, m2);\n\t  }\n\t  \n\t  //b->c\n\t  if((0<b.Count) && ((c.Count==0) || (c.Peek() < b.Peek()))) {\n\t    Stack<byte> bb = CloneStack<byte>(b);\n\t    Stack<byte> cc = CloneStack<byte>(c);\n\t    cc.Push(bb.Pop());\n\n\t\t//m3.Add(new byte[][]{a.ToArray(),bb.ToArray(),cc.ToArray()});\n\t\tt3 = calc_sub_dbg(cnt+1, max, a, bb, cc, m3);\n\t  }\n\t  \n\t  //c->b\n\t  if((0<c.Count) && ((b.Count==0) || (b.Peek() < c.Peek()))) {\n\t    Stack<byte> bb = CloneStack<byte>(b);\n\t    Stack<byte> cc = CloneStack<byte>(c);\n\t    bb.Push(cc.Pop());\n\n\t\t//m4.Add(new byte[][]{a.ToArray(),bb.ToArray(),cc.ToArray()});\n\t\tt4 = calc_sub_dbg(cnt+1, max, a, bb, cc, m4);\n\t  }\n\t  \n\t  mincnt = Math.Min(Math.Min(t1,t2),Math.Min(t3,t4));\n\t  if(t1==mincnt) { met.AddRange(m1); return mincnt; }\n\t  if(t2==mincnt) { met.AddRange(m2); return mincnt; }\n\t  if(t3==mincnt) { met.AddRange(m3); return mincnt; }\n\t  if(t4==mincnt) { met.AddRange(m4); return mincnt; }\n\t  \n\t  return mincnt;\n  }\n  \n    public static Stack<T> CloneStack<T>(Stack<T> original)\n    {\n        var arr = new T[original.Count];\n        original.CopyTo(arr, 0);\n        Array.Reverse(arr);\n        return new Stack<T>(arr);\n    }\n  \n  \n  \n  \n  \n  \n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var [n,m]=arr.shift().split(\" \").map(Number);\n   if(n==0 && m==0)break;\n   var [a,b,c]=arr.slice(0,3).map(v=>v.split(\" \").slice(1).map(Number).reverse());\n   var obj={};\n   var result =-1;\n   var bfs=[[a,b,c,0]];\n   while(true){\n      if(bfs.length==0)break;\n      var [a,b,c,cnt]=bfs.shift();    \n      if(cnt>m)break;\n      if((a.length==0 && b.length==0) || (b.length==0 && c.length==0)){\n         result=cnt;\n         break;\n       }\n      var str=\"a\"+a.join(\",\")+\"b\"+b.join(\",\")+\"c\"+c.join(\",\");\n      if(obj.hasOwnProperty(str))continue;\n      else obj[str]=1;    \n      if(a.length==0)bfs.push([[b[0]],b.slice(1),c,cnt+1]);\n      else if(b.length==0)bfs.push([a.slice(1),[a[0]],c,cnt+1]);\n      else if(a[0]<b[0])bfs.push([[b[0]].concat(a),b.slice(1),c,cnt+1]);\n      else if(a[0]>b[0])bfs.push([a.slice(1),[a[0]].concat(b),c,cnt+1]);\n         \n      if(b.length==0)bfs.push([a,[c[0]],c.slice(1),cnt+1]);\n      else if(c.length==0)bfs.push([a,b.slice(1),[b[0]],cnt+1]);\n      else if(b[0]<c[0])bfs.push([a,[c[0]].concat(b),c.slice(1),cnt+1]);\n      else if(b[0]>c[0])bfs.push([a,b.slice(1),[b[0]].concat(c),cnt+1]);\n   }\n   console.log(result);\n   arr=arr.slice(3);\n}\n"
  },
  {
    "language": "Ruby",
    "code": "def f;gets.split.map &:to_i;end\nwhile(n,m=f)[0]>0\nl=(0..2).map{(i=f)[0]=0;i}\nr=[0,1].map{|x|a,b,c=t=l.map(&:dup);(0..m).find{|d|!(b[1]||a[1]&&c[1])||!(t[z=x][-1]>t[y=x+1][-1]&&(x,y=y,x);t[x].push t[y].pop;x=1-z)}||1e8}.min\np r<1e8?r:-1\nend"
  },
  {
    "language": "Ruby",
    "code": "Problem = Struct.new(:cup_count, :swap_limit, :trays) do\n  def solve\n    steps = dive(0, trays)[0]\n    p steps > swap_limit ? -1 : steps\n  end\n  \n  private\n  \n  def dive(swap_count, trays)\n    # p [:dive, swap_count, trays]\n    \n    if swap_count > swap_limit\n      return swap_count, trays\n    end\n  \n    lesser, max = lesser_and_max(trays)\n    lesser == max and raise \"assertion failed: lesser != max\"\n    max.nil? and raise \"assertion failed: !max.nil?\"\n    \n    if lesser.nil?\n      if max == 1\n        count, moved = move(max, 0, trays)\n        return count + swap_count, trays\n      else\n        return swap_count, trays\n      end\n    end\n  \n    other = ([0, 1, 2] - [max, lesser])[0]\n    \n    if max == 1\n      c1, t1 = move(max, other, trays)\n      c2, t2 = move(lesser, max, t1)\n      way1 = dive swap_count + c1 + c2, t2\n      \n      c3, t3 = move(max, lesser, trays)\n      way2 = dive swap_count + c3, t3\n      \n      if way1[0] < way2[0]\n        way1\n      else\n        way2\n      end\n    else\n      c1, t1 = move1(lesser, other, trays)\n      c2, t2 = move(max, other, t1)\n      way1 = dive swap_count + c1 + c2, t2\n      \n      c3, t3 = move(max, lesser, trays)\n      way2 = dive swap_count + c3, t3\n      \n      if way1[0] < way2[0]\n        way1\n      else\n        way2\n      end\n    end\n  end\n  \n  def lesser_and_max(trays)\n    trays.each_with_index.\n      sort_by {|t,i| t.last || -1 }[1..-1].\n      map {|x,i| i unless x.empty? }\n  end\n  \n  def move1(from, to, trays)\n    # p [:move1, from, to, trays]\n    from != to or raise \"source and trays must differ\"\n    \n    trays = trays.dup\n    trays[to] = trays[to].dup.push trays[from].last\n    trays[from] = trays[from][0..-2]\n    \n    steps = to == 1 || from == 1 ? 1 : 2\n    \n    return steps, trays\n  end\n  \n  def move(from, to, trays)\n    # p [:move, from, to, trays]\n    from != to or raise \"source and trays must differ\"\n    \n    from_tray = trays[from]\n    \n    from_tray.empty? and raise \"The source tray must not be empty\"\n    \n    if from_tray.size == 1\n      return *move1(from, to, trays)\n    end\n    \n    i = from_tray.size - 1\n    while from_tray[i - 1] == from_tray[i] - 1\n      i -= 1\n    end\n  \n    trays = trays.dup\n    trays[to] = trays[to] + from_tray[i..-1]\n    trays[from] = trays[from][0...i]\n    \n    steps = 3 ** (from_tray.size - i) - 1\n    steps /= 2 if to == 1 || from == 1\n    \n    return steps, trays\n  end\nend\n\ndef input\n  STDIN.gets.split.map &:to_i\nend\n\nwhile true\n  n, m = input\n  break if n == 0 && m == 0\n  trays = Array.new(3) { input[1..-1] }\n  Problem.new(n, m, trays).solve\nend"
  },
  {
    "language": "Ruby",
    "code": "Problem = Struct.new(:cup_count, :swap_limit, :trays) do\n  def solve\n    steps = dive(0, trays)[0]\n    p steps > swap_limit ? -1 : steps\n  end\n  \n  private\n  \n  def dive(swap_count, trays)\n    # p [:dive, swap_count, trays]\n    \n    if swap_count > swap_limit\n      return swap_count, trays\n    end\n  \n    lesser, max = lesser_and_max(trays)\n    lesser == max and raise \"assertion failed: lesser != max\"\n    max.nil? and raise \"assertion failed: !max.nil?\"\n    \n    if lesser.nil?\n      if max == 1\n        count, moved = move(max, 0, trays)\n        return count + swap_count, trays\n      else\n        return swap_count, trays\n      end\n    end\n    \n    if max == 1\n      count, t1 = move(max, lesser, trays)\n      return *dive(count + swap_count, t1)\n    else\n      other = ([0, 1, 2] - [max, lesser])[0]\n      \n      c1, t1 = move1(lesser, other, trays)\n      c2, t2 = move(max, other, t1)\n      way1 = dive swap_count + c1 + c2, t2\n      \n      c3, t3 = move(max, lesser, trays)\n      way2 = dive swap_count + c3, t3\n      \n      if way1[0] < way2[0]\n        way1\n      else\n        way2\n      end\n    end\n  end\n  \n  def lesser_and_max(trays)\n    trays.each_with_index.\n      sort_by {|t,i| t.last || -1 }[1..-1].\n      map {|x,i| i unless x.empty? }\n  end\n  \n  def move1(from, to, trays)\n    #p [:move1, from, to, trays]\n    from != to or raise \"Source and Destination must differ\"\n    \n    trays = trays.dup\n    trays[to] = trays[to].dup.push trays[from].last\n    trays[from] = trays[from][0..-2]\n    \n    steps = to == 1 || from == 1 ? 1 : 2\n    \n    return steps, trays\n  end\n  \n  def move(from, to, trays)\n    # p [:move, from, to, trays]\n    from != to or raise \"Source and Destination must differ\"\n    \n    from_tray = trays[from]\n    \n    from_tray.empty? and raise \"The source tray must not be empty\"\n    from_tray.last == cup_count or raise \"The source tray must have the biggest cup\"\n    \n    if from_tray.size == 1\n      return *move1(from, to, trays)\n    end\n    \n    i = from_tray.size - 1\n    while from_tray[i - 1] == from_tray[i] - 1\n      i -= 1\n    end\n  \n    trays = trays.dup\n    trays[to] = trays[to] + from_tray[i..-1]\n    trays[from] = trays[from][0...i]\n    \n    steps = 3 ** (from_tray.size - i) - 1\n    steps /= 2 if to == 1 || from == 1\n    \n    return steps, trays\n  end\n  \n  def a_to_c_steps\n    @a_to_c ||= cup_count ** 3 - 1\n  end\n  \n  def a_to_b_steps\n    @a_to_b ||= a_to_c_steps / 2\n  end\nend\n\ndef input\n  STDIN.gets.split.map &:to_i\nend\n\nwhile true\n  n, m = input\n  break if n == 0 && m == 0\n  trays = Array.new(3) { input[1..-1] }\n  Problem.new(n, m, trays).solve\nend"
  },
  {
    "language": "Ruby",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* constant */\n\n#define MAX_INT (1 << 30)\n#define MAX_N   (15)\n#define MAX_KEY (14348907)      /* 3 ** 15 */\n\n/* typedef */\n\ntypedef char cup_t[MAX_N];\n\n/* global variables */\n\nstatic int n, m;\n\nstatic int dists[MAX_KEY];\n\nstatic int qhead, qtail;\nstatic long q[MAX_KEY];\n\n/* subroutines */\n\nlong expi(long d, int n) {\n  long e = 1;\n  while (n) {\n    if (n & 1) e *= d;\n    d *= d;\n    n >>= 1;\n  }\n  return e;\n}\n\nlong arr2key(cup_t cups) {\n  int i;\n  long key = 0;\n\n  for (i = n - 1; i >= 0; i--)\n    key = key * 3 + cups[i];\n\n  return key;\n}\n\nchar *key2arr(long key, cup_t cups) {\n  int i;\n\n  for (i = 0; i < n; i++) {\n    cups[i] = key % 3;\n    key /= 3;\n  }\n\n  return cups;\n}\n\n/* main */\n\nint main(int argc, char **argv) {\n  int cn, cp, d, dg, g0, g1, i, j, k, nnbr;\n  long key, st, u, v;\n  static int tops[3];\n  static long nbrs[4];\n  static cup_t cups, cups0, cups1;\n\n  for (;;) {\n    scanf(\"%d %d\", &n, &m);\n    if (n == 0 && m == 0) break;\n\n    for (k = 0; k < 3; k++) {\n      scanf(\"%d\", &cn);\n      for (i = 0; i < cn; i++) {\n        scanf(\"%d\", &j);\n        cups[j - 1] = k;\n      }\n    }\n\n    g0 = 0;\n    g1 = expi(3, n) - 1;\n\n    st = arr2key(cups);\n\n    for (i = g0; i <= g1; i++)\n      dists[i] = MAX_INT;\n    dists[st] = 0;\n\n    qhead = 0;\n    qtail = 1;\n    q[0] = st;\n\n    while (qtail > qhead) {\n      u = q[qhead++];\n\n      if (u == g0 || u == g1 || dists[u] >= m) break;\n\n      tops[0] = tops[1] = tops[2] = -1;\n      key = u;\n\n      for (i = 0; i < n; i++) {\n        cp = key % 3;\n        cups0[i] = cp;\n        key /= 3;\n        tops[cp] = i;\n      }\n\n      nnbr = 0;\n      if (tops[0] > tops[1]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[0]] = 1;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n      if (tops[1] > tops[0]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[1]] = 0;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n      if (tops[1] > tops[2]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[1]] = 2;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n      if (tops[2] > tops[1]) {\n        memcpy(cups1, cups0, sizeof(cup_t));\n        cups1[tops[2]] = 1;\n        nbrs[nnbr++] = arr2key(cups1);\n      }\n\n      d = dists[u] + 1;\n\n      for (i = 0; i < nnbr; i++) {\n        v = nbrs[i];\n        if (dists[v] > d) {\n          dists[v] = d;\n          q[qtail++] = v;\n        }\n      }\n    }\n\n    dg = (dists[g0] < dists[g1]) ? dists[g0] : dists[g1];\n\n    printf(\"%d\\n\",  dg < MAX_INT ? dg : -1);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "Ruby",
    "code": "def f;gets.split.map &:to_i;end\nwhile(n,m=f)[0]>0\no=(u=(0..2).map{(i=f)[0]=0;i}).reverse.map &:dup\nr=[o,u].map{|a,b,c|(0..m).find{|d|!(b[1]||a[1]&&c[1])||!(s,t=a[-1]>b[-1]?[b,a]:[a,b];s.push t.pop;a,c=c,a)}||1e8}.min\np r<1e8?r:-1\nend"
  },
  {
    "language": "Ruby",
    "code": "while 1\n\n\ntmp=gets.chomp.split(\" \")\ntmp.map!{|x| x.to_i}\n\n\n\n\nn=0\nm=0\na=[0]\nb=[0]\nc=[0]\nsolve = -1\n\nn = tmp[0]\nm = tmp[1]\n\na=gets.chomp.split(\" \")\nb=gets.chomp.split(\" \")\nc=gets.chomp.split(\" \")\n\nfor x in 1..m\n\tif b.length == 1 then\n\t\tsolve = x-1\n\t\tbreak\n\telse\n\t\tt = b[b.length-1]\n\t\tif a[a.length-1] < t then\n\t\t\ta.push(t)\n\t\t\tb.pop\n\t\telsif c[c.length-1] < t then\n\t\t\tc.push(t)\n\t\t\tb.pop\n\t\tend\n\tend\t\nend\n\nputs solve\n\n\nend"
  },
  {
    "language": "Ruby",
    "code": "while true do\n  n, m = gets.split.map(&:to_i)\n  break if m == 0 && n == 0\n\n  target = []\n  3.times do |i|\n    nums = gets.split.map(&:to_i)\n    nums.shift\n    \n    nums.each do |num|\n      target[num-1] = i\n    end\n  end\n\n\n  cnv_target = []\n  target.size.times do |i|\n    n_odd = 0\n    target[0,i].each do |j|\n      n_odd += 1 if j.odd?\n    end\n    cnv = n_odd.even? ? target[i] : 2 - target[i]\n    cnv_target << cnv\n  end\n\n  count0 = 0\n  cnv_target.reverse.each_with_index do |num, i|\n    count0 += num * 3**i\n  end\n\n  count1 = 3**n - 1 - count0\n\n  count = [count0, count1].min\n  puts count > m ? -1 : count\nend"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nloop do\n  $n, $m = gets.strip.split(' ').map{|s| s.to_i}\n  break if $n == 0 && $m == 0\n\n  target = []\n  for k in (0..2)\n    cs = gets.strip.split(' ').map{|s| s.to_i}\n    cs.shift\n\n    for c in cs\n      target[$n - c] = k\n    end\n  end\n\n  count0 = 0\n  p = 0\n\n  ($n - 1).downto(0) do |k|\n    if p != target[k]\n      d = (target[k] - p).abs\n      count0 += d * (3 ** k)\n      if d == 1\n        p = 2 - p\n      end\n    end\n  end\n\n  count1 = (3 ** $n) - 1 - count0\n  count = [count0, count1].min\n\n  puts (count > $m ? -1 : count)\nend"
  },
  {
    "language": "Ruby",
    "code": "def f;gets.split.map &:to_i;end\nwhile(n,m=f)[0]>0\nl=(0..2).map{(i=f)[0]=0;i}\nr=[0,1].map{|x|a,b,c=t=l.map(&:dup);(0..m).find{|d|!(b[1]||a[1]&&c[1])||![t[x][-1]>t[z=y=x+1][-1]&&(x,y=y,x),(t[x].push t[y].pop),x=2-z]}||1e8}.min\np r<1e8?r:-1\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 1 << 30\n\n### subroutines\n\ndef arr2key(arr)\n  key = 0\n  ($n - 1).downto(0) do |i|\n    key = key * 3 + arr[i]\n  end\n  key\nend\n\ndef key2arr(key)\n  arr = []\n  for i in (0...$n)\n    arr << key % 3\n    key /= 3\n  end\n  arr\nend\n\n### main\n\nloop do\n  $n, $m = gets.strip.split(' ').map{|s| s.to_i}\n  break if $n == 0 && $m == 0\n\n  ta = gets.strip.split(' ').map{|s| s.to_i}\n  tb = gets.strip.split(' ').map{|s| s.to_i}\n  tc = gets.strip.split(' ').map{|s| s.to_i}\n\n  nta = ta.shift\n  ntb = tb.shift\n  ntc = tc.shift\n\n  cups = []\n  ta.each{|c| cups[c - 1] = 0}\n  tb.each{|c| cups[c - 1] = 1}\n  tc.each{|c| cups[c - 1] = 2}\n  # p cups\n\n  g0 = 0\n  g1 = (3 ** $n) - 1\n\n  st = arr2key(cups)\n\n  dists = (g0..g1).map{MAX_INT}\n  dists[st] = 0\n\n  q = [st]\n\n  while ! q.empty?\n    u = q.shift\n    next if u == g0 || u == g1 || dists[u] >= $m\n\n    tops = [-1, -1, -1]\n    cups0 = []\n    key = u\n    for i in (0...$n)\n      cp = key % 3\n      cups0 << cp\n      key /= 3\n      tops[cp] = i\n    end\n    #p tops\n\n    nbrs = []\n    if tops[0] > tops[1]\n      cups1 = cups0.clone\n      cups1[tops[0]] = 1\n      nbrs << arr2key(cups1)\n    end\n    if tops[1] > tops[0]\n      cups1 = cups0.clone\n      cups1[tops[1]] = 0\n      nbrs << arr2key(cups1)\n    end\n    if tops[1] > tops[2]\n      cups1 = cups0.clone\n      cups1[tops[1]] = 2\n      nbrs << arr2key(cups1)\n    end\n    if tops[2] > tops[1]\n      cups1 = cups0.clone\n      cups1[tops[2]] = 1\n      nbrs << arr2key(cups1)\n    end\n\n    d = dists[u] + 1\n\n    for v in nbrs\n      if dists[v] > d\n        dists[v] = d\n        q << v\n      end\n    end\n  end\n\n  dg = [dists[g0], dists[g1]].min\n\n  puts (dg < MAX_INT ? dg : -1)\nend"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\ndef f n,p\nr=h=[[$a,b=$b],[b,$c],[$c,b],[b,$a]]\nn>$m ?-1:$a+b==[]||b+$c==[]?n: (1..4).any?{|w|q,s=h[w-1];q.size>0&&p!=5-w&&q[-1]>(s[-1]||0)&&s<<q.pop&&!((r=f n+1,w)<0&&q<<s.pop)}?r:-1\nend\nwhile(_,$m=g)[0]>0\n_,*$a=g\n_,*$b=g\n_,*$c=g\np f(0,0)\nend"
  },
  {
    "language": "Ruby",
    "code": "Max = 1500000\nA, B, C = (0...3).to_a\nFrom, To = 1, 0\n\nuntil (n,m=gets.split.map(&:to_i)).all?(&:zero?) do\n  tray = Array.new\n  3.times do\n    tray.push([-1] + gets.split.slice(1...$_.split.size).map(&:to_i))\n  end\n  answer = Max + 1\n  [[A,B], [B,C]].each do |move|\n    t = tray.map(&:dup)\n    for depth in 0..m do\n      if t[A].size==n+1 || t[C].size==n+1\n        answer = [answer, depth].min\n        break\n      end\n      move.sort!{|a,b|t[a].last<=>t[b].last}\n      t[move[To]].push( t[move[From]].pop )\n      move = move.include?(C) ? [A,B] : [B,C]\n    end\n  end\n  p answer<=Max ? answer : -1\nend"
  },
  {
    "language": "Ruby",
    "code": "def f;gets.split.map &:to_i;end\nwhile(n,m=f)[0]>0\nl=(0..2).map{(i=f)[0]=-1;i}\nr=[0,1].map{|x|a,b,c=t=l.map(&:dup);(0..m).find{|d|!(b[1]||a[1]&&c[1])||![t[x][-1]>t[z=y=x+1][-1]&&(x,y=y,x),(t[x].push t[y].pop),x=2-z]}||1e8}.min\np r<1e8?r:-1\nend"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n//???????????°??\\??????function\nfunction cupArrangement(&$tray) {\n\n    //??\\??????????????§??????\n    $stdin = trim(fgets(STDIN));\n    $stdin = explode(\" \", $stdin);\n\n    //???????????°?????????????????°????????????????????°???????????????\n    for ($i = 0; $i < $stdin[0]; $i++) {\n        $tray[$i] = $stdin[$i];\n    }\n}\n\n//??????????§???????function\nfunction moveCup(&$moveTray, &$destinationTray) {\n\n    $destinationTray[] = $moveTray[count($moveTray) - 1];\n    array_pop($moveTray);\n}\n\n//cupNum?????§??????????????????????????¨????????????function\nfunction seachTray($tray, $cupNum) {\n\n    for ($i = 0; $i < count($tray); $i++) {\n        if ($tray[$i] == $cupNum) {\n            //??¢??????????????????????????????????????????????????°????????????\n            return $i;\n        }\n    }\n\n    //????????????????????´??????-1?????????\n    return -1;\n}\n\n//????????????????????°???????????????\n$count = 0;\n\n//??????????????°n??¨?????§?§?????????°m\n$n;\n$m;\n\n//?????¬???A,B,C?????°????????????????????????\n$trayA = array();\n$trayB = array();\n$trayC = array();\n\n//?????¨??¢?´¢??????????????????????????????\n$nowMinCup = 1;\n\nwhile ($count < 5) {\n\n    //n??¨m?????°????????\\?????????\n    //??\\??????????????§??????\n    $stdin = trim(fgets(STDIN));\n    $stdin = explode(\" \", $stdin);\n\n    //m,n???????????????0??????????????????\n    if ($stdin[0] == 0 && $stdin[1] == 0) {\n        break;\n    }\n    //n?????\\??????????????´?????\\???\n    if (1 <= $stdin[0] && $stdin[0] <= 15) {\n        $n = $stdin[0];\n    }\n\n    //m?????\\??????????????´?????\\???\n    if (1 <= $stdin[1] && $stdin[1] <= 15000000) {\n        $m = $stdin[1];\n    }\n\n    //?????¬???????????£??????????????????????????±??\\???\n    cupArrangement($trayA);\n    cupArrangement($trayB);\n    cupArrangement($trayC);\n\n    //??¨???????????????????????¨??????????????????????????°\n    $crearFlag = false;\n\n    //?????????????§?????????°\n    $cupMove = 0;\n\n    //m????????§?????????????§?????????????\n    for ($i = 0; $i < $m; $i++) {\n\n        //?????¬???A???C????????°?????????????????????\n        if ($trayA == null && $trayB == null || $trayB == null && $trayC == null) {\n            $crearFlag = true;\n            break;\n        }\n\n        //?????¨??????????????????????????????????????¢?´¢\n        $Anum = seachTray($trayA, $nowMinCup);\n        $Bnum = seachTray($trayB, $nowMinCup);\n        $Cnum = seachTray($trayC, $nowMinCup);\n\n        //A??¨C?????????1????????????????????????????????????\n        //A????????¨????????????????????????????????????\n        if ($Anum) {\n\n            //A???1????????????????????????\n            if ($trayA[0] == 1) {\n                //??¢?´¢?????????????????????????????????\n                $nowMinCup++;\n            }\n\n            //C????????£????????????????????§??\\????????????\n            else {\n\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ($trayA[count($trayA) - 1] > $trayB[count($trayB) - 1]) {\n                    moveCup($trayA, $trayB);\n                }\n\n                //B?????§???????????????????????????B???C????§????\n                else {\n                    moveCup($trayB, $trayC);\n                }\n            }\n        }\n\n        //B????§????????????????????????????????????´???\n        else if ($Bnum) {\n\n            //A???1????????????????????????A????§????\n            if ($trayA[0] == 1) {\n\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ($trayA[count($trayA) - 1] > $trayB[count($trayB) - 1]) {\n                    moveCup($trayB, $trayA);\n                }\n            }\n\n            //C???1???????????????????????´???\n            else if ($trayC[0] == 1) {\n\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ($trayC[count($trayC) - 1] > $trayB[count($trayB) - 1]) {\n                    moveCup($trayB, $trayC);\n                }\n            }\n        }\n\n        //C????§????????????????????????????????????´???\n        else {\n\n            //C???1????????????????????????\n            if ($trayC[0] == 1) {\n                //??¢?´¢?????????????????????????????????\n                $nowMinCup++;\n            }\n\n            //A????????£????????????????????§??\\????????????\n            else {\n\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ($trayC[count($trayC) - 1] > $trayB[count($trayB) - 1]) {\n                    moveCup($trayC, $trayB);\n                }\n\n                //B?????§???????????????????????????B???A????§????\n                else {\n                    moveCup($trayB, $trayA);\n                }\n            }\n        }\n\n        //?§?????????°???????????????????¢???????\n        $cupMove++;\n    }\n\n    //??????????????????????§?????????°?????????\n    if ($crearFlag) {\n        echo $cupMove . \"\\n\";\n    }\n\n    //????????§???????????°-1?????????\n    else {\n        echo \"-1\" . \"\\n\";\n    }\n\n    //?????????\n    $trayA = array();\n    $trayB = array();\n    $trayC = array();\n    $nowMinCup = 1;\n    $crearFlag = false;\n    $cupMove = 0;\n\n    //?????????????????£????????????????????°????¢???????\n    $count++;\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n//???????????°??\\??????function\nfunction cupArrangement(&$tray) {\n\n    //??\\??????????????§??????\n    $stdin = trim(fgets(STDIN));\n    $stdin = explode(\" \", $stdin);\n\n    //???????????°?????????????????°????????????????????°???????????????\n    for ($i = 0; $i < $stdin[0]; $i++) {\n        $tray[$i] = $stdin[$i];\n    }\n}\n\n//??????????§???????function\nfunction moveCup(&$moveTray, &$destinationTray) {\n\n    $destinationTray[] = $moveTray[count($moveTray) - 1];\n    array_pop($moveTray);\n}\n\n//cupNum?????§??????????????????????????¨????????????function\nfunction seachTray($tray, $cupNum) {\n\n    for ($i = 0; $i < count($tray); $i++) {\n        if ($tray[$i] == $cupNum) {\n            //??¢??????????????????????????????????????????????????°????????????\n            return $i;\n        }\n    }\n\n    //????????????????????´??????-1?????????\n    return -1;\n}\n\n//????????????????????°???????????????\n$count = 0;\n\n//??????????????°n??¨?????§?§?????????°m\n$n;\n$m;\n\n//?????¬???A,B,C?????°????????????????????????\n$trayA = array();\n$trayB = array();\n$trayC = array();\n\n//?????¨??¢?´¢??????????????????????????????\n$nowMinCup = 1;\n\nwhile ($count < 5) {\n\n//n??¨m?????°????????\\?????????\n//??\\??????????????§??????\n    $stdin = trim(fgets(STDIN));\n    $stdin = explode(\" \", $stdin);\n\n//n?????\\??????????????´?????\\???\n    if (1 <= $stdin[0] && $stdin[0] <= 15) {\n        $n = $stdin[0];\n    }\n\n//m?????\\??????????????´?????\\???\n    if (1 <= $stdin[1] && $stdin[1] <= 15000000) {\n        $m = $stdin[1];\n    }\n\n//m,n???????????????0??????????????????\n    if ($n == 0 && $m == 0) {\n        break;\n    }\n\n//?????¬???????????£??????????????????????????±??\\???\n    cupArrangement($trayA);\n    cupArrangement($trayB);\n    cupArrangement($trayC);\n\n//??¨???????????????????????¨??????????????????????????°\n    $crearFlag = false;\n\n//?????????????§?????????°\n    $cupMove = 0;\n\n//m????????§?????????????§?????????????\n    for ($i = 0; $i < $m; $i++) {\n\n        //?????¬???A???C????????°?????????????????????\n        if ($trayA == null && $trayB == null || $trayB == null && $trayC == null) {\n            $crearFlag = true;\n            break;\n        }\n\n        //?????¨??????????????????????????????????????¢?´¢\n        $Anum = seachTray($trayA, $nowMinCup);\n        $Bnum = seachTray($trayB, $nowMinCup);\n        $Cnum = seachTray($trayC, $nowMinCup);\n\n        //A??¨C?????????1????????????????????????????????????\n        //A????????¨????????????????????????????????????\n        if ($Anum) {\n\n            //A???1????????????????????????\n            if ($trayA[0] == 1) {\n                //??¢?´¢?????????????????????????????????\n                $nowMinCup++;\n            }\n\n            //C????????£????????????????????§??\\????????????\n            else {\n\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ($trayA[count($trayA) - 1] > $trayB[count($trayB) - 1]) {\n                    moveCup($trayA, $trayB);\n                }\n\n                //B?????§???????????????????????????B???C????§????\n                else {\n                    moveCup($trayB, $trayC);\n                }\n            }\n        }\n\n        //B????§????????????????????????????????????´???\n        else if ($Bnum) {\n\n            //A???1????????????????????????A????§????\n            if ($trayA[0] == 1) {\n\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ($trayA[count($trayA) - 1] > $trayB[count($trayB) - 1]) {\n                    moveCup($trayB, $trayA);\n                }\n            }\n\n            //C???1???????????????????????´???\n            else if ($trayC[0] == 1) {\n\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ($trayC[count($trayC) - 1] > $trayB[count($trayB) - 1]) {\n                    moveCup($trayB, $trayC);\n                }\n            }\n        }\n\n        //C????§????????????????????????????????????´???\n        else {\n\n            //C???1????????????????????????\n            if ($trayC[0] == 1) {\n                //??¢?´¢?????????????????????????????????\n                $nowMinCup++;\n            }\n\n            //A????????£????????????????????§??\\????????????\n            else {\n\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ($trayC[count($trayC) - 1] > $trayB[count($trayB) - 1]) {\n                    moveCup($trayC, $trayB);\n                }\n\n                //B?????§???????????????????????????B???A????§????\n                else {\n                    moveCup($trayB, $trayA);\n                }\n            }\n        }\n\n        //?§?????????°???????????????????¢???????\n        $cupMove++;\n    }\n\n    //??????????????????????§?????????°?????????\n    if ($crearFlag) {\n        echo $cupMove . \"\\n\";\n    }\n\n    //????????§???????????°-1?????????\n    else {\n        echo \"-1\" . \"\\n\";\n    }\n\n    //?????????\n    $trayA = array();\n    $trayB = array();\n    $trayC = array();\n    $nowMinCup = 1;\n    $crearFlag = false;\n    $cupMove = 0;\n\n    //?????????????????£????????????????????°????¢???????\n    $count++;\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n//???????????°??\\??????function\nfunction cupArrangement(&$tray) {\n    //??\\??????????????§??????\n    $stdin = trim(fgets(STDIN));\n    $stdin = explode(\" \", $stdin);\n\n    //???????????°?????????????????°????????????????????°???????????????\n    for ($i = 0; $i < $stdin[0]; $i++) {\n        $tray[$i] = $stdin[$i];\n    }\n}\n\n//??????????§???????function\nfunction moveCup(&$moveTray, &$destinationTray) {\n\n    $destinationTray[] = $moveTray[count($moveTray) - 1];\n    array_pop($moveTray);\n}\n\n//cupNum?????§??????????????????????????¨????????????function\nfunction seachTray($tray, $cupNum) {\n\n    for ($i = 0; $i < count($tray); $i++) {\n        if ($tray[$i] == $cupNum) {\n            //??¢??????????????????????????????????????????????????°????????????\n            return $i;\n        }\n    }\n\n    //????????????????????´??????-1?????????\n    return -1;\n}\n\n//????????????????????°???????????????\n$count = 0;\n\n//??????????????°n??¨?????§?§?????????°m\n$n;\n$m;\n\n//?????¬???A,B,C?????°????????????????????????\n$trayA = array();\n$trayB = array();\n$trayC = array();\n\n//?????¨??¢?´¢??????????????????????????????\n$nowMinCup = 1;\n\n\n\nwhile ($count < 5) {\n//n??¨m?????°????????\\?????????\n//??\\??????????????§??????\n    $stdin = trim(fgets(STDIN));\n    $stdin = explode(\" \", $stdin);\n\n//n?????\\??????????????´?????\\???\n    if (1 <= $stdin[0] && $stdin[0] <= 15) {\n        $n = $stdin[0];\n    }\n\n//m?????\\??????????????´?????\\???\n    if (1 <= $stdin[1] && $stdin[1] <= 15000000) {\n        $m = $stdin[1];\n    }\n\n//m,n???????????????0??????????????????\n    if ($n == 0 && $m == 0) {\n        break;\n    }\n\n//?????¬???????????£??????????????????????????±??\\???\n    cupArrangement($trayA);\n    cupArrangement($trayB);\n    cupArrangement($trayC);\n    \n//??¨???????????????????????¨??????????????????????????°\n$crearFlag = false;\n\n//?????????????§?????????°\n$cupMove = 0;\n\n//m????????§?????????????§?????????????\n    for ($i = 0; $i < $m; $i++) {\n\n        //?????¬???A???C????????°?????????????????????\n        if ($trayA == null && $trayB == null || $trayB == null && $trayC == null) {\n            $crearFlag=true;\n            break;\n        }\n\n        //?????¨??????????????????????????????????????¢?´¢\n        $Anum = seachTray($trayA, $nowMinCup);\n        $Bnum = seachTray($trayB, $nowMinCup);\n        $Cnum = seachTray($trayC, $nowMinCup);\n\n        //A??¨C?????????1????????????????????????????????????\n        //A????????¨????????????????????????????????????\n        if ($Anum) {\n\n            //A???1????????????????????????\n            if ($trayA[0] == 1) {\n                //??¢?´¢?????????????????????????????????\n                $nowMinCup++;\n            }\n\n            //C????????£????????????????????§??\\????????????\n            else {\n\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ($trayA[count($trayA) - 1] > $trayB[count($trayB) - 1]) {\n                    moveCup($trayA, $trayB);\n                }\n                //B?????§???????????????????????????B???C????§????\n                else {\n                    moveCup($trayB, $trayC);\n                }\n            }\n        }\n\n        //B????§????????????????????????????????????´???\n        else if ($Bnum) {\n            //A???1????????????????????????A????§????\n            if ($trayA[0] == 1) {\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ($trayA[count($trayA) - 1] > $trayB[count($trayB) - 1]) {\n                    moveCup($trayB, $trayA);\n                }\n            }\n\n            //C???1???????????????????????´???\n            else if ($trayC[0] == 1) {\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ($trayC[count($trayC) - 1] > $trayB[count($trayB) - 1]) {\n                    moveCup($trayB, $trayC);\n                }\n            }\n        }\n\n        //C????§????????????????????????????????????´???\n        else {\n            //C???1????????????????????????\n            if ($trayC[0] == 1) {\n                //??¢?´¢?????????????????????????????????\n                $nowMinCup++;\n            }\n\n            //A????????£????????????????????§??\\????????????\n            else {\n\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ($trayC[count($trayC) - 1] > $trayB[count($trayB) - 1]) {\n                    moveCup($trayC, $trayB);\n                }\n                //B?????§???????????????????????????B???A????§????\n                else {\n                    moveCup($trayB, $trayA);\n                }\n            }\n        }\n\n\n\n        //\n        //????????§???????????????????§?????????????\n        //A??¨B???????????????????????????\n        /* if ($trayA(count($trayA) - 1) > $trayB(count($trayB) - 1)) {\n          //?¬????C??¨????????????\n          //A???????????§????????´???\n          if ($trayA(count($trayA) - 1) > $trayC(count($trayC) - 1)) {\n          //B?????¨?????§?????????????§????\n          moveCup($trayA,$trayB);\n          }\n          //C???????????§????????´???\n          else{\n          //B?????¨?????§?????????????§????\n          moveCup($trayC,$trayB);\n          }\n          } else {\n          //?¬????C??¨????????????\n          if ($trayB(count($trayB) - 1) > $trayC(count($trayC) - 1)) {\n          //B???????????§????????´???\n          //A?????¨?§????\n          //C?????¨?§????\n          }\n          //C???????????§????????´???\n          else{\n          //B?????¨?????§?????????????§????\n          moveCup($trayC,$trayB);\n          }\n          }\n         * */\n\n        //?§?????????°???????????????????¢???????\n        $cupMove++;\n    }\n    //??????????????????????§?????????°?????????\n    if($crearFlag){\n        echo $cupMove.\"\\n\";\n    }\n    //????????§???????????°-1?????????\n    else{\n        echo \"-1\".\"\\n\";\n    }\n\n//?????????????????£????????????????????°????¢???????\n    $count++;\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n//???????????°??\\??????function\nfunction cupArrangement(&$tray) {\n\n    //??\\??????????????§??????\n    $stdin = trim(fgets(STDIN));\n    $stdin = explode(\" \", $stdin);\n\n    //???????????°???0????????????\n    if ($stdin[0] == 0) {\n        return;\n    }\n\n    //???????????°?????????????????°????????????????????°???????????????\n    for ($i = 0; $i < $stdin[0]; $i++) {\n        $tray[$i] = $stdin[$i + 1];\n    }\n}\n\n//??????????§???????function\nfunction moveCup(&$moveTray, &$destinationTray) {\n\n    $destinationTray[] = $moveTray[count($moveTray) - 1];\n    array_pop($moveTray);\n}\n\n//cupNum?????§??????????????????????????¨????????????function\nfunction seachTray($tray, $cupNum) {\n\n    for ($i = 0; $i < count($tray); $i++) {\n        if ((int) $tray[$i] == $cupNum) {\n            //??¢??????????????????????????????????????????????????°????????????\n            return $i;\n        }\n    }\n\n    //????????????????????´??????-1?????????\n    return -1;\n}\n\n//????????????????????°???????????????\n$count = 0;\n\n//??????????????°n??¨?????§?§?????????°m\n$n;\n$m;\n\n//?????¬???A,B,C?????°????????????????????????\n$trayA = array();\n$trayB = array();\n$trayC = array();\n\n//?????¨??¢?´¢??????????????????????????????\n$nowMinCup = 1;\n\nwhile ($count < 5) {\n\n    //n??¨m?????°????????\\?????????\n    //??\\??????????????§??????\n    $stdin = trim(fgets(STDIN));\n    $stdin = explode(\" \", $stdin);\n\n    //m,n???????????????0??????????????????\n    if ($stdin[0] == 0 && $stdin[1] == 0) {\n        break;\n    }\n    //n?????\\??????????????´?????\\???\n    if (1 <= $stdin[0] && $stdin[0] <= 15) {\n        $n = $stdin[0];\n    }\n\n    //m?????\\??????????????´?????\\???\n    if (1 <= $stdin[1] && $stdin[1] <= 15000000) {\n        $m = $stdin[1];\n    }\n\n    //?????¬???????????£??????????????????????????±??\\???\n    cupArrangement($trayA);\n    cupArrangement($trayB);\n    cupArrangement($trayC);\n\n    //??¨???????????????????????¨??????????????????????????°\n    $crearFlag = false;\n\n    //?????????????§?????????°\n    $cupMove = 0;\n\n    //m????????§?????????????§?????????????\n    for ($i = 0; $i < $m; $i++) {\n\n        var_dump($trayA);\n        var_dump($trayB);\n        var_dump($trayC);\n\n        //?????¬???A???C????????°?????????????????????\n        if (empty($trayA) && empty($trayB) || empty($trayB) && empty($trayC)) {\n            $crearFlag = true;\n            var_dump(\"clearFlagTrue\");\n            break;\n        }\n\n        //?????¨??????????????????????????????????????¢?´¢\n        $Anum = seachTray($trayA, $nowMinCup);\n        $Bnum = seachTray($trayB, $nowMinCup);\n        $Cnum = seachTray($trayC, $nowMinCup);\n\n        //A??¨C?????????1????????????????????????????????????\n        //A????????¨????????????????????????????????????\n        if ($Anum != -1) {\n\n            //A???1????????????????????????\n            if ((int) $trayA[0] == 1) {\n                //??¢?´¢?????????????????????????????????\n                $nowMinCup++;\n                var_dump($nowMinCup);\n            }\n\n            //C????????£????????????????????§??\\????????????\n            else {\n\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ((int) $trayA[count($trayA) - 1] > (int) $trayB[count($trayB) - 1]) {\n                    moveCup($trayA, $trayB);\n                    //?§?????????°???????????????????¢???????\n                    $cupMove++;\n                }\n\n                //B?????§???????????????????????????B???C????§????\n                else {\n                    if ((int) $trayB[count($trayB) - 1] > (int) $trayC[count($trayC) - 1]) {\n                        moveCup($trayB, $trayC);\n                        //?§?????????°???????????????????¢???????\n                        $cupMove++;\n                    }\n                }\n            }\n        }\n\n        //B????§????????????????????????????????????´???\n        else if ($Bnum != -1) {\n\n            //A???1????????????????????????A????§????\n            if ((int) $trayA[0] == 1) {\n\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ((int) $trayB[count($trayB) - 1] > (int) $trayA[count($trayA) - 1]) {\n                    //B???????????§???????????????????????????????????????????????´???\n                    if ((int) $trayB[count($trayB) - 1] == $nowMinCup) {\n                        moveCup($trayB, $trayA);\n                        //?§?????????°???????????????????¢???????\n                        $cupMove++;\n                    }\n                    //?????´??????????????????????????§????????????\n                    else {\n                        moveCup($trayB, $trayC);\n                        //?§?????????°???????????????????¢???????\n                        $cupMove++;\n                    }\n                }\n\n                //????????°?????????????????§????????´?????????B????§????\n                else {\n                    if ((int) $trayA[count($trayA) - 1] > (int) $trayB[count($trayB) - 1]) {\n                        moveCup($trayA, $trayB);\n                        //?§?????????°???????????????????¢???????\n                        $cupMove++;\n                    }\n                }\n            }\n\n            //C???1???????????????????????´???\n            else if ((int) $trayC[0] == 1) {\n\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ((int) $trayB[count($trayB) - 1] > (int) $trayC[count($trayC) - 1]) {\n                    //B???????????§???????????????????????????????????????????????´???\n                    if ((int) $trayB[count($trayB) - 1] == $nowMinCup) {\n                        moveCup($trayB, $trayC);\n                        //?§?????????°???????????????????¢???????\n                        $cupMove++;\n                    }\n                    //?????´??????????????????????????§????????????\n                    else {\n                        moveCup($trayB, $trayA);\n                        //?§?????????°???????????????????¢???????\n                        $cupMove++;\n                    }\n                }\n                //????????°?????????????????§????????´?????????B????§????\n                else {\n                    if ((int) $trayC[count($trayC) - 1] > (int) $trayB[count($trayB) - 1]) {\n                        moveCup($trayC, $trayB);\n                        //?§?????????°???????????????????¢???????\n                        $cupMove++;\n                    }\n                }\n            }\n        }\n\n        //C????§????????????????????????????????????´???\n        else {\n\n            //C???1????????????????????????\n            if ((int) $trayC[0] == 1) {\n                //??¢?´¢?????????????????????????????????\n                $nowMinCup++;\n            }\n\n            //A????????£????????????????????§??\\????????????\n            else {\n\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ((int) $trayC[count($trayC) - 1] > (int) $trayB[count($trayB) - 1]) {\n                    moveCup($trayC, $trayB);\n                    //?§?????????°???????????????????¢???????\n                    $cupMove++;\n                }\n\n                //B?????§???????????????????????????B???A????§????\n                else {\n\n                    if ((int) $trayB[count($trayB) - 1] > (int) $trayA[count($trayA) - 1]) {\n                        moveCup($trayB, $trayA);\n                        //?§?????????°???????????????????¢???????\n                        $cupMove++;\n                    }\n                }\n            }\n        }\n    }\n\n    //??????????????????????§?????????°?????????\n    if ($crearFlag) {\n        echo $cupMove . \"\\n\";\n    }\n\n    //????????§???????????°-1?????????\n    else {\n        echo \"-1\" . \"\\n\";\n    }\n\n    //?????????\n    $trayA = array();\n    $trayB = array();\n    $trayC = array();\n    $nowMinCup = 1;\n    $crearFlag = false;\n    $cupMove = 0;\n\n    //?????????????????£????????????????????°????¢???????\n    $count++;\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n//???????????°??\\??????function\nfunction cupArrangement(&$tray) {\n    //??\\??????????????§??????\n    $stdin = trim(fgets(STDIN));\n    $stdin = explode(\" \", $stdin);\n\n    //???????????°?????????????????°????????????????????°???????????????\n    for ($i = 0; $i < $stdin[0]; $i++) {\n        $tray[$i] = $stdin[$i];\n    }\n}\n\n//??????????§???????function\nfunction moveCup(&$moveTray, &$destinationTray) {\n\n    $destinationTray[] = $moveTray[count($moveTray) - 1];\n    array_pop($moveTray);\n}\n\n//cupNum?????§??????????????????????????¨????????????function\nfunction seachTray($tray, $cupNum) {\n\n    for ($i = 0; $i < count($tray); $i++) {\n        if ($tray[$i] == $cupNum) {\n            //??¢??????????????????????????????????????????????????°????????????\n            return $i;\n        }\n    }\n\n    //????????????????????´??????-1?????????\n    return -1;\n}\n\n//????????????????????°???????????????\n$count = 0;\n\n//??????????????°n??¨?????§?§?????????°m\n$n;\n$m;\n\n//?????¬???A,B,C?????°????????????????????????\n$trayA = array();\n$trayB = array();\n$trayC = array();\n\n//?????¨??¢?´¢??????????????????????????????\n$nowMinCup = 1;\n\n\n\nwhile ($count < 5) {\n//n??¨m?????°????????\\?????????\n//??\\??????????????§??????\n    $stdin = trim(fgets(STDIN));\n    $stdin = explode(\" \", $stdin);\n\n//n?????\\??????????????´?????\\???\n    if (1 <= $stdin[0] && $stdin[0] <= 15) {\n        $n = $stdin[0];\n    }\n\n//m?????\\??????????????´?????\\???\n    if (1 <= $stdin[1] && $stdin[1] <= 15000000) {\n        $m = $stdin[1];\n    }\n\n//m,n???????????????0??????????????????\n    if ($n == 0 && $m == 0) {\n        break;\n    }\n\n//?????¬???????????£??????????????????????????±??\\???\n    cupArrangement($trayA);\n    cupArrangement($trayB);\n    cupArrangement($trayC);\n    \n//??¨???????????????????????¨??????????????????????????°\n$crearFlag = false;\n\n//?????????????§?????????°\n$cupMove = 0;\n\n//m????????§?????????????§?????????????\n    for ($i = 0; $i < $m; $i++) {\n\n        //?????¬???A???C????????°?????????????????????\n        if ($trayA == null && $trayB == null || $trayB == null && $trayC == null) {\n            $crearFlag=true;\n            break;\n        }\n\n        //?????¨??????????????????????????????????????¢?´¢\n        $Anum = seachTray($trayA, $nowMinCup);\n        $Bnum = seachTray($trayB, $nowMinCup);\n        $Cnum = seachTray($trayC, $nowMinCup);\n\n        //A??¨C?????????1????????????????????????????????????\n        //A????????¨????????????????????????????????????\n        if ($Anum) {\n\n            //A???1????????????????????????\n            if ($trayA[0] == 1) {\n                //??¢?´¢?????????????????????????????????\n                $nowMinCup++;\n            }\n\n            //C????????£????????????????????§??\\????????????\n            else {\n\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ($trayA[count($trayA) - 1] > $trayB[count($trayB) - 1]) {\n                    moveCup($trayA, $trayB);\n                }\n                //B?????§???????????????????????????B???C????§????\n                else {\n                    moveCup($trayB, $trayC);\n                }\n            }\n        }\n\n        //B????§????????????????????????????????????´???\n        else if ($Bnum) {\n            //A???1????????????????????????A????§????\n            if ($trayA[0] == 1) {\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ($trayA[count($trayA) - 1] > $trayB[count($trayB) - 1]) {\n                    moveCup($trayB, $trayA);\n                }\n            }\n\n            //C???1???????????????????????´???\n            else if ($trayC[0] == 1) {\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ($trayC[count($trayC) - 1] > $trayB[count($trayB) - 1]) {\n                    moveCup($trayB, $trayC);\n                }\n            }\n        }\n\n        //C????§????????????????????????????????????´???\n        else {\n            //C???1????????????????????????\n            if ($trayC[0] == 1) {\n                //??¢?´¢?????????????????????????????????\n                $nowMinCup++;\n            }\n\n            //A????????£????????????????????§??\\????????????\n            else {\n\n                //B???????????§??????????????????????§???????????????????????????§????????´????§????\n                if ($trayC[count($trayC) - 1] > $trayB[count($trayB) - 1]) {\n                    moveCup($trayC, $trayB);\n                }\n                //B?????§???????????????????????????B???A????§????\n                else {\n                    moveCup($trayB, $trayA);\n                }\n            }\n        }\n\n\n\n        //\n        //????????§???????????????????§?????????????\n        //A??¨B???????????????????????????\n        /* if ($trayA(count($trayA) - 1) > $trayB(count($trayB) - 1)) {\n          //?¬????C??¨????????????\n          //A???????????§????????´???\n          if ($trayA(count($trayA) - 1) > $trayC(count($trayC) - 1)) {\n          //B?????¨?????§?????????????§????\n          moveCup($trayA,$trayB);\n          }\n          //C???????????§????????´???\n          else{\n          //B?????¨?????§?????????????§????\n          moveCup($trayC,$trayB);\n          }\n          } else {\n          //?¬????C??¨????????????\n          if ($trayB(count($trayB) - 1) > $trayC(count($trayC) - 1)) {\n          //B???????????§????????´???\n          //A?????¨?§????\n          //C?????¨?§????\n          }\n          //C???????????§????????´???\n          else{\n          //B?????¨?????§?????????????§????\n          moveCup($trayC,$trayB);\n          }\n          }\n         * */\n\n        //?§?????????°???????????????????¢???????\n        $cupMove++;\n    }\n    //??????????????????????§?????????°?????????\n    if($crearFlag){\n        echo $cupMove.\"\\n\";\n    }\n    //????????§???????????°-1?????????\n    else{\n        echo \"-1\".\"\\n\";\n    }\n\n//?????????????????£????????????????????°????¢???????\n    $count++;\n}"
  },
  {
    "language": "OCaml",
    "code": "type trays = Tray of int list * int list * int list\n\ntype move_command = AB | BA | BC | CB\n\nlet finished = function\n  | Tray (_, [], []) | Tray ([], [], _) -> true\n  | _ -> false\n\nlet move (Tray (as_, bs, cs)) command =\n  let move xs ys = match xs, ys with\n    | x :: xs, [] -> (xs, [x])\n    | x :: xs, y :: ys when x > y -> (xs, x :: y :: ys)\n    | _ -> invalid_arg \"move\" in\n  try\n    Some\n      begin\n        match command with\n        | AB -> let as_, bs = move as_ bs in Tray (as_, bs, cs)\n        | BA -> let bs, as_ = move bs as_ in Tray (as_, bs, cs)\n        | BC -> let bs, cs = move bs cs in Tray (as_, bs, cs)\n        | CB -> let cs, bs = move cs bs in Tray (as_, bs, cs)\n      end\n  with Invalid_argument _ -> None\n\nlet next_states state =\n  List.fold_left\n    (fun acc ->\n     function\n     | None -> acc\n     | Some s -> s :: acc)\n    []\n  @@ List.map (move state) [CB; BC; BA; AB]\n\nlet search initial_state max_swaps =\n  let states = Queue.create () in\n  Queue.push (initial_state, 0) states;\n  let seen = Hashtbl.create 1024 in\n  let rec search () =\n    if Queue.length states = 0 then -1\n    else\n      let state, count = Queue.pop states in\n      if finished state then count\n      else if count > max_swaps then -1\n      else if Hashtbl.mem seen state then search ()\n      else\n        begin\n          Hashtbl.add seen state true;\n          List.iter\n            (fun next_state -> Queue.push (next_state, succ count) states)\n            @@ List.filter\n                 (fun state -> not @@ Hashtbl.mem seen state)\n                 (next_states state);\n          search ()\n        end in\n  search ()\n\nlet read_lines n =\n  let rec read_lines n acc =\n    if n = 0 then List.rev acc\n    else read_lines (pred n) ((read_line ()) :: acc) in\n  read_lines n []\n\nlet split str delim =\n  let len = String.length str in\n  let rec split offset acc =\n    try\n      let index = String.index_from str offset delim in\n      split (index + 1) ((String.sub str offset (index - offset)) :: acc)\n    with Not_found -> List.rev ((String.sub str offset (len - offset)) :: acc) in\n  split 0 []\n\nlet rec solve () =\n  let read_tray () =\n    List.rev @@ List.tl @@ List.map int_of_string @@ split (read_line ()) ' ' in\n  let line = read_line () in\n  let n_cups, max_swaps = Scanf.sscanf line \"%d %d\" (fun n m -> (n, m)) in\n  if (n_cups, max_swaps) = (0, 0) then ()\n  else\n    let tray_a = read_tray () in\n    let tray_b = read_tray () in\n    let tray_c = read_tray () in\n    print_endline @@ string_of_int\n    @@ search (Tray (tray_a, tray_b, tray_c)) max_swaps;\n    solve ()\n\nlet () = solve ()"
  },
  {
    "language": "D",
    "code": "module main;\n\nimport std.array : array, empty, back;\nimport std.algorithm : map, filter, schwartzSort;\nimport std.conv : to, ConvException;\nimport std.range : zip, iota, dropOne;\nimport std.stdio : stdin, readln, writeln;\nimport std.string : split;\nimport std.typecons : Nullable, Tuple;\n\nauto input()\n{\n\treturn stdin.readln().split().map!(to!int);\n}\n\nstruct Problem\n{\n\talias int[] Tray;\n\talias Tray[3] Trays;\n\t\n\tint cup_count, swap_limit;\n\tTrays trays;\n\t\n\tpublic void solve()\n\t{\n\t\tauto result = dive(0, trays);\n\t\tdebug writeln(result);\n\t\twriteln(result.swap_count > swap_limit ? -1 : result.swap_count);\n\t}\n\t\n\talias Tuple!(int, \"swap_count\", Trays, \"trays\") Dive;\n\t\n\tprivate Dive dive(int swap_count, Trays trays)\n\t{\n\t\treturn dive(Dive(swap_count, trays));\n\t}\n\t\n\tprivate Dive dive(Dive state)\n\t{\n\t\tif (state.swap_count > swap_limit)\n\t\t{\n\t\t\treturn state;\n\t\t}\n\t\t\n\t\tconst lesser_and_max = top2(state.trays);\n\t\tconst lesser = lesser_and_max[0];\n\t\tconst max = lesser_and_max[1];\n\t\t\n\t\tassert(!max.isNull);\n\t\tassert(lesser.isNull || lesser != max);\n\t\t\n\t\tif (lesser.isNull)\n\t\t{\n\t\t\tif (max == TrayID.B)\n\t\t\t{\n\t\t\t\tDive m = move(max, TrayID.A, state.trays);\n\t\t\t\treturn Dive(state.swap_count + m.swap_count, m.trays);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn state;\n\t\t\t}\n\t\t}\n\t\t\n\t\tconst other = [TrayID.A, TrayID.B, TrayID.C].filter!(x => x != max && x != lesser).front;\n\t\t\n\t\tif (max == TrayID.B)\n\t\t{\n\t\t\tauto d1 = move(max, other, state.trays);\n\t\t\tauto d2 = move1(lesser, max, d1.trays);\n\t\t\tauto way1 = dive(state.swap_count + d1.swap_count + d2.swap_count, d2.trays);\n\t\t\t\n\t\t\tauto d3 = move(max, lesser, state.trays);\n\t\t\tauto way2 = dive(state.swap_count + d3.swap_count, d3.trays);\n\t\t\t\n\t\t\treturn way1.swap_count < way2.swap_count ? way1 : way2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto d1 = move1(lesser, other, state.trays);\n\t\t\tauto d2 = move(max, other, d1.trays);\n\t\t\tauto way1 = dive(state.swap_count + d1.swap_count + d2.swap_count, d2.trays);\n\t\t\t\n\t\t\tauto d3 = move(max, lesser, state.trays);\n\t\t\tauto way2 = dive(state.swap_count + d3.swap_count, d3.trays);\n\t\t\t\n\t\t\treturn way1.swap_count < way2.swap_count ? way1 : way2;\n\t\t}\n\t}\n\t\n\tenum TrayID { A, B, C };\n\talias Nullable!TrayID[2] Top2;\n\t\n\tprivate Top2 top2(Trays trays)\n\t{\n\t\tauto pairs = zip(trays[], [TrayID.A, TrayID.B, TrayID.C]);\n\t\tauto sorted = pairs.schwartzSort!(pair => pair[0].empty ? -1 : pair[0].back);\n\t\tauto indices = sorted.map!(pair => pair[0].empty ? Nullable!TrayID() : Nullable!TrayID(pair[1]));\n\t\treturn cast(Top2)indices.dropOne().array()[0..2];\n\t}\n\t\n\tprivate pure Dive move1(TrayID from, TrayID to, Trays trays)\n\t\tin\n\t{\n\t\tassert(from != to, \"source and destination must differ\");\n\t\tassert(!trays[from].empty);\n\t}\n\tbody\n\t{\n\t\tdebug writeln(\"move1 \", from, \",\", to, \", \", trays);\n\t\t\n\t\tTrays t = trays.dup;\n\t\tt[to] = trays[to] ~ t[from].back;\n\t\tt[from] = trays[from][0..$ - 1];\n\t\t\n\t\tconst steps = to == TrayID.B || from == TrayID.B ? 1 : 2;\n\t\t\n\t\treturn Dive(steps, t);\n\t}\n\t\n\tprivate pure Dive move(TrayID from, TrayID to, Trays trays)\n\t\tin\n\t{\n\t\tassert(from != to, \"source and destination must differ\");\n\t\tassert(!trays[from].empty);\n\t}\n\tbody\n\t{\n\t\tdebug writeln(\"move \", from, \",\", to, \", \", trays);\n\t\t\n\t\tif (trays[from].length == 1)\n\t\t{\n\t\t\treturn move1(from, to, trays);\n\t\t}\n\t\t\n\t\tuint i = trays[from].length - 1;\n\t\twhile (i > 0 && trays[from][i - 1] == trays[from][i] - 1)\n\t\t{\n\t\t\ti--;\n\t\t}\n\t\t\n\t\tTrays t = trays.dup;\n\t\tt[to] = t[to] ~ t[from][i..$];\n\t\tt[from] = t[from][0..i];\n\t\t\n\t\tconst steps = (3 ^^ (trays[from].length - i) - 1) / (to == TrayID.B || from == TrayID.B ? 2 : 1);\n\t\t\n\t\treturn Dive(steps, t);\n\t}\n\t\n\tpublic static Nullable!Problem read()\n\t{\n\t\ttry\n\t\t{\n\t\t\tauto a = input();\n\t\t\tif (a.length != 2 || a[0] == 0 && a[1] == 0)\n\t\t\t{\n\t\t\t\treturn Nullable!Problem();\n\t\t\t}\n\t\t\tint[][3] trays = iota(3).map!(_ => input().dropOne().array()).array();\n\t\t\treturn Nullable!Problem(Problem(a[0], a[1], trays));\n\t\t}\n\t\tcatch (ConvException)\n\t\t{\n\t\t\treturn Nullable!Problem();\n\t\t}\n\t}\n}\n\nvoid main(string[] args)\n{\n\tNullable!Problem problem;\n\twhile (!(problem = Problem.read()).isNull)\n\t{\n\t\tproblem.solve();\n\t}\n}"
  },
  {
    "language": "D",
    "code": "module main;\n\nimport std.array : array, empty, back;\nimport std.algorithm : map, filter, schwartzSort;\nimport std.conv : to, ConvException;\nimport std.range : zip, iota, drop;\nimport std.stdio : stdin, readln, writeln;\nimport std.string : split;\nimport std.typecons : Nullable, Tuple;\n\nauto input()\n{\n\treturn stdin.readln().split().map!(to!int);\n}\n\nstruct Problem\n{\n\talias int[] Tray;\n\talias Tray[3] Trays;\n\t\n\tint cup_count, swap_limit;\n\tTrays trays;\n\t\n\tpublic void solve()\n\t{\n\t\tauto result = dive(0, trays);\n\t\tdebug writeln(result);\n\t\twriteln(result.swap_count > swap_limit ? -1 : result.swap_count);\n\t}\n\t\n\talias Dive = Tuple!(int, \"swap_count\", Trays, \"trays\");\n\t\n\tprivate Dive dive(int swap_count, Trays trays)\n\t{\n\t\treturn dive(Dive(swap_count, trays));\n\t}\n\t\n\tprivate Dive dive(Dive state)\n\t{\n\t\tif (state.swap_count > swap_limit)\n\t\t{\n\t\t\treturn state;\n\t\t}\n\t\t\n\t\tconst lesser_and_max = top2(state.trays);\n\t\tconst lesser = lesser_and_max[0];\n\t\tconst max = lesser_and_max[1];\n\t\t\n\t\tassert(!max.isNull);\n\t\tassert(lesser.isNull || lesser != max);\n\t\t\n\t\tif (lesser.isNull)\n\t\t{\n\t\t\tif (max == TrayID.B)\n\t\t\t{\n\t\t\t\tDive m = move(max, TrayID.A, state.trays);\n\t\t\t\treturn Dive(state.swap_count + m.swap_count, m.trays);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn state;\n\t\t\t}\n\t\t}\n\t\t\n\t\tconst other = [TrayID.A, TrayID.B, TrayID.C].filter!(x => x != max && x != lesser).front;\n\t\t\n\t\tif (max == TrayID.B)\n\t\t{\n\t\t\tauto d1 = move(max, other, state.trays);\n\t\t\tauto d2 = move1(lesser, max, d1.trays);\n\t\t\tauto way1 = dive(state.swap_count + d1.swap_count + d2.swap_count, d2.trays);\n\t\t\t\n\t\t\tauto d3 = move(max, lesser, state.trays);\n\t\t\tauto way2 = dive(state.swap_count + d3.swap_count, d3.trays);\n\t\t\t\n\t\t\treturn way1.swap_count < way2.swap_count ? way1 : way2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto d1 = move1(lesser, other, state.trays);\n\t\t\tauto d2 = move(max, other, d1.trays);\n\t\t\tauto way1 = dive(state.swap_count + d1.swap_count + d2.swap_count, d2.trays);\n\t\t\t\n\t\t\tauto d3 = move(max, lesser, state.trays);\n\t\t\tauto way2 = dive(state.swap_count + d3.swap_count, d3.trays);\n\t\t\t\n\t\t\treturn way1.swap_count < way2.swap_count ? way1 : way2;\n\t\t}\n\t}\n\t\n\tenum TrayID { A, B, C };\n\talias Nullable!TrayID[2] Top2;\n\t\n\tprivate Top2 top2(Trays trays)\n\t{\n\t\tauto pairs = zip(trays[], [TrayID.A, TrayID.B, TrayID.C]);\n\t\tauto sorted = pairs.schwartzSort!(pair => pair[0].empty ? -1 : pair[0].back);\n\t\tauto indices = sorted.map!(pair => pair[0].empty ? Nullable!TrayID() : Nullable!TrayID(pair[1]));\n\t\treturn cast(Top2)indices.drop(1).array()[0..2];\n\t}\n\t\n\tprivate pure Dive move1(TrayID from, TrayID to, Trays trays)\n\t\tin\n\t{\n\t\tassert(from != to, \"source and destination must differ\");\n\t\tassert(!trays[from].empty);\n\t}\n\tbody\n\t{\n\t\tdebug writeln(\"move1 \", from, \",\", to, \", \", trays);\n\t\t\n\t\tTrays t = trays.dup;\n\t\tt[to] = trays[to] ~ t[from].back;\n\t\tt[from] = trays[from][0..$ - 1];\n\t\t\n\t\tconst steps = to == TrayID.B || from == TrayID.B ? 1 : 2;\n\t\t\n\t\treturn Dive(steps, t);\n\t}\n\t\n\tprivate pure Dive move(TrayID from, TrayID to, Trays trays)\n\t\tin\n\t{\n\t\tassert(from != to, \"source and destination must differ\");\n\t\tassert(!trays[from].empty);\n\t}\n\tbody\n\t{\n\t\tdebug writeln(\"move \", from, \",\", to, \", \", trays);\n\t\t\n\t\tif (trays[from].length == 1)\n\t\t{\n\t\t\treturn move1(from, to, trays);\n\t\t}\n\t\t\n\t\tuint i = trays[from].length - 1;\n\t\twhile (i > 0 && trays[from][i - 1] == trays[from][i] - 1)\n\t\t{\n\t\t\ti--;\n\t\t}\n\t\t\n\t\tTrays t = trays.dup;\n\t\tt[to] = t[to] ~ t[from][i..$];\n\t\tt[from] = t[from][0..i];\n\t\t\n\t\tconst steps = (3 ^^ (trays[from].length - i) - 1) / (to == TrayID.B || from == TrayID.B ? 2 : 1);\n\t\t\n\t\treturn Dive(steps, t);\n\t}\n\t\n\tpublic static Nullable!Problem read()\n\t{\n\t\ttry\n\t\t{\n\t\t\tauto a = input();\n\t\t\tif (a.length != 2 || a[0] == 0 && a[1] == 0)\n\t\t\t{\n\t\t\t\treturn Nullable!Problem();\n\t\t\t}\n\t\t\tint[][3] trays = iota(3).map!(_ => input().drop(1).array()).array();\n\t\t\treturn Nullable!Problem(Problem(a[0], a[1], trays));\n\t\t}\n\t\tcatch (ConvException)\n\t\t{\n\t\t\treturn Nullable!Problem();\n\t\t}\n\t}\n}\n\nvoid main(string[] args)\n{\n\tNullable!Problem problem;\n\twhile (!(problem = Problem.read()).isNull)\n\t{\n\t\tproblem.solve();\n\t}\n}"
  },
  {
    "language": "D",
    "code": "module main;\n\nimport std.array : array, empty, back;\nimport std.algorithm : map, filter, schwartzSort;\nimport std.conv : to, ConvException;\nimport std.range : zip, iota, dropOne;\nimport std.stdio : stdin, readln, writeln;\nimport std.string : split;\nimport std.typecons : Nullable, Tuple;\n\nauto input()\n{\n\treturn stdin.readln().split().map!(to!int);\n}\n\nstruct Problem\n{\n\talias Tray = int[];\n\talias Trays = Tray[3];\n\t\n\tint cup_count, swap_limit;\n\tTrays trays;\n\t\n\tpublic void solve()\n\t{\n\t\tauto result = dive(0, trays);\n\t\tdebug writeln(result);\n\t\twriteln(result.swap_count > swap_limit ? -1 : result.swap_count);\n\t}\n\t\n\talias Dive = Tuple!(int, \"swap_count\", Trays, \"trays\");\n\t\n\tprivate Dive dive(int swap_count, Trays trays)\n\t{\n\t\treturn dive(Dive(swap_count, trays));\n\t}\n\t\n\tprivate Dive dive(Dive state)\n\t{\n\t\tif (state.swap_count > swap_limit)\n\t\t{\n\t\t\treturn state;\n\t\t}\n\t\t\n\t\tconst lesser_and_max = top2(state.trays);\n\t\tconst lesser = lesser_and_max[0];\n\t\tconst max = lesser_and_max[1];\n\t\t\n\t\tassert(!max.isNull);\n\t\tassert(lesser.isNull || lesser != max);\n\t\t\n\t\tif (lesser.isNull)\n\t\t{\n\t\t\tif (max == TrayID.B)\n\t\t\t{\n\t\t\t\tDive m = move(max, TrayID.A, state.trays);\n\t\t\t\treturn Dive(state.swap_count + m.swap_count, m.trays);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn state;\n\t\t\t}\n\t\t}\n\t\t\n\t\tconst other = [TrayID.A, TrayID.B, TrayID.C].filter!(x => x != max && x != lesser).front;\n\t\t\n\t\tif (max == TrayID.B)\n\t\t{\n\t\t\tauto d1 = move(max, other, state.trays);\n\t\t\tauto d2 = move1(lesser, max, d1.trays);\n\t\t\tauto way1 = dive(state.swap_count + d1.swap_count + d2.swap_count, d2.trays);\n\t\t\t\n\t\t\tauto d3 = move(max, lesser, state.trays);\n\t\t\tauto way2 = dive(state.swap_count + d3.swap_count, d3.trays);\n\t\t\t\n\t\t\treturn way1.swap_count < way2.swap_count ? way1 : way2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto d1 = move1(lesser, other, state.trays);\n\t\t\tauto d2 = move(max, other, d1.trays);\n\t\t\tauto way1 = dive(state.swap_count + d1.swap_count + d2.swap_count, d2.trays);\n\t\t\t\n\t\t\tauto d3 = move(max, lesser, state.trays);\n\t\t\tauto way2 = dive(state.swap_count + d3.swap_count, d3.trays);\n\t\t\t\n\t\t\treturn way1.swap_count < way2.swap_count ? way1 : way2;\n\t\t}\n\t}\n\t\n\tenum TrayID { A, B, C };\n\talias Top2 = Nullable!TrayID[2];\n\t\n\tprivate Top2 top2(Trays trays)\n\t{\n\t\tauto pairs = zip(trays[], [TrayID.A, TrayID.B, TrayID.C]);\n\t\tauto sorted = pairs.schwartzSort!(pair => pair[0].empty ? -1 : pair[0].back);\n\t\tauto indices = sorted.map!(pair => pair[0].empty ? Nullable!TrayID() : Nullable!TrayID(pair[1]));\n\t\treturn cast(Top2)indices.dropOne().array()[0..2];\n\t}\n\t\n\tprivate pure Dive move1(TrayID from, TrayID to, Trays trays)\n\t\tin\n\t{\n\t\tassert(from != to, \"source and destination must differ\");\n\t\tassert(!trays[from].empty);\n\t}\n\tbody\n\t{\n\t\tdebug writeln(\"move1 \", from, \",\", to, \", \", trays);\n\t\t\n\t\tTrays t = trays.dup;\n\t\tt[to] = trays[to] ~ t[from].back;\n\t\tt[from] = trays[from][0..$ - 1];\n\t\t\n\t\tconst steps = to == TrayID.B || from == TrayID.B ? 1 : 2;\n\t\t\n\t\treturn Dive(steps, t);\n\t}\n\t\n\tprivate pure Dive move(TrayID from, TrayID to, Trays trays)\n\t\tin\n\t{\n\t\tassert(from != to, \"source and destination must differ\");\n\t\tassert(!trays[from].empty);\n\t}\n\tbody\n\t{\n\t\tdebug writeln(\"move \", from, \",\", to, \", \", trays);\n\t\t\n\t\tif (trays[from].length == 1)\n\t\t{\n\t\t\treturn move1(from, to, trays);\n\t\t}\n\t\t\n\t\tuint i = trays[from].length - 1;\n\t\twhile (i > 0 && trays[from][i - 1] == trays[from][i] - 1)\n\t\t{\n\t\t\ti--;\n\t\t}\n\t\t\n\t\tTrays t = trays.dup;\n\t\tt[to] = t[to] ~ t[from][i..$];\n\t\tt[from] = t[from][0..i];\n\t\t\n\t\tconst steps = (3 ^^ (trays[from].length - i) - 1) / (to == TrayID.B || from == TrayID.B ? 2 : 1);\n\t\t\n\t\treturn Dive(steps, t);\n\t}\n\t\n\tpublic static Nullable!Problem read()\n\t{\n\t\ttry\n\t\t{\n\t\t\tauto a = input();\n\t\t\tif (a.length != 2 || a[0] == 0 && a[1] == 0)\n\t\t\t{\n\t\t\t\treturn Nullable!Problem();\n\t\t\t}\n\t\t\tint[][3] trays = iota(3).map!(_ => input().dropOne().array()).array();\n\t\t\treturn Nullable!Problem(Problem(a[0], a[1], trays));\n\t\t}\n\t\tcatch (ConvException)\n\t\t{\n\t\t\treturn Nullable!Problem();\n\t\t}\n\t}\n}\n\nvoid main(string[] args)\n{\n\tNullable!Problem problem;\n\twhile (!(problem = Problem.read()).isNull)\n\t{\n\t\tproblem.solve();\n\t}\n}"
  },
  {
    "language": "D",
    "code": "module main;\n\nimport std.array : array, empty, back;\nimport std.algorithm : map, filter, schwartzSort;\nimport std.conv : to, ConvException;\nimport std.range : zip, iota, drop;\nimport std.stdio : stdin, readln, writeln;\nimport std.string : split;\nimport std.typecons : Nullable, Tuple;\n\nauto input()\n{\n\treturn stdin.readln().split().map!(to!int);\n}\n\nstruct Problem\n{\n\talias int[] Tray;\n\talias Tray[3] Trays;\n\t\n\tint cup_count, swap_limit;\n\tTrays trays;\n\t\n\tpublic void solve()\n\t{\n\t\tauto result = dive(0, trays);\n\t\tdebug writeln(result);\n\t\twriteln(result.swap_count > swap_limit ? -1 : result.swap_count);\n\t}\n\t\n\talias Tuple!(int, \"swap_count\", Trays, \"trays\") Dive;\n\t\n\tprivate Dive dive(int swap_count, Trays trays)\n\t{\n\t\treturn dive(Dive(swap_count, trays));\n\t}\n\t\n\tprivate Dive dive(Dive state)\n\t{\n\t\tif (state.swap_count > swap_limit)\n\t\t{\n\t\t\treturn state;\n\t\t}\n\t\t\n\t\tconst lesser_and_max = top2(state.trays);\n\t\tconst lesser = lesser_and_max[0];\n\t\tconst max = lesser_and_max[1];\n\t\t\n\t\tassert(!max.isNull);\n\t\tassert(lesser.isNull || lesser != max);\n\t\t\n\t\tif (lesser.isNull)\n\t\t{\n\t\t\tif (max == TrayID.B)\n\t\t\t{\n\t\t\t\tDive m = move(max, TrayID.A, state.trays);\n\t\t\t\treturn Dive(state.swap_count + m.swap_count, m.trays);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn state;\n\t\t\t}\n\t\t}\n\t\t\n\t\tconst other = [TrayID.A, TrayID.B, TrayID.C].filter!(x => x != max && x != lesser).front;\n\t\t\n\t\tif (max == TrayID.B)\n\t\t{\n\t\t\tauto d1 = move(max, other, state.trays);\n\t\t\tauto d2 = move1(lesser, max, d1.trays);\n\t\t\tauto way1 = dive(state.swap_count + d1.swap_count + d2.swap_count, d2.trays);\n\t\t\t\n\t\t\tauto d3 = move(max, lesser, state.trays);\n\t\t\tauto way2 = dive(state.swap_count + d3.swap_count, d3.trays);\n\t\t\t\n\t\t\treturn way1.swap_count < way2.swap_count ? way1 : way2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto d1 = move1(lesser, other, state.trays);\n\t\t\tauto d2 = move(max, other, d1.trays);\n\t\t\tauto way1 = dive(state.swap_count + d1.swap_count + d2.swap_count, d2.trays);\n\t\t\t\n\t\t\tauto d3 = move(max, lesser, state.trays);\n\t\t\tauto way2 = dive(state.swap_count + d3.swap_count, d3.trays);\n\t\t\t\n\t\t\treturn way1.swap_count < way2.swap_count ? way1 : way2;\n\t\t}\n\t}\n\t\n\tenum TrayID { A, B, C };\n\talias Nullable!TrayID[2] Top2;\n\t\n\tprivate Top2 top2(Trays trays)\n\t{\n\t\tauto pairs = zip(trays[], [TrayID.A, TrayID.B, TrayID.C]);\n\t\tauto sorted = pairs.schwartzSort!(pair => pair[0].empty ? -1 : pair[0].back);\n\t\tauto indices = sorted.map!(pair => pair[0].empty ? Nullable!TrayID() : Nullable!TrayID(pair[1]));\n\t\treturn cast(Top2)indices.drop(1).array()[0..2];\n\t}\n\t\n\tprivate pure Dive move1(TrayID from, TrayID to, Trays trays)\n\t\tin\n\t{\n\t\tassert(from != to, \"source and destination must differ\");\n\t\tassert(!trays[from].empty);\n\t}\n\tbody\n\t{\n\t\tdebug writeln(\"move1 \", from, \",\", to, \", \", trays);\n\t\t\n\t\tTrays t = trays.dup;\n\t\tt[to] = trays[to] ~ t[from].back;\n\t\tt[from] = trays[from][0..$ - 1];\n\t\t\n\t\tconst steps = to == TrayID.B || from == TrayID.B ? 1 : 2;\n\t\t\n\t\treturn Dive(steps, t);\n\t}\n\t\n\tprivate pure Dive move(TrayID from, TrayID to, Trays trays)\n\t\tin\n\t{\n\t\tassert(from != to, \"source and destination must differ\");\n\t\tassert(!trays[from].empty);\n\t}\n\tbody\n\t{\n\t\tdebug writeln(\"move \", from, \",\", to, \", \", trays);\n\t\t\n\t\tif (trays[from].length == 1)\n\t\t{\n\t\t\treturn move1(from, to, trays);\n\t\t}\n\t\t\n\t\tuint i = trays[from].length - 1;\n\t\twhile (i > 0 && trays[from][i - 1] == trays[from][i] - 1)\n\t\t{\n\t\t\ti--;\n\t\t}\n\t\t\n\t\tTrays t = trays.dup;\n\t\tt[to] = t[to] ~ t[from][i..$];\n\t\tt[from] = t[from][0..i];\n\t\t\n\t\tconst steps = (3 ^^ (trays[from].length - i) - 1) / (to == TrayID.B || from == TrayID.B ? 2 : 1);\n\t\t\n\t\treturn Dive(steps, t);\n\t}\n\t\n\tpublic static Nullable!Problem read()\n\t{\n\t\ttry\n\t\t{\n\t\t\tauto a = input();\n\t\t\tif (a.length != 2 || a[0] == 0 && a[1] == 0)\n\t\t\t{\n\t\t\t\treturn Nullable!Problem();\n\t\t\t}\n\t\t\tint[][3] trays = iota(3).map!(_ => input().drop(1).array()).array();\n\t\t\treturn Nullable!Problem(Problem(a[0], a[1], trays));\n\t\t}\n\t\tcatch (ConvException)\n\t\t{\n\t\t\treturn Nullable!Problem();\n\t\t}\n\t}\n}\n\nvoid main(string[] args)\n{\n\tNullable!Problem problem;\n\twhile (!(problem = Problem.read()).isNull)\n\t{\n\t\tproblem.solve();\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.conv, std.array, std.string, std.math, std.typecons, std.numeric;\n\nalias C = Tuple!(int, \"size\", int, \"p\");\n\nvoid solve(int N, int M)\n{\n    auto CS = new int[](N);\n    foreach (s; readln.split.to!(int[])[1..$]) CS[s-1] = 0;\n    foreach (s; readln.split.to!(int[])[1..$]) CS[s-1] = 1;\n    foreach (s; readln.split.to!(int[])[1..$]) CS[s-1] = 2;\n\n    int s, min_s, max_s = 3^^N-1;\n    foreach_reverse (c; CS) {\n        s *= 3;\n        s += c;\n    }\n    if (s == min_s || s == max_s) {\n        writeln(0);\n        return;\n    }\n    auto memo = new bool[](3^^N);\n    memo[s] = true;\n    auto ss = [s];\n    foreach (cnt; 1..M+1) {\n        int[] nss;\n        foreach (x; ss) {\n            int a = -1, b = -1, c = -1;\n            foreach (i; 0..N) {\n                CS[i] = x%3;\n                x /= 3;\n                switch (CS[i]) {\n                    case 0: a = i.to!int; break;\n                    case 1: b = i.to!int; break;\n                    default: c = i.to!int;\n                }\n            }\n            int add() {\n                int y;\n                foreach_reverse (x; CS) {\n                    y *= 3;\n                    y += x;\n                }\n                return y;\n            }\n            int r = -1;\n            if (a > b) {\n                CS[a] = 1;\n                r = add();\n                CS[a] = 0;\n            } else if (a < b) {\n                CS[b] = 0;\n                r = add();\n                CS[b] = 1;\n            }\n            if (r != -1 && !memo[r]) {\n                if (r == min_s || r == max_s) {\n                    writeln(cnt);\n                    return;\n                }\n                nss ~= r;\n                memo[r] = true;\n            }\n            r = -1;\n            if (b > c) {\n                CS[b] = 2;\n                r = add();\n                CS[b] = 1;\n            } else if (b < c) {\n                CS[c] = 1;\n                r = add();\n                CS[c] = 2;\n            }\n            if (r != -1 && !memo[r]) {\n                if (r == min_s || r == max_s) {\n                    writeln(cnt);\n                    return;\n                }\n                nss ~= r;\n                memo[r] = true;\n            }\n        }\n        ss = nss;\n    }\n    writeln(-1);\n}\n\nvoid main()\n{\n    for (;;) {\n        auto nm = readln.split.to!(int[]);\n        auto N = nm[0];\n        auto M = nm[1];\n        if (N == 0 && M == 0) break;\n        solve(N, M);\n    }\n}\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef search(x):\n    for a in A[1:]:\n        if x == a: return 'A'\n    for b in B[1:]:\n        if x == b: return 'B'\n    for c in C[1:]:\n        if x == c: return 'C'\n\nwhile 1:\n    n, m = map(int, input().split())\n    if n == m == 0:\n        break\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = list(map(int, input().split()))\n    s = ''\n    for i in range(1, n+1):\n        s += search(i) \n    d = {}\n    d[s] = 0\n    q = deque([s])\n    cnt = 0\n    while q:\n        s = q.popleft()\n        if d[s] > m:\n            continue\n        if s in ['A' * n, 'C' * n]:\n            print(d[s])\n            break\n        lastA, lastB, lastC = -1, -1, -1\n        for i in reversed(range(n)):\n            if s[i] == 'A' and lastA < 0:\n                lastA = i\n            if s[i] == 'B' and lastB < 0:\n                lastB = i\n            if s[i] == 'C' and lastC < 0:\n                lastC = i\n        if lastA > lastB:\n            news = s[:lastA] + 'B' + s[lastA+1:]\n            if news not in d:\n                d[news] = d[s] + 1\n                q.append(news)\n        if lastB > lastA:\n            news = s[:lastB] + 'A' + s[lastB+1:]\n            if news not in d:\n                d[news] = d[s] + 1\n                q.append(news)\n        if lastB > lastC:\n            news = s[:lastB] + 'C' + s[lastB+1:]\n            if news not in d:\n                d[news] = d[s] + 1\n                q.append(news)\n        if lastC > lastB:\n            news = s[:lastC] + 'B' + s[lastC+1:]\n            if news not in d:\n                d[news] = d[s] + 1\n                q.append(news)\n    else:\n        print(-1)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\ndef main():\n    while True:\n        n, m = [int(i) for i in input().split()]\n        if n == 0 and m == 0:\n            return\n        _, *a = [int(i) for i in input().split()]\n        _, *b = [int(i) for i in input().split()]\n        _, *c = [int(i) for i in input().split()]\n        a.insert(0, 0)\n        b.insert(0, 0)\n        c.insert(0, 0)\n\n        q = deque()\n        q.appendleft([a, b, c, 0, -1])\n        tmp = [i for i in range(0, n+1)]\n\n        while q:\n            # d はカウンタ\n            a, b, c, d, t = q.pop()\n            \"\"\"\n            print(a)\n            print(b)\n            print(c)\n            print('=======')\n            \"\"\"\n            # 終了\n            if d > m:\n                print(-1)\n                break\n            if a == tmp or c == tmp:\n                print(d)\n                break\n            # a から b\n            if a[-1] > b[-1] and t != 1:\n                q.appendleft([a[:-1], b+[a[-1]], c[:], d+1, 0])\n            # b から a\n            if b[-1] > a[-1] and t != 0:\n                q.appendleft([a+[b[-1]], b[:-1], c[:], d+1, 1])\n            # b から c\n            if b[-1] > c[-1] and t != 3:\n                q.appendleft([a[:], b[:-1], c+[b[-1]], d+1, 2])\n            # c から b\n            if c[-1] > b[-1] and t != 2:\n                q.appendleft([a[:], b+[c[-1]], c[:-1], d+1, 3])\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "def move(a,b):\n    aa = a[:]\n    bb = b[:]\n    bb.append(aa.pop(-1))\n    return aa,bb\n\ndef move_is_True(a,b):\n    if len(a) == 0:\n        return False\n    elif len(b) == 0 or a[-1]>b[-1]:\n        return True\n    return False\n\ndef search(abc_first, n):\n    counts = [10**10]\n    abcs = [(abc_first, abc_first, 0)]\n    while True:\n        if len(abcs) == 0 or min(counts) < sorted(abcs, key=lambda x:x[2])[0][2]:\n            break\n        new_abcs = []\n        for abc, last_abc, count in abcs:\n            abc_copy = abc[:]\n            #print(\"abc\", abc)\n            a = abc_copy[0]\n            b = abc_copy[1]\n            c = abc_copy[2]\n            if len(a) == n or len(c) == n:\n                counts.append(count)\n            else:\n                movements = [(a,b), (b,a), (c,b), (b,c)]\n                can_move = [move_is_True(a,b) for a,b in movements] #a2b, b2a, c2b, b2c\n                #print(\"can_move\", can_move)\n                for i in range(4):\n                    if can_move[i]:\n                        new_count = count+1\n                        x,y = movements[i]\n                        x,y = move(x,y)\n                        if i == 0:\n                            new_abc = [x,y,c]\n                        elif i == 1:\n                            new_abc = [y,x,c]\n                        elif i == 2:\n                            new_abc = [a,y,x]\n                        elif i == 3:\n                            new_abc = [a,x,y]\n                        #print(abc, new_abc, new_count, n)\n                        if new_abc != last_abc:\n                            if new_count < 15000000:\n                                new_abcs.append((new_abc, abc, new_count))\n            abcs = new_abcs[:]\n    return min(counts)\n\nn, m = map(int, input().split())\nwhile (m!=0 or n!=0):\n    abc = []\n    for i in range(3):\n        abc.append(list(map(int, input().split()))[1:])\n    ans = search(abc, n)\n    if ans <= m:\n        print(ans)\n    else:\n        print(-1)\n    n, m = map(int, input().split())\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nfrom collections import deque\n\n\ndef main():\n    while True:\n        N, M = map(int, readline().rstrip().split())\n        if N == M == 0:\n            break\n        _, *A = map(int, readline().rstrip().split())\n        _, *B = map(int, readline().rstrip().split())\n        _, *C = map(int, readline().rstrip().split())\n\n        A = [0] + A\n        B = [0] + B\n        C = [0] + C\n        N += 1\n\n        que = deque([(A, B, C, 0, -1)])   # pre: 1: A->B, 2: B->A, 3: B->C, 4: C->B\n        res = -1\n        while que:\n            A, B, C, t, pre = que.popleft()\n            if t > M:\n                break\n            if len(A) == N or len(C) == N:\n                res = t\n                break\n            \n            # A -> B\n            if A[-1] > B[-1] and pre != 2:\n                que.append((A[:-1], B + [A[-1]], C, t + 1, 1))\n\n            # B -> A\n            if B[-1] > A[-1] and pre != 1:\n                que.append((A + [B[-1]], B[:-1], C, t + 1, 2))\n            \n            # B -> C\n            if B[-1] > C[-1] and pre != 4:\n                que.append((A, B[:-1], C + [B[-1]], t + 1, 3))\n            \n            # C -> B\n            if C[-1] > B[-1] and pre != 3:\n                que.append((A, B + [C[-1]], C[:-1], t + 1, 4))\n            \n\n        print(res)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom math import log2\nans = []\nwhile True:\n    N, M = map(int, input().split())\n    if (N,M) == (0,0):\n        break\n    a,b,c = 0,0,0\n    for i in range(3):\n        A = list(map(int, input().split()))\n        if A[0]!=0:\n            if i==0:\n                for j in range(A[0]):\n                    a += 1<<(A[1+j]-1)\n            elif i==1:\n                for j in range(A[0]):\n                    b += 1<<(A[1+j]-1)\n            else:\n                for j in range(A[0]):\n                    c += 1<<(A[1+j]-1)\n\n    d = deque([(0,a,b,c,'')])\n\n    while len(d)>0:\n        cnt,a,b,c,prev = d.popleft()\n        if cnt>M:\n            ans.append(-1)\n            break\n        if a+b==0 or b+c==0:\n            ans.append(cnt)\n            break\n        if a==0:\n            amax = -1\n        else:\n            amax = int(log2(a))\n        if b==0:\n            bmax = -1\n        else:\n            bmax = int(log2(b))\n        if c==0:\n            cmax = -1\n        else:\n            cmax = int(log2(c))\n        if amax>bmax and prev!='ba':\n            d.append((cnt+1,a-(1<<amax),b+(1<<amax),c,'ab'))\n        elif amax<bmax and prev!='ab':\n            d.append((cnt+1,a+(1<<bmax),b-(1<<bmax),c,'ba'))\n        if cmax>bmax and prev!='bc':\n            d.append((cnt+1,a,b+(1<<cmax),c-(1<<cmax),'cb'))\n        elif cmax<bmax and prev!='cb':\n            d.append((cnt+1,a,b-(1<<bmax),c+(1<<bmax),'bc'))\nprint(*ans, sep='\\n')\n"
  },
  {
    "language": "Python",
    "code": "def biggest_cup(s,v):\n    try:\n        return s.index(v)\n    except ValueError:\n        return 127\n\ndef neighbors(s):\n    a = biggest_cup(s,0)\n    b = biggest_cup(s,1)\n    c = biggest_cup(s,2)\n    if b > a:\n        t = list(s)\n        t[a] = 1\n        yield tuple(t)\n    elif b < a:\n        t = list(s)\n        t[b] = 0\n        yield tuple(t)\n    if c > b:\n        t = list(s)\n        t[b] = 2\n        yield tuple(t)\n    elif c < b:\n        t = list(s)\n        t[c] = 1\n        yield tuple(t)\n\n\ndef solve_bfs(s0, m):\n    n = len(s0)\n    visited = {s0}\n    q = [s0]\n    for i in range(m+1):\n        nq = []\n        for s in q:\n            if all(v == 0 for v in s) or all(v == 2 for v in s):\n                return i\n            for t in neighbors(s):\n                if t not in visited:\n                    visited.add(t)\n                    nq.append(t)\n        q = nq\n    return -1\n\n\ndef solve_optimized(s0, m):\n    qq = []\n    q = [s0]\n    for i in range(m+1):\n        nq = []\n        for s in q:\n            if all(v == 0 for v in s) or all(v == 2 for v in s):\n                return i\n            for t in neighbors(s):\n                if t not in qq:\n                    nq.append(t)\n        qq,q = q,nq\n    return -1\n\nif __name__ == '__main__':\n    while True:\n        n,m = map(int,input().split())\n        if n == m == 0:\n            break\n        s = [None]*n\n        for i in map(int,input().split()[1:]):\n            s[-i] = 0\n        for i in map(int,input().split()[1:]):\n            s[-i] = 1\n        for i in map(int,input().split()[1:]):\n            s[-i] = 2\n        print(solve_optimized(tuple(s), m))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**8)\ndef dfs(A, B, C, x):\n    key = tuple(A+[0]+B+[0]+C)\n    if key in memo or M < x:\n        return\n    memo[key] = x\n    if A:\n        if not B or B[-1] < A[-1]:\n            B.append(A.pop())\n            dfs(A, B, C, x+1)\n            A.append(B.pop())\n    if B:\n        if not A or A[-1] < B[-1]:\n            A.append(B.pop())\n            dfs(A, B, C, x+1)\n            B.append(A.pop())\n        if not C or C[-1] < B[-1]:\n            C.append(B.pop())\n            dfs(A, B, C, x+1)\n            B.append(C.pop())\n    if C:\n        if not B or B[-1] < C[-1]:\n            B.append(C.pop())\n            dfs(A, B, C, x+1)\n            C.append(B.pop())\nINF = 10**18\nwhile 1:\n    N, M = map(int, input().split())\n    if not N:\n        break\n    _, *A = map(int, input().split())\n    _, *B = map(int, input().split())\n    _, *C = map(int, input().split())\n    memo = {}\n    dfs(A, B, C, 0)\n    *F, = range(1, N+1)\n    res = min(memo.get(tuple([0, 0] + F), INF), memo.get(tuple(F + [0, 0]), INF))\n    if res <= M:\n        print(res)\n    else:\n        print(-1)\n"
  },
  {
    "language": "Python",
    "code": "# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0503\n\ndef main():\n    from collections import deque\n    while True:\n        N, M = map(int, input().split())\n        if N == 0 and M == 0:\n            return\n        cop = [list(map(int, input().split())) for _ in range(3)]\n        cop = [cop[0][1:]] + [cop[1][1:]] + [cop[2][1:]] + [0] + [-1]\n        q = deque([cop])\n        cnt = 0\n        while q:\n            lst = q.popleft()\n            # a->b, b->a, b->c, c->bの4手が可能\n            a = lst[0][-1] if lst[0] else 0\n            b = lst[1][-1] if lst[1] else 0\n            c = lst[2][-1] if lst[2] else 0\n            a_cops = lst[0]\n            b_cops = lst[1]\n            c_cops = lst[2]\n            cnt = lst[3]\n            last = lst[4]\n            if (lst[1] + lst[2] == []) or (lst[0] + lst[1] == []):\n                print(cnt)\n                break\n            if cnt > M:\n                print(-1)\n                break\n            if a > b and last != 1:\n                nq = [a_cops[:-1]] + [b_cops + [a]] + [c_cops] + [cnt + 1] + [0]\n                q.append(nq)\n            if b > a and last != 0:\n                nq = [a_cops + [b]] + [b_cops[:-1]] + [c_cops] + [cnt + 1] + [1]\n                q.append(nq)\n            if b > c and last != 3:\n                nq = [a_cops] + [b_cops[:-1]] + [c_cops + [b]] + [cnt + 1] + [2]\n                q.append(nq)\n            if c > b and last != 2:\n                nq = [a_cops] + [b_cops + [c]] + [c_cops[:-1]] + [cnt + 1] + [3]\n                q.append(nq)\n\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom fractions import gcd\n\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nans = []\nwhile 1:\n\tn, m = MAP()\n\tif n == 0 and m == 0:\n\t\tbreak\n\tA = LIST()\n\tB = LIST()\n\tC = LIST()\n\n\tA = A[1:]\n\tB = B[1:]\n\tC = C[1:]\n\tgoal = defaultdict(int)\n\tfor i in A:\n\t\tgoal[n-i] = 0\n\tfor i in B:\n\t\tgoal[n-i] = 1\n\tfor i in C:\n\t\tgoal[n-i] = 2\n\t# print(goal)\n\tp = 0  # Aにすべての円盤あり\n\tx = 0\n\tfor i in range(n-1, -1, -1):\n\t\td = abs(p-goal[i])\n\t\tx += d*(3**i)\n\t\tif d == 1:\n\t\t\tp = 2-p\n\ttmp = min(x, 3**n-1-x)\n\tif tmp <= m:\n\t\tans.append(tmp)\n\telse:\n\t\tans.append(-1)\n\nfor i in ans:\n\tprint(i)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.buffer.readline\n\nfrom collections import deque\nimport copy\n\ndef myinput():\n    return map(int,readline().split())\n\ndef bfs(n,S_start):\n    q = deque()\n    q.append(S_start)\n    count = 0\n    while q:\n        S = q.popleft()\n        state = S[0]\n        a = S[0][0]\n        b = S[0][1]\n        c = S[0][2]\n        which = S[1]\n        if len(state[0])==(n+1):\n            return count \n        elif len(state[2])==(n+1):\n            return count\n        else:\n            if which:\n                if a[-1]>b[-1]:\n                    state[1].append(state[0].pop())\n                    count += 1\n                    nS = [state, not which ]\n                    q.append(nS)\n                else:\n                    state[0].append(state[1].pop())\n                    count += 1\n                    nS = [state, not which ]\n                    q.append(nS)\n            else:\n                if b[-1]>c[-1]:\n                    state[2].append(state[1].pop())\n                    count += 1\n                    nS = [state, not which ]\n                    q.append(nS)\n                else:\n                    state[1].append(state[2].pop())\n                    count += 1\n                    nS = [state, not which ]\n                    q.append(nS)\n    return float(\"inf\")\n            \nls_ans = []\nwhile True:\n    n,m = myinput()\n    if (n+m)==0:\n        break\n    state_start_1 = [ [0] + list(myinput())[1:] for _ in range(3) ]\n    state_start_2 = copy.deepcopy(state_start_1)\n    S1 = [state_start_1,True]\n    S2 = [state_start_2,False]\n    ans1 = bfs(n,S1)\n    ans2 = bfs(n,S2)\n    ans = min(ans1,ans2)\n    if ans<=m:\n        ls_ans.append(ans)\n    else:\n        ls_ans.append(-1)\n\nfor i in range(len(ls_ans)):\n    print(ls_ans[i])\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nans = []\nwhile True:\n    n, m = map(int, input().split())\n    if n == 0 and m == 0:\n        break\n\n    state = 0\n    for i in range(3):\n        _, *cups = map(int, input().split())\n        for cup in cups:\n            state += i * 3**(cup-1)\n    res = -1\n    d = [-1] * 3**n\n    que = deque([state])\n    d[state] = 0\n    while que:\n        state = que.popleft()\n        if state == 0 or state == 3**n - 1:\n            res = d[state]\n            break\n        if d[state] > m:\n            break\n\n        state_copy = state\n        tops = [-1] * 3\n        for cup in range(n):\n            tray = state_copy % 3\n            state_copy //= 3\n            tops[tray] = cup\n        dt = [[1], [-1, 1], [-1]]\n        for i, top in enumerate(tops):\n            if top != -1:\n                for di in dt[i]:\n                    if top > tops[i + di]:\n                        next_state = state + di * 3**top\n                        if d[next_state] == -1:\n                            d[next_state] = d[state] + 1\n                            que.append(next_state)\n    ans.append(res)\n\nfor a in ans:\n    print(a)\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n  try:\n    n,m = map(int,input().split())\n    l = [0 for i in range(n)]\n\n    for i in range(3):\n      s = list(map(int,input().split()))\n      for j in s[1:]:\n        l[j - 1] = i\n    ans = 100000000\n    for pos in [0,2]:\n      count = 0\n      for i in range(n):\n        if abs(l[i] - pos) == 2:\n          count += 2 * 3 ** (n - i - 1)\n        elif pos == 1 and l[i] == 0:\n          count += (3 ** (n - i - 1) - 1) // 2\n          pos = 2\n        elif pos == 1 and l[i] == 2:\n          count += (3 ** (n - i - 1) - 1) // 2\n          pos = 0\n        elif pos == 0 and l[i] == 1:\n          count += 3 ** (n - i - 1)\n          pos = 2\n        elif pos == 2 and l[i] == 1:\n          count += 3 ** (n - i - 1)\n          pos = 0\n      ans = min(count,ans)\n    if (ans <= m):\n      print(ans)\n    else:\n      print(-1)\n  except EOFError:\n    break\n"
  },
  {
    "language": "Python",
    "code": "import itertools\nR, C = map(int, raw_input().split())\na = []\nfor i in range(R):\n    a.append(map(int, raw_input().split()))\n\nans = 0\nfor pat in itertools.product((0, 1), repeat = R):\n    rev = [[c^p for c in row]\n            for (row, p) in zip(a, pat)]\n    cols = zip(*rev)\n    zeros = [c.count(0) for c in cols]\n    points = [max(z, R-z) for z in zeros]\n    ans = max(sum(points), ans)\nprint ans\n\n# def rev(row):\n#     return [1^v for v in row]\n# \n# def count(m):\n#     rm = zip(*m)\n#     return sum([max(rm[c].count(0), rm[c].count(1)) for c in range(C)])\n# \n# ans = 0\n# for i in range(1 << R):\n#     b = [a[r] if (i >> r) & 1 else rev(a[r]) for r in range(R)]\n#     ans = max(ans, count(b))\n# \n# print ans"
  },
  {
    "language": "Python",
    "code": "def dfs(A, B, C, x):\n    key = tuple(A+[0]+B+[0]+C)\n    if key in memo or M < x:\n        return\n    memo[key] = x\n    if A:\n        if not B or B[-1] < A[-1]:\n            B.append(A.pop())\n            dfs(A, B, C, x+1)\n            A.append(B.pop())\n    if B:\n        if not A or A[-1] < B[-1]:\n            A.append(B.pop())\n            dfs(A, B, C, x+1)\n            B.append(A.pop())\n        if not C or C[-1] < B[-1]:\n            C.append(B.pop())\n            dfs(A, B, C, x+1)\n            B.append(C.pop())\n    if C:\n        if not B or B[-1] < C[-1]:\n            B.append(C.pop())\n            dfs(A, B, C, x+1)\n            C.append(B.pop())\nINF = 10**18\nwhile 1:\n    N, M = map(int, input().split())\n    if not N:\n        break\n    _, *A = map(int, input().split())\n    _, *B = map(int, input().split())\n    _, *C = map(int, input().split())\n    memo = {}\n    dfs(A, B, C, 0)\n    *F, = range(1, N+1)\n    res = min(memo.get(tuple([0, 0] + F), INF), memo.get(tuple(F + [0, 0]), INF))\n    if res <= M:\n        print(res)\n    else:\n        print(-1)\n"
  },
  {
    "language": "Python",
    "code": "INF = 10 ** 20\n\nfull_move1_memo = [None] * 16\nfull_move2_memo = [None] * 16\n\ndef full_move1(n):\n  if n == 1:\n    return 2\n  if full_move1_memo[n]:\n    return full_move1_memo[n]\n  a = full_move1(n - 1) * 3 + 2\n  full_move1_memo[n] = a\n  return a\n\ndef full_move2(n):\n  if n == 1:\n    return 2\n  if full_move2_memo[n]:\n    return full_move2_memo[n]\n  a = full_move1(n - 1) * 2 + 2\n  full_move2_memo[n] = a\n  return a\n\ndef half_move(n):\n  if n == 1:\n    return 1\n  if full_move1_memo[n - 1]:\n    return full_move1_memo[n - 1] + 1\n  return full_move1(n - 1) + 1\n\ndef solve():\n  while True:\n    n, m = map(int, input().split())\n    if not n:\n      break\n\n    lst = [list(map(int,input().split()))[1:] for _ in range(3)]\n    inds = [-1 for i in range(n)]\n\n    for i in range(3):\n      for j in lst[i]:\n        inds[j - 1] = i\n    \n    ans = INF\n    for p in [0, 2]:\n      rec = 0\n      for i in range(n):\n        pi = inds[i]\n        if abs(pi - p) == 2:\n          rec += full_move2(n - i)\n        elif abs(pi - p) == 1:\n          rec += half_move(n - i)\n          p = (p + 2) % 4\n      if rec < ans:\n        ans = rec\n\n    if ans <= m:\n      print(ans)\n    else:\n      print(-1)\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 0503: Cup\n# Python3 2018.6.29 bal4u\n\np3, c = [1]*16, [0]*16\n\nfor i in range(1, 16): p3[i] = 3*p3[i-1]\nwhile True:\n\tn, m = map(int, input().split())\n\tif n == 0: break\n\tfor i in range(3):\n\t\ta = list(map(int, input().split()))\n\t\tfor j in range(a[0]): c[a[j+1]-1] = i\n\tans = k = 0;\n\tfor i in range(n):\n\t\tj = c[i]-k\n\t\tif j < 0: j = -j\n\t\tans += j*p3[n-i-1]\n\t\tif j == 1: k = 2-k\n\tk = p3[n]-ans-1\n\tif ans > k: ans = k\n\tprint(ans if ans <= m else -1)\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import deque\n\n\ndef l2t(g):\n    return tuple(map(tuple,g))\n\n\n\n\nclass BFS():\n    def __init__(self, graph, m, n):\n        # 盤面\n        self.graph = graph\n        self.m = m\n        self.n = n\n        # 始点からの距離\n        self.dist = {}\n        # キュー\n        self.que = deque()\n\n        self.eg_arr = [[[i for i in range(1,self.n+1)],[],[]],\n                       [[],[],[i for i in range(1,self.n+1)]]]\n\n    def list2num(self,g):\n        str_ = ''\n        for i in range(self.n):\n            if i+1 in g[0]:\n                str_ += '0'\n            elif i+1 in g[1]:\n                str_ += '1'\n            else:\n                str_ += '2'\n        return str_\n\n    def bfs(self):\n        self.graph = self.list2num(self.graph)\n        self.eg_arr[0] = self.list2num(self.eg_arr[0])\n        self.eg_arr[1] = self.list2num(self.eg_arr[1])\n\n        # 初期条件\n        self.dist[self.graph] = 0\n        self.que.append(self.graph)\n\n        if self.graph in self.eg_arr:\n            return 0\n\n        while self.que:\n            g = self.que.popleft()\n            if self.dist[g] > self.m: continue\n\n            ng_arr = []\n            ind0 = g.rfind('0')\n            ind1 = g.rfind('1')\n            ind2 = g.rfind('2')\n            if ind0 >= 0:\n                if (ind1 >= 0 and ind1<ind0) or ind1 < 0:\n                    ng = g[:ind0]+'1'+g[ind0+1:]\n                    ng_arr.append(ng)\n            if ind1 >= 0:\n                if (ind0 >= 0 and ind0<ind1) or ind0 < 0:\n                    ng = g[:ind1]+'0'+g[ind1+1:]\n                    ng_arr.append(ng)\n                if (ind2 >= 0 and ind2<ind1) or ind2 < 0:\n                    ng = g[:ind1]+'2'+g[ind1+1:]\n                    ng_arr.append(ng)\n            if ind2 >= 0:\n                if (ind1 >= 0 and ind1<ind2) or ind1 < 0:\n                    ng = g[:ind2]+'1'+g[ind2+1:]\n                    ng_arr.append(ng)\n\n            for ng in ng_arr:\n                if ng in self.dist.keys(): continue\n                self.dist[ng] = self.dist[g] + 1\n                self.que.append(ng)\n                if ng in self.eg_arr:\n                    return self.dist[ng]\n        else:\n            return -1\n\n\ndef main():\n    _in = [_.rstrip() for _ in stdin.readlines()]\n    io_cnt = 0\n    while True:\n        try:\n            n, m = list(map(int,_in[io_cnt].split(' ')))  # type:list(int)\n            graph = []\n            for i in range(3):\n                _ = list(map(int,_in[io_cnt+i+1].split(' ')))  # type:list(int)\n                if _[0] == 0:\n                    graph.append([])\n                else:\n                    graph.append(_[1:])\n            io_cnt += 4\n            # vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n            bfs = BFS(graph,m,n)\n            cnt = bfs.bfs()\n            # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            print(cnt)\n        except:\n            break\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef main():\n    while True:\n        n, m = [int(i) for i in input().split()]\n        if n == 0 and m == 0:\n            return\n        _, *a = [int(i) for i in input().split()]\n        _, *b = [int(i) for i in input().split()]\n        _, *c = [int(i) for i in input().split()]\n        a.insert(0, 0)\n        b.insert(0, 0)\n        c.insert(0, 0)\n\n        q = deque()\n        q.appendleft([a, b, c, 0, -1])\n        tmp = [i for i in range(0, n+1)]\n\n        while q:\n            a, b, c, d, t = q.pop()\n            if d > m:\n                print(-1)\n                break\n            if a == tmp or c == tmp:\n                print(d)\n                break\n\n            if a[-1] > b[-1] and t != 1 and t != 0:\n                q.appendleft([a[:-1], b+[a[-1]], c[:], d+1, 0])\n            if b[-1] > a[-1] and t != 0 and t != 1:\n                q.appendleft([a+[b[-1]], b[:-1], c[:], d+1, 1])\n            if b[-1] > c[-1] and t != 3 and t != 2:\n                q.appendleft([a[:], b[:-1], c+[b[-1]], d+1, 2])\n            if c[-1] > b[-1] and t != 2 and t != 3:\n                q.appendleft([a[:], b+[c[-1]], c[:-1], d+1, 3])\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0503\n\nfrom collections import deque\n\ndef main():\n    N, M = map(int, input().split()) # N: コップの数　M: 最大回数\n    if N==0:\n        exit()\n    data = [0]*N\n    map(int, input().split())\n    for b in list(map(int, input().split()))[1:]:\n        data[N-b]=1\n    for c in list(map(int, input().split()))[1:]:\n        data[N-c]=2\n\n    next_set = deque([(data[:],0)])\n    visit=set([tuple(data)])\n\n    while next_set:\n        q = next_set.popleft()\n        data, t = q\n        l = data[0]\n\n        # M 回より大きい回数かかる場合は-1\n        if t > M:\n            return -1\n\n        # 全てのコップがA(あるいはC)にいるとき、時刻を返す\n        for cnt, k in enumerate(data):\n            if k != l:\n                break\n            if cnt == N-1 and k != 1:\n                return t\n            l = k\n\n        pos = [N,N,N]\n        k = 0\n        for i, ABC in enumerate(data):\n            if pos[ABC] == N:\n                pos[ABC] = i\n                k += 1\n            if k == 3:\n                break\n\n        if pos[0] < pos[1]:\n            data[pos[0]] = 1\n            t_data = tuple(data)\n            if t_data not in visit:\n                next_set.append((data[:],t+1))\n                visit.add(t_data)\n            data[pos[0]] = 0\n        else:\n            data[pos[1]] = 0\n            t_data = tuple(data)\n            if t_data not in visit:\n                next_set.append((data[:],t+1))\n                visit.add(t_data)\n            data[pos[1]] = 1\n\n        if pos[1] < pos[2]:\n            data[pos[1]] = 2\n            t_data = tuple(data)\n            if t_data not in visit:\n                next_set.append((data[:],t+1))\n                visit.add(t_data)\n            data[pos[1]] = 1\n        else:\n            data[pos[2]] = 1\n            t_data = tuple(data)\n            if t_data not in visit:\n                next_set.append((data[:],t+1))\n                visit.add(t_data)\n            data[pos[2]] = 2\n\n\nwhile True:\n    print(main())\n\n\n\n\n\n\n'''\n\n3 10\n0\n1 1\n2 2 3\n\n'''\n"
  },
  {
    "language": "Python",
    "code": "import os\n\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\n\ndef solve(N, M, A, B, C, ab):\n    A = [0] + A\n    B = [0] + B\n    C = [0] + C\n    for i in range(M + 1):\n        if len(A) == N + 1 or len(C) == N + 1:\n            return i\n        if ab:\n            if A[-1] < B[-1]:\n                A.append(B.pop())\n            else:\n                B.append(A.pop())\n        else:\n            if C[-1] < B[-1]:\n                C.append(B.pop())\n            else:\n                B.append(C.pop())\n        ab = not ab\n    return IINF\n\n\nwhile True:\n    N, M = list(map(int, sys.stdin.readline().split()))\n    if N == M == 0:\n        break\n    _, *A = list(map(int, sys.stdin.readline().split()))\n    _, *B = list(map(int, sys.stdin.readline().split()))\n    _, *C = list(map(int, sys.stdin.readline().split()))\n\n    s1 = solve(N, M, A, B, C, True)\n    s2 = solve(N, M, A, B, C, False)\n    ans = min(s1, s2)\n    if ans <= M:\n        print(ans)\n    else:\n        print(-1)\n\n"
  },
  {
    "language": "Python",
    "code": "import collections\n\nwhile 1:\n    src_dsts = [(0, 1), (1, 0), (1, 2), (2, 1)]\n    n, m = map(int, raw_input().split())\n    if n == m == 0:\n        break\n    cupss = tuple([tuple(map(int, raw_input().split())[1:]) for i in range(3)])\n    dones = set()\n    q = collections.deque()\n    q.append((0, cupss))\n    while q:\n        s, cupss = q.popleft()\n        if s > m:\n            continue\n        if cupss in dones:\n            continue\n        dones.add(cupss)\n        if len(cupss[0]) == n or len(cupss[2]) == n:\n            print s\n            break\n        for src, dst in src_dsts:\n           if len(cupss[src]) > 0:\n                if len(cupss[dst]) == 0 or cupss[dst][-1] < cupss[src][-1]:\n                    next = list(cupss)\n                    next[dst] = cupss[dst] + (cupss[src][-1],)\n                    next[src] = cupss[src][:-1]\n                    q.append((s + 1, tuple(next)))\n    else:\n        print -1"
  },
  {
    "language": "Python",
    "code": "INF = 10 ** 20\n\nfull_move1_memo = [None] * 100\nfull_move2_memo = [None] * 100\ndef full_move1(n):\n  if n == 1:\n    return 2\n  if full_move1_memo[n]:\n    return full_move1_memo[n]\n  a = full_move1(n - 1) * 3 + 2\n  full_move1_memo[n] = a\n  return a\n\ndef full_move2(n):\n  if n == 1:\n    return 2\n  if full_move2_memo[n]:\n    return full_move2_memo[n]\n  a = full_move2(n - 1) * 2 + 2\n  full_move2_memo[n] = a\n  return a\n\ndef half_move(n):\n  if n == 1:\n    return 1\n  if full_move1_memo[n - 1]:\n    return full_move1_memo[n - 1] + 1\n  return  full_move1(n - 1) + 1\n\ndef solve():\n  while True:\n    n, m = map(int, input().split())\n    if not n:\n      break\n\n    lst = [list(map(int,input().split()))[1:] for _ in range(3)]\n    inds = [-1 for i in range(n)]\n\n    for i in range(3):\n      for j in lst[i]:\n        inds[j - 1] = i\n    \n    ans = INF\n    for pos in [0, 2]:\n      rec = 0\n      for i in range(n):\n        pi = inds[i]\n        if abs(pi - pos) == 2:\n          rec += full_move2(n - i)\n          pass\n        elif abs(pi - pos) == 1:\n          rec += half_move(n - i)\n          pos = (pos + 2) % 4\n      if rec < ans:\n        ans = rec\n\n    if ans <= m:\n      print(ans)\n    else:\n      print(-1)\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(100000)\n\ndef resolve():\n    def toC(A, B, C):\n        if not (A or B):\n            return 0\n        if C & 1:\n            return toC(A>>1, B>>1, C>>1) # Cにある一番小さいコップは考えない\n        if B & 1:\n            return (toC(C>>1, B>>1, A>>1) # 一度反対側にどかす\n            + toC((A|B|C)>>1, 0, 0) # 反対側からそいつらを持ってくる\n            + 1) # B -> C\n        if A & 1:\n            return (toC(A>>1, B>>1, C>>1) # まずすべてCにまとめる\n            + 2 * toC((A|B|C)>>1,0,0) # 端から端へ2回移動させる\n            + 2) # A -> B -> C\n\n    while True:\n        n, m = map(int, input().split())\n        cup = [0 for _ in range(3)]\n        if n == 0:\n            return\n        for i in range(3):\n            a = list(map(int, input().split()))\n            for s in a[1:]:\n                cup[i] |= 1 << s-1\n        a = min(toC(*cup), toC(*reversed(cup)))\n        print(a if a <= m else -1)\n\nif __name__ == \"__main__\":\n    resolve()\n    \n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\ndef main():\n    while True:\n        n, m = [int(i) for i in input().split()]\n        if n == 0 and m == 0:\n            return\n        _, *a = [int(i) for i in input().split()]\n        _, *b = [int(i) for i in input().split()]\n        _, *c = [int(i) for i in input().split()]\n        a.insert(0, 0)\n        b.insert(0, 0)\n        c.insert(0, 0)\n\n        q = deque()\n        q.appendleft([a, b, c, 0, -1])\n        tmp = [i for i in range(0, n+1)]\n\n        while q:\n            # d はカウンタ\n            a, b, c, d, t = q.pop()\n            \"\"\"\n            print(a)\n            print(b)\n            print(c)\n            print('=======')\n            \"\"\"\n            # 終了\n            if d > m:\n                print(-1)\n                break\n            if a == tmp or c == tmp:\n                print(d)\n                break\n            # a から b\n            if a[-1] > b[-1] and t != 1 and t != 0:\n                q.appendleft([a[:-1], b+[a[-1]], c[:], d+1, 0])\n            # b から a\n            if b[-1] > a[-1] and t != 0 and t != 1:\n                q.appendleft([a+[b[-1]], b[:-1], c[:], d+1, 1])\n            # b から c\n            if b[-1] > c[-1] and t != 3 and t != 2:\n                q.appendleft([a[:], b[:-1], c+[b[-1]], d+1, 2])\n            # c から b\n            if c[-1] > b[-1] and t != 2 and t != 3:\n                q.appendleft([a[:], b+[c[-1]], c[:-1], d+1, 3])\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    n, m = map(int, input().split())\n    if not n:\n        break\n\n    dest = [0] * n\n    for tray in range(3):\n        itr = map(int, input().split())\n        next(itr)\n        for i in itr:\n            dest[i - 1] = tray\n\n    cnt = 0\n    current_tray = 0\n    for i, tray in enumerate(dest):\n        move = abs(tray - current_tray)\n        if move == 1:\n            cnt += 3 ** (n - i - 1)\n            current_tray = abs(current_tray - 2)\n        elif move == 2:\n            cnt += 2 * 3 ** (n - i - 1)\n\n    ans = min(cnt, 3 ** n - cnt - 1)\n    print(ans if ans <= m else -1)"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from sys import stdin\n    f_i = stdin\n    \n    def rec(i):\n        if i == 0:\n            return 0\n        \n        tray = cups[n - i]\n        if tray == 'A':\n            return rec(i - 1)\n        elif tray == 'B':\n            return 2 * 3 ** (i - 1) - 1 - rec(i - 1)\n        else:\n            return rec(i - 1) + 2 * 3 ** (i - 1)\n    \n    while True:\n        n, m = map(int, f_i.readline().split())\n        if n == 0:\n            break\n        \n        cups = [None] * n\n        for tray in 'ABC':\n            itr = map(int, f_i.readline().split())\n            next(itr)\n            for i in itr:\n                cups[i-1] = tray\n        \n        num = rec(n)\n        ans = min(num, 3 ** n - 1 - num)\n        if ans <= m:\n            print(ans)\n        else:\n            print(-1)\n\nsolve()\n"
  },
  {
    "language": "Rust",
    "code": "use std::fmt;\nuse std::io::stdin;\nuse std::io::BufRead;\nuse std::str;\nuse std::str::FromStr;\nuse std::vec::Vec;\nuse std::collections::{VecDeque, HashSet};\n\nfn main() {\n    let stdin = stdin();\n    let mut scan = InputScanner::new(stdin.lock(),256);\n\n    let mut answer:Vec<i64> = Vec::new();\n\n    loop {\n        let n:usize = scan.next();\n        let m:usize = scan.next();\n\n        if n == 0 || m == 0 {\n            break;\n        }\n\n        let abc = {\n            let mut abc = Vec::new();\n\n            for _ in 0..3 {\n                let n: usize = scan.next();\n                abc.push((0..n).map(|_| scan.next::<usize>()).collect::<Vec<usize>>());\n            }\n            abc\n        };\n\n        let mut queue = VecDeque::new();\n        let mut s:HashSet<(u16,u16,u16)> = HashSet::new();\n\n        let (ha,hb,hc) = calc_hash(&abc[0],&abc[1],&abc[2]);\n\n        queue.push_back((ha,hb,hc));\n        s.insert((ha,hb,hc));\n\n        let mut count = 0;\n        let mut found = false;\n\n        'search: while queue.len() > 0 && count <= m {\n            let mut current = queue.drain(0..).collect::<VecDeque<_>>();\n\n            while let Some((ha,hb,hc)) = current.pop_front() {\n                let abc = abc_from_hash(ha,hb,hc);\n\n                if abc[0].len() == n || abc[2].len() == n {\n                    found = true;\n                    break 'search;\n                }\n\n                for &(i,d) in &[(0,1),(1,-1),(1,1),(2,-1)] {\n                    let i = i as i64;\n\n                    if abc[i as usize].len() > 0 {\n                        let top = abc[i as usize][abc[i as usize].len()-1];\n\n                        if abc[(i+d) as usize].len() == 0 || abc[(i+d) as usize][abc[(i+d) as usize].len()-1] < top {\n                            let mut abc = abc.iter().map(|c| c.clone()).collect::<Vec<Vec<usize>>>();\n\n                            abc[i as usize].pop();\n                            abc[(i+d) as usize].push(top);\n\n                            let h = calc_hash(&abc[0],&abc[1],&abc[2]);\n                            if !s.contains(&h) {\n                                s.insert(h);\n                                queue.push_back(h);\n                            }\n                        }\n                    }\n                }\n            }\n            count += 1;\n        }\n\n        if found {\n            answer.push(count as i64);\n        } else {\n            answer.push(-1);\n        }\n    }\n\n    println!(\"{}\",answer.into_iter().map(|a| format!(\"{}\",a)).collect::<Vec<String>>().join(\"\\n\"));\n}\nfn calc_hash(a:&Vec<usize>,b:&Vec<usize>,c:&Vec<usize>) -> (u16,u16,u16) {\n    let mut ha:u16 = 0;\n    let mut hb:u16 = 0;\n    let mut hc:u16 = 0;\n\n    for n in a {\n        ha |= 1 << *n;\n    }\n\n    for n in b {\n        hb |= 1 << *n;\n    }\n\n    for n in c {\n        hc |= 1 << *n;\n    }\n\n    (ha,hb,hc)\n}\nfn abc_from_hash(ha:u16,hb:u16,hc:u16) -> Vec<Vec<usize>> {\n    let mut abc:Vec<Vec<usize>> = Vec::new();\n    abc.push(Vec::new());\n\n    let mut ha = ha;\n\n    while ha > 0 {\n        abc[0].push(ha.trailing_zeros() as usize);\n        ha = ha & (ha - 1);\n    }\n\n    abc.push(Vec::new());\n\n    let mut hb = hb;\n\n    while hb > 0 {\n        abc[1].push(hb.trailing_zeros() as usize);\n        hb = hb & (hb - 1);\n    }\n\n    abc.push(Vec::new());\n\n    let mut hc = hc;\n\n    while hc > 0 {\n        abc[2].push(hc.trailing_zeros() as usize);\n        hc = hc & (hc - 1);\n    }\n\n    abc\n}\nstruct InputScanner<R: BufRead> {\n\treader: R,\n\tbuf: Vec<u8>, // Should never be empty\n\tpos: usize,   // Should never be out of bounds as long as the input ends with '\\n'\n}\nimpl<R: BufRead> InputScanner<R> {\n\tfn new(reader: R, capacity: usize) -> Self {\n\t\tInputScanner {\n\t\t\treader: reader,\n\t\t\tbuf: Vec::with_capacity(capacity),\n\t\t\tpos: 0,\n\t\t}\n\t}\n\n\t#[inline]\n\tfn next<T: FromStr>(&mut self) -> T\n\twhere\n\t\tT::Err: fmt::Debug,\n\t{\n\t\tif self.buf.is_empty() {\n\t\t\tself._read_next_line();\n\t\t}\n\t\tlet mut start = None;\n\t\tloop {\n\t\t\tmatch (self.buf[self.pos], start.is_some()) {\n\t\t\t\t(b' ', true) | (b'\\n', true) | (b'\\r', true) => break,\n\t\t\t\t(_, true) | (b' ', false) => self.pos += 1,\n\t\t\t\t(b'\\n', false) | (b'\\r', false) => self._read_next_line(),\n\t\t\t\t(_, false) => start = Some(self.pos),\n\t\t\t}\n\t\t}\n\t\tlet target = &self.buf[start.unwrap()..self.pos];\n\t\tunsafe { str::from_utf8_unchecked(target) }.parse().unwrap()\n\t}\n\n\t#[inline]\n\tfn _read_next_line(&mut self) {\n\t\tself.pos = 0;\n\t\tself.buf.clear();\n\t\tif self.reader.read_until(b'\\n', &mut self.buf).unwrap() == 0 {\n\t\t\tpanic!(\"Reached EOF\");\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n *  _           _                 __                            _   _ _   _                                 _                    _                  _\n * | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n * | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n * | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n * | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n * |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n *                                                  | |                                                                           | |   | |\n *                                                  |_|                                                                           |_|   |_|\n *\n * https://github.com/hatoo/competitive-rust-snippets\n */\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\nfn search((from, to): (usize, usize), m: usize, s: &[Vec<usize>; 3]) -> Option<usize> {\n    let mut s = s.clone();\n    {\n        let x = s[from].pop().unwrap();\n        s[to].push(x);\n    }\n    let mut last = (from, to);\n\n    'outer: for i in 1..m + 1 {\n        if (s[0].is_empty() && s[1].is_empty()) || (s[1].is_empty() && s[2].is_empty()) {\n            return Some(i);\n        }\n\n        for &(f, t) in &[(0, 1), (1, 2), (1, 0), (2, 1)] {\n            if last != (t, f) && !s[f].is_empty()\n                && s[t].last()\n                    .map(|x| x < s[f].last().unwrap())\n                    .unwrap_or(true)\n            {\n                let x = s[f].pop().unwrap();\n                s[t].push(x);\n                last = (f, t);\n                continue 'outer;\n            }\n        }\n    }\n    None\n}\n\n#[allow(dead_code)]\nfn main() {\n    loop {\n        let (n, m) = get!(usize, usize);\n\n        if n == 0 && m == 0 {\n            return;\n        }\n\n        let mut s1 = util::gets::<usize>();\n        s1.remove(0);\n        let mut s2 = util::gets::<usize>();\n        s2.remove(0);\n        let mut s3 = util::gets::<usize>();\n        s3.remove(0);\n\n        if s1.len() == n || s3.len() == n {\n            println!(\"{}\", 0);\n            continue;\n        }\n        let s = [s1, s2, s3];\n\n        let mut ans = None;\n\n        for &(f, t) in &[(0, 1), (1, 2), (1, 0), (2, 1)] {\n            if !s[f].is_empty()\n                && s[t].last()\n                    .map(|x| x < s[f].last().unwrap())\n                    .unwrap_or(true)\n            {\n                if let Some(x) = search((f, t), m, &s) {\n                    ans = Some(ans.map(|y| min(x, y)).unwrap_or(x));\n                }\n            }\n        }\n\n        if let Some(x) = ans {\n            println!(\"{}\", x);\n        } else {\n            println!(\"{}\", -1);\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n *  _           _                 __                            _   _ _   _                                 _                    _                  _\n * | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n * | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n * | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n * | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n * |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n *                                                  | |                                                                           | |   | |\n *                                                  |_|                                                                           |_|   |_|\n *\n * https://github.com/hatoo/competitive-rust-snippets\n */\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\nfn search((from, to): (usize, usize), m: usize, s: &[Vec<usize>; 3]) -> Option<usize> {\n    let mut s = s.to_vec();\n\n    let x = s[from].pop().unwrap();\n    s[to].push(x);\n    let mut last = (from, to);\n\n    'outer: for i in 1..m + 1 {\n        if (s[0].is_empty() && s[1].is_empty()) || (s[1].is_empty() && s[2].is_empty()) {\n            return Some(i);\n        }\n\n        for &(f, t) in &[(0, 1), (1, 2), (1, 0), (2, 1)] {\n            if last != (t, f) && !s[f].is_empty()\n                && s[t].last()\n                    .map(|x| x < s[f].last().unwrap())\n                    .unwrap_or(true)\n            {\n                let x = s[f].pop().unwrap();\n                s[t].push(x);\n                last = (f, t);\n                continue 'outer;\n            }\n        }\n    }\n    None\n}\n\n#[allow(dead_code)]\nfn main() {\n    loop {\n        let (n, m) = get!(usize, usize);\n\n        if n == 0 && m == 0 {\n            return;\n        }\n\n        let mut s1 = util::gets::<usize>();\n        s1.remove(0);\n        let mut s2 = util::gets::<usize>();\n        s2.remove(0);\n        let mut s3 = util::gets::<usize>();\n        s3.remove(0);\n\n        if s1.len() == n || s3.len() == n {\n            println!(\"{}\", 0);\n            continue;\n        }\n        let s = [s1, s2, s3];\n\n        let mut ans = None;\n\n        for &(f, t) in &[(0, 1), (1, 2), (1, 0), (2, 1)] {\n            if !s[f].is_empty()\n                && s[t].last()\n                    .map(|x| x < s[f].last().unwrap())\n                    .unwrap_or(true)\n            {\n                if let Some(x) = search((f, t), m, &s) {\n                    ans = Some(ans.map(|y| min(x, y)).unwrap_or(x));\n                }\n            }\n        }\n\n        if let Some(x) = ans {\n            println!(\"{}\", x);\n        } else {\n            println!(\"{}\", -1);\n        }\n    }\n}\n\n"
  }
]